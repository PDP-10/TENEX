;<SOURCES>SA10F.MAC	  9/13/77 17:00		EDIT BY RINDFLEISCH
; Added paged memory test for KI-10
;<SOURCES>SA10F.MAC	  9/6/77 17:00		EDIT BY RINDFLEISCH
; Added human engineering to drive formatting functions and to pack
; copying.  Also added ECC error correction to copy.
;<SOURCES>SA10F.MAC	  9/2/77 14:20		EDIT BY RINDFLEISCH
; Added CPY code from CLEMENTS/ISI SA10D.MAC
;<OPERATOR>SA10E.MAC;2    24-AUG-77 21:59:57    EDIT BY OPERATOR

TITLE SA10 - DIAGNOSTIC FOR SYSTEMS CONCEPTS SA-10 IBM-TO-DEC SUBSYSTEM ADAPTER

KIFLG==1	; Running on KI-10 processor - use paging
FTKL10==0	;IF ON KL10 PROC
NCHN==2		;# OF CHANNELS ON THIS SA-10
BASE==160	;START OF STATUS BLOCK
DCHAN==0	;CHANNEL FOR DISK CONTROLLER
IDEV==300	;ADDRESS OF DISK CONTROLLER (C0)
NPACKS==4	;# OF DRIVES ON DISK CONTROLLER
NCYL==^D815	;NUMBER OF CYLINDERS PER PACK
NUCYL==^D808	;NUMBER OF CYLINDERS AVAILABLE TO USER
NSCYL==^D808+1	;NUMBER OF SYSTEM CYLINDERS (808 plus 1
		; cylinder of spare tracks)
NSURF==^D19	;NUMBER OF SURFACES
RECL==1000	;# OF DATA WORDS PER RECORD
NRPT==^D5	;NUMBER OF ABOVE RECORDS THAT FIT ON A TRACK
TCHAN==1	;CHANNEL FOR TAPE CONTROLLER
TUNIT==340	;ADDRESS OF TAPE CONTROLLER (E0)
NTAPES==2	; Number of tape drives on line
PCHAN==1	;CHANNEL FOR PRINTER CONTROLLER
SA0==274	;DEVICE NUMBER OF SA-10
CNOB==1

PSTART=4000	; Program starting address

Z=0		; AC definitions
A=1
B=2
C=3
D=4
E=5
F=6
G=7
H=10
I=11
J=12
K=13
L=14
DD=15
BF=16		; BUSY FLAGS, FOR LIGHT WATCHERS. B0-7 MEAN DRIVE
		;  0-7 WAITING FOR DEVICE END. RH IS MOST RECENT INT DV
P=17		; PUSHDOWN POINTER

IFNDEF CNOB,<
CNOB==0>
IFNDEF CV,<
CV==1>		; 0 FOR B, 1 FOR C (HARDWARE POINTER LAYOUTS)
IFLE CV,<
CNTSFT==2>	;SHIFT IN LH FOR COUNT
IFG CV,<
CNTSFT==6>	; ..
IFNDEF EADR,<
EADR==1>	;22 BIT ADDRESS FEATURE
APRCH==2	;PI CH FOR TIME, PAR ERR, AND NXM
SA0CH==1	;PI CHANNEL IN DISK ROUTINE
NBF==20		; # OF BYTES IN RING BUFFER (FIFO) IN EACH CHANNEL
NRETRY==^D8	; TIMES TO REREAD A CORRECTABLE DATA CHECK
NBADSP==100	; NUMBER OF BADSPOTS TO REMEMBER
IFL CV,<
CNOB==1>

;MACROS FOR WORD POINTERS DEPENDING ON WHICH KIND OF SA10 (B OR C)

IFE CV,<
	DEFINE IOW(CT,ADR)
	<-CT*4,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*4,,ADR>>
IFN CV,<
	DEFINE IOW(CT,ADR)
	<-CT*100,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*100,,ADR>>

DEFINE	CW(BYTS)<
	BYTE (8) BYTS
	>

OPDEF	TIC [1B1]	; Transfer in Channel

;BITS FOR CONO
RSTSA==400000	;RESET WHOLE SCHMEER, START CLOCK
CLMERR==200000	;CLEAR MEMORY ERROR FLAGS
SASTEP==1000	;STOP CLOCK IF RUNNING; STEP IT IF STOPPED
SACGO==1040	;START CLOCK
RSTCH==300	;RESET CHANNEL SPECIFIED BY 10 AND 20 BITS
CLBSY==400	;CLEAR BUSY FLAG OF CHANNEL . . .
STBSY==440	;SET BUSY FLAG OF CHANNEL . . .
CLSRQ==500	;CLEAR STATUS REQUEST FLAG OF CHANNEL . . .
STSRQ==540	;SET STATUS REQUEST FLAG OF CHANNEL . . .
CLSTF==600	;CLEAR STATUS FLAG OF CHANNEL . . .
STSTF==640	;SET STATUS FLAG OF CHANNEL . . .
CLPIE==700	;CLEAR PI ENABLE OF CHANNEL . . .
STPIE==740	;SET PI ENABLE OF CHANNEL . . .

;CERTAIN OF ABOVE BITS ALSO SELECT WHAT DIAGNOSTIC WORD WILL
;BE READ BY THE NEXT DATAI TO BE EXECUTED, AS FOLLOWS:

RDCCI==0	;READ CHANNEL SELECTED (BITS 16, 17); CON-
		;TENTS OF CBUS (BITS 18-25); MICRO-PROGRAM
		;COUNTER (BITS 26-35)
RDMA==10	;READ MEMORY ADDRESS REGISTER (BITS 16-35)
RDMBL==20	;READ CHANNEL REFERENCING MEMORY (BITS 16,
		;17); LEFT HALF OF MEMORY BUFFER (BITS 18-
		;35).  THIS M.B. IS ONLY FOR DATA GOING
		;TOWARDS THE MEMORY.
RDMBR==30	;READ PARITY BIT OF MEMORY BUFFER (BIT 17);
		;RIGHT HALF OF MEMORY BUFFER (BITS 18-35)
RDCONI==40	;READ THE "CLOCK RUNNING" BIT (BIT 16); THE
		;"MEMORY SUBROUTINE BUSY" BIT (BIT 17); AND
		;THE SAME DATA SENSED BY CONI (BITS 18-35)
;CONTINUED ON NEXT PAGE


RDBITS==50	;READ SOME MISCELLANEOUS BITS:
		;BITS 16 AND 17 SPECIFY WHICH CHANNEL IS
		;USING THE MEMORY
	WRRQ==400000	;CURRENT MEM CYCLE IS A WRITE
	MUXACK==200000	;ACKNOWLEDGE FROM MEMORY PORT
	MEMACK==100000	;ACKNOWLEDGE FROM MEMORY
	MBUSDN==40000	;MEMORY BUS FINISHED
	MDNSYN==20000	;MEMORY DONE SYNC
	RDDIAG==10000
	IOFWR==4000
	CHRST==2000
	RESET==1000
	BRANCH==400	;THE MICRO-INSTRUCTION WHICH IS
			;ABOUT TO BE EXECUTED IS GOING TO BRANCH
;LOW 3 BITS ARE PI CHANNEL ASSIGNMENT

;BITS FOR CONI, CONSZ, CONSO
PIRQ==400000	;THIS SA-10 IS REQUESTING AN INTERRUPT
PARERR==200000	;PARITY ERROR IN SOME WORD (COMMAND OR
		;DATA) READ FROM MEMORY
NXM==100000	;SA-10 TRIED TO REFERENCE NON-EX MEMORY
PIE0==40000	;PI ENABLE FLAG FOR CHANNEL 0
PIE1==20000	; . . . CHANNEL 1
PIE2==10000	; . . . CHANNEL 2
PIE3==4000	; . . . CHANNEL 3
BSY0==2000	;BUSY FLAG FOR CHANNEL 0
BSY1==1000	; . . . CHANNEL 1
BSY2==400	; . . . CHANNEL 2
BSY3==200	; . . . CHANNEL 3
STF0==100	;STATUS FLAG FOR CHANNEL 0
STF1==40	; . . . CHANNEL 1
STF2==20	; . . . CHANNEL 2
STF3==10	; . . . CHANNEL 3
;LOW 3 BITS ARE PI CHANNEL ASSIGNMENT

HANGPC==64	;MAGIC PLACE TO STICK MICRO-PROGRAM COUNTER
		; THIS IS A MICRO-CODE PC. NOT A PDP-10 ADDRESS

;DEFS FOR TAPE
TRECL==2000	; RECORD LENGTH ON TAPE
TUNIT==340

DSW==0
IFN FTKL10,<
;DTE20 PARAMS

DTEFLG=444	;DONE FLG
DTEF11=450	;ARG FROM 11
DTECMD=451	;COMMAND LOC
DTEMTD=455	;TYO DONE
DTEMTI=456	;TYI READY

DTE==200	;DEVICE CODE

.DTMTO==10B27	;TYO CMD
.DTMMC==11B27	;MON MODE ON
.DTMNM==12B27	;MON MODE OFF

TO11DB==1B22	;DOORBELL TO 11
CL11PT==1B26	;CLEAR DOORBELL FOR 10
PILDEN==1B31	;ENABLE LOAD PIA
DTE11=142	;INT ADR
DTEEPW=144	;EXAMINE PROT WORD

>

DEFINE LOOP(N,LOC)
<	DATAI DSW,A
	HLRZS A
	CAIN A,N
	JRST LOC
>

DEFINE SLOOP
<	DATAI DSW,A
	TRNE A,4
	JRST DDT
>
DEFINE MCONO(DEV,DAT)
<	MOVEI DD,DAT
	XCT DCONO
>

DEFINE MCONSZ(DEV,DAT)
<	XCT DCONI
	TRNE DD,DAT
>
DEFINE MCONSO(DEV,DAT)
<	XCT DCONI
	TRNN DD,DAT
>
DEFINE MDATAO(DEV,DAT)
<	MOVE DD,DAT
	XCT DDATAO
>

DEFINE MDATAI(DEV,DAT)
<	XCT DDATAI
	MOVEM DD,DAT
>

DEFINE MCONI(DEV,DAT)
<	XCT DCONI
	MOVEM DD,DAT
>

; Pager controls for KI-10

IFN KIFLG,<

DEFINE	PGRON <
	DATAO PAG,KIEPTW
	>

DEFINE	PGROFF <
	DATAO PAG,[400000]
	>

	>	; End IFN KIFLG

;SOME 3330 COMMANDS
NOOP==3		; No Op
SEEK==7		; Seek
SEEKHD==33	; Seek Head
SCHIDE==61	; Search ID Equal
RDDATA==6	; Read Data
WRDATA==5	; Write Data
RDHA==32	; Read Home Address
MULTRK==200	; Multi-track option for Search and Read commands
RELOC PSTART-140

GOGO:	JRST DDTE
DDTG:	MOVE A,116
	MOVEM A,36
	AOBJN A,.
	ADDI A,100	;PATCH SPACE
	HRRZM A,ADRLO	;BOTTOM OF FREE STORAGE
	HRRZM A,PADRLO	;BOTTOM OF FREE STORAGE
	HRRZM A,LOWBD	; Lower bound for memory test
	MOVE A,117
	MOVEM A,32
	JRST DDT

DDTE:	SETZM QUIET	; Clear quiet flag
IFN KIFLG,<
	PGROFF		; Turn off pager
	>	; End IFN KIFLG
	SKIPN SUPER0
	JRST DDT
	MOVE A,SUPER0
	MOVEM A,36
	MOVE A,SUPER1
	MOVEM A,32
	SETZM SUPER0
	JRST DDT

BEG:	MOVEI P,PDL-1
BEG0:	PUSHJ P,STATIC
	AOS STATCT
	JRST BEG0

STATIC:	CONO 635550	;CLEAR OUT THE WORLD
	CLEARM PIE	;NO INTERRUPTS ARE EXPECTED
	CONO PI,11577
IFN FTKL10,<
	CONO PAG,0
	CONO DTE,PILDEN
	SETZM DTEEPW
	SETZM DTEMTI
	SETZM DTEFLG
	MOVEI A,.DTMMC
	MOVEM A,DTECMD
	CONO DTE,TO11DB
	SKIPN DTEFLG
	JRST .-1
>
	PUSHJ P,SETSAA	;SET UP SA-10 DEVICE ADDRESS
	MOVE A,[JSR UUOH]
	MOVEM A,41	;INITIALIZE MAGIC MEMORY LOCATIONS
	MOVE A,[JSR INT1]
	MOVEI B,42	;ALL INTERRUPT ROUTINES ARE SAME LENGTH
PISETL:	MOVEM A,(B)
	ADDI A,INT2-INT1
	ADDI B,2
	CAIE B,60
	JRST PISETL
BTE:	CONO 200000	;I O RESET
	MOVEI A,^D300
	SOJG A,.	;DELAY A BIT
BTE0:	MCONI SA0,A
	TLNE A,1	;CONI SHOULD GIVE 1 IN L.H.
	JRST BTE2	;IF IT DID, OK
	MOVE A,DCONI
	TLC A,400
	XCT A
	TLNN DD,1	;IS THIS AN SA-10?
	JRST BTE1	;IF NOT
	MOVEI A,4
	XORM A,SADEVA	;IT IS (AND SA0 WASN'T) CHANGE DEV ADDR
	PUSHJ P,SETSAA
	MOVE A,SADEVA
	MOVEI C,[ASCIZ /
SA-10 DEV ADDR IS %A /]
	PUSHJ P,STYO
	JRST BTE0

BTE1:	MCONO SA0,7	;OTHERWISE LOOK DEEPER
	MCONI SA0,A
	TDNE A,[1,,7]	;ANY PIA BITS GET SET?
	JRST ERR50	;IF YES
	MOVEI A,5
	MOVEM A,PIE	;WE'LL TRY AN INTERRUPT
	CONO PI,2377	;TURN ON ALL CHANNELS
	MCONO SA0,STSTF+6	;SHOULD NOT INTERRUPT YET
	MOVEI A,10
	MCONO SA0,STPIE+5	;THIS SHOULD CAUSE INTERRUPT
	SOJG A,.	;GIVE IT A CHANCE
	MCONO SA0,400000	;RESET SA-10
	CONO PI,11577	;CHANNELS OFF AGAIN
	SKIPN PIE
	JRST ERR51	;INTERRUPT OCCURRED
	CLEARM PIE	;INTERRUPT DIDN'T OCCUR
	JRST ERR52

BTE2:	CAME A,[1,,0]
	JRST ERR53	;SOME BAD BITS ON
	MOVEI A,10
	CONO PI,2377	;ENABLE ALL PI CHANNELS
	SOJG A,.	;WAIT NERVOUSLY
	MCONO SA0,7	;SET PIA BITS
	MCONI SA0,A
	CAME A,[1,,7]
	JRST ERR55	;IF PIA DOESN'T READ IN
	MOVSI C,40000	;WILL SWEEP THRU DEVICE CODE BITS
BTE2A:	MOVE B,DCONI
	XOR B,C	;CREATE CODE OF SIMILAR DEVICE
	XCT B	;CONI IT
	CAMN DD,[1,,7]	;NO OTHER DEVICE CAN MAKE THIS STATEMENT
	JRST ERR54	;IF ONE TRIED
	LSH C,-1
	CAME C,[200,,0]
	JRST BTE2A	;IF MORE DEV ADDR BITS TO CHECK
	CONO 200000	;I O RESET SHOULD CLEAR PIA
	MCONI SA0,A
	CONO PI,11577	;RESET PI
	CAME A,[1,,0]
	JRST ERR56	;PIA DIDN'T CLEAR

BTE4:	MCONO SA0,RDCONI+7	;CAN WE DO A DATAI?
	MDATAI SA0,A
	CAME A,[2,,7]	;CLEN, PIA
	JRST ERR57	;IF WRONG
	MCONO SA0,SASTEP	;STOP THE CLOCK
	MCONO SA0,RDCONI
	MDATAI SA0,A
	JUMPN A,ERR58	;IF WE DIDN'T BEAT THE CLOCK
	MCONO SA0,RSTSA!CLMERR
;SEE IF CHANNEL COUNTER COUNTS WHEN CLOCK IS STEPPED
BEG1AA:	MOVEI B,2*NCHN
	JRST BEG1AB
BEG1A:	MDATAO SA0,[0]
BEG1AB:	MCONO SA0,SASTEP!RDCCI
	MDATAI SA0,C
	MOVE A,C
	LSH A,-22	;FLUSH CBUS AND MICRO-P.C.
	TDNE A,[-1_2]
	JRST ERR1	;DATAI READ IN EXTRANEOUS BITS
BEG1B:	LOOP 1,BEG1A
	JUMPN A,BEG1	;WAIT UNTIL WE GET TO CHANNEL 0
BEG1C:	LOOP 2,BEG1AA
	MOVSI A,-NCHN	;CLEAR OUT COUNT TABLE
BEG20:	CLEARM CCTBL(A)
	AOBJN A,BEG20

BEG20A:	MOVEI B,100*NCHN
BEG2:	MDATAO SA0,[0]	;GET THE THING A NO-OP TO EXECUTE
	MCONO SA0,SASTEP!RDCCI
	MDATAI SA0,A
	LSH A,-22
	ANDI A,-1_<-44+2>
	AOS CCTBL(A)	;NOTE THAT THIS CHANNEL HAS BEEN COUNTED
	SOJG B,BEG2
	MOVSI A,-NCHN	;MAKE SURE ALL CHANNELS GOT SERVICE
BEG21:	SKIPN CCTBL(A)
	JRST ERR3	;THIS GUY DIDN'T GET COUNTED
BEG21A:	LOOP 3,BEG20A
	AOBJN A,BEG21	;CHECK THE OTHERS

;MAKE SURE ALL BITS OF MICRO-P.C. CAN BE SET
	PUSHJ P,STEPC0
	MOVEI A,^D10
	JSR PTN	;TRY VALUES FOR 10 BITS
IARL:	ANDI A,1777
	MOVE B,A
	MDATAO SA0,B
	PUSHJ P,STEP0
	ANDI A,1777
	CAME A,B
	JRST ERR4	;MICRO-P.C. NOT BEING SET PROPERLY
IARL1:	LOOP 4,IARL
	MDATAO SA0,[040000]	;CBUS_IARB
	MDATAI SA0,A
	LDB A,[121000,,A]
	MOVE C,B
	ANDI C,377
	CAME A,C
	JRST ERR5	;CBUS_IARB LOSING
IARL2:	LOOP 5,IARL
	JSR PTN0	;ON TO NEXT DATA VALUE

;SEE IF SOURCE OF ZEROES WORKS
SZER:	MOVEI A,176320	;REG. 3_0
	PUSHJ P,C0XCT
	MOVEI A,072260	;START DUMMY WRITE FROM REG. 3
	PUSHJ P,C0XCT
	MCONO SA0,RDMBL
	MDATAI SA0,A	;SHOULD GIVE US 0 IN THE R.H. OF A
	TRNE A,-1
	JRST ERR40	;FAILS HERE IF NO ROMS INSTALLED YET
SZER1:	LOOP ^D40,SZER
MAMB:	MOVEI A,^D36
	JSR PTN	;TRY ALL 36 BITS OF WORD
MAMB1:	MOVE C,[200000,,TEST]
	PUSHJ P,LC0CW
	MOVE C,A
	HLRZM C,MAMBTL
	HRRZM C,MAMBTR
	PUSHJ P,LC0R2
	MOVEI A,062260	;START DUMMY WRITE FROM REG. 2
	PUSHJ P,C0XCT
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
	MCONO SA0,RDMA
	MDATAI SA0,C
	MOVE A,C
	AND A,[3,,-1]
	CAIE A,TEST
	JRST ERR11	;MEM ADDR REG HAS WRONG THING IN IT
MAMB1A:	LOOP ^D11,MAMB1
	MCONO SA0,RDMBL
	MDATAI SA0,A
	HRRZ B,A
	CAME B,MAMBTL
	JRST ERR6	;MB LEFT LOSING
MAMB2:	LOOP 6,MAMB1
	TLNE A,-1
	JRST ERR7	;WRONG CHANNEL HAS MEMORY SUBROUTINE
MAMB3:	LOOP 7,MAMB1
	MCONO SA0,RDMBR
	MDATAI SA0,A
	CAME A,MAMBTR
	JRST ERR12	;MB RIGHT LOSING
MAMB4:	LOOP ^D12,MAMB1
	JSR PTN0	;ON TO NEXT DATA VALUE
CWTST0:	MOVEI G,NCHN-1	;TRY OUT WC, CA, PC PATHS
CWTST:	PUSHJ P,STEPCX	;STEP CLOCK TO APPROPRIATE CHANNEL
CWTST1:	MOVEI A,^D36	;CHECK 36 BIT POSITIONS
	JSR PTN
	MOVEM A,CWTA	;DATA WORD
	SETCM B,A	;ITS COMPLEMENT
	LSH B,1
	MOVEM B,CWTB	;A SLIGHTLY DIFFERENT DATA WORD
	MOVE J,[441100,,CWTD]
	MOVE D,[441000,,A]
	ILDB C,D	;GET A BYTE OF 1ST DATA WORD
	TRO C,200
	IDPB C,J	;PUT MUNGED BYTE INTO CWTD
	ILDB C,D	;GET ANOTHER BYTE
IFN CV,<	TRO C,17>	;DIDDLE IT IF NEED BE
	IDPB C,J	;PUT IT AWAY
	MOVEI C,340	;MAGIC BYTE
	IDPB C,J	;INTO TABLE
	ILDB C,D
	IDPB C,J	;ANOTHER BYTE FROM 1ST WD
	ILDB C,D
	IDPB C,J	;AND ANOTHER
	LDB C,[400,,A]	;REMAINING NIBBLE OF 1ST WORD
	ASH C,4
IFN CV,<	LDB D,[240200,,A]	;EXTRA BITS IN C VERSION
	ADD C,D>
	IDPB C,J	;INTO TABLE
	LDB C,[141000,,B]	;RIGHT BITS FROM 2ND WORD
	IDPB C,J	;INTO TABLE
	LDB C,[41000,,B]	;RIGHTER BITS
	IDPB C,J	;INTO TABLE
	LDB C,[400,,B]	;RIGHTEST BITS
	ASH C,4
IFN CV,<	LDB D,[240200,,B]
	ADD C,D>
	IDPB C,J	;LAST TABLE ENTRY
CWTST2:	MOVE C,CWTA
	MOVE J,[441100,,CWTD]
	PUSHJ P,LCXCW	;PUT INTO WC, CA REGISTERS
	MOVE C,CWTB
	PUSHJ P,LCXR2
	MOVEI A,065300	;PC_ADR FILED OF REG. 2
	PUSHJ P,CXXCT
	MOVEI C,040400	;CBUS_BYTE 1 OF WC
	MOVEI F,3	;DO STUFF FOR EACH OF 3 REGISTERS
CWT1:	MOVEI B,3	;DO THIS STUFF FOR EACH OF 3 BYTES
CWT2:	MDATAO SA0,C	;GET DATA ONTO CBUS
	MCONO SA0,RDCCI
	MDATAI SA0,A
	LDB A,[121000,,A]	;GET CONTENTS OF CBUS
	ILDB D,J	;GET EXPECTED ANSWER
	CAIN B,1	;CHECK FOR 3RD BYTE
	ANDI A,360	;IGNORE EXTRANEOUS BITS
	CAIN B,1
	ANDI D,360
	CAME D,A	;ARE THEY THE SAME?
	JRST ERR28	;NOPE
CWT2A:	ADDI C,400	;ADVANCE TO NEXT BYTE OF REGISTER
	SOJG B,CWT2	;THAT'S ALL FOR THAT REGISTER
	ADDI C,400	;ADVANCE TO NEXT REGISTER
	SOJG F,CWT1	;WE'VE TESTED ALL THREE REGISTERS
	JSR PTN0	;TRY NEXT DATA VALUE
	SOJGE G,CWTST	;TRY ALL CHANNELS
	LOOP ^D28,CWTST0
INCT:	MOVEI J,0	;0 OR -1
INCT0:	HRLOI F,17	;SHIFTS
INCT1:	MOVE C,F	;DATA WORD
	XOR C,J	;COMPLEMENTED SECOND TIME THROUGH
	MOVEM C,INCTW	;REAL DATA WORD
	ADDM J,INCTW
	JUMPL J,INCT1A
	AOS INCTW	;SIMULATE THE INCREMENTER
INCT1A:	PUSHJ P,LC0CW	;LOAD CA, WC
	MOVEI A,42300
	JUMPGE J,INCT2
	MOVEI A,42660
INCT2:	PUSHJ P,C0XCT	;DO THE INCREMENT/DECREMENT
	MOVEI A,62260
	PUSHJ P,C0XCT
	MCONO SA0,RDMA	;TO READ THE MA BACK
	MDATAI SA0,A
	MCONO SA0,RDBITS	;TO READ THE EXTRA ADDR BITS
	MDATAI SA0,B
	DPB B,[240200,,A]	;PUT EXTRA BITS WHERE THEY BELONG
	XOR A,INCTW	;COMPARE
	TDNE A,[17,,777777]	;WHERE WORDS SHOULD MATCH
	JRST ERR39	;IF ERROR
INCT4:	LOOP ^D39,INCT1	;USE SAME DATA IF LOOPING
	JUMPE F,INCT5	;IF ALL BIT POSITIONS TRIED
	ASH F,-1
	JRST INCT1	;OTHERWISE TRY NEXT ONE

INCT5:	SETCA J,0	;COMPLEMENT J
	JUMPL J,INCT0	;AND DO OTHER PASS IF NEEDED
MRD0:	MOVE C,[200000,,TEST]
	PUSHJ P,LC0CW
	MOVEI E,146720	;REG. 0_MEM RD BUFFER
MRD1:	MOVEI A,042200	;START READ AT CA
	PUSHJ P,C0XCT
	MOVEI B,3
MRD:	MOVE A,E
	PUSHJ P,C0XCT
	SOJLE B,ERR8	;MEM CYCLE TOOK TOO MANY TICKS
	MCONO SA0,RDCONI
	MDATAI SA0,A
	TLNE A,1
	JRST MRD
MRD1A:	LOOP ^D8,MRD1
	MOVE A,E
	PUSHJ P,C0XCT
	ADDI E,10000	;FILL NEXT REGISTER
	TRNE E,40000	;ALL FILLED?
	JRST MRD1	;NO
	SETOM TEST1	;CLOBBER PLACE WHERE DATA WILL BE READ BACK
	CLEARM TEST1+1
	MOVE A,TEST+2
	SETCAM A,TEST1+2
	MOVEM A,TEST1+3
	MOVEI E,042240	;START WRITE CYCLE
MWR1:	MOVE A,E
	PUSHJ P,C0XCT
	MOVEI B,3
MWR:	SOJLE B,ERR9	;MEM CYCLE TOOK TOO MANY TICKS
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
	MOVEI A,0
	PUSHJ P,C0XCT
	MCONO SA0,RDCONI
	MDATAI SA0,A
	TLNE A,1
	JRST MWR
MWR1A:	LOOP ^D9,MWR1
	ADDI E,10000
	TRNE E,40000
	JRST MWR1
	MOVSI A,-4
MCMP:	MOVE B,TEST1(A)
	MOVE C,TEST(A)
	CAME B,C
	JRST ERR10	;DATA GOTTEN BACK WRONG
	AOBJN A,MCMP
MCMP1:	LOOP ^D10,MRD0


;FALLEN INTO FROM PREVIOUS PAGE
STCL:	MOVEI G,NCHN-1	;HANG ALL CHANNELS
STCLH:	PUSHJ P,STEPCX	;GET TO RIGHT CHANNEL
	MOVEI A,HANGPC	;FEED IT MAGIC PC WHICH WILL HANG IT
	PUSHJ P,CXXCT
	SOJGE G,STCLH	;DO SAME FOR ALL CHANNELS
	MCONO SA0,SACGO	;START THE CLOCK SO CONO'S WILL WORK
	MOVEI E,10*<NCHN-1>
	MOVEI D,PIE0_<1-NCHN>
	MOVEI C,NCHN-1
STCL1:	MCONO SA0,STPIE(E)
	MCONSO SA0,(D)
	JRST ERR13
STCL1A:	MCONO SA0,CLPIE(E)
	MCONSZ SA0,(D)
	JRST ERR14
STCL1B:	LSH D,-4
	MCONO SA0,STBSY(E)
	MCONSO SA0,(D)
	JRST ERR15
STCL1C:	MCONO SA0,CLBSY(E)
	MCONSZ SA0,(D)
	JRST ERR16
STCL1D:	LSH D,-4
	MCONO SA0,STSTF(E)
	MCONSO SA0,(D)
	JRST ERR17
STCL1E:	MCONO SA0,CLSTF(E)
	MCONSZ SA0,(D)
	JRST ERR18
STCL1F:	LSH D,10+1
	LOOP ^D13,STCL1
	SUBI C,1
	SUBI E,10
	JUMPGE E,STCL1
	MOVSI B,-3
	MCONO SA0,SASTEP
	PUSHJ P,STEPC0
STCLM2:	MOVE A,STCLM(B)
	PUSHJ P,C0XCT
	MCONSO SA0,@STCLM1(B)
	JRST ERR19
STCLM3:	MOVE A,STCLM(B)
	SUBI A,4000
	PUSHJ P,C0XCT
	MCONSZ SA0,@STCLM1(B)
	JRST ERR20
STCLM4:	LOOP ^D19,STCLM2
	AOBJN B,STCLM2
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
QFIFO:	MOVEI G,NCHN-1	;FILL UP THE FIRST-IN, FIRST-OUT
		;BUFFERS OF EACH OF THE CHANNELS
FIFO1:	PUSHJ P,STEPCX	;STEP TO THE APPROPRIATE CHANNEL
	MOVEI A,002000	;CLEAR TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,027000	;SET WRITE BIT IN TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,027400	;SET BUFFER ENABLE BIT IN TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,145000	;TEST BUFFER EMPTY BIT
	PUSHJ P,CXTST
	TRNN A,40_12	;CHECK RESULTS OF TEST
	JRST ERR21	;BUFFER WASN'T EMPTY
FIFO1A:	LOOP ^D21,FIFO1
	MOVEI C,0
	PUSHJ P,LCXCW	;CAUSE AN APPARENT W.C. OVERFLOW
	MOVEI D,NBF	;SET UP COUNT OF # BYTES TO SEND
FIFO2:	MOVE A,G
	LSH A,5
	ADD A,D		;SYNTHESIZE A UNIQUE BYTE OF DATA
	PUSHJ P,CXXCT	;PUT IT INTO MICRO-P.C.
	MOVEI A,040140	;PUT "FIFO_MICRO-P.C." IN MICROIN-
	PUSHJ P,CXTST	;STRUCTION REGISTER TO SEE IF IT
			;WILL BRANCH
	PUSHJ P,STEPX	;NOW EXECUTE THE MICROINSTRUCTION
	MOVEI A,145000	;TEST BUFFER EMPTY BIT
	PUSHJ P,CXTST
	TRNE A,40_12
	JRST ERR22	;BUFFER WAS EMPTY
FIFO2A:	LOOP ^D22,FIFO2
	SOJG D,FIFO2	;KEEP DOING IT UNTIL FIFO SHOULD BE FULL
FIFO2C:	MOVEI A,040140	;TRY TO PUT ANOTHER WORD INTO FIFO
	PUSHJ P,CXXCT
	TRNN A,1	;OUGHT TO COMPLAIN THIS TIME
	JRST ERR24	;DIDN'T
FIFO2B:	LOOP ^D24,FIFO2C
	SOJGE G,FIFO1	;FILL UP FIFOS OF OTHER CHANNELS
;O.K., FOLKS, NOW WE SEE IF WE CAN GET THE DATA BACK
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
	MOVEI G,NCHN-1	;START UNLOADING HIGHEST CHANNEL
FIFO3:	PUSHJ P,STEPCX	;STEP COUNTER TO APPROPRIATE CHANNEL
	MOVEI A,023400	;CLEAR BUFFER ENABLE
	PUSHJ P,CXXCT
	MOVEI A,027400	;SET BUFFER ENABLE
	PUSHJ P,CXXCT
	MOVEI A,145000	;TEST BUFFER EMPTY (SHOULD BE)
	PUSHJ P,CXTST
	TRNN A,40_12
	JRST ERR25	;WASN'T
FIFO3A:	LOOP ^D25,FIFO3
	MOVEI A,023000	;CLEAR WRITE
	PUSHJ P,CXXCT
FIFO3Z:	MOVEI D,NBF
FIFO4:	MOVEI A,145000	;TEST BUFFER EMPTY
	PUSHJ P,CXTST
	TRNE A,40_12
	JRST ERR26	;OOPS, IT WAS
FIFO4A:	LOOP ^D26,FIFO4
	MOVEI A,147000	;R0B0_FIFO
	PUSHJ P,CXTST
	PUSHJ P,STEPX
	MOVE H,G
	LSH H,5
	ADD H,D
	MOVEI A,140000	;CBUS_R0B0
	PUSHJ P,CXTST
	LDB A,[121000,,A]
	CAME A,H
	JRST ERR27	;WRONG DATA READ BACK FROM FIFO
FIFO4B:	SOJG D,FIFO4	;READ BACK THE REST
	LOOP ^D27,FIFO3Z
	MOVEI A,145000	;BUFFER SHOULD NOW BE EMPTY
	PUSHJ P,CXTST
	TRNN A,40_12
	JRST ERR23	;OOPS, IT ISN'T
FIFO4C:	LOOP ^D23,FIFO3
	SOJGE G,FIFO3	;READ BACK FIFOS OF OTHER CHANNELS
;FALL THRU

;TRY OUT P.I. REQUEST LOGIC
PITST0:	MCONO SA0,SACGO
	MOVEI G,<NCHN-1>*10
PITST:	MCONO SA0,CLSRQ(G)	;CLEAR STATUS REQUEST FLAG
	MCONO SA0,CLSTF(G)	;AND STATUS FLAG
	MCONO SA0,STPIE(G)	;AND SET P.I. ENABLE FLAG
	SUBI G,10
	JUMPGE G,PITST	;FOR ALL CHANNELS
	MCONSZ SA0,PIRQ	;SHOULD NOT BE REQUESTING AN INTERRUPT
	JRST ERR29	;OOPS, WAS
PITST1:	LOOP ^D29,PITST0
	CLEARM PIE	;NOT EXPECTING ANY INTERRUPTS
	CONO PI,12377	;ENABLE ALL P.I. CHANNELS
	MOVEI B,7
PIT1:	MCONO SA0,(B)
	SOJG B,.-1	;SHOULD NEVER INTERRUPT
	MOVEI G,<NCHN-1>*10
PIT2:	MOVEI B,7
PIT3:	MOVEM B,PIE
	ADD B,G
	MCONO SA0,STSTF(B)	;SHOULD CAUSE AN INTERRUPT
	ROT 377	;DELAY FOR KI-10
	XCT .-1
	JFCL
	SKIPE PIE	;DID IT?
	JRST ERR38	;NO, COMPLAIN
PIT3A:	LOOP ^D38,PIT3
	SUB B,G
	SOJG B,PIT3	;TRY ALL P.I. CHANNELS
	SUBI G,10
	JUMPGE G,PIT2	;TRY ALL SA-10 CHANNELS
UCT:	MOVEI B,0	;ADDRESS
	PUSHJ P,STEP0	;DO GOTO
UCT0:	HRRZ C,MCBEG0(B)	;WHAT UINST SHOULD BE
	TRNE C,140000
	JRST UCT8	;IF NOT GOTO OR OFF/ON
	MOVE A,B
	PUSHJ P,C0XCT	;IT'S HARMLESS, DO IT
	PUSHJ P,STEP0
	LDB D,[100200,,B]
	TRZE C,36000
	DPB D,[100200,,C]
	ANDI A,1777
	CAME A,C
	JRST ERR41
UCT7:	LOOP ^D41,UCT0
UCT8:	CAIGE B,1400-<CNOB*400>-1
	AOJA B,UCT0
	POPJ P,	;O.K., IT ALL WORKS
;HERE


BEG1:	SOJG B,BEG1A
	JRST ERR2		;DIDN'T GET TO CHANNEL 0

STEPC0:	MOVEI G,0
STEPCX:	MCONO SA0,RDCCI
STPC0A:	MDATAI SA0,A
	LDB H,[220200,,A]	;CHANNEL SELECTION.
	CAMN H,G		;DESIRED CHANNEL?
	POPJ P,			;YES.
	MDATAO SA0,[HANGPC]	;NO. STICK OTHER CHANNELS AT STICKY PC
STEPX:
STEPX1:	MCONO SA0,SASTEP!RDCCI
	JRST STPC0A

LC0CW:	MOVEI G,0
LCXCW:	PUSHJ P,LCXR2
	MOVEI A,060700	;WC_WC FIELD OF REG. 2
	PUSHJ P,CXXCT
	MOVEI A,063300	;CA_CA FIELD OF REG. 2
CXXCT:	MDATAO SA0,A
	JRST STEPX

C0XCT:	MDATAO SA0,A
STEP0:	MOVEI G,0
	JRST STEPX1

CXTST:	MDATAO SA0,A
	MCONO SA0,RDCCI
	MDATAI SA0,A
	POPJ P,

LC0R2:	MOVEI G,0
LCXR2:	MOVEI D,060000-20	;IARB TO BYTE OF REG. 2
LCXR2A:	ADDI D,20	;ADVANCE TO NEXT BYTE OF REGISTER
	MOVEI B,0
	LSHC B,10
	MDATAO SA0,B	;PUT A BYTE OF DATA INTO MICRO-P.C.
	PUSHJ P,STEPX
	MDATAO SA0,D	;TRANSFER IT TO BYTE OF REG. 2
	PUSHJ P,STEPX
	TRNN D,100	;WAS THAT THE LAST BYTE?
	JRST LCXR2A	;NO
	POPJ P,	;I CAN'T BELIEVE WE FILLED THE WHOLE WORD

PTORG=0			; Origin of Executive and User page tables
DATPG=400		; Virtual page for data buffer
DATPGA=1000*DATPG	; Virtual address of start of buffer page
PHYADR:	0		; Physical address of start of buffer page
KIEPTW:	400000+PTORG,,420000+PTORG	; Pager initialization
LOWBD:	ADRLO		; Lower bound of memory test (must be above program)
HIBD:	0		; Upper bound of memory test
DATYPE:	-1		; Data type  -1 = random data
			;	      0 = fixed data from DATVAL
DATVAL:	-1		; Fixed data pattern

CMT:	MOVEI P,PDL-1	; Memory test
	PUSH P,QUIET	; Save the quiet setting
	SETZM QUIET	; Let him hear us for now
	MOVEI C,[ASCIZ /
SA-10 Memory Access Test
/]
	PUSHJ P,STYO
	PUSHJ P,RSTALL	; Reset the world
	PUSHJ P,STATIC	; Test static mode
	CONO PI,731577	; Turn off PI's
	MOVEI A,0	; Reset the SA-10
	PUSHJ P,CSET
	MCONO SA0,@CLPIEC	; Turn off SA10 interrupts
IFE KIFLG,<
	PUSHJ P,SETHI
	POP P,QUIET	; Restore quiet setting
CMT0:	MOVE E,ADRLO
CMT1:	MOVE A,[MOVE CMTP0]
	PUSHJ P,RND
	MOVEM B,(E)
	HRRM E,CMTP0
	PUSHJ P,CMTG
	CAME B,CMTPT
	JRST CMT1E0
	SETCAM B,CMTPT
	MOVE A,[MOVE CMTP1]
	HRRM E,CMTP1A
	PUSHJ P,CMTG
	MOVE F,(E)
	EQV B,F
	JUMPN B,CMT1E1
	ADDI E,1
	CAMGE E,ADRHI
	JRST CMT1
	MOVEI B,"."
	PUSHJ P,TYO
	JRST CMT0
	>	; End IFE KIFLG

IFN KIFLG,<
; Paged memory test
; LOWBD = lower bound of memory test (must be above program)
; HIBD  = upper bound of memory test
; DATYPE = Data type
;	   -1 = random data
;	    0 = fixed data from DATVAL

	PUSHJ P,PSETHI			; Find memory limits
	SETZ BF,			; Clear loop counter
CMTI:	MOVEI C,[ASCIZ /Test region from /]
	SETO A,				; Get octal input
	PUSHJ P,NUMGM			; Get the limit
	 JRST   [MOVE D,PADRLO		; Only break char, default it
		 MOVEI C,[ASCIZ /%D /]
		 PUSHJ P,STYO
		 MOVE A,PADRLO
		 JRST .+1]
	CAMGE A,PADRLO			; Check lower bound
	 JRST   [MOVEI C,[ASCIZ /  (Lower bound in program region, resetting to %D)
/]
		 MOVE D,PADRLO
		 PUSHJ P,STYO
		 MOVE A,PADRLO		; Set it to minimum
		 JRST .+1]
	MOVEM A,LOWBD			; Set the lower bound
	MOVEI C,[ASCIZ /to /]
	SETO A,
	PUSHJ P,NUMGM
	 JRST   [MOVE D,PADRHI		; Only break char, default it
		 MOVEI C,[ASCIZ /%D /]
		 PUSHJ P,STYO
		 MOVE A,PADRHI
		 JRST .+1]
	CAMLE E,PADRHI			; OK?
	 JRST   [MOVEI C,[ASCIZ /  (Upper bound out of range, resetting to %D)
/]
		 MOVE D,PADRHI
		 PUSHJ P,STYO
		 MOVE A,PADRHI		; Set it to maximum
		 JRST .+1]
	MOVEM A,HIBD			; Set it to maximum
	PUSHJ P,CONDCR			; Do cr if needed
	MOVE E,LOWBD			; Lower bound below upper?
	CAMLE E,HIBD
	 JRST   [MOVEI C,[ASCIZ "!!! Lower bound exceeds upper bound

"]
		 PUSHJ P,STYO		; No go, bomb out
		 JRST CMTI]
CMTI0:	MOVEI C,[ASCIZ /Random or Fixed data (R or F): /]
	PUSHJ P,NUMGM
	 SKIPA
	JRST CMTI0
	TRZ B,40			; Upper case only
	CAIN B,"R"
	 JRST   [SETOM DATYPE		; Random
		 JRST CMTI1]
	CAIE B,"F"
	 JRST   [PUSHJ P,CR		; Bad input
	 	 JRST CMTI0]
	SETZM DATYPE			; Fixed data
	PUSHJ P,CONDCR			; Do cr if needed
	MOVEI C,[ASCIZ /Octal data pattern: /]
	PUSHJ P,NUMGM
	 JFCL
	MOVEM A,DATVAL			; Save it
CMTI1:	PUSHJ P,CONDCR			; Do cr if needed
	POP P,QUIET			; Reset quiet setting
CMT0:	MOVE E,LOWBD			; OK, set up for lowest address
	MOVE B,E
	DPB B,[POINT 22,CMTP0,35]	; Set up chan prg addresses
	DPB B,[POINT 22,CMTP1A,35]
	ANDCMI B,777			; Compute 1st phys addr in page
	MOVEM B,PHYADR			; start and save it
	LSH B,-^D9			; Get page number
	PUSHJ P,STPGR			; And set up pager
	ANDI E,777			; Set up virtual address here
	ADDI E,DATPGA
CMT1:	SKIPN DATYPE			; Random data?
	 SKIPA B,DATVAL			; No, use set value
	PUSHJ P,RND			; Yes, get a new one
	MOVEM B,(E)			; Put it in the test memory location
	MOVE A,[TIC CMTP0]		; Run the chan prog
	PUSHJ P,CMTG
	CAME B,CMTPT			; Value read and written OK
	 JRST CMT1E0			; No, report error
	SETCAM B,CMTPT			; Now complement the pattern
	MOVE A,[TIC CMTP1]		; And run the inverse chan prgm
	PUSHJ P,CMTG
	MOVE F,(E)			; Fetch the new value
	EQV B,F				; Complement of old one?
	JUMPN B,CMT1E1			; If no, report error
	MOVEI B,1			; Now bump chan prgm addresses
	ADDM B,CMTP0
	ADDM B,CMTP1A
	ADDI E,1			; And bump virtual address
	TRNN E,777			; New page?
	 JRST   [MOVEI B,1000		; Yes, assign new phy pg to data pg
		 ADDB B,PHYADR		; Bump physical address
		 LSH B,-^D9		; Isolate page number
		 PUSHJ P,STPGR		; Reinit the pager
		 MOVEI E,DATPGA		; And the virtual address
		 JRST .+1]
	LDB B,[POINT 9,E,35]		; Construct phys addr of test word
	ADD B,PHYADR
	CAMG B,HIBD			; Out of test range?
	 JRST CMT1			; No, test it
	AOJA BF,CMT0			; Yes, start over again
	>	; End IFN KIFLG
CMTG:	MOVEM A,@CBASE
	MCONO SA0,@STBSYC
CMTG0:	MCONSO SA0,600170
	JRST CMTG0
	MCONSZ SA0,600000
	JRST CMTGE
	MCONO SA0,@CLSTFC
	POPJ P,
CMTGE:	SKIPN QUIET		; Output on?
	 JRST   [PUSHJ P,DSPE1	; Yes, record error conditions
		 JRST DDT]	; and quit
CMTLP:	SKIPN QUIET		; Output on?
	 JRST DDT		; Yes, quit
	MCONO SA0,CLMERR	; Off, clear memory errors
	MCONO SA0,@CLSTFC	; Clear status flag
	MOVEI P,PDL-1		; Reset stack
	JRST CMT1		; And loop on it

CMTP0:	40000,,0	;LAC X (X FILLED IN ABOVE)
	440000,,CMTPT	;DAC CMTPT
	0

CMTP1:	40000,,CMTPT	;LAC CMTPT
CMTP1A:	440000,,0	;DAC XX (XX FILLED IN ABOVE)
	0

CMTPT:	0


CMT1E0:	
IFN KIFLG,<
	ANDI E,777			; Convert to physical address
	ADD E,PHYADR
	>	; End IFN KIFLG
	JSR RRR
	^D101
	[ASCIZ /CPU WROTE /]
	SAVB
	[ASCIZ /, SA-10 READ /]
	CMTPT
	[ASCIZ / AT ADDR /]
	E
	0
	CMTLP

CMT1E1:	
IFN KIFLG,<
	ANDI E,777			; Convert to physical address
	ADD E,PHYADR
	>	; End IFN KIFLG
	JSR RRR
	^D102
	[ASCIZ /SA-10 WROTE /]
	CMTPT
	[ASCIZ /, CPU READ /]
	F
	[ASCIZ / AT ADDR /]
	E
	0
	CMTLP



; ROUTINE TO FIND HIGH END OF MEMORY

SETHI:	CONO 4,10000	;CLEAR PI
	JFCL 17,.+1	;AND APR FLAGS SO CONSZ BELOW WORKS
			;ON BOTH KA10 AND KI10
	MOVSI B,-1000	;SCAN FOR MEMORY SIZE
SETHI0:	MOVE A,(B)	;SEE IF MEMORY EXISTS
IFE FTKL10,<
IFE KIFLG,<
	CONSZ 0,1B23	;KA OR KI NXM?
	>
IFN KIFLG,<
	CONSZ 0,1B29	;KA OR KI NXM?
	>
	JRST SETHI1	;YES
>
	ADDI B,777	;NO, ANOTHER PAGE
	AOBJN B,SETHI0	;LOOP THROUGH ALL MEMORY
SETHI1:	MOVEI B,-1(B)	;LAST EXISTENT LOCATION
	CAMGE B,ADRHI	;ADRHI TOO HIGH?
	MOVEM B,ADRHI	;YES, BACK OFF
	MOVEI D,(B)
	MOVEI C,[ASCIZ /
LAST WORD OF MEMORY IS %D
/]
	JRST STYO


; Paged memory scan

IFN KIFLG,<

PSETHI: MOVE A,[JSR BDLUUO]	; Set up for bad LUUO's
	MOVEM A,PTORG+41
	MOVEI A,BDMUUO		; And bad MUUO's
	MOVEM A,PTORG+430
	MOVE A,[PTORG+430,,PTORG+431]
	BLT A,PTORG+437
	MOVE A,[JSR PAGTRP]	; Set up for page traps
	MOVEM A,PTORG+420
	MOVE A,[JSR OVRTRP]	; And overflow traps
	MOVEM A,PTORG+421
	MOVEM A,PTORG+422
	MOVEM A,PTORG+423
	MOVE B,ADRLO	; Set up for page table entry - after ADRLO
	LSH B,-^D9	; Form page number
	ADDI B,1	; Start with page after program
PSETH0:	PUSHJ P,STPGR	; Set up pager for this page
	MOVE A,DATPGA	; See if memory exists for this page
	CONSZ 0,1B29	; NXM?
	 JRST PSETH1	; Yes
	AOJA B,PSETH0	; No, look at the next page
PSETH1:	PGROFF		; Turn off paging
	CONO APR,1B29	; Clear NXM flag
	LSH B,^D9	; Make page number into address
	SUBI B,1	; Address of highest memory
	MOVEM B,PADRHI	; Save it
	SKIPN HIBD	; Is test upper bound set?
	 MOVEM B,HIBD	; No, set it to maximum
	MOVE D,B	; And print message
	MOVEI C,[ASCIZ /
LAST WORD OF MEMORY IS %D
/]
	JRST STYO



; Routine to set data page (DATPG) to physical page
; Entry:  B = physical page corresponding to DATPG
; Call:   PUSHJ P,STPGR
; Returns with pager set up and on

STPGR:	PUSH P,B		; Save page number
	ADDI B,500000		; Set access bits
	MOVEI C,DATPG		; Virtual page number
	ROT C,-1		; Compute entry address in page table
	JUMPL C,[HRRM B,PTORG(C)	; Odd entry in right half
		 JRST .+2]
	HRLM B,PTORG(C)		; Even entry in left half
	PGRON			; Turn on paging
	POP P,B			; Restore B
	POPJ P,


; Handlers for traps of various sorts

BDLUUO:	0			; Set up for bad LUUO's
	JSR SAVACS		; Save AC's for later
	MOVEI C,[ASCIZ \
!!! Bad LUUO
\]
	JRST SCAT


BDMUUO:	JSR SAVACS		; Save AC's for later
	MOVEI C,[ASCIZ \
!!! Bad MUUO
\]
	JRST SCAT


PAGTRP:	0			; Set up for page traps
	JSR SAVACS		; Save AC's for later
	MOVEI C,[ASCIZ \
!!! Bad Pager Trap
\]
	JRST SCAT


OVRTRP:	0			; Overflows, etc.
	JFCL 17,.+1		; Clear flags on all channels
	HRRZS OVRTRP		; And in return PC
	JRST @OVRTRP		; Now continue

SAVACS:	0
	MOVEM P,CACS+P		; Save AC's
	MOVEI P,CACS
	BLT P,CACS+16
	MOVEI P,EPDL-1		; And set up error stack
	JRST @SAVACS

SCAT:	PUSHJ P,STYO		; Print the string
	MOVSI P,CACS		; Restore AC's
	BLT P,P
	JRST DDT
	>	; End IFN KIFLG
; Loop to store SA-10 status information when nothing but I/O bus works

STLOP:	MOVEI A,BASE		; Location of SA-10 base locations
	SETZM 1(A)		; Clear status locations for chan 0
	SETZM 2(A)
	CONO SA0,RSTSA+CLMERR	; Reset SA-10 and clear mem errors
	MOVE A,STDELA		; Wait a bit for the reset
	SOJG A,.
	CONO SA0,STSRQ		; Now request status information
	MOVE A,STDELB		; Wait a bit longer for it to happen
	SOJG A,.
	DMOVE B,CBASE+1		; Put old value in AC's for lights
	JRST STLOP


STDELA:	12		; Delay for SA-10 reset (minimum)
STDELB:	14		; Delay for SA-10 to store status (minimum)


;DISK TEST INTERRUPT CODE FOR DSKT BELOW
;JSR HERE ON CH 1 INT, SET UP AT START OF DSKT
DSKI:	0
	MOVEM G,ACS+G
	MOVEI G,ACS
	BLT G,ACS+G-1
	PUSH P,DD
	MCONI SA0,0
	TRNN 0,PIRQ
	JRST DSKIE
	TRNE 0,PARERR+NXM
	JRST DSPE
	TRNE 0,170
	JRST DSI0
DSKIE:	MOVEI C,[ASCIZ /UNKNOWN INT. CONI=%@
/]				;INT ON CH 1, NOT FROM SA10
	PUSHJ P,STYO
	JRST DSKXX

DSKX1:	MCONO SA0,@CLSTFC
DSKEX:	POP P,DD
	MOVSI G,ACS
	BLT G,G
	JEN @DSKI

DSPE1:	MCONO SA0,10
	MDATAI SA0,D		;ADDR
	MCONO SA0,20
	MDATAI SA0,A
	HLRZM A,E		;CH
	MCONO SA0,30
	MDATAI SA0,F
	HRLM A,F		;WORD
	MOVE G,(D)		;WORD IN MEM
	MOVEI C,[ASCIZ /NON EX MEM ON CH %E
ADDR=%D MEM HAS %G CHNL GOT %F
/]
	MCONSZ SA0,PARERR	;SELECT PARITY ERR OR NXM MSG
	MOVEI C,[ASCIZ /MEM PAR ERR ON CH %E
ADDR=%D MEM HAS %G CHNL GOT %F
/]
	JRST STYO

DSPE:	PUSHJ P,DSPE1
	LSH E,3			; CHANNEL NUMBER CAUSING INTERRUPT

	MCONO SA0,RSTCH+40(E)
	MCONO SA0,CLMERR+SA0CH
	JRST DSKEX

DSKXX:	SKIPE SERR
	JSR GOPR
	JRST DSKT0

;HERE ON SA10 INT FOR DSK CHANNEL

DSI0:	LDB G,[DEVFLD,,@CBASE+1]
	SUB G,IDEVA
	CAILE G,NPACKS-1
	JRST DSE1		;BAD DEV #
	MOVE A,TIME		; OK. UPDATE TIME OF RECENT INTERRUPT.
	EXCH A,HUNGT(G)		; FOR THIS DRIVE
	SKIPN OFFLIN(G)		; IF IT HAD BEEN OFF LINE, OR
	AOJN A,DSI0A		; IF IT HAD BEEN HUNG,
	MOVSI B,(1B14)		; Flag ON-LINE state change
	IORM B,CHCW(G)		; AT MAIN PROGRAM LEVEL
	MOVSI B,(1B2)		; Make sure it is not written on
	ANDCAM B,CHCW(G)
	SETZM OFFLIN(G)		; AND CLEAR THE OFF-LINE FLAG.
	SETOM UWP(G)		; Read enable whole drive
	JRST DSKXX		; Better restart the whole thing because
				; the old chan pgm may not be right.
DSI0A:	MOVE A,@CBASE+1
	TLNE A,163014		;SELECT ERR,BIPERR,CONTROL ERR,PROG INT,
				; ATTN, UNIT CK, UNIT EXCEPTION
	JRST DSE1		;BAD BITS IN STATUS
	TLNE A,100
	JRST DSIBSY		;POSS CU BUSY
	TLNE A,200
	JRST DSKX2		;CU END, RESTART CHAN
	TLNN A,20		;DEV END
	JRST DSI5		; NO.
	TLNE A,4000		; LENGTH ERROR HERE IS BAD
	JRST DSE1		; ..
	TDZ BF,BITS(G)		; AND IN LIGHT-WATCHER WORD.
	MOVE B,CHCW(G)		; Fetch status word
	TLZ B,(1B17)		; Clear DEV END wait
	MOVEM B,CHCW(G)		; Save new status word
DSI5:	MOVE A,CHCW(G)
	TLNE A,7		; MAIN PROG WAIT OR DEV END WAIT?
	JRST DSKX1		; YES, DISMISS
	MOVE B,G		; NO, PROCESS THIS INT.
	ADD B,IDEVA
	HRR BF,B		; FOR LIGHT WATCHERS
	HRRZM B,DEVN
	JRST (A)		;DISMISS VIA FINITE STATE MACHINE

DSIBSY:	TLNN A,400		; STATUS MODIFIER?
	JRST DSIB1		;NO STATUS MOD, DEVICE BUSY
	MOVE B,CPGP(G)		; CONTROLLER BUSY
	MOVEM B,DEVL(G)		;BACK UP CHNL PC
	JRST DSKX1		;BUT WAIT FOR CU END BEFORE RESTARTING

DSKX2:	MCONO SA0,@STBSYC
	JRST DSKX1		;CLEAR STATUS FLAG, RESTORE AC'S, DISMISS INT.

DSIB1:	TLNN A,200		; DEVICE BUSY. CU END?
	JRST DSE1		; NO.
	MOVE B,CPGP(G)		; YES. PREVIOUS CU BUSY IS NOW OVER
	MOVEM B,DEVL(G)
	JRST DSKX2		;TRY CMD AGAIN IF CU END IN INIT STAT

;CALLED AT THESE TAGS FROM INT ROUTINE WITH CHCW(DRIVE) IN A.
; BITS IN LH MEAN:
;B1: RANDOM TRACK AND HEAD
;B2: DO WRITES
;B3: DO READS
;B4: RE-FILL DATA, CHECK DATA
;B5: RANDOM CORE ADDR ON RD AND WRITE
;B6: TEST THIS DRIVE AT ALL.
;B7-8 - COUNT THRU SURFACE VERIFIER PATTERNS: 00=ZEROES, 01=ONES,
;	1X=WORST CASE PATTERN.
;B9 - USE VERIFIER, NOT RANDOM TRK AND DATA
;B17: WAITING FOR DEVICE END
;B16: REQUESTS MAIN PROG TO FILL WITH NEW DATA
;B15: REQUESTS MAIN PROG TO CHECK DATA
;B14: Change in on-line state occurred
;B13: RETRYING CORRECTABLE DATA CHECK
;B12: Change in write enabled state occurred

DIP0:	TLNN A,(1B9)		; NOT RANDOM IF SURFACE VERIFYING
	TLNN A,200000		; OK, RANDOM IF REQUESTED BY B1
	JRST DIP1
	PUSHJ P,RNDTK
	MOVEM C,TRK(G)
DIP1:	TLNN A,(1B9)		; DON'T RANDOMIZE IN SURFACE VERIFIER
	TLNN A,10000		; RANDOM CORE ADDR REQUESTED? (WRITE)
	JRST DIP1A
	PUSHJ P,RNDAD
	MOVEM C,ADDR(G)
DIP1A:	TLNN A,20000		; RE-FILL DATA AREA?
	JRST DIP1B
	MOVSI B,2
	JSP F,DIMP		; REQUEST MAIN PROG TO FILL DATA
DIP1B:	TLNN A,(1B2)		; Write data?
	JRST DIP2		; No
	MOVEI C,5		; WRITE DATA OPCODE
	PUSHJ P,DIRW		; DISK INT, READ/WRITE RTN
	MOVEI A,NRPT*RECL
	ADDM A,NWRITE(G)	; COUNT WORDS WRITTEN
	JSP F,DIGO
DIP2:	TLNN A,(1B9)		; DON'T RANDOMIZE ADR IN SURF VERIFY
	TLNN A,10000		; RANDOM CORE ADDR? (READ)
	JRST DIP2A
	PUSHJ P,RNDAD
	MOVEM C,ADDR(G)
DIP2A:	TLNN A,40000		; DO READS?
	JRST DIP3
	MOVEI C,6		; READ DATA OPCODE
	PUSHJ P,DIRW
	MOVEI A,NRPT*RECL
	ADDM A,NREAD(G)		; COUNT WORDS READ
	JSP F,DIGO
DIP3:	TLNE A,40000		; READING?
	TLNN A,20000		; YES. WANT DATA CHECKED?
	JRST DIP0		; NO TO ONE OF THOSE. DON'T CHECK
	MOVSI B,4		; REQUEST MAIN PROG TO CHECK DATA
	JSP F,DIMP
	JRST DIP0

DIGO:	HLL F,CHCW(G)
	TLO F,1
	MOVEM F,CHCW(G)
	IOR BF,BITS(G)		; FLAG BUSY FOR LIGHTS WATCHERS
	JRST DSKX2

DIMP:	HRRM F,CHCW(G)
	IORM B,CHCW(G)
	JRST DSKX1

RNDTK:	PUSHJ P,RND
	TLNE B,7
	JRST RNDT1		;MAKE CYL RANDOM ONLY 1/8 OF THE TIME
	SKIPN UWP(G)
	JRST RNDT3
	IDIVI B,NCYL*NSURF
	JRST RNDT2		; MAKE SURE NOT A BADSPOT

RNDT1:	IDIVI B,NSURF		;RANDOM HEAD ONLY
	MOVE D,TRK(G)
	IDIVI D,NSURF		;GET OLD HEAD
	SUB C,E	;NEW-OLD
	ADD C,TRK(G)
	SKIPE UWP(G)
	JRST RNDT2
	CAIGE C,NSCYL*NSURF
	JRST RNDT3
RNDT2:	MOVE D,C		; TRACK*19+HEAD
	HRL D,G			; DRIVE
	MOVSI E,-NBADSP		; COUNT THRU BAD SPOTS TABLE
RNDT2L:	SKIPGE SPOTTB(E)	;A SPOT IN TABLE?
	POPJ P,0		;NO, SO SELECTED ONE IS OK
	CAMN D,SPOTTB(E)	;YES. SAME AS SELECTED ONE?
	JRST RNDTK		;YES. DON'T USE IT. PICK ANOTHER
	AOBJN E,RNDT2L		;NO, SEE IF ANY MORE
	POPJ P,

RNDT3:	IDIVI B,<NCYL-NSCYL>*NSURF
	ADDI C,NSCYL*NSURF
	JRST RNDT2

RND:	MOVEI B,105
	FMPB B,RNDM
	POPJ P,
RNDM:	123456,,654321

RNDAD:	MOVE D,ADRHI
	SUB D,ADRLO		;SIZE OF BUFFER AREA
	IDIVI D,NPACKS		; SIZE FOR EACH DEVICE
	MOVEI E,(D)		; SIZE OF ONE DRIVE'S SPACE
	IMULI E,(G)		; BASE OF CURRENT GUY'S SPACE
	ADD E,ADRLO		; PLUS BASE OF ALL DATA AREAS.
	SUBI D,RECL*NRPT	;MAXIMUM POSSIBLE BUFFER ORIGIN OFFSET
	PUSHJ P,RND
	IDIVI B,1(D)		;OFFSET TO C
	ADD C,E			;BUFFER ORIGIN TO C
	POPJ P,

PBITS:	JUMPE E,CPOPJ
	TRNN E,1
	JRST PBIT1
	TLON D,400000
	JRST PBIT2
	MOVEI B,"+"
	PUSHJ P,TYO
PBIT2:	MOVE C,(D)
	PUSHJ P,STYO
PBIT1:	LSH E,-1
	AOJA D,PBITS

SNSMSG:	[ASCIZ /STATISTICS/]
	[ASCIZ /2-2/]
	[ASCIZ /CORRECTABLE/]
	[ASCIZ /2-0/]
	[ASCIZ /INCOMPLETE/]
	[ASCIZ /WRITE INHIBIT/]
	[ASCIZ /FILE PROTECT/]
	[ASCIZ /NO RECORD FOUND/]
	[ASCIZ /1-3/]
	[ASCIZ /CYLINDER END/]
	[ASCIZ /TRACK OVERRUN/]
	[ASCIZ /PERMANENT ERROR/]
	[ASCIZ /0-7/]
	[ASCIZ /0-6/]
	[ASCIZ /OVERRUN/]
	[ASCIZ /DATA CHECK/]
	[ASCIZ /EQUIPMENT CHECK/]
	[ASCIZ /BUS OUT PARITY CHECK/]
	[ASCIZ /INTERVENTION REQUIRED/]
	[ASCIZ /COMMAND REJECT/]
STAMSG:	[ASCIZ /UNIT EXCEPTION/]
	[ASCIZ /UNIT CHECK/]
	[ASCIZ /DEVICE END/]
	[ASCIZ /CHANNEL END/]
	[ASCIZ /BUSY/]
	[ASCIZ /CONTROL UNIT END/]
	[ASCIZ /STATUS MODIFIER/]
	[ASCIZ /ATTENTION/]
	[ASCIZ /PROG INT FLAG/]
	[ASCIZ /LENGTH ERROR/]
	[ASCIZ /BIT 5?/]
	[ASCIZ /SA10 CONTROL SEQ CHECK/]
	[ASCIZ /BUS IN PARITY CHECK/]
	[ASCIZ /SELECT ERROR/]

;DISK INTERRUPT, READ OR WRITE TO BE DONE. OPCODE IN C.

DIRW:	MOVSI A,2000
	MOVE B,CPGP(G)
	MOVEM B,DEVL(G)
	HRLI B,200000		;TCH
	LSH C,^D20		; TO OPCODE FIELD (RD OR WRT)
	MOVE D,DEVN		; DEVICE WHICH CAUSED THIS INTERRUPT
	LSH D,^D12
	TLC D,162034		;SEEK, CHAINED
	MOVE E,TRK(G)
	IDIVI E,NSURF
	LSH E,^D20
	LSH F,4
	IOR E,F
	ADDI B,4
	MOVEM D,-4(B)		;STORE SEEK
	MOVSI F,<-6>_CNTSFT
	HRRI F,177(B)
	MOVEM F,-3(B)		;PTR TO SEEK ARG
	SETZM 177(B)		;BB
	TLC D,2220		;MAKE SET SECTOR
	MOVEM D,-2(B)
	MOVE F,[<<-1>_CNTSFT>,,[0]]	; ONE BYTE OF ZERO FOR SECTOR NUMBER
	MOVEM F,-1(B)		;PTR TO SECTOR
	TLC D,110		;MAKE SRCH ID =
DIRW1:	MOVEM D,(B)		;STORE SRCH
	MOVSI F,<<-5>_CNTSFT>
	ADDI F,200(B)
	MOVEM F,1(B)		;STORE DCW FOR SEARCH
	MOVEM B,2(B)		;STORE TCH *-1 WHILE SRCH FAILS
	TLZ D,21774		; THEN DO THE RD OR WRT
	XOR D,C			; PUT RD OR WRT OPCODE INTO CMD
	MOVEM D,3(B)		;STORE CMD
	MOVSI F,<<-RECL>_CNTSFT>		; WORDS IN A RECORD (ONE PAGE)
	ADDI F,(A)
	ADD F,ADDR(G)		; BASE ADDR OF DATA AREA FOR THIS PACK
	MOVEM F,4(B)		;STORE DCW
	TLZ D,21774
	TLC D,20304		; CONVERT BACK TO "SEARCH ID EQUAL"
	MOVEM E,200(B)		;STORE CCHH
	MOVEM A,201(B)		;STORE REC #
	ADDI B,5		; COMMAND WORDS PER RECORD
	ADD A,[2000,,RECL]
	CAMGE A,[<NRPT+1>*2000,,0]	; RECORDS PER TRK. FILLED TRACK?
	JRST DIRW1			; NO. GO DO ANOTHER RECORD
	SETZM (B)		; YES. DONE. STORE HALT
	MOVSI F,40000
	ANDCAM F,-2(B)		;UNCHAIN LAST CMD
	POPJ P,


;HERE IF BUSY, NOT STATUS MOD, NOT CU END.
;HERE IF WRONG DEVICE INTERRUPTS.
;HERE IF "BAD BITS" IN CONI OR STATUS WORD (CHANNEL ERRORS)
DSE1:	SETOM SENSED		; IN CASE NO SENSE DONE
	HRLZ A,CBASE		; COPY THE 4 WORDS FROM LOW CORE
	HRRI A,DSTAT		; FORM BLT POINTER
	BLT A,DSTAT+3		; BEFORE DOING SENSE
	LDB D,[141000,,DSTAT+1]	; DEV CAUSING INT
	MOVE A,DSTAT+1		; SEE IF UNIT CHECK
	TLNE A,10		; ..
	PUSHJ P,DSENSE		; YES. DO A SENSE.
	PUSH P,QUIET		; Save current QUIET flag
	LDB E,[202400,,SENSED]	; SUPPRESS ERROR TYPEOUT ON SOME OF
	CAMN E,[3,,777777]	; Sense data collected?
	 JRST DSE4		; No
	CAIE E,100004		; THE CORRECTABLES, IN REPEATS.
	 JRST DSE1A		; NOT A CORRECTABLE
	MOVE E,CQUIET		; Correctable, replace QUIET flag
	MOVEM E,QUIET
	MOVE E,RETRYC(G)	; FIRST OR LAST ERROR?
	CAIE E,NRETRY
	CAIN E,0		; ..
	 JRST DSE4		; YES.
	JRST DSKCDC		; NO. DON'T TYPE THE SENSE STUFF

DSE1A:	CAME E,[2,,000040]	; Drive write inhibited?
	 JRST DSE1B		; No, look further
	MOVE A,CHCW(G)		; Yes, fetch the control word
	TLO A,(1B12)		; Flag state change
	TLZ A,(1B2)		; Also turn off write enable bits
	MOVEM A,CHCW(G)		; Update control word
	SETOM UWP(G)		; Read enable whole disk
	JRST DSE5		; And start scanning drives over again

DSE1B:	TLNN E,(1B17)		; Intervention required?
	 JRST DSE4		; No, print the data
	SETOM OFFLIN(G)		; Yes, set the code
	MOVSI A,(1B14)		; Show the state changed
	IORM A,CHCW(G)
	MOVSI A,(1B2)		; Turn off write enable
	ANDCAM A,CHCW(G)
	JRST DSE5		; And resume scanning drives

DSE4:	PUSHJ P,PTIME		; TIME-STAMP THE ERROR
	LDB A,[420200,,DSTAT+1] ; GET 0=INIT,1=END,2=ASYNC,3=DUMMY
	MOVE C,STTT(A)		; WHAT KIND OF STATUS STORED
	PUSHJ P,STYO
	LDB D,[141000,,DSTAT+1]	; DEVICE NUMBER
	MOVEI C,[ASCIZ / STATUS, DEVICE %D =
/]
	PUSHJ P,STYO
	LDB E,[241600,,DSTAT+1] ;FOURTEEN STATUS BITS FRM 1ST WD
	MOVEI D,STAMSG
	PUSHJ P,PBITS
	MOVE D,DSTAT+2
	MOVE E,TRK(G)		; WHERE SHOULD IT HAVE BEEN?
	IDIVI E,NSURF		; CYL TO E, HD TO F
	MOVEI C,[ASCIZ /
SW2=%D , CYLINDER %E, HEAD %F
/]
	PUSHJ P,STYO
	MOVE A,DSTAT+1
	TLNN A,10		; UNIT CHECK?
	JRST DSE5		; NO, RESTART
DSE2:	MOVEI C,[ASCIZ /SENSE: /]
	PUSHJ P,STYO
	MOVE E,SENSED
	AOJE E,[HRROI C,[ASCIZ \MISSING
\]
		PUSHJ P,STYO
		JRST DSE5]
	PUSHJ P,DPHADR		; PRINT PHYS ADR LETTER OR "?"
	PUSHJ P,CR
	PUSHJ P,PSB		; Print the hex bits
	MOVEI D,SNSMSG
	LDB E,[202400,,SENSED]
	PUSHJ P,PBITS		; Interpret them in English
	PUSHJ P,CR		; Fresh line
	LDB E,[202400,,SENSED]	; FIRST TWENTY BITS OF SENSE DATA
	TRNE E,1		;STATISTICS?
	JRST DSE5		;YES. NOT A FATAL ERROR, DON'T GET OPR
	CAIN E,100004		;SKIP UNLESS CORRECTABLE DATA CHECK
	JRST DSKCDC		;PRINT WHERE THE ERROR WAS
	PUSHJ P,CR		; Make sure we have a clean line
	AOS A,ERRCT(G)		; COUNT "OTHER" ERRORS
	CAMGE A,MAXBER		; MORE THAN MAX BAD ERRORS?
	JRST DSE5		; NO
	SETOM OFFLIN(G)		; YES. SHUT IT DOWN.
	MOVEI D,(G)		; TELL THE WORLD
	MOVEI C,[ASCIZ /
*** DRIVE %D EXCESSIVE ERRORS. MARKED OFF LINE, /]
	PUSHJ P,STYO
	PUSHJ P,PTIME
	PUSHJ P,CR		; Make sure we have a clean line
	PUSHJ P,CR		; Make sure we have a clean line
DSE5:	POP P,QUIET		; Restore QUIET flag
	JRST DSKXX		; GET OPR OR RESTART.

MAXBER:	EXP ^D50

; CALL WITH DRIVE CODE IN A

DPHADR:	MOVEI C,[ASCIZ /PHYSICAL DRIVE /]
	PUSHJ P,STYO
	MOVSI C,-10
	LDB A,[POINT 6,SENSED+1,7]	;BYTE 4 TELLS WHAT DRIVE
	CAMN A,PHADRT(C)	; LOOK THRU FUNNY NAMES
	JRST DPHAD2		; FOUND IT
	AOBJN C,.-2
	MOVEI B,"?"		; NOT FOUND
	JRST DPHAD3
DPHAD2:	MOVEI B,"A"(C)
DPHAD3:	PUSHJ P,TYO
	POPJ P,0

DSENSE:	DPB D,[141000,,PSENSE]	; SUBR TO GET SENSE FROM DEV IN D
	MOVEI A,10
	MOVEM A,SENSCT
DSE2A:	MOVE A,[MOVE PSENSE]
	MOVEM A,@CBASE
	SETOM SENSED
	SETZM SENSED+1
	SETZM SENSED+2
	SETZM SENSED+3
	SETZM SENSED+4
	SETZM SENSED+5
	SETZM @CBASE+1
	MCONO SA0,@STBSYC
	MCONO SA0,@CLSTFC
	MOVEI A,-1
DSE2A0:	MCONSO SA0,170
	SOJG A,DSE2A0
	JUMPLE A,DSE2B
	MOVE A,@CBASE+1
	TLNN A,(1B11)		; BUSY?
	JRST DSE2B
	SOSLE SENSCT
	JRST DSE2A
DSE2B:	POPJ P,0

DSENS1:	DPB D,[141000,,PNOP]	; SAME SUBR BUT DO NOP FIRST
	MOVE A,[MOVE PNOP]	; BECAUSE SENSE NOT UP TO DATE AT
	MOVEM A,@CBASE		; AT STARTUP WITHOUT IT
	MCONO SA0,@STBSYC
	MCONO SA0,@CLSTFC
	MOVEI A,-1
DSENS2:	MCONSO SA0,170
	SOJG A,DSENS2
	POPJ P,
PNOP:	BYTE (8) 240,3,IDEV,0
	0

STTT:	[ASCIZ /INITIAL/]
	[ASCIZ /ENDING/]
	[ASCIZ /ASYNC/]
	[ASCIZ /DUMMY/]

DSKCDC:	AOS NCORDC(G)		; COUNT CORRECTABLE DATA CHECKS
	MOVSI A,(1B13)		; FLAG CORRECTABLE CHECK
	IORB A,CHCW(G)		; IN DRIVE STATUS WORD
	SOS D,RETRYC(G)		; COUNT DOWN RETRIES
	CAIN D,NRETRY-1		; IF THIS IS FIRST ERROR,
	JRST DSKWHR		; GO REPORT ITS LOCATION
	JUMPGE D,DSKWHX		; IF NOT COUNTED OUT, QUIT HERE.
	MOVE D,0(P)		; Try to report permanent one -
	MOVEM D,QUIET		; Put back regular QUIET flag
	MOVEI D,NRETRY		; CALL IT PERMANENT
	MOVEI C,[ASCIZ /
*** DATA CHECK AFTER $D RE-READS.
/]
	PUSHJ P,STYO		; COMPLAIN, FALL INTO FULL REPORTER
DSKWHR:	LDB D,[POINT 3,SENSED+1,27]	; SENSE FORMAT DESCRIPTOR
	CAIE D,4		;IF 4 OR 5, GIVES POSITIONS.
	CAIN D,5		; ..
	JRST DSKWH1		; GOOD
	MOVEI C,[ASCIZ /SENSE BYTE FORMAT IS %D, SHOULD BE 4 OR 5.
/]
	PUSHJ P,STYO
	JRST DSKWHX		;GIVE UP
DSKWH1:	LDB D,[POINT 16,SENSED+2,15]	; CYL
	LDB E,[POINT 16,SENSED+2,31]	; HEAD
	MOVEI C,[ASCIZ /ERROR ADDRESS: DRIVE %G, CYLINDER %D, HEAD %E/]
	PUSHJ P,STYO
	LDB D,[POINT 8,SENSED+3,7]	; RECORD
	LDB E,[POINT 8,SENSED+3,15]	; SECTOR
	LDB F,[POINT 8,SENSED+3,23]	; OFFSET
	MOVEI C,[ASCIZ /
   RECORD %D, SECTOR %E, OFFSET %F

/]
	PUSHJ P,STYO
DSKWHX:	JRST DSE5			; Go start over

PHADRT:	EXP 70,61,52,43,34,25,16,07	;WIERD NAMES OF DRIVES

; ROUTINE TO PRINT ERROR STUFF FOR TAPE TEST

TSPE1:	SETOM TAPF		; FLAG TAPE, NOT DISK
	LDB A,[420200,,@CBASE+1] ; GET 0=END,1=INIT,2=ASYNC,3=DUMMY
	MOVE C,STTT(A)		; WHAT KIND OF STATUS STORED
	PUSHJ P,STYO
	LDB D,[141000,,@CBASE+1] ; DEVICE ADDR FROM STORED STATUS
	DPB D,[141000,,PSENSE]	; TO DO SENSE ON IT.
	MOVEI C,[ASCIZ / STATUS, DEVICE %D =
/]
	PUSHJ P,STYO
	LDB E,[241600,,@CBASE+1] ;FOURTEEN STATUS BITS FRM 1ST WD
	MOVEI D,STAMSG
	PUSHJ P,PBITS
	MOVE D,@CBASE+2
	MOVEI C,[ASCIZ /
SW2=%D
/]
	PUSHJ P,STYO
	MOVE A,@CBASE+1
TSE2:	MOVEI A,10
	MOVEM A,SENSCT
TSE2A:	MOVE A,[MOVE PSENSE]
	MOVEM A,@CBASE
	SETOM SENSED
	SETZM SENSED+1
	MOVE A,[SENSED+1,,SENSED+2]
	BLT A,SENSED+5
	SETZM @CBASE+1
	MCONO SA0,@STBSYC
	MCONO SA0,@CLSTFC
	MOVEI A,-1		; COUNTER
TSE2A0:	MCONSO SA0,170
	SOJG A,TSE2A0
	JUMPLE A,TSE2B
	MOVE A,@CBASE+1
	TLNN A,(1B11)		; BUSY?
	JRST TSE2B		; NO.
	SOSLE SENSCT
	JRST TSE2A
TSE2B:	MOVEI C,[ASCIZ /SENSE: /]
	PUSHJ P,STYO
	MOVE E,SENSED
	AOJE E,[HRROI C,[ASCIZ \MISSING
\]
		PUSHJ P,STYO
		JRST QTT0]
	LDB E,[202400,,SENSED]
	MOVEI D,SNSMSG
	LDB E,[242000,,SENSED]	;SIXTEEN BITS OF SENSE DATA
	MOVEI D,TAPSNS
	PUSHJ P,PBITS
	PUSHJ P,PSB
	POPJ P,0
; Disk exerciser and surface verifier

DSKT:	TDZA A,A		;ENTRY FOR RANDOM TRANSFERS
DSKTV:	SETO A,			;ENTRY FOR VERIFYING SURFACES
	MOVEM A,DSVFLG		;DISK SURFACE VERIFY FLAG
	MOVEI P,PDL-1
	PUSHJ P,RSTALL		; Reset the world
	MOVE A,DCHANA
	PUSHJ P,CSET0		;SET UP TO USE disk
	MOVEI C,[ASCIZ /
SA-10 DISK EXERCISER
/]
	SKIPE DSVFLG		; EXER OR VERIFY?
	MOVEI C,[ASCIZ /
SA-10 DISK SURFACE VERIFIER
/]
	PUSHJ P,STYO
	SETZM TIME
	SETZM TIMEC		; CLEAR RUNNING TIME COUNTERS.
	PUSHJ P,SETHI
	MOVE A,IDEVA
	MOVEM A,IDEVT
DSKTL0:	MOVSI G,-NPACKS
DSKTL1:	SETZM OFFLIN(G)		; ASSUME NOT OFF LINE
	MOVSI A,374000		; Init CHCW for complete test
	MOVEM A,CHCW(G)
	MOVEI A,0(G)		; Get the drive number
	PUSH P,G		; Save G (CHKDRV/CSET clobber it)
	PUSHJ P,CHKDRV		; Check its status
	 JRST DSKTL2		; Off line
	 JRST DSKTL3		; Write protected
	 JRST DSKTL4		; Read and write OK

DSKTL2:	POP P,G			; Restore G
	MOVE A,@CBASE+1		; Off line or serious error
	TLNE A,100000
	JRST DTSET		;IF SELECT ERROR
	SETOM OFFLIN(G)		; No, just offline.  Set code
	MOVEI D,(G)		; AND LOGICAL NAME
	MOVEI C,[ASCIZ /Logical drive %D OFF LINE.
/]
	PUSHJ P,STYO		; Print message
	MOVSI A,(1B2)		; Never allow it to be write enabled
	ANDCAM A,CHCW(G)
	SETZM UWP(G)		; And only maint cyls for now
	JRST DSKTS3		; And move on

DSKTL3:	POP P,G			; Restore G
	MOVSI A,(1B2)		; Write protected, turn off write enab
	ANDCAM A,CHCW(G)
	SETOM UWP(G)		; Read enable whole disk
	MOVEI D,0(G)		; Print message
	MOVEI C,[ASCIZ /Logical drive %D READ ONLY.
/]
	PUSHJ P,STYO
	JRST DSKTS3

DSKTL4:	POP P,G			; Restore G
	MOVEI D,0(G)		; And message
	MOVEI C,[ASCIZ /Logical drive %D WRITE ENABLED.
/]
	PUSHJ P,STYO
	SETZM UWP(G)		; Read/write OK, enable only maint cyls
	MOVEI C,[ASCIZ / Write enable whole pack (Y or N)? /]
	PUSHJ P,YORN
	CAIN B,"Y"
	 SETOM UWP(G)		; Yes, set flag
DSKTS3:	PUSHJ P,RNDAD		; SET UP ADDRESS TABLE
	MOVEM C,ADDR(G)		; IN CASE NOT RANDOM DURING TEST
	SETZM RETRYC(G)		; CLEAR RETRY COUNTER
	SETZM NREAD(G)		; CLEAR SUMMARY COUNTERS OF READS,
	SETZM NWRITE(G)		; WRITES,
	SETZM NCORDC(G)		; AND CORRECTABLE DATA CHECKS
	SETZM ERRCT(G)		; AND OTHER ERRORS
	SETZM TRK(G)		; START AT TRACK 0 IN CASE VERIFIER
	MOVSI A,(177B17!1B9!3B8)	; CLEAR WAITING STATES, VERIFIER FLAG,
	ANDCAB A,CHCW(G)	; AND VERIFIER STATE FIELD
	MOVSI A,(1B9)		; SET VERIFIER BIT IF
	SKIPE DSVFLG		; STARTED AT DSKVT
	IORM A,CHCW(G)		; ..
	AOBJN G,DSKTL1
	SETZM NOPRT		; Reenable error printing (after CHKDRV)
	MOVE A,IDEVA
	MOVEI C,[ASCIZ /
CONTROLLER ADDRESS IS %A /]
	CAME A,IDEVT
	PUSHJ P,STYO
	MOVSI A,-10
	MOVE B,IDEVA
	LSH B,-4
	IFLE CV,<DPB B,[300400,,CPGP(A)]>
	IFG CV,<DPB B,[400400,,CPGP(A)]>
	AOBJN A,.-1
	SETZM CQUIET		; Assume we report everything
	MOVEI C,[ASCIZ \Details on correctable errors (Y or N)? \]
	PUSHJ P,YORN
	CAIE B,"Y"
	 SETOM CQUIET		; No, then set the QUIET flag
;FALL THRU

;FALL THRU, ALSO BACK HERE AFTER ERRORS.
DSKT0:	MOVEI P,PDL-1		; Set up stack anew
	MOVE A,[JSR DSKI]	; Set up for disk interrupts
	MOVEM A,40+2*SA0CH
	MOVE A,[JSR APRI]	; And for clock/error interrupts
	MOVEM A,40+2*APRCH
	MCONO SA0,@RSTCHC	; Reset disk channel
IFE FTKL10,<
	CONO PI,652377		; Initialize PI's
>
IFN FTKL10,<
	CONO PI,12377
>
IFE KIFLG,<
	CONO APR,2000+APRCH	;ENABLE CLOCK
	>
IFN KIFLG,<
	CONO APR,2000+<APRCH_3>+APRCH
	>
	MOVSI A,1		; Wait for things to clear
	SOJG A,.
	MOVEI BF,0		; LIGHT-WATCHER CELL
	MOVSI G,-NPACKS
DSKT1:	MOVSI A,7		; CLEAR WAITING STATES
	ANDCAB A,CHCW(G)	; IN CONTROL WORD
	SETOM DEVL(G)
	SETZM HUNGT(G)		; NEVER STARTED DRIVE YET
	MOVEI D,0(G)		; Set up in case we print the drive no
	TLNE A,(1B14)		; Change in on-line status?
	SKIPN OFFLIN(G)		; to be off-line?
	 JRST DSKT1A		; NOPE.
	MOVSI A,(1B2!1B14)	; Turn off bit and be sure write off
	ANDCAB A,CHCW(G)
	 MOVEI C,[ASCIZ /
*** DRIVE %D NOW OFF-LINE, /]
	PUSHJ P,STYO
	PUSHJ P,PTIME
	MOVEI B,DIP0		; Start of FSM
	JRST DSKT1C		; Go set up next operation

DSKT1A:	TLNN A,(1B12)		; Read/write access change?
	 JRST DSKT1B		; No
	MOVSI A,(1B2!1B12)	; Turn off bit and be sure write off
	ANDCAB A,CHCW(G)
	MOVEI C,[ASCIZ /
*** DRIVE %D NOW READ-ONLY, /]
	PUSHJ P,STYO		; Print message
	PUSHJ P,PTIME		; And time stamp
	MOVEI B,DIP0		; Start of FSM
	JRST DSKT1C		; Go set up next operation

DSKT1B:	MOVEI B,DIP0		; INITIAL FSM FOR DRIVE
	TLNN A,(1B13)		; RETRYING?
	JRST DSKT1C		; NO.
	MOVEI B,DIP2A		; YES. START AT THE READ
	SKIPL RETRYC(G)		; UNLESS ALL COUNTED OUT
	JRST DSKT1C		; STILL TRIES LEFT. GO READ.
	MOVSI A,(1B13)		; TOO MANY. CLEAR RETRY FLAG
	ANDCAB A,CHCW(G)	; SET TO RUN CHECKER
	MOVE C,TRK(G)		; PUT IT IN THE BADSPOT TABLE
	HRL C,G			; PUT DRIVE IN LH
	MOVSI B,-NBADSP		; AND PUT RESULT IN TABLE
	SKIPL SPOTTB(B)		; FREE SLOT? (NEGATIVE)
	AOBJN B,.-1		; NO, FIND ONE
	SKIPGE B		; ONE FOUND?
	MOVEM C,SPOTTB(B)	; YES. STORE THE BAD SPOT
	MOVEI B,DIP3		; CHECKER WILL MOVE PAST THE ERROR
DSKT1C:	HRRM B,CHCW(G)
	MOVE B,CPGP(G)
	HRRI B,[0]
	TLNE A,4000
	SKIPE OFFLIN(G)
	SKIPA			; DON'T START DRIVE
	MOVEM B,DEVL(G)		; GIVE IT EMPTY CMD LIST TO GET INT
	AOBJN G,DSKT1

	MOVE A,[600000,,DEVL]
	MOVEM A,@CBASE
	MCONO SA0,@STPIEC
	MCONO SA0,@STBSYC
DSKT2:	AOS G,STDRV		; Get starting drive number for this scan
	CAIL G,NPACKS		; In range?
	 SETZB G,STDRV		; No, reset to 0
	HRLI G,-NPACKS		; And set up left half for AOBJN
DSKT3:	MOVEI A,0(G)		; Keep drive number in range
	CAIL A,NPACKS
	 HLLZS G		; Reset if too big
	MOVE A,CHCW(G)		; Now check out the chan control word
	TLNE A,(1B14)		; Change in on-line status?
	SKIPE OFFLIN(G)		; Yes, is it now off-line?
	 JRST DSKT4		; Off-line or no change
	MOVSI A,(1B2!1B14)	; Turn off bit and be sure write off
	ANDCAB A,CHCW(G)
	MOVEI C,[ASCIZ /
*** DRIVE %D NOW ON-LINE (READ TESTING ONLY), /]
	MOVEI D,0(G)		; Get the drive number
	PUSHJ P,STYO
	PUSHJ P,PTIME
	MOVEI B,DIP0		; Start of FSM
	HRRM B,CHCW(G)
	JRST FILX		; Restart the drive opns

DSKT4:	TLNE A,2
	JRST FILLIT
	TLNE A,4
	JRST CHKIT
	SKIPG B,HUNGT(G)	; SEE IF DRIVE IS HUNG
	JRST DSKT5		; NEGATIVE MEANS IDLE
	ADDI B,^D60*^D5		; TIME DRIVE IS HUNG (2 sec in ticks)
	CAMG B,TIME		; THAT LONG SINCE INT?
	JRST HUNG		; YUP
DSKT5:	AOBJN G,DSKT3
	MOVE A,TIMEC
	CAIGE A,^D60*^D60*^D15
	JRST DSKT2
	SETZM TIMEC
	MOVEI C,[ASCIZ /
TIME CHECK:  /]
	PUSHJ P,STYO
	PUSHJ P,PTIME		; REPORT TOTAL TIME
	MOVEI C,[ASCIZ /SUMMARY:

DRIVE, BYTES READ, BYTES WRITTEN, CORR'BLE DATA CKS, OTHER ERRS

/]
	PUSHJ P,STYO

	MOVEI G,0
DSKSML:	MOVE D,NREAD(G)
	ASH D,-1
	IMULI D,11		; CONVERT TO BYTES (8 BITS)
	MOVE E,NWRITE(G)
	ASH E,-1
	IMULI E,11		; CONVERT TO BYTES
	MOVE F,NCORDC(G)
	MOVE H,ERRCT(G)
	MOVEI C,[ASCIZ /  %G,    $D,    $E,    $F,   $H
/]
	PUSHJ P,STYO
	CAIGE G,NPACKS-1
	AOJA G,DSKSML
	PUSHJ P,CR
	JRST DSKT2


; Routine to reset the world
; Call:  PUSHJ P,RSTALL

RSTALL:	CONSZ TTY,20		; Make sure CTY is done
	JRST .-1
IFE KIFLG,<
	CONO APR,635550		; Clear KA CPU
	CONO PI,711577		; Clear PI's
	>
IFN KIFLG,<
	CONO APR,325300		; Clear KI CPU
	CONO PI,731577		; Clear PI's
	MOVEI A,100000		; Delay a bit
	SOJG A,.
	CONO APR,20000		; Have to be sure Auto Restart is off
	PGROFF			; Be sure paging is off
	>
	MCONO SA0,RSTSA		; Reset the SA-10
	MOVSI A,1		; Wait a bit
	SOJG A,.
	POPJ P,			; Return


FILLIT:	MOVEI A,NRETRY		; SET UP MAX COUNT IN CASE OF ERRORS
	MOVEM A,RETRYC(G)	; ..
	HRRZ A,ADDR(G)
	HRLI A,-RECL*NRPT
	MOVE B,TRK(G)
	MOVE C,CHCW(G)		; Get control word
	TLNN C,(1B2)		; Write enabled?
	 JRST FILX		; No, just finish setting up
	TLNE C,(1B9)		; WANT RANDOM, OR SURFACE VERIFIER
	JRST FILLV		; VERIFIER
FILI1:	MOVEM B,(A)
	SETCAM B,1(A)
	AOBJP A,FILX
	ROT B,1
	AOBJN A,FILI1
FILX:	MOVSI A,6
	ANDCAM A,CHCW(G)
	MOVE A,CPGP(G)
	HRRI A,[0]
	MOVEM A,DEVL(G)
	SETZM HUNGT(G)		; Clear time out til we get started again
	MCONO SA0,@STBSYC
	JRST DSKT5

FILLV:	TLNE C,(2B8)		; WORST CASE?
	JRST FILLVW		; YES
	MOVEI B,0		; NO. ZEROES OR ONES
	TLNE C,(1B8)		; ..
	SETO B,			; ONES.
	MOVEM B,(A)
	AOBJN A,.-1		; FILL WITH THIS WORD
	JRST FILX

FILLVW:	MOVSI C,-NWCPDT		; GENERATE BUFFER FULL OF WORSTCASE PAT
FILVW1:	MOVE B,WCPDAT(C)
	MOVEM B,(A)		; A WORD OF THE PATTERN
	AOBJN C,.+2		; COUNT THE SOURCE
	MOVSI C,-NWCPDT		; WRAPAROUND
	AOBJN A,FILVW1
	JRST FILX

WCPDAT:	; 28-BIT REPEATING PATTERN FROM CALCOMP CONSULTANTS

IFG CV,<	; HERE IT IS EXCEPT FOR SA10 ROTATING/SPLITTING A BYTE
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 6,0,17,13,6,15,13,6,0
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 6,0,17,13,6,15,13,6,0
>
IFLE CV,<	;AND THIS IS SAME WITH ODD WORDS SHUFFLED AS NEEDED
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 15,13,6,0,17,13,6,15,6
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 17,13,6,15,13,6,0,17,0
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 13,6,0,17,13,6,15,13,15
	BYTE (4) 6,0,17,13,6,15,13,6,0
	BYTE (4) 13,6,15,13,6,0,17,13,17
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 6,0,17,13,6,15,13,6,13
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 6,15,13,6,0,17,13,6,13
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 0,17,13,6,15,13,6,0,6
>
NWCPDT==.-WCPDAT		;LENGTH OF REPEATED BLOCK

CHKIT:	MOVE C,CHCW(G)		; SEE IF IN RETRY SEQUENCE
	TLNN C,(1B13)		; ..
	JRST CHK0		; NO.
	MOVNI D,NRETRY+1	; YES. BUT READ OK NOW, SAY SO.
	ADD D,RETRYC(G)		; COMPUT READS NEEDED
	MOVMS D			; ..
	MOVEI E,(G)		; RH DRIVE NUMBER
	MOVEI C,[ASCIZ /DRIVE %E READ OK ON PASS $D.

/]
	PUSHJ P,STYO
	MOVSI A,(1B13)		; CLEEAR RETRYING FLAG
	ANDCAM A,CHCW(G)
CHK0:	HRRZ A,ADDR(G)
	HRLI A,-RECL*NRPT
	MOVE C,CHCW(G)		; Get status word
	TLNN C,(1B2)		; Write enabled?
	 JRST CHKX		; No, just finish cleaning up
	TLNE C,(1B9)		; RANDOM OR FIXED PATTERN?
	JRST CHKV		; FIXED. VERIFY SURFACE
	SKIPGE RETRYC(G)	; PERMANENT ERROR?
	JRST CHKX		; YES. DON'T TEST DATA
	MOVE B,TRK(G)
CHK1:	CAME B,(A)
	PUSHJ P,UNDET		; UNDETECTED ERROR!!
	SETCM C,1(A)
	CAME B,C
	JRST [	ADDI A,1	; UNDETECTED ERROR. MAKE AC'S LIKE 
		SETCA B,	; IN OTHER CALLS TO ERR ROUTINE
		PUSHJ P,UNDET
		SETCA B,
		SOJA A,.+1]
	AOBJP A,FILX
	ROT B,1
	AOBJN A,CHK1
CHKX:	SETZM RETRYC(G)		; START FRESH
	JRST FILX

CHKV:	SKIPGE RETRYC(G)	; END OF PERMANENT ERROR?
	JRST CHKVX		; YES.
	TLNE C,(2B8)		; WORST CASE PATTERN?
	JRST CHKVW		; YES
	MOVEI B,0		; NO. ZEROES, OR ONES
	TLNE C,(1B8)		; ..
	SETO B,			; ONES.
	CAME B,(A)		; IS WORD CORRECT?
	PUSHJ P,UNDET		; NO. UNDETECTED ERROR.
	AOBJN A,.-2		; CHECK WHOLE BUFFER
	JRST CHKVX		; DONE

CHKVW:	MOVSI C,-NWCPDT		; COUNT THRU CORRECT DATA
CHKVW1:	MOVE B,WCPDAT(C)	; GET CORRECT DATUM
	CAME B,(A)		; IS THIS WHAT WE READ?
	PUSHJ P,UNDET		; NO. UNDETECTED ERROR
	AOBJN C,.+2		; OK, COUNT THRU GOOD DATA
	MOVSI C,-NWCPDT		; WRAP AROUND
	AOBJN A,CHKVW1
CHKVX:	AOS A,TRK(G)		; ON TO NEXT HEAD
	CAIGE A,NCYL*NSURF	; ALL DONE?
	JRST CHKVXX		; NO
	SETZM TRK(G)		; YES. ON TO NEXT PATTERN, BACK TO CYL 0
	LDB A,[POINT 2,CHCW(G),8]
	ADDI A,1
	CAIL A,3
	MOVEI A,0		; RECYCLE AFTER ALL DONE
	DPB A,[POINT 2,CHCW(G),8]
	JUMPN A,CHKVXX
	MOVEI D,(G)
	MOVEI C,[ASCIZ /FINISHED VERIFY PASS ON DRIVE %D.
/]
	PUSHJ P,STYO
CHKVXX:	JRST CHKX

DSKTLE:	MOVE A,CHAN
	MOVEI C,[ASCIZ /
TIMEOUT EXECUTING NO-OP ON CHANNEL %A /]
	PUSHJ P,STYO
	JRST DDT

DTSET:	MOVE A,IDEVA
	ADDI A,20	;STEP THROUGH CONTROLLER ADDRESSES
	ANDI A,377
	MOVEM A,IDEVA
	CAME A,IDEVT
	JRST DSKTL0	;TRY THIS ADDRESS
	MOVE A,CHAN
	MOVEI C,[ASCIZ /
NO CONTROLLER RESPONDS ON CHANNEL %A /]
	PUSHJ P,STYO
	JRST DDT

PTIME:	MOVE A,TIME		; REPORT TOTAL TIME
	IDIVI A,^D60*^D60*^D60	; HOURS TO A
	MOVE D,A
	IDIVI B,^D60*^D60	;MINUTES TO B
	MOVE E,B
	MOVEI C,[ASCIZ /TIME $D HOURS, $E MINUTES
/]
	PUSHJ P,STYO
	POPJ P,0

HUNG:	SETOM HUNGT(G)		;SO DOESN'T REPEAT
	MOVEI D,(G)
	MOVEI C,[ASCIZ /
***   DRIVE %D HUNG, /]
	PUSHJ P,STYO
	PUSHJ P,PTIME
	JRST DSKT5

APRI:	0
IFE KIFLG,<
	CONSZ APR,230110	; KA - PDL, MEM PROT, NXM, OVERFLOWS?
	>
IFN KIFLG,<
	CONSZ APR,220300	; KI - PAR, POW FAIL, IN/OUT, NXM?
	>
	JSR BAD	;NXM
	CONSZ PI,600000		; POWER FAIL or PARITY?
	JSR BAD	;PAR ERR
	CONSO APR,1000		; CLOCK?
	JEN @APRI
	AOS TIME
	AOS TIMEC
IFE KIFLG,<
	CONO APR,1000+APRCH	; Reset clock
	>
IFN KIFLG,<
	CONO APR,1000+<APRCH_3>+APRCH  ; Reset clock
	>
	JEN @APRI

UNDET:	PUSH P,C		; HERE ON UNDETECTED READ ERROR
	PUSH P,A		; OR CATASTROPHE CAUSING CHECK ROUTINE
	PUSH P,B		; TO FAIL. SAVE AC'S
	MOVEI D,(G)		; DRIVE NUMBER
	MOVE E,TRK(G)		; CYL AND HEAD
	IDIVI E,NSURF		; CYL TO E, HD TO F
	MOVEI C,[ASCIZ /
*** UNDETECTED ERROR, DRIVE %D, CYLINDER %E, HEAD %F
/]
	PUSHJ P,STYO
	MOVE D,0(P)
	MOVE A,-1(P)
	MOVE E,0(A)
	MOVEI C,[ASCIZ /    WORD SHOULD BE %D, BUT WAS %E
/]
	PUSHJ P,STYO
	PUSHJ P,PTIME
	PUSHJ P,CR2
	POP P,B
	POP P,A
	POP P,C
	SKIPE SERR		; STOP ON ERROR?
	JSR GOPR		; YES. RING FOR HUMAN OPERATOR
	POPJ P,0

BAD:	0
	CONO PI,400
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	HRRZ D,BAD
	MOVEI C,[ASCIZ /BAD ERROR FROM %D
/]
	PUSHJ P,STYO
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	SKIPN SERR
	JRST DSKT0
	JSR GOPR

GOPR:	0
	DATAI TTY,B
GOPR1:	MOVEI B,7
	PUSHJ P,TYO
	CONSO TTY,40
	JRST GOPR1
	JRST DDT



CPGP:
IFLE CV,<
	BYTE (8)320,IDEV(20)CPG0
	BYTE (8)320,IDEV+1(20)CPG1
	BYTE (8)320,IDEV+2(20)CPG2
	BYTE (8)320,IDEV+3(20)CPG3
	BYTE (8)320,IDEV+4(20)CPG4
	BYTE (8)320,IDEV+5(20)CPG5
	BYTE (8)320,IDEV+6(20)CPG6
	BYTE (8)320,IDEV+7(20)CPG7
>
IFG CV,<
	BYTE (8)IDEV,320(20)CPG0
	BYTE (8)IDEV+1,320(20)CPG1
	BYTE (8)IDEV+2,320(20)CPG2
	BYTE (8)IDEV+3,320(20)CPG3
	BYTE (8)IDEV+4,320(20)CPG4
	BYTE (8)IDEV+5,320(20)CPG5
	BYTE (8)IDEV+6,320(20)CPG6
	BYTE (8)IDEV+7,320(20)CPG7
>

; CONTROL WORDS FOR DRIVE. DISPATCH IN RH, BITS IN LH.
; SEE COMMENTS ON BIT USAGE AT DIP0
CHCW:	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0

ADRLO:	GOGO+33000		;FIRST AREA FREE FOR BUFFERS
			; SPACE TO LOAD PROG AT 1000, DDT, SYMS.
ADRHI:	777000		;FIRST NON-EX ADDR
PADRLO:	ADRLO		; Paged low address for testing
PADRHI:	1777777		; Paged high address for testing (physical)

ADDR:	BLOCK 10		; DATA AREAS PER DRIVE
OFFLIN:	BLOCK 10		; NON-ZERO IF DRIVE OFF LINE
NREAD:	BLOCK 10
NWRITE:	BLOCK 10
NCORDC:	BLOCK 10
ERRCT:	BLOCK 10		; NUMBER OF ERRORS OTHER THAN CORR-
				; ECTABLE DATA CHECKS AND STATISTICS
TRK:	BLOCK 10		; CYL*19 + HEAD OF CURRENT TRANSFER
UWP:	BLOCK 10		;USE WHOLE PACK IF NON ZERO
RETRYC:	BLOCK 10		; COUNTER FOR CORRECTABLE DATA CK'S
HUNGT:	BLOCK 10		;VALUE OF TIME WHEN INT OCCURRED.
				; MINUS ONE IF HUNG OR NOT STARTED.

DEVN:	0
ACS:	BLOCK 20
CACS:	BLOCK 20
SERR:	0
DSVFLG:	0			; DSK SURFACE VERIFIER FLAG
STDRV:	NPACKS			; Starting drive for service scan.
				; This rotates so all drives get the
				; same amount of attention.

SPOTTB:	REPEAT NBADSP,<-1>	; SPACE FOR BAD SPOTS. -1 IS FREE
	-1			; AND ONE FOR END TEST

DEVL:	-1
	0
	0
	0
	0
	0
	0
	0
	0

TIME:	0
TIMEC:	0
SENSCT:	0
DSTAT:	BLOCK 4			; COPY OF 4 WORDS FROM LOW CORE
				; ON CHANNEL COMPLETION

TYIM:	PUSHJ P,STYO
TYI:IFE FTKL10,<
	CONSO TTY,40
	JRST .-1
	DATAI TTY,B
>
IFN FTKL10,<
	SKIPN DTEMTI
	JRST .-1
	SETZM DTEMTI
	MOVE B,DTEF11
>
	ANDI B,177
	CAIE B,15		; CR typed?
	JRST TYO		; No, just echo it
	PUSH P,C		; Yes, make it CRLF
	PUSHJ P,CR
	POP P,C			; And restore the CR
	MOVEI B,15
	POPJ P,			; Return

; Routine to print a prompt string and fetch a number from the console TTY.
; Breaks on non-numeric input.
; Entry:  A = 0  Collect a decimal input
;	     -1  Collect an octal input
;	  C =    Address of string prompt
; Entry:  NUMGM  Print prompt and collect an input
;	  NUMG   Just collect the input
; Return:  +1  No number entered
;	   +2  Number returned in A
; Last character typed is saved in LSTCHR

NUMGM:	MOVEM A,NUMTYP		; Save the type conversion code
	PUSHJ P,STYO		; Print the prompt
	SKIPA
NUMG:	MOVEM A,NUMTYP		; Non-prompt entry, save the conv code
	SETZB A,NONUM		; Clear number accumulator, and collection flag
NUMG0:	PUSHJ P,TYI		; Get a character
	SKIPE NUMTYP		; Decimal?
	 JRST NUMG1		; No, octal
	CAIG B,"9"		; Decimal, digit out of range?
	CAIGE B,"0"
	 JRST NUMG2		; Yes, quit
	SETOM NONUM		; OK, set collection flag
	IMULI A,^D10		; Do decimal conversion
	ADDI A,-"0"(B)
	JRST NUMG0		; Get next digit

NUMG1:	CAIG B,"7"		; Octal, digit out of range?
	CAIGE B,"0"
	 JRST NUMG2		; Yes, quit
	SETOM NONUM		; OK, set collection flag
	LSH A,3			; Do octal conversion
	ADDI A,-"0"(B)
	JRST NUMG0

NUMG2:	MOVEM B,LSTCHR		; Save last character typed
	SKIPE NONUM		; Break char, any number entered?
	 AOS 0(P)		; Yes, return +2
	POPJ P,			; No, return +1

NONUM:	0			; Flag indicating number collected
NUMTYP:	0			; Flag for conversion type
LSTCHR:	0			; Last character typed



HTYO:	CAIL B,12
	ADDI B,"A"-"9"-1
	JRST OPT3


SMPT:	EXP 007,007,007,007,007,007,007,007
	EXP 007,007,007,007,007,007,007,007
	EXP 207,107,047,027,017,003,005,005
	EXP 007,007,007,007,006,377,017,007
SMPT1:	EXP 000,000,000,000,364,364,364,364
	EXP 364,363,070,010,364,310,070,010
	EXP 000,000,000,000,000,000,000,000
	EXP 000,000,000,000,000,000,000,000
SMPT2:	EXP 020,010,004,002,001,000,000,000
	EXP 001,020,010,004,002,000,000,000
	EXP 000,000,000,000,000,037,010,000
	EXP 000,000,000,000,000,000,000,000


;FORMAT A PACK. ASSUMES REC 0 EXISTS, WRITES 1-5
; Requests a drive number to be formatted

FMT:	MOVEI P,PDL-1
	PUSHJ P,RSTALL		; Reset the world
	MOVE A,DCHANA		;SA-10 CHAN FOR DISK
	PUSHJ P,CSET0
FMTI:	MOVEI D,NPACKS-1	; Get drive number to be formatted
	MOVEI C,[ASCIZ "
Format drive (0-$D): "]
	PUSHJ P,CPNUM		; Return subchannel,,drive
	 JRST FMTI		; Invalid input, try again
	HRRZM A,FMTDRV		; Save the drive number
	MOVE D,IDEVA		; DEVICE TO FORMAT
	ADD D,FMTDRV		; Tack in the drive number
	MOVEI F,0		; FORMAT PATTERN NUMBER. (JUST 0 NOW)
FMT0:	LSH D,^D12
	MOVE I,FMTM	;0=HA, R0 ARE GOOD; 1=WRT R0; -1=WRT HA AND R0
	;PUT IN DEV FLD
	MOVE J,RECSIZ(F)
	IMULI J,^D9
	ADDI J,1
	ASH J,-1	;J HAS SIZE IN BYTES
	LSH J,4
	MOVEI E,0
FMT1:	TRZ E,7760		; CLEAR HEAD FIELD
	MOVE H,ADRLO	;PLACE TO PUT C C H H # KL DL DL
	MOVSI C,200000	;A TIC CMD
	ADDI C,<NRPT+1>*^D20*2(H)	;LEAVE ROOM FOR DATA
	MOVEM C,FWP0
	JUMPE I,FMT1A	;IF NO SET FM NEEDED
	MOVE G,[BYTE (8)70,37]	;SET FM
	PUSHJ P,FMTS0
	MOVE G,[-1,,[BYTE (8)300]]	;ALLOW ALL
	PUSHJ P,FMTS1
FMT1A:	TRNE E,7760	;ALWAYS SEEK IF HEAD 0
	JUMPGE I,FMT1B	;OR IF WRITING HA'S
	MOVE G,[BYTE (8)70,7]	;SEEK
	PUSHJ P,FMTS0
	MOVE G,[400000-2,,[0]]	;2 BYTES OF BB
	PUSHJ P,FMTS1
	MOVSI G,-4
	PUSHJ P,FMTS1A
FMT1B:	JUMPL I,FMT1C
	JUMPG I,FMT1D
	MOVE G,[BYTE (8)70,61]	;SRCH ID EQ
	TRNE E,7760
	TLO G,1000	;SET M-T IF NOT 1ST REC
	PUSHJ P,FMTS0
	MOVSI G,-5
FMT1BR:	PUSHJ P,FMTS1A
	PUSHJ P,FMTS2
;FALLS THRU
;FALLS IN
FMT1E:	TLZ J,776000	;SET RN TO 0
FMT2:	MOVEM E,(H)
	MOVEM J,1(H)
	MOVEI A,200
	TLNN J,776000
	HRRM A,1(H)	;R0 HAS DL OF 8
	ADDI H,2
	CAML J,NRECS2(F)
	JRST FMT2A	;NO MORE RECS ON TRK
	ADD J,[2000,,0]
	MOVE G,[BYTE (8)72,35]	;SLI, WRT CKD
	PUSHJ P,FMTS0
	MOVSI G,-^D8
	PUSHJ P,FMTS1A
	JRST FMT2
FMT2A:	ADDI E,20
	LDB A,[41000,,E]
	CAMGE A,NHEDS(F)
	JRST FMT1A	;MORE TRKS ON CYL
	MOVE G,[BYTE (8)240,3]	;NOP
	PUSHJ P,FMTS0
	SETZM (C)
	MOVE A,FWP0
	PUSHJ P,SCHN	;FORMATS ONE CYL
	JRST DDT	;IF ERROR
	ADD E,[4,,0]		; COUNT A CYLINDER
	LDB A,[242000,,E]	; WHAT CYLINDER ARE WE UP TO?
	CAMGE A,NTRKS(F)
	JRST FMT1		; NOT DONE YET.
	MOVEI C,[ASCIZ /
FORMATTER DONE.
/]
	PUSHJ P,STYO
	JRST DDT

FMT1D:	MOVE G,[BYTE (8)70,71]	;SRCH HA EQ
	TRNE E,7760
	TLO G,1000	;SET M-T IF NOT 1ST TRK
	PUSHJ P,FMTS0
	MOVSI G,-4
	PUSHJ P,FMTS1A
	PUSHJ P,FMTS2
	JRST FMT1CR

FMT1C:	MOVE G,[BYTE (8)70,31]	;WRT HA
	PUSHJ P,FMTS0
	MOVE G,[400000-1,,[0]]
	PUSHJ P,FMTS1	;PUT OUT A ZERO FLAG BYTE
	MOVSI G,-4
	PUSHJ P,FMTS1A
FMT1CR:	MOVE G,[BYTE (8)72,25]	;WRITE R0
	PUSHJ P,FMTS0
	MOVSI G,-^D8
	PUSHJ P,FMTS1A
	JRST FMT1E

FMTS0:	ADD G,D
FMTS3:	MOVEM G,(C)
	ADDI C,1
	POPJ P,

FMTS2:	MOVE G,C
	SUBI G,2
	JRST FMTS3

FMTS1A:	HRR G,H
FMTS1:	HLLZ A,G
		LSH A,CNTSFT
	SKIPL G
	TLZ A,400000
	HLL G,A
	JRST FMTS3


MXRECT=40			; MAX RECORDS PER TRACK
DEVFLD=141000
; FOLLOWING 4 ARE TABLES, OF LENGTH 1 NOW, DEFINING A FORMAT OF
; A PACK. INDEXED BY F IN FMT ABOVE
RECSIZ:	RECL
NRECS2:	NRPT*2000,,0
NHEDS:	NSURF
NTRKS:	NCYL
NUTRKS:	NSCYL

FWP0:	0	;PTR TO CHNL PRGM
FMTM:	0	;FORMATTING MODE
FMTDRV:	0	; Drive to be formatted
REPEAT 0,<

;LOGICAL BLOCK NUMBERS FOR BAT BLOCKS
BATBK0==2
BATBK1==13
;BAFGO -- WRITES OR UPDATES BAT BLOCKS AND OPTIONALLY FORMATS DISKS
BAFGO:	MOVEI P,PDL-1		;INITIALIZE PDL PTR
	PUSHJ P,RSTALL		; Reset the world
	MOVE A,DCHANA
	PUSHJ P,CSET0
BAFGOA:	MOVEI C,[ASCIZ /
HOW MANY PATTERNS TO TRY? /]
	SETZ A,			; Get decimal input
	PUSHJ P,NUMGM
	 JFCL			; Just typed break char
	JUMPLE A,BAFGOA	;CHECK FOR PLAUSIBILITY
	CAIE B,15	;END WITH CR
	JRST BAFGOA	;OR ELSE
	MOVEM A,BAFMAX
	SETZM BAFF		;FORMAT-ALL FLAG
	MOVEI C,[ASCIZ /
FORMAT ALL UNITS (Y OR N)? /]
	PUSHJ P,NUMGM		; Type doesn't matter
	 SKIPA			; Just a break char
	JRST .-3		; Oops, he typed some numbers
	CAIN B,"Y"
	JRST BAFW0		;YES
BAFW:	MOVEI C,[ASCIZ /
WHAT UNITS TO HAVE BAT BLOCKS REINITIALIZED? (TYPE #,#,...CR)
/]
	PUSHJ P,STYO
	SETZM BAFWT
	MOVE A,[BAFWT,,BAFWT+1]
	BLT A,BAFWT+17		;CLEAN OUT TABLE
BAFW1:	SETZ A,			; Decimal input
	PUSHJ P,NUMG
	 JRST BAFW2A		;NO MORE NUMBERS
	CAIE B,","
	CAIN B,15	;CR
	CAIL A,20
	JRST BAFW	;TYPED SOMETHING WRONG, TRY AGAIN
	AOS BAFWT(A)
	JRST BAFW1

BAFW0:	MOVEI C,[ASCIZ /
/]
	PUSHJ P,STYO
	AOSA BAFF	;SET FORMAT-ALL FLAG
BAFW3:	AOSA A,BAFD	;SKIP TO NEXT DEVICE
BAFW2:	SETZB A,BAFD	;DRIVE #
	CAIL A,20
	JRST BAFDN	;IF DONE ALL DRIVES
	PUSHJ P,DRAVL	;IS DRIVE AVAILABLE?
	JRST BAFW3	;NO, TRY NEXT ONE
	SETZM BAFPAT	;PATTERN 0
	PUSHJ P,BAFP	;SET UP DATA
	MOVEI B,BAFTP
	PUSHJ P,BAFT	;PUT DEV ADDR IN FORMATTING CHAN PGM
	MOVEI B,BAFWP
	PUSHJ P,BAFT	;PUT DEV ADDR IN NORMAL CHAN PGM
	SETZM BAFCYL	;CYLINDER 0
	SETZM BAFHED	;HEAD 0
BAFW9:	SKIPN BAFF	;ARE WE FORMATTING?
	JRST BAFW8	;IF NOT
	MOVEI A,BAFTP
	PUSHJ P,BAFO	;RUN FORMATTING CHAN PGM
	JRST BAFW9E	;IF IT FAILS
	JRST BAFW6	;IF TRACK 0 FORMATTED OK

BAFW8:	MOVE A,BAFD	;DRIVE #
	SKIPN BAFWT(A)
	JRST BAFW4	;DON'T WRITE INITIAL BAT BLOCKS
BAFW6:	SETZM BAFWT(A)	;NO NEED TO RE-REINITIALIZE
	PUSHJ P,IBAF
	PUSHJ P,WBAT	;WRITE OUT INITIAL BAT BLOCKS
	MOVE D,BAFD	;DRIVE #
	MOVEI C,[ASCIZ /DRIVE %D BAT BLOCKS INITIALIZED
/]
	PUSHJ P,STYO
BAFW4:	PUSHJ P,RBAF	;TRY TO READ IN BAT BLOCK (EITHER ONE IF OK)
	JRST BAFW3	;LOSE, TRY ANOTHER DRIVE
	JRST BAFX1	;OK, NOW TRY ALL OTHER TRACKS

BAFW9E:	MOVE D,BAFD	;DRIVE #
	MOVEI C,[ASCIZ /CAN'T FORMAT TRACK 0 ON DRIVE %D
/]
	PUSHJ P,STYO
	JRST BAFW3	;ON TO NEXT DRIVE

BAFW2A:	MOVEI C,[ASCIZ /
/]
	PUSHJ P,STYO
	JRST BAFW2

BAFX2:	AOS B,BAFHED	;TRY NEXT HEAD
	MOVE A,BAFCYL
	CAIGE B,NSURF
	JRST BAFX3	;OK, TRY THIS TRACK
	MOVEI B,0	;NEED TO GO TO START OF NEXT CYLINDER
	AOS A,BAFCYL	;TRY NEXT CYLINDER
	CAIGE A,NSCYL	;IS IT IN NORMAL AREA OF DISK?
	JRST BAFX5	;IF YES, OK
	MOVE D,BAFPAT	;IF NO, TIME FOR NEXT PATTERN
	MOVE E,BAFD
	MOVE F,BAFCT
	MOVEI C,[ASCIZ /DONE PATTERN %D ON DRIVE %E, MARKED $F REGIONS BAD
/]
	PUSHJ P,STYO	;GIVE PROGRESS MESSAGE
	AOS A,BAFPAT	;STEP TO NEXT PATTERN
	CAML A,BAFMAX
	JRST BAFW3	;IF DONE ALL PATTERNS, ON TO NEXT DRIVE
	PUSHJ P,BAFP	;SET UP DATA FOR THIS PATTERN
BAFX1:	SETZB A,BAFCYL	;CYLINDER 0
	MOVEI B,1
BAFX5:	MOVEM B,BAFHED	;HEAD 1 (AVOID TRACK 0)
BAFX3:	MOVEI A,BAFTP	;FORMATTING CHAN PGM
	SKIPN BAFPAT	;IF PATTERN NONZERO, TRACK IS ALREADY FORMATTED
	SKIPN BAFF	;IF FORMAT-ALL MODE
	MOVEI A,BAFWP	;NORMAL WRITE-READ CHAN PGM
	PUSHJ P,BAFO	;RUN CHAN PGM
	JRST BAFY	;IF TROUBLE
	JRST BAFX2	;IF TRACK OK, ON TO NEXT TRACK
BAFY:	MOVE A,BAFCYL
	IMULI A,NSURF
	ADD A,BAFHED	;RESULT IS TRACK # WITH TROUBLE
	IMULI A,NRPT	;GET 1ST LBN IN TRACK
	MOVEM A,BAFYV
	MOVE D,BAFD	;DRIVE #
	MOVE E,BAFCYL	;CYLINDER #
	MOVE F,BAFHED	;HEAD #
	MOVE G,BAFYV	;LBN
	MOVEI C,[ASCIZ /DRIVE %D, CYL $E, HEAD $F (1ST LBN $G)
/]
	PUSHJ P,STYO
	MOVE A,BAFYV
	MOVE B,A
	ADDI B,NRPT-1	;LAST LBN IN TRACK
	HRRZ C,BAF+1	;OFFSET OF WORD PAIRS
	ADDI C,BAF
	LDB D,[POINT 9,BAF+2,17]
	ADD D,BAF+3	;COMPUTE # WDS USED BY ENTRIES
BAFY0:	JUMPE D,BAFY7	;IF TABLE IS EMPTY
BAFY1:	LDB E,[POINT 20,1(C),35]	;1ST BLOCK IN BAD REGION
	CAMLE E,B
	JRST BAFY6	;NO CONFLICT WITH THIS ENTRY
	LDB F,[POINT 9,(C),8]
	ADD F,E		;LAST BLOCK IN BAD REGION
	CAMGE F,A
	JRST BAFY6	;NO CONFLICT
	CAMN E,A
	CAME F,B
	JRST BAFY2	;IF DIFFERENT FROM OLD REGION
	JRST BAFY1X	;IF SAME AS OLD REGION

BAFY2:	MOVE G,E
	SUB G,A
	SKIPGE G
	MOVEI G,0	;AMOUNT REGION EXTENDED AT BEGINNING
	CAMGE A,E
	MOVE E,A	;1ST BLOCK OF NEW REGION
	MOVE A,B
	SUB A,F
	SKIPLE A	;AMOUNT REGION EXTENDED AT END
	ADD G,A		;TOTAL AMOUNT REGION EXTENDED
	LDB A,[POINT 9,BAF+2,8]
	ADD A,G		;TOTAL OF BAD BLOCKS
	CAIL A,1000
	JRST BAFY2F	;IF TOO MANY!!
	DPB A,[POINT 9,BAF+2,8]
	CAMLE B,F
	MOVE F,B	;LAST BLOCK OF NEW REGION
	MOVEM E,1(C)	;PUT 1ST BLOCK # INTO BAT TABLE
	SUB F,E
	CAIL F,1000
	JRST BAFY2E	;IF REGION GOT TOO BIG
	DPB F,[POINT 9,(C),8]	;LENGTH OF NEW REGION
	MOVEI C,[ASCIZ /EXPANDED EXISTING REGION
/]
	PUSHJ P,STYO
	JRST BAFY8	;ALL DONE, WRITE IT OUT

BAFY6:	ADDI C,2	;PASS OVER A WORD PAIR
	SOJA D,BAFY0	;COUNT A PAIR

;HERE IF NO RELEVANT ENTRY FOUND
BAFY7:	CAIL C,BAF+200-2
	JRST BAFY7X	;FULL!!
	MOVEM A,1(C)	;1ST ADDR INTO BAT TABLE
	MOVSI A,<NRPT-1>_11
	MOVEM A,(C)	;LENGTH-1 OF REGION INTO BAT TABLE
	MOVE A,[BYTE (9)NRPT,1]
	ADDM A,BAF+2	;INDICATE TWO MORE WORDS USED
BAFY8:	PUSHJ P,WBAT	;WRITE OUT MODIFIED BAT BLOCKS
	AOS BAFCT	;COUNT A NEW REGION FOUND BY THIS PATTERN
	JRST BAFX2	;ON TO NEXT TRACK
BAFY2E:	MOVEI C,[ASCIZ /REGION GREW TOO BIG!!
/]
	PUSHJ P,STYO
	JRST BAFX2	;TRY ANOTHER TRACK

BAFY7X:	MOVEI C,[ASCIZ /BAT TABLE FULL!!
/]
	PUSHJ P,STYO
	JRST BAFW3	;TRY ANOTHER DRIVE

BAFY1X:	MOVEI C,[ASCIZ /REGION ALREADY IN BAT TABLE
/]
	PUSHJ P,STYO
	JRST BAFX2	;ON TO ANOTHER TRACK

BAFY2F:	MOVE D,BAFD	;DRIVE #
	MOVEI C,[ASCIZ /TOO MANY BLOCKS IN BAD REGIONS ON DRIVE %D
/]
	PUSHJ P,STYO
	JRST BAFW3	;TRY ANOTHER DRIVE
BAFDN:	MOVEI C,[ASCIZ /BAT PROGRAM DONE!
/]
	PUSHJ P,STYO
	JRST DDT


;SUBROUTINE TO PUT PATTERN OF DATA INTO BAFDAT
BAFP:	MOVE A,BAFPAT	;PATTERN #
	ANDI A,3	;ALLOW ANY NUMBER OF PATTERNS BUT CHOOSE FROM 4
	MOVE B,BAFPT0(A)
	MOVEM B,BAFDAT	;1ST WORD
	MOVE B,BAFPT1(A)
	MOVEM B,BAFDAT+1	;2ND WORD
	MOVE B,BAFPT2(A)
	MOVEM B,BAFDAT+2	;3RD AND FINAL WORD
	MOVE B,[BAFDAT,,BAFDAT+3]
	BLT B,BAFDAT+217
	SETZM BAFCT	;NO ERRORS FOR THIS PATTERN
	POPJ P,

BAFPT0:	BYTE (8)314,314,314,314
	BYTE (9)111,111,111,100
	BYTE (9)666,666,666,660
	-20
BAFPT1:	BYTE (8)314,314,314,314
	BYTE (9)444,444,444,440
	BYTE (9)333,333,333,320
	-20
BAFPT2:	BYTE (8)314,314,314,314
	BYTE (9)222,222,222,220
	BYTE (9)555,555,555,540
	-20
NBPAT=.-BAFPT2
;SUBROUTINE TO PUT DEV ADDR INTO A CHAN PGM (ADDR IN B)
BAFT:	MOVE A,IDEVA	;CONTROLLER PART OF DEVICE ADDRESS
	ADD A,BAFD	;DRIVE PART
BAFT1:	LDB C,[POINT 8,(B),7]	;FLAG BYTE OF COMMAND
	JUMPE C,CPOPJ	;IF END OF CHAN PGM
	CAIN C,70
	DPB A,[POINT 8,(B),23]	;IF DEV COMMAND, PUT IN DEV ADDR
	AOJA B,BAFT1	;AND LOOK AT NEXT WORD

;SUBROUTINE TO RUN CHAN PGM -- ADDR IN A -- SKIP RETURNS IF OK
BAFO:	MOVE BF,BAFD	;DRIVE #
	LSH BF,^D9
	ADD BF,BAFPAT	;PATTERN #
	LSH BF,^D12
	ADD BF,BAFCYL	;CYLINDER #
	LSH BF,6
	ADD BF,BAFHED	;HEAD #
	MOVE B,BAFCYL	;CYLINDER #
	DPB B,[POINT 16,BAFTD,15]
	MOVE B,BAFHED	;HEAD #
	DPB B,[POINT 16,BAFTD,31]
	JRST SCHN	;RUN IT

;CHAN PGM TO FORMAT A TRACK, READ IT BACK
BAFTP:	BYTE (8)70,37	;SET FILE MASK
	-100,,[BYTE (8)300]	;PERMIT ALL
BAFTP1:	BYTE (8)70,SEEK
	400000-200,,DRAVLD	;2 BYTES OF ZEROS
	-400,,BAFTD	;THEN 4 BYTES OF CCHH
BAFTP2:	BYTE (8)70,31	;WRITE HA
	400000-100,,DRAVLD	;ANOTHER ZERO BYTE
	-400,,BAFTD		;CCHH
BAFTP3:	BYTE (8)70,25	;WRITE R0
	400000-1000,,BAFTD	;CCHH0008
	-1000,,DRAVLD		;0
BAFTP4:	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,35	;WRITE CKD
	400000-400,,BAFTD	;CCHH
	400000-400,,[ZZ_34+1100_4]	;R, KL, DL DL
	-110000,,BAFDAT	;FINALLY THE DATA PATTERN
	ZZ==ZZ+1
	>
	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,61	;SEARCH ID EQUAL
	400000-400,,BAFTD	;CCHH
	-100,,[ZZ_34]	;R
	MOVE .-3	;TRANSFER IN CHANNEL
	BYTE (8)70,6	;READ DATA
	-110000,,BAFXBF	;INTO SCRATCH BUFFER
	ZZ==ZZ+1
	>
	0
;CHAN PGM TO WRITE A TRACK AND READ IT BACK
BAFWP:	BYTE (8)70,SEEK
	400000-200,,DRAVLD	;00
	-400,,BAFTD		;CCHH
	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,61		;SEARCH ID EQUAL
	400000-400,,BAFTD	;CCHH
	-100,,[ZZ_34]		;R
	MOVE .-3
	BYTE (8)70,WRDATA
	-110000,,BAFDAT
	ZZ==ZZ+1
	>
	ZZ==1
REPEAT NRPT,<
	BYTE (8)70,61
	400000-400,,BAFTD
	-100,,[ZZ_34]
	MOVE .-3
	BYTE (8)70,6	;READ DATA
	-110000,,BAFXBF
	ZZ==ZZ+1
	>
	0
WBAT:	PUSHJ P,IBAF0	;INITIALIZE BAF TABLE FOR 1ST BAT BLOCK
	PUSHJ P,WBAF	;WRITE IT OUT
	PUSHJ P,IBAF1	;INITIALIZE FOR 2ND BAT BLOCK
WBAF:	MOVEI B,WRDATA	;WRITE DATA COMMAND
	PUSHJ P,RWBAF	;DO THE WRITE
	JRST WBAFE	;IF FAILED
	POPJ P,		;IF OK

WBAFE:	MOVE D,BAFD	;DRIVE #
	MOVEI C,[ASCIZ /CAN'T WRITE BAT BLOCKS ON DRIVE %D
/]
	PUSHJ P,STYO
	JRST DDT	;REALLY BAD NEWS

RBAF:	MOVEI A,BATBK0	;LBN OF 1ST BAT BLOCK
RBAF0:	MOVEI B,RDDATA	;READ DATA COMMAND
	MOVEM A,RBAFV	;SAVE LBN
	SETZM BAF	;WIPE OUT KEY WORDS..
	SETZM BAF+176	;..IN BAF TABLE
	PUSHJ P,RWBAF	;READ IN 1ST BAT BLOCK
	JRST RBAF3	;IF ERROR
	MOVE A,[SIXBIT /BAT/]
	MOVEI B,606060
	CAMN A,BAF
	CAME B,BAF+176
	JRST RBAF3	;IF ERROR
	JRST CPOPJ1

RBAF3:	MOVEI A,BATBK1	;LBN OF 2ND BAT BLOCK
	CAME A,RBAFV	;HAVE WE TRIED IT ALREADY?
	JRST RBAF0	;NO, GIVE IT A CHANCE
	MOVE D,BAFD	;DRIVE #
	MOVEI C,[ASCIZ /CAN'T READ GOOD BAT BLOCK ON DRIVE %D
/]
	JRST STYO	;NON-SKIP RETURN
;SUBROUTINE TO INITIALIZE BAF TABLE
IBAF:	MOVE A,[SIXBIT /BAT/]
	MOVEM A,BAF
	MOVE A,[200-6,,4]
	MOVEM A,BAF+1
	MOVE A,SADEVA	;SA-10 DEVICE CODE
	LSH A,^D9
	MOVEM A,BAF+2
	SETZM BAF+3
	MOVE A,[BAF+3,,BAF+4]
	BLT A,BAF+200-3	;PUT IN ZEROES JUST TO BE SAFE
	MOVEI A,606060
	MOVEM A,BAF+200-2
IBAF0:	SKIPA A,[BATBK0]	;LBN OF 1ST BAT BLOCK
IBAF1:	MOVEI A,BATBK1		;LBN OF 2ND BAT BLOCK
	MOVEM A,BAF+200-1
	POPJ P,

;SUBROUTINE TO READ OR WRITE BAT BLOCK
RWBAF:	ADDI A,1	;CONVERT BLOCK # TO RECORD #
	DPB A,[POINT 8,BAFPD2,23]
	DPB B,[POINT 8,BAFPG5,15]	;READ DATA OR WRITE DATA COMMAND
	MOVE A,IDEVA		;CONTROLLER ADDR
	ADD A,BAFD		;DRIVE #
	DPB A,[POINT 8,BAFPG1,23]
	DPB A,[POINT 8,BAFPG3,23]
	DPB A,[POINT 8,BAFPG5,23]
	MOVEI A,BAFPG1
	JRST SCHN		;WILL SKIP FOR GOOD RETURN
;SUBROUTINE TO DETERMINE IF DRIVE AVAILABLE -- SKIP-RETURNS IF IT IS
DRAVL:	MOVE A,IDEVA
	ADD A,BAFD		;DRIVE DEVICE ADDRESS
	DPB A,[POINT 8,DRAVLP,23]
	DPB A,[POINT 8,DRAVLQ,23]
	DPB A,[POINT 8,DRAVLR,23]
	MOVEI A,DRAVLP
SARUN:	PUSHJ P,SAGO
	HLRZ A,@CBASE+1
	TRZ A,600003
	CAIN A,60		;CHANNEL END AND DEVICE END
	JRST CPOPJ1		;IF GOOD
	MOVE A,@CBASE
	LDB A,[DEVFLD,,(A)]
	DPB A,[DEVFLD,,SCHS]
	MOVEI A,SCHS
SAGO:	HRLI A,200000
	MOVEM A,@CBASE
	MCONO SA0,@CLSTFC
	MCONO SA0,@STBSYC
SAGO1:	MCONSO SA0,170
	JRST SAGO1
	MCONO SA0,@CLSTFC
	POPJ P,

DRAVLP:	BYTE (8)70,SEEK
	-600,,DRAVLD
DRAVLQ:	BYTE (8)70,SCHIDE
	-500,,DRAVLD
	200000,,DRAVLQ
DRAVLR:	BYTE (8)50,WRDATA
	-1000,,DRAVLD
	0
DRAVLD:	0
	0
;CHAN PGM FOR RWBAF
BAFPG1:	BYTE (8)70,SEEK
	-600,,BAFPD1
BAFPG3:	BYTE (8)71,SCHIDE
	-500,,BAFPD1
	200000,,BAFPG3
BAFPG5:	BYTE (8)40
	-20000,,BAF
	0

BAFPD1:	0	;00CC
BAFPD2:	0	;HHR0
BAFWT:	BLOCK 20
BAFPAT:	0
BAFCYL:	0
BAFHED:	0
BAFCT:	0
BAFF:	0
BAFD:	0
RBAFV:	0
BAFMAX:	0
BAFYV:	0
BAF:	BLOCK 200
BAFDAT:	BLOCK 220
BAFXBF:	BLOCK 220
BAFTD:	0	;CCHH
	200
	>	; End REPEAT 0 of BAT track stuff


CPOPJ1:	AOS (P)		;SKIP RETURN
CPOPJ:	POPJ P,

; Non-interrupt routine to run a channel program
; Entry:  A = address of channel program
; Call:   PUSHJ P,SCHN
; Return: +1  Error encountered - SA-10 CONI information in SVCONI
;				  SA-10 status in STBUF and STBUF2
;				  Sense data in SENSED
;	  +2  No errors

QUIET:	0	; Flag to suppress string output (STYO)
CQUIET:	0	; Flag to suppress details on correctable errors
NOPRT:	0	; Flag to inhibit printing of simple errors
SVCPG:	0	; Save area for channel program address
SVCONI:	0	; Save area for SA-10 CONI data

SCHN:	MOVEM A,SVCPG		; Save channel program address
	HRLI A,200000		; Set up TIC to channel program
	MOVEM A,@CBASE
	MCONO SA0,@STBSYC	; Start the SA-10
SCHN0:	MCONI SA0,A		; Get CONI information
	MOVEM A,SVCONI		; Save it for posterity
	TRNE A,774000		; PI req, Par Err, NXM, or Int Enables?
	 JRST SCHSA		; Yes, bad news
	TRNN A,170		; Any status flags up?
	JRST SCHN0		; No, try again
	MCONO SA0,@CLSTFC	; Got status, clear the flag
	MOVE A,@CBASE+1
	TLNN A,163314		; Sel err, Bus par, Ctl err, PI, Attn, CU end,
				; Busy, Unit check, or Unit exception?
	 JRST CPOPJ1		; No, skip return
	MOVEM A,STBUF		; Yes, save the status word
	TLNN A,163014		; Something other than St mod, CU end, or Busy?
	 JRST SCHBSY		; No, go retry the command
	MOVE A,@CBASE+2
	MOVEM A,STBUF2
	MOVE A,@CBASE
	LDB A,[DEVFLD,,(A)]
	PUSHJ P,SCHSNS		; Go get the sense information
	MOVE A,SVCONI		; Get CONI bits from previous operation
	TLNN B,163004		; Any "serious" bits on?
	SKIPN NOPRT		; Or printing desired?
	 SKIPA			; Yes, print message
	POPJ P,			; No, return +1
SCHNX:	MOVEI C,[ASCIZ /
     !!! ERROR !!!
/]
	PUSHJ P,STYO
	PUSHJ P,PSB
	POPJ P,	;BAD NEWS, NONSKIP RETURN


; Should come here when some drive changed status and interrupted
; operation in progress.  Just retry it.
SCHBSY:	MOVE A,SVCPG		; Recover channel program address
	JRST SCHN		; And retry things


; Routine to collect drive sense information
; Entry:   A = drive id (e.g., 301)
; Call:    PUSHJ P,SCHSNS
; Return:  Sense information in SENSED

SCHSNS:	DPB A,[DEVFLD,,SCHS]	; Install drive number
	MOVE A,[MOVE SCHS]	; Set up TIC to ch pgm
	MOVEM A,@CBASE
	MCONO SA0,@STBSYC	; Start the operation
SCHSN0:	MCONSO SA0,170		; Wait for it to finish
	JRST SCHSN0
	MOVE A,@CBASE+1		; Get status data
	TLNE A,163314		; Any errors?
	 JRST   [MOVEI C,[ASCIZ \
Error collecting sense data
\]
		 PUSHJ P,STYO
		 JRST DDT]
	MCONO SA0,@CLSTFC	; Done, clear status flag
	POPJ P,


; Serious SA-10 error here

SCHSA:	MOVEI C,[ASCIZ "
!!! SA-10 error:  CONI = %D
"]
	MOVE D,SVCONI
	PUSHJ  P,STYO		; Put out message
	TRNN D,400000		; PI req?
	 JRST SCHSA0		; No
	MOVEI C,[ASCIZ "Unexpected PI request
"]
	PUSHJ P,STYO
SCHSA0:	TRNE D,300000		; Other problems?
	 PUSHJ P,DSPE1		; Go describe them
	JRST DDT		; Now bomb out


; Reset the SA-10
; Call:  PUSHJ P,SARSET

SARSET:	CONO SA0,RSTSA+CLMERR	; Do reset CONO
	MOVEI A,100		; Wait for it
	SOJG A,.
	POPJ P,			; Return

SCHS:	BYTE (8)50,4
	IOW (30,SENSED)
	0
PSB:	MOVE	F,SENSED
	AOJE	F,[HRROI C,[ASCIZ \MISSING
\]
	 	JRST	STYO]
	MOVE F,[440400,,SENSED]
	MOVEI D,6
PS0:	MOVEI E,^D8
PS1:	ILDB B,F
	CAILE B,^D9
	ADDI B,"A"-"0"-^D10
	ADDI B,"0"
	PUSHJ P,TYO
	MOVEI B,40
	TLNE F,40000
	PUSHJ P,TYO
	SOJG E,PS1
	PUSHJ P,TYO
	IBP F
	TRNE D,1
	PUSHJ P,CR
	SOJG D,PS0
	POPJ P,

PS:	PUSHJ P,PSB
	JRST DDT
; Routine to check disk drive status - does a read and write on a
; maintenance cylinder record to test the status.
; A = subchannel,,drive number
; IDEV = disk channel
; Call:  PUSHJ P,CHKDRV
; Sense data returned in SENSED
; Returns:  +1  - Drive off-line
;	    +2  - Drive write protected
;	    +3  - Drive OK for read and write

CHKDRV:	MOVE C,A		; Save the drive information
	HLRZS A			; Isolate subchannel in A
	PUSHJ P,CSET0		; Set up SA-10 addresses
	SETZ A,			; Install drive number in cmd lists
CHKDR0:	SKIPN B,CKPTR(A)	; Get a command ptr, is it 0?
	 JRST CHKDR1		; Yes, all done
	DPB C,B			; No, deposit the drive number
	AOJA A,CHKDR0		; Do them all

CHKDR1:	MOVEI A,CKPGR		; Try the read
	SETOM NOPRT		; No print outs from SCHN
	PUSHJ P,SCHN		; Run the channel program
	 PUSHJ P,CHKDRE		; Some kind of error - check it out
	AOS 0(P)		; OK, at least Read access
	MOVEI A,CKPGW		; Try the write
	PUSHJ P,SCHN
	 PUSHJ P,CHKDRE		; Some kind of error
	JRST CPOPJ1		; Now return +3


; Routine for error checking on drive access checkout
; Call:  PUSHJ P,CHKDRE

CHKDRE:	MOVE A,SVCONI		; Fetch SA-10 CONI data
	MOVE B,STBUF		; And status information
	TRNN A,700000		; Bad SA-10 error
	TLNE B,163000		; or controller error?
CHKDE0:	 JRST   [PUSHJ P,CPHRD	; Yes, complain
		 JRST DDT]
	MOVE A,SENSED		; No, look at first 4 sense bytes
	TLNE A,(BYTE(8) 064, 355)  ; Serious drive error?
	 JRST CHKDE0		; Yes, bomb out
	TLNE A,(CMDREJ!INTVEN!WPROT)	; Cmd rej, Int req, or Write prot?
	 SUB P,[1,,1]		; Yes, return directly to user
	POPJ P,			; No, return to CHKDRV


; Channel programs to check drive access status
; READ
CKPGR:	CW <070,SEEK,IDEV>	; Read program - Seek
	IOW 6, CKADR
CKPGR0:	CW <071,SCHIDE,IDEV>	; Search ID equal
	IOW 5, CKADR
	TIC CKPGR0		; Transfer back until record found
CKPGR1:	CW <040,RDDATA,IDEV>	; Read
	IOW RECL,ORGBUF
	0

; WRITE
CKPGW:	CW <071,SCHIDE,IDEV>	; Write pgm - Search ID equal
	IOW 5, CKADR
	TIC CKPGW		; Transfer back until record found
CKPGW0:	CW <040,WRDATA,IDEV>	; Write
	IOW RECL,ORGBUF
	0

; SEEK/SEARCH ID EQ DATA
CKADR:	BYTE (16) 0, NCYL-1	; 00CCHHR for maint cylinder
	BYTE (16)0 (8)1		; Head 0, record 1

; Byte pointers to install drive address in chan pgms
CKPTR:	POINT 4,CKPGR,23	; Read pgm - SEEK
	POINT 4,CKPGR0,23	; Read pgm - SEARCH ID EQ
	POINT 4,CKPGR1,23	; Read pgm - READ DATA
	POINT 4,CKPGW,23	; Write pgm - SEARCH ID EQ
	POINT 4,CKPGW0,23	; Write pgm - WRITE DATA
	0			; End of list

CMDREJ=1B0		; Command reject
INTVEN=1B1		; Intervention required
WPROT=1B14		; Write protect
; Routine for hard error in selecting disk controller
; SA-10 status is printed after message in octal
; Call:  PUSHJ P,CPHRD

CPHRD:	MOVE D,STBUF		; Get status data from Sa-10
	MOVEI C,[ASCIZ "
!!! Hard error selecting disk controller: %D
"]
	PUSHJ P,STYO
	POPJ P,


; Routine to get drive number
; Prompt message in C
; Call:  PUSHJ P,CPNUM
; Returns +1 if error
;	  +2 if success (DCHAN,,drive no in A)

CPNUM:	SETZ A,			; Request decimal input
	PUSHJ P,NUMGM		; Print his preamble and get number
	 JRST CPNUM0		; No number typed, error
	CAIN B,177		; Did he hit delete?
	 JRST   [MOVEI C,[ASCIZ \ XXX \]	; Yes
		 PUSHJ P,STYO
		 SETZ C,
		 JRST CPNUM]	; Wipe that one and try again
	CAIG B,40		; Some ctl char or blank?
	CAIL A,NPACKS		; And drive in range?
	 JRST CPNUM0
	PUSHJ P,CONDCR		; OK, be sure we have a new line
	HRLI A,DCHAN		; Set up disk channel,,drive in A
	JRST CPOPJ1		; Return +2

CPNUM0:	MOVEI C,[ASCIZ \   Invalid response!
\]				; Error, print message
	PUSHJ P,STYO
	POPJ P,			; Return +1



; Routine to output BELL to TTY
; Call:  PUSHJ P,BELL

BELL:	MOVEI B,7		; Set to print bell
	PUSHJ P,TYO
	MOVEI B,-1		; Now wait for it to hit
	SOJG B,.
	POPJ P,


; Routine to terminate an input from TTY.  A valid ending is any
; control character or blank.  A delete means kill the input to here.
; Anything else is illegal.
; Call:   PUSHJ P,ENDIT
; Return: +1  - non-terminating character typed
;	  +2  - delete (177) typed
;	  +3  - valid terminator

ENDIT:	PUSHJ P,TYI		; Get another TTY char
	MOVEM B,LSTCHR		; Save it
	CAIG B,40		; Valid terminator?
	 JRST   [PUSHJ P,CONDCR	; Yes, be sure we have a new line
		 AOS 0(P)	; Step return by 1
		 JRST ENDIT0]	; And again to return +3
	CAIE B,177		; Was it a delete?
	 POPJ P,		; No, return +1
	MOVEI C,[ASCIZ \ XXX \]	; Delete, do indicator
	PUSHJ P,STYO
ENDIT0:	MOVE B,LSTCHR		; Reinstall last char
	SETZ C,			; Clear message AC
	JRST CPOPJ1		; And return +2 or +3
	


; Routine to return YES or NO choice.
; Entry:   C = adr of prompt string
; Call:    PUSHJ P,YORN
; Return:  B = Upper case Y or N

YORN:	PUSH P,C		; Save prompt
YORN0:	MOVE C,0(P)		; Recover header string
YORN1:	PUSHJ P,NUMGM		; Get some input
	 SKIPA			; OK, none numeric
YORN2:	JRST   [MOVEI C,[ASCIZ \  ??? Invalid response
\]
		PUSHJ P,STYO
		JRST YORN0]	; Try again
	TRZ B,40		; Upper case only
	CAIE B,"Y"		; YES response?
	CAIN B,"N"		; Or NO response
	 SKIPA			; OK, see if he really means it
	JRST YORN2		; Neither, don't screw around
	MOVEM B,D		; Save the response
	PUSHJ P,ENDIT		; Get a terminator
	 JRST YORN2		; Invalid
	 JRST YORN1		; He changed his mind
	MOVE B,D		; Restore the response
	POP P,C			; Clear the header adr
	POPJ P,			; And return
REPEAT 0,<

PDEV==16	;PRINTER DEVICE CODE
PBUFLB==^D132	;NUMBER CHARS PER LINE
PBUFL==PBUFLB/4	;WORDS OF PRINT BUFFER
UCBLB==^D240	;NUMBER OF LOGICAL CHARS ON CHAIN
UCBL==UCBLB/4	;WORDS FOR UCB BUFFER

DEFINE UCS2 (A,B,C,D)
<BYTE (8)"A","B","C","D">

DEFINE UCS1 (AA,BB,CC)
<UCS2 1,2,3,4
UCS2 5,6,7,8
UCS2 9,0,X,Y
UCS2 /,S,T,U
BYTE (8)"V","W",AA,BB
BYTE (8)CC,"*",",","="
UCS2 J,K,L,M
UCS2 N,O,P,Q
UCS2 R,-,Z,(
UCS2 A,B,C,D
UCS2 E,F,G,H
UCS2 I,+,.,)
>

	SALL
UCB:	UCS1 137,42,"$"
	UCS1 74,73,"#"
	UCS1 "?",76,40
	UCS1 "]","'","&"
	UCS1 "[",":","%"
UCBE:	UCS1 137,42,"$"


PAT0:	UCS2 A,B,C,D
	UCS2 E,F,G,H
	UCS2 I,J,K,L
	UCS2 M,N,O,P
	UCS2 Q,R,S,T
	UCS2 U,V,W,X
	UCS2 Y,Z,0,1
	UCS2 2,3,4,5
	UCS2 6,7,8,9
	BYTE (8)"/","*",",","="
	BYTE (8)"-","(","+","."
	BYTE (8)")",137,42,"$"
	BYTE (8)74,73,"#","?"
	BYTE (8)76,40,"]","'"
	BYTE (8)"&","[",":","%"

	XALL

PBUF:	BLOCK PBUFL
PBUFE:

RIP0:	AOS C,PPOS
	MOVE B,[441000,,PBUF]
	DATAI 0,A
	ANDI A,177
	CAIL A,3
	JRST RIP2
	SOJG A,RIP3
	MOVEI D,^D45
	SKIPL A
	MOVEI D,^D60
RIP1:	AOS E,C
	IDIV E,D
	ROT F,-2
	MOVE E,PAT0(F)
	LSH F,-^D31
	LSH E,-^D28(F)
	IDPB E,B
	CAME B,[041000,,PBUFE-1]
	JRST RIP1
	POPJ P,

RIP2:	IDPB A,B
	CAME B,[041000,,PBUFE-1]
	JRST RIP2
	POPJ P,

RIP3:	IMULI C,43
RIP3A:	MOVEI G,3
RIP4:	AOS E,C
	IDIVI E,^D288
	ROT F,-2
	MOVE E,UCB(F)
	LSH F,-^D31
	LSH E,-^D28(F)
	IDPB E,B
	SOJG G,RIP4
	CAME B,[041000,,PBUFE-1]
	SOJA C,RIP3A
	POPJ P,

PTST:	MOVEI P,PDL-1
	PUSHJ P,RSTALL	; Reset the world
	MOVE A,PCHANA	;SA-10 CHANNEL FOR PRINTER
	PUSHJ P,CSET0
	MOVEI A,PRTI
	PUSHJ P,PTSTG
PTST1:	PUSHJ P,RIP0
	MOVEI A,PRGO
	PUSHJ P,PTSTG
	JRST PTST1

PTSTG:	HRLI A,200000
	MOVEM A,@CBASE
	MCONO SA0,@STBSYC
PTSTG0:	MCONSO SA0,170
	JRST PTSTG0
	MOVE A,@CBASE+1
	TLNE A,163310
	JRST DDT
	MCONO SA0,@CLSTFC
	POPJ P,

PRTI:	BYTE (8)260,353,PDEV
	BYTE (8)260,163,PDEV
	BYTE (8)70,373,PDEV
	IOW (360,UCB)
	BYTE (8)240,3,PDEV
PRTIE:	0
PRGO:	BYTE (8)70,11,PDEV
	IOW (PBUFLB,PBUF)
	BYTE (8)240,3,PDEV
PRGOE:	0
PPOS:	0
	>	; End REPEAT 0 for printer test
; Tape drive exerciser

QTT:	SETOM TAPF		;FOR ERROR ROUTINE
	SETZM RECDNO		;CLEAR COUNTERS
	SETZM REWNO		; OF RECORDS, REWINDS, WRITE ERRS
	SETZM WERRNO		; ..
	MOVEI P,PDL-1
	PUSHJ P,RSTALL		; Reset the world
	MOVE A,TCHANA	;SA-10 CHAN FOR TAPE
	PUSHJ P,CSET0
	MOVEI C,[ASCIZ /
SA-10 MAGNETIC TAPE EXERCISER
/]
	PUSHJ P,STYO
QTTI:	MOVEI C,[ASCIZ /Unit to be tested: /]
	MOVEI A,0
	PUSHJ P,NUMGM
	 JRST QTTI		; Error, must enter a number
	CAIL A,NTAPES		; In range of on-line units?
	 JRST QTTI		; No
	DPB A,[POINT 4,TDEV,35]	; Install it
QTT0:	MCONO SA0,RSTSA	;RESET, START CLOCK
	MOVEI P,PDL-1	;STACK
	MOVNI A,^D10000
	AOJL A,.	;DELAY A BIT AFTER RESET
	SETZB I,K	;START AT REC 0
	MOVE A,TDEV	;SET DEVICE NUMBER OF TAPE ON IBM BUS
	DPB A,[DEVFLD,,TREW]
	DPB A,[DEVFLD,,TERG]
	DPB A,[DEVFLD,,TCP0]	;SET CHANNEL PGM FOR PROPER DEV
	DPB A,[DEVFLD,,TCP0W]
	DPB A,[DEVFLD,,TCP1]
	DPB A,[DEVFLD,,TCP2]
	MOVN A,KTRECL		;MINUS LENGTH OF RECORD
	ADDI A,7
IFLE CV,<
	ASH A,2>		;SIXTEEN BIT WD CT
IFG CV,<
	ASH A,6>
	HRLM A,TCP0B		;SET CHANNEL PROGRAM LENGTHS
	MOVN A,KTRECL
	ADDI A,13
IFLE CV,<
	ASH A,2>
IFG CV,<
	ASH A,6>
	HRLM A,TCP2B		; ..
	SETZM F7TK	;ASSUME NINE TRACK DRIVE
	PUSHJ P,TSENSE	;GET THE DRIVE SENSE DATA
	MCONO SA0,@CLSTFC	;CLEAR THE INTERRUPT FLAG
	MOVE A,SENSED+0	;7 TRACK BIT
	TLNE A,100	; ..
	SETOM F7TK	;IT IS A 7 TRACK DRIVE
	MOVEI A,303	;MODE SET FOR 1600 PE 9 TK
	SKIPGE F7TK	;UNLESS 7 TRACK,
	MOVEI A,223	;MAKE IT 800 BPI, ODD, NO XLATORS
	DPB A,[241000,,TCP0]
	PUSHJ P,TGB	;FILL FIRST BUFFER (REC 0)
	PUSHJ P,TGO	;START FIRST OPER
	;FALLS THROUGH

;FALLS IN
QTT1:	MOVEI I,1(K)	;GENERATE DATA FOR REC N+1
	PUSHJ P,TGB
	PUSHJ P,TWT	;WAIT FOR COMPLETION ON REC N
	ADDI K,1	;NOW ON NEXT REC
	PUSHJ P,TGO	;START IT
	MOVEI I,-1(K)	;SET TO CHECK DATA ON N-1
	PUSHJ P,TCB	;CHECK IT
	JRST QTT1	;KEEP GOING

TGB:	TDZA J,J	;J=0 FOR GENERATE
TCB:	MOVEI J,1	;J=1 FOR CHECK
	MOVN G,KTRECL		;LENGTH OF RECORD
	MOVSI G,(G)		;AOBJN COUNTER
	HRR G,ADRLO	;SETUP FOR BUF 0
	TRNN I,1	;SKIP IF ODD REC
	JRST .+3	;EVEN. DON'T OFFSET
	ADD G,KTRECL	;STEP UP TWO BUFFERS
	ADD G,KTRECL	; ..
	MOVE D,I	;USE REC # FOR SEED WORD
	MOVE C,KTRECL	;POINTER TO SECOND BUFFER OF PAIR (READ)
	HRLI C,G	;INDEX BY AOBJN COUNT
	IMUL D,[175*175*175*175]
TGB1:	XCT TGB3(J)	;STORE OR CHECK DATA (MOVEM OR CAMN)
	JRST TGB2	;OK
	MOVE E,@C	;ERROR, GET BAD WORD
	HLRO F,G	;- REMAINING COUNT
	ADD F,KTRECL	;GET INDEX TO READ WORD
	MOVEI C,[ASCIZ /DATA ERR, REC=%I, WD=%F, WROTE=%D, GOT=%E
/]
	PUSHJ P,STYO
	JRST QTT0	;START TEST OVER
;I.E., TOTAL ABORT ON ANY DATA FAILURE

TGB2:	TLNN D,200000
	TLC D,400000	;FEEDBACK SHIFT REGISTER TYPE RANDOMIZER
	ROT D,1
	AOBJN G,TGB1	;LOOP FOR EACH WORD OF REC
	POPJ P,

TGB3:	MOVEM D,(G)		;XCT'ED FOR DATA GENERATE
	CAMN D,@C		;XCT'ED FOR DATA CHECK

TGO:	AOS RECDNO		;STARTING ANOTHER RECORD
	MOVE A,[MOVE TCP0]	;I.E., TCH TCP0. SKIP REWIND
	MOVEM A,@CBASE	;SET UP PTR TO CHAN PGM, BASE FOR THIS CHAN
	LDB A,[200,,K]		;DECIDE PACKING MODE FROM RECD NO.
	MOVE A,TGOT(A)		;TOP BYTE FOR READ COMMAND
	DPB A,[341000,,TCP2]	;PUT IN READ COMMAND
	ADDI A,22		;ADD CHAIN AND SLI BITS
	DPB A,[341000,,TCP0W]	;PUT IN WRITE COMMAND, MATCHING FORMAT.
	MOVE A,ADRLO
	TRNN K,1		;WHICH BUFFER? (ODD/EVEN REC)
	JRST .+3		;EVEN. FIRST PAIR
	ADD A,KTRECL		;ODD. SECOND PAIR. SKIP 2
	ADD A,KTRECL		; ..
	HRRM A,TCP0A	;PUT IN CHAN PGM
	ADDI A,7
	HRRM A,TCP0B	; SECOND OF TWO WRITE  POINTERS
	SUBI A,7
	ADD A,KTRECL		;AND SECOND OF PAIR IS FOR READING
	HRRM A,TCP2A	;SETUP READ ADDR
	ADDI A,13
	HRRM A,TCP2B	; SECOND READ POINTER
	MCONO SA0,@STBSYC	; SPIN!
	POPJ P,

TGOT:	EXP 40,140,150,140	;WORD, NAT, TCOMPAT, NAT.

; NON-PI WAIT LOOP

TWT:	MCONSZ SA0,PARERR+NXM
	JRST TWME	;MEM ERR, BAD NEWS
	MCONSO SA0,170
	JRST TWT	;WAIT FOR SOME ACTION
	LDB A,[DEVFLD,,@CBASE+1]	; GET DEVICE CAUSING INTERRUPT
	CAME A,TDEV		;IS IT THE TAPE?
	JRST TWE	;UNEXPECTED DEVICE CAUSED TROUBLE
	MOVE A,@CBASE+1	;GET STATUS
TWT1:	TLNE A,163010
	JRST TWE	;BAD BITS ON
	TLNE A,4
	JRST TWUX	;UNIT EXCEPTION, PROBABLY EOT
	TLNE A,100
	JRST TWBSY	;CONTROL BUSY OR STATUS PENDING
	TLNE A,200
	JRST TWRST	;CU END, RESTART
	TLNN A,20
	JRST TWE	;NO DEVICE END IN STATUS
	TLNN A,40
	JRST TWRST	;DEVICE END ALONE
	HRRZ A,@CBASE+2	;LOOKS OK. CHECK THAT WHOLE PGM WAS DONE
	CAIE A,TCPE+1
	JRST TWE	;WASN'T
;HERE IF ALL IS WELL
TWTX:	MCONO SA0,@CLSTFC	; CLEAR STATUS FLAG
	POPJ P,

TDEV:	TUNIT		;THIS GOES INTO CHAN CMDS BELOW
KTRECL:	TRECL		;LENGTH OF RECORDS IN TAPE TEST
TREW:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, REWIND OR BACKSPACE
TERG:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, NOP OR ERG
TCP0:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, SET MODE
TCP0W:	BYTE (8)162,1	;GO, CHAIN, SLI, WRITE
TCP0A:	IOWC (7,0)	;BFR ADDR PLUGGED IN RH THIS WD
TCP0B:	IOW (TRECL-7,0)
TCP1:	BYTE (8)260,47	;NO MEM XFER, GO, CHAIN, BACKSPACE BLOCK
TCP2:	BYTE (8)140,2	;GO, READ
TCP2A:	IOWC (13,0)
TCP2B:	IOW (TRECL-13,0)
TCPE:	0		;HALT

TWRST:	MCONO SA0,@CLSTFC
	MCONO SA0,@STBSYC	; TRY OPERATION AGAIN
	JRST TWT	;AND WAIT FOR RESULTS

TWBSY:	TLNE A,260
	JRST TWRST	;JUST PENDING STATUS, TRY AGAIN
	MCONO SA0,@CLSTFC
	JRST TWT	;REALLY BUSY, WAIT FOR COMPLETION

TWUX:	HRRZ A,@CBASE+2
	CAIE A,TCP1		; PC POINTING AFTER THE WRITE?
	JRST TWE	;BOMBED IN WRONG PLACE, ERROR
	AOS D,REWNO	;COUNT REWINDS
	MOVE E,RECDNO	;TYPE SUMMARY FOR PASS
	MOVEI C,[ASCIZ /END OF TAPE, PASS $D, $E RECORDS.
/]
	PUSHJ P,STYO
	MOVEI A,7	;REWIND CMD
	MOVEI B,3	;NOP CMD
TWUX1:	DPB A,[241000,,TREW]	;BACK HERE ON WRITE ERR TOO
	DPB B,[241000,,TERG]
	MOVEI A,TREW
	HRRM A,@CBASE	;SET TO REWIND OR ERASE TAPE, IF
			; WRITE ERROR,  AND TRY AGAIN
	JRST TWRST

TWME:	PUSHJ P,TSPE1	;TYPE MESSAGE
	JRST QTT0

TWE:	MOVE A,@CBASE+1
	TLNN A,10
	JRST TWEX	;OTHER THAN UNIT CHECK, GIVE UP
	HRRZ A,@CBASE+2	;WHAT WAS CHANNEL PC AT FAILURE?
	CAIE A,TCP1	;WRITE ERROR?
	JRST TWEX	;FAILURE NOT ON WRITE CMD, GIVE UP
	PUSH P,@CBASE+1	;YES. TRY TO RECOVER
	PUSH P,@CBASE+2
	PUSHJ P,TSENSE	;GET SENSE BYTES FROM TAPE UNIT
	LDB A,[242000,,@CBASE+1]
	CAIE A,14
	JRST TWEX1	;NOT CHEND+DEVEND, GIVE UP
	LDB A,[341000,,SENSED]	;FIRST BYTE OF SENSE DATA
	CAIE A,10
	JRST TWEX1	;NOT JUST A DATA CHK
	POP P,@CBASE+2	;DATA ERROR ON WRITE. TRY TO
			; ERASE GAP, RE-WRITE.
	POP P,@CBASE+1	;MOSTLY JUST TO RESTORE PDL
	MOVE E,RECDNO	;REPORT THE WRITE ERROR.
	AOS D,WERRNO
	MOVEI C,[ASCIZ /WRITE ERROR # $D, RECORD $E.
/]
	PUSHJ P,STYO
	MOVEI A,47	;BACKSPACE
	MOVEI B,27	;ERASE GAP
	JRST TWUX1	;GO TRY TO RECOVER

TSENSE:	MOVEI A,PSENSE	;GET SENSE BITS TO EXAMINE ERROR
			; (NEW CHANNEL PROGRAM)
	HRRM A,@CBASE	;SETUP TO DO SENSE
	MOVE A,TDEV
	DPB A,[DEVFLD,,PSENSE]	;ON RIGHT DEV
	MCONO SA0,@STBSYC
	MCONO SA0,@CLSTFC	;DO IT
TSENS1:	MCONSO SA0,170
	JRST TSENS1	;WAIT FOR SENSE DATA
	POPJ P,0

TWEX1:	POP P,@CBASE+2	;RESET STATUS FOR MESSAGE
	POP P,@CBASE+1
TWEX:	SETOM TAPF	;TELL ERR ROUTINE ITS TAPE
	PUSHJ P,TSPE1	;TYPE MESSAGE
	JRST QTT0	;RESTART WHOLE TAPE ROUTINE AT RECORD 0

TAPF:	0
TAPSNS:	[ASCIZ /NOT CAP/]
	[ASCIZ /FILE PROT/]
	[ASCIZ /WRT STAT/]
	[ASCIZ /LD POINT/]
	[ASCIZ /7 TRK/]
	[ASCIZ /TU ST B/]
	[ASCIZ /TU ST A/]
	[ASCIZ /NOISE/]
	[ASCIZ /DATA CONV CHK/]
	[ASCIZ /WC ZERO/]
	[ASCIZ /OVERRUN/]
	[ASCIZ /DATA CHK/]
	[ASCIZ /EQUIP CHK/]
	[ASCIZ /BUS OUT CHK/]
	[ASCIZ /INTERVENTION REQ/]
	[ASCIZ /COMMAND REJECT/]

RECDNO:	BLOCK 1
REWNO:	BLOCK 1
WERRNO:	BLOCK 1
F7TK:	BLOCK 1

NITX==1
NTICKS==^D5000
LSTBUF==20
PSEEK:	120034000000+<IDEV_14>	;SEEK, BYTE MODE
	IOW 6,SEEKD
	0
SEEKD:	0
	0
PSENSE:	120020000000+<IDEV_14>	;SENSE
	IOW 30,SENSED		;24 BYTES OF SENSE DATA
	0
SENSED:	BLOCK 6
STBUF:	BLOCK LSTBUF
STBUF2:	BLOCK LSTBUF
IAR:	0
BPLOC:	-1

	EXTERN .JBREL
IOLIST:	EXP 0,0

SUPER:	OPEN 1,[EXP 17,SIXBIT /SUPER/,0]
	HALT .
	MTAPE 1,1
	MTAPE 1,0
	MOVN A,.JBREL
	MOVSI A,GOGO(A)
	HRRI A,GOGO-1
	MOVEM A,IOLIST
	OUT 1,IOLIST
	SKIPA
	HALT .
	RELEAS 1,
	EXIT
SUPER0:	0
SUPER1:	0


PPP=PUSHJ P,PWORLD

PWORLD:	PUSHJ P,STEPX1
	MOVSI D,-5
PW0:	MCONO SA0,@PW0T1(D)
	MOVE C,PW0T2(D)
	PUSHJ P,STYO
	MDATAI SA0,A
	TRNN D,-1
	ANDI A,1777
	PUSHJ P,OPT
	AOBJN D,PW0
	MCONO SA0,RDCCI
	MOVSI D,-4
PW1:	MOVE C,BTIMT(D)
	PUSHJ P,STYO1
	MDATAO SA0,BTIMD(D)
	MDATAI SA0,A
	LDB A,[121000,,A]
	PUSHJ P,OPT
	AOBJN D,PW1
	MOVSI D,-4
	MOVEI E,040000
PW2:	MOVE C,PCWT(D)
	PUSHJ P,STYO1
	MOVE C,[301000,,A]
	ADDI E,400
PW2A:	MDATAO SA0,E
	MDATAI SA0,B
	LSH B,-12
	IDPB B,C
	ADDI E,400
	TRNE E,1400
	JRST PW2A
	LSH A,-4
	PUSHJ P,OPT
	AOBJN D,PW2
	MOVSI D,-4
	MOVEI E,140002
PW3:	MOVE C,REGT(D)
	PUSHJ P,STYO1
	MOVE C,[441000,,A]
PW3A:	MDATAO SA0,E
	MDATAI SA0,F
	LSH F,-12
	IDPB F,C
	TRNE E,2000
	JRST PW3B
	ADDI E,400
	JRST PW3A

PW3B:	LSH A,-4
	LSHC A,4
	PUSHJ P,OPT
	ADDI E,6000
	AOBJN D,PW3
	MOVEI C,[ASCIZ \
TDS0=\]
	PUSHJ P,STYO
	MDATAI SA0,A
	LDB A,[100400,,A]
	PUSHJ P,OPT
CR:	MOVEI C,[ASCIZ \
\]
STYO:	JUMPE C,CPOPJ		; If nothing there, just return
	SKIPE QUIET		; Don't want output?
	 POPJ P,		; Yes, just return
	HRLI C,440700
STYO1:	ILDB B,C
	CAIN B,"%"
	JRST STYO2
	CAIN B,"$"
	JRST STYO3		;DECIMAL TYPEOUT
	CAIN B,"\"
	JRST STYO4		;HEX TYPEOUT
	JUMPE B,CPOPJ
	PUSHJ P,TYO
	JRST STYO1

STYO2:	ILDB B,C
	MOVE A,-100(B)
	PUSHJ P,OPT
	JRST STYO1
STYO3:	ILDB B,C
	MOVE A,-100(B)
	PUSHJ P,DPT
	JRST STYO1
STYO4:	ILDB B,C
	MOVE A,-100(B)
	PUSHJ P,HPT
	JRST STYO1

CR4:	PUSHJ P,CR2
CR2:	PUSHJ P,CR
	JRST CR

; Conditional carriage return
CONDCR:	PUSH P,A
	MOVE A,LSTCHR		; Get last char typed
	CAIE A,15		; If it was not cr
	 PUSHJ P,CR		; Do one
	POP P,A
	POPJ P,

OPT:	TLNN A,-1
	JRST OPT1
	PUSH P,A
	HLRZS A
	PUSHJ P,OPT2
	POP P,A
	MOVEI B,54
	PUSHJ P,TYO
	PUSHJ P,TYO
OPT1:	HRRZS A
OPT2:	IDIVI A,10
	JUMPE A,OPT3
	HRLM B,(P)
	PUSHJ P,OPT2
	HLRZ B,(P)
OPT3:	ADDI B,60
	CAILE B,"9"
	ADDI B,"A"-"9"-1
TYO:
IFE FTKL10,<
	CONSZ TTY,20
	JRST .-1
	SKIPE QUIET		; No printout wanted?
	 POPJ P,		; Yes, just return
	DATAO TTY,B
	CAIE B,12
	POPJ P,
	MOVNI B,^D10000
TYOF0:	CONSO TTY,20
	AOJL B,TYOF0
	JUMPGE B,TYOF9
	SETCM B,TYOFIL
	MOVEM B,TYOFCT
	MOVEI B,0
TYOF1:	AOSL TYOFCT
	JRST TYOF9
	PUSHJ P,TYO	;A NULL AS FILLER
	JRST TYOF1

TYOF9:	MOVEI B,12
	POPJ P,

TYOFIL:	4	;# OF FILL CHARACTERS TO DO AFTER L.F.
TYOFCT:	0
>
IFN FTKL10,<
	SETZM DTEMTD
	PUSH P,B
	ANDI B,177
	MOVEI B,.DTMTO(B)
	MOVEM B,DTECMD
	CONO DTE,TO11DB
	SKIPN DTEMTD
	JRST .-1
	POP P,B
	POPJ P,
>

DPT:	MOVEI B,"-"
	SKIPGE A
	PUSHJ P,TYO
	MOVMS A
DPT1:	IDIVI A,12
	JUMPE A,OPT3
	HRLM B,(P)
	PUSHJ P,DPT1
	HLRZ B,(P)
	JRST OPT3

HPT:	MOVEI B,0
	ROTC A,-4
	ROT B,4
	JUMPE A,OPT3
	HRLM B,(P)
	PUSHJ P,HPT
	HLRZ B,(P)
	JRST OPT3

SETSAA:	MOVE DD,SADEVA
	LSH DD,-2
	DPB DD,[320700,,DCONO]
	DPB DD,[320700,,DCONI]
	DPB DD,[320700,,DDATAO]
	DPB DD,[320700,,DDATAI]
	POPJ P,

DCONO:	CONO SA0,(DD)
DCONI:	CONI SA0,DD
DDATAO:	DATAO SA0,DD
DDATAI:	DATAI SA0,DD

IDEVA:	IDEV	;CONTROLLER ADDRESS FOR DISK TEST
BASEA:	BASE	;BASE ADDRESS FOR SA-10 FIXED DATA BLOCK
DCHANA:	DCHAN	;SA-10 CHANNEL FOR DISK
PCHANA:	PCHAN	;SA-10 CHANNEL FOR PRINTER
TCHANA:	TCHAN	;SA-10 CHANNEL FOR TAPE
SADEVA:	SA0	;SA-10 DEVICE ADDRESS

STATCT:	0
IDEVT:	0

BTIMT:	440700,,[ASCIZ \
BUS= \]
	440700,,[ASCIZ \
TAG= \]
	440700,,[ASCIZ \
INS= \]
	440700,,[ASCIZ \
MISC=\]

BTIMD:	144000
	145000
	145400
	142400

PCWT:	440700,,[ASCIZ \
WC=  \]
	440700,,[ASCIZ \
CA=  \]
	440700,,[ASCIZ \
PC=  \]
	440700,,[ASCIZ \
A3=  \]

REGT:	440700,,[ASCIZ \
R0=  \]
	440700,,[ASCIZ \
R1=  \]
	440700,,[ASCIZ \
R2=  \]
	440700,,[ASCIZ \
R3=  \]

PW0T1:	RDCCI
	RDMA
	RDMBL
	RDMBR
	RDCONI

PW0T2:	[ASCIZ /
IARB=/]
	[ASCIZ /
MA=  /]
	[ASCIZ /
MBLT=/]
	[ASCIZ /
MBRT=/]
	[ASCIZ /
CONI=/]

CSET0:	MOVEM A,CHAN
	SETZM NOPRT		; Allow printing of sense messages
	JRST CSET3

CSET:	MOVEM A,CHAN
	PUSHJ P,STEP0	;STOP CLOCK
	MOVEI A,43700
	PUSHJ P,C0XCT
	MOVEI A,42260
	PUSHJ P,C0XCT
	MCONO SA0,RDMA
	MDATAI SA0,A	;READ IN BASE ADDRESS SWITCHES
	MCONO SA0,400000	;START CLOCK
	CAMN A,BASEA
	JRST CSET2	;IF BASE ADDRESS IS AS EXPECTED
	MOVEM A,BASEA	;OTHERWISE CHANGE IT
	MOVEI C,[ASCIZ /
BASE ADDR SW = %A /]
	PUSHJ P,STYO	;AND INFORM OPERATOR
CSET2:	MOVEI A,NCHN_3	; Now finish cleaning up the SA10
	SUBI A,1_3	; Address channel
	JUMPL A,CSET3	; If neg, all done
	CONO SA0,CLPIE(A)  ; Clear interrupt enable for this channel
	JRST .-3	; Do them all

CSET3:	MOVE A,CHAN
	LSH A,2
	ADD A,BASEA
	MOVEM A,CBASE
	ADDI A,1
	MOVEM A,CBASE+1
	ADDI A,1
	MOVEM A,CBASE+2
	MOVE A,CHAN
	DPB A,[030200,,CLPIEC]
	DPB A,[030200,,RSTCHC]
	DPB A,[030200,,STBSYC]
	DPB A,[030200,,CLSTFC]
	DPB A,[030200,,STPIEC]
	DPB A,[030200,,STSRQC]
	POPJ P,0

CHAN:	0
CBASE:	BLOCK 3
CLPIEC:	CLPIE+SA0CH
RSTCHC:	RSTCH+SA0CH
STBSYC:	STBSY+SA0CH
CLSTFC:	CLSTF+SA0CH
STPIEC:	STPIE+SA0CH
STSRQC:	STSRQ+SA0CH

INT1:	0
	MOVEI I,1
	CAME I,PIE	;ARE WE EXPECTING AN INTERRUPT ON THIS CHANNEL?
	JRST ERR31	;NO
	MCONO SA0,CLSTF(B)	;REMOVE THE CAUSE FOR THIS INTERRUPT
			;(MAIN PROGRAM HAS SET B UP)
	CLEARM PIE	;NOTE THAT NO FURTHER INTERRUPTS ARE EX-
			;PECTED, ALSO TELL MAIN PROGRAM THAT ONE
			;INTERRUPT DID OCCUR
	JEN @INT1

INT2:	0
	MOVEI I,2
	CAME I,PIE
	JRST ERR32
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JEN @INT2

INT3:	0
	MOVEI I,3
	CAME I,PIE
	JRST ERR33
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JEN @INT3

INT4:	0
	MOVEI I,4
	CAME I,PIE
	JRST ERR34
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JEN @INT4

INT5:	0
	MOVEI I,5
	CAME I,PIE
	JRST ERR35
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JEN @INT5


INT6:	0
	MOVEI I,6
	CAME I,PIE
	JRST ERR36
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JEN @INT6

INT7:	0
	MOVEI I,7
	CAME I,PIE
	JRST ERR37
	MCONO SA0,CLSTF(B)
	CLEARM PIE
	JEN @INT7

PIE:	0	;CHANNEL ON WHICH INTERRUPT IS EXPECTED
UUOH:	0
	JSR RRR
	^D100
	[ASCIZ /
UUO AT /]
	UUOH
	[ASCIZ /-1/]
	0
	DDT
;WRAPAROUND TESTS;  PUT SPECIAL JUMPER CABLE BETWEEN BUS-IN AND BUS-OUT OF CHANNEL N
;  THEN GO TO WRAPN

WRAP0:	MOVEI G,0
	JRST WRP

WRAP1:	MOVEI G,1
	JRST WRP

WRAP2:	MOVEI G,2
	JRST WRP
WRAP3:	MOVEI G,3

WRP:	MOVEI A,^D8	;8 BIT POSITIONS TO CHECK
	PUSHJ P,PTN
	LDB D,[1000,,A]	;RIGHT 8 BITS
WRP2:	MOVEI A,2400	;PULSE 01
	PUSHJ P,CXXCT	;RESET OP STATUS BITS
	MOVE A,D	;DATA BYTE
	PUSHJ P,PARITY	;COMPUTE ODD PARITY
	MOVE A,D
	DPB B,[100100,,A]	;PUT PAR BIT LEFT OF DATA BITS
	LSH A,-1	;AND SHIFT RIGHT 1 BIT
	MOVEM A,WRAPV	;EXPECTED DATA BYTE
	MOVE A,D
	PUSHJ P,CXXCT	;DO GOTO WITH INITIAL BYTE
	MOVEI A,40120
	PUSHJ P,CXXCT	;DO IARB TO BUS OUT
	MOVEI A,144000
	MDATAO SA0,A	;ROUTE BUS IN TO C BUS
	MCONO SA0,RDCCI
	MDATAI SA0,B	;READ IN CBUS, ETC.
	LDB B,[121000,,B]	;EXTRACT C BUS
	CAME B,WRAPV	;THE MOMENT OF TRUTH
	JRST ERR42
WRP4:	LOOP ^D42,WRP2	;IF LOOPING TEST, USE SAME DATA
	PUSHJ P,STEPX	;DO THE BUSIN TO CBUS
	MOVEI A,145400
	MDATAO SA0,A	;ROUTE OP STATUS BITS TO CBUS
	MCONO SA0,RDCCI
	MDATAI SA0,C	;READ IN CBUS, ETC.
	TRNE C,40000	;BUS IN PAR ERR?
	JRST ERR43	;YES
WRP6:	LOOP ^D43,WRP2	;TRY AGAIN IF LOOPING
	JSR PTN0	;DO NEXT DATA VALUE
	JRST DDT	;WHEN ALL DONE
;GENERATE ODD PARITY OF WORD IN A
;  LEAVES 0 IN A, 0 OR 1 IN B
PARITY:	MOVEI B,0
PARIT1:	TRNE A,1
	TRC B,1
	LSH A,-1
	JUMPN A,PARIT1
	POPJ P,
EXTERN DDT

RRR:	0
	MOVEM A,SAVA
	MOVEM B,SAVB
	MOVEM C,SAVC
	MOVEM D,SAVD
	HRRZ D,@RRR
	MOVEI C,[ASCIZ /
ERR # %D OCTAL /]
	PUSHJ P,RRRT
	JRST RRR2	;IF TYPEOUT SUPPRESSED
	PUSHJ P,STYO
RRR2:	AOS C,RRR
	SKIPN C,(C)
	JRST RRR8
	PUSHJ P,RRRT
	JRST RRR3	;IF NO PRINTOUT
	PUSHJ P,STYO
RRR3:	AOS C,RRR
	SKIPN C,(C)
	JRST RRR8
	PUSHJ P,RRRT
	JRST RRR2	;IF NO PRINTOUT
	MOVE A,(C)
	SKIPN QUIET	; If no printout
	PUSHJ P,OPT
	JRST RRR2

RRR8:	AOS C,RRR
	MOVE C,(C)
	HRRM C,RRR
	MOVEI C,[ASCIZ /
/]
	TRNN A,3
	PUSHJ P,STYO
RRR9:	MOVE D,SAVD
	MOVE C,SAVC
	MOVE B,SAVB
	DATAI DSW,A
	TRNE A,4
	JRST RRR95
	MOVE A,SAVA
	JRST @RRR

RRR95:	MOVE A,SAVA
RRRB:	JRST DDT
	JRST @RRR

RRRT:	DATAI DSW,A	;READ DATA SWITCHES
	MOVEI B,207	;BELL
	TRNE A,2
	CONSZ TTY,20
	JRST RRRT3	;IF TTY BUSY
	DATAO TTY,B
RRRT3:	TRNN A,3
	AOS (P)
	POPJ P,
SAVA:	0
SAVB:	0
SAVC:	0
SAVD:	0

ERR8:	MCONSZ SA0,200000
	JRST ERR8P	;PAR ERR
	JSR RRR
	^D8
	[ASCIZ /MEM READ UNFINISHED/]
	0
	MRD1A

ERR8P:	MCONO SA0,RDMBL+CLMERR
	MDATAI SA0,ERR8P0
	MCONO SA0,RDMBR
	MDATAI SA0,ERR8P1
	JSR RRR
	^D8
	[ASCIZ /MEM READ PAR ERR: MB /]
	ERR8P0
	[ASCIZ /, MBR /]
	ERR8P1
	0
	MRD1A

ERR8P0:	0
ERR8P1:	0

ERR1:	JSR RRR
	1
	[ASCIZ /DATAI /]
	SAVC
	0
	BEG1B

ERR2:	JSR RRR
	2
	[ASCIZ /CHAN 0 NOT SERVED/]
	0
	BEG1C

ERR3:	HRRZ B,A
	JSR RRR
	3
	[ASCIZ /CHAN /]
	SAVB
	[ASCIZ / NOT SERVED/]
	0
	BEG21A

ERR4:	JSR RRR
	4
	[ASCIZ /IAR WROTE /]
	SAVB
	[ASCIZ /, READ /]
	SAVA
	0
	IARL1

ERR5:	JSR RRR
	5
	[ASCIZ /WROTE IAR /]
	SAVB
	[ASCIZ /, READ CBUS /]
	SAVA
	0
	IARL2

ERR40:	JSR RRR
	^D40
	[ASCIZ /WROTE 0 IN R3 TO MBL, READ /]
	SAVA
	0
	SZER1
ERR11:	JSR RRR
	^D11
	[ASCIZ /WROTE /]
	[0,,TEST]
	[ASCIZ / IN R2 TO MA, READ /]
	SAVC
	0
	MAMB1A

ERR6:	JSR RRR
	6
	[ASCIZ /WROTE /]
	MAMBTL
	[ASCIZ / IN R2 TO MBL, READ /]
	SAVB
	0
	MAMB2

MAMBTL:	0
MAMBTR:	0
INCTW:	0
WRAPV:	0
ERR28V:	0
CWTA:	0
CWTB:	0
ERR7:	HLRZ B,A
	JSR RRR
	7
	[ASCIZ /CHAN /]
	SAVB
	[ASCIZ / HAS MEM/]
	0
	MAMB3

ERR12:	JSR RRR
	^D12
	[ASCIZ /WROTE /]
	MAMBTR
	[ASCIZ / IN R2 TO MBR, READ /]
	SAVA
	0
	MAMB4

ERR9:	JSR RRR
	^D9
	[ASCIZ /MEM WRITE UNFINISHED/]
	0
	MWR1A

ERR10:	HRRZ D,A
	JSR RRR
	^D10
	[ASCIZ /WORD /]
	SAVD
	[ASCIZ / WROTE /]
	SAVC
	[ASCIZ /, READ /]
	SAVB
	0
	MCMP1
ERR28:	MOVEI E,3
	SUB E,F
	MOVEM E,ERR28V
	MOVEI E,3
	SUB E,B
	JSR RRR
	^D28
	[ASCIZ /CHAN /]
	G
	[ASCIZ /, WORD /]
	ERR28V
	[ASCIZ /, BYTE /]
	E
	[ASCIZ / WROTE /]
	SAVD
	[ASCIZ /, READ /]
	SAVA
	0
	CWT2A

ERR13:	JSR RRR
	^D13
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T SET PIE/]
	0
	STCL1A

ERR14:	JSR RRR
	^D13
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T CLEAR PIE/]
	0
	STCL1B

ERR15:	JSR RRR
	^D13
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T SET BUSY/]
	0
	STCL1C

ERR16:	JSR RRR
	^D13
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T CLEAR BUSY/]
	0
	STCL1D
ERR17:	JSR RRR
	^D13
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T SET STATUS FLAG/]
	0
	STCL1E

ERR18:	JSR RRR
	^D13
	[ASCIZ /CHAN /]
	SAVC
	[ASCIZ / CAN'T CLEAR STATUS FLAG/]
	0
	STCL1F

ERR19:	MOVE C,STCLM(B)
	JSR RRR
	^D19
	[ASCIZ /CAN'T DO /]
	SAVC
	0
	STCLM3

ERR20:	MOVE C,STCLM(B)
	SUBI C,4000
	JSR RRR
	^D19
	[ASCIZ /CAN'T DO /]
	SAVC
	0
	STCLM4

ERR21:	JSR RRR
	^D21
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT EMPTY/]
	0
	FIFO1A

ERR22:	JSR RRR
	^D22
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO EMPTY/]
	0
	FIFO2A

ERR24:	JSR RRR
	^D24
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT FULL/]
	0
	FIFO2B

ERR25:	JSR RRR
	^D25
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT EMPTY/]
	0
	FIFO3A

ERR26:	JSR RRR
	^D26
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO EMPTY/]
	0
	FIFO4A
ERR27:	MOVEI C,NBF
	SUB C,D
	JSR RRR
	^D27
	[ASCIZ /CHAN /]
	G
	[ASCIZ /, WORD /]
	SAVC
	[ASCIZ / WROTE /]
	H
	[ASCIZ /, READ /]
	SAVA
	0
	FIFO4B

ERR23:	JSR RRR
	^D23
	[ASCIZ /CHAN /]
	G
	[ASCIZ / FIFO NOT EMPTY/]
	0
	FIFO4C

ERR29:	JSR RRR
	^D29
	[ASCIZ /INTERRUPT REQ/]
	0
	PITST1

ERR38:	MOVE C,B
	JSR RRR
	^D38
	[ASCIZ /PIA /]
	SAVC
	[ASCIZ / DOESN'T INTERRUPT/]
	0
	PIT3A

ERR31:
ERR32:
ERR33:
ERR34:
ERR35:
ERR36:
ERR37:	JSR RRR
	^D31
	[ASCIZ /PIA /]
	I
	[ASCIZ / INTERRUPTED, /]
	PIE
	[ASCIZ / EXPECTED/]
	0
	DDT
ERR39:	XOR A,INCTW
	MOVE C,INCTW
	TLZ C,777760
	JSR RRR
	^D39
	[ASCIZ ?INC/DEC EXPECTED ?]
	SAVC
	[ASCIZ /, READ /]
	SAVA
	0
	INCT4

ERR41:	JSR RRR
	^D41
	[ASCIZ /UCODE LOC /]
	SAVB
	[ASCIZ / ADDR /]
	SAVC
	[ASCIZ / JUMPED TO /]
	SAVA
	0
	UCT7

ERR42:	JSR RRR
	^D42
	[ASCIZ /EXPECTED /]
	WRAPV
	[ASCIZ /, READ/]
	SAVB
	0
	WRP4

ERR43:	JSR RRR
	^D43
	[ASCIZ /BUS IN PAR ERR/]
	0
	WRP6

ERR50:	JSR RRR
	^D50
	[ASCIZ /CONI SHOULD BE /]
	[1,,7]
	[ASCIZ /, IS /]
	SAVA
	0
	BTECI

BTECI:	SLOOP
BTECI1:	MCONI SA0,A
	JRST BTECI
ERR51:	JSR RRR
	^D51
	[ASCIZ /CONI FAILING/]
	0
	BTECI

ERR52:	JSR RRR
	^D52
	[ASCIZ /SA-10 INACCESSABLE/]
	0
	BTECI

ERR53:	JSR RRR
	^D53
	[ASCIZ /CONI SHOULD BE /]
	[1,,0]
	[ASCIZ /, IS /]
	SAVA
	0
	BTECR

BTECR:	SLOOP
	CONO 200000
	MCONI SA0,A
	JRST BTECR

ERR54:	LDB D,[301100,,B]
	TRZ D,3
	JSR RRR
	^D54
	[ASCIZ /DEVICE /]
	SAVD
	[ASCIZ / CONI GIVES /]
	[1,,0]
	0
	BTECW

BTECW:	SLOOP
	XCT SAVB
	JRST BTECW

ERR55:	JSR RRR
	^D55
	[ASCIZ /CONO 7 GIVES CONI /]
	SAVA
	0
	BTECC

BTECC:	SLOOP
	MCONO SA0,7
	MCONI SA0,A
	JRST BTECC
ERR56:	JSR RRR
	^D56
	[ASCIZ /RESET GIVES CONI /]
	SAVA
	0
	BTERC

BTERC:	SLOOP
	MCONO SA0,7
	CONO 200000
	JRST BTERC

ERR57:	JSR RRR
	^D57
	[ASCIZ /CONO RDCONI+7 GIVES DATAI /]
	SAVA
	[ASCIZ /, SHOULD BE /]
	[2,,7]
	0
	BTEDI

BTEDI:	SLOOP
	MDATAI SA0,A
	JRST BTEDI

ERR58:	JSR RRR
	^D58
	[ASCIZ /CONO RDCONI+SASTEP GIVES DATAI /]
	SAVA
	0
	BTESD

BTESD:	SLOOP
	MCONO SA0,SASTEP
	MCONO SA0,RDCONI
	MDATAI SA0,A
	JRST BTESD
PTN0:	0	;CALLED BY JSR
	JRST PTN1	;ON TO NEXT VALUE

PTN:	0
	ADDI A,PTNTX	;BEG OF SINGLE BITS IN TABLE
	MOVEM A,PTNA	;WHERE IN TABLE TO STOP
	MOVEI A,PTNT-1
	MOVEM A,PTNP	;INITIALIZE POINTER
PTN1:	AOS A,PTNP
	CAML A,PTNA	;AT END OF DATA?
	JRST PTN5	;YES, MAKE 1 RANDOM #
	MOVE A,(A)	;NO, TAKE ENTRY FROM TABLE
	JRST @PTN	;EXIT TO TOP OF LOOP

PTN5:	CAME A,PTNA	;GIVEN RANDOM VALUE YET?
	JRST @PTN0	;YES, EXIT TO BOTTOM OF LOOP
	MOVEI A,105	;NO, MAKE IT NOW
	FMPB A,RNDM
	JRST @PTN	;AND EXIT TO TOP OF LOOP

PTNT:	0
	-1
	252525,,252525
	525252,,525252
PTNTX:	REPEAT ^D36,<	EXP 1B<PTNTX-.+^D35>>

PTNA:	0
PTNP:	0


TEST:	0
	-1
	252525,,252525
	525252,,525252	;PSEUDO-RANDOM TEST DATA
TEST1:	BLOCK 4	;PLACE TO READ STUFF BACK INTO

CWTD:
IFE CV,<325125,,340125>
IFN CV,<325137,,340125>
	125120,,252252
	240000,,

STCLM:	014000	;SET BUSY FLAG
	015000	;SET STATUS FLAG
	015400	;SET P.I. ENABLE FLAG

STCLM1:	BSY0
	STF0
	PIE0

BITS:	REPEAT ^D36,<	EXP 1B<.-BITS>>

CCTBL:	BLOCK NCHN	;LITTLE TABLE USED AT BEGINNING OF PROG.

	BLOCK 10
CPG0:	BLOCK 400
CPG1:	BLOCK 400
CPG2:	BLOCK 400
CPG3:	BLOCK 400
CPG4:	BLOCK 400
CPG5:	BLOCK 400
CPG6:	BLOCK 400
CPG7:	BLOCK 400

PDL:	BLOCK 200	;PUSHDOWN LIST
EPDL:	BLOCK 20	;ERROR PUSHDOWN LIST

R0==0
R1==10000
R2==20000
R3==30000
B0==0
B1==1
B2==2
B3==3
B4==4
SW1==5
BUSOUT==5
FOFI==6
FOFIS==7
BUSIN==10
STRD==10
STRDC==11
TAGB==12
STWR==12
INTST==13
STWRD==13
ZERO==14
LOAD==14
MRB==15
WHOLE==15
FIFO==16
B14==16
FIFOS==17

WC==0
CA==2000
PC==4000
A3==6000
IARB==0
INCR==0
WCFLD==1
ADRFLD==2
MAGIC==3
DECR==1
CLRINS==400
CLRTAG==0
STGO==10000
STRQ==10400
STFLG==11000
STPIE==11400
ADROUT==20000
SELOUT==20400
SRVOUT==21000
NOPOUT==21400
SUPOUT==22000
CMDOUT==22400
WRBIT==23000
BUFENB==23400
INS0==30000
INS1==30400
SELERR==31000
CTBYT==31400
CTLERR==32000
SKPFLG==32400
LENERR==33000
PCIFLG==33400
BIT00==0
BIT01==1
BIT10==20
BIT11==21
BIT20==40
BIT21==41
BIT30==60
BIT31==61
BIT40==100
BIT41==101
BIT50==120
BIT51==121
BIT60==140
BIT61==141
BIT70==160
BIT71==161
Z==200
NZ==201
ERR==221
NERR==220
DEVM==240
RBAK==260
NBTM==300
IFN EADR,<SKPC==320>
IFE EADR,<SKPC==Z>
TAGBS==TAGB_10
ADRI0==TAGBS+BIT00
ADRI1==TAGBS+BIT01
SELI0==TAGBS+BIT10
SELI1==TAGBS+BIT11
BFMT0==TAGBS+BIT20
BFMT1==TAGBS+BIT21
OPLI0==TAGBS+BIT30
OPLI1==TAGBS+BIT31
RQI0==TAGBS+BIT40
RQI1==TAGBS+BIT41
STAI0==TAGBS+BIT50
STAI1==TAGBS+BIT51
BCRQ0==TAGBS+BIT60
BCRQ1==TAGBS+BIT61
BFHLT0==TAGBS+BIT71
BFHLT1==TAGBS+BIT70
INSTS==INTST_10
INS00==INSTS+BIT00
INS01==INSTS+BIT01
INS10==INSTS+BIT10
INS11==INSTS+BIT11
PCIF0==INSTS+BIT70
PCIF1==INSTS+BIT71
SW1S==SW1_10
BSY0==SW1S+BIT00
BSY1==SW1S+BIT01
STRQ0==SW1S+BIT10
STRQ1==SW1S+BIT11
STFL0==SW1S+BIT20
STFL1==SW1S+BIT21
WCOK0==SW1S+BIT40
WCOK1==SW1S+BIT41
TIMER0==SW1S+BIT50
TIMER1==SW1S+BIT51

DEFINE MPAGE
<IFN .&17,<.PRINT <BADMPG>>>

DEFINE ADRSET (NAME)
<IFIDN <NAME>,<>,<ADR=.+1>
IFDIF <NAME>,<>,<ADR=NAME>
IF2,<IFN <.&1400>-<ADR&1400>,<.PRINT <BNDER1>>>
ADR=ADR&377
>
DEFINE PULSE (BIT,NAME)
<ADRSET NAME
.,,BIT+2000+ADR
>

DEFINE ON (BIT,NAME)
<ADRSET NAME
.,,BIT+4000+ADR
>
DEFINE OFF (BIT,NAME)
<ADRSET NAME
.,,BIT+ADR
>
DEFINE ADRST1 (NAME)
<IFIDN <NAME>,<>,<ADR=.+1>
IFDIF <NAME>,<>,<ADR=NAME>
IF2,<IFN <.&1760>-<ADR&1760>,<.PRINT <BNDERR>>>
ADR=ADR&17
>
DEFINE XFER (REG,SRC,DEST,NAME)
<ADRST1 NAME
.,,140000+REG+<SRC_10>+<DEST_4>+ADR
>
DEFINE XANC (SRC1,SRC2,REG,DEST,NAME)
<ADRST1 NAME
.,,040000+REG+SRC1+<SRC2_10>+<DEST_4>+ADR
>
DEFINE GOTO (NAME)
<.,,NAME
>
DEFINE TEST (REG,SRC,FN,NAME)
<ADRST1 NAME
.,,100000+REG+<SRC_10>+<<FN!<ADR+1>>-<FN&<ADR+1>>>
>
DEFINE HANG (REG,SRC,FN)
<.,,100000+REG+<SRC_10>+FN+.&17
>
;THIS IS WHERE THE MICROCODE IS LOADED

	SALL
MCBEG0:

PHASE 0

MCBEG:!

	PULSE CLRINS,RST	;SYS
	ON ADROUT,HIO	;HALT I/O
	PULSE CLRINS,RST	;PROG SYS
	ON INS0,RST	;PROG SEL
	REPEAT 4,<ON INS0,RST>	;PANIC
	REPEAT 10,<0>
	MPAGE

RST:!	OFF STGO
	OFF STFLG
	PULSE CLRTAG
	TEST 0,0,INS01,RS1
RS1:!	ON SUPOUT
	ON NOPOUT
	HANG 0,0,TIMER0
	XFER R0,ZERO,WHOLE
	HANG 0,0,TIMER1
	OFF STRQ
	HANG 0,0,TIMER0
	TEST 0,0,INS00,RS2
RS2:!	OFF NOPOUT,IDLE
HIO1:!	XFER R0,ZERO,WHOLE
	HANG 0,0,OPLI1
	OFF NOPOUT,RS3
	MPAGE

HIO:!	OFF SELOUT,HIO1
ASC1:!	TEST R1,B1,BIT10,ASC1A
ASC1A:!	XANC PC,INCR,0,LOAD	;SKIP A CMD IF DEVEND+STAMOD ON DCC
	GOTO ASC1B
IDLE:!	PULSE CLRINS
	XFER R1,ZERO,WHOLE
IDL1:!	TEST 0,0,BSY1,IDL2
	ON SELOUT,ASY1	;DO A POLL CYCLE
IDL2:!	TEST 0,0,STRQ1,IDL3
	OFF STGO,GO0	;START COMMAND
IDL3:!	TEST 0,0,RQI1,IDL1
	GOTO STR	;DUMMY STATUS REQUEST
RS3:!	PULSE CLRTAG
	PULSE CLRINS
	ON CTLERR
	ON INS0,STR	;TERMINATE A SEL RST WITH A CTRL CHECK INT
	MPAGE


ASY1:!	TEST 0,0,OPLI1,ASY2
	OFF SELOUT,ASYU	;GOT SELECT IN ON POLL - REQ IN MUST HAVE DROPPED
ASY2:!	TEST 0,0,SELI1,ASY1
	ON INS1,ASY3	;POLL SUCCESSFUL
ASY3:!	HANG 0,0,ADRI0
	XFER R1,BUSIN,B2,ASY4	;GET ADDR
ASY5:!	HANG 0,0,ADRI1
	OFF CMDOUT
	HANG 0,0,STAI0
	XFER R1,BUSIN,B1	;GET THE STATUS
	OFF SELOUT,AST	;AND GO TEST FOR DCC
ASY4:!	ON CMDOUT,ASY5
ASYU:!	HANG 0,0,SELI1
	GOTO IDLE
ASP1:!	HANG 0,0,OPLI1
	GOTO STR
	MPAGE

AST:!	TEST R1,B1,NERR,AST1
AST3B:!	TEST R2,B0,BIT01,AST4
AST1:!	ON SRVOUT,ASP	;ERR IN STATUS, GIVE TO PROG
	TEST R1,B1,BIT51,AST2
AST2:!	ON SRVOUT,ASP	;NO DEVEND IN STATUS,GIVE TO PROG
	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,STRD
	GOTO AST3
AST3A:!	TEST R2,B1,BIT01,AST4
	TEST R2,B1,BIT30,AST6	;MATCHING DEV CODE FOUND, CHK WAIT
AST4:!	ON SRVOUT,ASP	;SEL MODE OR END OF LIST,GIVE TO PROG
	XANC A3,INCR,0,STRD
	XFER R2,MRB,WHOLE	;DEV TABLE ENTRY TO R2
AST5:!	TEST R1,0,DEVM,AST3A
AST6:!	ON SRVOUT,ASP	;START OR HALTED, GIVE TO PROG
	ON SUPOUT,ASC	;ALL TESTS PASSED, INDICATE CHAINING
	MPAGE

ASC:!	ON SRVOUT,ASC1
ASC3:!	PULSE CLRINS,FET
ASC1B:!	HANG 0,0,STAI1
	OFF SRVOUT,ASC1C
CMD12:!	GOTO XD4
	0
ASC2:!	XANC A3,DECR,0,STWRD
	XANC A3,B1,R0,B2
	XANC A3,B2,R0,B3
	XANC A3,B3,R0,B14
	XANC CA,INCR,0,LOAD
	XANC CA,INCR,0,LOAD	;BASE+3
	XANC CA,INCR,R0,STWR	;STORE PTR TO DEVLST
ASC2A:!	XANC PC,ADRFLD,R2,LOAD,ASC3
ASP:!	HANG 0,0,STAI1
	OFF SRVOUT,ASP1
	MPAGE

FET:!	XANC PC,INCR,0,STRD
FET0:!	ON INS0
	XFER R0,MRB,WHOLE	;GET CMD
	TEST R0,B0,BIT21,FET1
FET1:!	TEST R0,B0,BIT11,FET2	;SP CMD
	XFER R0,B2,BUSOUT	;DEV CMD
	ON ADROUT,INI2
FET4:!	TEST R0,B0,BIT01,FET5
FET2:!	TEST R0,B0,BIT31,FET3
	XANC PC,ADRFLD,R0,LOAD,FET	;TCH
FET3:!	ON INS1,INERR	;HALT
	XANC CA,ADRFLD,R0,LOAD,FET4	;LOAD OR STORE
FET5:!	XANC CA,INCR,0,STRD,FET6	;LOAD
	XANC CA,INCR,R2,STWR,FET	;STORE
FET6:!	XFER R2,MRB,WHOLE,FET
STR1:!	OFF STRQ,STX
MPAGE

INI6:!	HANG 0,0,SELI1
	OFF ADROUT,INI6A
MERR:!	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,STRD
	ON PCIFLG,MERR1
INI5A:!	OFF SELOUT,INI7
INI2:!	ON SELOUT
INI2A:!	XFER R1,MRB,B2,INI5	;SAVE DEVADR IN STAT FOR CU BSY ETC
INI3:!	TEST 0,0,OPLI1,INI4
	OFF SELOUT,INI6	;NOT OPER
INI4:!	TEST 0,0,STAI1,INI5
	OFF ADROUT,CMD	;NORMAL SELECTION
INI5:!	TEST 0,0,SELI1,INI3
	XFER R1,BUSIN,B1,INI5A	;CU BUSY SEQ, GET STATUS
INI7:!	HANG 0,0,STAI1
	OFF ADROUT,INERR
	MPAGE

CMD:!	OFF SUPOUT,CMD1
CMD2:!	TEST R0,B0,NBTM,CMD3
CMD1:!	HANG 0,0,ADRI0
	XFER R1,BUSIN,B2	;GET ECHOED ADDR
	XFER R0,B1,BUSOUT	;PUT OUT CMD BYTE
	ON CMDOUT,CMD2
CMD3:!	ON CTBYT
	XANC PC,B1,R2,B2
	HANG 0,0,ADRI1	;WAIT FOR CMD ACCEPTED
	OFF CMDOUT,CMD4
CMD10:!	HANG 0,0,STAI0
	TEST 0,BUSIN,Z,CMD11
CMD11:!	GOTO ED
	ON SRVOUT	;ACCEPT INITIAL STATUS OF 0 (NMT)
	HANG 0,0,STAI1
	OFF SRVOUT,CMD12
	MPAGE

CMD4:!	TEST R0,B1,NZ,CMD5
CMD8:!	GOTO DAT
CMD5:!	GOTO ESW	;CMD WAS TEST I/O
	XANC PC,B2,R2,B3
	XANC PC,B3,R2,B14
	TEST R0,B0,BIT00,CMD6
CMD6:!	XANC A3,ADRFLD,R2,LOAD,CMD9	;NMT, SETUP FOR RETRY
	XANC PC,INCR,0,STRD	;START FIRST DCW FET
	XANC A3,ADRFLD,R2,LOAD	;SETUP SAVED PC FOR RETRY
	TEST R0,B1,BIT71,CMD7
CMD7:!	OFF WRBIT,CMD8
	ON WRBIT,CMD8
CMD9:!	ON WRBIT
	ON INS1,CMD10	;MAKE BUFFER NO AVAIL TO DEVICE
INI6A:!	ON SELERR,INERR
INERR:!	OFF SUPOUT,MERR
	MPAGE

STR:!	XFER R1,INTST,B0	;STORE STATUS ROUTINE
	XANC WC,B1,R2,B0
	XANC WC,B2,R2,B1
	XANC PC,B1,R2,B2
	XANC PC,B2,R2,B3
	XANC PC,B3,R2,B14
	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,LOAD
	HANG 0,0,STFL1
	XANC CA,INCR,R1,STWR
	XANC CA,INCR,R2,STWR
	XFER R2,MRB,WHOLE	;WAIT FOR LAST STORE DONE
	ON STFLG,STR1
STX2:!	TEST R0,B0,BIT21,STX3
STX3:!	PULSE CLRINS,FET	;NORMAL PCI
	GOTO SIT	;PCI WITH CHNL END AND DCC
	MPAGE

STX8:!	TEST R2,B0,BIT10,STX9
STX:!	TEST 0,0,PCIF1,STX1
STX1:!	TEST 0,0,INS00,STX4
	OFF PCIFLG,STX2
STX4:!	TEST 0,0,INS10,STX5	;ASYNC OR DUMMY
	TEST R0,B0,BIT21,STX6	;INI OR END
STX5:!	XANC CA,MAGIC,0,LOAD,STX7	;DUMMY
	GOTO STX9	;ASYNC
STX6:!	TEST R0,B0,BIT01,STX6A	;HLT
	GOTO STX9	;NO A HLT
STX6A:!	GOTO STX9	;SLOW HALT
	GOTO SIT	;FAST HLT
STX7:!	XANC CA,INCR,0,STRD
	XFER R2,MRB,WHOLE,STX8
STX9:!	HANG 0,0,STFL1
	GOTO IDLE
	MPAGE

MERR1:!	XFER R2,MRB,WHOLE
	TEST R2,B0,BIT01,MERR2
MERR2:!	OFF PCIFLG,STR	;SEL MODE, JUST STORE
MRK:!	XANC CA,INCR,0,LOAD	;BM
	XANC CA,INCR,0,LOAD
	XANC CA,INCR,0,STRD	;GET SAVED PTR TO DEVLST
	XFER R3,MRB,WHOLE
	XANC A3,ADRFLD,R3,LOAD
	XANC A3,INCR,0,STRD	;GET DEVLST ENTRY
	XANC A3,ADRFLD,R3,LOAD	;SET A3 BACK FOR REWRITE
	XFER R2,MRB,WHOLE
	XANC PC,B1,R2,B2
	XANC PC,B2,R2,B3
	XANC CA,WCFLD,0,LOAD
	GOTO MRK1
	0
	MPAGE

MRK1:!	TEST 0,0,PCIF0,MRK2
CMD7A:!	GOTO DAT
MRK2:!	XANC CA,INCR,0,LOAD	;SET CA FOR TERM
	XANC CA,B3,R2,B1,MRK2A
MRK2B:!	XANC A3,INCR,R2,STWR	;STORE UPDATED PTR
	TEST 0,0,PCIF0,MRK3
MRK3:!	OFF PCIFLG,STR	;MARK TERM DONE
	TEST R0,B0,BIT50,MRK4	;MARK HUNG DONE
MRK4:!	ON PCIFLG,STR	;PIC W/DCC CHNL END
SIT:!	TEST R3,B1,BIT01,SIT1	;TEST FOR ASYNC OR GOFLG STRT
SIT1:!	GOTO IDLE	;ASYNC START
	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,LOAD	;SET CA FOR ASC
	GOTO GO2
MRK2A:!	XANC PC,B3,R2,B14,MRK2B
	0
	MPAGE

GO0:!	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,STRD
	XFER R2,MRB,WHOLE
	TEST R2,B0,BIT01,GO1
GO1:!	GOTO ASC2A	;SEL MODE
	XANC A3,ADRFLD,R2,LOAD,GO2	;BM
GO3:!	GOTO IDLE	;END OF LIST
	TEST R2,B1,BIT21,GO4
GO4:!	XFER R0,MRB,WHOLE,GO4A	;START FOUND,MAKE R0 NEG
GO2:!	XANC A3,INCR,0,STRD	;KEEP LOOKING
	XFER R2,MRB,WHOLE
	TEST R2,B1,BIT01,GO3
GO5:!	GOTO ASC2	;CA:!BASE+1, A3:!DEVLSTPT+1, R2:!CMD ADR
GO4A:!	XFER R1,MRB,B0	;PUT DEVADR INTO STATUS WORD
	XFER R1,B0,B2	;GET IT IN THE CORRECT BYTE
	XFER R1,ZERO,B1,GO5	;AND CLEAR BYTE 1
	MPAGE

DUN:!	TEST 0,0,PCIF1,DUN1
DUN3:!	ON PCIFLG,STR	;DO PCI
DUN1:!	TEST R0,B0,BIT51,DUN2	;NOT DCC
	OFF PCIFLG,DUN4	;DCC
DUN2:!	PULSE CLRINS,FET	;NOT PCI
	XFER R0,ZERO,WHOLE,DUN3	;PCI, CAUSE RET TO FETCH
DUN4:!	OFF SUPOUT,MRK	;MARKS HUNG
AST3:!	XFER R2,MRB,WHOLE	;BLK MUX FLAG TO R2
	XANC A3,ADRFLD,R2,LOAD
	GOTO AST3B
	0
	0
ASC1C:!	HANG 0,0,OPLI1
	XFER R0,ZERO,WHOLE
	GOTO GO4A
	0
	MPAGE

ED:!	TEST 0,0,OPLI1,ED1
IMM:!	TEST 0,INTST,BIT31,ES1
ES1:!	TEST 0,INTST,BIT61,ES1A	;NO PARERR
	GOTO ES7	;BUS IN PAR ERR
ES1A:!	GOTO ES2	;NO LEN ERR
	TEST R0,B0,BIT61,ES1B	;TEST SLI
ES1B:!	GOTO ES3B	;HALT ON LEN ERR
	GOTO ES2	;IGNORE LEN ERR
ED1:!	ON CTLERR,ED1A	;END STATUS MISSING
	XFER R1,BUSIN,B1,IMM
ESWI:!	HANG 0,0,STAI1
	OFF SRVOUT
ESW:!	TEST 0,0,OPLI1,ESW1
ES0:!	XFER R1,BUSIN,B1,IMM	;MORE STATUS
ESW1:!	GOTO DUN	;NORMAL DISCONNECT
	TEST 0,0,STAI1,ESW
	MPAGE

ES2:!	TEST 0,BUSIN,ERR,ES3
ES8A:!	XANC PC,ADRFLD,R2,LOAD,ES8B	;CHAIN BACK TO PREV CMD
ES3:!	TEST R0,B0,BIT31,ES4	;NO BAD BITS
ES3B:!	TEST 0,BUSIN,BIT61,ES7	;BAD BITS
ES4:!	OFF SELOUT,ES5	;NO CHAINING
ES4A:!	ON SUPOUT,ES6	;CHAINING
ES7:!	OFF SUPOUT,CMDE	;NO UNIT CHECK
	TEST 0,BUSIN,BIT11,ES8	;UN CHECK
ES8:!	OFF SUPOUT,CMDE	;NO STA MOD
	XANC A3,B1,R2,B2	;RETRY STATUS
	XANC A3,B2,R2,B3
	XANC A3,B3,R2,B14,ES8A
ES8B:!	OFF LENERR
	XANC PC,DECR,0,STWRD,ES4A
CMDE:!	OFF SELOUT
	ON SRVOUT,CMDE1
	MPAGE

ES6:!	TEST 0,BUSIN,BIT51,ES6A
ES9A:!	TEST R2,B0,BIT01,ES5
ES6A:!	XANC CA,MAGIC,0,LOAD,ES9	;NO DEV END
	TEST 0,BUSIN,BIT11,ES6B	;DEV END
ES6B:!	OFF SELOUT,ESF	;DEVEND W/O STAMOD
	TEST 0,BUSIN,BIT61,ES6C	;STA MOD
ES6C:!	XANC PC,INCR,0,LOAD	;DEVEND, STAMOD, NOT UNCHK
	OFF SELOUT,ESF	;UNCHK OVERRIDES SKIP
ES9:!	XANC CA,INCR,0,STRD
	XFER R2,MRB,WHOLE,ES9A
ES5:!	ON SRVOUT,ESWI
	ON PCIFLG,ES4
XD2D:!	HANG 0,0,BFHLT0
	ON LENERR,XD2C
	0
	0
	MPAGE

DSRO:!	TEST R3,B2,SKPC,DSRO1
XD3:!	TEST R0,B1,BIT71,XD3A
DSRO1:!	TEST R0,B1,RBAK,DSRO3	;NOT SKIP
	TEST R3,B3,Z,DSRO2	;POSS SKIP
DSRO2:!	TEST R0,B1,RBAK,DSRO3	;NOT SKIP
	GOTO SK6	;SKIP
DSRO3:!	GOTO RD6	;RD FWD
	TEST R0,B0,BIT41,DSRO4	;RD BAK
DSRO4:!	GOTO RB6	;RD BAK WD
	GOTO RBB	;RD BAK BYTE
XD3A:!	GOTO XD2	;DON'T DO ANYTHING SPECIAL IF READ
	XANC WC,WCFLD,0,LOAD,XD3B	;FORCE WCOK
XD4:!	XFER R3,ZERO,WHOLE,XD3D	;SET TO CLE@R WC
XD3B:!	XFER R3,ZERO,WHOLE,XD3C	;CLEAR TSD0
XD3D:!	XANC WC,ADRFLD,R3,LOAD,XD3A	;FORCE WC ZERO
XD3C:!	XFER R2,B4,FOFI,XD3D	;WRITE LAST BYTE (HALF FULL)
	MPAGE

DAT2:!	HANG 0,0,STAI0
	TEST 0,BUSIN,Z,DAT3	;TEST INITIAL STATUS
DAT3:!	OFF INS1,XD1D	;NOT ZERO, NO XFER
	TEST R0,B1,BIT71,DAT4	;TEST WRITE
DAT4:!	ON SRVOUT,DAT5	;ACCEPT ZERO STATUS ON READ
	XANC CA,INCR,0,STRD	;FETCH FIRST WORD TO WRITE
	TEST R0,B0,BIT11,DAT6	;TEST TAPE COMPAT MODE
	0
DAT6:!	GOTO DSW0	;NOT TAPE COMPAT
	XFER R2,ZERO,WHOLE	;FOR ZERO BITS IN 9 TRACK MODE
	OFF CTBYT	;MAY HAVE BEEN SET IF 9 TRACK
	GOTO DXW
DAT5:!	HANG 0,0,STAI1
	TEST R0,B0,BIT11,DAT5A
DAT5A:!	OFF SRVOUT,DSR
	GOTO DXR	;TAPE COMPAT READ
	MPAGE

DSR:!	TEST R3,B2,SKPC,DSR1
DSR6A:!	GOTO SK6
DSR1:!	TEST R0,B1,RBAK,DSR3	;NOT SKIP
	TEST R3,B3,Z,DSR2	;POSS SKIP
DSR2:!	TEST R0,B1,RBAK,DSR3	;NOT SKIP
	TEST R0,B1,RBAK,DSR4	;SKIP
DSR3:!	GOTO RD0	;RD FWD
	TEST R0,B0,BIT71,DSR5	;RD BAK
DSR4:!	GOTO SK0	;SKP FWD
	TEST R0,B0,BIT71,DSR6	;SKP BAK
DSR5:!	TEST R0,B0,BIT41,DSR7	;RD BAK EVEN
	GOTO RB11	;RD BAK ODD
DSR6:!	GOTO SK0	;SKP BAK EVEN
	XFER R2,FIFO,B4,DSR6A	;SKP BAK ODD
DSR7:!	GOTO RB0	;RD BAK WD
	GOTO RBB	;RD BAK BYTE
	MPAGE

RD1:!	XFER R2,FIFO,B1,RD2
RDX:!	GOTO DEE
RD2:!	XFER R2,FIFO,B2,RD3
RD5:!	XANC CA,INCR,R2,STWR,RD6
	0
RD3:!	XFER R2,FIFO,B3,RD4
RD4:!	XFER R2,FIFO,B4,RD5
RD10:!	XANC CA,INCR,R3,STWR,RD0
RD7:!	XFER R3,FIFO,B1,RD8
RDX2:!	GOTO DEO
RD8:!	XFER R3,FIFO,B2,RD9
RD0:!	XFER R2,FIFO,B0,RD1
	0
	0
RD9:!	XFER R3,FIFO,B3,RD10
RD6:!	XFER R3,FIFO,B0,RD7
	MPAGE

RB1:!	XFER R3,FIFO,B2,RB2
RBX:!	GOTO DEE
RB2:!	XFER R3,FIFO,B1,RB3
RB5:!	XANC CA,DECR,R3,STWR,RB6
	0
RB3:!	XFER R3,FIFO,B0,RB4
RB4:!	XFER R2,FIFO,B4,RB5
RB10:!	XANC CA,DECR,R2,STWR,RB0
RB7:!	XFER R2,FIFO,B2,RB8
RBX2:!	GOTO DEO
RB8:!	XFER R2,FIFO,B1,RB9
RB0:!	XFER R3,FIFO,B3,RB1
ED1A:!	GOTO MERR
RB9:!	XFER R2,FIFO,B0,RB10
RB6:!	XFER R2,FIFO,B3,RB7
RB11:!	XFER R2,FIFO,B4,RB6
MPAGE

SK1:!	XFER R2,FIFO,B1,SK2
SKX:!	GOTO DEE
SK2:!	XFER R2,FIFO,B2,SK3
SK6:!	XFER R3,FIFO,B0,SK7
	0
SK3:!	XFER R2,FIFO,B3,SK4
SK4:!	XFER R2,FIFO,B4,SK6
SK0:!	XFER R2,FIFO,B0,SK1
SK7:!	XFER R3,FIFO,B1,SK8
SKX2:!	GOTO DEO
SK8:!	XFER R3,FIFO,B2,SK9
	0
	0
SK9:!	XFER R3,FIFO,B3,SK0
DSW4:!	HANG 0,0,STAI1
	OFF SRVOUT,WR2
	MPAGE

ESF:!	ON SRVOUT
	TEST R0,B0,BIT51,ESF1
ESF1:!	XANC PC,INCR,0,STRD,ESF2	;NO PCI, START NEXT FETCH
	GOTO ESWI	;PCI, CAN'T BE FAST
ESF2:!	PULSE CLRINS,ESF3
RBB:!	XFER R2,ZERO,WHOLE,RBBA
RBBT:!	TEST R3,B1,BIT71,RBB0	;3 OR 4 BYTES IN 1ST WD
	TEST R3,B1,BIT71,RBB2	;1 OR 2 BYTES IN 1ST WD
RBB1:!	XFER R2,FIFO,B2,RBB2
	GOTO DEE
RBB2:!	XFER R2,FIFO,B1,RBB3	;2 BYTE ENTRY
RBB3:!	XFER R2,FIFO,B0,RBB4	;1 BYTE ENTRY
RBB0:!	XFER R2,FIFO,B3,RBB1	;4 BYTE ENTRY
	XFER R2,FIFO,B2,RBB2	;3 BYTE ENTRY
RBB4:!	XANC CA,DECR,R2,STWR,RBB0
RBBA:!	TEST R3,B1,BIT61,RBBT
	MPAGE

WR1:!	XFER R2,B1,FOFI,WR2
WRX:!	GOTO DEE
WR2:!	XFER R2,B2,FOFI,WR3
WR3A:!	XFER R3,MRB,WHOLE,WR5
WR4:!	XFER R2,B4,FOFI,WR6
WR3:!	XFER R2,B3,FOFI,WR3A
WR6:!	XFER R3,B0,FOFI,WR7
WR10:!	XFER R2,MRB,WHOLE,WR10A
WR7:!	XFER R3,B1,FOFI,WR8
WRX2:!	GOTO DEO
WR8:!	XFER R3,B2,FOFI,WR9
WR0:!	XFER R2,B0,FOFI,WR1
WR10A:!	XANC CA,INCR,0,STRDC,WR0
WR9:!	XFER R3,B3,FOFI,WR10
WR5:!	XANC CA,INCR,0,STRDC,WR4
WRT:!	XANC CA,INCR,0,STRD,WR10
	MPAGE

DSRE:!	TEST R3,B2,SKPC,DSRE1
	0
DSRE1:!	TEST R0,B1,RBAK,DSRE3	;NOT SKIP
	TEST R3,B3,Z,DSRE2	;POSS SKIP
DSRE2:!	TEST R0,B1,RBAK,DSRE3	;NOT SKIP
	GOTO SK0	;SKIP
DSRE3:!	GOTO RD0	;RD FWD
	TEST R0,B0,BIT41,DSRE4	;RD BAK
DSRE4:!	GOTO RB0	;RD BAK WD
	GOTO RBB	;RD BAK BYTE
DSW2:!	ON SRVOUT,DSW3	;ACCEPT INITIAL STATUS FOR NORMAL WRITE
DSW0:!	TEST R0,B0,BIT71,DSW1
DSW1:!	XFER R2,MRB,WHOLE,DSW2	;WAIT FOR FIRST WORD TO BE WRITTEN
	XFER R2,MRB,WHOLE	;SKIP 2 BYTES
	XANC CA,INCR,0,STRD
	ON SRVOUT,DSW4	;ACCEPT INITIAL STATUS - SKIP 2 BYTES MODE
	MPAGE

DEE:!	TEST 0,0,WCOK1,DEE1
DEE2A:!	XANC CA,ADRFLD,R3,LOAD,DEE2B
DEE1:!	TEST 0,0,INS11,DEE2	;WC OVF TEST DC
DEE1A:!	TEST 0,0,INS11,DEE1B	;DEV TRUNC, SEE IF SKIP DCW'S NEEDED
DEE2:!	GOTO XD2	;NO DC (CHNL TRUNC OR OK)
	XANC PC,INCR,0,STRD	;GET NEXT DCW
	XFER R3,MRB,WHOLE,DEE2A	;DONT STEP ON TDS0
DEE2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD	;SET READ-OK
	TEST R3,B0,BIT00,DEE3
DEE3:!	ON INS1	;FLAG NO MORE DCWS
	TEST R0,B1,BIT71,DEE4
DEE4:!	GOTO DSRE
	GOTO WRT
DEE1B:!	ON LENERR,XD2C	;NO SKIPS NEEDED
	ON INS1,XD1E	;FLAG AS ENDING STATUS, DO SKIPS IF REQUIRED
	MPAGE

DEO:!	TEST 0,0,WCOK1,DEO1
DEO2A:!	XANC CA,ADRFLD,R3,LOAD,DEO2B
DEO1:!	TEST 0,0,INS11,DEO2	;WC OVF TEST DC
	GOTO DEE1A	;DEV TRUNC
DEO2:!	GOTO XD3	;NO DC (CHNL TRUNC OR OK)
	XANC PC,INCR,0,STRD	;GET NEXT DCW
	XFER R3,MRB,WHOLE,DEO2A	;DONT STEP ON TDS0
DEO2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD	;SET READ-OK
	TEST R3,B0,BIT00,DEO3
DEO3:!	ON INS1	;FLAG NO MORE DCWS
	TEST R0,B1,BIT71,DEO4
DEO4:!	GOTO DSRO	;READ
	XANC CA,INCR,0,STRD	;WRITE
	GOTO WR3A
	0
	MPAGE

XD2:!	HANG 0,0,BFHLT0
	TEST 0,0,BCRQ1,XD2A
XD2A:!	TEST 0,0,BFMT1,XD2B
	ON CMDOUT	;CHNL TRUNC
	HANG 0,0,BCRQ1
	OFF CMDOUT,XD2D
XD1C:!	XFER R3,MRB,WHOLE
XD1D:!	TEST R3,B0,BIT00,XD1A
XD2B:!	ON LENERR
XD2C:!	OFF BUFENB,ED
DSW3:!	HANG 0,0,STAI1
	OFF SRVOUT,WR10A
XD1A:!	ON LENERR,XD2C	;NO MORE
XD1E:!	TEST R0,B0,BIT61,XD1B	;UNUSED DCW
XD1B:!	ON LENERR,XD2C	;NO SLI OR NO MORE
	XANC PC,INCR,0,STRD,XD1C	;SKIP A DCW
	MPAGE

DAT:!	XFER R3,MRB,WHOLE
	XANC CA,ADRFLD,R3,LOAD
	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD	;SET READ-OK
	TEST R3,B0,BIT00,DAT1
	0
ESF3:!	HANG 0,0,STAI1
	OFF SRVOUT
	HANG 0,0,OPLI1
	GOTO FET0
CMDE1:!	HANG 0,0,STAI1
	OFF SRVOUT
	HANG 0,0,OPLI1
	GOTO MERR
DAT1:!	ON INS1	;FLAG NO MORE DCW'S
	ON BUFENB,DAT2
	MPAGE

W71:!	XFER R3,B1,FOFI,W72
W7X:!	GOTO DXE
W72:!	XFER R3,B2,FOFI,W73
W74:!	XFER R2,MRB,WHOLE,W75
W75:!	XANC CA,INCR,0,STRDC,W76
W73:!	XFER R3,B3,FOFI,W74
W77:!	XFER R2,B1,FOFIS,W78
W76:!	XFER R2,B0,FOFIS,W77
W78:!	XFER R2,B2,FOFIS,W79
W7X1:!	GOTO DXO
W79:!	XFER R2,B3,FOFIS,W7A
W7B:!	XFER R3,MRB,WHOLE,W7C
W70:!	XFER R3,B0,FOFI,W71
W7A:!	XFER R2,B4,FOFIS,W7B
W7C:!	XANC CA,INCR,0,STRDC,W70
W7D:!	XANC CA,INCR,0,STRD,W7B
	MPAGE

R71:!	XFER R3,FIFO,B1,R72
R7X:!	GOTO DXE
R72:!	XFER R3,FIFO,B2,R73
R75:!	XANC CA,INCR,R3,STWR,R76
	0
R73:!	XFER R3,FIFO,B3,R74
R74:!	XFER R2,FIFOS,B0,R75
R76:!	XFER R2,FIFOS,B1,R77
R77:!	XFER R2,FIFOS,B2,R78
R7X1:!	GOTO DXO
R78:!	XFER R2,FIFOS,B3,R79
R7A:!	XANC CA,INCR,R2,STWR,R70
R70:!	XFER R3,FIFO,B0,R71
R79:!	XFER R2,FIFOS,B4,R7A
	0
	0
	MPAGE

B71:!	XFER R2,FIFOS,B3,B72
B7X:!	GOTO DXE
B72:!	XFER R2,FIFOS,B2,B73
B75:!	XANC CA,DECR,R2,STWR,B76
	0
B73:!	XFER R2,FIFOS,B1,B74
B74:!	XFER R2,FIFOS,B0,B75
B7B:!	XFER R2,FIFOS,B0,B76
B77:!	XFER R3,FIFO,B2,B78
B7X1:!	GOTO DXO
B78:!	XFER R3,FIFO,B1,B79
B7A:!	XANC CA,DECR,R3,STWR,B70
	0
B79:!	XFER R3,FIFO,B0,B7A
B76:!	XFER R3,FIFO,B3,B77
B70:!	XFER R2,FIFOS,B4,B71
	MPAGE

S71:!	XFER R3,FIFO,B1,S72
S7X:!	GOTO DXE
S72:!	XFER R3,FIFO,B2,S73
S75:!	XFER R2,FIFOS,B1,S76
S79:!	XFER R2,FIFOS,B0,S7A
S73:!	XFER R3,FIFO,B3,S74
S74:!	XFER R2,FIFOS,B0,S75
	0
S76:!	XFER R2,FIFOS,B2,S77
S7X1:!	GOTO DXO
S77:!	XFER R2,FIFOS,B3,S78
S70:!	XFER R3,FIFO,B0,S71
	0
S78:!	XFER R2,FIFOS,B4,S70
S7A:!	XFER R2,FIFOS,B1,S76
	0
	MPAGE

W91:!	XFER R3,B1,FOFI,W92
W9X:!	GOTO DXE
W92:!	XFER R3,B2,FOFI,W93
W95:!	XFER R3,MRB,WHOLE,W96
W90:!	XFER R3,B0,FOFI,W91
W93:!	XFER R3,B3,FOFI,W94
W94:!	XFER R2,B4,FOFI,W95
W96:!	XANC CA,INCR,0,STRDC,W90
R91:!	XFER R3,FIFO,B1,R92
R9X:!	GOTO DXE
R92:!	XFER R3,FIFO,B2,R93
R95:!	XANC CA,INCR,R3,STWR,R90
W97:!	XANC CA,INCR,0,STRD,W95
R93:!	XFER R3,FIFO,B3,R94
R94:!	XFER R3,FIFO,B4,R95
R90:!	XFER R3,FIFO,B0,R91
	MPAGE

B91:!	XFER R3,FIFO,B3,B92
B9X:!	GOTO DXE
B92:!	XFER R3,FIFO,B2,B93
B95:!	XANC CA,DECR,R3,STWR,B90
B90:!	XFER R3,FIFO,B4,B91
B93:!	XFER R3,FIFO,B1,B94
B94:!	XFER R3,FIFO,B0,B95
	0
S91:!	XFER R3,FIFO,B1,S92
S9X:!	GOTO DXE
S92:!	XFER R3,FIFO,B2,S93
S90:!	XFER R3,FIFO,B0,S91
DXW:!	XFER R3,MRB,WHOLE,DXWA
S93:!	XFER R3,FIFO,B3,S94
S94:!	XFER R3,FIFO,B4,S90
DXWA:!	ON SRVOUT,DXW0
	MPAGE

DXE:!	TEST 0,0,WCOK1,DXE1
DXE2A:!	XANC CA,ADRFLD,R3,LOAD,DXE2B
DXE1:!	TEST 0,0,INS11,DXE2
	GOTO DEE1A	;DEV TRUNC
DXE2:!	GOTO XD2	;NO DC
	XANC PC,INCR,0,STRD
	XFER R3,MRB,WHOLE,DXE2A
DXE2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD
	TEST R3,B0,BIT00,DXE3
DXE3:!	ON INS1
	TEST R0,B1,BIT71,DXE4
DXE4:!	GOTO DXRE
	TEST R0,B0,BIT41,DXE5
DXE5:!	GOTO W7D
	GOTO W97
	MPAGE

DXO:!	TEST 0,0,WCOK1,DXO1
DXO2A:!	XANC CA,ADRFLD,R3,LOAD,DXO2B
DXO1:!	TEST 0,0,INS11,DXO2
	GOTO DEE1A	;DEV TRUNC
DXO2:!	GOTO XD3	;NO DC
	XANC PC,INCR,0,STRD
	XFER R3,MRB,WHOLE,DXO2A
DXO2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD
	TEST R3,B0,BIT00,DXO3
DXO3:!	ON INS1
	TEST R0,B1,BIT71,DXO4
DXO4:!	GOTO DXRO
	XANC CA,INCR,0,STRD
	GOTO W74
	0
	MPAGE

DXRE:!	TEST R3,B2,SKPC,DXRE1
	OFF CTBYT,DXRS
DXRE1:!	TEST R0,B1,RBAK,DXRE3	;NOT SKIP
	TEST R3,B3,Z,DXRE2	;POSS
DXRE2:!	TEST R0,B1,RBAK,DXRE3	;NOT SKIP
	TEST R0,B0,BIT41,DXRE4	;SKIP
DXRE3:!	TEST R0,B0,BIT41,DXRE5	;RD FWD
	TEST R0,B0,BIT41,DXRE6	;RD BAK
DXRE4:!	GOTO S70	;SKIP 7
	OFF CTBYT,S90	;SKIP 9
DXRE5:!	GOTO R70	;RD 7
	OFF CTBYT,R90	;RD 9
DXRE6:!	GOTO B70	;RB 7
	OFF CTBYT,B90	;RB 9
DXR:!	OFF SRVOUT
	TEST R0,B0,BIT71,DXRE
	MPAGE

DXRO:!	TEST R3,B2,SKPC,DXRO1
DXRS:!	TEST R3,B2,SKPC,DXRS1
DXRO1:!	TEST R0,B1,RBAK,DXRO3	;NOT SKIP
	TEST R3,B3,Z,DXRO2	;POSS
DXRO2:!	TEST R0,B1,RBAK,DXRO3	;NOT SKIP
	GOTO S75	;SKIP
DXRO3:!	GOTO R76	;RD FWD
	GOTO B76	;RD BAK
DXRS1:!	GOTO B7B	;NOT SKIP
	TEST R3,B3,Z,DXRS2	;POSS
DXRS2:!	GOTO B7B	;NOT SKIP
	GOTO S79	;SKIP
DXW0:!	HANG 0,0,STAI1
	TEST R0,B0,BIT41,DXW1
DXW1:!	OFF SRVOUT,W7C
	OFF SRVOUT,W96
	MPAGE

	BLOCK 6*20
	XALL
DEPHASE


PATCH:
PAT:!	BLOCK 1000

	LIT
	VAR

ORGBUF=20000+<1000*<<.+777>/1000>>	; Working buffer definition

	END DDTG
