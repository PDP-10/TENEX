
IFNDEF SALONE,<
	TITLE DISFOR -- FORTRAN DRIVER FOR DISPLAY ROUTINES
>



COMMENT $

THIS IS A DRIVER FOR THE DISPLAY ROUTINES FOR USE WITH FORTRAN
PROGRAMS.  IT INCLUDES CODE FOR READING IN THE APPROPRIATE
DEVICE-DEPENDENT SEGMENT OF CODE, AND SUBSEQUENTLY DISPATCHING
ALL CALLS TO THAT SEGMENT.


THIS PROGRAM IS TO BE ASSEMBLED WITH DISDEF.FAI, THE GLOBAL
DEFINITIONS OF CALLS, ETC. FOR THE DISPLAY ROUTINES.

$

BEGIN FORTRAN


IFNDEF SALONE,<
INTERNAL PPNRJF,DEVRJF
>

EXTERNAL ALCOR.,DECOR.		;USE FOROTS CORE ALLOCATION ROUTINES

PDLEN_20	;LENGTH OF PUSH-DOWN LIST

;EVERY SUBROUTINE CALL COMES TO THIS DISPATCHER.
;A SAMPLE ENTRY POINT LOOKS LIKE:
;
;	SIXBIT /DOT3/
;DDOT3: 0		;JSA 16,DDOT3 LEAVES OLD AC 16 HERE
;	JSP 0,DISP	;CALL DISPATCHER
;	JRST @23(S)	;DISPATCH TABLE ENTRY TO DISPLAY-DEPENDENT CODE
;	BYTE-WORD	;ARGUMENT TYPES.
;

DISP:	MOVEI	1,ACSAV		;SAVE ALL AC'S
	BLT	1,ACSAV+17	;LIKE SO.
	MOVE	P,[IOWD PDLEN,PDLIST]
	MOVEM	0,LASTDIS	;LAST ROUTINE CALLED.
	HRLI	0,(<POINT 4,0,35>) ;POINTER TO ARGUMENT TYPES.
	JRST	NEXT		;AND EXAMINE THEM.
PGO:	PUSH	P,1		;SAVE THIS ARGUMENT.
	ADDI	16,1		;GET NEXT ARGUMENT.
NEXT:	ILDB	2,0		;GET NEXT 4-BIT CODE.
	JRST	@DOTAB(2)	;...

DOTAB:	DISPA			;DONE -- GO TO ROUTINE.
	WINT			;INTEGER VALUE
	WREL			;REAL VALUE
	WPTR			;POINTER VALUE.

LASTDIS:	0		;DISPATCH LAST ROUTINE.
ACSAV:	BLOCK	20		;AC SAVE AREA.
RETLOC_ACSAV+16
PDLIST:	BLOCK	PDLEN		;PUSH-DOWN LIST FOR X ROUTINES

DISPA:	MOVEM	16,ACSAV+16		;SAVE FORTRAN AC.
	MOVEI	S,T			;POINTER TO DISPATCH
	MOVE	R,.DBASE(S)		;GET POINTER TO DATA AREA
	MOVE	0,.0SAV(S)		;AND RESTORE AC0
	XCT	@LASTDIS		;CALL ROUTINE WITH JRST

FRET:	TDZA	A,A			;RETURN 0
TRET:	MOVNI	A,1			;RETURN TRUE
	MOVEM	A,ACSAV			;RETURN IN AC 0
RET:	MOVEM	0,.0SAV(S)		;SAVE THE AC
	MOVSI	17,ACSAV		;RESTORE AC'S
	BLT	17,17			;LIKE SO.
	JRA	16,(16)			;RETURN TO CALLER.

WINT:	MOVE	1,@(16)			;PICK UP ARG.
	LDB	3,[POINT 4,(16),12]	;GET TYPE BITS.
	JUMPE	3,PGO			;OK.
	CAIE	3,2			;FLOATING?
	 JRST	 ERR1			;NO -- ERROR.
	PUSHJ	P,WFIXW			;FIX IT.
	JRST	PGO			;OK

WREL:	MOVE	1,@(16)			;ARG.
	LDB	3,[POINT 4,(16),12]
	CAIN	3,2			;REAL?
	 JRST	 PGO			;YES
	JUMPN	3,ERR1			;NO -- ERROR.
	PUSHJ	P,WFLOAT		;FLOAT THE INTEGER.
	JRST	PGO

WPTR:	MOVE	1,(16)			;GET ADDRESS.
	JRST	PGO			;AND STACK IT.


ERR1:	PUSHJ	P,@[XWD =2*40,WERROR]	;CALL ERROR PRINTER.
					;ERROR 8
	JRST	PGO			;AND GO WITH IT ANYWAY.


INT__1
REL__2
PTR__3
III__CLBASE

DEFINE CL & (NAM,ARGS,ROUT) <
	INTERNAL D&NAM
	SIXBIT /NAM/			;DISPLAY NAME
D&NAM:	0				;PLACE FOR JSA
	JSP	0,DISP			;CALL DISPATCHER.
	IFDIF <ROUT><>,<JRST ROUT>
	IFIDN <ROUT><>,<JRST @III(S)
		III__III+1
	>
	BBYTE_0
	BBPOS_=32
	IFDIF <ARGS><>,<
	FOR I IN (ARGS) {
	BBYTE_I  BBPOS ! BBYTE
	BBPOS_BBPOS-4
	}
	>
	BBYTE
>

DEFINE CI & (NAM) <
	.&NAM __ III
	III__III+1
>

CALLS					;PUT IN ALL THE SUBROUTINES
;MISCELLANEOUS ROUTINES.


WFIXW:	PUSH	P,2			;FIX VAL IN 1
	MULI	1,400
	TSC	1,1
	ASH	2,-243(1)
	MOVE	1,2
	POP	P,2
	POPJ	P,

WFLOAT:	PUSH	P,2		;FLOAT VAL IN 1
	IDIVI	1,400000
	SKIPE	1
	TLC	1,254000
	TLC	2,233000
	FAD	1,2
	POP	P,2
	POPJ	P,


;ERROR PRINTER
INTERNAL DERRHL
WERROR:	PUSH	P,A		;SAVE AN AC
	PUSH	P,B
	PUSH	P,C
	TTCALL	3,[ASCIZ /?DISPLAY ERROR #/]
	MOVE	A,-3(P)		;ADDRESS
	MOVE	A,-1(A)		;LITERAL LOCN.
	TLZ	A,777760	;ONLY SAVE INDEX FIELD.
	MOVEM	A,ERRLOC#	;SAVE IT. (IT WILL HAVE INDEX AC, MAYBE)
	LDB	A,[POINT 12,@ERRLOC,12] ;GET ERROR NUMBER
	PUSHJ	P,DECPNT
	TTCALL	3,[ASCIZ /; ROUTINE D/]
	MOVE	B,LASTDIS
	MOVE	B,-3(B)		;SIXBIT NAME.
W0:	SETZM	A
	LSHC	A,6
	JUMPE	A,W1
	ADDI	A,40
	TTCALL	1,A		;TYPE CHAR
	JRST	W0
W1:	SKIPG	@ERRLOC		;ONLY PRINT IF FATAL
	TTCALL	3,[ASCIZ /
 CALLED FROM /]
	HRRZ	A,RETLOC
	SUBI	A,1
	SKIPG	@ERRLOC		;ONLY PRINT IF FATAL
	PUSHJ	P,OCTPNT	;PRINT IT.
	TTCALL	3,[ASCIZ /
/]
	POP	P,C
	POP	P,B
	POP	P,A
DERRHL:	SKIPL	@ERRLOC		;FATAL?
	 POPJ	 P,		;NO -- IT WILL HANDLE IT.
	CALLI	12		;EXIT.

DECPNT:	MOVEI	C,=10
	SKIPA
OCTPNT:	MOVEI	C,10
RECUR:	IDIVI	A,(C)		;LEAVES REMAINDER IN B.
	ADDI	B,"0"
	HRLM	B,(P)
	SKIPE	A
	 PUSHJ	 P,RECUR
	HLRZ	B,(P)
	TTCALL	1,B		;TYPE THE CHARACTER.
	POPJ	P,
;LANGUAGE-DEPENDENT ROUTINES

;ROUTINE TO TRANSFER MATRIX POINTED TO BY B INTO
;THE WORK MATRIX.  THE WORK MATRIX IS STORED WITH
;COLUMN NUMBER THE MOST RAPIDLY-VARYING.  WE
;MUST CHANGE THAT FOR FORTRAN.

PUTMAT:	MOVEI	C,WORKM-1(R)	;FIRST ELEMENT IN MATRIX
	MOVEI	D,4		;FOUR ROWS TO FILL.
PUT0:	PUSH	C,(B)		;ROW 1, COLUMN 1
	PUSH	C,4(B)
	PUSH	C,=8(B)
	PUSH	C,=12(B)
	ADDI	B,1
	SOJG	D,PUT0		;LOOP FOR 4 ROWS.
	POPJ	P,

STRING:	MOVE	A,(16)		;==> ENCODED ARRAY
	HRLI	A,(<POINT 7,0>)
	MOVEM	A,BYTEP#
	MOVEI	A,2
	ADDB	A,ACSAV+16		;BUMP RETURN ADDRESS
	MOVE	16,@-1(A)		;COUNT.
	MOVNI	A,1
	PUSHJ	P,@.TEXT(S)		;START STRING.
SLOP:	SOJL	16,STRD			;ANY MORE?
	ILDB	A,BYTEP
	PUSHJ	P,@.TEXT(S)
	JRST	SLOP
STRD:	MOVNI	A,2
	PUSHJ	P,@.TEXT(S)
	JRST	RET


;INITIALIZATION ROUTINES (PHASE 1)

INIGO:
	MOVE	A,(P)		;IF USER WANTS HISEG DISPLAY
	CAIN	A,1		;FILE, SKIP INITIALIZATION
	JRST	INIG2		;YES - HISEG
;HERE WHEN LOSEG CORE ALLOCATION REQUESTED TO CHECK IF FORSE
;IS LOADED
	MOVS	A,ALCOR.	;GET INSTR AT ALCOR.
	CAIE	A,254200	;IS IT A HALT
	JRST	INIG3		;NO-OK FOROTS LOADED
			;YES-ERROR SINCE FORSE CANNOT BE USED
			;WITH LOSEG
REPEAT 0,<
	TTCALL	3,[ASCIZ /FORSE REQUIRES HIGH SEGMENT CORE ALLOCATION.
LOW SEGMENT SPECIFICATION IGNORED.
/]
>

REPEAT 0,<
	TTCALL 3,[ASCIZ /ERROR *** FORSE REQUIRES HIGH SEGMENT DISPLAY FILE.
LOW SEGMENT REQUEST IGNORED.  YOU SHOULD EITHER RELOAD YOUR PROGRAM 
WITH FOROTS OR EXPLICITLY REQUEST HIGH SEGMENT DISPLAY FILE BY 
CHANGING THE 4TH ARG OF THE DINI CALL TO 1.  TYPE HELP OMNI FOR AN
EXPLANATION OR CALL 496-4823.
/]
>
	MOVEI	A,1		;SET SEGMENT FLAG TO HISEG
	MOVEM	A,(P)
	JRST	INIG1		;NO INITIALIZATION NEEDED
;HERE TO INITIALIZE FOR LOSEG CORE ALLOCATION
INIG3:	SETZM	.LANG(S)		;SAY THIS IS FORTRAN
;PATCH IN ADDRESSES OF FORTRAN CORE ALLOCATION ROUTINES
	MOVEI	A,ALCOR.
	MOVEM	A,.GET(S)
	MOVEI	A,DECOR.
	MOVEM	A,.REL(S)
	
	MOVEI	A,PATADR	;FIXUP ADDRESS FOR PATCHING
	MOVEM	A,.PADR(S)


IFDEF SALONE,<
	MOVEI	A,DISNUM
	SKIPN	A		;IF STAND-ALONE FOR 340
	PUSHJ	P,PATADR	;THEN PATCH
	JRST	INIG1
>

	MOVE	A,-3(P)		;GET DISPLAY # OR NAME
	CAMN	A,[SIXBIT /DEC340/]	;IS THIS THE 340?
	MOVEI	A,0		;YES
	SKIPN	A		;IS THIS THE 340?
	PUSHJ	P,PATADR	;YES - PATCH
	JRST	INIG1

;HERE WHEN HIGH SEG CORE ALLOCATION REQUESTED TO CHECK IF
;FOROTS LOADED
INIG2:	MOVS	A,ALCOR.	;GET INSTR AT ALCOR.
	CAIN	A,254200	;IS IT A HALT?
	JRST	INIG1		;YES - OK FORSE LOADED
			;NO - BUT FOROTS CANNOT BE USED
			;WITH HISEG DISPLAY FILE
REPEAT 0,<
	TTCALL	3,[ASCIZ /FOROTS REQUIRES LOW SEGMENT CORE ALLOCATION.
HIGH SEGMENT SPECIFICATION IGNORED.
/]
>

REPEAT 0,<
	TTCALL 3,[ASCIZ /ERROR *** FOROTS REQUIRES LOW SEGMENT DISPLAY FILE.
HIGH SEGMENT REQUEST IGNORED.  YOU SHOULD EITHER RELOAD YOUR PROGRAM 
WITH FORSE OR EXPLICITLY REQUEST LOW SEGMENT DISPLAY FILE BY CHANGING
THE 4TH ARG OF THE DINI CALL TO 0.  TYPE HELP OMNI FOR AN EXPLANATION
OR CALL 496-4823.
/]
>
	MOVEI	A,1		;SET SEGMENT FLAG TO HISEG
	SETZM	(P)		;SETUP STACK ENTRY TO SPECIFY LOSEG
	JRST	INIG3		;INITIALIZE FOR LOSEG CORE ALLOCATION
;HERE WITH ALL INITIALIZATIONS FOR THE CORRECT SEGMENT DONE OK
INIG1:
IFNDEF SALONE,<    ; CODE TO READ-IN THE APPROPRIATE SEGMENT

	MOVE	B,-3(P)		;GET DISPLAY NUMBER
	OPEN	OBLK		;TRY TO GET CHANNEL OPEN
	 JRST	 NODIS		;NO DISK == NO DISPLAY
	MOVE	A,PPNRJF
	MOVEM	A,INAM+3		;PPN
	LOOKUP	INAM
	 JRST	 NODIS		;NO SEGMENT FILE == NO DISPLAY
AG:	INPUT [IOWD ROUTSIZE,<TT+PCHBRK>
				0]
	STATZ	20000		;LOOK FOR END OF FILE.
	 JRST	 NODIS
	CAME	B,.DISN(S)	;CORRECT DISPLAY NUMBER
	CAMN	B,.DISNM(S)	;OR CORRECT SIXBIT NAME?
	 JRST	 GOTIT		;YES
	JRST	AG		;NO -- LOOK FARTHER

INAM:	SEGNAM			;SIXBIT NAME OF SEGMENT.
	SIXBIT	/SEG/
	BLOCK	2
PPNRJF:	SEGPPN

OBLK:	17
DEVRJF:	SEGDEV
	0


NODIS:	PUSHJ	P,@[XWD S+(=14*40),.ERRGO]
	SUB	P,[XWD 4,4]	;GET RID OF ALL ARGS.
	JRST	FRET		;RETURN FALSE, FALSE, FALSE

GOTIT:	RELEASE

>
IFDEF SALONE,<     ; CODE TO MOVE LOW PART OF DISPATCH TABLE
		   ; BACK WHERE IT BELONGS.
^T_CBEG			;BEGINNING OF CODE AREA

	MOVE	A,[XWD TT+.FIX,CBEG+.FIX]
	BLT	A,CBEG+PCHBRK-1
>

	JRST @.INI(S)		;GO TO DISPLAY-DEPENDENT PART

;ROUTINE CALLED BY FOROTS WHEN IT MUST EXPAND CORE AND THE
;340 IS INIT'D. THIS ALLOWS OMNIGRAPH TO TAKE CARE OF
;STOPPING THE 340 AND UNLOCKING BEFORE CORE IS EXPANDED

?OMN.PT__20

FORTB:	PUSH	P,R		;SAVE AC'S AND SETUP NEW VALUES
	PUSH	P,0
	PUSH	P,A
	MOVEI	S,T		;SETUP AC'S
	MOVE	R,.DBASE(S)
	MOVE	0,.0SAV(S)
	SKIPN	.RUN(S)		;IS THE DISPLAY GOING?
	JRST	OMN1		;NO
	MOVE	A,OXSTAT(R)	;SAVE STATUS
	MOVEM	A,SAVSTAT
	MOVE	A,[XWD 4,400007]	;STOP 340 AND UNLOCK
	DISCAL	A
OMN1:	MOVE	S,.JBOPS	;SETUP AC 15
	MOVEI	A,FORTA		;CHANGE OMNIGRAPH ENTRY POINT
	MOVEM	A,OMN.PT(S)
RST1:	POP	P,A	;RESTORE AC'S
	POP	P,0
	POP	P,R
	POPJ	P,


;ROUTINE CALLED BY FOROTS AFTER IT HAS EXPANDED CORE TO
;START 340 UP AGAIN

FORTA:	PUSH	P,R		;SAVE AC'S AND SETUP AC'S
	PUSH	P,0
	PUSH	P,A
	MOVEI	S,T		;SETUP AC'S
	MOVE	R,.DBASE(S)
	MOVE	0,.0SAV(S)
	SKIPN	.RUN(S)		;SHOULD WE TRY TO GET STARTED AGAIN
	JRST	OMN2		;NO
	MOVEI	A,OXSTAT(R)	
	HRLI	A,1		;TRY TO RE-SEIZE DISPLAY
	DISCAL	A
	JRST	OMN3		;CANNOT
	MOVE	A,SAVSTAT	;RESTORE DEVICE RUN BITS
	HRLI	A,3
	DISCAL	A		;RESTART DEVICES
OMN2:	PUSHJ	P,PATADR
	MOVE	S,.JBOPS
	JRST	RST1
OMN3:	TTCALL	3,[ASCIZ /CANNOT RE-SEIZE DISPLAY
/]
	TLZ	DISRUN		;SAY NO LONGER RUNNING
	MOVEM	.0SAV(S)
	SETZM	.RUN(S)
	JRST	OMN2


PATADR:	PUSH	P,S		;SAVE AC S
	MOVE	S,.JBOPS	;SETUP S TO POINT TO BASE OF FOROTS
				;LOW SEG STATIC DATA AREA
	MOVEI	A,FORTB
	MOVEM	A,OMN.PT(S)
	POP	P,S
	POPJ	P,


SAVSTAT:	0	;FOR SAVING DEVICE RUN BITS

CADR:	CBLK		;FOR ALLOCATING CHANNEL VIA FOROTS
	-1	
CBLK:	0



IFNDEF SALONE,<
^T:
>
TT:			;HERE BEGINS THE DISPATCH TABLE.
	0		;SAVE REGISTER 0
	0		;POINTER TO DATA AREA
	WFIXW		;FIX ROUTINE
	WFLOAT		;FLOAT ROUTINE
	PUTMAT		;MATRIX TRANSFER ROUTINE
	TRET		;RETURN TRUE
	FRET		;RETURN FALSE
	RET		;RETURN INTEGER
	RET		;RETURN
	JRST 	WERROR	;.ERRGO
	0		;DEFINES WHICH CORE ALLOCATION METHOD
			;0 IF LOW SEG, -1 IF HISEG
;THE FOLLOWING ENTRIES ARE USED ONLY BY THE LOW SEGMENT
;CORE ALLOCATION METHOD
	ALCOR.		;FOR ADDRESS OF ALCOR.
	DECOR.		;FOR ADDRESS OF DECOR.
	PATADR		;FOR ADDRESS OF PATCH ROUTINE
	0		;FLAG IF DISPLAY IS RUNNING
	0		;FLAG WHICH LANGUAGE
	BLOCK 20		;FOR AC SAVE AREA


IFNDEF SALONE, <

;IF THESE ARE NOT STAND-ALONE ROUTINES, HERE IS WHERE WE LEAVE
;A BLOCK OF STORAGE FOR THE ROUTINES TO BE READ INTO.

BLOCK	ROUTSIZE

>
BEND
END

