;<DODDS>TELNET.MAC;92    28-JUN-74 15:37:13    EDIT BY DODDS
;  1) CORRECTED OPERATION WITH SCREEN TERMINALS
;  2) ADJUSTMENT FOR MORE GENERAL /HSTNAM/ TABLE
;  3) HOST.NAMES LISTER,  4) REENTER ADR,  5) NO EOL'S TO NON-TERMINALS
;<DODDS>TELNET.MAC;77    22-MAY-74 10:27:02    EDIT BY DODDS
; 1) Numerous adjustments to assure proper AC's, esp. CNX after
;    escapes, fork restarts, aborted connecs., etc., due to BCPL rtns
;<DODDS>TELNET.MAC;71    15-MAY-74 15:23:42    EDIT BY DODDS
; 1) Typescript files changed to access to self only.
; 2) Cnx state change interrupt to report host-not-responding & restored
; 3) For failed connec. or IO error, host down status (if any) reported.
;<DODDS>TELNET.MAC;63    21-APR-74 01:43:40	EDIT BY DODDS
; 1) Improved restart/resume logic for receive fork
; 2) Ability to send new protocol commands manually (command do...)
;<DODDS>TELNET.MAC;56    16-APR-74 21:12:54	EDIT BY DODDS
; 1) Slight change to data block ST to make INS ctr whole word
; 2) Added scheme to time out unmatched Data-Marks
; 3) Changed (foreign) default socket to 27 (temporary)
;<DODDS>TELNET.MAC;50    15-APR-74 13:40:00	EDIT BY DODDS
; 1) Removed all old protocol operations
; 2) New commands option.state.for.current.conn and recognized.options
; 3) New protocol action routines for Echo, Timing-Mark, Suppr-GA
; 4) Revamped handling of INS/DM
;<DODDS>TELNET.MAC;38    10-APR-74 11:34:00	EDIT BY DODDS
; Initial conversion to use of BCPL-coded primitives:
;  1) NET: JFN's and option data moved to grand data block ST
;  2) ICP done by BCPL rtn DOAICP & subsidiaries
;  3) All network I/O done by SNDCH, RCVCH, TRNSMT & subsidiaries
;  4) New goodie for symbol lookup where search for "no match" obtains,
;      e.g., .STNAM
;<DODDS>TELNET.MAC;17    23-JAN-74 11:39:30	EDIT BY DODDS
; Fix of minor bug in symbol evaluator: ? to name.curr... with empty tab
;<DODDS>TELNET.MAC;15     5-NOV-73 15:26:54	EDIT BY DODDS
; Conversion to MACRO and repaging
;<DODDS>TELNET.FAI;4     3-NOV-73 08:03:43	EDIT BY DODDS
;<JOHNSON>TELNET.FAI;29    16-APR-73 11:18:32	EDIT BY JOHNSON
; CHANGE NEWS SOCKET TO 367 (OCTAL) FROM 15600031
;<SOURCES>TELNET.FAI;28    18-JAN-73 11:20:44	EDIT BY TOMLINSON
;<SOURCES>TELNET.FAI;27    17-JAN-73 16:46:23	EDIT BY TOMLINSON
;<SOURCES>TELNET.FAI;26    16-JAN-73 10:52:09	EDIT BY TOMLINSON
; Deleted surveying and time constant. Revamped receive fork.
;<TOMLINSON>TELNET.FAI;13    15-JAN-73 14:02:33	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;12    15-JAN-73 13:43:16	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;11    15-JAN-73 13:13:11	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;10    15-JAN-73 12:29:13	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;9    15-JAN-73 11:57:40	EDIT BY TOMLINSON
;<TOMLINSON>MESSAGE.TXT;2    14-JAN-73 17:10:46	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;6    14-JAN-73 16:51:00	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;5    14-JAN-73 13:50:18	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;4    14-JAN-73 13:20:44	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;3    11-JAN-73 14:12:15	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;2    11-JAN-73 13:32:49	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;1    11-JAN-73 12:36:52	EDIT BY TOMLINSON
;<SOURCES>TELNET.FAI;25    10-SEP-72 10:07:17	EDIT BY TOMLINSON

;<SOURCES>TELNET.FAI;24     8-SEP-72 10:02:57	EDIT BY TOMLINSON
;<SOURCES>TELNET.FAI;23     8-SEP-72  9:08:11	EDIT BY TOMLINSON
;<SOURCES>TELNET.FAI;22     5-SEP-72 11:37:29	EDIT BY TOMLINSON
;<SOURCES>TELNET.FAI;21     5-SEP-72 11:33:24	EDIT BY TOMLINSON
;<SOURCES>TELNET.FAI;20     5-SEP-72 11:17:41	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;46     3-SEP-72 11:37:58	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;45     2-SEP-72 16:02:59	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;44     2-SEP-72 15:56:36	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;43     2-SEP-72 15:54:09	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;42     2-SEP-72 15:28:21	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;41     2-SEP-72 15:13:34	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;40     2-SEP-72 14:54:29	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;39     2-SEP-72 14:45:07	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;38     2-SEP-72 14:43:04	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;37     2-SEP-72 14:19:33	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;36     2-SEP-72 13:59:08	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;35     2-SEP-72 13:57:07	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;34     2-SEP-72 12:04:40	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;33     2-SEP-72 11:33:29	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;32    28-JUL-72 15:15:14	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;31    28-JUL-72 14:24:37	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;30    28-JUL-72 14:17:41	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;29    28-JUL-72 13:27:03	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;28    28-JUL-72 11:42:16	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;27    28-JUL-72 11:23:30	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;26    28-JUL-72 11:09:29	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;25    28-JUL-72 10:53:32	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;24    28-JUL-72 10:29:02	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;23    27-JUL-72 16:59:25	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;22    27-JUL-72 16:01:50	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;21    27-JUL-72 15:55:01	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;20     3-JUL-72 13:29:08	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;19     3-JUL-72 13:22:25	EDIT BY TOMLINSON
;<TOMLINSON>TELNET.FAI;10    29-JUN-72 21:15:41	EDIT BY TOMLINSON

	TITLE TELNET (USER)
	SUBTTL	R.S.Tomlinson

	SEARCH STENEX

ENTVEC:	JRST START		; entry vector: start adr
	JRST START		; restart adr, changed later
	JRST NPSURV		; ENTRY TO SURVEY OF INSTALLATIONS
	JRST SURVEY		; ENTRY TO DOWN-STATUS SURVEY

VERNUM:	ASCIZ \4.3 1-JUL-74\
	BLOCK 3

ST:	STBLK			; pointer to BCPL data area

OPDEF	ERROR[1B8]


; Accumulators

A=1
B=2
C=3
D=4
X=5
Y=6
Z=7
PTR=10
TAB=11
NOA=12
CNX=13
NCNX=14
P=17
F=0

; Flags (rh of f)

REMOTF==1		; Operating in remote mode
COMMDF==4		; In command mode
NSTIWF==2		; Don't do stiw's
ICPMOD==10		; ICP in progress
TMPF==400000		; Temporary flags
TMPF2==200000
TMPF3==100000
TMPF4==40000
TMPF5==20000
TMPF6==10000

; Parameters

NPDL==2000		; Size of push list
NCONN==7		; Number of connections to remember
NHSTW==[^D256+^D35]/^D36 ; Number of words in host bit tables
IESC=="Z"-100		; Initial escape character
ICBF=="O"-100		; Initial clear output buffer character
ESCCHN==0		; Use channel 0 for escape
ABNCHN==2		; Channel 2 for abnormal connection termination
NTICHN==3		; Channel 3 for network psi's
CBFCHN==4
SAVBFS==4000		; Size of string saving buffer
NMOPTS==^D9		; highest option # supported 

LOC 200000		; FORK DATA AREA

SPDL:	BLOCK 100
FKRET1:	BLOCK 1
FKRET2:	BLOCK 1
FKRET3:	BLOCK 1
ACSAV:	BLOCK 21		; to save fork's AC's for BCPL rtn calls
BCLFLG:	BLOCK 1			; BCPL rtn in progress for intrpt rtns
FSVCNX:	BLOCK 1			; fork's cnx for use by INSRCV
IRSST:	BLOCK 1			; ditto temp for Send status
ISPDL:	BLOCK 100		; Ditto pdl
IACSAV:	BLOCK 20		; ditto AC save area
ISTBAS:	BLOCK 100		; ditto BCPL stack
STBAS:	BLOCK ^D500		; stack for BCPL rtn calls
SAVBUF:	BLOCK SAVBFS

LOC 100000		; Where to store variables

; Variables etc.

ARRAY	HOSTRG[4*^D256]
ARRAY	SHOSTB,NHOSTB[^D256]
INTEGER	SHSTAB,NHSTAB,CONTAB
ARRAY	PDL[NPDL]
ARRAY	COMBUF[200]
ARRAY	BIGBUF[4000]
INTEGER	LODFLG,WATFLG,TCASE,TRMLWC
INTEGER	BPTR,LPTR,SVP
INTEGER	TTCOC0,TTCOC1,TTMOD0,TTMODR,TTMODC,JOBTIW,HDX,NFANCY
INTEGER	ESCAPE,ESCCOD,CBFCHR,CBFCOD,LSTBDI,CONCSF
INTEGER	ABNLCK,ABNCNX
INTEGER	LCASCF,UCASCF
INTEGER	LCASC,LCASL,UCASC,UCASL,UNSFT
INTEGER	BRKC,SYNC,QUOT,QUOTF
ARRAY	FAC[20]
INTEGER	IJFN,JJFN,AJFN,SCRJFN,SCRCNT,SCRTIM,REALTT
INTEGER	DIVJFN,DIVSWT,RLACJ,SPCFRK
INTEGER	SKTMSK,FSKT,FHST,FHSTN,RETPC1,RETPC2,RETPC3
ARRAY	SNDFRK,RCVFRK,DMTIME,LSKT,ELCLF,LFCRF,LNBFF[NCONN+1]
ARRAY	XPARNT,RCVBSW,CBFCNT,ALTJFN,ALTJCT[NCONN+1]
ARRAY	RAISEF,LOWERF,ECHCOC,CONTB,SAVINP,SAVINC,SAVONP,SAVSWT[NCONN+1]
ARRAY	CONNAM[3+3*NCONN]
INTEGER	ICPTIM,SUMTOT,SUMPHC,SUMSCL,SUMTIM,SUMTM2,SUMFST,SUMSRT,SWOFLG
ARRAY	SUMAVG,SUMAVC,SUMUPT,SUMUPC,SUMTTC[400]
INTEGER	TERM
INTEGER	JUNK
INTEGER	NTICNT,NTIIA,CLROBF
ARRAY	LINBUF[200]

INTERN	ST
EXTERN	SNDCH,TRNSMT,SNDSYN,RCVCH,DOOPT,DNTOPT,WILOPT,WNTOPT,SUBOPT
EXTERN	INSRCV,DOAICP,INITPK,DSCNXE,DRCNXE,DSCNCT,RTNSST,SETSST,CLRSST
EXTERN	RTSJFN,RTRJFN,STRPCH,RSITM,RSOTM,RTOPTS,ZINSCT,BRKSND
EXTERN	RTNOSC,RTNISC
RELOC


; The following macro generates a "supersafe" calling sequence to
; the BCPL subroutines: it saves all AC's, then loads all arguments
; (any number) into the stack, sets up 16 as the stack pointer, puts
; number of arguments into pos. 1 on the stack, then calls the routine.
; On return, it saves the (possible) value returned in 1 and restores
; the previous AC's.  It is therefore completely transparent to all AC's
; A flag is set on entry and cleared on return to show BCALL in progress
; for interrupt routines

DEFINE	BCALL(RTN,ARG)<
	MOVEM 17,ACSAV+17
	MOVEI 17,ACSAV
	BLT 17,ACSAV+16
	SETOM BCLFLG
NNN==0
IRP ARG
<	MOVE 1,ARG
NNN==NNN+1
	MOVEM 1,STBAS+NNN+1
>	MOVEI 16,STBAS
	MOVEI 1,NNN
	MOVEM 1,STBAS+1
	JSP 1,RTN
	MOVEM 1,STBAS
	HRLZI 17,ACSAV
	BLT 17,17
	AOS BCLFLG
>

; The following macro merely adds an instruction to BCALL to place
; a returned value in 1 after restoring the AC's.  It should be used for
; any call to a function.  It is of course transparent except to 1.
; DANGER: A list of more than one ARG to BVCALL, i.e., ARG1,ARG2,...
; must be enclosed by double <>'s: <<ARG1,ARG2,ARG3>> as one set is
; stripped off at each level of macro processing.

DEFINE	BVCALL(RTN,ARG)<
	BCALL(RTN,ARG)
	MOVE 1,STBAS
>

; This macro is to restore the pre-BCPL-call AC's if a BCALL in
; progress.  This may matter a lot to interrupt handlers.

DEFINE	BCLRST<
	AOSE BCLFLG
	JRST BCLEND
	HRLZI 17,ACSAV
	BLT 17,17
BCLEND==.
>


; This macro generates the setup sequence for a BCPL call at 
; the interrupt level

DEFINE	BISTUP(ARG)<
	MOVEM 17,IACSAV+17
	MOVEI 17,IACSAV
	BLT 17,IACSAV+16
NNN==0
IRP ARG
<	MOVE 1,ARG
NNN==NNN+1
	MOVEM 1,ISTBAS+NNN+1
>	MOVEI 16,ISTBAS
	MOVEI 1,NNN
	MOVEM 1,ISTBAS+1
>

; This macro sets up the whole BCPL call for use at the interrupt 
; level.  WATCH OUT: double <>'s are required for a multiple ARG list
; in this macro.

DEFINE	BICALL(RTN,ARG)<
	BISTUP(ARG)
	JSP 1,RTN
	MOVEM 1,ISTBAS
	HRLZI 17,IACSAV
	BLT 17,17
>

; The following macro merely adds an instruction to BICALL to place 
; a returned value in 1 after restoring the AC's.  EXTREME DANGER:
; a multiple arg list in this macro requires TRIPLE <>'s!!!

DEFINE	BVICAL(RTN,ARG)<
	BICALL(RTN,ARG)
	MOVE 1,ISTBAS
>




; Program starts here

START:	MOVEI A,100
	SIBE
	JRST RSTART
	HRROI A,[ASCIZ /
User Telnet /]
	PSOUT
	HRROI A,VERNUM
	PSOUT
	HRROI A,[ASCIZ /.  Type HELP<cr> for help./]
	PSOUT
RSTART:	RESET			; Reset the world
	MOVE P,[XWD -NPDL,PDL-1]
	MOVE A,[PUSHJ P,UUO]
	MOVEM A,41
	MOVEI A,400000
	RPCAP			; Find out what we can do
	AND B,[1B0!1B2]
	IOR C,B
	EPCAP			; Enable control-c stealing
	TLNE C,(1B0)
	TROA F,NSTIWF
	TRZ F,NSTIWF
	SETZB F,VARS
	MOVE A,[XWD VARS,VARS+1]
	BLT A,EVARS-1		; Zero all variables, set BCPL params
	BCALL(INITPK,<[OPTRTN],[NMOPTS],[JRST ZCFOBF],[JRST RCVBIN]>)
	MOVE A,[SIXBIT /HOSTN/]
	SYSGT
	PUSH P,B
	MOVE A,[SIXBIT /HSTNAM/]
	SYSGT
	PUSH P,B
	MOVEI Y,NHOSTB-1
	MOVEI X,SHOSTB-1
	MOVEI C,HOSTRG-1
	HLLZ D,-1(P)

GTHSTL:	HRRZ A,-1(P)
	HRL A,D
	GETAB
	 0
	MOVEI B,1(C)
	HRLI B,(<POINT 7,0>)
	TLNN A,(1B0)
	 JRST [	PUSH Y,B
		JRST .+2]
	PUSH X,B
	MOVE B,A
GTHSTE:	HRRZ A,0(P)		; Hostab number
	HRL A,B			; Offset
	GETAB
	 0
	MOVE PTR,[POINT 7,A]
	MOVEI Z,5
GTHSTX:	ILDB NOA,PTR
	SKIPN NOA
	 JRST [ SOJLE Z,GTHSTY
		IDPB NOA,PTR
		JRST GTHSTX+2 ]
	SOJG Z,GTHSTX
GTHSTY:	PUSH C,A		; Store in hostrg
	TRNE A,377
	 AOJA B,GTHSTE		; Loop
	LDB A,[POINT 9,B,17]
	PUSH C,[PUSHJ P,.CVHST]
	PUSH C,A
GTHSTN:	AOBJN D,GTHSTL
	HLLZS X
	HLLZS Y
	MOVNS X
	MOVNS Y
	HRRI X,SHOSTB
	HRRI Y,NHOSTB
	MOVEM X,SHSTAB
	MOVEM Y,NHSTAB
	SUB P,[XWD 2,2]
	SETOM ABNLCK		; Unlock abnormal interrupt handler.
	SETOM UCASC
	SETOM UCASL
	SETOM LCASC
	SETOM LCASL
	SETOM UNSFT
	SETOM QUOT
	SETOM BRKC
	SETOM SYNC
	MOVSI B,-NCONN

ICNVL:	MOVE A,[BYTE (1)0,0,0,0,0,0,0,1,0,1,1,0,0,1]
	MOVEM A,ECHCOC(B)	; Initial control character local echo
	SETOM LFCRF(B)
	SETOM ELCLF(B)
	AOBJN B,ICNVL
	MOVEI A,CONTB
	MOVEM A,CONTAB		; Contab points at contb
	SETZ NOA,
	PUSHJ P,SETSCR		; Set up for typescript
	MOVEI A,IESC		; Setup initial escape character
	MOVEM A,ESCAPE
	PUSHJ P,CVINTC		; Convert character to interrup channel
	 HALT .			; Can't fail
	MOVEM A,ESCCOD
	MOVEI A,ICBF
	MOVEM A,CBFCHR
	PUSHJ P,CVINTC
	 HALT .
	MOVEM A,CBFCOD
	SETZM FSVCNX
	MOVEI A,400000
	CIS
	MOVE B,[XWD LEVTAB,CHNTAB]
	SIR
	EIR
	MOVEI A,100
	RFMOD			; Find out what kind of line we have
	MOVEM B,TTMOD0		; Remember same
	TRNE B,1B32		; Hdx terminal?
	 SETOM HDX		; Yes, set hdx flag
	TLNE B,(1B3)
	 SETOM TRMLWC		; Remember term has lower case
	ANDCMI B,77B23!3B25!17B29!1B30!1B31
	PUSH P,B
	IORI B,17B23!0B25!1B29
	MOVEM B,TTMODC		; In command mode: break-all, echo-none
	POP P,B
	IORI B,17B23!1B29
	MOVEM B,TTMODR		; No change for remote mode
	RFCOC			; Get standard control output control
	MOVEM B,TTCOC0
	MOVEM C,TTCOC1
	MOVE A,[JRST PCLP]	; set up restart adr
	MOVEM A,ENTVEC+1
PCLP:	MOVEI A,ESCCHN		; Psi channel
	HRL A,ESCCOD		; Escape terminal code
	ATI
	MOVEI A,CBFCHN
	HRL A,CBFCOD
	ATI			; Assign
	MOVE B,[1B<ESCCHN>!1B<ABNCHN>!1B<NTICHN>!1B<CBFCHN>!1B9!1B11!1B15!7B18]
	MOVEI A,400000
	AIC			; Activate interrupt channel

; Main command loop

COMLP:	TRO F,COMMDF
	TRZ F,TMPF3!ICPMOD
	MOVEI A,101
	DOBE
	MOVE P,[XWD -NPDL,PDL-1]
	MOVE NCNX,CNX
	SETO B,
	MOVEI A,-5
	TRNN F,NSTIWF
	STIW			; Restore terminal interrupt word
	MOVEI A,100
	MOVE B,TTMODC
	SKIPE NFANCY
	 JRST [	TRZ B,77B23
		TRO B,2B25!16B23
		JRST .+1]
	SFMOD			; Set tty mode for command input
	MOVE B,[BYTE (2)0,0,1,1,1,1,1,2,0,2,2,1,2,2,1,1,1,1]
	MOVE C,[BYTE (2)0,1,1,1,1,1,0,1,1,0,1,1,1,2]
	SFCOC
	HRROI A,[ASCIZ /
#/]
	PUSHJ P,.PSOUT		; Prompt character
	MOVE PTR,[POINT 7,COMBUF-1,34]
	MOVEM PTR,LPTR		; Pointer to beginning of line
	MOVEI A," "
	IDPB A,PTR		; Deposit initial space to line up
	MOVE TAB,COMTAB		; Setup to use comtab
	PUSHJ P,SYMVAL		; Call symbol evaluator
	BVCALL(DSCNXE,CNX)	; Was connection created or
	SKIPE A
	TRNN F,REMOTF		; Remote mode?
	 JRST COMLP		; No. stay in command mode
	TRZ F,COMMDF
	MOVEM CNX,FSVCNX	; save CNX for later restoration
	HRROI A,[ASCIZ /#
/]
	PUSHJ P,.PSOUT
	MOVEI A,-5
	MOVN C,ESCCOD
	MOVSI B,400000
	ROT B,(C)		; Get bit for escape code
	PUSH P,B
	MOVN C,CBFCOD
	MOVSI B,400000
	ROT B,0(C)
	IORM B,0(P)
	POP P,B
	IORI B,1B30		; Include carrier off
	TRNN F,NSTIWF
	STIW			; And set tiw to that

	MOVEI A,100
	MOVE B,TTMODR
	SKIPE XPARNT(CNX)
	 TRZ B,3B29
	SFMOD			; Set tty mode for remote
	MOVEI A,101
	GTTYP
	SETZ C,
	CAIL B,12		; is terminal a scope?
	 JRST [ EXCH C,B
		STTYP		; yes, save & set to 33 for remote
		JRST .+1 ]
	MOVEM C,REALTT		; save terminal type or 0 if not scope
	MOVE A,RCVFRK(CNX)
	FFORK			; Freeze it
	MOVEI A,400000
	DIR			; Interrupts off to avoid confusion
	SETZM SAVSWT(CNX)	; Resume output
	MOVE A,RCVFRK(CNX)
	RFSTS			; Get pc of receive fork
	MOVE A,RCVFRK(CNX)
	HRRZS B
	CAIG B,RECV0		; If fork will get back to RECVO
	 JRST REST2		;  let it proceed
	CAIG B,RECVB
	 JRST REST1
	CAIL B,RCVBX
	CAILE B,RCVB1+1
	SKIPE RCVBSW(CNX)
	 JRST REST1
	JRST REST2
REST1:	MOVEI B,RECV0		; Else restart it at RECV0
	SFORK
REST2:	MOVE A,SNDFRK(CNX)	; if io wait and input file assigned,
	RFSTS
	MOVE A,SNDFRK(CNX)
	HRRZS B
	CAIN B,PBINX+1
	SKIPN ALTJFN(CNX)
	JRST REST3
	MOVEI B,.PBIN	; restart .PBIN to prevent input hang
	SFORK
REST3:	MOVEI A,400000
	EIR
	MOVE A,RCVFRK(CNX)
	RFORK			; And resume
	MOVE A,SNDFRK(CNX)
	RFORK			; Resume send fork
	WFORK			; Should wait forever
	HRROI A,[ASCIZ /
Funny fork termination. Restarted./]
	PUSHJ P,.PSOUT
	JRST RSTART

; Abnormal interrupts come here

BADINT:	MOVE CNX,FSVCNX
	MOVEI A,101
	DOBE
	TIME
	SUBI A,^D15000
	CAMGE A,LSTBDI		; Within 5 seconds of last bad int?
	 JRST BADBAD		; Very bad
	HRROI A,[ASCIZ /
Abnormal interrupt from location /]
	PUSHJ P,.PSOUT
	HRRZ B,RETPC1
	MOVEI C,10
	MOVEI A,101
	PUSHJ P,.NOUT
	 JFCL
	HRROI A,[ASCIZ /.
/]
	PUSHJ P,.PSOUT
	TIME
	MOVEM A,LSTBDI
	JRST ESCINZ

BADBAD:	HALTF
	JRST BADINT

; If remote host initiates disconnect, rec'v fork inits int'rpt to here

ABNINT:	MOVE CNX,FSVCNX
	MOVE X,ABNCNX		; Get the correct cnx
	BVICAL(RTSJFN,X)	; get sendjfn & convert to host #
	GDSTS
	MOVEM C,FHSTN
	PUSHJ P,HSTFLD		; report host failure status (if any)
	PUSHJ P,DISC1
	JRST ESCINZ

; Clear outbuf int comes here

CBFINT:	MOVE CNX,FSVCNX
	BVICAL(DSCNXE,CNX)
	SKIPE A
	AOSE QUOTF
	 JRST CBFINZ
	PUSH P,B
	MOVEI B,SENDO
	JRST SPCSND


CBFINZ:	SETOM CLROBF
	PUSH P,A
	MOVEI A,101
	CFOBF
	POP P,A
	DEBRK
	DEBRK

; Escape interrupt comes to here

ESCINT:	AOSE QUOTF		; IF QUOTE PREFIX TYPED AND
	 JRST ESCINV
	MOVE CNX,FSVCNX
	BVICAL(DSCNXE,CNX)
	SKIPN A			; If connection exists,
	 JRST ESCINV
	PUSH P,B
	MOVEI B,SENDE
SPCSND:	PUSH P,A		; Then sent escape character
	MOVE A,SNDFRK(CNX)
	FFORK
	SFORK
	RFORK
	POP P,A
	POP P,B
	DEBRK

ESCINV:	MOVEI A,100
	CFIBF			; DO THIS EARLY FOR PERFORMANCE
	BCLRST
	MOVEI A,101
	TRNE F,COMMDF		; COMMAND MODE?
	 CFOBF			; YES, FLUSH OUTPUT
	JRST ESCINY
ESCINZ:	BCLRST			; restore AC's if in BCPL rtn
	MOVEI A,100
	CFIBF
ESCINY:	SKIPE RLACJ		; Is there likely to be a jfn in ac 1?
	TDNE A,[XWD -1,700000]
	SKIPA			; Apparently not
	 PUSHJ P,CLRJFN		; Apparently yes
	SETZM RLACJ
	SKIPE A,SNDFRK(CNX)	; If there is a send fork
	 FFORK			; Freeze it
	BVICAL(DRCNXE,CNX)
	SKIPN A			; Connected?
	 JRST ESCINW		; No, skip this
	SETOM SAVSWT(CNX)	; Switch to saving input
	MOVE A,RCVFRK(CNX)
	RFORK			; Leave running

ESCINW:	SKIPE A,SPCFRK		; If there is a special fork
	 KFORK			; Kill it
	SETZM SPCFRK
	SKIPE A,AJFN
	 PUSHJ P,CLRJFN
	SETZM AJFN
	SKIPE A,JJFN
	 PUSHJ P,CLRJFN
	SETZM JJFN
	SKIPE A,IJFN
	 PUSHJ P,CLRJFN
	SETZM IJFN		; Release temporary jfn's
	TRNE F,ICPMOD
	 PUSHJ P,RELCON		; release connections if ICP was in prog
	SKIPE B,REALTT		; scope terminal type saved?
	 JRST [ MOVEI A,101
		STTYP		; yes, restore type for command mode
		MOVEI A,100
		SIBE		; any type-ahead since cfibf?
		 JRST .+1	; yes, restored ok
		MOVEI B,40
		STI		; no, simulate char in to break
		PBIN		;  scroll hold, if any
		JRST .+1 ]
ESCI1:	MOVE A,[XWD 10000,COMLP]
	MOVEM A,RETPC1
	DEBRK			; Debrk back to comlp

LEVTAB:	RETPC1
	RETPC2
	RETPC3

CHNTAB:	REPEAT ESCCHN,<XWD 1,BADINT>
	XWD 1,ESCINT
	0
	XWD 1,ABNINT
	XWD 3,NTIINT
	XWD 2,CBFINT
	REPEAT <^D36-5-ESCCHN>,<XWD 1,BADINT>

FKLVT:	FKRET1
	FKRET2
	FKRET3

FKCHT:	0
	XWD 3,RCVINS
	XWD 3,RCVSTX
	REPEAT ^D7,<0>
	XWD 2,RCVEOF
	XWD 1,IOERR
	REPEAT ^D36-^D12,<0>
	DEBRK

; Get a character

GCH:	PUSHJ P,.PBIN
	CAIE A,177
CPOPJ:	POPJ P,
	HRROI A,[ASCIZ /XXX/]
	PUSHJ P,.PSOUT
	JRST COMLP

; Echo character in a

ECHOIT:	SKIPE HDX
	 PUSHJ P,PBOUT0
	SKIPE HDX
	POPJ P,
	SKIPE NFANCY
	TRNN F,COMMDF
	PUSHJ P,.PBOUT
	POPJ P,

; Primary output with case indicate

.PEOUT:	PUSHJ P,PBOUT0
	CAIL A,100		; Does character have case?
	SKIPE TRMLWC		; Or does terminal have lower case?
	 JRST EOUTX1		; Caseless
	SKIPGE LCASL
	SKIPL LCASC
	SKIPA
	 JRST EOUTX1		; Don't indicate if shift chars absent
	SKIPGE UCASL
	SKIPL UCASC
	SKIPA
	 JRST EOUTX1
	CAIE A,177
	CAIN A,137
	 JRST EOUTX1
	PUSH P,B
	MOVE B,A
	ANDI B,40		; Extract case
	ANDCMI A,40		; Force upper
	CAMN B,TCASE		; Same as current case?
	 JRST EOUTX0		; No need to indicate
	PUSH P,A
	JUMPE B,IUPC		; Upper case
	SKIPG A,LCASL		; Do we have a lower case lock?
	 JRST LCS1		; No, try for lowercase char
	PBOUT			; Yes, print it
	MOVEM B,TCASE		; And remember new case
	JRST EOUTX


LCS1:	SKIPG A,LCASC		; Have we a lower case char prefix?
	 JRST EOUTX		; No, can't indicate
	PBOUT			; Yes, print it
	JRST EOUTX		; But don't change case

IUPC:	SKIPG A,UCASL		; Do we have a upper case lock
	 JRST UCS1
	PBOUT
	MOVEM B,TCASE
	JRST EOUTX

UCS1:	SKIPG A,UCASC
	 JRST EOUTX
	PBOUT
EOUTX:	POP P,A
EOUTX0:	POP P,B
EOUTX1:	CAME A,UCASC
	CAMN A,UCASL
	 JRST ESPCL
	CAME A,LCASC
	CAMN A,LCASL
	 JRST ESPCL
	CAME A,QUOT
	CAMN A,BRKC
	 JRST ESPCL
	PBOUT
	POPJ P,

ESPCL:	PUSH P,A
	SKIPLE A,QUOT
	PBOUT
	POP P,A
	PBOUT
	POPJ P,


; Primary input

.PBIN:	PUSH P,B
PBIN1:	MOVEI A,100
	TRNN F,COMMDF
	SKIPN ALTJFN(CNX)
	JRST PBIN0
	MOVE A,ALTJFN(CNX)  ; if alt. file exists & in remote mode,
	SOSGE ALTJCT(CNX)   ; take input from file, else tty
	 JRST [ SETZ NOA,
		PUSHJ P,SETALT	; if ct shows eof, close & release
		JRST PBIN1 ]
	BIN
	MOVE A,B
	POP P,B
	POPJ P,
PBIN0:	RFMOD			; will echo be generated?
	TRNE B,3B33!3B25
	 JRST [	MOVEI B,PBOUT0
		EXCH B,0(P)
		JRST .+2]
	POP P,B
PBINX:	PBIN
	POPJ P,

; Primary output

.PBOUT:	PBOUT
PBOUT0:	SKIPN SCRJFN
	 POPJ P,
	PUSH P,B
	MOVE B,A
	MOVE A,SCRJFN
	CAIN B,37
	 JRST [ MOVEI B,15	; translate EOL to <CR><LF>
		BOUT
		MOVEI B,12
		BOUT
		MOVEI B,37
		JRST .+2 ]
	BOUT
	PUSHJ P,SCRUPD
	MOVE A,B
	POP P,B
	POPJ P,


.GTJFN:	MOVE B,[XWD 100,101]
GTJFN0:	SETOM RLACJ
	GTJFN
	 JRST [	SETZM RLACJ
		POPJ P,]
	MOVEM A,IJFN
	SETZM RLACJ
	PUSH P,C
	SETZ C,
	MOVE B,A
	SKIPE A,SCRJFN
	 JFNS
	POP P,C
	PUSHJ P,SCRUPD
	MOVE A,B
	JRST SKPRET

.NOUT:	NOUT
	 POPJ P,
	SKIPE A,SCRJFN
	NOUT
	 JFCL
	PUSHJ P,SCRUPD
	MOVEI A,101
	AOS (P)
	POPJ P,

.SOUT:	SKIPN A,SCRJFN
	 JRST .SOUT0
	PUSH P,B
	PUSH P,C
	SOUT
	PUSHJ P,SCRUPD
	POP P,C
	POP P,B
.SOUT0:	MOVEI A,101
	SOUT
	POPJ P,

.PSOUT:	SKIPE SCRJFN
	PUSH P,A
	PSOUT
	SKIPN SCRJFN
	 POPJ P,
	EXCH B,0(P)
	PUSH P,C
	MOVE A,SCRJFN
	SETZ C,
	SOUT
	PUSHJ P,SCRUPD
	MOVE A,B
	POP P,C
	POP P,B
	POPJ P,

; Uuo handler

UUO:	HRRO A,40
	PUSHJ P,ERROUT
	MOVEI A,400000
	CIS
	EIR
	JRST COMLP

ERROUT:	PUSH P,A
	MOVEI A,101
	DOBE
	POP P,A
	PUSHJ P,.PSOUT
	MOVEI A,^D1000
	DISMS
	MOVEI A,100
	CFIBF
	POPJ P,

; Convert interrupt character to code

CVINTC:	CAIG A,33
	 JRST SKPRET
	CAIE A,177
	CAIN A,40
	 SKIPA
	POPJ P,
	CAIN A,40
	MOVEI A,^D29
	CAIN A,177
	MOVEI A,^D28
	JRST SKPRET

; Map fork one to one with this fork through page 177
; Call:	A	; Fork handle
;	PUSHJ P,MAPFRK
; Returns
;	+1	; Always. transparent

MAPFRK:	PUSH P,C
	PUSH P,D
	PUSH P,B
	MOVSI D,-177
	MOVSI B,(A)
	MOVSI A,400000
	MOVSI C,160000
MAPFKL:	HRR A,D
	HRR B,D
	PMAP
	AOBJN D,MAPFKL
	HLRZ A,B
	POP P,B
	POP P,D
	POP P,C
	POPJ P,

INIFRK:	MOVEM NCNX,CNX+FAC
	MOVEI B,FAC
	SFACS
	MOVE B,[XWD FKLVT,FKCHT]
	CIS
	SIR
	EIR
	MOVSI B,(1B1!1B2!1B10!1B11)
	AIC
	POPJ P,

; Close and release jfn

CLRJFN:	PUSH P,A
	CLOSF
	 JFCL
	POP P,A
	RLJFN
	 JFCL
	POPJ P,

; Macro for generating commands

DEFINE	CC(STR,VAL)<
	POINT 7,[ASCIZ \STR\
		VAL]
>

; Top level commands

TOPC:	XWD -1,SHSTAB
	XWD -1,NULTAB
	CC(<;*%x>,<JRST DOCOMT>)
	CC(<flush.host>,<PUSHJ P,.FLUSH>)
	CC(<list.connections>,<PUSHJ P,LSTCON>)
	CC(<where.am.I>,<PUSHJ P,.WHERE>)
	CC(<wait.for.any.active.connection>,<PUSHJ P,WATRET>)
	CC(<retrieve.connection.under.name>,<PUSHJ P,RETCON>)
	CC(<name.current.connection.to.be>,<PUSHJ P,.STNAM>)
	CC(<write.modes.for.host>,<PUSHJ P,WRTMDF>)
	CC(<command>,<PUSHJ P,CMMAND>)
	CC(<!synch!>,<PUSHJ P,SNDSNC>)
	CC(<!break!>,<PUSHJ P,SNDBRK>)
	CC(<control>,<PUSHJ P,SNDCTL>)
	XWD -1,CODTB
	CC(<code>,<JRST [	MOVE TAB,CODTB
				JRST SYMVAL]>)
	CC(<exec>,<PUSHJ P,.EXEC>)
	CC(<ddt>,<JRST 770000>)
	CC(<reset>,<PUSHJ P,.RESET>)
	CC(<logout>,<PUSHJ P,.LGOUT>)
	CC(<quit>,<PUSHJ P,.QUIT>)
	CC(<run>,<PUSHJ P,.RUN>)
	CC(<socket.map>,<PUSHJ P,.SMAP>)
	CC(<netstatus>,<PUSHJ P,.NSTS>)
	CC(<help>,<PUSHJ P,.HELP>)
	CC(<clear.output.character=>,<PUSHJ P,SETCBF>)
	CC(<escape.character=>,<PUSHJ P,SETESC>)
	XWD -1,YNTB
	CC(<host.names>,<PUSHJ P,HSTNMP>)
	CC(<recognized.options>,<PUSHJ P,RECOP>)
	CC(<option.state.for.current.connection>,<PUSHJ P,CUROPS>)
	CC(<current.modes.are>,<PUSHJ P,PRCMD>)
	CC(<no>,<JRST [SETCA NOA,
			MOVE TAB,YNTB
			JRST SYMVAN]>)
	CC(<remote.mode>,<PUSHJ P,SETREM>)
	CC(<local.mode>,<TRZ F,REMOTF>)
	CC(<terminal.type.is>,<PUSHJ P,SETTRM>)
	CC(<echo.mode.is>,<PUSHJ P,.ECHO>)
	CC(<net.exec>,<PUSHJ P,.NEWS>)
	CC(<status.of>,<PUSHJ P,.STAT>)
	CC(<disconnect>,<PUSHJ P,.DISC>)
	CC(<connection.to>,<PUSHJ P,.CONN>)
COMTAB:	XWD TOPC-.,TOPC

YNT:	CC(<signal.waiting.output>,<MOVEM NOA,SWOFLG>)
	CC(<typescript.to.file>,<PUSHJ P,SETSCR>)
	CC(<take.input.stream.from.file>,<PUSHJ P,SETALT>)
	CC(<divert.output.stream.to.file>,<PUSHJ P,SETDIV>)
	CC(<fancy.command.interpret>,<SETCAM NOA,NFANCY>)
	CC(<verbose>,<SETCAM NOA,CONCSF>)
	CC(<concise>,<MOVEM NOA,CONCSF>)
	CC(<attention.character:>,<PUSHJ P,SETATN>)
	CC(<synch.character:>,<PUSHJ P,SETSNC>)
	CC(<quote.prefix:>,<PUSHJ P,SETQOT>)
	CC(<unshift.prefix:>,<PUSHJ P,SETUNS>)
	CC(<case.shift.prefix.for>,<PUSHJ P,SETSHF>)
	CC(<transparent.mode>,<MOVEM NOA,XPARNT(CNX)>)
	CC(<lower>,<MOVEM NOA,LOWERF(CNX)>)
	CC(<raise>,<MOVEM NOA,RAISEF(CNX)>)
	CC(<line.buffer>,<MOVEM NOA,LNBFF(CNX)>)
	CC(<character.mode>,<SETCAM NOA,LNBFF(CNX)>)
YNTB:	XWD YNT-.,YNT

; Null table

NTP:	CC(<>,<JFCL>)
NULTAB:	XWD NTP-.,NTP

; Table of character code specifiers

CDTB:	CC(<d%d*%d>,<PUSHJ P,SNDDCD>)
	CC(<h%h*%h>,<PUSHJ P,SNDHCD>)
	CC(<o%o*%o>,<PUSHJ P,SNDOCD>)
	CC(<%o*%o>,<PUSHJ P,SNDOCT>)
CODTB:	XWD CDTB-.,CDTB

; Command table for terminal modes

TRMT:	CC(<lowercase>,<PUSHJ P,SETLWR>)
	CC(<halfduplex>,<MOVEM NOA,HDX>)
	CC(<fullduplex>,<SETCAM NOA,HDX>)
	CC(<no>,<JRST [	SETCA NOA,
			JRST SYMVAN]>)
TRMTAB:	XWD TRMT-.,TRMT

; Command table for echo modes

ETP:	CC(<local>,<JRST [	MOVEM NOA,ELCLF(CNX)
				JRST CHGECH]>)
	CC(<remote>,<JRST [	SETCAM NOA,ELCLF(CNX)
				JRST CHGECH]>)
	CC(<linefeed.for.carriage.return>,<MOVEM NOA,LFCRF(CNX)>)
	CC(<control.character.echo.for>,<PUSHJ P,SETCOC>)
	CC(<no>,<JRST [SETCA NOA,
			JRST SYMVAN]>)
ECTAB:	XWD ETP-.,ETP

; Command table for socket lookup

STP:	CC(<FTP>,<PUSHJ P,.STFSK
			3>)
	CC(<RJS>,<PUSHJ P,.STFSK
			5>)
	CC(<Terminal.test>,<PUSHJ P,.STFSK
			23>)
	CC(<Netstatus>,<PUSHJ P,.STFSK
			17>)
	CC(<Date>,<PUSHJ P,.STFSK
			15>)
	CC(<Systat>,<PUSHJ P,.STFSK
			13>)
	CC(<Discard>,<PUSHJ P,.STFSK
			11>)
	CC(<Echo>,<PUSHJ P,.STFSK
		7>)
	CC(<logger>,<PUSHJ P,.STFSK
			1>)
	CC(<%o*%o>,<PUSHJ P,OCTFSK>)
	CC(<name.for.connection.is>,<PUSHJ P,.STNAM>)
	XWD -1,SETTAB
	XWD -1,NULTAB
SKTTAB:	XWD STP-.,STP

STB:	CC(<no>,<JRST [	SETCA NOA,
			MOVE TAB,SETTAB
			JRST SYMVAN]>)
	CC(<wait>,<MOVEM NOA,WATFLG>)
	CC(<load.settings>,<MOVEM NOA,LODFLG>)
SETTAB:	XWD STB-.,STB

; Host table

HTP:	XWD -1,NHSTAB
	XWD -1,SHSTAB
	XWD -1,OCTB
HOSTAB:	XWD HTP-.,HTP

; Octal number table

OCT:	CC(<%o*%o>,<PUSHJ P,CVOCT>)
OCTB:	XWD OCT-.,OCT

; Decimal number table

DCM:	CC(<%d*%d>,<PUSHJ P,CVDEC>)
DCMTB:	XWD DCM-.,DCM

; Letter table

LTR:	CC(<%a>,<ILDB A,BPTR>)
LTRTB:	XWD LTR-.,LTR

; Connection name table

NAMT:	CC(<%n*%n>,<SETO A,>)
NAMTB:	XWD -2,[XWD NAMT-.,NAMT
		XWD -1,CONTAB]

; Case shift command table

SFTAB:	CC(<lock.upper.case>,<MOVEI A,UCASL>)
	CC(<char.upper.case>,<MOVEI A,UCASC>)
	CC(<lock.lower.case>,<MOVEI A,LCASL>)
	CC(<char.lower.case>,<MOVEI A,LCASC>)
SFTB:	XWD SFTAB-.,SFTAB

; socket map host table

SMTAB:	XWD -1,HOSTAB
	CC(<all>,<SETOB C,A>)
SMTB:	XWD SMTAB-.,SMTAB

; Socket map state table

STTAB:	CC(<dead>,<MOVSI A,1B18>)
	CC(<clzd>,<MOVSI A,1B19>)
	CC(<pndg>,<MOVSI A,1B20>)
	CC(<lsng>,<MOVSI A,1B21>)
	CC(<rfcr>,<MOVSI A,1B22>)
	CC(<clw2>,<MOVSI A,1B23>)
	CC(<rfcs>,<MOVSI A,1B24>)
	CC(<opnd>,<MOVSI A,1B25>)
	CC(<clsw>,<MOVSI A,1B26>)
	CC(<datw>,<MOVSI A,1B27>)
	CC(<rfn1>,<MOVSI A,1B28>)
	CC(<clzw>,<MOVSI A,1B29>)
	CC(<rfn2>,<MOVSI A,1B30>)
	CC(<kild>,<MOVSI A,1B31>)

	CC(<all>,<SETO A,>)
STTB:	XWD STTAB-.,STTAB

; New protocol command table

NPCMT:	CC(<do>,<MOVEI A,DOOPT>)
	CC(<dont>,<MOVEI A,DNTOPT>)
	CC(<will>,<MOVEI A,WILOPT>)
	CC(<wont>,<MOVEI A,WNTOPT>)
NPCMTB:	XWD NPCMT-.,NPCMT

; Symbol evaluator

SYMVAL:	SETO NOA,
SYMVAN:	MOVEM PTR,BPTR		; Save beginning of symbol
SYMLUP:	PUSHJ P,GCH		; Get a character
	CAIE A,"A"-100		; Control-a
	CAIN A,"H"-100		; Or control-h
	 JRST DELCH		; Delete character
	CAIN A,"R"-100
	 JRST RETYPE		; Control-r, retype line
	CAIN A,"W"-100		; Control-w
	 JRST DELWRD		; Delete word
	CAIN A,"?"		; Question mark
	 JRST PRQUES		; Print options
	CAIE A,33		; Altmode or
	CAIN A,37		; Eol
	 JRST SYMEND		; Lookup
	CAIE A,","		; Comma
	CAIN A," "		; Or space same thing
	 JRST SYMEND
	IDPB A,PTR		; Else deposit into string
	PUSHJ P,TRMST
	SKIPE NFANCY
	 JRST SYMLPE
	SETZ X,			; Clear x
	MOVEM P,SVP		; Save p
	MOVE Y,TAB		; Init y
	PUSHJ P,SYMLUK		; Lookup the current symbol
	MOVE P,SVP		; Restore p
	JUMPE X,[DPB X,PTR	; Smash null onto last character
		MOVE A,PTR
		BKJFN		; Back up pointer
		 0
		MOVEM A,PTR
		JRST DING]	; And echo bell
SYMLPE:	LDB A,PTR		; Symbol still ok, get char
	PUSHJ P,ECHOIT
	JRST SYMLUP		; And loop

DELCH:	CAMN PTR,BPTR		; Delete character, any to delete?
	 JRST DING		; No, echo bell
	MOVEI A,"\"
	PUSHJ P,.PBOUT
	LDB A,PTR
	PUSHJ P,.PBOUT
	MOVE A,PTR
	BKJFN
	 0
	MOVEM A,PTR
	JRST SYMLUP

TRMST:	PUSH P,A
	PUSH P,PTR
	SETZ A,
	IDPB A,PTR
	POP P,PTR
	POP P,A
	POPJ P,

DING:	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST SYMLUP

DELWRD:	CAMN PTR,BPTR		; Delete word
	 JRST DING		; Nothing
	MOVEI A,"#"
	PUSHJ P,.PBOUT
	PUSHJ P,.PBOUT
DELW0:	MOVE PTR,BPTR
	JRST SYMLUP

RETYPE:	MOVE A,PTR
	MOVEI B,0
	IDPB B,A
	MOVEI A,37
	PUSHJ P,.PBOUT
	MOVE A,LPTR
	PUSHJ P,.PSOUT
	JRST SYMLUP

; End of symbol, try lookup

SYMEND:	MOVEM A,TERM		; Save terminator
	PUSHJ P,TRMST
	SETZ X,
	MOVE Y,TAB
	PUSHJ P,SYMLUK
	JUMPE X,[HRROI A,[ASCIZ / ? /]
		PUSHJ P,ERROUT
		MOVE A,TERM
		CAIE A,37
		 JRST DELW0
		JRST COMLP]
	CAIE X,1		; Exactly one symbol
	 JRST SYMAMB		; No. ambiguous
	POP P,C			; Leave pointer to head in c
	POP P,B			; Get pointer to tail of command
SYMCLP:	ILDB A,B		; Copy to terminal
	JUMPE A,SYMECL
	MOVE D,TERM
	SKIPE HDX
	 JRST NCOMP
	SKIPN NFANCY
	SKIPE CONCSF
NCOMP:	CAIN D,33
	 PUSHJ P,.PBOUT
	IDPB A,PTR
	JRST SYMCLP

SYMECL:	MOVEI A,40
	MOVE D,TERM
	CAIN D,33
	 JRST [	PUSHJ P,.PBOUT
		JRST .+4]
	CAIE D,37
	MOVE A,D
	PUSHJ P,ECHOIT
	IDPB A,PTR
	PUSHJ P,TRMST
	TRZ F,TMPF3!TMPF4!TMPF5
	XCT 1(B)		; Execute "value"
	POPJ P,			; And return
	XCT 2(B)		; If first value skips, execute 2nd
	POPJ P,

SYMAMB:	JUMPE X,DING		; Nothing left, go ding
	POP P,C			; Leave pointer to head in c
	POP P,B			; Get pointer to tail
	ILDB A,B		; Get first ch of tail
	JUMPN A,[SOJA X,SYMAMB]	; If not null, then loop
SYMAML:	SOJLE X,SYMECL		; Else unique
	SUB P,[XWD 2,2]		; Flush the junk
	JRST SYMAML


PRQUES:	PUSHJ P,ECHOIT
	PUSHJ P,TRMST
	SETZ X,
	MOVE Y,TAB
	TRZ F,TMPF5
	TRO F,TMPF6
	PUSHJ P,SYMLUK		; Get all the possibilities
PRQUEL:	JUMPE X,RETYPE		; All done, retype the line
	MOVEI A,37
	PUSHJ P,.PBOUT		; Eol
	TRZ F,TMPF!TMPF2!TMPF4
PRQUEN:	ILDB A,0(P)
	JUMPE A,PRQUEE
PRQUEB:	CAIN A,"*"
	 JRST [	TRNE F,TMPF3	; reassurance if in "not" mode
		TRNE F,TMPF5!TMPF6
		CAIA
		 JRST [	PUSH P,A
			HRROI A,[ASCIZ /[but otherwise] /]
			PUSHJ P,.PSOUT
			TRO F,TMPF5
			POP P,A
			JRST PRQUEB]
		HRROI A,[ASCIZ /<any number of /]
		PUSHJ P,.PSOUT
		TRO F,TMPF!TMPF4
		JRST PRQUEN]
	CAIN A,"%"
	 JRST [	TRNE F,TMPF3	; reassurance if in "not" mode
		TRNE F,TMPF5!TMPF6
		CAIA
		 JRST [	PUSH P,A
			HRROI A,[ASCIZ /[but otherwise] /]
			PUSHJ P,.PSOUT
			TRO F,TMPF5
			POP P,A
			JRST PRQUEB]


		ILDB A,0(P)
		CAIN A,"%"
		 JRST .+1
		SETZ B,
		CAIN A,"D"+40
		 HRROI B,[ASCIZ /decimal digit/]
		CAIN A,"O"+40
		 HRROI B,[ASCIZ /octal digit/]
		CAIN A,"H"+40
		 HRROI B,[ASCIZ /hexadecimal digit/]
		CAIN A,"A"+40
		 HRROI B,[ASCIZ /alphabetic/]
		CAIN A,"N"+40
		 HRROI B,[ASCIZ /alphameric/]
		CAIN A,"S"+40
		 HRROI B,[ASCIZ /separator/]
		CAIN A,"P"+40
		 HRROI B,[ASCIZ /punctuation mark/]
		CAIN A,"X"+40
		 HRROI B,[ASCIZ /any character/]
		JUMPE B,.+1
		MOVEI A,"<"
		TRNN F,TMPF
		 PUSHJ P,.PBOUT
		MOVE A,B
		PUSHJ P,.PSOUT
		TRO F,TMPF2!TMPF4
		JRST PRQUEQ]
	TRNN F,TMPF4
	TRNN F,TMPF3
	CAIA
	 JRST [	PUSH P,A
		HRROI A,[ASCIZ /[not] /]
		PUSHJ P,.PSOUT
		TRO F,TMPF4
		TRZ F,TMPF6
		POP P,A
		JRST .+1]
	PUSHJ P,.PBOUT
PRQUEQ:	TRNN F,TMPF!TMPF2
	 JRST PRQUEN
	HRROI A,[ASCIZ /'s>/]
	TRZE F,TMPF2
	 HRROI A,[ASCIZ /s>/]
	TRZN F,TMPF
	 HRROI A,[ASCIZ />/]
	PUSHJ P,.PSOUT
	JRST PRQUEN

PRQUEE:	SUB P,[XWD 2,2]		; Flush pointer to end
	SOJA X,PRQUEL		; And loop

; Lookup symbol
; Operates recursively and accumulates a list of things on the stack

SYMLUK:	PUSH P,SVP		; Save old bottom
	MOVEM P,SVP		; Svp points to chain of svp
	TLNE Y,7000		; Byte pointer in y?
	 JRST SYMLK1		; No aobjn word
	PUSH P,Y		; Yes, sve y
	MOVE D,BPTR		; Get pointer to symbol
SYMLKL:	ILDB A,D		; Get character from input
	ILDB B,Y		; And from table entry
	PUSHJ P,SYMCMP		; Compare the characters
	 JRST SYMNEQ		; Not equal
	JUMPN A,SYMLKL		; Continue until null
SYMEQL:	MOVE A,Y
	BKJFN			; Back up pointer to tail
	 JRST [ CAIE A,600150	; DONT BOMB OUT IF EMPTY LIST--
		0		; (NON-NEG. AOBJN PTR)
		JRST SYMNEX ]
	MOVEM A,Y
	EXCH Y,-2(P)		; Pointer to tail to stack, get ret
	POP P,A			; Pointer to head
	POP P,SVP		; Restore svp
	PUSH P,A		; Pointer to head back to stack
	AOJA X,0(Y)		; Return and count items

SYMNEQ:	JUMPE A,SYMEQL		; If input ends first, then substring
SYMNEX:	SUB P,[XWD 1,1]		; Else flush saved y
	POP P,SVP		; Restore svp
	POPJ P,			; And return

SYMLK1:	PUSH P,Z		; Save z
	MOVE Z,Y		; Use as place to count y
SYMLK3:	MOVE Y,0(Z)		; Loop to here for each item
	PUSHJ P,SYMLUK		; Do this item
	AOBJN Z,SYMLK3		; Loop over all things
	MOVE A,P		; Get p
	SUB A,[XWD 1,1]
	CAMN A,SVP		; Any items saved on stack?
	 JRST SYMLK4		; No, shuffle not needed
	MOVE A,SVP		; Get base of stack
	MOVE Z,1(A)		; Restore z
	POP A,SVP		; Restore svp
	MOVE Y,0(A)		; Get return
	MOVEI B,0(A)		; Where to blt to
	HRLI B,3(A)		; And where from
	BLT B,-3(P)		; Copy stack down
	SUB P,[XWD 3,3]
	JRST 0(Y)		; Return

SYMLK4:	POP P,Z
	POP P,SVP
	POPJ P,

SYMCMP:	CAIN B,"*"		; Asterisk
	 JRST SYMMNY		; Means any number of
	CAIN B,"%"		; Percent
	 JRST SYMCLS		; Means character class
	CAIN B,"#"		; Pound sign
	 JRST SYMNCL		; Means not character class
SYMCM2:	PUSH P,B
	PUSH P,A
	XOR A,B
	TRZ B,40		; Ignore case of b
	CAIL B,"A"		; Then if b has
	CAILE B,"Z"		;  a letter
	SKIPA
	 TRZ A,40		; Then ignore case of difference
	SKIPN A
	AOS -2(P)
	POP P,A
	POP P,B
	POPJ P,

SYMMNY:	PUSH P,Y		; Save where we are in table entry
	ILDB B,Y		; Get what we are doing many of
	PUSHJ P,SYMCMP		; Check match
	 JRST SYMMNN		; Not equal
	ILDB B,Y		; See if next is also equal
	PUSHJ P,SYMCMP
	 JRST [	EXCH A,0(P)	; Not equal, get back y, save a
		BKJFN
		 0
		MOVEM A,Y
		POP P,A
		JRST SKPRET]
	SUB P,[XWD 1,1]		; Matches next thing, use it instead
SKPRET:	AOS(P)
	POPJ P,

SYMMNN:	SUB P,[XWD 1,1]		; Go to next thiing
	ILDB B,Y
	JRST SYMCMP

SYMCLS:ILDB B,Y		; Get class indicator
	CAIN B,"%"		; %% means %
	 JRST SYMCM2
	CAIN B,"d"		; d means decimal digit
	 JRST SYMDEC
	CAIN B,"o"		; o means octal digit
	 JRST SYMOCT
	CAIN B,"h"
	 JRST SYMHEX
	CAIN B,"a"		; a means alphabetic
	 JRST SYMALP
	CAIN B,"n"		; n means alphameric
	 JRST SYMALM
	CAIN B,"s"		; s means separator
	 JRST SYMSEP
	CAIN B,"p"		; p for punctuation
	 JRST SYMPNC
	CAIN B,"x"
	 JRST SYMANY
	POPJ P,			; Else fail

SYMNCL:	PUSHJ P,SYMCLS
	 AOS (P)
	POPJ P,

SYMANY:	AOS (P)
	POPJ P,

SYMDEC:	CAIG A,"9"
	CAIGE A,"0"
	 POPJ P,
	JRST SKPRET

SYMOCT:	CAIG A,"7"
	CAIGE A,"0"
	 POPJ P,
	JRST SKPRET

SYMHEX:	CAIG A,"9"
	CAIGE A,"0"
	 JRST SYMHE1
	JRST SKPRET

SYMHE1:	TRZ A,40
	CAIG A,"F"
	CAIGE A,"A"
	 POPJ P,
	JRST SKPRET

SYMALM:	PUSHJ P,SYMDEC
	 JRST SYMALP
	JRST SKPRET

SYMALP:	TRZ A,40
	CAIG A,"Z"
	CAIGE A,"A"
	 POPJ P,
	JRST SKPRET

SYMSEP:SYMPNC:POPJ P,

; News (Net.exec)

.NEWS:	MOVE B,[367]
	MOVEM B,FSKT
	MOVEI A,105
	MOVEM A,FHSTN
	MOVEM A,FHST
	JRST CONNX1

; Connect.to

.CONN:	MOVE TAB,HOSTAB
	PUSHJ P,SYMVAL
	MOVEM A,FHSTN
CONNX:	MOVEM A,FHST
	SETOM FSKT
CONNX1:	MOVSI X,-NCONN
CONNX2:	BVCALL(DSCNXE,X)	; Find an empty connection
	SKIPE A
	 AOBJN X,CONNX2
	JUMPGE X,[ERROR [ASCIZ /too many connections./]]
	HRRZS NCNX,X
	MOVE A,NCNX
	IMULI A,3
	ADDI A,CONNAM
	HRLI A,440700
	MOVEI B,1(X)
	MOVEI C,010
	NOUT
	 JFCL
	IBP A
	HRLI X,(<MOVEI A,0>)
	MOVEM X,1(A)
	SKIPL FSKT
	 JRST CONN2
	PUSHJ P,DEFSKT
	PUSHJ P,SETMOD
	 JRST CONN2		; Settings not changed
	HRROI A,[ASCIZ /(settings loaded) /]
	SKIPN CONCSF
	PUSHJ P,.PSOUT

CONN2:	HRROI A,[ASCIZ /is /]
	PUSHJ P,.PSOUT
	TRO F,ICPMOD		; set "ICP in progress"
	PUSHJ P,ASNSKT
	PUSHJ P,DOICP		; Do icp
	 JRST [	SKIPN WATFLG	; Failed. wait?
		 JRST [ PUSHJ P,HSTFLD	; no, report host failure status
			TRZ F,ICPMOD
			POPJ P, ]
		HRROI A,[ASCIZ /incomplete on first try.
Trying again ... /]
		SKIPG WATFLG
		PUSHJ P,.PSOUT
		MOVMS WATFLG
		MOVEI A,^D10000
		DISMS
		JRST .-2]
	MOVEI A,7
	MOVEI B,20
	SKIPLE WATFLG
	PUSHJ P,.PBOUT
	SOJG B,.-2
	MOVEI A,400000
	DIR
	HRROI A,[ASCIZ /complete/]
	PUSHJ P,.PSOUT
	TRZ F,ICPMOD
	SKIPE A,SNDFRK(NCNX)
	 JRST CONN3
	MOVSI A,(1B1)
	CFORK
	 JRST [	JSP X,CONFL0
		ASCIZ /can't create send fork./]
	MOVEM A,SNDFRK(NCNX)
	PUSHJ P,MAPFRK

CONN3:	PUSHJ P,INIFRK
	SKIPE A,RCVFRK(NCNX)
	 JRST CONN4
	MOVSI A,(1B1)
	CFORK
	 JRST [	JSP X,CONFL1
		ASCIZ /can't create receive fork./]
	MOVEM A,RCVFRK(NCNX)
	PUSHJ P,MAPFRK
CONN4:	PUSHJ P,INIFRK
	MOVE CNX,NCNX
	HLRE A,CONTAB
	MOVNS A
	ADD A,CONTAB
	HRRZ B,CNX
	IMULI B,3
	ADDI B,CONNAM
	HRLI B,440700
	MOVEM B,(A)
	MOVSI B,-1
	ADDM B,CONTAB
	MOVN A,LSKT(CNX)
	ASH A,-1
	MOVSI B,(1B0)
	ROT B,(A)
	IORM B,SKTMSK
	SETZM SAVSWT(CNX)
	MOVEI B,SEND
	MOVE A,SNDFRK(CNX)
	FFORK
	SFORK
	MOVE A,RCVFRK(CNX)
	MOVEI B,RECV
	FFORK
	SFORK
	TRO F,REMOTF
	MOVEM CNX,FSVCNX	; change save loc to reflect new CNX
	MOVEI A,"."
	PUSHJ P,.PBOUT
	MOVEI A,400000
	EIR
	POPJ P,

CONFL1:CONFL0:	HRROI A,[ASCIZ /,
 but /]
	PUSHJ P,.PSOUT
	PUSHJ P,RELCON
CONFLX:	PUSHJ P,.PSOUT
	POPJ P,

; Assign local socket for connection

ASNSKT:	SETCM A,SKTMSK
	PUSH P,B
	JFFO A,ASNSK1
	MOVEI B,177
ASNSK1:	MOVE A,B
	POP P,B
	LSH A,1
	POPJ P,

; Get foreign socket number or return default socket

DEFSKT:	SETZM WATFLG
	SETOM LODFLG
	MOVEI A,27
	MOVEM A,FSKT		; Default socket is 27 temp. (new prtcl)
DEFSK0:	MOVE A,TERM
	CAIN A,37
	 POPJ P,
	MOVE TAB,SKTTAB
	PUSHJ P,SYMVAL		; Look for a possible socket
	JRST DEFSK0


; Perform icp

DOICP:	MOVEM A,LSKT(NCNX)	; Remember local socket
	BVCALL(DOAICP,<<NCNX,FHST,FSKT,LSKT(NCNX)>>)
	SKIPN A			; perform ICP, 0 rturnd if OK
	AOS (P)			; if OK, 2nd return
	POPJ P,


RELCON:	MOVEI A,400000
	DIR
	BCALL(DSCNCT,NCNX)	; Disconnect current conx
	SETZM IJFN
	SETZM JJFN
	MOVEI A,400000
	EIR
	POPJ P,

NTIINT:	MOVEM A,NTIIA
	AOSN NTICNT
	DEBRK
; Let's see if this screws up anything
;	HRRZ A,RETPC3
;	CAIE A,OPNWTK
;	CAIN A,OPNWTK+1		; Either two locations is ok
;	 SKIPA A,[XWD 10000,OPNWTL]
;	 SKIPA A,NTIIA
;	MOVEM A,RETPC3
	DEBRK

; Disconnect

.DISC:	MOVE A,TERM
	MOVE X,CNX
	CAIN A,37
	 JRST DISC1
	SKIPL TAB,CONTAB
	 POPJ P,
	PUSHJ P,SYMVAL
	MOVE X,A
DISC1:	MOVEI A,400000
	DIR
	CAMN X,CNX
	 TRZ F,REMOTF
	MOVE A,ABNCNX		; Might be abncnx
	SETOM ABNCNX		; Clear it
	CAMN X,A		; And if it was
	 SETOM ABNLCK		; Unlock abnlck
	BVCALL(DRCNXE,X)
	SKIPN A
	 POPJ P,		; No connection
	MOVE A,RCVFRK(X)
	FFORK
	BCALL(DSCNCT,X)		; break connection
	MOVN A,LSKT(X)
	ASH A,-1
	MOVSI B,(1B0)
	ROT B,(A)
	ANDCAM B,SKTMSK
	IMULI X,3		; Compute pointer to this name
	ADDI X,CONNAM
	HRLI X,440700
	MOVE Y,CONTAB
	CAME X,0(Y)		; Search for entry in contb
	 AOBJN Y,.-1
	MOVE A,1(Y)		; Move entries above here, down to
	MOVEM A,0(Y)		;  fill in the gap
	AOBJN Y,.-2
	MOVSI X,1
	ADDM X,CONTAB		; One less entry in contb
	MOVEI A,400000
	EIR
	POPJ P,


; Set name for connection

.STNAM:	MOVE TAB,NAMTB
	TRO F,TMPF3
	PUSHJ P,SYMVAL
	JUMPGE A,NAMINU
	HRRZ A,NCNX
	IMULI A,3
	ADDI A,CONNAM
	HRLI A,440700
	MOVE B,BPTR
	MOVEI C,^D8
	LDB D,PTR		; Get terminator
	SOUT			; Copy through it
	SETZ B,
	DPB B,A			; Replace terminator with null
	MOVE B,NCNX
	HRLI B,(<MOVEI A,>)
	MOVEM B,1(A)
	POPJ P,

NAMINU:	ERROR [ASCIZ /name already in use/]


; Wait for a connection wanting to print

WATRET:	MOVSI X,-NCONN
WATREL:	BVCALL(DSCNXE,X)
	SKIPN A
	 JRST WATREX
	SKIPG SAVINC(X)
	 JRST WATREX
	HRROI A,[ASCIZ /
connection /]
	PUSHJ P,.PSOUT
	HRRZ A,X
	IMULI A,3
	HRROI A,CONNAM(A)
	PUSHJ P,.PSOUT
	HRROI A,[ASCIZ / ready. /]
	PUSHJ P,.PSOUT
	HRRZ A,X
	JRST RETCO1

WATREX:	AOBJN X,WATREL
	MOVEI A,^D10000
	DISMS
	JRST WATRET

; Retrieve connection

RETCON:	SKIPL TAB,CONTAB
	 JRST [	HRROI A,[ASCIZ /
No connections.
/]
		PUSHJ P,.PSOUT
		POPJ P,]
	PUSHJ P,SYMVAL
RETCO1:	MOVEM A,CNX
	TRO F,REMOTF
	POPJ P,

; List connections

LSTCON:	TRZ F,TMPF
	MOVE X,CONTAB
	JUMPGE X,LSTCOX
LSTCOL:	HRROI A,[ASCIZ /
-Name-  -From-  --To--

/]
	TRON F,TMPF
	PUSHJ P,.PSOUT
	SETZ C,
	MOVE A,(X)
	PUSHJ P,.PSOUT
	MOVE B,1(A)
	MOVEI A,11
	PUSHJ P,.PBOUT
	HRRZS B
	BVCALL(RTSJFN,B)	; Get send jfn to decode
	MOVE B,A
	MOVEI A,101
	MOVE C,[BYTE (3)0,0,1,1,0,0,0(5)0,0,2]
	JFNS
	SKIPE A,SCRJFN
	 JFNS
	PUSHJ P,SCRUPD
	MOVEI A,37
	PUSHJ P,.PBOUT
LSTCOX:	AOBJN X,LSTCOL
	HRROI A,[ASCIZ /
No saved connections./]
	TRZN F,TMPF
	PUSHJ P,.PSOUT
	POPJ P,

; Set mode switches

SETMOD:	SKIPN LODFLG
	 POPJ P,
	PUSHJ P,OPNMDF		; Open mode file
	 POPJ P,		; Non-existent
	 JFCL			; Ok if we can't write
	PUSHJ P,SCHMDF		; Search mode file for the right host
	 JRST STMDX		; Not found
	MOVE C,PMODSW
	BIN
	MOVEM B,@0(C)
	AOBJN C,.-2
	AOS (P)
STMDX:	PUSHJ P,CLRJFN
	SETZM IJFN
	POPJ P,

WRTMDF:	MOVE TAB,HOSTAB
	PUSHJ P,SYMVAL
	PUSHJ P,DEFSKT
	PUSHJ P,OPNMDF		; Open it
	 JFCL			; Can't find it
	 JRST [	HRROI A,[ASCIZ /Cannot write TELNET.MODES/]
		PUSHJ P,.PSOUT
		SKIPE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		POPJ P,]
	PUSHJ P,SCHMDF		; See if old settings exist
	 JRST WRTMD1		; No, ok to write
	HRROI A,[ASCIZ /Confirm /]
	PUSHJ P,.PSOUT
	PUSHJ P,GCH
	CAIE A,37
	 JRST [	HRROI A,[ASCIZ /Not done./]
		PUSHJ P,.PSOUT
		JRST WRTMDX]
	MOVE A,IJFN
WRTMD1:	MOVE B,FHSTN
	ROUT
	MOVE B,FSKT
	BOUT
	MOVE NCNX,CNX
	MOVE C,PMODSW
	MOVE B,@0(C)
	BOUT
	AOBJN C,.-2
WRTMDX:	MOVE A,IJFN
	PUSHJ P,CLRJFN
	SETZM IJFN
	POPJ P,


PMODSW:	XWD -NMODSW,MODSWP

MODSWP:	XWD NCNX,LFCRF
	XWD NCNX,ELCLF
	XWD NCNX,LNBFF
	XWD NCNX,RAISEF
	XWD NCNX,JUNK
	XWD NCNX,ECHCOC
	XWD NCNX,LOWERF
	XWD NCNX,JUNK
	XWD NCNX,JUNK
	XWD NCNX,JUNK

SCHMDF:	MOVEI C,0		; Start with word 0
SCHMDL:	RIN			; Read it
	JUMPE B,CPOPJ		; End of file
	CAME B,FHSTN		; Correct host?
	 JRST SCHMDN		; Not this, try next
	BIN			; Get socket
	CAMN B,FSKT		; Correct one?
	 JRST SKPRET
SCHMDN:	ADDI C,NMODSW+2
	JRST SCHMDL

OPNMDF:	MOVEI A,400000
	DIR
	HRROI B,[ASCIZ /<SYSTEM>TELNET.MODES/]
	MOVSI A,1
	GTJFN
	 JRST [	MOVEI A,400000
		EIR
		POPJ P,]
	MOVEM A,IJFN
	MOVEI A,400000
	EIR
	MOVE A,IJFN
	MOVE B,[XWD 440000,300000]
	OPENF
	 JRST [	MOVE A,IJFN
		TRZE B,100000
		 JRST .-1
		PUSHJ P,CLRJFN
		SETZM IJFN
		POPJ P,]
	TRNE B,100000
	AOS (P)
	JRST SKPRET

; Status.of

.STAT:	MOVEI NCNX,NCONN	; Use this cnx for status
	MOVE TAB,HOSTAB
	PUSHJ P,SYMVAL
	MOVEM A,FHST
	PUSHJ P,DEFSKT
	PUSHJ P,SETMOD
	 JFCL
STAT1:	MOVEI NCNX,NCONN	; For late-comers
	MOVEI A,74		; Local socket for icp
	TRO F,ICPMOD
	PUSHJ P,DOICP
	 JRST [ PUSHJ P,HSTFLD
		TRZ F,ICPMOD
		POPJ P, ]
	PUSHJ P,RELCON		; Flush things set up by doicp
	TRZ F,ICPMOD
	HRROI A,[ASCIZ /logger operational./]
	PUSHJ P,.PSOUT
	POPJ P,


; Command  (DO,DONT,WILL,WONT)

CMMAND:	MOVE TAB,NPCMTB		; Lookup command
	PUSHJ P,SYMVAL
	HRRM A,CMCAL+13		; Specialize JSP
	MOVE TAB,OCTB
	PUSHJ P,SYMVAL		; Get option #
	ANDI A,377
	MOVE C,A
CMCAL:	BVCALL(DOOPT,<<CNX,C>>)	; send it
	SKIPE A
	 POPJ P,		; Returns true if ok
	HRROI A,[ASCIZ / invalid./]
	PUSHJ P,.PSOUT
	POPJ P,


; Exec

.EXEC:	HRROI B,[ASCIZ /<SYSTEM>EXEC.SAV/]
	MOVSI C,(1B0)		; CAUSE INTERRUPTS TO GO OFF
	MOVSI A,100001
	JRST SBGET

; Run

.RUN:	MOVSI A,100003
	MOVE B,[XWD 100,101]
	SETZ C,
	JRST SBGET

; Socket.map

.SMAP:	SETOM FAC
	SETOM FAC+1
	MOVE A,TERM
	CAIN A,37
	 JRST SMAPD
	MOVE TAB,SMTB
	PUSHJ P,SYMVAL
	TLNN A,-1
	 MOVE C,A
	MOVEM C,FAC+0
	MOVE A,TERM
	CAIN A,37
	 JRST SMAPD
	SETZM FAC+1
	HRROI A,[ASCIZ /(states) /]
	PUSHJ P,.PSOUT
SMAPL:	MOVE TAB,STTB
	PUSHJ P,SYMVAL
	IORM A,FAC+1
	MOVE A,TERM
	CAIN A,","
	 JRST SMAPL
SMAPD:	MOVEI C,1
	JRST NTSTSD


; Netstatus

.NSTS:	MOVEI C,0
NTSTSD:	HRROI B,[ASCIZ /<SUBSYS>NETSTASAV/]
	MOVSI A,100001
SBGET:	PUSH P,B
	PUSHJ P,GTJFN0
	 JRST [	POP P,A
		TLNN A,-1
		PUSHJ P,.PSOUT
		ERROR [ASCIZ / not available./]]
	SUB P,[XWD 1,1]
	MOVEI A,400000
	DIR
	MOVSI A,(1B1!1B3)
	MOVEI B,FAC
	CFORK
	 JRST [	HRROI A,[ASCIZ /No forks available./]
		JRST GETF]
	MOVEM A,SPCFRK
	HRLZ A,SPCFRK
	HRR A,IJFN
	GET
	SETZM IJFN
	MOVEI A,400000
	EIR
	JUMPGE C,SBGET4
	DIR
	MOVE A,ESCCOD
	DTI
	MOVE A,CBFCOD
	DTI

SBGET4:	PUSH P,C
	MOVEI A,100
	MOVE B,TTCOC0
	MOVE C,TTCOC1
	SFCOC
	MOVE B,TTMOD0
	SFMOD
	HRRZ B,0(P)
	MOVE A,SPCFRK
	SFRKV
	WFORK
	MOVEI A,400000
	DIR
	MOVE A,SPCFRK
	KFORK
	SETZM SPCFRK
	POP P,C
	JUMPGE C,SBGET5
	MOVEI A,ESCCHN
	HRL A,ESCCOD
	ATI
	MOVEI A,CBFCHN
	HRL A,CBFCOD
	ATI
SBGET5:	MOVEI A,400000
	EIR
	POPJ P,

GETF:	PUSH P,A
	MOVEI A,400000
	EIR
	SKIPE A,IJFN
	 PUSHJ P,CLRJFN
	SETZM IJFN
	POP P,A
	PUSHJ P,.PSOUT
	POPJ P,

; Set escape character

SETESC:	PUSHJ P,SETICH
	 ESCAPE
	 ESCCOD
	 ESCCHN
	POPJ P,

SETCBF:	PUSHJ P,SETICH
	 CBFCHR
	 CBFCOD
	 CBFCHN
	POPJ P,

SETICH:	MOVE X,0(P)
	ADDI X,3
	EXCH X,0(P)
	PUSHJ P,.PBIN
	CAIN A,"?"
	 JRST PRESC
	PUSH P,A
	PUSHJ P,CVINTC
	 JRST SETED
	PUSH P,A
	MOVEI A,400000
	DIR
	POP P,A
	MOVE B,0(P)
	MOVEM B,@0(X)
	EXCH A,@1(X)
	DTI
	HRLZ A,@1(X)
	HRRI A,@2(X)
	ATI
	MOVE A,0(P)
	CAIL A,40
	 JRST SETE1
	MOVEI A,"^"
	PUSHJ P,ECHOIT
	MOVEI A,100
	ADDM A,0(P)
SETE1:	POP P,A
	PUSHJ P,ECHOIT
	MOVEI A,400000
	EIR
	POPJ P,


SETED:	POP P,A
	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST SETESC

PRESC:	HRROI A,[ASCIZ /
control-@ through control-z
altmode
rubout
space
/]
	PUSHJ P,.PSOUT
	MOVE A,LPTR
	PUSHJ P,.PSOUT
	JRST SETESC

; Set terminal modes

SETTRM:	MOVE TAB,TRMTAB
	JRST SYMVAL

; Set attention character

SETATN:	SETOM BRKC
	JUMPGE NOA,CPOPJ
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,BRKC
	POPJ P,

; Set synch character

SETSNC:	SETOM SYNC
	JUMPGE NOA,CPOPJ
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,SYNC
	POPJ P,

; Set single charcter quote prefix

SETQOT:	SETOM QUOT
	JUMPGE NOA,CPOPJ
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,QUOT
	POPJ P,

; Set unshift prefix

SETUNS:	SETOM UNSFT
	JUMPGE NOA,CPOPJ
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,UNSFT
	POPJ P,

; Set case shift prefixes

SETSHF:	PUSH P,NOA		; Save noa
	MOVE TAB,SFTB
	PUSHJ P,SYMVAL
	POP P,NOA
	SETOM (A)		; Turn off prefix
	JUMPGE NOA,CPOPJ	; Done if "no"
	PUSH P,A
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,@(P)
	SUB P,[XWD 1,1]
	POPJ P,

; Echo.mode.is

.ECHO:	MOVE TAB,ECTAB
	JRST SYMVAL

CHGECH:	HRROI A,[ASCIZ /A half-duplex terminal (which I believe you have) will not work well
with remote echoing./]
	SKIPE HDX
	SKIPE ELCLF(CNX)
	CAIA
	 PUSHJ P,.PSOUT
	BVCALL(DSCNXE,CNX)	; Exit if no connection exists
	SKIPN A
	 POPJ P,
	SKIPE ELCLF(CNX)	; If remote echo called for,
	 JRST CHGEC1
	SETOM ELCLF(CNX)
	BVCALL(DOOPT,<<CNX,[ECHO]>>)	; Send DO ECHO
	SKIPN A
	 SETZM ELCLF(CNX)	; If valid call, turn off remote echo
	POPJ P,			;  pending response

CHGEC1:	BCALL(DNTOPT,<CNX,[ECHO]>)	; If local echo called, send
	POPJ P,			;  DONT ECHO

; Terminal has lower case

SETLWR:	MOVEM NOA,TRMLWC
	MOVSI B,(1B3)
	JUMPGE NOA,SETLW1
	IORM B,TTMODR
	IORB B,TTMODC
	JRST SETLW2

SETLW1:	ANDCAM B,TTMODR
	ANDCAB B,TTMODC
SETLW2:	MOVEI A,101
	STPAR
	POPJ P,

SNDSNC:	BCALL(SNDSYN,CNX)	; Send an INS/DM  ("sync")
	POPJ P,

; Set control character echoing

SETCOC:	PUSHJ P,GCH
	CAIN A,"?"
	 JRST SETCOQ
	PUSHJ P,ECHOIT
SETCO2:	CAIN A,37
	MOVEI A,15
	MOVEM A,TERM
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	EXCH A,TERM
	ANDI A,37
	MOVSI B,400000
	MOVNS A
	ROT B,(A)
	SKIPN NOA
	ANDCAM B,ECHCOC(CNX)
	SKIPE NOA
	IORM B,ECHCOC(CNX)
	MOVE A,TERM
	CAIE A,37
	 JRST [	CAIE A,40
		CAIN A,","
		 JRST SETCOC
		JRST SETCO2]
	POPJ P,

SETCOQ:	HRROI A,[ASCIZ /
control characters or letter equivalents/]
	PUSHJ P,.PSOUT
	MOVE A,LPTR
	PUSHJ P,.PSOUT
	JRST SETCOC

SETCOE:	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST SETCOC

; Print current modes

PRCMD:	MOVSI X,-NPMDTB
PRCMD1:	MOVEI A,37
	PUSHJ P,.PBOUT
	MOVSI C,CNX
	HLR C,PCMDTB(X)
	HRROI A,[ASCIZ /no /]
	SKIPN @C
	PUSHJ P,.PSOUT
	HRRO A,PCMDTB(X)
	PUSHJ P,.PSOUT
	AOBJN X,PRCMD1
	HRROI A,[ASCIZ /
Special characters:
/]
	PUSHJ P,.PSOUT
	MOVSI X,-NSPECH
PCSLP:	HLRZ B,CSTAB(X)
	SKIPG (B)
	 JRST PCSLPN
	HRRO A,CSTAB(X)
	PUSHJ P,.PSOUT
	MOVEI A,11
	PUSHJ P,.PBOUT
	MOVE A,(B)
	PUSHJ P,.PBOUT
PCSLPE:	MOVEI A,37
	PUSHJ P,.PBOUT
PCSLPN:	AOBJN X,PCSLP
	SKIPE D,ECHCOC(CNX)
	SKIPN ELCLF(CNX)
	 POPJ P,		; Done if not local echo or no coc
	HRROI A,[ASCIZ /
Local echo for control /]
	PUSHJ P,.PSOUT
PRCM2:	JFFO D,.+1
	MOVSI B,400000
	MOVN C,D+1
	ROT B,(C)
	ANDCAM B,D
	JUMPN D,PRCM1
	HRROI A,[ASCIZ /and /]
	CAME B,ECHCOC(CNX)
	PUSHJ P,.PSOUT
PRCM1:	MOVEI A,100(D+1)
	PUSHJ P,.PBOUT
	JUMPE D,CPOPJ
	HRROI A,[ASCIZ /, /]
	PUSHJ P,.PSOUT
	JRST PRCM2

PCMDTB:	XWD RAISEF,[ASCIZ /Raise/]
	XWD LOWERF,[ASCIZ /Lower/]
	XWD ELCLF,[ASCIZ /Local echo/]
	XWD LFCRF,[ASCIZ /Echo linefeed for carriage return/]
	XWD LNBFF,[ASCIZ /Line buffer/]
NPMDTB==.-PCMDTB

CSTAB:	XWD ESCAPE,[ASCIZ /Escape: /]
	XWD CBFCHR,[ASCIZ /Clrobf: /]
	XWD QUOT,[ASCIZ /Quote:  /]
	XWD UNSFT,[ASCIZ /Unshift:/]
	XWD LCASC,[ASCIZ /Char.lower:/]
	XWD LCASL,[ASCIZ /Lock.lower:/]
	XWD UCASC,[ASCIZ /Char.upper:/]
	XWD UCASL,[ASCIZ /Lock.upper:/]
	XWD BRKC,[ASCIZ /Break:  /]
	XWD SYNC,[ASCIZ /Synch:  /]

NSPECH==.-CSTAB


; Help

.HELP:	MOVEI A,400000
	DIR
	HRROI B,[ASCIZ /<SYSTEM>TELNET.HELP/]
	MOVSI A,100001
	GTJFN
	 JRST [	MOVEI A,400000
		EIR
		HRROI A,[ASCIZ /Help file not found./]
		PUSHJ P,.PSOUT
		POPJ P,]
	MOVEM A,IJFN
	MOVEI A,400000
	EIR
	MOVE A,IJFN
	MOVE B,[XWD 70000,200000]
	OPENF
	 JRST [	MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		HRROI A,[ASCIZ /Help file can't be opened./]
		PUSHJ P,.PSOUT
		POPJ P,]
TYPLP:	MOVEI X,^D20
TYPLP1:	MOVE A,IJFN
	MOVE B,[POINT 7,COMBUF]
	MOVEI C,200*5-3
	MOVEI D,12
	SIN
	GTSTS
	TLNE B,1000
	 JRST ETYPL
	MOVEI A,101
	MOVE B,[POINT 7,COMBUF]
	MOVEI C,200*5-3
	MOVEI D,12
	PUSHJ P,.SOUT
	SOJG X,TYPLP1
	CAIGE C,200*5-3-2
	 JRST TYPLP1
	HRROI A,[ASCIZ /
More help? /]
	PUSHJ P,.PSOUT

TYPAL:	PUSHJ P,.PBIN
	CAIE A,"Y"
	CAIN A,"Y"+40
	 JRST TYPMO
	CAIE A,"N"
	CAIN A,"N"+40
	 JRST TYPNO
	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST TYPAL

TYPMO:	HRROI A,[ASCIZ /Yes
/]
	PUSHJ P,.PSOUT
	JRST TYPLP

TYPNO:	HRROI A,[ASCIZ /No
/]
	PUSHJ P,.PSOUT
	JRST ETYPX

ETYPL:	SUBI C,200*5-3
	SOUT
ETYPX:	MOVE A,IJFN
	PUSHJ P,CLRJFN
	SETZM IJFN
	POPJ P,

; Typescript to a file

SETSCR:	PUSHJ P,UGTAD
	MOVEM B,SCRTIM		; Time of last typescript entry
	SETZM SCRCNT		; Characters output since last openf
	MOVEI A,400000
	DIR
	SETZ A,
	EXCH A,SCRJFN
	SKIPLE A
	 PUSHJ P,CLRJFN
	JUMPGE NOA,[MOVSI A,400001
		HRROI B,[ASCIZ /TELNET.TYPESCRIPT;T;P770000/]
		GTJFN
		 JRST [	MOVEI A,400000
			EIR
			POPJ P,]
		PUSH P,A
		MOVE B,[XWD 70000,20000]
		OPENF
		 JRST [	POP P,A
			RLJFN
			 JFCL
			MOVEI A,400000
			EIR
			POPJ P,]
		HRROI B,[ASCIZ /
TELNET typescript file started at /]
		SETZ C,
		SOUT
		SETO B,
		MOVE C,[1B1+1B7+1B12+1B17]
		ODTIM
		MOVEI B,15
		BOUT
		MOVEI B,12
		BOUT
		POP P,SCRJFN
		MOVEI A,400000
		EIR
		POPJ P,]
	MOVEI A,400000
	EIR

	MOVEI A,[XWD 460000,0
		XWD 100,101
		REPEAT 4,<0>
		XWD 500000,770000
		REPEAT 2,<0>]
	SETZ B,
	PUSHJ P,GTJFN0		; get any file name, but with self-only
	 ERROR [ASCIZ /File not available./]
	MOVE B,[XWD 70000,100000]
	OPENF
	 JRST [	MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		ERROR [ASCIZ /Cannot open file./]]
	MOVEI A,400000
	DIR
	MOVEI B,0
	EXCH B,IJFN
	MOVEM B,SCRJFN
	EIR
	POPJ P,

; Get uniform time in secs

UGTAD:	GTAD
	HRRZS B,A
	HLRZS A
	IMULI A,^D24*^D60*^D60
	ADDB A,B
	POPJ P,


; Update script file

SCRUPD:	SKIPN SCRJFN
	 POPJ P,
	PUSH P,A
	PUSH P,B
	SKIPGE SCRTIM
	 JRST SCRUP0		; Forced update
	PUSHJ P,UGTAD
	SUB B,SCRTIM		; Ho long since last update?
	CAIG B,^D30
	 JRST SCRUPX		; Never less than 30 secs
	CAIL B,^D300
	 JRST SCRUP0		; Always every 5 min
	MOVE A,SCRJFN
	RFPTR
	 SETZ B,
	SUB B,SCRCNT
	CAIG B,^D1000
	 JRST SCRUPX		; Then not fewer thant 1000 chars
SCRUP0:	PUSHJ P,UGTAD
	MOVEM B,SCRTIM
	MOVE A,SCRJFN
	RFPTR
	 SETZ B,
	MOVEM B,SCRCNT
	HRLI A,400000
	CLOSF
	 JFCL
	HRRZS A
	MOVE B,[XWD 70000,20000]
	OPENF
	 0
SCRUPX:	POP P,B
	POP P,A
	POPJ P,


; Divert output  to a file

SETDIV:	MOVEI A,400000
	DIR
	MOVEI A,0
	EXCH A,DIVJFN
	SKIPLE A
	 PUSHJ P,CLRJFN
	MOVEI A,400000
	EIR
	JUMPGE NOA,CPOPJ
	MOVSI A,460003
	PUSHJ P,.GTJFN
	 ERROR [ASCIZ /File not found./]
	MOVE B,[XWD 70000,100000]
	OPENF
	 JRST [	MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		ERROR [ASCIZ /Cannot open./]]
	MOVEI A,400000
	DIR
	MOVEI B,0
	EXCH B,IJFN
	MOVEM B,DIVJFN
	EIR
	POPJ P,


; Take input from a file (remote mode)

SETALT:	MOVEI A,400000
	DIR
	MOVEI A,0
	EXCH A,ALTJFN(CNX)
	SKIPLE A
	 PUSHJ P,CLRJFN
	MOVEI A,400000
	EIR
	JUMPGE NOA,CPOPJ
	MOVSI A,160003
	PUSHJ P,.GTJFN
	 ERROR [ASCIZ /File not found./]
	MOVE B,[XWD 1,11]
	MOVEI C,C
	GTFDB
	LDB B,[POINT 6,C,11]
	CAIE B,7
	 ERROR [ASCIZ /Not an ASCII file./]
	SIZEF
	 ERROR [ASCIZ /File not found./]
	MOVEM B,ALTJCT(CNX)
	MOVE B,[XWD 70000,200000]
	OPENF
	 JRST [ MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		ERROR [ASCIZ /Cannot open./]]
	MOVEI A,400000
	DIR
	MOVEI B,0
	EXCH B,IJFN
	MOVEM B,ALTJFN(CNX)
	EIR
	POPJ P,

; Print where we are

.WHERE:	MOVEI A,37
	PUSHJ P,.PBOUT
	BVCALL(DSCNXE,CNX)
	SKIPN A
	 JRST NOCC
	HRROI A,[ASCIZ /Connection /]
	PUSHJ P,.PSOUT
	MOVE A,CNX
	IMULI A,3
	ADDI A,CONNAM
	HRROS A
	PUSHJ P,.PSOUT
	HRROI A,[ASCIZ / from /]
	PUSHJ P,.PSOUT
	BVCALL(RTSJFN,CNX)
	MOVE B,A
	MOVEI A,101
	MOVSI C,(<BYTE (3)0,0,1>)
	JFNS
	SKIPE A,SCRJFN
	JFNS
	HRROI A,[ASCIZ / to /]
	PUSHJ P,.PSOUT
	BVCALL(RTSJFN,CNX)
	MOVE B,A
	MOVEI A,101
	MOVSI 3,(<BYTE (3)0,0,0,1>)
	JFNS
	SKIPE A,SCRJFN
	JFNS
	MOVEI A,37
	PUSHJ P,.PBOUT
NOCC:	MOVE A,[SIXBIT /SYSVER/]
	SYSGT
	MOVE D,P
	HRRZ C,B
	HLLZS B

.WHRL:	MOVE A,C
	HRL A,B
	GETAB
	 JFCL
	PUSH P,A
	AOBJN B,.WHRL
	PUSH P,[0]
	HRROI A,1(D)
	PUSHJ P,.PSOUT
	MOVE P,D
	HRROI A,[ASCIZ /
Job /]
	PUSHJ P,.PSOUT
	GJINF
	PUSH P,1
	MOVEI A,101
	MOVE B,C
	MOVEI C,12
	PUSHJ P,.NOUT
	 JFCL
	HRROI A,[ASCIZ /, terminal /]
	PUSHJ P,.PSOUT
	MOVE B,D
	MOVEI C,10
	MOVEI A,101
	PUSHJ P,.NOUT
	 JFCL
	HRROI A,[ASCIZ /, user /]
	PUSHJ P,.PSOUT
	POP P,B
	MOVEI A,101
	DIRST
	 JFCL
	SKIPLE A,SCRJFN
	 DIRST
	 JFCL
	HRROI A,[ASCIZ /
TELNET version /]
	PUSHJ P,.PSOUT
	HRROI A,VERNUM
	PUSHJ P,.PSOUT
	POPJ P,


; Request monitor to send reset to a host
; Is nop if not wheel

.FLUSH:	MOVE TAB,HOSTAB
	PUSHJ P,SYMVAL
	TLNN A,-1
	MOVE C,A
	PUSH P,C
	MOVEI A,400000
	DIR
	RPCAP
	EXCH C,0(P)
	PUSH P,C
	TRO C,600000
	EPCAP
	POP P,A
	FLHST
	MOVEI A,400000
	POP P,C
	EPCAP
	EIR
	POPJ P,

; Reset

.RESET:	JRST RSTART

; Logout

.LGOUT:	HRROI A,[ASCIZ / [Confirm] /]
	PUSHJ P,.PSOUT
	PUSHJ P,.PBIN
	CAIE A,37
	POPJ P,
	PUSHJ P,.PBOUT
	MOVNI 1,1
	LGOUT
	HALTF

; Quit, exit back to exec

.QUIT:	SETOM SCRTIM
	PUSHJ P,SCRUPD		; Update script before leaving
	MOVEI A,400000
	DIR
	HALTF
	MOVEI A,-4
	FFORK
	MOVEI A,400000
	EIR
	POPJ P,


; Send code and control

SNDDCD:	IBP BPTR		; Send decimal # as code
	PUSHJ P,CVDEC
	JRST SNDC

SNDOCD:	IBP BPTR		; Send octal # as code
SNDOCT:	PUSHJ P,CVOCT
	JRST SNDC

SNDHCD:	IBP BPTR		; Send hex # as code
	SETZ A,
SNDHCL:	ILDB B,BPTR
	JUMPE B,SNDC
	CAIL B,"A"
	ADDI B,11
	ANDI B,17
	ASH A,4
	ADD A,B
	JRST SNDHCL

SNDCTL:	MOVE TAB,LTRTB		; Send control char.
	PUSHJ P,SYMVAL
	ANDI A,37
	JRST SNDC

SNDCD1:	PUSHJ P,CVOCT
SNDC:	MOVE B,A
	BVCALL(DSCNXE,CNX)
	SKIPN A
	 POPJ P,
	BCALL(SNDCH,<CNX,B>)	; Send and push out byte
	BCALL(TRNSMT,CNX)
	POPJ P,

SNDBRK:	BVCALL(BRKSND,CNX)	; Send a break
	POPJ P,

; Set remote mode

SETREM:	BVCALL(DSCNXE,CNX)
	SKIPE A
	TRO F,REMOTF
	POPJ P,


; option.state.for.current.connection

CUROPS:	HRROI A,[ASCIZ /
No connections.
/]
	SKIPL CONTAB
	 JRST [	PUSHJ P, .PSOUT
		POPJ P, ]
	BVCALL(DSCNXE,CNX)
	SKIPN A
	 JRST [ HRROI A,[ASCIZ /
Current connection not open.
/]
		PUSHJ P,.PSOUT
		POPJ P, ]
	TRZ F,TMPF6
	HRROI A,[ASCIZ /
Server-to-User Options On:
/]
CUROP1:	PUSHJ P,.PSOUT
	MOVE X,OPTTB
CUROP2:	HLRE B,X
	ADDI B,NMOPTS+1
	SETZ C,
	TRNE F,TMPF6
	SETO C,
	BVCALL(RTOPTS,<<CNX,B,C>>)
	SKIPN A
	 JRST CUROP3
	MOVEI A,40
	PUSHJ P,.PBOUT
	HRRO A,0(X)
	PUSHJ P,.PSOUT
	MOVEI A,37
	PUSHJ P,.PBOUT
CUROP3:	AOBJN X,CUROP2
	TRNE F,TMPF6
	 JRST [	HRROI A,[ASCIZ /
All other options off/]
		PUSHJ P,.PSOUT
		POPJ P, ]
	TRO F,TMPF6
	HRROI A,[ASCIZ /
User-to-Server Options On:
/]
	JRST CUROP1


; recognized.options

RECOP:	MOVE X,OPTTB
	HRROI A,[ASCIZ /
Opt#  Implmntd?  Name
/]
	PUSHJ P,.PSOUT
RECOP1:	HLRE B,X
	ADDI B,NMOPTS+1
	MOVEI A,101
	MOVEI C,12
	PUSHJ P,.NOUT
	 JFCL
	MOVEI A,11
	PUSHJ P,.PBOUT
	HRROI A,[ASCIZ /Yes/]
	MOVE Y,0(X)
	TLNE Y,-1
	PUSHJ P,.PSOUT
	MOVEI A,11
	PUSHJ P,.PBOUT
	HRRO A,Y
	PUSHJ P,.PSOUT
	MOVEI A,37
	PUSHJ P,.PBOUT
	AOBJN X,RECOP1
	POPJ P,


; Protocol-defined options; -1 means supported in TELNET

OPTT:	XWD 0,[ASCIZ /Transmit-Binary/]
	XWD -1,[ASCIZ /Echo/]
	XWD 0,[ASCIZ /RCP/]
	XWD -1,[ASCIZ /Suppress-Go-Ahead/]
	XWD 0,[ASCIZ /NAMS/]
	XWD 0,[ASCIZ /Status/]
	XWD -1,[ASCIZ /Timing-Mark/]
	XWD 0,[ASCIZ /RCTE/]
	XWD 0,[ASCIZ /NAOL/]
	XWD 0,[ASCIZ /NAOP/]
OPTTB:	XWD OPTT-.,OPTT


; host.names

HSTNMP:	HRROI A,[ASCIZ /
Server Hosts:
/]
	PUSHJ P,.PSOUT
	MOVE Z,SHSTAB
	PUSHJ P,HSTNLS
	HRROI A,[ASCIZ /
Non-server Hosts:
/]
	PUSHJ P,.PSOUT
	MOVE Z,NHSTAB
	PUSHJ P,HSTNLS
	POPJ P,

HSTNLS:	MOVE A,0(Z)
	MOVE B,A
	SETZ C,
	SOUT
	MOVE B,2(B)
	MOVEI A,101
	MOVE C,[XWD 100003,10]
	PUSHJ P,.NOUT
	 JFCL
	MOVEI A,40
	PUSHJ P,.PBOUT
	MOVE A,0(Z)
	PUSHJ P,.PSOUT
	MOVEI A,37
	PUSHJ P,.PBOUT
	AOBJN Z,HSTNLS
	POPJ P,


; Other routines

.CVHST:	MOVE A,C
	MOVEM A,FHST
	MOVE C,2(B)
	MOVEM C,FHSTN
	CAME TAB,COMTAB
	 POPJ P,
	MOVE A,FHST
	JRST CONNX

; Check if host is up

HSTCHK:	PUSH P,A
	PUSH P,B
	MOVE A,[SIXBIT /IMPHRT/]
	SYSGT
	PUSH P,B
	MOVE A,FHSTN
	IDIVI A,^D36
	HRLM A,0(P)
	POP P,A
	GETAB
	 SETZ A,
	ROT A,(B)
	SKIPGE A
	 AOS -2(P)
	POP P,B
	POP P,A
	POPJ P,

; Set socket number

.STFSK:	SKIPA A,2(B)
OCTFSK:	PUSHJ P,CVOCT
	MOVEM A,FSKT
	POPJ P,

DOCOMT:	PUSHJ P,GCH
	PUSHJ P,ECHOIT
	CAIE A,37
	JRST DOCOMT
	POPJ P,

CVOCT:	SKIPA C,[10]
CVDEC:	MOVEI C,^D10
	MOVE A,BPTR
	NIN
	 SETZ B,
	MOVE A,B
	POPJ P,

; uncoupled rtn to survey new-protocol implementations

NPSURV:	MOVE P,[XWD -NPDL,PDL-1]
	HRROI A,[ASCIZ /
Survey of New Protocol Implementations in all Server Hosts

/]
	PUSHJ P,.PSOUT
	MOVE NOA,SHSTAB
	PUSHJ P,CTSPRQ
CTSLP:	MOVE A,0(NOA)
	MOVEI B,1
	PUSHJ P,CTSPRT
	MOVE A,0(NOA)
	MOVEI B,27
	PUSHJ P,CTSPRT		; connect to each server host, both
	AOBJN NOA,CTSLP		;  socket 1 and 27
	MOVEI A,37
	PUSHJ P,.PBOUT
	PUSHJ P,.PBOUT
	PUSHJ P,.PBOUT
	HALTF

CTSPRT:	PUSHJ P,.PSOUT		; print host name
	MOVE A,2(A)
	MOVEM A,FHST
	MOVEM A,FHSTN		; set foreign host #
	MOVEM B,FSKT
	MOVEI A,40
	PUSHJ P,.PBOUT		; print space
	MOVEI A,101
	MOVEI C,10
	PUSHJ P,.NOUT		; then socket number
	 JFCL
	MOVEI A,40
	PUSHJ P,.PBOUT		; space again
	PUSHJ P,CONNX1		; then enter connection rtn
	BVCALL(DRCNXE,CNX)
	SKIPN A			; if connection exists
	 JRST CTSPRX
	MOVEI A,400000		; render receive fork harmless
	DIR
	SETOM SAVSWT(CNX)
	MOVEI A,400000
	EIR
	MOVE A,RCVFRK(CNX)
	RFORK			; let it run,
	MOVEI A,^D10000
	DISMS			; wait for host-init negot to subside


	MOVE A,[JRST RTNTRU]	; DIDDLE TIMING-MARK RTNS
	MOVEM A,ONRTM
	MOVEM A,ONSTM
	MOVSI Z,-NMOPTS-1
CTSPRA:	HRRZ C,Z
	BVCALL(DOOPT,<<CNX,C>>)	; request every option both ways
	BVCALL(WILOPT,<<CNX,C>>)
	AOBJN Z,CTSPRA
CTSPRB:	MOVEI A,^D15000
	DISMS			; wait for answers
	MOVEI A,101
	SOBE
	 JRST CTSPRB
	MOVSI Z,-NMOPTS-1
CTSPRC:	HRRZ C,Z
	BVCALL(RTNISC,<<CNX,C>>)
	TRNE A,7		; inspect state & ctr for each option
	 JRST CTSPRW		; declare new prot not working if ct>0
	HRRZM A,HSFSTR(Z)
	BVCALL(RTNOSC,<<CNX,C>>)
	TRNE A,7
	 JRST CTSPRW		; same for both directions,
	HRLM A,HSFSTR(Z)	; store state if ok
	AOBJN Z,CTSPRC
	HRROI A,[ASCIZ /
Implemented Options:
     /]
	PUSHJ P,.PSOUT		; if responses ok, report on optns impl
	MOVSI Z,-NMOPTS-1
	MOVEI A,101
	MOVE C,[XWD 100003,12]
CTSPRD:	HRRZ B,Z
	PUSHJ P,.NOUT
	 JFCL
	AOBJN Z,CTSPRD
	HRROI A,[ASCIZ /
Incm:/]
	PUSHJ P,.PSOUT
	MOVE Z,[XWD -NMOPTS-1,HSFSTR]
CTSPRE:	HRROI A,[ASCIZ /  N/]
	HRRZ B,0(Z)
	TRNE B,17
	 HRROI A,[ASCIZ /  Y/]
	PUSHJ P,.PSOUT
	AOBJN Z,CTSPRE


	HRROI A,[ASCIZ /
Outg:/]
	PUSHJ P,.PSOUT
	MOVE Z,[XWD -NMOPTS-1,HSFSTR]
CTSPRF:	HRROI A,[ASCIZ /  N/]
	HLRZ B,0(Z)
	TRNE B,17
	 HRROI A,[ASCIZ /  Y/]
	PUSHJ P,.PSOUT
	AOBJN Z,CTSPRF
	JRST CTSPRV

CTSPRW:	HRROI A,[ASCIZ "
New protocols not implemented for this host/socket."]
	PUSHJ P,.PSOUT
CTSPRV:	MOVE A,[MOVEM A,0(16)]	; RESTORE TIMING-MARK RTNS
	MOVEM A,ONRTM
	MOVEM A,ONSTM
	MOVE X,CNX
	PUSHJ P,DISC1		; break connection now,
CTSPRX:	MOVEI A,37
	PUSHJ P,.PBOUT
	MOVEI A,37
	PUSHJ P,.PBOUT		; type crlf and exit
	POPJ P,

CTSPRQ:	MOVE Z,NOA		; eliminate nicknames from table
	SETZ D,
CTSPRR:	MOVE A,0(Z)
	MOVE B,A
	SETZ C,
	SOUT
	MOVE A,2(B)
	ANDI A,77
	CAMGE A,D
	 JRST CTSPRS
	MOVE D,A
	AOBJN Z,CTSPRR
CTSPRS:	HLLZS Z
	MOVNS Z
	ADD NOA,Z
	POPJ  P,


; Rtn to set up and call host down status reporter

HSTFLD:	MOVE B,FHSTN		; If a host number, use it
	TLNN B,-1
	 JRST HSTFLE
	MOVE A,B		; Else scan down string to get number
	SETZ C,
	SOUT
	MOVE B,2(B)
HSTFLE: MOVE A,[POINT 7,HSFSTR]	; Reporter called w/ host # & buf str
	PUSHJ P,HSTFLX
	 POPJ P,		; 1st return: host not down, no str wr
	MOVE A,[POINT 7,HSFSTR]
	PUSHJ P,.PSOUT		; 2nd return: string written, output it
	POPJ P,


; Uncoupled routine to survey dead-host data for all host numbers

SURVEY:	MOVE P,[XWD -100,PDL-1]
	MOVSI Z,-400
SURV1:	HRRZM Z,FHSTN
	PUSHJ P,HSTFLD
	AOBJN Z,SURV1
	MOVEI A,37
	PUSHJ P,.PBOUT
	PBIN
	CAIN A,37
	HALTF
	JRST SURVEY


; Dead host status reporting routine, using system table HSTSTS
;  called with host number in AC 2, JFN or ptr to buffer for writing
;  report line in 1.  Entered by PUSHJ P,HSTFLX.  Transparent to other
;  AC's.  Returns updated string pointer (if pertinent) in 1.  Takes
;  first return if nothing to report (host not down, etc.), and no 
;  string has been written, otherwise skip return, string written in buf

HSTFLX:	PUSH P,C
	PUSH P,D
	PUSH P,X
	MOVE X,A
	MOVE D,B		; save input args
	MOVE A,[SIXBIT /HSTSTS/]
	SYSGT
	SKIPN B
	 JRST HSTFLZ		; 1st return if no HSTSTS table
	HRLZ A,D
	LSH A,-1
	HRR A,B			; host #/2 is index on table
	GETAB
	 JRST [ MOVEI B,3	; invalid index: report "no such host"
		MOVE A,X
		SETZ C,
		JRST HSTFL4 ]
	TRNE D,1
	 MOVSS A		; if host # odd use rh, even, lh
HSTFL1:	TLNE A,(1B0)		; if status wd contains invalid data,
	TLNN A,(1B1)		; or host not down, take 1st exit
	 JRST HSTFLZ		; (no string written)
	EXCH A,X
	MOVEI B,15		; get ptr, output crlf
	BOUT
	MOVEI B,12
	BOUT
	MOVE B,D		; get host # and convert
	CVHST
	 JRST [ HRROI B,[ASCIZ /Host #/]
		SETZ C,		; no name for host: output number
		SOUT
		MOVEI C,10
		MOVE B,D
		NOUT
		 JFCL
		JRST HSTFL2 ]
HSTFL2:	HRROI B,[ASCIZ / is /]
	SETZ C,
	SOUT
	LDB B,[POINT 4,X,17]	; get reason code
	CAIG B,3		; if 0-3, ignore day/time field
	 JRST HSTFL4
	LDB B,[POINT 12,X,13]	; look at whole time-coming-up field
	CAIN B,7777		; -1 means down for > 1 week
	 JRST [ HRROI B,[ASCIZ /down for >7 days: /]
		JRST HSTFL3 ]

	SKIPN B			; 0 means down period unknown
HSTF2A:	 JRST [ HRROI B,[ASCIZ /down for unknown period: /]
		JRST HSTFL3 ]
	LDB B,[POINT 5,X,9]	; get hours and 5-min int
	LDB C,[POINT 4,X,13]
	CAIG B,23
	CAILE B,11		; if time params erroneous, flush
	 JRST HSTF2A
	MOVE D,A		; save ptr
	GTAD			; get today's date for time convers.
	IMULI B,^D12		; decode time: GMT hour*12...
	ADD B,C			; plus 5-min interval
	IMULI B,^D300		; all times 300, gives secs since 0000
	HLL B,A			;  GMT; combine with today's date,
	PUSH P,B		; save this time/date and ptr
	PUSH P,D
	SETZ D,
	ODCNV			; output time conversion
	HRRZ C,D		; get local time
	HRRZ B,-1(P)		; and GMT internal time
	MOVSI A,-1
	TLNE D,(1B1)		; subtract 1 from time zone if DST
	 ADD D,A
	LSH D,^D12		; left just. time zone conv.
	MOVEI A,^D8
	SKIPL D			; if time zone is east of GMT and lt<GMT
	SOJ A,			; then add one to day
	CAML C,B		; If time zone is west of GMT & lt>GMT,
	SOJ A,			; then subtract one from day
	LDB B,[POINT 3,X,4]
	ADD A,B			; take day of week mod 7
	IDIVI A,7
	MOVE B,HFDAYT(B)	; lookup day string & output
	POP P,A
	PUSH P,B
	SETZ C,
	HRROI B,[ASCIZ /down until /]
	SOUT
	POP P,B
	SOUT
	HRROI B,[ASCIZ / at /]
	SOUT
	POP P,B			; retreive constructed time/date
	MOVSI C,400261		; convert time only to str w/ zone
	ODTIM
	HRROI B,[ASCIZ /: /]

HSTFL3:	SETZ C,
	SOUT
	LDB B,[POINT 4,X,17]	; get reason code and lookup and output
HSTFL4:	MOVE B,HFRSNT(B)
	SOUT
	MOVEI B,"."
	BOUT
	SETZ B,
	BOUT
	AOS -3(P)		; take 2nd exit
HSTFLZ:	POP P,X
	POP P,D
	POP P,C
	POPJ P,


; Day of week table

HFDAYT: POINT 7,[ASCIZ /Monday/]
	POINT 7,[ASCIZ /Tuesday/]
	POINT 7,[ASCIZ /Wednesday/]
	POINT 7,[ASCIZ /Thursday/]
	POINT 7,[ASCIZ /Friday/]
	POINT 7,[ASCIZ /Saturday/]
	POINT 7,[ASCIZ /Sunday/]
	POINT 7,[ASCIZ /Year day/]


; Table of reasons for down host

HFRSNT:	POINT 7,[ASCIZ /down, reason unknown/]
	POINT 7,[ASCIZ /not ready/]
	POINT 7,[ASCIZ /tardy/]
	POINT 7,[ASCIZ /nonexistent/]
	POINT 7,[ASCIZ /Reason unknown/]
	POINT 7,[ASCIZ /Scheduled PM/]
	POINT 7,[ASCIZ /Scheduled hardware work/]
	POINT 7,[ASCIZ /Scheduled software work/]
	POINT 7,[ASCIZ /Emergency restart/]
	POINT 7,[ASCIZ /Power outage/]
	POINT 7,[ASCIZ /Software breakpoint/]
	POINT 7,[ASCIZ /Hardware failure/]
	POINT 7,[ASCIZ /Reason unknown/]
	POINT 7,[ASCIZ /Reason unknown/]
	POINT 7,[ASCIZ /Reason unknown/]
	POINT 7,[ASCIZ /Reason unknown/]



; Option numbers for new TELNET protocol

TRNSBN==0
ECHO==1
RCP==2
SUPRGA==3
NAMS==4
STTUS==5
TM==6
RCTE==7
NAOL==^D8
NAOP==^D9

; The following is a dispatch table to routines serving the various
; recognized TELNET options.  It is organized as follows: there are
; 8 entries for each option; the first 8 apply to option 0, the next 8
; to option 1, etc.; the blocks of 8 are ordered OnOpt, OffOpt, Shall-
; I-Opt, ParseSubOpt, all for INcoming (receiving) side, then the same 4
; for OUTgoing (sending) side.  See listing of TELPRM.BCP for more info.

OPTRTN:	REPEAT 10,<JRST RTNFLS>		; For Transmit-Binary (not sup.)
	JRST ONRECH			; Echo (incoming only)
	JRST OFRECH
	JRST SIRECH			; Always agree, assuming req 
	JRST RTNFLS			;  only comes at start pts.
	REPEAT 4,<JRST RTNFLS>		; No outgoing "echoes"
	REPEAT 10,<JRST RTNFLS>		; RCP (not supported)
	REPEAT 10,<JRST RTNTRU>		; Suppress-GA (no action needed)
	REPEAT 10,<JRST RTNFLS>		; NAMS (not supported)
	REPEAT 10,<JRST RTNFLS>		; Status
	JRST ONRTM			; Timing-Mark   (reset state)
	JRST RTNFLS
	JRST RTNFLS			; refuse unsolicited WILL
	JRST RTNFLS
	JRST ONSTM			; (reset state)
	JRST RTNFLS
	JRST SISTM			; accept DO
	JRST RTNFLS
	REPEAT 10,<JRST RTNFLS>		; RCTE (not supported)
	REPEAT 10,<JRST RTNFLS>		; NAOL (not supported)
	REPEAT 10,<JRST RTNFLS>		; NAOP (not supported)
	REPEAT 10,<JRST RTNFLS>		; Spare


; Option action routines

RTNFLS:	MOVEM A,0(16)		; general rtn to return false
	SETZ A,
	JRST 2,@0(16)

RTNTRU:	MOVEM A,0(16)		; general rtn to return true
	SETO A,
	JRST 2,@0(16)

ONRTM:	MOVEM A,0(16)		; "On" rtn for incoming Timing-Mark,
	MOVE A,2(16)		; merely resets state of TM option (6)
	MOVEM A,5(16)		; to off after sending DO TM --
	MOVEI A,1		; crummy protocol
	MOVEM A,4(16)
	ADDI 16,3
	JSP A,RSITM
	SUBI 16,3
	SETO A,
	JRST 2,@0(16)

ONSTM:	MOVEM A,0(16)		; Ditto for outgoing TM
	MOVE A,2(16)
	MOVEM A,5(16)
	MOVEI A,1
	MOVEM A,4(16)
	ADDI 16,3
	JSP A,RSOTM
	SUBI 16,3
	SETO A,
	JRST 2,@0(16)

SISTM:	MOVEM A,0(16)		; Should-I-TM: wait till terminal
	MOVEI A,101		;  output buf empty, then return to WILL
	DOBE
	SETO A,			; Return true
	JRST 2,@0(16)

ONRECH:	MOVEM A,0(16)		; Turn on remote echo
	MOVE CNX,2(16)
	SETZM ELCLF(CNX)
	JRST 2,@0(16)

OFRECH:	MOVEM A,0(16)		; Turn off remote echo
	MOVE CNX,2(16)
	SETOM ELCLF(CNX)
	JRST 2,@0(16)

SIRECH:	MOVEM A,0(16)		; Shall-I-Receive-Echoes:
	SETCM A,HDX		;  Ys, unless half-duplex term
	JRST 2,@0(16)


SEND:	CIS
	MOVEM CNX,FSVCNX	; save CNX for later restoration
	BVCALL(RTSJFN,CNX)
	MOVEI B,24
	MOVSI C,777702
	MTOPR			; CNX state change intrpts to chan 2
	MOVE P,[XWD -100,SPDL-1]
	MOVE PTR,[POINT 7,LINBUF-1,34]
	BVCALL(DOOPT,<<CNX,[SUPRGA]>>)
	BVCALL(WILOPT,<<CNX,[SUPRGA]>>)	; ask to suppress GA both ways
	MOVEI A,^D5000
	DISMS		; allow time for echo mode to settle
SEND0:	PUSHJ P,.PBIN
	ANDI A,177
	SKIPE XPARNT(CNX)	; Completely transparent?
	 JRST [	MOVE B,A	; Yes
		BCALL(STRPCH,<CNX,B>)
		JRST SEND0]
	AOSN QUOTF
	 JRST SEND02		; Not special (may be shifted though)
	CAMN A,QUOT		; Quote character
	 JRST [	SETOM QUOTF	; Yes, remember
		JRST SEND0]
	CAMN A,BRKC		; Break substitute?
	 JRST [	PUSHJ P,SNDBRK	; Yes, send break
		JRST SEND0]
	CAMN A,SYNC		; Synch substitute
	 JRST [	PUSHJ P,SNDSNC	; Yes, send sync seq
		JRST SEND0]
	CAMN A,UNSFT		; Now for the shifts...unshift?
	 JRST [	SETZM RAISEF(CNX)
		SETZM LOWERF(CNX)
		SETZM UCASCF
		SETZM LCASCF	; clear all shift flags
		JRST SEND0]
	CAME A,LCASC
	CAMN A,UCASC
	 JRST SETCAS
	CAME A,LCASL
	CAMN A,UCASL
	 JRST SETCAS
SEND02:	CAIG A,136		; Regular character...needs shift?
	CAIGE A,100
	 JRST SEND1		; Not upper case
	AOSE UCASCF		; Upper case.  if no upper case shift
	 PUSHJ P,SFTDWN		; Then see if down shift wanted
	JRST SEND3


SEND1:	CAIG A,176
	CAIGE A,140
	 JRST SEND3		; Not lower case either
	AOSE LCASCF		; Lower case.  if no down shift
	 PUSHJ P,SFTUP		; Then shift up if wanted
	JRST SEND3

SETCAS:	SETZM LCASCF		; Clear character shifts
	SETZM UCASCF
	CAMN A,LCASC		; If lower case char prefix
	 JRST [	SETOM LCASCF	; Remember
		JRST SEND0]
	CAMN A,UCASC		; If upper case char prefix
	 JRST [	SETOM UCASCF	; Remember
		JRST SEND0]
	SETZM LOWERF(CNX)	; Clear shift locks
	SETZM RAISEF(CNX)
	CAMN A,LCASL
	 JRST [	SETOM LOWERF(CNX)
		JRST SEND0]
	CAMN A,UCASL
	 JRST [	SETOM RAISEF(CNX)
		JRST SEND0]

SEND3:	SKIPN LNBFF(CNX)	; If not line buffering
	 PUSHJ P,SNDBUF		; Send any stuff already buffered
	CAIN A,37
	 JRST [	MOVEI A,15
		PUSHJ P,SNDDO
		SETCM A,LFCRF(CNX)	; Get complement of switch
		HRRI A,12	; Line feed
		JRST .+1]
	PUSHJ P,SNDDO
	HRRZS A
	CAIE A,12
	CAIN A,33
	 PUSHJ P,SNDBUF
	JRST SEND0

SFTDWN:	AOSE LCASCF
	SKIPE LOWERF(CNX)
	 TRO A,140
	POPJ P,

SFTUP:	AOSE UCASCF
	SKIPE RAISEF(CNX)
	 TRZ A,40
	POPJ P,

SENDO:	SKIPA A,CBFCHR
SENDE:	MOVE A,ESCAPE
	JRST SEND3

SNDBUF:	CAMN PTR,[POINT 7,LINBUF-1,34]
	 POPJ P,
	PUSHJ P,TRMST
	MOVE PTR,[POINT 7,LINBUF-1,34]
	MOVE C,PTR
SNDBF1:	ILDB B,C		; YES, it's true, replace a SOUT with
	SKIPN B			; a tight loop including SNDCH!
	 JRST [ BCALL(TRNSMT,CNX)	; This make me soffer so...
		POPJ P, ]
	BCALL(SNDCH,<CNX,B>)
	JRST SNDBF1

SNDDO:	SKIPE LNBFF(CNX)
	 JRST SNDLBF
	MOVE B,A
	BCALL(SNDCH,<CNX,B>)	; Unbuffered: send char & push it out
	BCALL(TRNSMT,CNX)
	MOVE A,B
SNDECH:	JUMPL A,CPOPJ		; Never echo ch with -1 lh
	SKIPN HDX		; If hdx terminal
	SKIPN ELCLF(CNX)		; If not local echo
	 POPJ P,		; Then done
	MOVE B,ECHCOC(CNX)
	ROT B,(A)		; Prepare to test coc
	CAIGE A,40		; If not control
	JUMPGE B,CPOPJ
	 PUSHJ P,.PEOUT		; Echo
	POPJ P,

SNDLBF:	CAIE A,"A"-100
	CAIN A,"H"-100
	 JRST [	CAMN PTR,[POINT 7,LINBUF-1,34]
		 JRST [	MOVEI A,7
			PUSHJ P,.PBOUT
			POPJ P,]
		MOVEI A,"\"
		PUSHJ P,.PBOUT
		LDB A,PTR
		PUSHJ P,.PBOUT
		MOVE A,PTR
		BKJFN
		 0
		MOVEM A,PTR
		POPJ P,]
	CAIN A,"X"-100
	 JRST [	MOVEI A,"#"
		PUSHJ P,.PBOUT
		PUSHJ P,.PBOUT
		MOVEI A,37
		PUSHJ P,.PBOUT
		MOVE PTR,[POINT 7,LINBUF-1,34]
		POPJ P,]
	CAIN A,"R"-100
	 JRST [	MOVEI A,37
		PUSHJ P,.PBOUT
		PUSHJ P,TRMST
		MOVE A,[POINT 7,LINBUF-1,34]
		PUSHJ P,.PSOUT
		POPJ P,]
	IDPB A,PTR
	SKIPE ELCLF(CNX)
	 PUSHJ P,SNDECH
	POPJ P,

RECV:	CIS
	MOVEM CNX,FSVCNX
	BVCALL(RTRJFN,CNX)
	MOVEI B,24
	MOVSI C,017702		; state shange interrupts on ch 2
	MTOPR			; Ins interrupts on channel 1
	MOVE P,[XWD -100,SPDL-1]
	BCALL(ZINSCT,CNX)	; clean INS count
	SETZM CBFCNT(CNX)
RECVY:	SETZM SAVINC(CNX)	; Loop to here to reset buffer
	MOVE A,[POINT 7,SAVBUF]
	MOVEM A,SAVINP(CNX)
	MOVEM A,SAVONP(CNX)
RECV0:	MOVE CNX,FSVCNX		; restore CNX in case fork restarted
	SKIPE SAVSWT(CNX)	; Saving output up?
	 JRST RECVR		; Yes, check if full and do it
	SKIPE SAVINC(CNX)	; No, any saved characters?
	 JRST RECVU		; Yes, unsave them
	JRST RECVB0		; No, get next input

RECVR:	MOVEI A,SAVBFS*5-5
	CAMG A,SAVINC(CNX)
RECVH:	 HALTF
RECVB0:	SETOM RCVBSW(CNX)	; Sw stays set until BIN for rstrtng
RECVB:	BVCALL(RCVCH,CNX)
	MOVE B,A
	SKIPE CBFCNT(CNX)
	 JRST RECVFT		; Flushing output or DM timing
RECVBA:	SKIPE SAVSWT(CNX)	; Saving up the output?
	 JRST RECVS		; Yes, go put it in buffer
RECV1:	SKIPE CLROBF
	 JRST RECVFL
	SKIPLE A,DIVJFN
	 JRST RECVX
	MOVE A,B
	PUSHJ P,.PEOUT
	JRST RECV0

RECVU:	SKIPE CLROBF		; Clear output buffer?
	 JRST [	MOVE A,SAVINP(CNX)
		MOVEM A,SAVONP(CNX)
		SETZM SAVINC(CNX)
		LDB B,SAVONP(CNX)
		JRST RECVFL]
	MOVNI A,SAVBFS		; No
	ADD A,SAVONP(CNX)	; Wrapped pointer if needed
	CAMN A,[POINT 7,SAVBUF-1,34]
	 MOVEM A,SAVONP(CNX)	; Wrap pointer
	ILDB B,SAVONP(CNX)	; Get byte
	SOS SAVINC(CNX)		; Account
	JRST RECV1		; Go put it out


RECVS:	MOVNI A,SAVBFS		; Prepare wrapped pointer
	ADD A,SAVINP(CNX)
	CAMN A,[POINT 7,SAVBUF-1,34]
	 MOVEM A,SAVINP(CNX)	; And use it if needed
	IDPB B,SAVINP(CNX)	; Store character
	AOS A,SAVINC(CNX)	; Account
	SKIPE SWOFLG		; Swo and
	CAIE A,1		; First character?
	 JRST RECV0		; No
	MOVEI A,101
	DOBE
	HRROI A,[ASCIZ /
Output waiting from connection /]
	PUSHJ P,.PSOUT
	MOVE A,CNX
	IMULI A,3
	HRROI A,CONNAM(A)

	PUSHJ P,.PSOUT
	MOVEI A,37
	PUSHJ P,.PBOUT
	JRST RECV0

RECVX:	BOUT
	SKIPE DIVSWT
	 JRST RECVN
	SKIPLE A,SCRJFN
	 BOUT
	MOVE A,B
	PUSHJ P,.PEOUT
RECVN:	CAIE B,12
	 JRST RECV0
	MOVEI A,101
	SOBE
	 JRST [	HRROI A,[ASCIZ /...
/]
		SKIPN DIVSWT
		 PUSHJ P,.PSOUT
		SETOM DIVSWT
		JRST RECV0]
	SETZM DIVSWT
	JRST RECV0


RECVFL:	MOVEM B,D
	BVCALL(RTRJFN,CNX)
	SKIPN SAVINC(CNX)
	SIBE
	 JRST RECV0
	MOVEI C,2
RECVF1:	MOVEI A,^D500
	DISMS
	BVCALL(RTRJFN,CNX)
	SIBE
	 JRST RECV0
	SOJG C,RECVF1
	SETZM CLROBF
	MOVEI A,37
	PUSHJ P,.PBOUT
	MOVE B,D
	JRST RECV1

IOERR:	HRROI A,[ASCIZ /
IO error for connection /]
	MOVE CNX,FSVCNX		; restore cnx to be sure
	JRST GENABN

RCVEOF:	MOVE A,[XWD 10000,RECVH]
	MOVEM A,FKRET2
	MOVE CNX,FSVCNX
	SKIPN SAVSWT(CNX)
	SKIPE SAVINC(CNX)
	 DEBRK			; Delay eof response until buffer gone
	HRROI A,[ASCIZ /Remote disconnect of /]
GENABN:	PUSH P,A
	AOSE ABNLCK		; Wait for abnormal interpt handler
	 JRST [	MOVEI A,^D1000
		DISMS
		JRST .-1]
	POP P,A
	PUSHJ P,.PSOUT
	MOVE A,CNX
	IMULI A,3
	HRROI A,CONNAM(A)
	PUSHJ P,.PSOUT
	MOVEM CNX,ABNCNX
	MOVEI A,-1
	MOVSI B,(1B<ABNCHN>)
	IIC			; Initiate abnormal interpt in superior
	MOVEI A,^D100000
	DISMS			; And hang
	JRST .-2

RECVFT:	SKIPG CBFCNT(CNX)	; go to flush output if neg.
	JRST RECV0
	PUSH P,B
	TIME			; If pos., there is an excess of DM's,
	POP P,B
	SUB A,DMTIME(CNX)	;  check elapsed time since last DM
	JUMPL A,RECVBA		;  go on if less than limit
	MOVEI A,400000
	DIR			;  else disable interrups to avoid 
	BCALL(ZINSCT,CNX)	;  confusion, then clear INS counts
	SETZM CBFCNT(CNX)
	MOVEI A,400000
	EIR
	JRST RECVBA


ZCFOBF:	MOVEM A,0(16)		; called from Dmrcv rtn
	MOVE CNX,2(16)
	AOS CBFCNT(CNX)		; if ct -> 0, output flushing stops
	SKIPL 3(16)		; if INS ct pos, more DM's to come,
	 JRST 2,@0(16)		;  clearing continues
	MOVEI A,101		; if INS ct neg, DM came first, 
	SKIPN SAVSWT(CNX)	;  initiate clearing of buf
	CFOBF
	SETZM SAVINC(CNX)
	MOVE A,[POINT 7,SAVBUF]
	MOVEM A,SAVINP(CNX)
	MOVEM A,SAVONP(CNX)
	TIME			; start timing interval from receipt of
	ADDI A,^D5000		;  last excess DM: if no balancing INS
	MOVEM A,DMTIME(CNX)	;  in 5 sec., counts will be cleared
	JRST 2,@0(16)		;  (lost INS, presumably)


RCVBIN:	MOVEM A,0(16)		; Called from RCVCH rtn:
	MOVE A,2(16)		; BIN done here so restart routine can
	MOVE CNX,FSVCNX		; tell if BIN has been completed yet
RCVBX:	SETZM RCVBSW(CNX)	; --switch set from entry to RCVCH
RCVB1:	BIN			; until this point-- this to prevent a
	MOVE A,B		; restarted conx from hanging on BIN,
	JRST 2,@0(16)		; and other undesirable effects


RCVSTX:	BISTUP(CNX)		; Cnx state change intrpt comes here
	MOVE CNX,FSVCNX		; can't trust CNX to be right
	MOVEM CNX,ISTBAS+2
	JSP A,RTNSST		; get send cnx status bit
	MOVEM A,IRSST
	JSP A,RTSJFN		; get send jfn
	MOVE P,[XWD -100,ISPDL-1]
	GDSTS			; check status on that jfn
	TLNE B,(1B7)		; check status bit 7,
	 JRST RCVSX1
	SKIPE IRSST		; off, is cnx status ok?
	 JRST RCVSXX		; yes, do nothing (in phase)
	JSP A,SETSST		; no, set it to ok & report cnx ok again
	MOVE CNX,FSVCNX
	SETZ NOA,		; and prepare to clear output-save
	HRROI B,[ASCIZ /
Service restored/]
	JRST RCVSX2
RCVSX1:	SKIPN IRSST		; bit 7 on, is cnx status ok?
	 JRST RCVSXX		; no, do nothing (already reported)
	JSP A,CLRSST		; yes, turn it off & report cnx dead
	MOVE CNX,FSVCNX
	SETOB NOA,SAVSWT(CNX)	; and set fork to save output
	HRROI B,[ASCIZ /
Host not responding/]
RCVSX2:	MOVE A,[POINT 7,HSFSTR]
	SETZ C,
	SOUT
	HRROI B,[ASCIZ / on connection /]
	SOUT
	MOVE B,FSVCNX
	IMULI B,3
	HRROI B,CONNAM(B)	; identify which connection in message
	SOUT
	HRROI B,[ASCIZ /.
/]
	SOUT
	SETZ B,
	BOUT
	MOVE A,[POINT 7,HSFSTR]
	PUSHJ P,.PSOUT
	MOVEI A,101		; wait until message typed out
	DOBE			;  for neatness
	MOVEM NOA,SAVSWT(CNX)	; execute determined state or saver
RCVSXX:	HRLZI 17,IACSAV
	BLT 17,17
	DEBRK			; restore AC's & exit


RCVINS:	BISTUP(CNX)		; INS interrupts come here
	MOVE CNX,FSVCNX
	MOVEM CNX,ISTBAS+2	; can't trust CNX
	JSP A,INSRCV
	MOVE CNX,FSVCNX
	SOS CBFCNT(CNX)		; If ct -> 0, flushing stops
	SKIPG A			;  if ct neg, more INS's to come
	 JRST RCVINX
	MOVEI A,101		; if ct pos, INS arrived first,
	SKIPN SAVSWT(CNX)	;  start clearing output
	CFOBF
	SETZM SAVINC(CNX)
	MOVE A,[POINT 7,SAVBUF]
	MOVEM A,SAVINP(CNX)
	MOVEM A,SAVONP(CNX)
	HRRZ A,FKRET2
	CAIE A,RECVH
	CAIN A,RECVH+1
	 JRST [	MOVEI A,RECV0
		HRRM A,FKRET2
		JRST RCVINX]
RCVINX:	HRLZI 17,IACSAV
	BLT 17,17
	DEBRK


LOC
VARS:	BLOCK 1
NCONN1==NCONN+1
STBLK:	BLOCK ^D64*NCONN1+2		; BCPL rtns data area
	VAR
HSFSTR:	BLOCK 20
FMODSW:	BLOCK 7
SPARE:	BLOCK 3
NMODSW==.-FMODSW
EVARS:
RELOC

END START
