ENTRY DOFUNC,FCTTYPE,FITDRIVER,DEEPDIFF,DOVECTORF,FANCYNUM,FIXNAME,MATSORT;
BEGIN "FUNC"
COMMENT

THIS PROGRAM CONTAINS THE MLAB ROUTINES FOR FUNCTIONS, CURVE FITTING, AND DIFFERENTIAL EQUATIONS;



INTEGER TEMP1,TEMP2,V,ISW,ACTUALSBASE,NACTUALS,
        ADX,DI,SUMSW;
STRING FF;
REAL VTEMP,UTEMP,EPS;
SAFE REAL ARRAY ITEMVAR Q,R,ITMV,FVALITM;
SAFE INTEGER ARRAY ITEMVAR YPTRITM;
INTEGER NEQS,FVALJ;

INTERNAL INTEGER FUNCX;






FORWARD INTERNAL PROCEDURE DOFUNC;
FORWARD INTERNAL PROCEDURE DIFF(INTEGER FCTIDX,ARGIDX);
FORWARD INTERNAL STRING SIMPLE PROCEDURE FIXNAME(STRING S);

COMMENT  LINKAGE TO MAIN PROGRAM;

DEFINE DUMMY="1";

SAFE EXTERNAL INTEGER ARRAY IDX[0:DUMMY],
                       A[0:DUMMY],
                       VALUE[0:DUMMY],
                       TYPE[0:DUMMY],
                       NODE[0:DUMMY],
                       P[0:DUMMY],
                       FITM[1:DUMMY], FITF[1:DUMMY], FITW[1:DUMMY];

SAFE EXTERNAL STRING ARRAY NAME[0:DUMMY];
SAFE EXTERNAL STRING ARRAY ST[1:DUMMY];

EXTERNAL SIMPLE PROCEDURE OUTSCR(STRING S);
EXTERNAL SIMPLE PROCEDURE OUTCR(INTEGER CHANNEL;STRING S);
EXTERNAL SIMPLE PROCEDURE OUTSTL(STRING S);
EXTERNAL SIMPLE PROCEDURE LOUT(INTEGER C;STRING S);
EXTERNAL PROCEDURE ERROR(STRING S);
EXTERNAL PROCEDURE TYPEFORMERROR(INTEGER I);
EXTERNAL INTEGER PROCEDURE SYMTABENTRY(STRING X);
EXTERNAL PROCEDURE DELETEENTRY(INTEGER INDEX);
EXTERNAL INTEGER PROCEDURE STORECON(REAL R);
EXTERNAL PROCEDURE PUSH(INTEGER ARG);
EXTERNAL PROCEDURE POP(REFERENCE INTEGER ARG);
EXTERNAL PROCEDURE NEWNODE(REFERENCE INTEGER ARG;  SAFE INTEGER ARRAY STACK);
EXTERNAL PROCEDURE FREENODE(INTEGER ARG; SAFE INTEGER ARRAY STACK);
EXTERNAL INTEGER PROCEDURE UPUTANS(INTEGER ARG,RESULT,TYP);
EXTERNAL INTEGER PROCEDURE CURVEMATS(INTEGER CURVE,SWITCH);
EXTERNAL PROCEDURE SVD(INTEGER M,N;SAFE REAL ARRAY A,Q,U,V);
EXTERNAL INTEGER PROCEDURE BPUTANS(INTEGER ARG1,ARG2,RESULT,TYP,INDEX);
EXTERNAL SAFE REAL ARRAY ITEMVAR PROCEDURE ESM(INTEGER ROWS,COLS;REAL VAL);
EXTERNAL INTEGER PROCEDURE E(INTEGER V);
EXTERNAL SAFE REAL ARRAY ITEMVAR PROCEDURE EMM(INTEGER ROWS,COLS;REAL ARRAY M);
EXTERNAL PROCEDURE FREET(INTEGER I);
EXTERNAL PROCEDURE GETTOKEN(REFERENCE INTEGER U,V);

EXTERNAL INTEGER TEMPCHR,I,NARGS,
                 ZERO,ONE,
                 TEMPH,TEMPDH,
		 BRCHAR,
		 EOF,
                 VALSW,
                 INTEGRALOP,SUMOP,IGRATEOP,LLOKUPOP,ROOTOP,EVALOP,
                 QUIETSW,
                 FITN;

EXTERNAL REAL DEQRELERR;

EXTERNAL STRING B;

COMMENT "HERE VARIOUS MACROS ARE DEFINED.";




COMMENT "******* TOKENS *******";

DEFINE FUNCTIONF="20";
DEFINE POWEROP="3";
DEFINE TRANSP="28";
DEFINE GREATEROP="12";
DEFINE EQUALOP="8";
DEFINE IFOP="69";
DEFINE THENOP="70";
DEFINE MINUS="7";
DEFINE ASSIGNOP="16";
DEFINE ABSUOP = "60";
DEFINE NOTOP = "13";
DEFINE UPLUS = "18";
DEFINE UMINUS="53";
DEFINE PLUS="6";
DEFINE MULTSIGN="4";
DEFINE DIVIDESIGN="5";
DEFINE ID="1";
DEFINE DIFFOP="58";
DEFINE COMMA="17";
DEFINE CR="51";


COMMENT "*******  TYPES(IN SYMTAB) ******";

DEFINE OPERATOR="3";
DEFINE SCALAR="4";
DEFINE UNKNOWN="1 ";
DEFINE FUNCTION="5 ";
DEFINE MATRIX="6 ";
DEFINE WINDOW="7 ";
DEFINE CURVE="8 ";
DEFINE INITIAL="9 ";
DEFINE CONSTANT="2 ";
DEFINE COLON="10 ";
DEFINE ROW="12 ";
DEFINE COL="13 ";
DEFINE SUBSCR="14 ";
DEFINE TEXT="15";
DEFINE CONSTRAINTS = "16";


 

COMMENT "**** OTHER SYMBOLS *******";





DEFINE CRLF="('15&'12)";


DEFINE ROWSIZE(A)="ARRINFO(A,2)";
DEFINE COLSIZE(A)="ARRINFO(A,4)";
DEFINE SIZE(A)="(ARRINFO(A,0))";

DEFINE MAKEDIFFNAME(F,X)=""".""&NAME[F]&"".""&NAME[X]";

DEFINE MAX(A,B) = "IF A<B THEN B ELSE A";


DEFINE  NUMBER(A) = "(A=SCALAR OR A=CONSTANT)";
DEFINE NEWTEMP = "SYMTABENTRY("" ""&TEMPCHR); TEMPCHR_TEMPCHR+1";
DEFINE REL(X)="(0.0 XOR (X))";

DEFINE INT(X)="(0 XOR (X))";

DEFINE UNARYOP(X)="(X=UMINUS OR X=UPLUS OR X=ABSUOP OR X=TRANSP OR X=NOTOP)";



DEFINE STACK(X)="START!CODE '261000000000 15,X; END";
DEFINE UNSTACK(X)="START!CODE '262000000000 15,X; END";



INTEGER PROCEDURE READ (INTEGER I,J);
COMMENT
        INPUT DATA

        I = INDEX OF SYMTABENTRY WITH
                NAME[I] = *DEV:FILNAM.EXT

                OR - IF JUST FILNAM, ASSUME DEV AND EXT.  NOTE NO "*".
          J = INDEX OF SYMTABENTRY OF SCALAR(=# OF #'S TO READ) -IFF NARGS=2!!!.
;
BEGIN
STRING S,T,U;
INTEGER BRCHARX,EOFX,K,N;

        IF (U_NAME[I])="*" THEN K_LOP(U);
        T_SCAN(S_U,2,BRCHARX);
        IF BRCHARX NEQ ":" THEN
        BEGIN
        COMMENT NO DEVICE SPECIFIED. ;
        S_U;
        T_"DSK";
        END
        ELSE
        COMMENT STRIP OFF :;
        K_LOP(S);
COMMENT
        T = DEVICE
        S = FILNAM.EXT[PP]
;
COMMENT IF DEVICE = "TTY" WE MUST CLOSE IT ON CHANNEL 6.;
	IF EQU(T,"TTY") THEN
	BEGIN
	   OUTSCR("TYPE <CONTROL>Z AFTER LAST NUMBER");
	   RELEASE(6);
	END;
        OPEN(1,T,0,2,0,160,BRCHARX,EOFX);
        LOOKUP(1,S,BRCHARX);
        IF BRCHARX THEN
        BEGIN
           RELEASE(1);
           ERROR("LOOKUP FAILED FOR FILE "&S);
           RETURN(0)
        END;

        BEGIN
        SAFE REAL ARRAY TEMP1[1: (N_IF NARGS=1 THEN 2000 ELSE REL(VALUE[J]))];
        FOR K_1 STEP 1 UNTIL N DO
        BEGIN
           TEMP1[K]_REALIN(1);
           IF EOFX THEN DONE;
        END;
        IF BRCHARX=-1 OR K>N THEN K_K-1;  COMMENT  IF NO NUMBER WAS FOUND
                                            ON LAST REALIN, IGNORE
                                            THE 0 VALUE RETURNED.;
        BEGIN
        SAFE REAL ARRAY TEMP2[1:K,1:1];
           FOR K_K STEP -1 UNTIL 1 DO
                TEMP2[K,1]_TEMP1[K];
           Q_NEW(TEMP2);
        END;
        END;
COMMENT IF DEVICE = "TTY", OPEN IT ON CHANNEL 6 NOW.

	RELEASE(1);
	
	IF EQU(T,"TTY") THEN OPEN(6,"TTY",0,1,1,200,BRCHAR,EOF);
        IF NARGS=2 THEN FREET(J);
        RETURN(UPUTANS(I,CVN(Q),MATRIX));
END;
REAL SIMPLE PROCEDURE COLNO(INTEGER ARG);
COMMENT
        NUMBER OF COLUMNS IN A MATRIX

        ARG = ITEM NO. OF MATRIX IN SYMTAB

;
BEGIN
        Q_CVI(ARG);
        RETURN(COLSIZE("DATUM(Q)"));
END;





REAL SIMPLE PROCEDURE ROWNO(INTEGER ARG);
COMMENT
        NUMBER OF ROWS IN A MATRIX

        ARG = ITEM NO. OF MATRIX IN SYMTAB

;
BEGIN
        Q_CVI(ARG);
        RETURN(ROWSIZE("DATUM(Q)"));
END;
SIMPLE PROCEDURE MATSORT(SAFE REAL ARRAY A;INTEGER COLX;REAL DIRECTION);
COMMENT 
	REARRANGE THE ROWS OF A SO THAT ELEMENTS OF COLUMN
	COLX ARE SORTED IN INCREASING ORDER IF DIRECTION IS 1
        OR IN DECREASING ORDER IF DIRECTION IS -1
;
BEGIN
   INTEGER NUMROWS,NUMCOLS,K,C;
   REAL D;

   SIMPLE PROCEDURE SWAPROW(SAFE REAL ARRAY A;INTEGER ROW1,ROW2);
   COMMENT
           INTERCHANGE ROW1 AND ROW2 OF ARRAY A
   ;
   BEGIN
      INTEGER C;
      FOR C_1 STEP 1 UNTIL NUMCOLS DO A[ROW1,C] SWAP A[ROW2,C];
   END;

   SIMPLE PROCEDURE SIFTUP(SAFE REAL ARRAY A;INTEGER N,I);
   COMMENT
           ASSUME A[K,C] > A[2K,C], A[K,C] > A[2K+1,C]
           FOR I+1 <= K <= N.  SIFTUP SWAPS ROWS OF A UNTIL
           THESE CONDITIONS HOLD FOR I <= K <= N.
   ;
   BEGIN
      REAL X; INTEGER J; LABEL L1;

      X_D*A[I,C];
   L1:IF (J_2*I) > N THEN RETURN;
      IF J < N AND D*A[J+1,C] > D*A[J,C] THEN J_J+1;
      IF D*A[J,C] > X THEN
      BEGIN
         SWAPROW(A,I,J); I_J; GOTO L1;
      END;
   END;


   C_COLX;
   D_DIRECTION;
   NUMROWS_ROWSIZE(A);
   NUMCOLS_COLSIZE(A);
   IF COLX > NUMCOLS OR COLX < 1 THEN TYPEFORMERROR(-1);

   FOR K_NUMROWS%2 STEP -1 UNTIL 2 DO SIFTUP(A,NUMROWS,K);
   FOR K_NUMROWS STEP -1 UNTIL 2 DO
   BEGIN
      SIFTUP(A,K,1); SWAPROW(A,K,1);
   END;
END;



INTEGER PROCEDURE SVDM(INTEGER J);
COMMENT J=SYMTAB INDEX OF AN M BY N MATRIX,Z, WITH M>=N.

        AN M+2N BY N MATRIX H IS RETURNED SUCH THAT:
    LET U=H ROW 1:M,
        P=H ROW M+1:M+N,
        V=H ROW M+N+1:M+2N,

THEN P IS DIAGONAL AND U AND V OBEY U'*U=I, V'*V=I, AND
Z=U*P*V'.
;
BEGIN INTEGER M,N,I,K;
Q_CVI(VALUE[J]); M_ROWSIZE("DATUM(Q)"); N_COLSIZE("DATUM(Q)");
IF M<N THEN ERROR("SVD:#ROWS<#COLS");
BEGIN SAFE REAL ARRAY P[1:N], V[1:N,1:N], H[1:M+N+N,1:N];
SVD(M,N,DATUM(Q),P,H,V);

FOR I_1 STEP 1 UNTIL N DO 
BEGIN 
H[M+I,I]_P[I];
FOR K_1 STEP 1 UNTIL N DO H[M+N+I,K]_V[I,K];
END;
Q_NEW(H);
END;
RETURN(UPUTANS(J,CVN(Q),MATRIX));
END "SVDM";
INTEGER PROCEDURE DIAG(INTEGER M);
COMMENT
	RETURN THE SYMTAB INDEX OF A 1 COLUMN MATRIX WITH
	ELEMENTS EQUAL TO THE DIAGONAL ELEMENTS OF THE
	LARGEST SQUARE SUBMATRIX WHICH INCLUDES THE (1,1)
	ELEMENT OF M

	M = SYMTAB INDEX OF MATRIX
;
BEGIN
INTEGER I,N;

	IF TYPE[M] NEQ MATRIX THEN TYPEFORMERROR(M);
	Q_CVI(VALUE[M]);
	N_ IF (I_ROWSIZE("DATUM(Q)")) < (N_COLSIZE("DATUM(Q)"))
	   THEN I ELSE N;

	BEGIN
	SAFE REAL ARRAY R[1:N,1:1];
	   FOR I_1 STEP 1 UNTIL N DO R[I,1]_DATUM(Q)[I,I];
	   Q_NEW(R);
	END;

        RETURN(UPUTANS(M,CVN(Q),MATRIX));
END;





INTEGER SIMPLE PROCEDURE SORT(INTEGER M,COLX);

BEGIN
   IF TYPE[M] NEQ MATRIX THEN TYPEFORMERROR(M);
   IF NOT NUMBER(TYPE[COLX]) THEN TYPEFORMERROR(COLX);

   Q_CVI(VALUE[M]); Q_NEW(DATUM(Q));
   MATSORT(DATUM(Q),REL(VALUE[COLX]),1);
   RETURN(UPUTANS(M,CVN(Q),MATRIX));
END;



INTEGER SIMPLE PROCEDURE SMOOTH(INTEGER M);
BEGIN
INTEGER N,I,J;
REAL A,B,T,X,W;

DEFINE XC(I)="IF I<1 THEN 1 ELSE IF I>N THEN N ELSE I";

   IF TYPE[M] NEQ MATRIX THEN TYPEFORMERROR(M);

   R_Q_CVI(VALUE[M]); Q_NEW(DATUM(Q));
   N_ROWSIZE("DATUM(Q)");
   A_N/(ABS(DATUM(R)[N,1]-DATUM(R)[1,1]));

FOR I_1 STEP 1 UNTIL N DO BEGIN
    B_T_0;
    X_DATUM(R)[I,1];
    FOR J_I-2 STEP 1 UNTIL I+2 DO BEGIN
        W_1/(1+ABS(X-DATUM(R)[XC(J),1])*A);
        T_T+W*DATUM(R)[XC(J),2];
        B_B+W;
                                 END;
    DATUM(Q)[I,2]_T/B;
                           END;

   RETURN(UPUTANS(M,CVN(Q),MATRIX));
END;



INTEGER PROCEDURE COMPRESS(INTEGER M);
COMMENT M=SYMTAB INDEX OF MATRIX.
       RETURN A COMPRESSED COPY OF M WITH ALL ROWS WHOSE 1ST COMPONENT
       IS 0 REMOVED.;
BEGIN INTEGER A,B,T,I,J;
IF TYPE[M] NEQ MATRIX THEN TYPEFORMERROR(M);
Q_CVI(VALUE[M]);
A_ROWSIZE("DATUM(Q)"); B_COLSIZE("DATUM(Q)");
T_0;
FOR I_1 STEP 1 UNTIL A DO IF DATUM(Q)[I,1] NEQ 0 THEN T_T+1;
BEGIN SAFE REAL ARRAY R[1:T,1:B];
T_0;
FOR I_1 STEP 1 UNTIL A DO IF DATUM(Q)[I,1] NEQ 0 THEN BEGIN
                                                    T_T+1;
                                                      FOR J_1 STEP 1 UNTIL B DO R[T,J]_DATUM(Q)[I,J];
                                                      END;
Q_NEW(R);
END;
RETURN(UPUTANS(M,CVN(Q),MATRIX));
END "COMPRESS";

REAL SIMPLE PROCEDURE LOGGAMMA(REAL T);
BEGIN
COMMENT LOG(GAMMA(T))=LOGGAMMA(T) DOES NOT ALWAYS EXIST,SINCE
        GAMMA(T) MAY BE NEGATIVE FOR T<0.  THUS WE COMPUTE
        LOGGAMMA(T) ONLY FOR T>=0.
       TO COMPUTE GAMMA(T) FOR T<0, USE THE IDENTITY:
                 GAMMA(1-X)=PI/(GAMMA(X)*SIN(PI*X)),
       WITH X>0 AND NON-INTEGRAL.

       WE COMPUTE LOGGAMMA(T) BY USING THE ALGORITHM GIVEN BY
       M. C. PIKE AND I. D. HILL BASED ON STIRLING'S FORMULA.
       [ALGORITHM 291,CACM,SEPT. 1966, CACM ,1967].
;

      DEFINE C1=".918938533204673";
      DEFINE C2="-.000595238095238";
      DEFINE C3=".000793650793651";
      DEFINE C4="-.002777777777778";
      DEFINE C5=".083333333333333";


      REAL X,Z;

      X_1;
      FOR T_T STEP 1 WHILE T<7 DO X_X*T;
      X_-LOG(X);
      Z_1/(T*T);
      RETURN(  X+(T-.5)*LOG(T)-T+C1+(((C2*Z+C3)*Z+C4)*Z+C5)/T  );

END "LOGGAMMA";

REAL PROCEDURE TYPEOUT(REAL X);
BEGIN SETFORMAT(0,7); OUTSTL("TYPEOUT:"&CVG(X)&CRLF); RETURN(X) END;

INTEGER PROCEDURE CROSS(INTEGER X,Y);
COMMENT X AND Y ARE SYMTAB INDEXES OF MATRICES.  THE
SYMTAB INDEX OF THE CROSS PRODUCT MATRIX(ALL PAIRS OF ROWS)
IS RETURNED.  THIS ENTRY IS A TEMP OF COURSE.;
BEGIN
INTEGER I,J,CI,CJ,I1,I2,S;
Q_CVI(VALUE[X]); R_CVI(VALUE[Y]);
I_ROWSIZE("DATUM(Q)"); J_ROWSIZE("DATUM(R)");
CI_COLSIZE("DATUM(Q)"); CJ_COLSIZE("DATUM(R)");

BEGIN
SAFE REAL ARRAY M[1:I*J,1:CI+CJ];

S_1;
FOR I1_1 STEP 1 UNTIL I DO FOR I2_1 STEP 1 UNTIL J DO 
    BEGIN ARRBLT(M[S,1],DATUM(Q)[I1,1],CI); ARRBLT(M[S,CI+1],DATUM(R)[I2,1],CJ); S_S+1 END;

Q_NEW(M)
END;
RETURN(BPUTANS(X,Y,CVN(Q),MATRIX,0));
END "CROSS";

INTEGER PROCEDURE MESH(INTEGER X,Y);
COMMENT X AND Y ARE SYMTAB INDEXES OF MATRICES.  THE SYMTAB
INDEX OF THE MESH MATRIX (EVERY OTHER ROW FILLED FROM THE FIRST
MATRIX, AND THE OTHER ROWS FILLED FROM THE SECOND) IS RETURNED.;
BEGIN
INTEGER I,J,CI,CJ,I1,D;
Q_CVI(VALUE[X]); R_CVI(VALUE[Y]);
I_ROWSIZE("DATUM(Q)"); J_ROWSIZE("DATUM(R)");
CI_COLSIZE("DATUM(Q)"); CJ_COLSIZE("DATUM(R)");
D_MAX(I,J);

BEGIN
SAFE REAL ARRAY M[1:D+D,1:MAX(CI,CJ)];

FOR I1_1 STEP 1 UNTIL D DO 
    BEGIN IF I1 LEQ I THEN ARRBLT(M[I1+I1-1,1],DATUM(Q)[I1,1],CI); 
          IF I1 LEQ J THEN ARRBLT(M[I1+I1,1],DATUM(R)[I1,1],CJ); 
    END;
Q_NEW(M)
END;
RETURN(BPUTANS(X,Y,CVN(Q),MATRIX,0));
END "MESH";

INTEGER PROCEDURE ROTATE(INTEGER X;INTEGER N);
COMMENT X IS THE SYMTAB INDEX OF A MATRIX. N IS THE SYMTAB
INDEX OF A SCALAR REAL VALUE.  THE MATRIX OF X IS ROTATED
"DOWN" N PLACES AND THE SYMTAB ENTRY OF THE RESULTING MATRIX
IS RETURNED.  

NOTE THE RESULT IS X ROW (NROWS(X)-N+1:NROWS(X),1:N).;

BEGIN
INTEGER CS,RS,V,I,J;
Q_CVI(VALUE[X]);
CS_COLSIZE("DATUM(Q)"); RS_ROWSIZE("DATUM(Q)");
BEGIN
SAFE REAL ARRAY TEMP[1:RS,1:CS];

V_REL(VALUE[N]);
FOR I_1 STEP 1 UNTIL RS DO BEGIN
                           J_IF I LEQ RS-V THEN V+I ELSE I-RS+V;
                           ARRBLT(TEMP[J,1],DATUM(Q)[I,1],CS)
                           END;
Q_NEW(TEMP)
END;
RETURN(BPUTANS(X,N,CVN(Q),MATRIX,0));
END "ROTATE";
INTEGER PROCEDURE INTERPOLATE(INTEGER XY,N);
COMMENT
	GIVEN A MATRIX M OF DATA POINTS, CONSTRUCT A SMOOTH
	CURVE THROUGH THE POINTS.  

	N IS A ONE COLUMN MATRIX OF X COORDINATES.  RETURN
	A MATRIX OF THE POINTS ON THE CURVE WITH X 
	COORDINATES GIVEN BY N.

	SMOOTH CURVE ALGORITHM:

	CONSIDER FIVE POINTS.
	LET M(I) BE THE SLOPE OF THE LINE FROM POINT I TO
	POINT I+1.  THE SLOPE OF THE CURVE THROUGH POINT 3
	IS GIVEN BY

	T(3) = (ABS(M(4)-M(3))*M(2) + ABS(M(2)-M(1)*M(3)/
		(ABS(M(4)-M(3)) + ABS(M(2)-M(1)))
		IF THIS EXPRESSION EXISTS 
	ELSE 
	
	T(3) = (M(2)+M(3))/2

	TWO POINTS MUST BE CONSTRUCTED AT EACH END OF THE
	DATA.  THESE POINTS ARE CONSTRUCTED BY USING THE
	CUBIC WHICH PASSES THROUGH THE LAST 3 GIVEN POINTS.


	TO FIND THE Y COORDINATE OF THE POINT ON THE CURVE WITH
	X COORDINATE "X", PICK DATA POINTS X1 AND X2 SUCH THAT
	X1 <= X <= X2.  THEN THE Y COORDINATE CORRESPONDING TO
	X IS GIVEN BY

	Y = Y1 + T1 * (X-X1) + P2 * (X-X1)^2 + P3 * (X-X1)^3

	Y1 = Y COORDINATE CORRESPONDING TO POINT X1
	T1 = SLOPE OF CURVE AT (X1,Y1)

	P2 = (3*(Y2-Y1)/(X2-X1) - 2*T1-T2)/(X2-X1)
	
	P3 = (T1 + T2 - 2*(Y2-Y1)/(X2-X1))/(X2-X1)^2

	THIS ALGORITHM APPEARED IN THE JOURNAL OF THE ACM,
	OCTOBER, 1970, PP. 589-602

	WOE, WOE UNTO HE WHO WOULD USE THIS FUNCTION AS A
	SUBSTITUTE FOR A THOUGHT - OUT MODEL.  WE ARE NOT
	RESPONSIBLE FOR SUCH INTELLECTUAL SLOP!!!!!!!!!!

;
BEGIN
INTEGER I,NDP,NRP;
REAL D1,D2;

Q_CVI(VALUE[XY]);
R_CVI(VALUE[N]);
IF TYPE[XY] NEQ MATRIX OR COLSIZE("DATUM(Q)") NEQ 2 THEN TYPEFORMERROR(XY);
NDP_ROWSIZE("DATUM(Q)");

IF NDP < 3 THEN
BEGIN
REAL ARRAY M[1:3,1:2];
	CASE NDP OF
	BEGIN
	   ;
	   FOR I_1 STEP 1 UNTIL 2 DO FOR NRP_1 STEP 1 UNTIL 3
		DO M[NRP,I]_DATUM(Q)[1,I]+NRP*(2-I);
	   BEGIN
	   	FOR I_1 STEP 1 UNTIL 2 DO M[1,I]_DATUM(Q)[1,I];
		FOR I_1 STEP 1 UNTIL 2 DO M[3,I]_DATUM(Q)[2,I];
		FOR I_1 STEP 1 UNTIL 2 DO M[2,I]_(M[1,I]+M[3,I])/2;
	   END
	END;
	Q_NEW(M);
	NDP_3;
END;

BEGIN	"IALG"

SAFE REAL ARRAY T[1:NDP];

BEGIN	"CURVESLOPE"

SAFE REAL ARRAY M[-1:NDP+1];

COMMENT	M[I] = SLOPE OF LINE FROM POINT I TO POINT I+1;

	FOR I_1 STEP 1 UNTIL NDP-1 DO
		M[I]_(DATUM(Q)[I+1,2]-DATUM(Q)[I,2]) / 
		     (DATUM(Q)[I+1,1]-DATUM(Q)[I,1]);

COMMENT ALGORITM NEEDS SLOPES AT TWO POINTS ON EACH END OF
	THE DATA.  THE JACM ARTICLE DERIVES THE FOLLOWING
	GUESSES FOR THESE SLOPES.;

	FOR I_NDP STEP 1 UNTIL NDP+1 DO
	   	M[I]_M[I-1]*2 - M[I-2];

	FOR I_0 STEP -1 UNTIL -1 DO
		M[I]_M[I+1]*2 - M[I+2];

	FOR I_1 STEP 1 UNTIL NDP DO
	BEGIN
	   D1_(ABS(M[I+1]-M[I]))*M[I-1] + 
	      (ABS(M[I-1]-M[I-2]))*M[I];
	   D2_(ABS(M[I+1]-M[I]) + ABS(M[I-1]-M[I-2]));
	   T[I]_IF D2 = 0 THEN (M[I-1] + M[I])/2
			  ELSE D1/D2;
	END;
END	"CURVESLOPE";

	NRP_ROWSIZE("DATUM(R)");
	BEGIN	"COMPANSWER"
	SAFE REAL ARRAY RESULT[1:NRP,1:2];
	INTEGER DP,DPNEW;
	REAL DX;

	DP_1;
	DPNEW_TRUE;

	FOR I_1 STEP 1 UNTIL NRP DO
	BEGIN	"RESULTLOOP"
	REAL X;

	X_RESULT[I,1]_DATUM(R)[I,1];

	WHILE DP < NDP-1 AND X > DATUM(Q)[DP+1,1] DO
	BEGIN
	   DP_DP+1;
	   DPNEW_TRUE;
	END;

	IF DPNEW THEN
	BEGIN   "COMPUTECUBICCOEFFICIENTS"

	REAL A,B;

	A_DATUM(Q)[DP+1,2] - DATUM(Q)[DP,2];
	B_DATUM(Q)[DP+1,1] - DATUM(Q)[DP,1];
	D1_(3*A/B-2*T[DP]-T[DP+1])/B;
	D2_(T[DP]+T[DP+1]-2*A/B)/(B*B);
	DPNEW_FALSE;
	END	"COMPUTECUBICCOEFFICIENTS";

	DX_X-DATUM(Q)[DP,1];

	RESULT[I,2]_DATUM(Q)[DP,2]
		   + T[DP] * DX
		   + D1 * DX * DX
		   + D2 * DX * DX * DX;
	END "RESULTLOOP";
	IF CVN(Q) NEQ VALUE[XY] THEN DELETE(Q);
	Q_NEW(RESULT);
	END "COMPANSWER";

	END	"IALG";
RETURN(BPUTANS(XY,N,CVN(Q),MATRIX,0));
END	"INTERPOLATE";












INTEGER PROCEDURE HISTO(INTEGER I);
BEGIN  INTEGER J,N,J2,J21;
       REAL A;

       Q_CVI(VALUE[I]); N_ROWSIZE("DATUM(Q)");
BEGIN  SAFE REAL ARRAY H[1:N+N+2,1:2];

       IF N LEQ 1 THEN A_1 ELSE A_(DATUM(Q)[2,1]-DATUM(Q)[1,1])/2;
       H[1,1]_DATUM(Q)[1,1]-A;
       H[1,2]_0;
     IF N>1 THEN
       FOR J_1 STEP 1 UNTIL N DO BEGIN
           J2_J+J; J21_J2+1;
           H[J2,1]_DATUM(Q)[J,1]-A;
           H[J2,2]_H[J21,2]_DATUM(Q)[J,2];
           IF J<N THEN A_(DATUM(Q)[J+1,1]-DATUM(Q)[J,1])/2;
           H[J21,1]_DATUM(Q)[J,1]+A;
                                 END;
       H[N+N+2,1]_DATUM(Q)[N,1]+A;
       H[N+N+2,2]_0;

       Q_NEW(H);
END;

RETURN(UPUTANS(I,CVN(Q),MATRIX));
END "HISTO";

INTEGER PROCEDURE POINTS(INTEGER F,M);
COMMENT
        CALL:        F = INDEX OF A FUNCTION ENTRY IN SYMTAB
                M = INDEX OF A MATRIX ENTRY IN SYMTAB

        RETURN:        INDEX OF M&'F(M)

;
BEGIN
SAFE INTEGER ARRAY ITEMVAR PP;
INTEGER RS,CS,CS1,T,I1,J;
        

	IF TYPE[M] NEQ MATRIX OR NOT(TYPE[F] = FUNCTION
	   OR TYPE[F] LEQ UNKNOWN)
                THEN TYPEFORMERROR(-1);

        PP_CVI(VALUE[M]);
        RS_ROWSIZE("DATUM(PP)");
        NARGS_CS_COLSIZE("DATUM(PP)");
        CS1_CS+1;
        VALSW_TRUE;
        BEGIN
        SAFE INTEGER ARRAY AR[1:RS,1:CS1];

            PUSH(F);

           FOR I1_1 STEP 1 UNTIL RS DO
           BEGIN
                ARRBLT(AR[I1,1],DATUM(PP)[I1,1],CS);
                FOR J_1 STEP 1 UNTIL CS DO
                   P[I_I+1]_DATUM(PP)[I1,J];
           DOFUNC;
           AR[I1,CS1]_P[I];  P[I]_F;
           END;

           I_I-1;

           PP_NEW(AR);
        END;
RETURN(UPUTANS(M,CVN(PP),MATRIX));
END;
INTERNAL SIMPLE PROCEDURE DEEPDIFF(STRING F);
BEGIN
      INTEGER T;  STRING DIFFSYM;
      LABEL CKDIFF;

      CKDIFF:T_LENGTH(F);
              WHILE F[T FOR 1] NEQ "." DO T_T-1;
              DIFFSYM_F[T+1 TO INF];
              F_F[2 TO T-1];
              T_SYMTABENTRY(F);

              IF TYPE[T]=UNKNOWN THEN IF F NEQ "." THEN
                 ERROR(FIXNAME(F)&" NOT DEFINED.")  ELSE
                 GOTO CKDIFF;

              DIFF(T, SYMTABENTRY(DIFFSYM));
END;



SIMPLE PROCEDURE DEQSETUP(SAFE REAL ARRAY Y,TOL; SAFE INTEGER ARRAY YPTR,DYPTR; REFERENCE REAL T; INTEGER PBASE);
BEGIN
INTEGER J,K;

COMMENT P[PBASE+1:PBASE+NEQS] HOLDS A SEQUENCE OF
       SYMTAB ENTRIES FOR A SYSTEM OF DIFFERENTIAL EQUATIONS.
       YPTR AND DYPTR ARE TO BE COMPUTED, T AND Y ARE TO BE
       SET FROM THE INITIAL CONDITIONS, TOL IS TO BE SET BASED
       ON Y, AND THEN THESE RESULTS ARE RETURNED;

VALSW_TRUE;
FOR J_1 STEP 1 UNTIL NEQS DO BEGIN
    YPTR[J]_K_SYMTABENTRY( SCAN(FF_FIXNAME(NAME[DYPTR[J]_P[PBASE+J]]), 2, BRCHAR) );
    PUSH(K);
    NARGS_0;
    DOFUNC;
     COMMENT VALUE[K] HAS BEEN SET TO P[I] IN DOFUNC;
    I_I-1;
    Y[J]_REL(VALUE[K]);
    TOL[J]_DEQRELERR*ABS(Y[J])+.00001;

COMMENT  PICK UP INITIAL T VALUE - (AS ARG OF INIT FCT!);
    K_VALUE[A[NODE[IDX[K]+1]+1]];
    IF J>1 THEN BEGIN IF T NEQ REL(K) THEN ERROR("DEQ INIT VALUES BAD") END
           ELSE T_REL(K);
                           END;
END "DEQSETUP";
SAFE REAL ARRAY ITEMVAR PROCEDURE DEQ( SAFE INTEGER ARRAY YPTR,DYPTR; SAFE REAL ARRAY MV,Y,DY,TOL; REAL T);
BEGIN
DEFINE MAXORD="5";
DEFINE AMINSTEP=".0000002";

REAL AMAXSTEP;
INTEGER NPTS;
REAL T1;

SAFE REAL ARRAY YP[1:NEQS],
                DYP[1:NEQS],
                W[1:NEQS,0:MAXORD+1];

YPTRITM_NEW(YPTR);

           NPTS_ROWSIZE(MV);
           T1_MV[1,1];

         AMAXSTEP_ABS(MV[NPTS,1]-T1)/12;
         IF AMAXSTEP<1 THEN AMAXSTEP_12;
         IF NPTS=1 THEN AMAXSTEP_ABS(T1-T)/12;
         IF AMAXSTEP<.01 THEN AMAXSTEP_.01;

BEGIN "DEQLOOP"

LABEL GETDERIVES,ALPHA,ENDDEQ;
INTEGER KSW,K;
INTEGER WORSTEQ;
REAL ERRFAC,R,WORSTERR;

BEGIN SAFE REAL ARRAY FVAL[1:NPTS,1:NEQS+NEQS+1]; FVALITM_NEW(FVAL) END;

ERRFAC_DEQRELERR;
KSW_0;
FVALJ_1;
GOTO GETDERIVES;





ALPHA:  
BEGIN  "DEQCODE"
COMMENT ====================================================================

THIS PROCEDURE SOLVES A SYSTEM OF ORDINARY DIFFERENTIAL EQUATIONS
WITH KNOWN INITIAL CONDITIONS.
THE SYSTEM IS: Y1'=F1(Y,T)
               Y2'=F2(Y,T)
                .
                .
               YN'=FN(Y,T).

          WITH Y1[A]=V1,
               Y2[A]=V2,
                 .
                 .

               YN[A]=VN.

IN VECTOR FORM WE HAVE DY=F(Y,T) WITH Y[A]=V.

AN EXTERNAL PROCEDURE FOR EVALUATING F GIVEN Y AND T, THUS
OBTAINING DY FOR THAT T AND Y, MUST BE AVAILABLE.

THE OUTPUT IS THE VECTOR VALUES Y AND DY AT T1, GIVEN T=A.
THUS THE ROUTINE TAKES A SINGLE STEP AT EACH INVOCATION SEQUENCE.

THE PROGRAM IS BASED ON THE METHOD GIVEN IN

NORDSIECK,ARNOLD, ON NUMERICAL INTEGRATION OF ORDINARY DIFFERENTIAL
                  EQUATIONS,MATH. OF COMP., VOL 16,PP 22:49, 1962
AND

SHRAGER,RICHARD I.,NUMERICAL INTEGRATION OF ORDINARY DIFFERENTIAL
                   EQUATIONS:SOME METHODS WITH VARIABLE STEPSIZE
                   AND ORDER,  TO APPEAR.
===============================================================

   KSW=FLOW CONTROL IN USER'S CALLING PROGRAM. INITIALLY THE USER SETS IT TO
       0,MEANING START INTEGRATING WITH NO REGARD FOR PREVIOUS
       INTEGRATION IF THERE WAS ANY. THIS SIGNAL SHOULD BE GIVEN BY THE
       USER WHENEVER DISCONTINUITY OCCURS IN Y OR F, OR WHENEVER THE
       NUMBER OF Y'S CHANGES, OR WHEN THERE IS ANY ABRUPT CHANGE IN
       THE NATURE OF THE EQUATIONS.
       WHEN THE USER SETS KSW TO 0, SIGNALING THE START OF AN
        INTEGRATION FROM T TO T1, HE SHOULD COMPUTE Y AND THEN
       DY AT T BEFORE ENTERING DEQ.

KSW OUTPUT:
-----------
     0 IF DEQ RETURNS TO THE USER WITH KSW=0, SOME DIFF.EQ. DOES NOT
       MEET ITS TOLERANCE, EVEN WITH MINIMUM STEP SIZE. DO NOT ATTEMPT
       TO PROCEED WITHOUT CHANGING THE TOLERANCE VALUES, THE MINIMUM STEP SIZE,
       OR THE DIFF.EQS.. IF ONLY THE TOLERANCE OR MIN. STEPSIZE IS
       CHANGED, ONE MAY MERELY REENTER WITH KSW=0, SINCE T,T1,Y,
       AND DY ARE ALL APPROPRIATELY SET.

     1 MEANS THIS IS A MANDATORY POINT, T=T1 AS REQUESTED BY THE
       USER. Y AND DY ARE SOLUTION VALUES AT T. IF INTEGRATION IS TO
       CONTINUE, T1 MUST BE SET BY THE USER TO THE NEXT MANDATORY VALUE OF T.
     2 MEANS THAT THE POINT (T,Y,DY) IS A VALID SOLUTION POINT, BUT NOT
       THE MANDATORY POINT REQUESTED IN T1. 
    >2 IS A REQUEST FOR THE VECTOR OF DERIVATIVES ,DY, GIVEN BY
       F(Y,T), TO BE COMPUTED AND RETURNED.  (KSW=3 IS A REQUEST
       BY THE PREDICTOR, AND KSW=4 IS A REQUEST BY THE CORRECTOR.)

       DISCONTINUITIES, INCREASES OR DECREASES IN THE NUMBER 
       OF EQUATIONS, ETC. MAY BE  INTRODUCED ONLY WHEN KSW 
       IS RETURNED AS 1 OR 2. THEN KSW MAY BE RESET TO 0.

       IF SOME QUANTITIES ARE SLOWLY
       CHANGING IN THE DERIVATIVES, AND ARE EXPENSIVE TO COMPUTE, THEY
       MAY BE COMPUTED ONLY AT EVERY NTH VALID POINT, WHEN 
       KSW=1 OR KSW=2, AND NOT EACH TIME DY IS REQUESTED,
       BUT IT IS THEN ADVISABLE TO ALSO RECOMPUTE THE DERIVATIVES ,DY, BEFORE
       RE-ENTERING. OTHERWISE, THE METHOD WILL BE
       INCONSISTENT IN THE TEXT BOOK SENSE.

    ISW=A NON-ZERO VALUE ONLY IF THE SYSTEM OF DIFFERENTIAL
        EQUATIONS ARE OF THE FORM Y'=F(T) (THIS IS THE CASE
        WHEN WE ARE SOLVING A DIFFERENTIAL EQUATION FOR THE
        PURPOSE OF EVALUATING A DEFINITE INTEGRAL FOR EXAMPLE).
        IN THIS EVENT, THE DERIVATIVE ESTIMATES DO NOT HAVE
        TO BE CORRECTED SINCE THEY ARE INDEPENDENT OF Y, AND
        HENCE SOME TIME CAN BE SAVED.

    NEQS=NO. OF DIFF.EQS. IN THE SYSTEM, SET BY CALLER.
  MAXORD=MAXIMUM ALLOWABLE ORDER <=6., SET BY CALLER.
         MAXORD CANNOT BE RESET UNLESS KSW IS RESET TO 0.
 WORSTEQ=INDEX OF WORST DIFF.EQ., I.E. DIFF.EQ. WITH THE LARGEST
         FRACTION ABS(ERR[WORST])/TOL[WORST], SET BY DEQ.

      T1=THE NEXT MANDATORY TIME, AT WHICH THE VALID VALUES (T,Y,DY)
         MUST BE PRESENTED TO THE CALLER WITH KSW=1. T1 IS INITIALIZED
         BY THE CALLER, AND RESET BY THE CALLER WHENEVER KSW=1. OPTIONALLY,
         T1 MAY BE RESET AT ANY VALID TIME, AND MAY BE > OR < T.

AMINSTEP=ABSOLUTE VALUE OF MINIMUM PERMISSIBLE TIME STEP.
         SET BY CALLER, MAY BE RESET AT VALID POINTS.
WORSTERR=WORST FRACTION ERROR ABS(ERR[WORST])/TOL[WORST].
         WORSTERR IS NOT MEANINGFUL UNLESS WORSTEQ IS NON-ZERO.

       T=THE INDEPENDENT VARIABLE, A SCALAR.
         INITIALIZED BY THE USER, THEREAFTER CONTROLLED BY NIHD21.
      DY=THE VECTOR OF DERIVATIVES DY[I]/DT, I=1 TO NEQS.
         COMPUTED BY THE USER WHENEVER NIHD21 RETURNS WITH KSW>2.

      Y=THE VECTOR OF SOLUTION VALUES AT T.
    TOL=VECTOR OF TOLERANCES ON Y, THE MAXIMUM ABSOLUTE ERROR
        PERMITTED PER STEP. IF RELATIVE ERROR IS PREFERABLE FOR
        SOME Y'S THE USER SHOULD COMPUTE TOL[I]=RELTOL[I]*Y[I]
        FOR THOSE Y'S AT EVERY VALID STEP, OR FREQUENTLY
        ENOUGH TO KEEP TOL[I] REASONABLE.

YP[1:NEQS],
DYP[1:NEQS]=GLOBALLY-PROVIDED WORKSPACE ARRAYS.
W[1:NEQS,0:MAXORD+1]=AN ARRAY OF WORK SPACE.

=====================================================================

    NOLD=CURRENT ORDER OF INTEGRATION FOR VALID STEP JUST TAKEN.
       H=CURRENT STEP SIZE.
;

SAFE OWN REAL ARRAY HP[1:7];

PRELOAD!WITH  3,6,10,15,  0,4,10,20,  0,0,5,15,  0,0,0,6;
SAFE OWN REAL ARRAY PASCL[2:5,3:6];

PRELOAD!WITH  1,1,2,6,24,120,720,5040;
SAFE OWN REAL ARRAY FAC[0:7];

PRELOAD!WITH  .5, .416666666666667, .375, .348611111111111, .329861111111111, .315591931216931;
SAFE OWN REAL ARRAY CORY[1:6];

PRELOAD!WITH  
.5, .75,              .916666666666667,    1.04166666666667,    1.14166666666667,
0,  .166666666666667, .333333333333333,    .486111111111111,    .625,
0,  0,                .0416666666666667,   .104166666666667,    .177083333333333,
0,  0,                0,                   .00833333333333333,  .025,
0,  0,                0,                   0,                   .00138888888888889;
SAFE OWN REAL ARRAY CORZ[2:6,2:6];

PRELOAD!WITH  
0,       1.5,      4,        15,       72,       420,
0,       0,        4,        18.333333,100,      639.333333333333,
0,       0,        0,        7.5,      52.5,     393.75,
0,       0,        0,        0,        12,       119,
0,       0,        0,        0,        0,        17.5,
0,       0,        0,        0,        0,        0;
SAFE OWN REAL ARRAY ZLAG[2:7,1:6];

PRELOAD!WITH  2,  12,  24,  37.9,  53.3,  70.08;
SAFE OWN REAL ARRAY ERRFAC[1:6];

INTEGER  I,J,M,NGOOD,NOLD,NOLDP1,NORD,NORDP1,NORDP2,NEXTRA,UP;
REAL  TGOOD,TEMP,H,HOLD,TEMP1,ERR,WNEW,WOLD,HGOOD,FORD;
LABEL L2,MANDATE,ERRBIG,NEWH,ADVANCE;
        "=================================================================== "

CASE KSW OF BEGIN 
BEGIN "L0:"
COMMENT " INITIAL DERIVS NOW IN DY , Y IS ALSO SET.  START.  ";
WORSTEQ_0; WORSTERR_0;  
FORD_1; NORD_NOLD_NGOOD_1;  NORDP1_NOLDP1_2;  NORDP2_3;  
WORSTERR_1;  H_HOLD_.001;  NEXTRA_0;  
GOTO MANDATE;
END "L0:";
        "******************************************************************* "

GOTO L2;
        "******************************************************************* "

L2: 
BEGIN "L1:L2:"
COMMENT " A VALID POINT (T,Y,DY) HAS JUST BEEN PROCESSED BY THE CALLER  ";
FOR I_1 STEP 1 UNTIL NEQS DO BEGIN W[I,0]_Y[I]; W[I,1]_DY[I]; END;
TGOOD_T; HGOOD_H;

COMMENT " SELECT NEW STEP SIZE  ";
NEWH:
IF NORD NEQ NOLD THEN BEGIN FORD_NORD; NORDP1_NORD+1;  NORDP2_NORD+2;  NEXTRA_0;  END;

TEMP1_T1-TGOOD;
IF TEMP1=0 THEN GOTO MANDATE;
IF WORSTERR<.0001 THEN WORSTERR_.0001;
H_ABS(HOLD)*(.5/WORSTERR)^(1/(FORD+1));
IF H> ABS(TEMP1) THEN H_ABS(TEMP1);
IF H<AMINSTEP THEN H_AMINSTEP;
IF H>AMAXSTEP THEN H_AMAXSTEP;
IF TEMP1<0 THEN H_-H;

TEMP_H/TEMP1;
IF TEMP>.95 THEN  H_TEMP1 ELSE IF TEMP>.5  THEN H_.5*TEMP1;

COMMENT " SCALE HIGHER DERIVATIVES FOR NEW STEP OR ORDER OR BOTH  ";
HP[1]_H/HOLD;
M_IF NORD<NOLD THEN NOLD ELSE NORD;
FOR J_2 STEP 1 UNTIL M DO  HP[J]_HP[1]*HP[J-1];  

FOR I_1 STEP 1 UNTIL NEQS DO BEGIN "LOOP"
WOLD_W[I,NOLDP1];

IF NORD<NOLD THEN BEGIN
COMMENT " ORDER IS DECREASED  ";
W[I,NOLDP1]_WOLD*HP[NOLD];
FOR J_NOLD STEP -1 UNTIL 2 DO BEGIN
      TEMP_0;
      FOR M_(IF J>NORD THEN J ELSE NORD) STEP 1 UNTIL NOLD DO TEMP_TEMP-ZLAG[J,M]*W[I,M+1];   
      W[I,J]_(W[I,J]+ZLAG[J,NOLD]*WOLD)*HP[J-1]+TEMP;
                              END;
                  END ELSE
IF NORD=NOLD THEN BEGIN
COMMENT " ORDER IS RETAINED  ";
WNEW_W[I,NORDP1]_WOLD*HP[NORD];  
FOR J_2 STEP 1 UNTIL NORD DO W[I,J]_(W[I,J]+ZLAG[J,NORD]*WOLD)*HP[J-1]-ZLAG[J,NORD]*WNEW;  
                  END ELSE
BEGIN
COMMENT " ORDER IS INCREASED  ";
TEMP_W[I,NORDP1];  WNEW_TEMP*HP[NORD];  W[I,NORDP1]_WNEW;
FOR J_2 STEP 1 UNTIL NORD DO W[I,J]_(W[I,J]+ZLAG[J,NOLD]*WOLD+ZLAG[J,NORD]*TEMP)*HP[J-1]-ZLAG[J,NORD]*WNEW;  
END
                             END "LOOP";
COMMENT " PREDICT Y AND DY  ";
HOLD_H;  NOLD_NORD;  NOLDP1_NORDP1;
FOR I_1 STEP 1 UNTIL NEQS DO BEGIN 
    TEMP_TEMP1_0;
    FOR J_1 STEP 1 UNTIL NORD DO BEGIN 
                                 TEMP_TEMP+W[I,J]; 
                                 TEMP1_TEMP1+J*W[I,J]; 
                                 END;
    DYP[I]_TEMP1;
    Y[I]_YP[I]_W[I,0]+H*TEMP; 
                             END;
COMMENT "Y AND T ARE NOW TO BE USED TO COMPUTE DY OUTSIDE. ";
T_TGOOD+H;  KSW_3;  
END "L1:L2:";
         "******************************************************************* "

BEGIN "L3:"
COMMENT " DERIVS FOR PREDICTED Y ARE NOW IN DY  ";
WORSTERR_0;
FOR I_1 STEP 1 UNTIL NEQS DO BEGIN 
                             ERR_ABS(H*(DY[I]-DYP[I]))/(ERRFAC[NORD]*TOL[I]);
                             IF ERR>WORSTERR THEN BEGIN  WORSTERR_ERR; WORSTEQ_I; END;
                             END;
IF WORSTERR LEQ 1 THEN BEGIN
                       COMMENT " CORRECT THE PREDICTED Y VALUES  ";
                       FOR I_1 STEP 1 UNTIL NEQS DO Y[I]_YP[I]+CORY[NORD]*(DY[I]-DYP[I])*H;
                       KSW_4; 
                       IF ISW THEN BEGIN FOR I_1 STEP 1 UNTIL NEQS DO DYP[I]_DY[I]-DYP[I]; GOTO ADVANCE  END
                       END
ELSE ERRBIG:
COMMENT " (WORSTEQ)TH ERROR IS WORSTERR TIMES LARGER THAN TOL[WORSTEQ]  ";
       IF ABS(ABS(H)-AMINSTEP)>.00001*AMINSTEP THEN BEGIN
            TEMP1_.5/WORSTERR;  
            TEMP_((2*NGOOD-2)*H)/HGOOD;
            NORD_1;
            WHILE NORD<NGOOD AND NOT TEMP1 LEQ ((NORD+NORD-1)/TEMP)^(NORD+1) DO NORD_NORD+1;
            GOTO NEWH;
                                                    END  
       ELSE BEGIN
            FOR I_1 STEP 1 UNTIL NEQS DO BEGIN Y[I]_W[I,0]; DY[I]_W[I,1]; END;
            KSW_0; T_TGOOD;
            END
END "L3:";
        "******************************************************************* "

BEGIN "L4:"
COMMENT " DERIVS FOR CORRECTED VALUE OF Y ARE NOW IN DY  ";
WORSTERR_0;
FOR I_1 STEP 1 UNTIL NEQS DO BEGIN 
                             DYP[I]_DY[I]-DYP[I];
                             ERR_(ABS(DYP[I]*H)/ERRFAC[NORD]+ABS(Y[I]-YP[I]-CORY[NORD]*DYP[I]*H))/TOL[I];
                             IF ERR>WORSTERR THEN BEGIN  WORSTERR_ERR; WORSTEQ_I; END; 
                             END;
IF WORSTERR>1 THEN GOTO ERRBIG;

COMMENT " ADVANCE HIGHER DERIVS ONE STEP  ";
ADVANCE:
IF NORD=1 THEN WNEW_.5  ELSE WNEW_CORZ[NORD,NORD]/(FORD+1);
IF NORD<MAXORD AND NEXTRA=NORDP1 THEN UP_TRUE ELSE UP_FALSE;

FOR I_1 STEP 1 UNTIL NEQS DO BEGIN 
    FOR J_2 STEP 1 UNTIL NORD DO BEGIN
                                 TEMP_0;
                                 FOR M_J+1 STEP 1 UNTIL NORD DO TEMP_TEMP+W[I,M]*PASCL[J,M];
                                 W[I,J]_W[I,J]+TEMP+CORZ[J,NORD]*DYP[I];  
                                 END;
    TEMP1_W[I,NORDP1];  
    TEMP_W[I,NORDP1]_WNEW*DYP[I];
    IF UP THEN W[I,NORDP2]_(1/(FORD+2))*(TEMP-TEMP1);  
                             END;
NGOOD_NORD;  NEXTRA_IF NORDP1 LEQ NEXTRA THEN NORDP1 ELSE NEXTRA+1;
IF UP THEN NORD_NORD+1;

COMMENT " IS THIS A MANDATORY POINT?  ";
MANDATE:
IF ABS(T1-T) < AMINSTEP THEN BEGIN  T_T1; KSW_1; END ELSE KSW_2;
END "L4:";

END ;

END "DEQCODE";


IF KSW>2 THEN BEGIN
              GETDERIVES:
              FOR K_1 STEP 1 UNTIL NEQS DO BEGIN
                                   VALUE[DYPTR[K]]_INT(DY[K]);
                                   VALUE[YPTR[K]]_INT(Y[K]);
                                           END;
              FOR K_1 STEP 1 UNTIL NEQS DO BEGIN
                                   PUSH(DYPTR[K]);
                                   PUSH(INT(T));
                                   ARRBLT(P[I+1],P[ACTUALSBASE],NACTUALS);
                  "NACTUALS=0 UNLESS WE ARE COMPUTING AN INTEGRAL"
                                   I_I+NACTUALS;
                                   NARGS_NACTUALS+1;
                  
                                   DOFUNC;
 
                                   DY[K]_REL(P[I]);
                                   I_I-1;

                                           END;
              GOTO ALPHA;
              END


ELSE IF KSW=1 THEN BEGIN
         DATUM(FVALITM)[FVALJ,1]_T;
         FOR K_1 STEP 1 UNTIL NEQS DO BEGIN DATUM(FVALITM)[FVALJ,K+K]_Y[K]; DATUM(FVALITM)[FVALJ,K+K+1]_DY[K]; END;
        IF (FVALJ_FVALJ+1)>NPTS THEN GOTO ENDDEQ ELSE T1_MV[FVALJ,1];
                   END;
COMMENT CHECK ERRORS, RESET TOL IF NEEDED;

IF KSW=0 THEN 
IF ERRFAC>.5 THEN BEGIN SETFORMAT(0,6); OUTSCR("PASSING SINGULARITY NEAR "&CVF(T));
                       T_T+AMINSTEP; IF ABS(T-T1)<AMINSTEP THEN T1_T;
                       GOTO GETDERIVES    END
            ELSE BEGIN ERRFAC_ERRFAC*10; OUTSCR("TOLERANCE VIOLATED."); END
         ELSE IF ERRFAC>DEQRELERR THEN ERRFAC_ERRFAC/1.258926;
"1.258926... = THE TENTH ROOT OF 10, SO WE'RE A LITTLE AFRAID TO DECREASE ERRFAC TOO SOON AFTER AN INCREASE."
FOR K_1 STEP 1 UNTIL NEQS DO TOL[K]_ERRFAC*(IF (R_ABS Y[K]) LEQ .0001 THEN .0001 ELSE R);

GOTO ALPHA;

ENDDEQ:
DELETE(YPTRITM);
FVALJ_0; COMMENT RESET TO PROTECT DELAY-HANDLING CODE IN DOFUNC!;
RETURN(FVALITM)

END "DEQLOOP"
END "DEQ";
PROCEDURE DEQSTUFF(INTEGER Y);
BEGIN
COMMENT  LOGIC FOR SETTING UP TO INTEGRATE.
         Y = INDEX TO P OF FCT TOKEN FOR "INTEGRATE"
         ALL ARGUMENTS ARE ON THE P STACK, NARGS IS SET .
;
REAL T;
INTEGER L,PBASE;

L_P[I];
NEQS_I-1-(PBASE_Y);

BEGIN "DEQALLOC"
SAFE INTEGER ARRAY DYPTR[1:NEQS], YPTR[1:NEQS];
SAFE REAL ARRAY Y[1:NEQS], DY[1:NEQS], TOL[1:NEQS];
SAFE REAL ARRAY DATA[1:1,1:1];

DATA[1,1]_REL(VALUE[L]);
DEQSETUP(Y,TOL,YPTR,DYPTR,T,PBASE);
I_PBASE;
ITMV_CVI(VALUE[L]);
L_UPUTANS(L, CVN( IF TYPE[L]=MATRIX THEN DEQ(YPTR,DYPTR,DATUM(ITMV),Y,DY,TOL,T)  
                                       ELSE DEQ(YPTR,DYPTR,DATA,Y,DY,TOL,T) ), MATRIX);
P[I]_L;     "A TEMP IS SHARED WITHIN DOFUNC!  MUST NOT SAVE LOC OF P[I] HERE!!"
END "DEQALLOC";
END "DEQSTUFF";




INTERNAL PROCEDURE DOFUNC;
COMMENT
        FUNCTION PROCESSOR

        THE ARGUMENTS COME ON THE P STACK AS:
        ...FUNC A1 A2 ... AN.   NARGS MUST BE SET OK
        UPON ENTRY.
        IF VALSW =TRUE THE ARGS ARE JUST REAL VALUES (EXCEPT MATRICES ARE ALWAYS SYMTAB INDICES), OTHER-
        WISE THEY ARE SYMTAB INDEXES, EXCEPT FUNC IS ALWAYS
        A SYMTAB INDEX.

        MOREOVER, IF VALSW=TRUE THEN DOFUNC IS TO DELIVER A FLT PT
        SCALAR RESULT AND FREE THE ARGS + FUNC
        -- JUST  TAKE THEM OFF OF P.  
                  
        IF THIS IS IMPOSSIBLE, SET VALSW TO FALSE AND DO
        IT THAT WAY  (LIKE FOR POINTS,  ETC, WHICH USE UPUTANS),
        BUT INSTEAD WE MERELY DECLARE AN ERROR!
     
        VALSW=FALSE IF DOFUNC IS TO RETURN A SYMTAB INDEX
        OF AN ENTRY WITH THE APPROPRIATE TYPE AND VALUE.  IN
        THIS CASE THE P STACK IS TO BE CLEARED OF THE
        FUNC AND ARGS ALSO. BUT NOW WE HAVE TO FREET THEM.

	FOR A MATRIX SUBSCRIPT, IF THE TYPE OF THE
	"FUNCTION" IS UNKNOWN, SO THAT IT IS A NEW
	MATRIX, THEN VALSW MUST BE FALSE, INDICATING
	A CALL FROM PROCESS RATHER THAN RECURSIVELY,
	FOR EXAMPLE.

        THE RESULT VALUE OR SYMTAB INDEX IS RETURNED ON THE 
        STACK P AFTER CLEARING IT.

;

BEGIN
DEFINE READFCTNO="24";
LABEL A1,A5,START,SUBSCRIPT,EXIT;
INTEGER X,Y,I1,X1,Y1,TX,TY;
SAFE INTEGER ARRAY ITEMVAR ITM;
FUNCX_P[Y_I-NARGS];
X1_P[Y+1];  Y1_P[Y+2];

START:
IF (I1_-TYPE[FUNCX]) GEQ 0 THEN BEGIN
   IF NARGS NEQ ABS(X_VALUE[FUNCX]) THEN 
      IF I1 NEQ READFCTNO THEN ERROR("INCORRECT NUMBER OR TYPE OF ARGUMENTS");
   GOTO A1    END;

IF (I1_-I1) NEQ UNKNOWN THEN GOTO A5;

      
IF (FF_NAME[FUNCX])="." THEN BEGIN DEEPDIFF(FF); GOTO START END;

IF FUNCX=IGRATEOP THEN  BEGIN  "USEDEQSTUFF" DEQSTUFF(Y); RETURN END "USEDEQSTUFF";


IF FUNCX=LLOKUPOP THEN BEGIN "MLOOKUP"
   COMMENT X1=REAL ARGUMENT IF VALSW IS TRUE, ELSE SYMTAB INDEX.
           Y1=SYMTAB INDEX OF MATRIX (HOLDING ITEM # WITH MATRIX DATUM).
           WHEN LOOKUP IS CALLED FROM A FCT BODY, VALSW IS
          NECESSARILY TRUE.  RETURN INTERPOLATED LOOKED-UP VALUE
          FROM SECOND COL OF Y1-MATRIX AS SELECTED BY BRACKETING
          X1 IN THE FIRST-COLUMN VALUES;

  REAL S,T,Z;
  INTEGER H,B;
  SAFE REAL ARRAY ITEMVAR ITMV;

Z_IF VALSW THEN REL(X1) ELSE REL(VALUE[X1]);
ITMV_CVI(VALUE[Y1]);
X_H_ROWSIZE("DATUM(ITMV)");
B_1;

WHILE H GEQ B DO BEGIN
                 I1_(B+H)%2;
                 IF Z LEQ DATUM(ITMV)[I1,1] THEN H_I1-1 ELSE B_I1+1
                 END;
I_Y;
IF B<2 THEN P[I]_INT("DATUM(ITMV)[1,2]") ELSE
IF B>X THEN P[I]_INT("DATUM(ITMV)[X,2]") ELSE
P[I]_INT("(S_DATUM(ITMV)[B-1,2])+((Z-(T_DATUM(ITMV)[B-1,1]))/(DATUM(ITMV)[B,1]-T))*(DATUM(ITMV)[B,2]-S)");
IF NOT VALSW THEN P[I]_BPUTANS(X1,Y1,P[I],SCALAR,0);
RETURN
                     END "MLOOKUP";

COMMENT  WE COULD SEE IF .F.X(X,...) EXISTS.  IF SO WE MAY SOLVE A DIFFEQ
         TO GET F AT ARGS.;

COMMENT  F IS UNKNOWN. - IT MUST BE A NEW MATRIX.;

GOTO SUBSCRIPT;


COMMENT THE NAME IS NOT SPECIAL.  IT MUST BE AN
ARRAY NAME OR A DECLARED FUNCTION NAME;

A5:        IF I1=FUNCTION OR I1=INITIAL THEN  
BEGIN
  BEGIN "INTERPRET"


INTEGER M,N;
REAL S,H;
REAL FS,FH,FM,ROOTSTEP;


SIMPLE PROCEDURE EVALTREE;
BEGIN
INTEGER K;

FOR K_1 STEP 1 UNTIL N DO IF A[M+K]=TEMP1 THEN 
        BEGIN PUSH(P[Y+K]); RETURN END;
PUSH(VALUE[TEMP1])
END "EVALTREE";


RECURSIVE  PROCEDURE CALCTREE(INTEGER J);
BEGIN
LABEL GETRESULT,MATCHED,DELAYED,NODELAY;
INTEGER K;


IF (K_NODE[J])=FUNCTIONF THEN BEGIN "FCTOP"
                           TEMP1_NODE[J+2];
                           FOR K_1 STEP 1 UNTIL N DO 
                           IF A[M+K]=TEMP1 THEN BEGIN TEMP1_P[Y+K]; DONE END;
                           K_TEMP1;

                          COMMENT HERE WE CHECK FOR AND HANDLE
                                  SUM(I,A,B,E) OR INTEGRAL(X,A,B,E);

                          IF K=INTEGRALOP OR K=SUMOP  THEN BEGIN "SUMORINT"
                          SUMSW_K;
                          K_NODE[J+1];
                          J_NODE[K];
                          PUSH(VALUE[J]);PUSH(TYPE[J]);
                          TYPE[J]_SCALAR;

                          K_NODE[K+1];
                          TEMP1_NODE[K];
                          IF TEMP1<0 THEN CALCTREE(-TEMP1)
                                      ELSE EVALTREE;
                         VALUE[J]_P[I];
                         I_I-1;

                          K_NODE[K+1];
                          TEMP1_NODE[K];
                          IF TEMP1<0 THEN CALCTREE(-TEMP1)
                                      ELSE EVALTREE;
                         H_REL(P[I]); I_I-1;

                         S_0;
                         X_VALUE[J];
                         K_NODE[K+1];

                         IF SUMSW=INTEGRALOP THEN BEGIN
                         COMMENT  SET UP INITIAL TEMPH(A)=0;
                         COMMENT SET UP TEMPDH(X)=E(X);
                                                 X_IDX[TEMPDH];
                                                 NODE[NODE[X]+1]_NODE[K];
                                                 X_NODE[X+1];
                                                 ARRBLT(A[X+1],A[M],14);
                                                 A[X]_A[X+1]+1;
                                                 A[X+1]_J;
                                                 NACTUALS_N;
                                                 ACTUALSBASE_Y+1;

                        COMMENT CALL INTEGRATE(TEMPDH DIFF X, B);
                                                 PUSH(IGRATEOP);
                                                 PUSH(TEMPDH);
                                                 PUSH(UPUTANS(TEMPH,INT(H),SCALAR));
                                                 ISW_1;
                                                 STACK(M); STACK(NARGS); STACK(Y); STACK(VALSW);
                                                 NARGS_2;
                                                 DOFUNC;
                        COMMENT IF WE BLOW UP WHILE THE INTEGRAND
                                IS SHARED, WE'RE IN TROUBLE!;


                                                 UNSTACK(VALSW); UNSTACK(Y); UNSTACK(NARGS); UNSTACK(M);
                                                 N_A[M]; IF N>NARGS THEN N_NARGS;
                                                 ISW_0;
                                                 NACTUALS_0;
                       COMMENT PICK UP THE ANSWER IN S;
                                                 ITM_CVI(VALUE[P[I]]);
                                                 S_REL("DATUM(ITM)[1,2]");
                                                 FREET(P[I]); I_I-1;
                                                 NODE[NODE[IDX[TEMPDH]]+1]_ZERO;
                                                 END

                    ELSE WHILE REL(X) LEQ H DO BEGIN
                          TEMP1_NODE[K];
                          IF TEMP1<0 THEN BEGIN
                                          STACK(S);STACK(H);STACK(X);
                                          CALCTREE(-TEMP1) ;
                                         UNSTACK(X);UNSTACK(H);UNSTACK(S);
                                          END
                                     ELSE EVALTREE;
                          S_S+REL(P[I]); I_I-1;
                          VALUE[J]_X_INT("REL(X)+1.");
                                                 END;

                         TYPE[J]_P[I];
                         VALUE[J]_P[I_I-1];
                         P[I]_INT(S);
                         GOTO GETRESULT
                                                 END "SUMORINT"

ELSE IF K=ROOTOP THEN BEGIN "ROOTF"
DEFINE NOROOT="'400000000001";

LABEL ALPHA,NEWINTERVAL,FINISH,ROOTLESS;


REAL SIMPLE PROCEDURE GETVAL;
BEGIN
     IF TEMP1<0 THEN BEGIN
                     STACK(S);STACK(H);STACK(X);
                    CALCTREE(-TEMP1) ;
                   UNSTACK(X);UNSTACK(H);UNSTACK(S);
                   END
             ELSE EVALTREE;
                       I_I-1;
RETURN(REL(P[I+1])) 
END "GETVAL";


                          K_NODE[J+1];
                          J_NODE[K];
                          PUSH(VALUE[J]);PUSH(TYPE[J]);
                          TYPE[J]_SCALAR;

                          K_NODE[K+1];
                          TEMP1_NODE[K];
                         VALUE[J]_INT(S_GETVAL);

                          K_NODE[K+1];
                          TEMP1_NODE[K];
                         H_GETVAL;

                         K_NODE[K+1];

        ROOTSTEP_.01*(H-S);
        IF ROOTSTEP<0 THEN BEGIN OUTSTL("NULL INTERVAL "); GOTO ROOTLESS END;
NEWINTERVAL:
TEMP1_NODE[K];
FS_GETVAL;
TEMP1_NODE[K];
VALUE[J]_INT(H); FH_GETVAL;

ALPHA:
X_INT("((S+H)/2)");

IF NOT(S<REL(X)<H) THEN IF FS*FH>0 THEN GOTO ROOTLESS ELSE GOTO FINISH;
VALUE[J]_X; TEMP1_NODE[K]; FM_GETVAL;
IF FS*FM LEQ 0 THEN BEGIN H_REL(X); FH_FM; GOTO ALPHA END;
IF FH*FM LEQ 0 THEN BEGIN S_REL(X); FS_FM; GOTO ALPHA END;
S_S+ROOTSTEP; H_H-ROOTSTEP; IF S < H THEN BEGIN VALUE[J]_INT(S); GOTO NEWINTERVAL END;
ROOTLESS:X_NOROOT; OUTSCR("NOROOT");

FINISH:  COMMENT ANSWER IS X.  X = -INFINITY IF NO ROOT WAS
                 FOUND.;


                         TYPE[J]_P[I];
                         VALUE[J]_P[I_I-1];
                         P[I]_X;
                         GOTO GETRESULT
END "ROOTF";

IF K=EVALOP THEN BEGIN "SUBST"
   COMMENT EVAL(X,E,G)=G WITH E SUBSTITUTED FOR G.;
                          K_NODE[J+1];
                          J_NODE[K];
                          PUSH(VALUE[J]);PUSH(TYPE[J]);
                          TYPE[J]_SCALAR;

                          K_NODE[K+1];
                          TEMP1_NODE[K];
                          IF TEMP1<0 THEN CALCTREE(-TEMP1)
                                      ELSE EVALTREE;
                         VALUE[J]_P[I];
                         I_I-1;

                          K_NODE[K+1];
                          TEMP1_NODE[K];
                          IF TEMP1<0 THEN CALCTREE(-TEMP1)
                                      ELSE EVALTREE;
                         X_P[I]; I_I-1;
                         TYPE[J]_P[I];
                         VALUE[J]_P[I_I-1];
                         P[I]_X;
                         GOTO GETRESULT
                   END "SUBST";


                                IF TYPE[K]=INITIAL THEN BEGIN
IF (TEMP1_NODE[NODE[J+1]])<0 THEN CALCTREE(-TEMP1) ELSE EVALTREE;
IF FVALJ LEQ 1 THEN GOTO NODELAY;
FOR TEMP1_1 STEP 1 UNTIL NEQS DO IF K=DATUM(YPTRITM)[TEMP1] THEN DONE;
FOR TEMP2_FVALJ-1 STEP -1 UNTIL 1 DO IF REL(P[I]) GEQ DATUM(FVALITM)[TEMP2,1]  THEN GOTO DELAYED;
P[I]_INT("DATUM(FVALITM)[1,TEMP1+TEMP1]");
        GOTO GETRESULT;

DELAYED:
IF TEMP2=FVALJ-1 THEN NODELAY:BEGIN COMMENT NOT DELAYED!;
                            P[I]_VALUE[K]; GOTO GETRESULT END;
COMMENT LINEAR INTERPOLATE TO GET DELAYED VALUE.;
P[I]_0 XOR (DATUM(FVALITM)[TEMP2,K_TEMP1+TEMP1]+
           (REL(P[I])-DATUM(FVALITM)[TEMP2,1])/
           (DATUM(FVALITM)[TEMP2+1,1]-DATUM(FVALITM)[TEMP2,1])*
           (DATUM(FVALITM)[TEMP2+1,K]-DATUM(FVALITM)[TEMP2,K]));
GOTO GETRESULT;

COMMENT INTERPRET AN ORDINARY FUNCTION CALL EXPRESSION HERE;
                                                       END;

                                PUSH(K);
                                K_0;
                                WHILE (J_NODE[J+1]) NEQ 0 DO
                                     BEGIN
                                     TEMP1_NODE[J];
                                     IF TEMP1<0 THEN  CALCTREE(-TEMP1)
                                                ELSE 
BEGIN
FOR TEMP2_1 STEP 1 UNTIL N DO
    IF A[M+TEMP2]=TEMP1 THEN BEGIN PUSH(P[Y+TEMP2]); GOTO MATCHED END;
IF TYPE[TEMP1]=MATRIX THEN PUSH(TEMP1) ELSE PUSH(VALUE[TEMP1]);
MATCHED: END;
                                     K_K+1;
                                     END;

                                IF TYPE[P[V_I-K]]=MATRIX THEN
                                 BEGIN
                                 IF K=1 THEN BEGIN Y1_INT(1.0);X1_P[I] END
                                         ELSE BEGIN Y1_P[I];X1_P[I-1] END;      
                                 I_V;
                                 ITM_CVI(VALUE[P[I]]);
                                 P[I]_DATUM(ITM)[REL(X1),REL(Y1)]
                                 END
                                 ELSE BEGIN
                                 STACK(M);STACK(NARGS);STACK(Y);STACK(VALSW);
                                 VALSW_TRUE; NARGS_K;
                                 DOFUNC;
                                 UNSTACK(VALSW);UNSTACK(Y);UNSTACK(NARGS);UNSTACK(M);

                                N_A[M]; IF N>NARGS THEN N_NARGS;
                                      END;

                                GOTO GETRESULT;
                          END "FCTOP";

TEMP1_NODE[J+1];
IF TEMP1<0 THEN CALCTREE(-TEMP1) ELSE EVALTREE;

IF K>ASSIGNOP THEN BEGIN
IF K=IFOP THEN BEGIN
                TEMP1_NODE[NODE[J+2]+1+(IF REL(P[I]) = 0 THEN 1 ELSE 0)];
                I_I-1;
                IF TEMP1<0 THEN CALCTREE(-TEMP1) ELSE EVALTREE;
                GOTO GETRESULT
               END;

IF K=UMINUS THEN BEGIN P[I]_INT("-REL(P[I])"); GOTO GETRESULT END;
IF K=ABSUOP THEN P[I]_INT("ABS REL(P[I])");
COMMENT IF K=UPLUS THEN GOTO GETRESULT; GOTO GETRESULT;
END;

    TEMP1_NODE[J+2];
          IF TEMP1<0 THEN CALCTREE(-TEMP1) ELSE EVALTREE;

IF K=ASSIGNOP THEN BEGIN
                   IF (K_NODE[J+1])<0 THEN ERROR("BAD ASSIGN IN FCT");
                   P[I-1]_VALUE[K]_P[I];
                   I_I-1;
                   GOTO GETRESULT;
                   END;

H_REL(P[I]); I_I-1; S_REL(P[I]);
P[I]_INT(" CASE K OF (
     0.0,0., 0., S^H, S*H, S/H, S+H, S-H,
     IF S=H THEN 1. ELSE 0.,
     IF S<H THEN 1. ELSE 0.,
     IF S LEQ H THEN 1. ELSE 0.,
     IF S GEQ H THEN 1. ELSE 0.,
     IF S>H THEN 1. ELSE 0.,
     IF S=0. THEN 1. ELSE 0.,
     IF S NEQ 0. AND H NEQ 0. THEN 1. ELSE 0.,
     IF S NEQ 0. OR H NEQ 0. THEN 1. ELSE 0.
                      )"     );

GETRESULT:
END "CALCTREE";


M_NODE[IDX[FUNCX]+1];
N_IF M<0 THEN 0 ELSE A[M];
IF N>NARGS THEN N_NARGS;

IF NOT VALSW THEN FOR I1_Y+1 STEP 1 UNTIL I DO  IF (TEMP1_TYPE[V_P[I1]])=SCALAR OR TEMP1=CONSTANT THEN
             BEGIN P[I1]_VALUE[V]; FREET(V)  END;

CALCTREE(NODE[IDX[FUNCX]]);

POP(I1)

END "INTERPRET";

COMMENT  - SETTING THE "VALUE" OF A FUNCTION IS NICE
           FOR RECURSIVE FUNCTIONS(SOMETIMES) AND FOR
           DIFFERENTIAL EQUATIONS.
;
VALUE[P[I_Y]]_I1;

COMMENT SET X<0 SO THAT THE FREETS AT EXIT WONT HAPPEN!;
X_-1;

GOTO EXIT;
END;


IF NOT(TYPE[FUNCX] = MATRIX ) THEN TYPEFORMERROR(FUNCX);

COMMENT MATRIX SUBSCRIPT HANDLER;

SUBSCRIPT:
	IF VALSW OR NOT(NUMBER(TYPE[X1])) THEN TYPEFORMERROR(FUNCX);

           I_Y;
           Y_REL(VALUE[X1]);
           START!CODE MOVE 1,Y; HRLM 1,X; END;
           IF NARGS=1 THEN Y_1 ELSE Y_REL(VALUE[Y1]);
           START!CODE MOVE 1,Y; HRRM 1,X; END;
COMMENT
        RETURN INDEX OF SYMTABENTRY WITH
        NAME = TEMPNAME
        VALUE = X
        TYPE = SUBSCR
        IDX = SYMTAB INDEX OF MATRIX VAR
;
COMMENT NOTE FUNCX IS NOT A TEMP AND HENCE WILL NOT
         BE DELETED WHEN HANDED TO BPUTANS IN PLACE
        OF THE NON-EXISTENT Y1 FOR WANT OF 
        ANYTHING BETTER!;

           P[I]_(BPUTANS(X1,IF NARGS=2 THEN Y1 ELSE FUNCX,X,SUBSCR,FUNCX));
           RETURN;


A1:
    I_Y;
    IF NOT VALSW THEN BEGIN IF X<0 THEN VALSW_TRUE
                            COMMENT IF VALSW MUST BE OFF, THEN A                     
                                    SYMTABENTRY WILL BE RETURNED, SO LIE ABOUT VALSW TO FOIL THE
                                    TOKEN GENERATION BELOW!
                                    X1 AND Y1 ARE TOKENS.  THEY WILL BE
                                    FREETED IN THE ROUTINES WHICH USE THEM.;
                            ELSE BEGIN
                                 COMMENT A SCALAR REAL IS TO BE THE 
                                         RESULT, BUT TOKENS HAVE BEEN SENT IN.
                                         THEREFORE GET NUMBERS IN X1 AND Y1
                                        (EXCEPT WHEN X1 IS A MATRIX IDX ARG TO NROWS OR NCOLS.);
                         IF TYPE[X1] NEQ MATRIX THEN 
                            BEGIN    TX_VALUE[X1]; TX SWAP X1 END ELSE TX_X1;
                            IF NARGS=2 THEN BEGIN TY_VALUE[Y1]; TY SWAP Y1 END
                                END
                      END
                 ELSE IF X<0 THEN ERROR("IMPOSSIBLE TO COMPLY");

        I1_INT("CASE I1 OF
                (
                        EXP(REL(X1)),
                        LOG(REL(X1)),
                        .4342945*LOG(REL(X1)),
                        SQRT(REL(X1)),
                        SIN(REL(X1)),
                        SIND(REL(X1)),
                        COS(REL(X1)),
                        COSD(REL(X1)),
                        SINH(REL(X1)),
                        COSH(REL(X1)),
                        TANH(REL(X1)),
                        ASIN(REL(X1)),
                        ACOS(REL(X1)),
                        ATAN(REL(X1)),
                        RAN(REL(X1)),
                        LOGGAMMA(REL(X1)),
                        (I1_REL(X1)),
                        ATAN2(REL(X1),REL(Y1)),
                        (REL(X1) MOD REL(Y1)),
                        ROWNO(VALUE[X1]),
                        COLNO(VALUE[X1]),
                        REL(""POINTS(X1,Y1)""),
                        REL(""INTERPOLATE(X1,Y1)""),
                        REL(""SORT(X1,Y1)""),
                        REL(""READ(X1,Y1)""), 
                        REL(""DIAG(X1)""),
                        REL(""CURVEMATS(X1,0)""), 
                        REL(""CURVEMATS(X1,1)""),
                        REL(""HISTO(X1)""),
                        REL(""SMOOTH(X1)""),
                        REL(""SVDM(X1)""),
                        REL(""COMPRESS(X1)""),
                        TYPEOUT(REL(X1)),
                        REL(""CROSS(X1,Y1)""),
                        REL(""MESH(X1,Y1)""),
                        REL(""ROTATE(X1,Y1)"")
                                   )    ");


EXIT:
       IF NOT VALSW THEN BEGIN IF X>0 THEN BEGIN FREET(TX); IF NARGS=2 THEN FREET(TY) END;
                               V_NEWTEMP; VALUE[V]_I1; TYPE[V]_SCALAR; P[I]_V END
       ELSE  P[I]_I1;
FUNCX_0;

END;
INTERNAL SIMPLE PROCEDURE DOVECTORF(INTEGER F,C,H; SAFE REAL ARRAY M,FVAL);

COMMENT  F=IDX OF FUNCTION.
         C=NUMBER OF COLS OF M TO USE AS ARGS OF F.
         H=INDEX TO LAST FULL CELL IN THE RESULT ARRAY FVAL.
         M=ARRAY WHOSE ROWS ARE ARGS TO F.
         FVAL=ARRAY IN WHICH THE VECTOR OF RESULT VALUES ARE
              TO BE PLACED, STARTING AT H+1.
;
BEGIN
STRING S;
INTEGER T,I1,J,N;
LABEL START, JAMARGS;

N_ROWSIZE(M);

START:
IF TYPE[F]=FUNCTION THEN 
                    BEGIN 
IF A[NODE[IDX[F]+1]] NEQ C THEN OUTSCR("# ACTUALS NEQ # FORMALS FOR "&NAME[F]);
           JAMARGS: NARGS_C;
                    VALSW_TRUE;
                    PUSH(F);

                    FOR I1_1 STEP 1 UNTIL N DO BEGIN
                    FOR J_1 STEP 1 UNTIL C DO P[I_I+1]_INT("M[I1,J]");

                    DOFUNC;
                    FVAL[H+I1]_REL(P[I]);    P[I]_F;
                                              END;
                     I_I-1;
                     NARGS_1;
                    RETURN
                    END;
S_NAME[F];
IF S="." THEN BEGIN DEEPDIFF(S); GOTO START END;

COMMENT  SEE IF F IS DEFINED BY A DIFFEQ SYSTEM, AND IF SO
         SOLVE TO GET FVAL;
COMMENT  F IS NOT OF TYPE FUNCTION(I.E. IS UNDEFINED) AND
         HAS NO DERIVATIVE KNOWN AND IS NOT THE DERIVATIVE
         OF A KNOWN FUNCTION.
         THUS F MUST BE A SYSTEM FUNCTION (E.G. SIN) IF
         F HAS ANY CHANCE AT ALL! -- WE'LL LET DOFUNC FIND OUT!
;
GOTO JAMARGS;

END "DOVECTORF";
PROCEDURE DEQVECTORF(INTEGER J; SAFE REAL ARRAY FVAL);
BEGIN
      COMMENT A[DI] HOLDS (F DIFF T, G DIFF T, ... ).
              THERE ARE ADX ENTRIES.

              FITM[1]=SYMTAB INDEX OF DATA MESH VALUE MATRIX (USE 1ST COL ONLY).
              FITF=ARRAY OF FCT SYMTAB INDICES=THE MODEL FCTS.

              THERE ARE ADX EQUATIONS.  COPY INTO THE P STACK,
               CALL DEQSETUP AND DEQ AND COMPUTE THE SOLUTIONS.
               PUT THE SOLUTION FOR F IN FVAL STARTING AT J+1, AND RETURN;

INTEGER PBASE,NM;

SAFE INTEGER ARRAY DYPTR[1:ADX],
                   YPTR[1:ADX];

SAFE REAL ARRAY Y[1:ADX],
                DY[1:ADX],
                TOL[1:ADX];
REAL T;

PBASE_I;
ARRBLT(P[I+1],A[DI],ADX);
I_I+ADX;
ITMV_CVI(VALUE[FITM[1]]);
NM_ROWSIZE("DATUM(ITMV)");

NEQS_ADX;
DEQSETUP(Y,TOL,YPTR,DYPTR,T,PBASE);
I_PBASE;
ITMV_DEQ(YPTR,DYPTR,DATUM(ITMV),Y,DY,TOL,T);

FOR TEMP1_1 STEP 1 UNTIL FITN DO BEGIN
                                    TEMP2_1;
                                 IF TYPE[PBASE_FITF[TEMP1]]=INITIAL THEN BEGIN
                                    WHILE YPTR[TEMP2] NEQ PBASE DO TEMP2_TEMP2+1;
                                      TEMP2_TEMP2+TEMP2;
                                 END ELSE BEGIN
                                     WHILE DYPTR[TEMP2] NEQ PBASE DO TEMP2_TEMP2+1;
                                     TEMP2_TEMP2+TEMP2+1;
                                          END;
                                     FOR PBASE_1 STEP 1 UNTIL NM DO
                                              FVAL[J+PBASE]_DATUM(ITMV)[PBASE,TEMP2];
                                    J_J+NM;
                                    END;

DELETE(ITMV);
END "DEQVECTORF";
INTERNAL PROCEDURE FITDRIVER(SAFE INTEGER ARRAY PARM);

BEGIN
STRING S;


INTEGER I,J,T,K,MR,
        NPARMS,NPTS,C,KSW,
        NCONST, MAXITR,
        NITER,
        CONVSW,
        SEARCHCT;

REAL TOLSOS,
     FAC,
     BSOSQ,
     CLOW, 
     CHIGH,
     CSTEP;

LABEL NEXT,GETIN,DONEIN;

SAFE INTEGER ARRAY MRSIZE[1:FITN];

SIMPLE PROCEDURE OUTVEC(SAFE REAL ARRAY V; INTEGER VSIZE; STRING TITLE);
BEGIN  INTEGER I;
       IF VSIZE>0 THEN OUTSTL(TITLE);
       FOR I_1 STEP 1 UNTIL VSIZE DO
           OUTSTL(CRLF&"     "&CVG(V[I]));
       OUTSTL(CRLF);
END;


COMMENT **************  GET NPTS,NPARMS;

NPARMS_SIZE(PARM);
NPTS_0;
FOR I_1 STEP 1 UNTIL FITN DO BEGIN
                          IF TYPE[FITM[I]] NEQ MATRIX THEN TYPEFORMERROR(FITM[I]);
                          R_CVI(VALUE[FITM[I]]);
                          NPTS_NPTS+(MRSIZE[I]_ROWSIZE("DATUM(R)"));
                          END;

COMMENT  OBTAIN CONSTRAINT ARRAY IDX, MAXITR, ETC. VIA DIALOG.
;

ADX_0;

IF TYPE[FITF[1]]=INITIAL OR NAME[FITF[1]]="."  THEN BEGIN 
          IF FITN*MRSIZE[1] NEQ NPTS THEN ERROR("MODELS MUST BE FIT TO DATA WITH A COMMON RANGE!");
                        NEWNODE(DI,A);
                        ADX_DI-1;
 
                           OUTSTL(CRLF&"TYPE DERIVATIVE NAME(S) OF DEQ SYSTEM FOR MODEL"&CRLF);
                            B_INPUT(6,1)&'01&B;
                   GETIN:  GETTOKEN(I,J); IF I=ID THEN BEGIN
                           GETTOKEN(I,K); IF I=DIFFOP THEN BEGIN
                           GETTOKEN(I,K); IF I=ID THEN BEGIN
                            A[ADX_ADX+1]_SYMTABENTRY(MAKEDIFFNAME(J,K));
                           GETTOKEN(I,J);
                           IF I=COMMA THEN GOTO GETIN ELSE
                           IF I = CR THEN GOTO DONEIN;
                           END END END;
                           TYPEFORMERROR(-1);
                  DONEIN:
                          ADX_ADX-DI+1;
                   END;

OUTSTL(CRLF&"CONSTRAINTS NAME=(NONE)? ");
S_INPUT(6,1);
IF LENGTH(S)=0 THEN BEGIN NCONST_0; GOTO NEXT END;
R_CVI(VALUE[T_SYMTABENTRY(S)]);
IF TYPE[T] NEQ CONSTRAINTS THEN TYPEFORMERROR(T);
NCONST_ROWSIZE("DATUM(R)")-1;

NEXT:OUTSTL("MAX NUMBER OF ITERATIONS=(3)? ");
S_INPUT(6,1);
MAXITR_IF LENGTH(S)=0 THEN 3 ELSE INTSCAN(S,T);


OUTSTL("CONVERGENCE FACTOR FOR SUM OF SQUARES =(.001)?");
S_INPUT(6,1);
TOLSOS_IF LENGTH(S)=0 THEN .001 ELSE REALSCAN(S,T);


T_IF NPARMS>NCONST THEN NPARMS ELSE NCONST;

BEGIN "FITSTUFF"

SAFE REAL ARRAY PARAM[1:NPARMS],
           WEIGHT[1:NPTS],
           Y[1:NPTS],
           FVAL[1:NPTS],
           DFIDPJ[1:NPTS*NPARMS],
           PTPDIA[1:NPARMS],
           E[1:NPARMS], 
           LAGRANGE[1:NCONST],
           TLAGRANGE[1:NCONST];

SAFE REAL ARRAY CTDIAG[1:T],
                CP[1:NCONST],
                XOLD[1:T],
                XWORK[1:T],
                CWORK[1:T],
                XNEW[1:NCONST];


SAFE REAL ARRAY FBEST[1:NPTS],
           PBEST[1:NPARMS],
           PSAVE[1:NPARMS],
           PTP[1:NPARMS,1:NPARMS],
           GRAD[1:NPARMS],
           CBEST[1:NCONST],
           CONSTM[1:NCONST,1:NPARMS],
           CONSTV[1:NCONST],
           CCT[1:NCONST,1:NCONST];

SAFE INTEGER ARRAY CONSTO[1:NCONST];

SAFE INTEGER ARRAY IB[1:NPARMS],
                   ICB[1:NCONST];

SAFE REAL ARRAY DHOLD[1:NPTS];

COMMENT DFIDPJ IS A 1-DIMENSIONAL ARRAY,RATHER THAN 2, SO THAT
        DOVECTORF WILL WORK OK TO FILL IT UP!   ;


LABEL FCOMPUTE,
      CALLLSQ,
      RESETPARMS,
      DOKSW,
      DELTA,
      CORRECT;


SIMPLE PROCEDURE LINEQ(SAFE REAL ARRAY A,C,X; SAFE INTEGER ARRAY B);
BEGIN
COMMENT 
         GIVEN: REAL ARRAYS A[1:N,1:N], C[1:N], X[1:N],
                AND AN INTEGER ARRAY B[1:N].
 
        THIS PROGRAM COMPUTES X_LOWERTRIANGLE[A]*C.
 
 
    A[1:N,1:N]=SYMMETRIC MATRIX TO BE USED AS A MULTIPLIER.
             ONLY THE LOWER TRIANGLE OF A IS USED.  BY
             CONVENTION THE LOWER TRIANGLE OF A HOLDS
             THE INVERSE OF A.
 
   C[1:N]=THE COLUMN VECTOR WHICH WILL BE MULTIPLIED ON THE
          LEFT BY [A INVERSE].  C IS NOT DISTURBED BY THIS
          PROCEDURE.
 
   X[1:N]=THE RESULT OF THE ABOVE MULTIPLICATION.
 
   B[1:N]=A VECTOR OF "ACTIVITY" BITS.  
;
 
INTEGER I,N,J;
 
N_SIZE(B);
FOR I_1 STEP 1 UNTIL N DO X[I]_0;
FOR I_1 STEP 1 UNTIL N DO
IF B[I] NEQ 0 THEN BEGIN 
   X[I]_X[I]+A[I,I]*C[I];
   FOR J_1 STEP 1 UNTIL I-1 DO IF B[J] NEQ 0 THEN BEGIN X[I]_X[I]+A[I,J]*C[J]; X[J]_X[J]+A[I,J]*C[I] END;
                   END;
END "LINEQ";


COMMENT "*U****************************************************************************";

SIMPLE PROCEDURE MATINV(SAFE REAL ARRAY A, D; REAL T; INTEGER MSW; SAFE INTEGER ARRAY B);
BEGIN
COMMENT 
          INTEGER MSW
          REAL T
 
          REAL ARRAY A[1:N,1:N], D[1:N]
         INTEGER ARRAY B[1:N]
 
 
   A[1:N,1:N]=THE MATRIX TO BE INVERTED  OR WHOSE CURRENT INVERSE
          IS TO BE AUGMENTED OR DIMINISHED BY ONE ROW & COLUMN. THE
          UPPER TRIANGLE OF 'A', NOT INCLUDING THE MAIN DIAGONAL,
          CONTAINS THE OFF-DIAGONAL ELEMENTS OF THE ORIGINAL MATRIX
          WHICH IS ASSUMED POSITIVE SEMIDEFINITE SYMMETRIC. THE LOWER
          TRIANGLE, INCLUDING THE MAIN DIAGONAL, WILL BECOME THE DESIRED
          INVERSE, UPPER TRIANGLE IS SET BY CALLER.
 
   D[1:N]=THE MAIN DIAGONAL OF THE ORIGINAL MATRIX  SET BY CALLER.
 
   T=THE TOLERANCE ON THE MAIN DIAGONAL OF THE INVERSE.
          IF A[I,I]>1/(T*D[I]) THEN A[I,I] IS SET TO 1/(T*D[I,I]) BEFORE
          THE ITH ROW & COLUMN OF THE INVERSE ARE COMPUTED.
 
   N=THE ORDER OF THE ORIGINAL MATRIX  I.E. NO. OF ELEMENTS IN D.
 
   MSW=A CONTROL VARIABLE. IF MSW=O  THE MATRIX IS INVERTED, EXCEPTING
       THOSE ROWS & COLUMNS FOR WHICH B[I]=0.  IF MSW>0  THE
       MSWTH ROW & COLUMN ARE INCLUDED IN THE CURRENT INVERSE, AND
       B[M] IS SET TO 1.  IF MSW<0, THE -MSWTH ROW & COLUMN ARE
       REMOVED FROM THE CURRENT INVERSE, AND B[-MSW] IS SET TO 0.

  XWORK[1:N] AND CWORK[1:N] ARE WORK-SPACE ARRAYS DECLARED NON-LOCALLY.

       USUALLY, MSW\=0 WILL HAVE SOME EFFECT ON EVERY NUMBER IN
       THE CURRENT INVERSE.
 
   B[1:N]=AN INTEGER VECTOR WITH TWO INTERPRETATIONS:
         IF MSW=0 THEN B[I]=0 DIRECTS MATINV TO IGNORE THE ITH ROW
                & COLUMN IN COMPUTING THE INVERSE.  MANY B'S MAY BE ZERO.
         IF MSW\=0 THEN B[I]=0 WARNS MATINV THAT THE ITH ROW & COLUMN
                  OF THE ORIGINAL MATRIX HAVE NOT BEEN USED IN COMPUTING
                  THE CURRENT INVERSE.
 
  THE INVERSE MATRIX IS COMPUTED, AUGMENTED, OR DIMINISHED BY THE METHOD OF
  PARTITIONING USING THE FOLLOWING RELATION:
 
     LET 'AM' BE A MATRIX, 'AS' A SCALAR,
         'AV' A COLUMN VECTOR AND 'AVT' ITS TRANSPOSE.
     SIMILARLY FOR BM, BS, BV, AND BVT, SUCH THAT
        ^ AM  ^ AV ^ -1    ^ BM  ^ BV ^      
        ^-----^----^     _ ^-----^----^      
        ^ AVT ^ AS ^       ^ BVT ^ BS ^      
     THEN  BS=1/(AVT*(AM^-1)*AV),
           BV=-BS*(AM^-1)*AV, AND
           BM=(AM^-1)+BS*BVT*BV.
;
 
 
 
REAL FTEMP;
INTEGER I,L,K,K1,K2,J,N;
LABEL EXITK;
 
N_SIZE(B);
IF MSW<0 THEN BEGIN "MSWNEG"
         B[K_-MSW]_0;
         FOR I_1 STEP 1 UNTIL N DO IF B[I] NEQ 0 THEN BEGIN
                     FTEMP_(IF I>K THEN A[I,K] ELSE A[K,I])/A[K,K];
                     FOR J_1 STEP 1 UNTIL I DO IF B[J] NEQ 0 THEN 
                                               A[I,J]_A[I,J]-(IF J>K THEN A[J,K] ELSE A[K,J])*FTEMP;
                                                       END;
         RETURN
              END "MSWNEG" ELSE
IF MSW=0 THEN BEGIN I_1; L_N; FOR J_1 STEP 1 UNTIL N DO FOR K_1 STEP 1 UNTIL J DO A[J,K]_0 END ELSE I_L_MSW;
 
K1_I; K2_L;
FOR K_K1 STEP 1 UNTIL K2 DO BEGIN "KLOOP"
   IF MSW=0 THEN BEGIN IF B[K]=0 OR D[K]=0 THEN GOTO EXITK; L_K; B[K]_0 END ELSE L_N;
 
COMMENT  ****  MULTIPLY NEW ROW BY OLD INVERSE  ****;
   FOR I_1 STEP 1 UNTIL N DO XWORK[I]_0;
   CWORK[K]_D[K];
   FOR I_1 STEP 1 UNTIL K-1 DO CWORK[I]_A[I,K]; FOR I_K+1 STEP 1 UNTIL L DO CWORK[I]_A[K,I];
   FOR I_1 STEP 1 UNTIL L DO IF B[I] NEQ 0 THEN BEGIN 
       XWORK[I]_XWORK[I]+A[I,I]*CWORK[I];
       FOR J_1 STEP 1 UNTIL I-1 DO IF B[J] NEQ 0 THEN BEGIN XWORK[I]_XWORK[I]+A[I,J]*CWORK[J];
                                                            XWORK[J]_XWORK[J]+A[I,J]*CWORK[I] END;
                                                END;
 
COMMENT  ****  KTH DIAGONAL ELEMENT OF INVERSE  ****;
   FTEMP_D[K]; FOR I_1 STEP 1 UNTIL L DO IF B[I]=1 THEN FTEMP_FTEMP-CWORK[I]*XWORK[I];
   A[K,K]_1/(IF FTEMP>(T*D[K]) THEN FTEMP ELSE T*D[K]);
 
COMMENT  ****   KTH ROW/COLUMN OF INVERSE   ****;
FOR I_1 STEP 1 UNTIL L DO IF B[I] NEQ 0 THEN BEGIN CWORK[I]_-A[K,K]*XWORK[I];
                                                   IF I>K THEN A[I,K]_CWORK[I] ELSE A[K,I]_CWORK[I] END;
 
COMMENT  ****  ADJUST ELEMENTS OF OLD INVERSE  ****;
FOR I_1 STEP 1 UNTIL L DO IF B[I] NEQ 0 THEN FOR J_1 STEP 1 UNTIL I DO 
                                             IF B[J] NEQ 0 THEN A[I,J]_A[I,J]-CWORK[I]*XWORK[J];
B[K]_1;
EXITK:
END "KLOOP"
END "MATINV";

COMMENT ******* START FITSTUFF CODE. ************************************************************;


IF NCONST>0 THEN BEGIN "CONSTRAINTWORK"
LABEL ENDJLOOP;

T_COLSIZE("DATUM(R)");
FOR I_1 STEP 1 UNTIL NCONST DO BEGIN CONSTV[I]_DATUM(R)[I+1,T]; CONSTO[I]_DATUM(R)[I+1,T-1] END;

FOR J_1 STEP 1 UNTIL T-2 DO BEGIN
    C_SYMTABENTRY(ST[INT("DATUM(R)[1,J]")]);
    FOR I_1 STEP 1 UNTIL NPARMS DO 
        IF PARM[I]=C THEN BEGIN
           FOR K_1 STEP 1 UNTIL NCONST DO CONSTM[K,I]_DATUM(R)[K+1,J];
           GOTO ENDJLOOP  END; 

    COMMENT WE MUST "EVAL" COL J AND SUBTRACT OFF THE RHS VECTOR IN V;

    CLOW_REL(VALUE[C]);
    FOR K_1 STEP 1 UNTIL NCONST DO CONSTV[K]_CONSTV[K]-CLOW*DATUM(R)[K+1,J];

    ENDJLOOP:               END;

                 END "CONSTRAINTWORK";

CLOW_.0001;
CHIGH_2000;
CSTEP_10;
KSW_0;
COMMENT GET PARAM VECTOR, INITIALIZE DUMMY IB VECTOR;

OUTSTL(CRLF);
SETFORMAT(20,6);
FOR I_1 STEP 1 UNTIL NPARMS DO BEGIN PARAM[I]_REL(VALUE[PARM[I]]); IB[I]_1 END;

COMMENT GET WEIGHT VECTOR AND VECTOR OF Y VALUES;

T_1;
FOR I_1 STEP 1 UNTIL FITN DO BEGIN
                          MR_MRSIZE[I];
                          R_CVI(VALUE[FITM[I]]);
                          C_COLSIZE("DATUM(R)");
                          FOR J_1 STEP 1 UNTIL MR DO
                              Y[J+T-1]_DATUM(R)[J,C];

                          IF FITW[I]=0 THEN BEGIN
                             FOR J_1 STEP 1 UNTIL MR DO
                                 WEIGHT[T+J-1]_1;
                                         END
                          ELSE BEGIN
                          R_CVI(VALUE[FITW[I]]);
                          IF SIZE("DATUM(R)")<MR THEN TYPEFORMERROR(FITW[I]);
                          ARRBLT(WEIGHT[T],DATUM(R)[1,1],MR);
                               END;
                          T_T+MR;

                          END;


IF NCONST>0 THEN BEGIN ARRBLT(PSAVE[1],PARAM[1],NPARMS); GOTO RESETPARMS END;

FCOMPUTE:
IF KSW=0 AND NOT QUIETSW THEN BEGIN
                              OUTVEC(PARAM,NPARMS,"INITIAL PARAMETER VALUES:");
                              OUTSTL(CRLF);  END;

COMMENT COMPUTE F VALUES;

J_0;
IF ADX>0 THEN DEQVECTORF(0,FVAL) 
ELSE 
FOR I_1 STEP 1 UNTIL FITN DO BEGIN
                          R_CVI(VALUE[FITM[I]]);
                          DOVECTORF(FITF[I],COLSIZE("DATUM(R)")-1,J,DATUM(R),FVAL);
                          J_J+MRSIZE[I]
                          END;

CALLLSQ:
BEGIN "LSQ"
 
COMMENT
NON-LOCAL INTEGER NPTS, NPARMS, NCONST, MAXITR,
                 KSW, CONVSW, NITER
 
NON-LOCAL REAL TOLSOS, CLOW, CHIGH, CSTEP, BSOSQ, FAC
 
NON-LOCAL REAL ARRAY Y[1:NPTS],
                    WEIGHT[1:NPTS],
                    FVAL[1:NPTS],
                    PARAM[1:NPARMS],
                    DFIDPJ[1:NPTS,1:NPARMS],
                    PTPDIA[1:NPARMS],
                    E[1:NPARMS],
                    LAGRANGE[1:NCONST]
 
NON-LOCAL REAL ARRAY FBEST[1:NPTS],
                     PBEST[1:NPARMS],
                     PSAVE[1:NPARMS],
                     PTP[1:NPARMS,1:NPARMS],
                     GRAD[1:NPARMS],
                     CBEST[1:NCONST]
 
NON-LOCAL INTEGER ARRAY IB[1:NPARMS]
 
  THE METHOD CODED HERE WAS PUBLISHED IN THE FOLLOWING ARTICLE
  'NONLINEAR REGRESSION WITH LINEAR CONSTRAINTS', BY R.I.SHRAGER,
  JOURNAL OF THE ASSN. FOR COMPUTING MACHINERY, V 17, NO. 3, JULY 1970.
 
 
 
    KSW=0 IS SET BY THE CALLER TO INDICATE THE BEGINNING OF A NEW CASE.
           THEREAFTER, IT IS SET BY LSQ AS FOLLOWS:
 
        =1 MEANS COMPUTE THE FUNCTION, STORE IT IN FVAL[I],I=1 TO
          NPTS, AND CALL LSQ AGAIN. IF THERE ARE LINEAR
           CONSTRAINTS,  CALL CORECT BEFORE COMPUTING FVAL.
 
        =2 MEANS COMPUTE DFIDPJ[I,J]=THE PARTIAL
          DERIVATIVE OF FVAL[I] WITH RESPECT TO PARAM[J] FOR I=1 TO
          NPTS AND J=1 TO NPARMS, AND CALL LSQ AGAIN.
 
        =3 MEANS LSQ HAS FINISHED, EITHER BECAUSE OF CONVERGENCE
           [CONVSW=1] OR BECAUSE THE MAXIMUM NO. OF ITERATIONS HAS BEEN
           TAKEN [CONVSW=0].
 
    NPTS=NO. OF OBSERVATIONS, SET BY CALLER.
 
    NPARMS=NO. OF PARAMETERS, SET BY CALLER.
 
    NCONST=NO. OF LINEAR CONSTRAINTS, SET BY CALLER.
 
    NITER=NO. OF ITERATIONS TAKEN SO FAR.
 
    MAXITR=NO. OF ITERATIONS MAXIMUM, SET BY CALLER.
          IF MAXITR<0 ONLY THE ERROR ANALYSIS IS PERFORMED.
          SEE PTPDIA AND E BELOW.  THE CURRENT VALUES IN
          PARAM ARE USED.   IF MAXITR=0, LSQ RETURNS
          WITHOUT DOING ANYTHING.
 
          THERE IS NO ERROR ANALYSIS BASED ON PERTURBATIONS
          AVAILABLE CURRENTLY.
 
    CONVSW=1 IF CONVERGENCE HAS OCCURRED, AND =0 OTHERWISE.
 
         CONVERGENCE IS DEFINED AS THE FAILURE OF A GIVEN ITERATION
         TO IMPROVE THE SUM OF SQUARES BY A GIVEN FRACTION, I.E.:
          OLDSUM-NEWSUM<OLDSUM*TOLSOS.
          [(PBSOSQ-BSOSQ) <= (PBSOSQ*TOLSOS)]
 
    EPS=CURRENT VALUE OF FRACTIONAL INCREASE IN THE MAIN DIAGONAL
          OF THE COVARIANCE MATRIX. THIS INCREASE INSURES THE
          INVERTABILITY OF SAID MATRIX, AND AS EPS INCREASES FROM A
          NO. MUCH SMALLER THAN 1 [SAY 10**-4] TO A NO. MUCH LARGER THAN
          1 [SAY 100] THE METHOD LOOKS LESS LIKE GAUSS-NEWTON AND
          MORE LIKE A SHORTENED STEP STEEPEST DESCENT.
          (EPS IS LOCAL TO LSQ.)
 
    CLOW=MINIMUM VALUE FOR EPS, USUALLY 10**-4, SET BY CALLER.
         STABILITY PARAMETER.
 
    CHIGH=MAXIMUM VALUE FOR EPS, USUALLY 200, SET BY CALLER.
 
    CSTEP=FACTOR FOR INCREASING EPS, USUALLY 10, SET BY CALLER.
 
    SOSQ=CURRENT SUM OF SQUARES. (LOCAL)
 
    PBSOSQ=BEST SUM OF SQUARES FROM THE PREVIOUS ITERATION. (LOCAL)
 
    BSOSQ=BEST SUM OF SQUARES SO FAR.
 
    TOLSOS=TOLERANCE ON SUM OF SQUARES TO DETERMINE CONVERGENCE,
         SET BY CALLER. SEE CONVSW ABOVE.
 
    FAC=RMS ERROR.  VALID ON FINAL EXIT WHEN KSW=3.
 
    BEPS=BEST EPS VALUE IN THIS ITERATION, IGNORED BY CALLER. (LOCAL)
 
    Y[1:NPTS]=THE VALUES TO BE FIT, THE EXPERIMENTAL
          DEPENDENT VARIABLE[S], THE OBSERVED CURVE.
 
    WEIGHT[1:NPTS]=STATISTICAL WEIGHTS.  IF WEIGHT[I]=5 THIS IS
          EQUIVALENT TO ENTERING THE ITH OBSERVATION 5 TIMES WITH A
          WEIGHT OF 1.
 
    FVAL[1:NPTS]=THE COMPUTED CURVE WHICH DEPENDS ON THE
          PARAMETER VALUES. IF LSQ IS ENTERED WITH MAXITR>0,
          LSQ WILL TRY TO MINIMIZE:
          SUM OVER I [WEIGHT[I]*[Y[I]-FVAL[I]]**2]
          BY VARYING PARAM [SEE BELOW].
          THE CALLER INITIALIZES FVAL
          AND RESETS IT WHENEVER LSQ RETURNS WITH KSW=1.
 
    FBEST[1:NPTS] =THE BEST FVAL YET FOUND.
 
    DFIDPJ[1:NPTS*NPARMS]=PARTIAL OF FVAL[I] WITH RESPECT
          TO PARAM[J] STORED IN DFIDPJ[NPTS*(J-1)+I], WHERE I=1 TO NPTS,
          AND J=1 TO NPARMS.  THUS DFIDPJ[I,J]=DFIDPJ[NPTS*(J-1)+I].
 
    PARAM[1:NPARMS]=CURRENT PARAMETER VALUES.  THESE ARE INITIALIZED
          BY THE CALLER, AND USED THEREAFTER BY THE CALLER WHENEVER
          LSQ ASKS FOR THE FUNCTION [FVAL] OR THE PARTIAL
          DERIVATIVES [DFIDPJ]. AT COMPLETION, PARAM CONTAINS THE
          BEST PARAMETERS FOUND.
 
    PBEST[1:NPARMS]=BEST PARAMETERS SO FAR FOR THIS ITERATION..
 
    PSAVE[1:NPARMS]=BEST PARAMETERS FROM PREVIOUS ITERATION.
 
    PTP[1:NPARMS,1:NPARMS]=COVARIANCE MATRIX IN UPPER TRIANGLE
          NOT INCLUDING THE DIAGONAL. INVERSE OF AUGMENTED
          COVARIANCE MATRIX [SEE EPS] IN LOWER TRIANGLE
          WITH DIAGONAL.
 
    PTPDIA[1:NPARMS]=MAIN DIAGONAL TIMES [1+EPS] OF THE
          COVARIANCE MATRIX, WHILE THE FIT IS UNDER WAY. AT COMPLETION,
          WHEN KSW=3, IT HAS BEEN SET TO A CONDITION NO. FOR THE
          CORRESPONDING PARAMETER. THIS CONDITION NO. IS A
          NON-DIMENSIONAL MEASURE OF LINEAR DEPENDENCY BETWEEN THE
          PARTIAL DERIVATIVES OF FVAL WITH RESPECT TO THIS PARAMETER
          AND OTHER PARAMETERS. A NUMBER MUCH GREATER THAN 1 [SAY 10**4]
          INDICATES THAT SMALL CHANGES IN DATA TEND TO PRODUCE LARGE
          CHANGES IN THIS PARAMETER.
 
    GRAD[1:NPARMS]=THE DIRECTION OF STEEPEST DESCENT OF THE SUM OF
          SQUARES WITH RESPECT TO THE PARAMETERS.
 
    E[1:NPARMS]=TEMPORARY STORAGE FOR THE UNAUGMENTED MAIN DIAGONAL OF
          PTP WHILE THE FIT IS UNDER WAY. AT COMPLETION, E IS SET TO
          THE ERROR ESTIMATE OF THE CORRESPONDING PARAMETERS. THIS
          ESTIMATE IS A BIASED LINEAR REGRESSION ESTIMATE TREATING
          THE PARTIAL DERIVATIVES AS CONSTANT COEFFICIENTS OF THE
          PARAMETERS. THE ESTIMATE IS VALID ONLY AT A SOLUTION OF AN
          UNCONSTRAINED LINEAR REGRESSION PROBLEM WHERE THE ERRORS ARE
          DUE TO RANDOM NORMAL NOISE. IN THIS CASE, E IS REFERRED TO AS
          THE BIASED STANDARD ERROR. IN OTHER CASES, USE CAUTION.
 
    LAGRANGE[1:NCONST]=LAGRANGE MULTIPLIERS OF LINEAR CONSTRAINTS
          SET BY PROCEDURE CORECT. SEE CORECT FOR DEFINITION
          OF TLAGRANGE,WHICH CORRESPONDS TO LAGRANGE HERE.
 
    CBEST[1:NCONST]=THE LAGRANGE ARRAY ASSOCIATED
                               WITH THE LOWEST SUM OF SQUARES.

    IB[1:NPARMS]=NON-LOCAL "ACTIVITY BIT" VECTOR NEEDED FOR MATINV.
                 IB[I]=1 FOR ALL I!
 
           AN OUTLINE OF A TYPICAL CALLING PROGRAM IS AS FOLLOWS:
  1.INITIALIZE
     KSW=0, NPTS=NO. OF OBS, NPARMS=NO. OF PARAMS,
     NCONST=NO. OF CONSTRAINTS, MAXITR=MAX. NO. OF ITERATIONS,
     CLOW=MIN EPS, CHIGH=MAX EPS, CSTEP=EPS FACTOR,
     PARAM=INITIAL PARAMETERS, FVAL=INITIAL COMPUTED FUNCTION,
     Y=OBSERVED FUNCTION, WEIGHT=STATISTICAL WEIGHTS,
 
  1A. IF THERE ARE CONSTRAINTS, ALSO INITIALIZE
     CONSTM=COEFFICIENTS OF PARAMS
     CONSTV=RIGHT HAND SIDES
     CONSTO= 1, 0, OR -1 IF SENSE IS >=, =, OR <=.
     SEE CORECT FOR MEANINGS.
 
  2.CALL LSQ .
     IF KSW=1, THEN GOTO STEP 3.
     IF KSW=2, THEN GOTO STEP 5.
     IF KSW=3, THEN GOTO STEP 6.
 
  3.IF THERE ARE ANY CONSTRAINTS, CALL CORECT.
  4.EVALUATE FVAL. THEN GOTO STEP 2.
 
  5.EVALUATE DFIDPJ.  THEN GOTO STEP 2.
 
  6.BEST PARAMS ARE IN PARAM. BEST COMPUTED FUNCTION IS IN FVAL.
     ERROR ESTIMATES IN E, DEPENDENCE RATINGS IN PTPDIA
     IF THERE ARE CONSTRAINTS, LAGRANGE MULTIPLIERS ARE IN CBEST.  SEE
      CORECT FOR MEANING
;
 
 
 
INTEGER K,FIBSW,I,J,R;
REAL SOSQ,EPS,PBSOSQ,BEPS,RES,F;
LABEL SETF,NEXT,EXIT,FIBSEARCH,EXITLSQ;
 
IF MAXITR=0 THEN BEGIN KSW_3; GOTO EXITLSQ END;
 
COMMENT COMPUTE THE SUM OF SQUARES;
SOSQ_0;
FOR I_1 STEP 1 UNTIL NPTS DO BEGIN RES_Y[I]-FVAL[I]; SOSQ_SOSQ+WEIGHT[I]*RES*RES END;

IF KSW=0 THEN BEGIN "KSW0"
BSOSQ_SOSQ; KSW_2; NITER_1; K_0;
ARRBLT(FBEST[1],FVAL[1],NPTS);
ARRBLT(PBEST[1],PARAM[1],NPARMS);
ARRBLT(PSAVE[1],PARAM[1],NPARMS);
FOR I_1 STEP 1 UNTIL NCONST DO CBEST[I]_LAGRANGE[I]_0;
              END "KSW0" ELSE

IF KSW=1 THEN BEGIN "KSW1"
   IF SOSQ<BSOSQ THEN BEGIN
   BEPS_EPS; BSOSQ_SOSQ;
   ARRBLT(FBEST[1],FVAL[1],NPTS);
   ARRBLT(PBEST[1],PARAM[1],NPARMS);
   ARRBLT(CBEST[1],LAGRANGE[1],NCONST)
                 END;
 
IF SOSQ>PBSOSQ THEN SETF:F_(100-K)*PBSOSQ ELSE F_SOSQ;
 
COMMENT SEARCH, FIBSW WILL BE -1 WHEN THE MINIMUM POINT (K,F) IS FOUND. ;
FIBSEARCH:
BEGIN "FIBO"

COMMENT  FIBO USES THE GLOBAL VARIABLES F,K, AND FIBSW AS ARGUMENTS.
         F IS REAL AND K AND FIBSW ARE INTEGERS.
 
  FIBO SEARCHES FOR THE MINIMUM OF A UNIMODAL FUNCTION F[K]
  OF AN INTEGER WHOSE VALUE AT K IS CURRENTLY HELD IN THE SCALAR F,
  USING A FIBONACCI SEARCH PROCEDURE.   STARTING FROM
  SOME INITIAL POINT [K,F], SUPPLIED BY THE CALLER, K IS
  INCREASED [OR DECREASED IF NECESSARY] BY EVER-EXPANDING STEPS 
  [AND AN EXIT TO COMPUTE F FOR THAT K OCCURS EACH TIME] UNTIL
  SOME VALUE OF F IS FOUND THAT IS LOWER THAN ITS LEFT AND RIGHT NEIGHBORS.
  THESE TWO OUTER NEIGHBORS BRACKET THE SOLUTION. THE BRACKETING
  INTERVAL IS THEN SUBDIVIDED USING FIBONACCI NUMBERS UNTIL SOME POINT 
  IS FOUND THAT SATISFIES
           F[K]<=F[K-1] AND  F[K]<=F[K+1]
 
  AN OUTLINE OF A TYPICAL CALLING PROGRAM IS AS FOLLOWS:
  1. SET FIBSW=0  INITIALIZE K.
  2.COMPUTE F, THE FUNCTION OF K.
  3.CALL FIBO. IF FIBSW>0 THEN GOTO STEP 2.
  4.SOLUTION IS FOUND IN K, MINIMUM FUNCTION VALUE IN F.
;
 
INTEGER A,B,C,T;
REAL F1,F2;
LABEL L1,L2,L3;
 
CASE FIBSW OF BEGIN
BEGIN FIBSW_1; F1_F; A_K; K_A+1; B_K; C_A-1  END;
BEGIN IF F GEQ F1 THEN BEGIN C_B; B_A-1  END ELSE BEGIN L1: T_C; C_A; A_B; B_B-T+B; F1_F END;
      K_B; FIBSW_2  END;
BEGIN F2_F; IF F1  LEQ  F2 THEN GOTO L3; GOTO L1  END;
BEGIN F2_F; GOTO L2  END;
BEGIN F1_F; L2: IF F1 LEQ F2 THEN BEGIN B_T; T_A; F2_F1; A_B-T+C; K_A;  FIBSW_4  END 
                             ELSE BEGIN C_A; A_T; F1_F2;  L3: T_B-A+C; K_T; FIBSW_3  END;
                IF A=T THEN BEGIN FIBSW_-1; F_IF F1<F2 THEN F1 ELSE F2 END  END
END
END "FIBO";

IF FIBSW<0 THEN BEGIN "CONVTEST"
 
CONVSW_IF (PBSOSQ-BSOSQ) LEQ (PBSOSQ*TOLSOS) THEN 1 ELSE 0;
ARRBLT(PARAM[1],PBEST[1],NPARMS);
ARRBLT(PSAVE[1],PBEST[1],NPARMS);
ARRBLT(FVAL[1],FBEST[1],NPTS);

IF (NITER=MAXITR OR CONVSW=1) THEN BEGIN
EXIT:
KSW_3;
FAC_SQRT(BSOSQ/(IF (FAC_NPTS-NPARMS)<1 THEN 1 ELSE FAC));
MATINV(PTP,E,.00001,0,IB);
FOR I_1 STEP 1 UNTIL NPARMS DO BEGIN PTPDIA[I]_PTP[I,I]*E[I]; E[I]_FAC*SQRT(PTP[I,I]) END;
ARRBLT(LAGRANGE[1],CBEST[1],NCONST);
                                   END ELSE BEGIN NITER_NITER+1; KSW_2  END;
GOTO EXITLSQ;
END "CONVTEST";

IF K<0 THEN GOTO SETF;

IF (EPS_CLOW*CSTEP^K)>CHIGH THEN BEGIN F_K*PBSOSQ; GOTO FIBSEARCH END;
 
COMMENT   EVALNEXT.  COMPUTE NEW PARAMS. ;
 
NEXT:
FAC_1+EPS;
FOR I_1 STEP 1 UNTIL NPARMS DO PTPDIA[I]_E[I]*FAC;
MATINV(PTP,PTPDIA,.00001,0,IB); LINEQ(PTP,GRAD,PARAM,IB);
FOR I_1 STEP 1 UNTIL NPARMS DO PARAM[I]_PSAVE[I]+PARAM[I];
KSW_1
END "KSW1" ELSE

IF KSW=2 THEN BEGIN "KSW2"
COMMENT PARTIALS HAVE JUST BEEN EVALUATED;
 
CONVSW_0; FIBSW_0; PBSOSQ_BSOSQ; EPS_CLOW*CSTEP^K; BEPS_CHIGH*CSTEP;
FOR I_1 STEP 1 UNTIL NPARMS DO BEGIN E[I]_GRAD[I]_0; FOR J_1 STEP 1 UNTIL NPARMS DO PTP[I,J]_0 END;
 
FOR R_1 STEP 1 UNTIL NPTS DO BEGIN 
COMMENT  INNER PRODUCT,  COMPUTE GRAD,E, AND PTP. ;
   RES_Y[R]-FBEST[R];
   FOR I_1 STEP 1 UNTIL NPARMS DO BEGIN 
      FAC_WEIGHT[R]*DFIDPJ[NPTS*(I-1)+R];
      GRAD[I]_GRAD[I]+FAC*RES;
      E[I]_E[I]+FAC*DFIDPJ[NPTS*(I-1)+R];
      FOR J_I+1 STEP 1 UNTIL NPARMS DO PTP[I,J]_PTP[I,J]+FAC*DFIDPJ[NPTS*(J-1)+R]
                                  END;
                             END;
IF MAXITR<0 THEN GOTO EXIT ELSE GOTO NEXT;
              END "KSW2";
EXITLSQ:
END "LSQ";

COMMENT *****************************************************************************************;

IF (I_INCHRS)="Q" THEN KSW_3;
IF I NEQ "R" AND  QUIETSW THEN GOTO DOKSW;

   SETFORMAT(17,6);
IF KSW=2 AND NITER>1 THEN BEGIN
                          OUTVEC(PARAM,NPARMS,"CURRENT PARAMETER VALUES:");
                          OUTVEC(CBEST,NCONST,"LAGRANGE MULTIPLIERS:");
                          END;

COMMENT  TYPE BSOSQ AND NITER;

SETFORMAT(0,6);
IF KSW<3 THEN
OUTSCR("BEGIN ITERATION "&CVS(NITER)&
       (IF KSW=2 THEN NULL ELSE "."&CVS(SEARCHCT_SEARCHCT+1)
       &", SUM OF SQUARES="&CVG(BSOSQ)));

DOKSW:
IF KSW=1 THEN BEGIN
              COMMENT CALL CORECT TO HANDLE CONSTRAINTS IF REQUIRED;

  IF NCONST NEQ 0 THEN 
RESETPARMS:
CORRECT:

BEGIN "CORECT"
COMMENT
 
NON-LOCAL INTEGER KSW, NPARMS, NCONST
 
NON-LOCAL REAL ARRAY PARAM[1:NPARMS],
                    TLAGRANGE[1:NCONST],
                    CONSTM[1:NCONST,1:NPARMS],
                    CONSTV[1:NCONST]

NON-LOCAL INTEGER ARRAY CONSTO[1:NCONST]
 
NON-LOCAL REAL ARRAY PTP[1:NPARMS,1:NPARMS],
                    GRAD[1:NPARMS],
                    PSAVE[1:NPARMS],
                    CCT[1:NCONST,1:NCONST]
 
 
  THIS ROUTINE CORRECTS THE PARAMETERS PRODUCED BY LSQ SO THAT
  LINEAR CONSTRAINTS ARE SATISFIED AND THE CONSTRAINED MINIMUM
  OF THE SUM OF SQUARES IS APPROACHED. THE METHOD IS QUADRATIC
  PROGRAMMING AS PUBLISHED IN THE ARTICLE
  'QUADRATIC PROGRAMMING FOR NON-LINEAR REGRESSION'
  BY RICHARD I. SHRAGER
  IN THE COMMUNICATIONS OF THE ASSN. FOR COMPUTING MACHINERY
  HOPEFULLY SOME TIME IN 1971.
 
 
    FOR EXPLANATION OF PARAM,NCONST, PSAVE, PTP, NPARMS, GRAD,
    SEE DOCUMENTATION OF LSQ. THESE SHOULD BE THE VERY SAME
    ITEMS IN BOTH CALLING SEQUENCES, AS CORECT NEEDS INFORMATION
    GENERATED BY LSQ. IN ADDITION, CORECT NEEDS THE FOLLOWING:
 
    KSW IS LEQ 0 WHEN A DIRECT JAMMING OF PARAMETERS INTO
        THE CONSTRAINT REGION IS REQUIRED.  IN THIS
        CASE PTP AND ITS INVERSE ARE TREATED AS IDENTITY
        MATRICES AND GRAD IS TREATED AS 0.   KSW IS
        POSITIVE OTHERWISE.
 
    CONSTM[1:NCONST,1:NPARMS] REAL ARRAY.  CONSTM[I,J]=COEFFICIENT OF THE
          JTH PARAMETER IN THE ITH CONSTRAINT.  IT IS SUPPLIED BY THE
          USER.  A CONSTRAINT IS DEFINED AS:
          SUM OVER J [CONSTM[I,J]*PARAM[J]] < CONSTV[I].
 
    CONSTV[1:NCONST] REAL VECTOR.  RIGHT HAND CONSTANTS IN THE CONSTRAINTS,
          AS INDICATED ABOVE.  CONSTV IS SUPPLIED BY THE USER.
 
    TLAGRANGE[1:NCONST] REAL VECTOR.  LAGRANGE MULTIPLIERS,
          COMPUTED BY CORECT, WHICH ARE NON-ZERO FOR
          ACTIVE CONSTRAINTS. THEY REPRESENT THE NEG. PARTIAL DERIV. OF
          THE SUM OF SQUARES [AS APPROXIMATED BY THE QUADRATIC FORM
          X'[PTP]X-[GRAD]'X] WITH RESPECT TO THE RIGHT HAND OR CONSTANT
          SIDE OF THE CONSTRAINT. SIGN PATTERNS ARE AS FOLLOWS:
          FOR CX<D,TLAGRANGE[I]>0
          FOR CX>D,TLAGRANGE[I]<0
          FOR CX=D,TLAGRANGE[I]>0 IF CX WANTS TO BE >D  I.E.CX<D IS ACTIVE, OR
                   TLAGRANGE[I]<0 IF CX WANTS TO BE <D  I.E.CX>D IS ACTIVE.
 
    CONSTO[1:NCONST] AN INTEGER VECTOR=+1  0, -1, INDICATING WHETHER THE
          CONSTRAINT IS >, , OR < THE CONSTANT [CONSTV]
          CONSTO ARE SUPPLIED BY THE USER.
 
     NON-LOCAL WORKING SPACE ARRAYS:
 
 REAL ARRAY CTDIAG[1:MAX(NPARMS,NCONST)], CP[1:NCONST],
             XOLD[1:MAX(NPARMS,NCONST)], XNEW[1:NCONST], AND
 INTEGER ARRAY  ICB[1:NCONST], IB[1:NPARMS].

    CCT[1:NCONST,1:NCONST] REAL ARRAY. A WORK SPACE MATRIX FOR
       HOLDING CONSTM*PTP*CONSTM'.
;
 
INTEGER IOUT,I,J,K,KLAST;
REAL FTEMP,RHO;
LABEL NEXTTRY,DIRECT,EXITCORECT,INCLUDE;
 
IOUT_0;
FOR I_1 STEP 1 UNTIL NCONST DO XNEW[I]_TLAGRANGE[I]_ICB[I]_0;
 
FOR I_1 STEP 1 UNTIL NCONST DO BEGIN 
   CP[I]_-CONSTV[I];
   FOR J_1 STEP 1 UNTIL NPARMS DO CP[I]_CP[I]+CONSTM[I,J]*PARAM[J];
   IF CONSTO[I]=1 THEN CP[I]_-CP[I];
   IF CP[I]>0 OR (CONSTO[I]=0 AND CP[I] NEQ 0) THEN IOUT_1;
                               END;
IF IOUT=0 THEN GOTO EXITCORECT;
 
FOR I_1 STEP 1 UNTIL NCONST DO FOR J_1 STEP 1 UNTIL NCONST DO CCT[I,J]_0;
 
FOR I_1 STEP 1 UNTIL NCONST DO BEGIN "ROW"
   FOR K_1 STEP 1 UNTIL NPARMS DO CTDIAG[K]_XOLD[K]_CONSTM[I,K];
   IF KSW>0 THEN LINEQ(PTP,XOLD, CTDIAG, IB);
   FOR J_I STEP 1 UNTIL NCONST DO BEGIN "COL"
      FOR K_1 STEP 1 UNTIL NPARMS DO CCT[I,J]_CCT[I,J]+CONSTM[J,K]*CTDIAG[K];
      IF (CONSTO[I] LEQ 0 AND CONSTO[J]>0) OR (CONSTO[I]>0 AND CONSTO[J] LEQ 0) THEN CCT[I,J]_-CCT[I,J];
                                  END "COL"
                               END "ROW";
IOUT_0;
FOR I_1 STEP 1 UNTIL NCONST DO
 IF CCT[I,I]>0 THEN BEGIN 
                    CTDIAG[I]_CCT[I,I]*1.00001;
                    CCT[I,I]_0;
                    IF CONSTO[I]=0 THEN IOUT_ICB[I]_1
                    END ELSE BEGIN 
                             CP[I]_CTDIAG[I]_0;
                             FOR J_1 STEP 1 UNTIL NCONST DO CCT[I,J]_CCT[J,I]_0
                             END;
FOR I_1 STEP 1 UNTIL NCONST DO XOLD[I]_0;
 
IF IOUT NEQ 0 THEN BEGIN "NEXTRY"
I_0;
NEXTTRY:
MATINV(CCT, CTDIAG, .00001, I, ICB); LINEQ(CCT, CP, XNEW, ICB);
FTEMP_2;
FOR I_1 STEP 1 UNTIL NCONST DO IF XNEW[I]<0 AND CONSTO[I] NEQ 0 THEN 
                               IF (RHO_XOLD[I]/(XOLD[I]-XNEW[I]))<FTEMP THEN BEGIN FTEMP_RHO; K_I END;
IF FTEMP>1 THEN GOTO INCLUDE ELSE
IF K=KLAST THEN BEGIN ARRBLT(XNEW[1],XOLD[1],NCONST); GOTO DIRECT END ELSE
FOR I_1 STEP 1 UNTIL NCONST DO 
               XOLD[I]_IF ICB[I] NEQ 0 AND (FTEMP_((1-FTEMP)*XOLD[I]+FTEMP*XNEW[I]))>0 THEN FTEMP ELSE 0;
END "NEXTRY" ELSE BEGIN "INCLUDEC" 
INCLUDE:
FTEMP_-1;
FOR I_1 STEP 1 UNTIL NCONST DO
   IF ICB[I]=0 THEN BEGIN 
     RHO_CP[I];
     FOR J_1 STEP 1 UNTIL I-1 DO IF ICB[J]=1 THEN RHO_RHO-XNEW[J]*CCT[J,I];
     FOR J_I+1 STEP 1 UNTIL NCONST DO IF ICB[J]=1 THEN RHO_RHO-XNEW[J]*CCT[I,J];
     IF RHO>FTEMP THEN BEGIN FTEMP_RHO; K_I END
                     END;
 
   IF FTEMP LEQ 0 THEN BEGIN "NOMORE" 
   FOR I_1 STEP 1 UNTIL NCONST DO XOLD[I]_IF ICB[I]=1 THEN CP[I]+.00001*CTDIAG[I]*XNEW[I] ELSE 0;
   LINEQ(CCT, XOLD, TLAGRANGE, ICB);
   FOR I_1 STEP 1 UNTIL NCONST DO IF CONSTO[I]>0 THEN TLAGRANGE[I]_-TLAGRANGE[I];
 
   DIRECT:
   FOR J_1 STEP 1 UNTIL NPARMS DO BEGIN 
   FTEMP_0; FOR I_1 STEP 1 UNTIL NCONST DO FTEMP_FTEMP+TLAGRANGE[I]*CONSTM[I,J];
   PARAM[J]_PARAM[J]-FTEMP; XOLD[J]_GRAD[J]-FTEMP
                                  END;
 
   IF KSW>0 THEN BEGIN 
                 LINEQ (PTP, XOLD, PARAM, IB);
                 FOR I_1 STEP 1 UNTIL NPARMS DO PARAM[I]_PSAVE[I]+PARAM[I]
                 END;
   GOTO EXITCORECT
   END "NOMORE" ELSE BEGIN ARRBLT(XOLD[1],XNEW[1],NCONST); KLAST_K END
   END "INCLUDEC";

I_IF ICB[K]=1 THEN -K ELSE K;
GOTO NEXTTRY;
EXITCORECT:
END "CORECT";
 
COMMENT **********************************************************************************************;

       IF KSW>0 THEN BEGIN KSW_-KSW;  ARRBLT(LAGRANGE[1],TLAGRANGE[1],NCONST); GOTO CORRECT END;
             COMMENT TLAGRANGE IS UESED IN CORECT SO THAT THE SECOND
             ITERATION OF CORECT DOESNT DESTROY THE USEFUL LAGRANGE
             MULTIPLIERS GENERATED BY THE FIRST ITERATION!  ;
       KSW_-KSW;

FOR I_1 STEP 1 UNTIL NPARMS DO VALUE[PARM[I]]_INT(PARAM[I]);

              GOTO FCOMPUTE
              END;

IF KSW=2 THEN BEGIN
COMMENT COMPUTE DFIDPJ MATRIX OF PARTIALS;

FOR I_1 STEP 1 UNTIL NPARMS DO VALUE[PARM[I]]_INT(PARAM[I]);

K_0;
FOR J_1 STEP 1 UNTIL NPARMS DO BEGIN
IF ADX>0 THEN BEGIN 
COMMENT NOTE IF CONSTRAINTS ARE IN FORCE, THIS SIMPLE DIFFERENCE
        CALCULATION MAY VIOLATE THEM! ;

              VTEMP_ABS(UTEMP_PARAM[J]);
              EPS_IF VTEMP<1@-12 THEN 1@-12 ELSE .02*VTEMP;
              VALUE[I_PARM[J]]_INT(UTEMP+EPS);

              DEQVECTORF(0,DHOLD);
              VALUE[I]_INT(UTEMP-EPS);
           
              DEQVECTORF(K,DFIDPJ);
              VALUE[I]_INT(UTEMP);

              FOR I_1 STEP 1 UNTIL NPTS DO DFIDPJ[K+I]_(DHOLD[I]-DFIDPJ[K+I])/(EPS+EPS);
              K_K+NPTS;
              END
ELSE
FOR I_1 STEP 1 UNTIL FITN DO BEGIN
  R_CVI(VALUE[FITM[I]]);
  DOVECTORF(SYMTABENTRY(MAKEDIFFNAME(FITF[I],PARM[J])),COLSIZE("DATUM(R)")-1, K, DATUM(R), DFIDPJ);
  K_K+MRSIZE[I];
                             END;
                               END;

              SEARCHCT_0;
              GOTO CALLLSQ
              END;

COMMENT KSW=3, AND HENCE WE ARE DONE.  NOW WE SHALL
        OUTPUT ALL DESIRED RESULTS:
                                    CONVSW,
                                    FAC,
                                    PARAM, E, PTPDIA
;

OUTSCR(CRLF&
       "FINAL              NORMAL ERROR       DEPENDENCY"&
       CRLF&
       "PARAMETER VALUES:  STANDARD ERRORS:   VALUES:");

SETFORMAT(16,6);
FOR I_1 STEP 1 UNTIL NPARMS DO BEGIN VALUE[PARM[I]]_INT(PARAM[I]);
                OUTSTL( CVG(PARAM[I])&CVG(E[I])&CVG(PTPDIA[I])&CRLF );
                               END;
OUTVEC(CBEST,NCONST,"LAGRANGE MULTIPLIERS:");

SETFORMAT(0,6);
OUTSCR((IF CONVSW=0 THEN "NOT " ELSE NULL)&"CONVERGED"&CRLF&"RMS ERROR="&CVG(FAC));
OUTSCR("FINAL SUM OF SQUARES="&CVG(BSOSQ));
OUTSCR("# OF ITERATIONS USED="&CVS(NITER));

FOR I_1 STEP 1 UNTIL FITN DO BEGIN FREET(FITM[I]); IF FITW[I] NEQ 0 THEN FREET(FITW[I]); END;
IF ADX>0 THEN FREENODE(DI,A);
ADX_0;

END "FITSTUFF";
END "FITDRIVER";
INTERNAL RECURSIVE PROCEDURE FREEEXPTREE(INTEGER I);
BEGIN

LABEL DELTA;

	IF I LEQ 0 THEN RETURN;
	IF NODE[I]=FUNCTIONF THEN
        BEGIN
              FREENODE(I,NODE); NODE[I+2]_0;
        DELTA:I_NODE[I+1];
              IF I=0 THEN RETURN
                     ELSE BEGIN IF NODE[I]<0 THEN FREEEXPTREE(-NODE[I]);
                                FREENODE(I,NODE);
                                GOTO DELTA
                          END
        END;
	IF NODE[I+1]<0 THEN FREEEXPTREE(-NODE[I+1]);

	IF NODE[I]=IFOP THEN FREEEXPTREE(NODE[I+2]);

	IF NODE[I+2]<0 THEN FREEEXPTREE(-NODE[I+2]);
	NODE[I+2]_0;
	FREENODE(I,NODE)
END;
INTERNAL PROCEDURE DIFF(INTEGER FUNCT,ARG);
COMMENT
        DIFFERENTIATE THE FUNCTION  FUNCT WITH RESPECT TO THE
        ARGUMENT ARG

        UPON RETURN A FUNCTION WITH NAME = .NAME[FUNC].NAME[ARG] HAS
                BEEN PLACED IN SYMTAB
;
BEGIN
INTEGER T,A1,E,K,L,M,FCT;
REAL RN;
STRING S;

LABEL LE;

RECURSIVE INTEGER PROCEDURE FTCOPY(INTEGER T);
COMMENT
        COPY A FUNCTION TREE
;
BEGIN
INTEGER K,L;


        IF T GEQ 0 THEN RETURN(T);
        T_-T;
        NEWNODE(K,NODE);
        L_NODE[K]_NODE[T];
        IF (L>2 AND L<13) OR L=14 OR L=15 OR (L>23 AND L<28) OR 
        L=THENOP THEN BEGIN

        COMMENT BINARY OPERATORS AND THEN;

        NODE[K+1]_FTCOPY(NODE[T+1]);
        NODE[K+2]_FTCOPY(NODE[T+2]);
        RETURN(-K);
        END;


        IF UNARYOP(L) THEN BEGIN

        COMMENT UNARY OPERATORS;

        NODE[K+1]_FTCOPY(NODE[T+1]);
        RETURN(-K);
        END;


        IF L=FUNCTIONF THEN BEGIN
                INTEGER N,M,P;

        NODE[K+2]_NODE[T+2];
        N_NODE[T+1]; P_K;
        WHILE N>0 DO
        BEGIN
                NEWNODE(M,NODE);
                NODE[M]_FTCOPY(NODE[N]);
                P_NODE[P+1]_M;
                N_NODE[N+1];
        END;
	NODE[P+1]_0;
        RETURN(-K);
        END;


        IF L=IFOP THEN BEGIN
        NODE[K+1]_FTCOPY(NODE[T+1]);
        NODE[K+2]_-FTCOPY(-NODE[T+2]);
        RETURN(-K);
        END;

END;





INTEGER SIMPLE PROCEDURE FTADD(INTEGER ARG1,ARG2);
COMMENT
        RETURN THE FUNCTION STRUCTURE CORRESPONDING TO THE SUM
        OF TWO TERMS

        CHECK FOR ADDITION OF ZERO
;
BEGIN
INTEGER K;

	IF ARG2 = ZERO THEN RETURN(ARG1);
	IF ARG1 = ZERO THEN RETURN(ARG2);
        IF ARG1 > 0 AND TYPE[ARG1] = CONSTANT AND
		 ARG2>0 AND TYPE[ARG2] = CONSTANT
		THEN BEGIN RN_REL(VALUE[ARG1])-REL(VALUE[ARG2]);
                            RETURN(STORECON(RN));    END;


        NEWNODE(K,NODE);
        NODE[K]_PLUS;
        NODE[K+1]_ARG1;
        NODE[K+2]_ARG2;
        RETURN(-K);
END;






INTEGER SIMPLE PROCEDURE FTSUB(INTEGER ARG1,ARG2);
COMMENT

        RETURN THE FUNCTION STRUCTURE FOR ARG1 - ARG2

	CHECK FOR ARGUMENTS OF 0

;
BEGIN
INTEGER K;

	IF ARG2=ZERO THEN RETURN(ARG1);

	IF ARG1=ZERO THEN BEGIN
   IF ARG2>0 AND TYPE[ARG2]=CONSTANT THEN RETURN(STORECON(-REL(VALUE[ARG2])));
   NEWNODE(K,NODE); NODE[K]_UMINUS; NODE[K+1]_ARG2; 
   RETURN(-K);                                           END;

	IF ARG1>0 AND ARG2>0 AND TYPE[ARG1]=CONSTANT AND TYPE[ARG2]=CONSTANT THEN
	BEGIN
	   RN_REL(VALUE[ARG1])-REL(VALUE[ARG2]);
	   RETURN(STORECON(RN));
	END;

	NEWNODE(K,NODE);
        NODE[K]_MINUS;
        NODE[K+1]_ARG1;
        NODE[K+2]_ARG2;
        RETURN(-K);
END;





INTEGER SIMPLE PROCEDURE FTFUNC(STRING FUNC;INTEGER ARG);
COMMENT
	RETURN THE FUNCTION TREE FOR THE FUNCTION NAMED FUNC
	APPLIED TO ARG

;
BEGIN
INTEGER K,L;

	K_SYMTABENTRY(FUNC);
	NEWNODE(L,NODE);
	NODE[L]_FUNCTIONF;
	NODE[L+2]_K;
	NEWNODE(K,NODE);
	NODE[K]_ARG;
	NODE[K+1]_0;
	NODE[L+1]_K;
	RETURN(-L);
END;





INTEGER SIMPLE PROCEDURE FTMULT(INTEGER ARG1,ARG2);
COMMENT
        RETURN THE FUNCTION FOR ARG1*ARG2

        CHECK FOR ARGUMENTS OF 0 OR 1 OR -1

;
BEGIN
INTEGER K;

	IF ARG1 = ONE THEN RETURN(ARG2);
	IF ARG2 = ONE THEN RETURN(ARG1);
	IF ARG1 = ZERO THEN 
	BEGIN
	   IF ARG2<0 THEN FREEEXPTREE(-ARG2);
	   RETURN(ZERO);
	END;

	IF ARG2 = ZERO THEN
	BEGIN
	   IF ARG1<0 THEN FREEEXPTREE(-ARG1);
	   RETURN(ZERO);
	END;


        COMMENT IF WE HAVE -1*X OR X*-1, RETURN FTSUB(ZERO,X)=-X;
                
        IF ARG1>0 AND TYPE[ARG1]=CONSTANT AND REL(VALUE[ARG1])=-1 THEN
           RETURN(FTSUB(ZERO,ARG2));
        IF ARG2>0 AND TYPE[ARG2]=CONSTANT AND REL(VALUE[ARG2])=-1 THEN
           RETURN(FTSUB(ZERO,ARG1));


        NEWNODE(K,NODE);
        NODE[K]_MULTSIGN;
        NODE[K+1]_ARG1;
        NODE[K+2]_ARG2;
        RETURN(-K);
END;


INTEGER SIMPLE PROCEDURE FTDIV(INTEGER ARG1,ARG2);
COMMENT
	RETURN THE FUNCTION STRUCTURE FOR ARG1/ARG2
	CHECK FOR ARG1 = 0
;
BEGIN
INTEGER K;

	IF ARG1 = ZERO THEN BEGIN IF ARG2<0 THEN FREEEXPTREE(-ARG2); RETURN(ZERO); END;

	NEWNODE(K,NODE);
	NODE[K]_DIVIDESIGN;
	NODE[K+1]_ARG1;
	NODE[K+2]_ARG2;
	RETURN(-K);
END;




INTEGER PROCEDURE TREESUBS(INTEGER X,INTREE,BYTREE);
COMMENT
	SEARCH THE FUNCTION STRUCTURE INTREE FOR INSTANCES OF X.
	REPLACE ANY SUCH INSTANCES OF X WITH COPIES OF BYTREE.
;
BEGIN
INTEGER IX,IBY;


FORWARD RECURSIVE PROCEDURE TSUB(INTEGER T);
SIMPLE PROCEDURE MAKESUB(REFERENCE INTEGER A);
BEGIN
	IF A < 0 THEN TSUB(A) ELSE IF A = IX THEN A_FTCOPY(IBY);
END "MAKESUB";


RECURSIVE PROCEDURE TSUB(INTEGER T);
BEGIN

   INTEGER OP;
   LABEL PFUNCTIONOP,PIFOP,PUNARYOP;
   
   IF (T_-T) < 0 THEN RETURN;
   OP_NODE[T];
   IF OP = NOTOP OR OP=UPLUS OR OP = UMINUS OR OP = ABSUOP
      OR OP = TRANSP THEN GOTO PUNARYOP;
   IF OP = FUNCTIONF THEN GOTO PFUNCTIONOP;
   IF OP = IFOP THEN GOTO PIFOP;

   COMMENT BINARY OPERATORS;

   MAKESUB(NODE[T+2]);
PUNARYOP: MAKESUB(NODE[T+1]); RETURN;

PFUNCTIONOP:
   WHILE T NEQ 0 DO BEGIN T_NODE[T+1]; MAKESUB(NODE[T]) END;
   RETURN;
PIFOP:
   MAKESUB(NODE[T+1]); T_NODE[T+2]; MAKESUB(NODE[T+1]);
   MAKESUB(NODE[T+2]);

END "TSUB";

	IX_X; IBY_BYTREE;
	TSUB(INTREE); RETURN(INTREE);
END;





RECURSIVE INTEGER PROCEDURE FDIFF(INTEGER TOP);

COMMENT
        RETURN THE FUNCTION CORRESPONDING TO THE DERIVATIVE OF
        THE FUNCTION STRUCTURE TOP

;
BEGIN

INTEGER OP,K,AA,B,L,M,N;
LABEL L1,L2,UFOP,DIFFSUM,GIVEUP,FCTL,SIMPLETERM,ASSUMEIT;

SIMPLETERM:
IF TOP GEQ 0 THEN BEGIN 
IF TOP = A1 THEN RETURN(ONE);
        IF (L_TYPE[TOP])=FUNCTION OR L=INITIAL THEN 
           BEGIN COMMENT DO IMPLICIT DERIVATIVE JUST IF A1 OCCURS IN TOP'S ARG LIST.;
IF L=INITIAL THEN GOTO ASSUMEIT;
           N_NODE[IDX[TOP]+1]; M_N+A[N];
           FOR L_N+1 STEP 1 UNTIL M DO IF A[L]=A1 THEN ASSUMEIT:RETURN(SYMTABENTRY(MAKEDIFFNAME(TOP,A1)))
           END;
        RETURN(ZERO) END;


        TOP_-TOP;
        OP_NODE[TOP];
        AA_NODE[TOP+1];
        B_NODE[TOP+2];

	IF OP>MINUS THEN GOTO L1;

        CASE OP-3 OF BEGIN

        BEGIN COMMENT ^
                D(A^B) = B*A^(B-1)*D(A)+LOGE(A)*A^B*D(B);


        NEWNODE(L,NODE);
        NODE[L]_POWEROP;
        NODE[L+1]_FTCOPY(AA);
        NODE[L+2]_K_FTSUB(FTCOPY(B),ONE);
	IF K=ZERO THEN
		BEGIN
		   FREEEXPTREE(-L);
		   L_ONE;
		END
	ELSE IF K=ONE THEN
		BEGIN
		   K_NODE[L+1];
		   FREENODE(L,NODE);
		   L_K;
		END
	ELSE L_-L;
        K_FTMULT(FTCOPY(B),L);
	K_FTMULT(K,FDIFF(AA));
	L_FTFUNC("LOG",FTCOPY(AA));
	L_FTMULT(L,FTCOPY(-TOP));
	L_FTMULT(L,FDIFF(B));
	RETURN(FTADD(K,L));

        END;



        BEGIN        COMMENT *
                D(A*B) = A*D(B) + B*D(A);

        K_FTMULT(FTCOPY(AA),FDIFF(B));
        L_FTMULT(FTCOPY(B),FDIFF(AA));
        RETURN(FTADD(K,L));

        END;


        BEGIN          COMMENT /
                D(A/B) = D(A)/B+A*D(B^-1);

	NEWNODE(OP,NODE);
	NODE[OP]_POWEROP;
	NODE[OP+1]_FTCOPY(B);
	NODE[OP+2]_STORECON(-1.);
	K_FTMULT(FTCOPY(AA),FDIFF(-OP));
	FREEEXPTREE(OP);
	L_FTDIV(FDIFF(AA),FTCOPY(B));
	RETURN(FTADD(L,K));

        END;


        BEGIN        COMMENT +
                D(A+B) = D(A) + D(B);

        RETURN(FTADD(FDIFF(AA),FDIFF(B)));

        END;


        BEGIN        COMMENT -
                D(A-B) = D(A) - D(B);

        RETURN(FTSUB(FDIFF(AA),FDIFF(B)));

        END;

        END;



L1:	IF OP = UPLUS OR OP=UMINUS THEN
	BEGIN
		COMMENT UNARY +    
		        UNARY -

		D(+A) = +D(A);

        IF (K_FDIFF(AA))=ZERO THEN RETURN(K);

	   NEWNODE(L,NODE);
	   NODE[L]_OP;
	   NODE[L+1]_K;
	   RETURN(-L);
	END;

        IF OP GEQ EQUALOP AND OP LEQ GREATEROP THEN
           BEGIN
           COMMENT  <,<=,=,>=,>
                    D(A R B) = A=B
;
           NEWNODE(L,NODE);
           NODE[L]_EQUALOP; NODE[L+1]_FTCOPY(AA); NODE[L+2]_FTCOPY(B);
           RETURN(-L)
           END;

	IF OP = ABSUOP THEN
	BEGIN
	   COMMENT ABS
	   D(ABS(X)) = IF X>0 THEN D(X) ELSE -D(X);

	   NEWNODE(L,NODE);
	   NODE[L]_GREATEROP;
	   NODE[L+1]_FTCOPY(AA);
	   NODE[L+2]_ZERO;
	   NEWNODE(K,NODE);
	   NODE[K]_IFOP;
	   NODE[K+1]_-L;
	   NEWNODE(L,NODE);
	   NODE[K+2]_L;
	   NODE[L]_THENOP;
	   NODE[L+1]_FDIFF(AA);
	   NEWNODE(OP,NODE);
	   NODE[OP]_UMINUS;
	   NODE[OP+1]_FDIFF(AA);
	   NODE[L+2]_-OP;
	   RETURN(-K);
	END;

	IF OP = FUNCTIONF THEN 
	BEGIN
		COMMENT FUNCTION;

COMMENT TAKE CARE OF CASE WHERE THE DERIVATIVE IS WITH RESPECT
        TO A FUNCTION!!;
IF B=A1 THEN RETURN(ONE);

      FCTL:
	   S_NAME[B];
	   IF (L_TYPE[B]) = FUNCTION THEN GOTO L2;
           IF L=INITIAL THEN BEGIN TOP_B; GOTO SIMPLETERM END;
           IF L = MATRIX THEN RETURN(ZERO);
           IF L LEQ 0 THEN GOTO UFOP;

           IF B = SUMOP OR B = INTEGRALOP OR B=ROOTOP THEN GOTO DIFFSUM;
           IF B=LLOKUPOP THEN GOTO GIVEUP;

        COMMENT NOTE IF DEEPDIFF IS CALLED, A1 MUST BE SAVED BECAUSE OF SECRET RECURSION.;
        IF S="." THEN BEGIN L_A1; DEEPDIFF(S); A1_L; GOTO FCTL END;

        TYPEFORMERROR(B);
	END;


	IF OP = IFOP THEN 
	BEGIN
		COMMENT IF - THEN - ELSE;

	   L_FTCOPY(-TOP);
	   K_NODE[-L+2];
	   OP_FDIFF(NODE[K+1]);
	   IF NODE[K+1] < 0 THEN FREEEXPTREE(-NODE[K+1]);
	   NODE[K+1]_OP;
	   OP_FDIFF(NODE[K+2]);
	   IF NODE[K+2] < 0 THEN FREEEXPTREE(-NODE[K+2]);
	   NODE[K+2]_OP;
	   RETURN(L);
	END;

	ERROR("UNABLE TO DIFFERENTIATE "&NAME[FCT]);

L2:
	COMMENT DIFFERENTIATE A USER FUNCTION;

        L_NODE[IDX[B]+1];
	COMMENT L = POINTER TO FORMAL ARGLIST OF FUNC TO DIFFERENTIATE;
	K_0;	COMMENT K = ARGUMENT NUMBER;

	M_ZERO;
	WHILE AA NEQ 0 DO
	BEGIN
	   IF (K_K+1)>A[L] THEN ERROR(S&" CALLED WITH TOO MANY ARGUMENTS");
	   N_FTCOPY(-TOP);
	   OP_FTMULT(N,FDIFF(NODE[AA]));
           IF OP NEQ ZERO THEN BEGIN 
	   NODE[2-N]_SYMTABENTRY(MAKEDIFFNAME(B,A[L+K])); 
           M_FTADD(M,OP) END;
	   AA_NODE[AA+1];
	END;
	RETURN(M);


DIFFSUM:
COMMENT  SUM OPERATOR, INTEGRAL OPERATOR
         D(SUM(I,A,B,E)) = SUM(I,A,B,D(E))
         D(INTEGRAL(X,A,B,E)) = E(B)*B DIFF T -E(A)*A DIFF T +INTEGRAL(X,A,B,E DIFF T)
;
        K_FTCOPY(-TOP);
        AA_NODE[1-K];
        FOR OP_1 STEP 1 UNTIL 3 DO AA_NODE[AA+1];
        L_NODE[AA];
        NODE[AA]_FDIFF(L);
       IF NODE[AA]=ZERO THEN BEGIN FREEEXPTREE(-K); K_ZERO END ELSE 
  COMMENT ROOTFCT DERIVATIVE.;
        IF B=ROOTOP THEN BEGIN
           NEWNODE(N,NODE);
           NODE[N]_FUNCTIONF;
           NODE[N+2]_EVALOP;
           NEWNODE(M,NODE);
           NODE[N+1]_M;
           OP_A1;
           A1_NODE[M]_NODE[NODE[1-K]];
           NEWNODE(B,NODE);
           NODE[M+1]_B;
           NODE[B]_K;
           NEWNODE(M,NODE);
           NODE[B+1]_M;
           NODE[M]_FTSUB(ZERO,FTDIV(NODE[AA],FDIFF(L)));
           A1_OP;
           NODE[M+1]_0;
           NODE[AA]_L;
           RETURN(-N) END;

        IF L<0 THEN FREEEXPTREE(-L);
	IF B=SUMOP THEN BEGIN 
        L_NODE[TOP+1];M_NODE[L+1];N_NODE[M+1];AA_NODE[N+1];
	L_NODE[L];M_NODE[M];N_NODE[N];AA_NODE[AA];

	K_FTADD(FTSUB(ZERO,FTMULT(TREESUBS(L,FTCOPY(AA),M),FDIFF(M))),K);
	K_FTADD(FTMULT(TREESUBS(L,FTCOPY(AA),N),FDIFF(N)),K)
                           END;
	RETURN(K);





UFOP:	COMMENT BUILT-IN OPERATORS;

	AA_NODE[AA];

        IF L<-18 THEN GOTO GIVEUP;

	CASE -L OF BEGIN
	BEGIN	COMMENT EXP(X)
			D(EXP(X)) = D(X)*EXP(X);

	   RETURN(FTMULT(FDIFF(AA),FTCOPY(-TOP)));
	END;


	BEGIN	COMMENT LOG(X)

		D(LOG(X)) = 1/X*D(X);

	   L_FTDIV(ONE,FTCOPY(AA));
	   RETURN(FTMULT(L,FDIFF(AA)));
	END;

	
	BEGIN	COMMENT LOG10(X)

		D(LOG10(X)) = .4342945/X*D(X);

	   L_FTDIV(STORECON(.4342945),FTCOPY(AA));
	   RETURN(FTMULT(L,FDIFF(AA)));
	END;


	BEGIN	COMMENT SQRT(X)
		
		D(SQRT(X)) = D(X)/(2*SQRT(X));

	   L_FTMULT(STORECON(2),FTCOPY(-TOP));
	   RETURN(FTDIV(FDIFF(AA),L));
	END;


	BEGIN 	COMMENT SIN(X)

		D(SIN(X)) = COS(X)*D(X);

	   RETURN(FTMULT(FTFUNC("COS",FTCOPY(AA)),FDIFF(AA)));

	END;


	BEGIN	COMMENT SIND(X)

		D(SIND(X)) = COSD(X)*.0107372152*D(X);

	   RETURN(FTMULT(FTFUNC("COSD",FTCOPY(AA)),FTMULT(STORECON(.0107372152),FDIFF(AA))));

	END;


	BEGIN	COMMENT COS(X)

		D(COS(X)) = -SIN(X) * D(X);

	   NEWNODE(L,NODE);
	   NODE[L]_UMINUS;
	   NODE[L+1]_FTFUNC("SIN",FTCOPY(AA));
	   RETURN(FTMULT(-L,FDIFF(AA)));
	END;


	BEGIN	COMMENT COSD(X)

		D(COSD(X)) = -SIND(X)*.0107372152*D(X);

	   NEWNODE(L,NODE);
	   NODE[L]_UMINUS;
	   NODE[L+1]_FTFUNC("SIND",FTCOPY(AA));
	   RETURN(FTMULT(-L,FTMULT(STORECON(.0107372152),FDIFF(AA))));
	END;


	BEGIN	COMMENT SINH(X)

		D(SINH(X)) = COSH(X)*D(X);

	   RETURN(FTMULT(FTFUNC("COSH",FTCOPY(AA)),FDIFF(AA)));

	END;


	BEGIN	COMMENT COSH(X)

		D(COSH(X)) = SINH(X)*D(X);

	   RETURN(FTMULT(FTFUNC("SINH",FTCOPY(AA)),FDIFF(AA)));

	END;


	BEGIN	COMMENT TANH(X)

		D(TANH(X)) = D(X)/(COSH(X)^2);

	   NEWNODE(L,NODE);
	   NODE[L]_POWEROP;
	   NODE[L+1]_FTFUNC("COSH",FTCOPY(AA));
	   NODE[L+2]_STORECON(2.);
	   RETURN(FTDIV(FDIFF(AA),-L));
	END;

	BEGIN	COMMENT ASIN
		
		D(ASIN(X)) = D(X)/SQRT(1-X*X);

	   L_FTMULT(FTCOPY(AA),FTCOPY(AA));
	   L_FTFUNC("SQRT",L);
	   RETURN(FTDIV(FDIFF(AA),L));

	END;

	BEGIN	COMMENT ACOS

		D(ACOS(X)) = -D(X)/SQRT(1-X*X);

	   L_FTMULT(FTCOPY(AA),FTCOPY(AA));
	   L_FTSUB(ONE,L);
	   L_FTFUNC("SQRT",L);
	   L_FTDIV(FDIFF(AA),L);
	   NEWNODE(OP,NODE);
	   NODE[OP]_UMINUS;
	   NODE[OP+1]_L;
	   RETURN(-OP);
	END;


	BEGIN	COMMENT ATAN

		D(ATAN(X)) = D(X)/(1+X*X);

	   L_FTMULT(FTCOPY(AA),FTCOPY(AA));
	   L_FTADD(ONE,L);
	   RETURN(FTDIV(FDIFF(AA),L));

	END;

	COMMENT RAN;
	GOTO GIVEUP;

COMMENT LOGGAMMA;
        GOTO GIVEUP;
        
        COMMENT INT;
        RETURN(ZERO);

        COMMENT ATAN2

         D(ATAN2(X,Y)) = D(X/Y)/(1+(X/Y)*(X/Y));

        BEGIN
	   NEWNODE(L,NODE);
	   NODE[L]_DIVIDESIGN;
	   NODE[L+1]_FTCOPY(NODE[AA]);
	   NODE[L+2]_FTCOPY(NODE[NODE[AA+1]]);
	   L_-L;
	   OP_FTMULT(L,FTCOPY(L));
	   OP_FTADD(ONE,OP);
	   L_FTDIV(FDIFF(L),OP);
	   RETURN(L);
           END;

          COMMENT MOD;
          RETURN(ONE);


	END;


GIVEUP:
	ERROR("UNABLE TO DIFFERENTIATE "&NAME[FCT]
		&" BECAUSE OF CALL TO "&S);


END;





	FCT_FUNCT;
        A1_ARG;
        T_IDX[FUNCT];
        M_FDIFF(-NODE[T]);

        COMMENT T MUST BE RESET DUE TO SECRET RECURSION. ;

        K_NODE[(T_IDX[FUNCT])+1];
        E_SYMTABENTRY(MAKEDIFFNAME(FUNCT,ARG));
        NEWNODE(T,NODE);
        NODE[T+1]_K;
        IDX[E]_T;
        IF M>0 THEN BEGIN
                COMMENT DERIVATIVE IS A CONSTANT MAKE THE FUNCTION
                        = UNARY PLUS OF THE CONSTANT;

                NEWNODE(K,NODE);
                NODE[K]_UPLUS;
                NODE[K+1]_M;
                M_K;
                END 
                ELSE M_-M;
        NODE[T]_M;
        TYPE[E]_FUNCTION;
END;
INTERNAL STRING SIMPLE PROCEDURE FIXNAME(STRING S);
COMMENT
	RETURN THE NAME OF THE FUNCTION WITH NAME STRING
	S BY CHANGING  .F.X TO F DIFF X IF NEEDED
;
BEGIN
INTEGER M,B;
STRING T;

	WHILE S="." DO M_LOP(S);
	T_NULL;
	FOR M_LENGTH(S) STEP -1 UNTIL 1 DO
	BEGIN
	   B_LOP(S);
	   T_T&(IF B ="." THEN " DIFF " ELSE B);
	END;
	RETURN(T);
END;





INTERNAL STRING SIMPLE PROCEDURE FANCYNUM(REAL R);
BEGIN  STRING S;  INTEGER I,T; LABEL EXIT;
	SETFORMAT(0,6);
      IF R=0 THEN RETURN("0") ELSE S_CVG(R);
      T_LENGTH(S);
	I_1;
	WHILE I LEQ T DO IF S[I FOR 1] ="@" THEN GOTO EXIT ELSE I_I+1;
        WHILE  S[T FOR 1]="0" OR
         S[T FOR 1]=" " DO T_T-1;
	IF S[T FOR 1] ="." THEN T_T-1;
        S_S[1 TO T];
      WHILE  S[1 TO 1]=" " DO T_LOP(S);
EXIT:      RETURN(S)
END;
INTERNAL STRING PROCEDURE FCTTYPE(INTEGER F);
   
COMMENT
        TYPE THE DEFINITION OF THE FUNCTION WITH SYMTAB IDX F

;
BEGIN
INTEGER J,K,L,M,B;
STRING S;



BOOLEAN SIMPLE PROCEDURE NEEDP(INTEGER OP,TREE);
COMMENT
	RETURN TRUE IF THE EXPRESSION TREE MUST BE
	ENCLOSED IN PARENTHESES WHEN JOINED BY
	OPERATOR OP
;

BEGIN

	IF TREE>0 THEN RETURN(FALSE);

	TREE_NODE[-TREE];
	IF TREE = FUNCTIONF THEN RETURN(FALSE);


	IF OP = MULTSIGN THEN
	   RETURN(NOT(TREE=MULTSIGN OR TREE=POWEROP));

	IF OP = DIVIDESIGN THEN
	   RETURN(NOT(TREE=POWEROP));

	IF OP = PLUS THEN 
	   RETURN(NOT(TREE GEQ POWEROP AND TREE LEQ PLUS));

	IF OP = MINUS OR OP = UMINUS THEN
	   RETURN(NOT(TREE GEQ POWEROP AND TREE LEQ DIVIDESIGN));


	RETURN(TRUE);

END;








RECURSIVE STRING PROCEDURE FUNCST(INTEGER T);
COMMENT
        RETURN THE STRING CORRESPONDING TO THE FUNCTION STRUCTURE T

;
BEGIN
INTEGER N1,N2,OP;
STRING S,R;
LABEL L1,L2,LE,FTN;

PRELOAD!WITH "^","*","/","+","-","=","<","<=",">=",">","NOT ",
		" AND "," OR ","_",NULL,NULL,NULL,NULL,
		NULL,NULL,NULL,"&","&'"," ROW "," COL ","'";

SAFE OWN STRING ARRAY OPST[3:28];


        IF T>0 THEN RETURN(IF TYPE[T]=CONSTANT THEN
                        FANCYNUM(REL(VALUE[T])) ELSE IF (S_NAME[T])="." THEN FIXNAME(S) ELSE S);
        T_-T;
        OP_NODE[T];
        N1_NODE[T+1];
        N2_NODE[T+2];
        IF OP>TRANSP THEN GOTO L1;


	IF OP=FUNCTIONF THEN GOTO FTN;
	IF OP=NOTOP OR OP=UPLUS THEN
		S_OPST[OP]&FUNCST(N1)

	ELSE IF OP=TRANSP THEN S_FUNCST(N1)&"'"


	ELSE BEGIN
	   	S_FUNCST(N1);
		IF NEEDP(OP,N1) THEN S_"("&S&")";
		R_FUNCST(N2);
		IF NEEDP(OP,N2) THEN R_"("&R&")";
		S_S&OPST[OP]&R;
	END;

	RETURN(S&"");


FTN:
                        S_FIXNAME(NAME[N2])&"(";
                        WHILE N1 > 0 DO
                        BEGIN
                           S_S&FUNCST(NODE[N1])&",";
                           N1_NODE[N1+1];
                        END;
                        S_S[1 TO LENGTH(S)-1]&")";
                RETURN(S&"");




L1:        IF OP = UMINUS THEN BEGIN   COMMENT  UNARY -;

		S_FUNCST(N1);
		IF NEEDP(UMINUS,N1) THEN S_"("&S&")";
		S_"-"&S;
		GOTO L2;
                GOTO L2;
                END;

        IF OP = ABSUOP  THEN BEGIN   COMMENT ABS  ;

                S_"ABS("&FUNCST(N1)&")";
                GOTO L2;
                END;


        IF OP = IFOP THEN BEGIN   COMMENT  IF THEN ELSE  ;



                S_" IF "&FUNCST(N1)&" THEN ";
                N1_NODE[N2+1];
                N2_NODE[N2+2];

                S_S&FUNCST(N1)&" ELSE "&FUNCST(N2);
L2:                RETURN(""&S);
		END;


LE:                ERROR("***ILLEGAL FUNCTION STRUCTURE***");
                GOTO L2;

END "FUNCST";







	J_IDX[F];
	K_NODE[J+1];
	L_A[K];
	S_FIXNAME(NAME[F])&"(";

	FOR M_1 STEP 1 UNTIL L DO
		S_S&(IF TYPE[B_A[K+M]]=CONSTANT THEN FANCYNUM(REL(VALUE[B])) ELSE NAME[B])&",";
	S_S[1 TO LENGTH(S)-1];
	S_S&") = ";
	SETFORMAT(0,3);
	S_S&FUNCST(-NODE[J]);
	RETURN(S);
END "FCTTYPE";

END;
