00100	TITLE DEC340 DISPLAY CODE
00200	
00300	
00400	PHASE 0			;START PHASING ALL CODE!!!
00500	
00600	BLOCK PCHBRK		;LEAVE ROOM FOR LANGUAGE PART
00700	
00800		0		;DISPLAY NUMBER 0
00900		SIXBIT /DEC340/	;AND A NAME FOR IT.
01000	
01100	DISPATCH		;GENERATE DISPATCH TABLE.
01200	
01300	;****** DEC 340 DISPLAY SEGMENT ******
01400	
01500	?DISNUM__0		;WE ARE DISPLAY 0
01600	?DEC340__12		;DEFINE THIS CODE SO THAT CORE ROUTINES ARE RIGHT
01700	
01800	
01900	
02000	
02100	
02200	
02300	
02400	
02500	
02600	;FOLLOWING 36 VARIABLES ARE FOR 340 SERVICE OFFERED BY
02700	; THE NIH MONITOR.  THEY ARE ALL DESCRIBED IN THE APPENDIX
02800	; TO THE 'GUIDE TO THE PDP-10 TIMESHARING SYSTEM'
02900		XR (XSTAT)		;STATUS WORD
03000		XR (DISTARTADR)		;STARTING ADDRESS FOR DISPLAY
03100		XR (LPFLAG)		;LIGHT PEN FLAG
03200		XR (LPADR)		;DISPLAY ADDRESS AT LP HIT TIME
03300		XR (LPYX)		;Y,,X AT HIT TIME
03400		XR (ERRFLAG)		;ADDRESS, VIOLATION FLAG
03500		XR (ERRADR)
03600		XR (ERRYX)
03700	
03800		XR (FBXFLAG)		;FLAG THAT KEY PUSHED
03900		XR (FBXDAT)		;LIGHTS,,KEYS
04000		XR (MASK1)		;MASKS FOR CONTROLLING LIGHTS
04100		XR (MASK2)
04200		XR (MASK3)
04300		XR (MASK4)
04400		XR (MASK5)
04500	
04600		XR (GFNMODE)		;GRAPHACON MODE
04700		XR (GFNFLAG)		;FLAG THAT GFN EVENT HAPPENED
04800		XR (GFNDAT)		;DATA FOR LAST GFN EVENT
04900		XR (TRACLOC)		;POINTER TO TRACKING LOCN
05000		XR (INKLOC)		;PTR TO INK BUFFER
05100		XR (COMPSETTING)		;COMPARATOR SETTING
05200		XR (DELTA)		;EQUAL SPACE/TIME SETTING
05300		XR (UPTIM)		;UPTIME COUNT FOR MULTISTROKE
05400	
05500		XR (BFRBEGIN)		;FIRST WORD OF BUFFER
05600		XR (BFREND)		;LAST WORD OF BUFFER+1
05700		XR (BFRTIM)		;BUFFER TIMEOUT TIME
05800		XR (BFRSTAT)		;BUFFER STATUS WORD (XWD ENABLE,OVERRUN)
05900		XR (TAKER)		;POINTER TO PICK UP BUFFER ENTRIES
06000		XR (VALID)		;COUNT OF VALID CELLS IN BUFFER
06100		XR (FREEC)		;COUNT OF FREE CELLS IN BUFFER
06200	
06300	
06400		XRI__XRI+6		;SPARES....
06500	;END OF VARIABLES FOR COMMUNICATING WITH MONITOR.
06600	
06700	
06800		XR (UNLIST)		;LIST OF UNPOSTED PICS
06900		XR (PARMSAV)		;LAST PARAMETER MODE WORD.
07000		XR (XSTATV)		;SAVED DEVICE BITS.
07100	
07200	;FOLLOWING THINGS MUST BE CONSECUTIVE BECAUSE THEY ARE 'DISPLAY FILE'
07300	;FOR THE DISPLAY.  THE FIRST IS A LITTLE NULL SUBROUTINE USED
07400	;TO DECIDE WHEN THE DP IS OUT OF A BLOCK OF CORE.
07500	;THE SECOND IS A TRACKING AND INKING DISPATCH BLOCK.
07600	
07700		XR (DISNOP)		;NOP FOR THE DISPLAY
07800		XR (DISNP1)		;AND THE RETURN FROM IT.
07900	
08000		XR (IOSUBR)		;XWD 117,,0 (SCALE 0, INTENSITY 7)
08100		XR (TRCLOC)		;XWD 220000,,020000 (YBP PNT,,XBP PNT)
08200		XR (HYSTER)		;XWD 220777,,160777 (YPB 777 PNT,,XPB 777 SBR)
08300		XR (INKSBR)		;XWD DJP,,.+1 OR DJMS INK-BUFFER
08400		XR (INKSB0)		;XWD SBR,,DJP
08500		XR (INKSB1)		;XWD <FIRST DISPATCH LIST>,0
08600	
08700	;** END OF ORDER-IMPORTANT STUFF
08800	
08900	
09000		XR (MODE)		;THIS TIME'S MODE
09100		XR (MODEL)		;LAST TIME'S MODE
09200		XR (SCALE)		;CURRENT 340 SCALE
09300		XR (CURCORGET)		;POINTER TO CURRENT BLOCK OF PICTURE
09400		XR (GENTOP)		;POINTER TO FIRST BLOCK OF CURRENT PICTURE
09500		XR (BYTCOUNT)		;NUMBER OF FREE BYTES IN CURRENT BLOCK
09600		XR (NXTBYT)		;BYTE POINTER FOR NEXT BYTE
09700		XR (LEFTM)		;TEXT-OUTPUT STUFF.
09800		XR (IX)
09900		XR (TXTSCALE)
10000		XR (TXTPARM)		;END OF TEXT-OUTPUT VARIABLES.
10100	
10200		XR (EVENTS)		;MASK OF ENABLED EVENTS
10300		XR (XGFN)		;LAST X COORDINATE FROM GFN
10400		XR (YGFN)		;LAST Y COORDINATE FROM GFN
10500		XR (EFLAG)		;EVENT FLAG (SET TO 1,2)
10600	
10700	
10800	; DEFINITIONS OF THE MODES OF THE 340 DISPLAY
10900	
11000	?PRM_0
11100	?PNT_1*20000
11200	?RAS_2*20000
11300	?CHR_3*20000
11400	?VTR_4*20000
11500	?VCN_5*20000
11600	?INC_6*20000
11700	?SBR_7*20000
11800	
11900	?DJP_0			;SUBROUTINE MODE OP-CODES
12000	?DJMS_400000
12100	?DJPI_200000
12200	
12300	SMID _ <1023.0>		;SMID IS THE VIEWPORT SIZE.
12400	SMIDH _ <511.5>		;HALF-SIZE
12500	YVIEW _ <1.0>		;MAX Y VIEWPORT COORD.
12600	XVIEW _ <1.0>
12700	
12800	
12900	ENQTAB:	0.0		;NO WE ARE NOT A STORAGE TUBE.
13000		0.0		;NO WE DO NOT HAVE 3-D HARDWARE
13100		1.0		;YES WE HAVE A TABLET
13200		1.0		;YES WE HAVE KEYS
13300		SMID		;NUMBER OF POINTS IN UNIT VIEWPORT
13400		10.0		;NUMBER OF INCHES IN UNIT VIEWPORT
13500		XVIEW		;MAXIMUM X VIEWPORT
13600		YVIEW		;MAXIMUM Y VIEWPORT
13700	
13800	CHARTB:  BEGIN CHARACTER 
13900		N__0
14000		Y__3
14100		T__1		;TRANSLITERATE
14200	
14300		BYTE (2) N,N,N,N,N,N,N,N,N,N,Y,N,N,Y,N,N,N,N	; 0-21
14400		BYTE (2) N,N,N,N,N,N,N,N,N,N,N,N,N,N,Y,Y,Y,Y	; 22-43
14500		BYTE (2) Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y	; 44-65
14600		BYTE (2) Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y	; 66-107
14700		BYTE (2) Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y	; 110-131
14800		BYTE (2) Y,N,N,N,N,N,N,T,T,T,T,T,T,T,T,T,T,T	; 132-153
14900		BYTE (2) T,T,T,T,T,T,T,T,T,T,T,T,T,T,T,N,N,N	; 154-175
15000		BYTE (2) N,N					; 176-177
15100		BEND
     
00100	;**** THIS PART OF THE CODE IS STRICTLY DEPENDENT UPON THE 340 ****
00200	
00300	COMMENT $
00400	
00500	A WORD ABOUT THE DATA STRUCTURES SET UP FOR THE 340 DISPLAY.
00600	THE DEFINITIONS OF THE SYMBOLS IN THIS AREA ARE GIVEN ABOVE.
00700	
00800	CORE FOR THE DISPLAY FILE MAY BE ALLOCATED IN EITHER SEGMENT.
00900	IF THE VARIABLE .SEG(S) IS 0 THEN THE LOW SEGMENT IS USED.
01000	CORE ALLOCATION IS DONE VIA THE LANGUAGE CORE ALLOCATION
01100	ROUTINES. IF .SEG(S) IS -1 THEN A SEPARATE HIGH SEGMENT IS
01200	USED FOR THE DISPLAY FILE, AND OMNIGRAPH MAINTAINS A FREE
01300	SPACE LIST.  .SEG(S) IS SET WHEN DINI IS CALLED.
01400	
01500	A PICTURE IS A GROUP OF FREE-STORAGE BLOCKS, LINKED THROUGH -1(B).
01600	IF A BLOCK MUST BE BROKEN, A JUMP IS PLANTED INTO THE NEXT BLOCK.
01700	THE FIRST BLOCK IS SOMEWHAT SPECIAL, HAVING THE PICTURE
01800	NUMBER, THE ADDRESS OF THE DJPI, AND OTHER STUFF AT THE HEAD.
01900	THE LAYOUT IS:
02000	
02100	
02200		-LENGTH ,, ==> NEXT BLOCK	(%DNEXT)
02300		 PICTURE NUMBER			(%DNUM)
02400		 ADDRESS OF DJPI FOR THIS PIC	(%DJM)
02500			LEFT HALF IS -1 IF THIS PIC POSTED, 0 IF NOT
02600		 0 -- PLACE WHERE DJMS COMES
02700			...
02800			...
02900			DISPLAY CODE
03000			...
03100			DJPI THROUGH THE 0
03200				OR DJP TO NEXT BLOCK.
03300	
03400	FURTHER, THERE IS A MAIN DISPATCH TABLE FOR THE DISPLAY PROCESSOR.
03500	THE ADDRESS AT DISTARTADR POINTS TO IT.  THESE TOO MAY BE LINKED
03600	TO ANY EXTREME.  THE FIRST 'SBR' WORD HAS THE 'SYNC' BIT ON.
03700	
03800	THESE BLOCKS ARE USED TO LOCATE ANY PICTURE WHICH MAY BE POSTED,
03900	SIMPLY BY SEARCHING FOR THE DJMS TO THE PICTURE, THEN REFERENCING
04000	THE DATA DESCRIBED IMMEDIATELY ABOVE.
04100	
04200	FOR UNPOSTED PICTURES, THE CELL .UNLIST IS A TWO-WAY LINKED
04300	LIST OF SUCH PICTURES; THE LINKS GO THROUGH THE DJPI WORD.
04400	
04500	
04600	$
04700	
04800	?%DNEXT__-3
04900	?%DNUM __-2
05000	?%DJM  __-1
05100	
05200	
05300	?DLEN __ 20		;TWENTY DISPATCHES AT A TIME.
05400	
05500	
05600	DEFINE TRACKS (NAM,ARG) <
05700		TTCALL 3,[ASCIZ /TRACKS: NAM /](S)
05800		IFDIF <ARG><>,<XWD 11000,ARG
05900	>
06000		TTCALL 3,[ASCIZ /
06100	/](S)
06200	>
06300	
06400	
06500	
06600	;INITIALIZATION CODE.
06700	
06800	QCURSOR: SUB	P,[XWD 2,2](S)	;DELETE TWO ARGUMENTS
06900	QDONE:	JRST	@.RET(S)	;NOTHING TO DO HERE!
07000	
07100	QSTAT:	POP	P,A		;THROW AWAY ARGUMENT AND
07200		JRST	@.RET(S)	;JUST RETURN
07300	
07400	QGET:	TLZ	DISRUN		;ASSUME WILL NOT GET IT
07500	;	TRACKS	<GET>
07600		SETZM	.RUN(S)
07700	IFNDEF EXPORT,<
07800		MOVEI	B,XSTAT(R)		;SEIZE DISPLAY
07900		HRLI	B,1
08000		DISCAL	B
08100	>	;FOR EXPORT, CAN NEVER GET DISPLAY
08200		 JRST	 @.FRET(S)	;ERROR -- CANNOT GET IT.
08300		TLO	DISRUN
08400		SETOM	.RUN(S)
08500		HRRZ	B,XSTATV(R)	;GET SAVED DEVICES
08600		IOR	B,[XWD 3,1](S)	;START DISPLAY AND OTHERS.
08700		DISCAL	B		;LIKE SO.
08800		HLRZ	B,BFRSTAT(R)	;SEE IF ANYONE ENABLED IN BUFFER
08900		TRNN	B,7		;?
09000		 JRST	 @.TRET(S)	;NO
09100		IOR	B,[XWD 10,200070](S) ;MAKE BUFFER CALL (CLEAR AND ENABLE)
09200		DISCAL	B		;RESTART BUFFER
09300		 JFCL
09400		JRST	@.TRET(S)	;AND RETURN TRUE.
09500	
09600	QREL:	TLZ	DISRUN		;DISPLAY NO LONGER RUNNING.
09700	;	TRACKS	<REL>
09800		SETZM	.RUN(S)
09900		MOVE	A,XSTAT(R)		;GET CURRENT DEVICES.
10000		MOVEM	A,XSTATV(R)	;SAVE FOR LATER.
10100		MOVSI	A,5
10200		DISCAL	A
10300		JRST	@.RET(S)	;RETURN.
10400	
10500	
10600	
10700	
10800	QPOST:	MOVE	A,(P)		;PICTURE NUMBER
10900	;	TRACKS	<POST>,<A>
11000		TLNE	PICOPN		;IS THERE AN OPEN PICTURE?
11100		CAME	A,.CURPIC(R)	;AND IS IT THIS ONE?
11200		 JRST	 QPOST0(S)	;NO
11300		PUSHJ	P,CLOSE(S)	;CLOSE PRESENT PIC.
11400		JRST	QPOST(S)	;LOOP TO GET PIC NUM
11500	QPOST0:	PUSHJ	P,POST(S)	;GO POST IT.
11600	QPOST1: MOVE	A,.POSTN(R)	;RETURN NUMBER POSTED
11700		POP	P,(P)		;GET STACK IN GOOD SHAPE
11800		JRST	@.IRET(S)	;AND RETURN NUMBER OF PICS POSTED
11900	
12000	QUNPOST: MOVE	A,(P)		;GET PIC NUMBER
12100	;	TRACKS	<UNPOST>,<A>
12200		PUSHJ	P,UPOST(S)
12300		JRST	QPOST1(S)	;AND RETURN NUMBER OF PICS POSTED
12400	
12500	
12600	QKILL:	POP	P,A		;GET PIC NUMBER
12700	;	TRACKS	<KILL>,<A>
12800		PUSHJ	P,FNDUN(S)	;TRY TO FIND IT UNPOSTED.
12900		JUMPN	B,.+1(S)
13000		PUSHJ	P,UPOST(S)	;TRY TO UNPOST IT THEN
13100		JUMPE	B,@.RET(S)	;IF NOT THERE EITHER, BYE
13200		PUSHJ	P,REMUN(S)	;REMOVE IT FROM UNPOSTED LIST.
13300		PUSHJ	P,KILL(S)	;KILL STORAGE.
13400		JRST	@.RET(S)	;AND RETURN.
13500	
13600	
13700	QAPPEND: TLNE	PICOPN		;IF A PICTURE IS OPEN
13800		 PUSHJ	 P,CLOSE(S)	;CLOSE IT.
13900		TLO	APPEND
14000		JRST	QOP0(S)		;AND JOIN OPEN CODE.
14100	QOPEN:	TLNE	PICOPN		;IS THERE A PICTURE OPEN?
14200		 PUSHJ	 P,CLOSE(S)	;YES -- CLOSE IT.
14300		TLZ	APPEND		;NOT APPENDING
14400	QOP0:	TLO	PICOPN		;THERE IS ONE OPEN NOW.
14500		POP	P,.CURPIC(R)	;SAVE CURRENT PICTURE NUMBER.
14600	
14700	;	MOVE	A,.CURPIC(R)
14800	;	TRACKS	<OPEN OR APPEND>,<A>	;PREVIOUS STMT MUST BE 'UNCOMMENTED' TOO
14900	
15000		SETZM	CURCORGET(R)	;FIRST-TIME CALL!
15100		PUSHJ	P,BLOCK(S)	;GET THE BLOCK STARTED.
15200	;	MOVE	B,CURCORGET(R)	;CURRENT POINTER
15300		HRRZM	B,GENTOP(R)	;POINTER TO FIRST BLOCK
15400		TLNE	APPEND		;ARE WE APPENDING?
15500		 JRST	 QOP1(S)	;YES -- IGNORE THIS
15600		MOVSI	A,-6
15700		PUSHJ	P,STOBYT(S)	;AND STORE IT. MANY TIMES
15800		AOBJN	A,.-1(S)
15900		SKIPA	A,PARMSAV(R)	;GET PARAMETER MODE WORD FULL OF STUFF
16000	QOP1:	MOVEI	A,0		;PARM MODE WORD SO WE CAN ADJUST
16100		PUSHJ	P,STOBYT(S)
16200		SETZM	MODE(R)
16300		SETZM	MODEL(R)
16400		SETOM	.IXBEAM(R)	;AND MAKE SURE IT DOES NOT COMPARE
16500		JRST	@.RET(S)	;RETURN
16600	
16700	
16800	
16900	QCLOSE:	;	TRACKS	<CLOSE>
17000		PUSHJ	P,CLOSE(S)	;CLOSE THE PRESENT PICTURE
17100		JRST	@.RET(S)	;AND RETURN.
17200	
     
00100	;PLOT ROUTINE FOR 340.
00200	
00300	PLTIT:	PUSH	P,[0](S)	;COUNTER.
00400	PLT0:	MOVEI	F,T3(S)		;ADDRESS OF TEST ROUTINE.
00500		MOVEI	A,0		;COUNTER
00600		PUSHJ	P,FINDA(S)	;LOOK FOR NTH ENTRY.
00700		POP	P,F		;IF EVER GET HERE, DONE.
00800		POPJ	P,
00900	
01000	T3:	TLNN	B,DJMS		;IT IS A CALL?
01100		 JRST	 FINNO(S)	;NO
01200		CAME	A,-1(P)		;HAVE WE REACHED N?
01300		 AOJA	 A,FINNO(S)	;NO
01400		POP	P,A		;YES -- REMOVE RETURN.
01500		AOS	(P)		;BUMP N FOR NEXT TIME.
01600		ADDI	B,%DNUM		;B ==> GETCOR POINTER.
01700		ADDBIT	(B)		;FLIP 400000 BIT IF HISEG
01800		HRROI	A,(B)		;XWD -1,ADDRESS
01900		PUSHJ	P,PL(S)		;WRITE
02000	PLT1:	MOVEI	C,(B)
02100		HLL	B,-1(B)		;COUNT
02200		MOVE	A,-1(B)		;GET WORD.
02300		PUSHJ	P,PL(S)		;WRITE IT.
02400		AOBJN	B,.-2(S)	;LOP FOR ALL WORDS.
02500		HRRZ	B,-1(C)		;NEXT BLOCK FOR THIS PICTURE.
02600		JUMPN	B,PLT1(S)	;AND DUMP IT TOO.
02700		JRST	PLT0(S)		;GET NEXT PICTURE.
02800	
02900	
     
00100	
00200	
00300	PGEN:	TLNE	DISIFY		;IF WE ARE NOT INTENSIFYING
00400		 JRST	 PGEN0(S)	;AND
00500		CAMN	B,.IXBEAM(R)	;IF BEAM IS AT SAME LOC AS LAST TIME
00600		CAME	C,.IYBEAM(R)	;?
00700		 JRST	 PGEN0(S)	;
00800		POPJ	P,		;NO NEED TO DO ANYTHING
00900	PGEN0:	PUSH	P,B		;SAVE X
01000		MOVEM	B,.IXBEAM(R)
01100		MOVEM	C,.IYBEAM(R)	;SAVE Y COORDINATE
01200		PUSHJ	P,PGENY(S)	;LIKE SO
01300		POP	P,C		;RESTORE X AND FALL INTO PGENX
01400	PGENX:	MOVEI	A,0		;INITIALIZE FOR X.
01500		TLZE	DISIFY		;PUT A DOT THERE?
01600		 TRO	 A,2000		;TURN ON INTENSIFY BIT.
01700		SKIPA
01800	PGENY:	MOVEI	A,200000
01900		ANDI	C,1777		;LIMIT TO 10 BITS.
02000		IORI	C,(A)		;OR IN OP BITS AND IFY BIT
02100		PUSH	P,C		;SAVE OVER SNM CALL
02200		MOVEI	A,PNT
02300		PUSHJ	P,SNM(S)	;GET POINT MODE
02400		POP	P,A		;GET INSTRUCTION BACK
02500		JRST	STOBYT(S)	;AND STORE IT.
02600	
02700	
02800	VGEN:	MOVE	A,-2(P)		;DELTA X
02900		IDIV	A,SCALE(R)	;DIVIDE BY SCALE FACTOR
03000		MOVEM	A,-2(P)		;PUT BACK AS DELTAX
03100		IMUL	A,SCALE(R)	;NOW MULTIPLY BACK
03200		ADDM	A,.IXBEAM(R)	;AND BUMP IBEAM
03300		MOVE	A,-1(P)		;SAME FOR Y
03400		IDIV	A,SCALE(R)
03500		MOVEM	A,-1(P)
03600		IMUL	A,SCALE(R)
03700		ADDM	A,.IYBEAM(R)
03800		MOVEI	A,VTR
03900		PUSHJ	P,SNM(S)	;GET VECTOR MODE.
04000	VCUR:	MOVM	A,-2(P)		;DELTAX
04100		MOVM	B,-1(P)		;DELTAY
04200		CAIG	A,177
04300		CAILE	B,177
04400		 JRST	 RECUR(S)	;TOO LARGE IN ONE BIGHT
04500		LSH	B,=8
04600		IOR	A,B
04700		SKIPGE	-2(P)
04800		 TRO	 A,200		;IF DELTAX NEGATIVE
04900		SKIPGE	-1(P)
05000		 TRO	 A,100000	;IF DELTAY NEGATIVE
05100		TRO	A,200000	;INTENSIFY
05200		PUSHJ	P,STOBYT(S)
05300		SUB	P,[XWD 3,3](S)
05400		JRST	@3(P)		;RETURN.
05500	
05600	RECUR:	CAMGE	A,B		;IS X>Y ?
05700		 JRST	 XLESSY(S)	;NO
05800		MOVEI	C,177
05900		SKIPGE	-2(P)
06000		 MOVNI	 C,177
06100		PUSH	P,C		;THIS AMOUNT OF X WILL BE SHOWN
06200		MOVN	E,C
06300		MOVEI	C,177
06400		IMUL	C,-2(P)		;TIMES DELTA Y
06500		IDIV	C,A		;DIVIDED BY DELTA X
06600	RECGO:	PUSH	P,C
06700		MOVNS	C
06800		ADDM	C,-3(P)		;REDUCE DY
06900		ADDM	E,-4(P)		;REDUCE DX
07000		PUSHJ	P,VCUR(S)	;DO IT AGAIN.
07100		JRST	VCUR(S)		;AND PUT OUT LAST LITTLE BIT.
07200	
07300	XLESSY:	MOVEI	C,177
07400		IMUL	C,-2(P)
07500		IDIV	C,B		;177*X/(ABS Y)
07600		PUSH	P,C
07700		MOVN	E,C
07800		MOVEI	C,177
07900		SKIPGE	-2(P)
08000		MOVNI	C,177
08100		JRST	RECGO(S)
08200	
08300	
08400	
08500	;QINT	SET INTENSITY LEVEL
08600	
08700	QINT:	POP	P,A		;GET ARG IN RANGE 0 LEQ 1
08800		FMPR	A,[7.999](S)	;GET IN OUR UNITS.
08900		PUSHJ	P,@.FIX(S)	;FIX RESULT.
09000		DPB	A,[POINT 3,PARMSAV(R),35](S)	;SAVE IT.
09100		TLNE	PICOPN		;ONLY PUT OUT INSTR. IF PIC GOING.
09200		 PUSHJ	 P,PRMPUT(S)	;CALL SUBR.
09300		JRST	@.RET(S)	;EXIT.
09400	
09500	
09600	PRMPUT:	MOVEI	A,PRM		;GET PARAMETER MODE
09700		PUSHJ	P,SNM(S)
09800		MOVE	A,PARMSAV(R)
09900		JRST	STOBYT(S)	;STORE THE BYTE.
     
00100	;ROUTINES FOR TEXT OUTPUT.
00200	
00300	CTAB:	XWD 400000+40*=4,CHARW  	;CHARW _ 4*SCALE+1
00400		XWD 400000+40*=6,CHARH		;CHARH _ 6*SCALE+1
00500		XWD 40*=6,BOXW		;BOXW _ 6*SCALE
00600		XWD 40*=11,BOXH		;BOXH _ 11*SCALE
00700	
00800	
00900	;QTEXT	CALLED FOR EACH CHAR FROM THE LANGUAGE SEGMENT
01000	;	A HAS CHARACTER OR
01100	;	A=-1  START STRING (AND UPDATE BOX,CHARACTER PARAMETERS)
01200	;	A=-2  END STRING
01300	
01400	QTEXT:	CAME	A,[-1](S)	;START STRING?
01500		 JRST	 NOTBEG(S)	;NO
01600		SKIPGE	A,TSCAL(R)	;GET DTSCAL PARAMETER
01700		 TLZA	 TEXTON		;IF NEGATIVE, SAY TEXT MAY EXTEND OUTSIDE VIEWPORT
01800		TLO	TEXTON
01900		MOVMS	A		;GET MAGNITUDE
02000		CAMLE	A,[0.048](S)
02100		 MOVE	 A,[0.048](S)	;LIMIT HIS SIZE.
02200		FMPR	A,[107.73](S)	;MAGIC NUMBER
02300		LDB	A,[POINT 2,A,8](S) ;GET LOW BITS OF EXPONENT
02400		MOVEI	B,1		;COMPUTE ACTUAL SCALE FACTOR
02500		LSH	B,(A)		;BY SHIFTING.
02600		MOVEM	B,TXTSCAL(R)	;AND SAVE IT.
02700		IMULI	B,=6		;GET WIDTH IN RASTER
02800		MOVEM	B,IX(R)		;UNITS.
02900		TRO	A,4		;ENABLE SCALE CHANGE.
03000		DPB	A,[POINT 3,TXTPARM(R),31](S) ;SAVE AS PARM WORD.
03100		MOVEI	C,.XPM(R)	;POINTER TO MULTIPLIERS.
03200		MOVEI	B,CHARW(R)	;FIXUP CTAB
03300		HRRM	B,CTAB(S)
03400		MOVEI	B,CHARH(R)
03500		HRRM	B,CTAB+1(S)
03600		MOVEI	B,BOXW(R)
03700		HRRM	B,CTAB+2(S)
03800		MOVEI	B,BOXH(R)
03900		HRRM	B,CTAB+3(S)
04000		MOVEI	B,CTAB(S)	;POINTER TO OP-TABLE.
04100		HRLI	B,-4		;NUMBER OF THINGS TO DO.
04200	CLOP:	LDB	A,[POINT 4,(B),12](S) ;MULTIPLIER
04300		IMUL	A,TXTSCAL(R)	;*SCALE
04400		SKIPGE	(B)
04500		 ADDI	 A,1		;+1 IF NEEDED
04600		PUSHJ	P,@.FLOAT(S)	;FLOAT IT.
04700		MOVE	E,[PUSHJ P,CODE2(S)](S) ;GET INSTRUCTION.
04800		MOVE	F,[PUSHJ P,CONV2(S)](S)
04900		TLNE	LAST3D		;IF LAST POSITION WAS 3-D
05000		 JRST	 [FDVR A,.X3M-.XPM(C) ;GET NORMALIZED VIEWPORT COORD
05100			  FMPR A,.ZBEAM(R) ;AND FIX FOR THIS DEPTH.
05200			  TRC E,CODE2CODE3 ;CHANGE TO TEST CODE3.
05300			  TRC F,CONV2CONV3 ;CHANGE TO POSITION WITH CONV3
05400			  JRST .+2(S)](S)
05500		FDVR	A,.XPM-.XPM(C)	;COMPUTE WIDTH IN PAGE COORDS.
05600		MOVEM	A,@(B)		;AND SAVE IT.
05700		MOVEM	E,CHART(R)	;CHARACTER TEST ROUTINE.
05800		MOVEM	F,CHARP(R)	;CHARACTER POSITION ROUTINE.
05900		HRRZI	A,.YPM(R)	;SWITCH TO OTHER COORDINATES
06000		XORI	A,.XPM(R)
06100		TDC	C,A
06200	
06300		AOBJN	B,CLOP(S)	;LOOP UNTIL DONE.
06400		MOVE	A,.XBEAM(R)	;GET CURRENT BEAM LOCN.
06500		MOVEM	A,LEFTM(R)		;AND SAVE AS LEFT MARGIN.
06600		TLZ	FTEMP1!DISIFY	;IN CASE WE NEED TO POSITION BEAM.
06700					;FTEMP1 SAYS WE HAVE NOT YET GONE INTO CHR MODE
06800		JRST	QREN(S)		;INITIALIZE BYTE POINTERS
06900	
07000	NOTBEG:	TLNE	A,-1		;SEE IF LAST CHARACTER
07100		 JRST	 [PUSHJ P,ENDC(S) ;DUMP BUFFER
07200			  JRST PRMPUT(S)](S) ; AND RETURN TO OLD MODE AND SCALE.
07300		CAIN	A,15		;CARRIAGE RETURN?
07400		 JRST	 CR(S)		;YES
07500		CAIN	A,12		;LINE FEED?
07600		 JRST	 LF(S)		;YES
07700		TRZN	A,100		;CONVERT TO SIXBIT
07800		 JRST	 .+4(S)
07900		TRZ	A,40
08000		CAILE	A,32
08100		MOVEI	A,"*"		;ASTERIX FOR UNRECOGNIZABLES.
08200		PUSH	P,A		;SAVE CODE
08300		MOVE	B,.XBEAM(R)	;FIND OUT IF WE ARE ON SCREEN
08400		MOVE	C,.YBEAM(R)
08500		MOVE	D,.ZBEAM(R)
08600		XCT	CHART(R)	;EXECUTE CHARACTER TEST.
08700		JUMPN	A,TXT0(S)	;NOT ON SCREEN.
08800		FADR	B,BOXW(R)
08900		FADR	C,BOXH(R)	;TRY UPPER RIGHT CORNER OF BOX.
09000		XCT	CHART(R)	;CHARACTER TEST.
09100	TXT0:	MOVE	B,.XBEAM(R)	;RESTORE BEAM POSITION.
09200		MOVE	C,.YBEAM(R)
09300		XCT	CHARP(R)	;GET CHARACTER POSITION.
09400		JUMPN	A,TRYTXT(S)	;SEE IF SHOULD BE DISPLAYED NONETHELESS
09500	TXT1:	CAMN	B,.IXBEAM(R)	;SEE IF WE NEED TO PUT OUT A POINT-
09600		CAME	C,.IYBEAM(R)	;MODE INSTRUCTION.
09700		 JRST	 [PUSHJ P,ENDC(S)	;YES -- DUMP CHARACTER BUFFER
09800			  PUSHJ P,PGEN(S)	;NOW THE POINT INSTR.
09900			  JRST .+1(S)](S)
10000	
10100	CC:	TLOE	FTEMP1		;HAVE WE ACTUALLY STARTED STRING YET?
10200		 JRST	 CC1(S)		;YES -- GO AHEAD AND STORE.
10300		MOVEI	A,PRM		;GET PARAMETER MODE.
10400		PUSHJ	P,SNM(S)	;
10500		MOVE	A,TXTPARM(R)	;AND GO INTO CORRECT SCALE.
10600		PUSHJ	P,STOBYT(S)	;STORE BYTE.
10700	CC1:	SKIPN	.COD1(R)	;ENUF ROOM?
10800		 PUSHJ	 P,QTST(S)	;STORE BYTE AND REINITIALIZE
10900		SOS	.COD1(R)	;ONE FEWER CHAR
11000		MOVE	A,(P)		;GET CHARACTER IN SIXBIT
11100		IDPB	A,.COD2(R)	;STORE IT AWAY
11200	UPDT:	MOVE	A,BOXW(R)
11300		FADM	A,.XBEAM(R)	;BUMP PAGE COORD.
11400		MOVE	A,IX(R)
11500		ADDM	A,.IXBEAM(R)	;AND SCREEN COORD.
11600		JRST	POPAJ(S)	;ADJUST STACK AND RETRUN.
11700	
11800	TRYTXT:	TLNE	TEXTON		;SEE IF HE INSISTS ON STAYING ON VIEWPORT
11900		 JRST	 UPDT(S)	;YES -- RETURN WITHOUT DISPLAYING.
12000		MOVN	D,IX(R)		;GET CURRENT CHARACTER SIZE
12100		ADDI	D,=1023		;AND FORM RIGHT EDGE TEST
12200		JUMPL	B,UPDT(S)	;IF X NEGATIVE
12300		JUMPL	C,UPDT(S)	;OR Y NEGATIVE
12400		ADD	C,IX(R)		;ACCOUNT FOR INCREASED HIEGHT.
12500		CAIG	B,(D)		;OR X GREATER THAN RIGHT EDGE
12600		CAILE	C,(D)		;OR Y GREATER THAN RIGHT EDGE.
12700		 JRST	 UPDT(S)	;THEN DO NOT DISPLAY.
12800		SUB	C,IX(R)		;AND PUT IT BACK FOR OUTPUT
12900		JRST	TXT1(S)		;OTHERWISE REJOIN CHARACTER CODE.
13000	
13100	LF:	MOVN	A,BOXH(R)	;PUT THE Y SPOT DOWN.
13200		FADM	A,.YBEAM(R)
13300		JRST	ENDC(S)		;AND DUMP CURRENT CHARS.
13400	CR:	MOVE	A,LEFTM(R)		;LEFT MARGIN
13500		MOVEM	A,.XBEAM(R)	;STORE AS BEAM LOCN.
13600					;AND FALL IN TO ESCAPE, WHICH WE WILL SURELY NEED TO DO
13700	
13800	; SUBROUTINE TO DUMP CURRENT CHARACTER BUFFER AND
13900	; FINISH UP.
14000	; DESTROYS AC 'A'; CAREFULLY PRESERVES B,C
14100	ENDC:	MOVE	A,.COD1(R)	;GET COUNT
14200		CAIN	A,3		;ANY CHARACTERS IN BUFFER?
14300		 POPJ	 P,		;NO -- RETURN -- ALL DONE.
14400		PUSH	P,B		;SAVE X COORDINATE IN CASE CLOBBERED BY STOBYT
14500		PUSH	P,C
14600		SKIPN	A		;IF NO ROOM REMAINS.
14700		 PUSHJ	 P,QTST(S)	;DUMP THIS 18-BIT BYTE.
14800		MOVEI	A,37		;ESCAPE CODE.
14900		IDPB	A,.COD2(R)	;AND PUT IT DOWN.
15000		PUSHJ	P,QTST(S)	;STORE THE 18-BIT BYTE.
15100		SETOM	MODEL(R)
15200		SETZM	MODE(R)		;BACK IN PARM MODE.
15300		POP	P,C
15400		POP	P,B		;RESTORE
15500		POPJ	P,		;ALL DONE.
15600	
15700	
15800	;SUBROUTINE TO PUT OUT CHARACTER-MODE WORD.
15900	; FROM CURRENT CHARACTER BUFFER.
16000	QTST:	MOVEI	A,CHR
16100		PUSHJ	P,SNM(S)	;GET CHARACTER MODE.
16200		MOVE	A,DISNOP(R)
16300		PUSHJ	P,STOBYT(S)	;GO STORE THE WORD.
16400	QREN:	MOVEI	A,3		;NEW BYTE COUNT
16500		MOVEM	A,.COD1(R)	;
16600		MOVE	A,[POINT 6,DISNOP(R),17](S) ;BYTE POINTER
16700		MOVEM	A,.COD2(R)	;SAVED.
16800		POPJ	P,
16900	
     
00100	
00200	;MISCELLANEOUS ROUTINES USED BY THE ABOVE SUBROUTINES
00300	
00400	;MANAGERS OF THE UNPOSTED LIST.  
00500	; REMUN		REMOVE A PICTURE FROM THE UNPOSTED
00600	;		LIST.  B==> DJPI WORD OF THE PICTURE.
00700	
00800	;PUTUN		PUT A PICTURE ON THE UNPOSTED LIST.
00900	;		B ==> DJPI WORD OF THE PICTURE.
01000	
01100	;FNDUN		FIND A PICTURE ON THE UNPOSTED LIST.
01200	;		A HAS PICTURE NUMBER IN IT; RETURNS
01300	;		WITH B==> DJPI WORD OF PICTURE IF FOUND,
01400	;		0 OTHERWISE.
01500	
01600	
01700	
01800	REMUN:	MOVE	C,(B)		;REMOVE (B) FROM .UNLIST LIST
01900		MOVS	D,C
02000		TRNN	D,-1
02100		 JRST	 [HRRZM C,UNLIST(R) ;WAS HEAD OF LIST
02200			  JRST .+2(S)](S)	;RETURN TO FLOW
02300		HRRM	C,(D)		;FIX UP RIGHT-HAND LINK
02400		TRNE	C,-1
02500		 HRLM	 D,(C)
02600		POPJ	P,
02700	
02800	PUTUN:	HRRZ	C,UNLIST(R)	;PUT (B) ON UNLIST LIST
02900		MOVEM	C,(B)
03000		TRNE	C,-1		;WAS THERE ANYTHING?
03100		 HRLM	 B,(C)		;YES -- LINK IN.
03200		HRRZM	B,UNLIST(R)	;THIS BECOMES NEW LIST
03300		POPJ	P,
03400	
03500	FNDUN:	MOVE	B,UNLIST(R)	;FIND PIC NUMBER A ON UNLIST
03600	FND1:	JUMPE	B,CPOPJ(S)
03700		CAMN	A,%DNUM(B)	;CORRECT ONE?
03800		 POPJ	 P,		;YES
03900		HRRZ	B,(B)		;NEXT
04000		JRST	FND1(S)
04100	
04200	;FIND	ROUTINE FOR LOOKING THROUGH THE LIST OF POSTINGS
04300	;	THE ENTRY POINT AT 'FIND' LOOKS FOR THE PICTURE WITH
04400	;	NUMBER IN A.  ON EXIT,
04500	;	NOT FOUND:		A=B=0
04600	;	FOUND:			B ==> DJPI WORD OF PIC.
04700	;				1(C) ==> PLACE IN DISPATCH TABLE.
04800	
04900	;FINDA	ALTERNATE ENTRY POINT.  USES THE ROUTINE IN F AS THE TESTING
05000	;	ROUTINE AS EACH DISPATCH ENTRY IS LOOKED AT.  USED
05100	;	BY 'POST', BELOW, TO FIND AN UNUSED HOLE.
05200	
05300	
05400	FIND:	MOVEI	F,T1(S)		;LOCATE PIC #A IN DISPATCH LISTS
05500	FINDA:	HRRZ	E,DISTARTADR(R)	;GET FIRST TABLE
05600		ADDBIT	(E)		;FLIP 400000 BIT IF HISEG
05700	FIND0:	MOVE	C,E
05800		MOVEI	D,DLEN		;NUMBER OF DISPATCHES PER BLOCK
05900	FIND1:	MOVE	B,1(C)		;EXAMINE AN ENTRY
06000		JRST	(F)		;DO APPROPRIATE TEST
06100	FINNO:	ADDI	C,2		;BUMP TO NEXT ENTRY
06200		SOJG	D,FIND1(S)	;LOOP UNTIL BLOCK LOOKED AT
06300		HRRZ	E,-1(E)		;IS THERE ANOTHER BLOCK?
06400		JUMPN	E,FIND0(S)	;YES -- LOOK AT IT.
06500		SETZB	C,B		;ZERO THE INDICATORS
06600		POPJ	P,		;RETURN
06700	
06800	T1:	SKIPE	.SEG(S)		;DOES HE WANT HISEG CORE ALLOCATION
06900		JRST	T4(S)		;YES
07000		TLNE	B,DJMS		;IF IT IS A CALL
07100		CAME	 A,%DNUM(B) 	;AND IF NUMBER IS CORRECT
07200		  JRST   FINNO(S)
07300		POPJ	P,
07400	
07500	;HERE IF HISEG CORE ALLOCATION
07600	T4:	TLNE	B,DJMS		;IF IT IS A CALL
07700		CAME	A,400000+%DNUM(B)	;AND IF NUMBER IS CORRECT
07800		JRST	FINNO(S)
07900		TRO	B,400000	;THEN RETURN WITH B SETUP
08000		POPJ	P,
08100	
08200	T2:	TLNE	B,DJMS		;IF IT IS NOT A CALL
08300		 JRST	 FINNO(S)
08400		POPJ	P,		;THEN RETURN-- FOUND A HOLE.
08500	
08600	
08700	;UPOST	REMOVE A PICTURE FROM THE DISPATCH TABLE, AND PUT IT ON
08800	;	THE UNPOSTED LIST.  ON EXIT:
08900	;	B ==> DJPI WORD OF PICTURE, OR 0 IF NOT FOUND
09000	
09100	
09200	UPOST:	PUSHJ	P,FIND(S)	;INTERNAL POST -- FIND PIC NUMBER
09300		JUMPE	B,CPOPJ(S)	;NOT THERE -- IGNORE IT.
09400		MOVEI	C,2(C)	;PREPARE TO PLANT A DJP .+1
09500		SKIPE	.SEG(S)	;HISEG CORE ALLOCATION?
09600		MOVEI	C,400000(C)	;YES
09700		TLNE	DISRUN		;IS THE DISPLAY RUNNING?
09800		 JRST	 UP1(S)		;YES -- MORE COMPLICATED
09900	UP2:	SKIPE	.SEG(S)		;IS THERE A HISEG DISPLAY FILE?
10000		JRST	[MOVEM	C,400000-1(C)	;YES - BY-PASS THE PICTURE
10100			 JRST	UP3(S)](S)
10200		MOVEM	C,-1(C)		;NO - BY-PASS THE PICTURE
10300	UP3:	HRRZS	%DJM(B)		;SAY NO LONGER POSTED
10400		SOS	.POSTN(R)	;ONE FEWER PICTURE POSTED
10500		JRST	PUTUN(S)	;PUT ON UN-POSTED LIST
10600	
10700	UP1:	MOVEI	D,DISNOP(R)
10800		CLRBIT	(D)	;CLEAR 400000 BIT IF HISEG
10900		HRLI	D,DJMS!SBR
11000		SETZM	DISNOP(R)
11100		SKIPE	.SEG(S)		;IS HE USING HISEG CORE ALLOCATION?
11200		JRST	[MOVEM	D,400000-1(C)	;YES-PLANT SUBR CALL TO THE NOP SUBR
11300			 JRST	UP4(S)](S)
11400		MOVEM	D,-1(C)		;YES-PLANT SUBR CALL TO THE NOP SUBR
11500	UP4:	MOVEI	D,=250000	;ABOUT 1 SECOND
11600		SKIPN	DISNOP(R)	;WAIT FOR DISPLAY TO VISIT IT
11700		 SOJG	 D,.-1(S)	;BUT DON'T WAIT TOO LONG.
11800		JRST	UP2(S)		;OK -- DISPLAY IS DEFINITELY OUT OF THE CODE.
11900	
12000	
12100	;POST	ADD A PICTURE TO THE ACTIVE DISPATCH TABLE, EXPANDING
12200	;	THE DISPATCH TABLE IF NECESSARY.
12300	;	ENTER WITH A CONTAINING THE PICTURE NUMBER.  THE UNPOSTED
12400	;	LIST IS EXAMINED FOR THE RIGHT PICTURE.
12500	
12600	;POSTO	SIMILAR TO POST, BUT ENTRY WITH B==> DJPI WORD
12700	;	OF PICTURE TO ADD IN.  UNPOSTED LIST IS NOT ALTERED.
12800	
12900	
13000	
13100	POST:	PUSHJ	P,FNDUN(S)	;FIND IT ON UPOSTED LIST
13200		JUMPE	B,POSTER(S)	;TRYING TO POST POSTED PIC
13300		PUSHJ	P,REMUN(S)	;REMOVE FROM UNPOSTED LIST
13400	POSTO:	PUSH	P,B
13500	POST1:	MOVEI	F,T2(S)
13600		PUSHJ	P,FINDA(S)	;LOOK FOR HOLE IN DISPATCH TABLE.
13700		JUMPN	C,POST0(S)	;OK -- FOUND ONE.
13800		PUSHJ	P,MAKD(S)	;MAKE MORE ROOM
13900		TLNN	NOCORE		;DID IT SUCCEED?
14000		JRST	POST1(S)	;AND TRY AGAIN
14100		POPJ	P,		;NO -- FORGET POSTING
14200	
14300	POST0:	POP	P,B
14400		HRROS	%DJM(B)		;SAY IT IS NOW POSTED
14500		HRLI	B,DJMS!PRM
14600		CLRBIT	(B)	;CLEAR 400000 BIT IF HISEG
14700		MOVEM	B,1(C)		;PLANT THE CALL
14800		AOS	.POSTN(R)	;ONE MORE POSTING.
14900	POSTER:	POPJ	P,		;ALL DONE.
15000	
15100	MAKD:	MOVEI	C,DLEN*2+2	;MAKE NEW DISPATCH AREA
15200		PUSHJ	P,GETCOR(S)
15300		JUMPE	B,CPOPJ(S)	;WHAT DO WE DO HERE?
15400		MOVEI	F,DLEN
15500		MOVE	C,B
15600		MOVEI	E,2(C)		;GET ALL SET TO PLANT LOTS OF
15700		SKIPE	.SEG(S)		;HI SEG CORE ALLOCATION?
15800		MOVEI	E,400000(E)	;YES
15900		MOVEI	D,SBR		;DJP .+1 PRM    INSTRUCTIONS
16000	MAKD0:	MOVEM	D,(C)
16100		MOVEM	E,1(C)
16200		ADDI	C,2
16300		ADDI	E,2
16400		SOJG	F,MAKD0(S)	;LOOP
16500		HRLZM	D,(C)		;XWD SBR,,DJP
16600		MOVEI	A,IOSUBR(R)	 ;GO TO THE I/O SUBROUTINE LAST
16700		CLRBIT	(A)		;CLEAR 400000 BIT IF HISEG
16800		HRLZM	A,1(C)		;IT WILL DJP BACK TO DISTARTADR.
16900		SKIPN	E,DISTARTADR(R)	;FIRST TIME?
17000		 JRST	 MAKD1(S)	;YES
17100		MOVEI	A,-1
17200		SETBIT	(E)		;SET 400000 BIT IF HISEG
17300		TDNE	A,-1(E)		;LOOK FOR LAST DISPATCH BLOCK.
17400		JRST	 [HRRZ E,-1(E)
17500			  JRST .-1(S)](S) ;LOOK FOR END
17600		HRRM	B,-1(E)
17700		DPB	B,[POINT 17,DLEN*2+1(E),17](S)	;AND MAKE IT DJP TO US
17800		POPJ	P,
17900	
18000	MAKD1:	HRLI	A,PROTOTYPE(S)	;PROTOTYPE IOSUBR BLOCK
18100		HRRI	A,IOSUBR(R)
18200		BLT	A,INKSB1(R)	;PUT IT UP THERE
18300		MOVEI	E,INKSBR+1(R)	;FIXUP DJP .+1
18400		CLRBIT	(E)		;CLEAR 400000 BIT IF HISEG
18500		HRRM	E,INKSBR(R)	;TO MAKE DJP .+1 WORK RIGHT
18600		MOVEI	E,(B)		;
18700		SKIPE	.SEG(S)		;HISEG CORE ALLOCATION
18800		MOVEI	E,400000(E)	;YES
18900		HRLZM	E,INKSB1(R)	;DJP BACK TO BEGINNING OF BLOCK.
19000		TRO	D,200		;SYNC BIT
19100		MOVEM	D,(B)		;IN FIRST WORD.
19200		HRRZM	E,DISTARTADR(R)	;SAVE AS STARTING ADDRESS
19300		POPJ	P,		;AND EXIT
19400	
19500	
19600	;
19700	
19800	PROTOTYPE:
19900		XWD 117,PNT		;SCALE 0, INT 7
20000		XWD 220000,020000	;POINT MODE WORD 
20100		XWD 220777,160777	;LEAVE BEAM AT 777,777
20200					;DURING SYNC PERIOD TO COMBAT
20300					;OVERDRIVE IN DEFLECTION CIRCUITS
20400		XWD DJP,INKSBR+1 	;INK BUFFER DISPATCH
20500			;INCLUDE RELOCATION FOR .+1 AFTER BLT ABOVE
20600		XWD SBR,DJP		;
20700	
20800	
20900	;STOBYT STORES AWAY A BYTE IN THE DISPLAY FILE. IT DECREMENTS
21000	;	THE FREE BYTE COUNT.  IF THAT COUNT GOES TO ZERO, A NEW
21100	;	FREE STORAGE BLOCK IS ACQUIRED AND NXTBYT IS RECOMPUTED.
21200	;	
21300	;STOBY1 STORES REGARDLESS IF THE BYTE COUNT.
21400	
21500	;ACS:    BYTE IN A	;PRESERVED.
21600	;	 ALL ELSE	;CLOBBERED IF GETCOR CALLED
21700	;
21800	;MODEL  IS THE MODE OF THE LAST WORD, -1 IF LAST
21900	;	WORD CANNOT BE FIXED
22000	;MODE	IS THE MODE OF THE NEXT THING TO GO TO STOBYT
22100	;
22200	
22300	
22400	STOBYT: TLNE	NOMOCOD
22500		 POPJ	 P,		;NO MORE CODE UNTIL CORE EXISTS
22600		TLNN	PICOPN		;PICTURE MUST BE OPEN
22700		ERR	<CODE WITHOUT PIC OPEN>,3
22800		SOSLE	BYTCOUNT(R)	;ANY FREE ROOM?
22900		 JRST	 STOOK(S)	;YES -- JUST DEPOSIT BYTE.
23000		PUSH	P,A		;BYTE TO DEPOSIT.
23100		PUSH	P,MODE(R)	;SAVE OLD MODE.
23200		MOVEI	A,SBR		;NOW SUBROUTINE MODE.
23300		PUSHJ	P,SNM(S)	;GET SUBROUTINE MODE.
23400		POP	P,MODE(R)	;GET MODE BACK.
23500		MOVE	A,MODE(R)
23600		LSH	A,=13
23700		TRO	A,DJP		;COMPOSE A SUBROUTINE JUMP TO NEXT
23800		PUSHJ	P,STOBY1(S)	;BLOCK OF CODE.
23900		PUSHJ	P,STOBY1(S)	;DUMMY
24000		PUSH	P,NXTBYT(R)	;PLACE WHERE TO PATCH.
24100	
24200		PUSHJ	P,BLOCK(S)	;GETS NEW BLOCK.
24300		MOVE	A,NXTBYT(R)	;NEW SPOT TO BEGIN
24400		CLRBIT	(A)		;MAKE RELATIVE ADDRESS IF HISEG
24500		DPB	A,(P)		;AND FIX UP SUBROUTINE CALL.
24600		POP	P,(P)
24700		POP	P,A
24800		JRST	STOBYT(S)	;AND TRY AGAIN.
24900	
25000	STOBY1:	SOS	BYTCOUNT(R)
25100	STOOK:	IDPB	A,NXTBYT(R)
25200		PUSH	P,MODE(R)
25300		POP	P,MODEL(R)	;CHANGE MODE TO LAST
25400		POPJ	P,
25500	
25600	
25700	IFN 0,<	;DO NOT ASSEMBLE IN FOR NOW
25800	;INSURE   INSURES THAT N BYTES ARE AVAILABLE FOR SOME
25900	;	INSTRUCTION WHICH NEED CONSEQCUTIVE BYTES.
26000	;
26100	;ACS:	D	;NUMBER  OF BYTES, PRESERVED.
26200	;	A,B		;CLOBBERED.
26300	
26400	
26500	INSURE:	CAMGE	D,BYTCOUNT(R)	;ENOUGH LEFT?
26600		 POPJ	 P,		;YES.
26700		MOVEI	A,PRM		;GET PARAMETER MODE.
26800		PUSHJ	P,SNM(S)	;GET MODE.
26900		MOVEI	A,0
27000		PUSHJ	P,STOBYT(S)	;STORE A WORD...
27100		JRST	INSURE(S)
27200	>
27300	
27400	
27500	;BLOCK	CALLED TO GET A BLOCK OF CORE IN WHICH TO BUILD DISPLAY
27600	;	FILE.  BYTCOUNT AND NXTBYT ARE FIXED UP TO POINT TO IT.
27700	;	FURTHER, IT IS LINKED INTO THE PREVIOUS BLOCK, IF ANY,
27800	;	AS POINTED TO BY CURCORGET
27900	
28000	BLOCK:	MOVEI	C,400		;GET AN ENTIRELY NEW PIECE OFCORE.
28100	BLOCK1:	PUSHJ	P,GETCOR(S)	;GET SOME CORE.
28200		JUMPE	B,BLO0(S)	;NO MORE CORE HERE.
28300		HLRE	A,-1(B)		;LENGTH OF WHOLE GETCOR BLOCK.
28400		ADDI	A,5		;2 FOR GETCOR, 2 TO INSURE DJP AT END.
28500		LSH	A,1		;TIMES 2
28600		MOVNM	A,BYTCOUNT(R)	;AND SAVE AS BYTE COUNT.
28700		SKIPE	A,CURCORGET(R)	;HAS IT HAPPENED BEFORE.
28800		 HRRM	 B,-1(A)	;YES -- LINK IT IN.
28900		MOVEM	B,CURCORGET(R)
29000		HRLI	B,(<POINT 18,0>)
29100		MOVEM	B,NXTBYT(R)	;BYTE POINTER FOR STOBYT.
29200		POPJ	P,
29300	
29400	BLO0:	SETZM	NXTBYT(R)		;SO NO ONE WILL IDPB
29500		SKIPN	CURCORGET(R)	;HAD WE GOTTEN ANY CORE BEFORE?
29600		 POPJ	 P,		;NO
29700		MOVE	B,GENTOP(R)	;YES -- POINTER TO FIRST ONE
29800		JRST	KILL0(S)	;AND RETURN IT ALL NOW.
29900	
30000	
30100	
30200	
30300	;SNM	SET NEXT MODE FOR 340.  THE CURRENT MODE IS IN
30400	;	"MODE".  APPROPRIATE INFO IS PUT OUT TO CHANGE
30500	;	PREVIOUSLY DEPOSITED WORDS OR TO PUT OUT NEW
30600	;	WORDS WHICH GET INTO THE DESIRED MODE.
30700	;
30800	;ACS:	A (NEW MODE)	;CLOBBERED
30900	;	B,C		;CLOBBERED
31000	
31100	;WARNING -- MAY CAUSE UP TO 2 BYTES TO BE STORED IN THE
31200	; CASE OF GOING FROM CHAR MODE TO SBR MODE, SAY.
31300	
31400	SNM:	LSH	A,-=13			;SHIFT TO LOW 3 BITS.
31500		HRR	C,MODEL(R)		;LAST MODE
31600		MOVEM	A,MODE(R)		;SET NEW MODE.
31700		SKIPGE	MODEL(R)		;CAN WE FIX LAST BYTE?
31800		 JRST	 [JUMPE A,CPOPJ(S)	;NO -- TO PARM MODE.
31900			  JRST WORDIT(S)](S)	;NEED A WHOLE BYTE.
32000		ADDI	C,(S)		;RELOCATE
32100		ADDI	A,(S)		;RELOCATE
32200		LDB	B,BTAB(C)
32300		ADDI	B,(S)
32400		XCT	DSTAB(B)	;DISPATCH....
32500	
32600	DSTAB:	POPJ	P,		;0 -- DO NOTHING.
32700		JRST	ESCAP(S)	;1 -- JUST PUT IN ESCAPE BIT.
32800		JRST	ESCW(S)		;2 -- ESCAPE AND THEN A WORD.
32900		JRST	FIXBYT(S)	;3 -- CAN PUT NEW MODE IN LAST BYTE.
33000		JRST	CHRSP(S)	;4 -- SPECIAL HANDLING OFCHAR.
33100	
33200	
33300	BTAB:
33400		POINT 4,MODTAB(A),3
33500		POINT 4,MODTAB(A),7
33600		POINT 4,MODTAB(A),11
33700		POINT 4,MODTAB(A),15
33800		POINT 4,MODTAB(A),19
33900		POINT 4,MODTAB(A),23
34000		POINT 4,MODTAB(A),27
34100		POINT 4,MODTAB(A),31
34200	
34300	COMMENT @
34400	
34500	MODTAB IS INDEXED BY THE MODE TO BE SET.  EACH BYTE IN
34600	THE WORD SPECIFIES WHAT DO BE DONE WHEN COMING FROM THE
34700	CORRESPONDING MODE
34800	@
34900	
35000	MODTAB:	BYTE (4) 0,0,1,4,1,1,1,0
35100		BYTE (4) 3,3,2,4,2,2,2,3
35200		BYTE (4) 3,3,0,4,2,2,2,3
35300		BYTE (4) 3,3,2,0,2,2,2,3
35400		BYTE (4) 3,3,2,4,0,2,2,3
35500		BYTE (4) 3,3,2,4,2,0,2,3
35600		BYTE (4) 3,3,2,4,2,2,0,3
35700		BYTE (4) 3,3,2,4,2,2,2,3
35800	ESCAP:	LDB	A,NXTBYT(R)	;GET OLD CONTENTS.
35900		TRO	A,400000
36000		DPB	A,NXTBYT(R)	;AND TURN ON ESCAPE BIT.
36100		POPJ	P,
36200	
36300	CHRSP:	MOVEI	A,370000	;ESCAPE CODE.
36400		PUSHJ	P,STOBY1(S)	;.
36500		JRST	WORDIT(S)	;AND A PARM MODE WORD.
36600	ESCW:	PUSHJ	P,ESCAP(S)	;FIRST ESCAPE.
36700	WORDIT:	MOVE	A,MODE(R)
36800		LSH	A,=13
36900		JUMPE	A,CPOPJ(S)	;IF GOING INTO PARM MODE, NEVER MIND.
37000		JRST	STOBY1(S)	;PUT DOWN MODE CHANGE WORD.
37100	
37200	FIXBYT:	MOVE	A,MODE(R)
37300		LSH	A,=13
37400		LDB	B,NXTBYT(R)	;OLD WORD.
37500		IOR	B,A
37600		DPB	B,NXTBYT(R)	;DONE.
37700		POPJ	P,
37800	
37900	
38000	
38100	;CLOSE	CLOSE THE PICTURE WHICH IS CURRENTLY OPEN.
38200	;	IF AN APPEND, THEN THE NEW CODE IS LINKED ONTO
38300	;	THE END OF THE PICTURE BEING APPENDED TO.
38400	;
38500	;	IF NOT AN APPEND, THEN DELETE THE PREVIOUS
38600	;	COPY OF THE PICTURE NUMBER, IF ANY.  THEN ADD
38700	;	THE NEW COPY TO THE UNPOSTED LIST.
38800	
38900	CLOSE:	TLZE	NOMOCOD		;DID WE HAVE TO STOP IN THE MIDDLE OF THIS PIC?
39000		 POPJ	P,		;YES -- RETURN
39100		TLZ	PICOPN		;CLOSING A PICTURE
39200		MOVEI	A,SBR		;SET SUBROUTINE MODE.
39300		PUSHJ	P,SNM(S)
39400		HLRZ	B,NXTBYT(R)	;SEE IF WE WILL BE ON
39500		CAIN	B,(<POINT 18,0,17>);ON A WORD BOUNDARY
39600		JRST	[MOVSI B,SBR
39700			 ANDCAM B,@NXTBYT(R)	;TURN IT OFF (ONLY WAY TO GET SBR)
39800			 MOVEI B,SBR
39900			 IDPB	B,NXTBYT(R)	;AND NOW HERE.
40000			 JRST .+1(S)](S)
40100		MOVEI	A,DJPI!PRM
40200		PUSHJ	P,STOBY1(S)	;PUT OUT THE JUMP INDIRECT THROUGH
40300		MOVE	A,GENTOP(R)	;THE INDIRECT WORD
40400		ADDI	A,-%DNUM		;THIS IS THE REAL INDIRECT ADDRESS
40500		ADDBIT	(A)		;FLIP 400000 BIT IF HISEG
40600		PUSHJ	P,STOBY1(S)	;...
40700		MOVE	B,CURCORGET(R)
40800		HRRZ	C,NXTBYT(R)	;LAST ADDRESS USED.
40900		PUSHJ	P,PUTCOR(S)	;RETURN WHAT IS LEFT
41000	
41100		MOVE	A,.CURPIC(R)	;GET PICTURE NUMBER 
41200		TLZE	APPEND		;IS THIS AN APPEND ?
41300		 JRST	 CLO1(S)	;YES -- GO HANDLE IT.
41400		PUSHJ	P,UPOST(S)	;AND UNPOST IT IF IT IS POSTED.
41500		JUMPE	B,[PUSHJ P,FNDUN(S) ;LOOK FOR IT ON UNPOSTED LIST.
41600			   JUMPE B,CLO0(S)  ;WAS NOT THERE
41700			   JRST .+1(S)](S)  ;B ==> PICTURE TO KILL.
41800		PUSHJ	P,REMUN(S)	;TAKE IT OFF UNPOSTED LIST
41900		PUSHJ	P,KILL(S)	;KILL PIC IN B.
42000	CLO0:	MOVE	B,GENTOP(R)	;GET PIC TOP AGAIN.
42100		ADDI	B,-%DNUM
42200		MOVE	A,.CURPIC(R)	;INSTALL PICTURE NUMBER
42300		MOVEM	A,%DNUM(B)
42400		HRRZ	C,NXTBYT(R)
42500		MOVEM	C,%DJM(B)	;SAVE ADDRESS OF DJPI
42600		JRST	PUTUN(S)	;PUT ON UNPOSTED LIST.
42700	
42800	CLO1:	PUSHJ	P,FIND(S)	;SEE IF YOU CAN FIND IT
42900		JUMPN	B,CLO2(S)	;GOT IT.
43000		PUSHJ	P,FNDUN(S)	;LOOK IN UNPOSTED LIST
43100		JUMPE	B,[ERR <APPEND TO NON-EX PIC>,6](S)
43200	CLO2:	MOVE	A,%DJM(B)	;GET PTR TO HIS DJPI WORD.
43300		MOVE	C,(A)		;GET HIS DJPI WORD.
43400		MOVEM	C,@NXTBYT(R)	;AND PUT IT DOWN IN OURS.
43500		MOVE	C,GENTOP(R)	;PTR TO FIRST WORD OF OUR CODE.
43600		CLRBIT	(C)		;RELOCATE FOR DISPLAY IF HISEG
43700		MOVEM	C,(A)		;AND MAKE HIM JUMP.
43800	
43900		MOVEI	A,-1
44000		MOVEI	B,%DNEXT+1(B)	;ADJUST
44100		TDNE	A,-1(B)		;IS THIS THE LAST BLOCK?
44200		 JRST	 [HRRZ B,-1(B)
44300			  JRST .-1(S)](S) ;LOOK UNTIL YOU FIND
44400		MOVE	C,GENTOP(R)
44500		HRRM	C,-1(B)		;AND LINK US IN.
44600		POPJ	P,
44700	
44800	
44900	;KILL	RETURN A PICTURE TO FREE STORAGE.
45000	;	ENTER WITH B ==> DJPI WORD OF THE PICTURE.
45100	
45200	KILL:	MOVEI	B,%DNEXT+1(B)	;ADJUST POINTER
45300	KILL0:	 HRRZ	 E,-1(B)	;LINK TO NEXT
45400		PUSH	P,E
45500		PUSHJ	P,RELCOR(S)	;RELEASE
45600		POP	P,B
45700		JUMPN	B,KILL0(S)	;LOOP UNTIL ALL GONE.
45800	
45900	;	IPICTA IS POPJ BECAUSE NOT A GT40!
46000	;	CURSET IS POPJ BECAUSE NO CURSOR FOR THIS DEVICE.
46100	
46200	IPICTA:
46300	CURSET:	POPJ	P,		;RETURN
46400	
46500	
     
00100	
00200	;OTHER DEVICES: GRAPHACON, FUNCTION BOX AND LIGHTS
00300	
00400	
00500	QOUT:	POP	P,C		;CODE
00600		POP	P,B		;DEVICE
00700		CAIN	B,1		;LIGHTS?
00800		 JRST	 LTS(S)		;YES
00900		CAIE	B,2		;TABLET?
01000		 JRST	 @.RET(S)	;NO -- RETURN
01100	
01200		MOVSI	A,-1
01300		CAMN	C,[-1](S)	;TELLING US TO SHUT DOWN?
01400		 JRST	 GFNGO(S)	;YES
01500		MOVEI	A,600		;TRACK AND EQUAL SPACE
01600		JUMPE	C,GFNGO(S)	;TRACK ONLY.
01700		IMULI	C,=20		;CONVERT INCHES OF INK TO WORDS OF CORE!
01800		PUSHJ	P,GFNALL(S)	;ALLOCATE INK BUFFER THAT SIZE
01900		MOVEI	A,4700		;CLEAR BUFFER, TRACK AND INK
02000	GFNGO:	MOVEM	A,GFNMODE(R)	;SAVE FOR XDVSER ROUTINES
02100		MOVE	B,[XWD 3,2](S)  ;COMMAND TO START TABLET
02200		DISCAL	B		;LIKE SO.
02300		MOVE	C,EFLAG(R)		;SET FLAG
02400		TRO	C,2
02500		MOVEM	C,EFLAG(R)
02600		MOVE	C,TRCLOC(R)	;GET TRACKING INSTRUCTION		;INTENSIFY BIT.
02700		TRNE	A,200		;ASKED TO TRACK?
02800		 TROA	 C,2000		;YES -- TURN ON IFY BIT.
02900		 TRZ	 C,2000		;NO -- TURN OFF IFY BIT.
03000		MOVEM	C,TRCLOC(R)	;AND SAVE WORD.
03100		MOVE	C,INKLOC(R)	;GET ADDRESS OF INK BUFFER
03200		HRLI	C,DJMS		;AND MAKE INTO SUBR CALL
03300		TRNE	A,100		;INKING REQUESTED ?
03400		JRST	GFNG1(S)	;YES
03500		 MOVEI	 C,INKSBR+1(R) ; NO -- CHANGE TO DJP .+1
03600		CLRBIT	(C)		;CLEAR 400000 BIT IF HISEG
03700	GFNG1:	MOVEM	C,INKSBR(R)	;AND SAVE AS CALL INSTRUCTION.
03800					;NOTE THAT THE INK BUFFER WAS CLEARED
03900					;BY THE ABOVE CALL TO START GFN.
04000		JUMPGE	A,@.RET(S)	;RETURN IF SIGN BIT NOT SET
04100		MOVE	B,[XWD 4,2](S)	;STOP COMMAND
04200		DISCAL	B		;STOP TABLET ALTOGETHER
04300		MOVE	C,EFLAG(R)		;RESET FLAG
04400		TRZ	C,2
04500		MOVEM	C,EFLAG(R)
04600		MOVEI	C,0		;AND ALLOCATE 0 CORE FOR THE INK BUFFER
04700		PUSHJ	P,GFNALL(S)
04800		JRST	@.RET(S)	;RETURN.
04900	
05000	
05100	;THERE IS A DANGER INHERENT IN THE GFNALL SUBROUTINE WHICH
05200	;RE-ALLOCATES INKING BUFFER SPACE.  WE DEALLOCATE THE PRESENT
05300	;BUFFER EVEN THOUGH THE DISPLAY MAY BE IN IT. -- THAT'S OK
05400	;BECAUSE RELCOR WON'T DISTURB THE RETURN JUMP.
05500	;THE NEW BUFFER WILL BE OK TOO BECAUSE IT IS CLEARED BEFORE
05600	;BEING PATCHED INTO THE DISPLAY FILE.
05700	;THE DANGER ARISES IF:
05800	;(1) THE OLD BUFFER IS REUSED FOR DISPLAY FILE TOO FAST
05900	;	(UNLIKELY) WHILE THE DISPLAY IS STILL IN IT.
06000	;(2) THE OLD AND NEW BUFFERS OVERLAP AND THE 'CLEAR'
06100	;	HAPPENS WHILE THE DISPLAY IS STILL INSIDE THE INK
06200	;	SUBROUTINE -- A DJPI WILL BE GENERATED THROUGH A
06300	;	RETURN ADDRESS WHICH NEVER GOT SET UP.
06400	;THE TWO STARRED LINES BELOW MIGHT FIX THIS PROBLEM!
06500	
06600	GFNALL:	HLRZ	A,INKLOC(R)	;ALLOCATE C(C) WORDS FOR INK BUFFER
06700		CAIN	A,(C)		;ALREADY CORRECT AMOUNT?
06800		 POPJ	 P,		;YES
06900		MOVE	B,[XWD 4,2](S)  ;MUST STOP GFN WHILE DESTROYING BUFFER
07000		MOVEI	A,2		;BUT ONLY IF
07100		TDNE	A,XSTAT(R)		;IT IS NOW RUNNING
07200		DISCAL	B
07300		PUSH	P,C		;SAVE DESIRED SIZE.
07400		HRRZ	B,INKLOC(R)	;CURRENT CORE POINTER
07500		SETBIT	(B)		;RELOCATE INTO SECOND SEG IF HISEG DISPLAY FILE
07600		TRNE	B,377777	;IF THERE WAS CORE BEFORE,
07700		 PUSHJ	 P,RELCOR(S)	;RELEASE IT NOW
07800		POP	P,C		;RESTORE SIZE
07900		HRLM	C,INKLOC(R)	;INK BUFFER SIZE
08000		PUSHJ	P,GETCOR(S)	;AND RESERVE CORE
08100	;	MOVSI	C,INKSBR+1(R) ;** GET RETURN POINT
08200	;	SKIPE	.SEG(S)		;HISEG DISPLAY FILE?
08300	;	TLZ	C,400000	;YES-CLEAR 400000 BIT
08400	;	HRLM	C,(B)		;** SAVE AS RETURN ADDRESS
08500		CLRBIT	(B)		;CLEAR 400000 BIT IF HISEG
08600		HRRM	B,INKLOC(R)	;AND SAVE IT.!!
08700		JUMPN	B,CPOPJ(S)	;IF GETCOR REALLY GAVE US CORE, RETURN
08800		SETZM	INKLOC(R)		;NO POSSIBILITY OF INKING
08900		ERR	<NOT ENOUGH CORE FOR INK BUFFER>,15,@.RET(S)
09000	
09100	
09200	LTS:	MOVM	D,C		;GET ABS VALUE OF ARGUMENT
09300		JUMPE	D,[SETZM FBXDAT(R) ;NO LIGHTS AT ALL
09400			   JRST LTSGO(S)](S)
09500		CAILE	D,=16
09600		 JRST	 LTSGO(S)	;JUST TELL SYSTEM.
09700		MOVNS	D		;GET NEGATIVE
09800		MOVSI	B,100000
09900		LSH	B,1(D)		;POSITION A BIT.
10000		MOVE	A,[IORM B,FBXDAT(R)](S) ;GET INSTRUCTION
10100		SKIPGE	C		;IF ASKED TO TURN IT OFF,
10200		TLC	A,(<IORM><ANDCAM>) ;CHANGE FROM IORM TO ANDCAM
10300		XCT	A
10400	LTSGO:	MOVE	B,[XWD 3,4](S)	;START FBX
10500		DISCAL	B
10600		MOVE	C,EFLAG(R)	;SET FLAG
10700		TRO	C,1
10800		MOVEM	C,EFLAG(R)
10900		JRST	@.RET(S)
11000	
11100	
11200	
11300	
11400	;NOW FOR EVENT HANDLING!!!
11500	
11600	QEVENT: SKIPE	BFRBEGIN(R)	;IS EVENT BUFFER SET UP?
11700		 JRST	 QEV0(S)	;YES -- RUSH AHEAD
11800		MOVEI	C,=200		;FIXED SIZE EVENT BUFFER, ALAS
11900		PUSHJ	P,GETCOR(S)
12000		JUMPE	B,QEV99(S)	;COULD NOT GET CORE
12100		HRRZM	B,BFRBEGIN(R)	;FIRST LOCN OF BUFFER
12200		ADDI	B,=200		;COMPUTE END LOCN+1
12300		HRRZM	B,BFREND(R)	;AND SAVE FOR XDVSER
12400	QEV0:	MOVE	C,(P)		;GET ANSWER POINTER
12500		MOVE	B,-1(P)		;GET OP
12600		MOVE	A,-2(P)		;GET DEVICE
12700		TRNN	B,2		;ENABLING ANY DEVICES?
12800		JRST	QEV1(S)		;NO
12900		TRNN	A,1		;IS IT THE FUNCTION BOX?
13000		JRST	QEV2(S)		;NO
13100		MOVE	C,EFLAG(R)		;SEE IF DONE YET
13200		TRNE	C,1
13300		JRST	QEV2(S)		;YES, SO DON'T DO AGAIN
13400		TRO	C,1		;ELSE SET FLAG
13500		MOVEM	C,EFLAG(R)
13600		SETZM	FBXDAT(R)		;SET NO LIGHTS AT ALL
13700		MOVE	B,[XWD 3,4](S)	;START FUNCTION BOX
13800		DISCAL	B
13900	QEV2:	TRNN	A,6		;EITHER TYPE OF TABLET EVENT?
14000		JRST	QEV1(S)		;NO
14100		MOVE	C,EFLAG(R)	;SEE IF DONE YET
14200		TRNE	C,2		;IF NOT ALREADY DONE, DO IT
14300		JRST	QEV1(S)		;ELSE BYE
14400		TRO	C,2		;SET FLAG
14500		MOVEM	C,EFLAG(R)
14600		MOVEI	A,600		;TRACK AND EQUAL SPACE
14700		MOVEM	A,GFNMODE(R)	;SAVE FOR XDVSER
14800		MOVE	B,[XWD 3,2](S)	;START TABLET
14900		DISCAL	B
15000		MOVE	C,TRCLOC(R)	;GET TRACKING INSTRUCTION
15100		TRO	C,2000		;TURN ON IFY BIT
15200		MOVEM	C,TRCLOC(R)	;AND SAVE IT
15300		MOVEI	C,INKSBR+1(R)  ;CHANGE INKSBR TO DJP .+1
15400		CLRBIT	(C)		;CLEAR 400000 BIT IF HISEG
15500		MOVEM	C,INKSBR(R)
15600	QEV1:	POP	P,C
15700		POP	P,B
15800		POP	P,A
15900		MOVE	D,[XWD 10,70](S) ;START PREPARING COMMAND TO XDVSER
16000		TRNN	B,2		;ENABLE DEVICES?
16100		 TRZA	 D,70		;NO -- CHANGE NOTHING
16200		 MOVEM	 A,EVENTS(R)	;SAVE EVENTS MASK
16300		TRNE	B,1		;CLEAR BUFFER?
16400		 TRO	 D,200000	;YES
16500		TRNE	A,1		;FBX KEYS?
16600		 TRO	 D,4		;YES -- ENABLE
16700		TRNE	A,6		;EITHER KIND OF GFN?
16800		 TRO	 D,2		;YES
16900		TRNE	A,10		;DISPLAY (COMPARATOR HITS?)
17000		 TRO	 D,1		;YES
17100		TRNE	D,200070	;WERE ANY BITS TURNED ON?
17200		 DISCAL	 D		;YES -- PASS TO SYSTEM NOW
17300		JFCL			;IT SKIP RETURNS
17400	IGET:	SOSGE	VALID(R)		;ANY PENDING EVENT?
17500		 JRST	 [AOS VALID(R)	;NO -- UNDO EFFECT OF SOSGE
17600			  SETZM (C)	;ZERO THE EVENT NUMBER IN 'ANSWER'
17700			  TRNN	B,4	;ARE WE TO WAIT FOR EVENTS?
17800			   JRST @.RET(S) ;RETURN PRONTO.
17900			  MOVE A,[XWD 10,400000](S) ;WAIT ON BUFFER COMMAND
18000			  DISCAL A	;ASK SYSTEM FOR HIS SERVICES
18100			  JFCL		;NO BOTHER ABOUT ERROR
18200			  JRST IGET(S)](S) ;AND TRY AGAIN
18300		AOS	A,TAKER(R)		;BUMP POINTER TO NEXT BUFFER ENTRY
18400		CAMN	A,BFREND(R)	;AT END?
18500		 JRST	 [MOVE A,BFRBEGIN(R) ;YES -- RESET TO BEGIN
18600			  MOVEM A,TAKER(R)  ;AND SAVE FOR NEXT TIME
18700			  JRST .+1(S)](S)
18800		MOVE	A,(A)		;PICK UP ENTRY
18900		AOS	FREEC(R)		;ONE MORE FREE ENTRY.
19000	GOTIN:	LDB	D,[POINT 6,A,5](S) ;GET OP-CODE IN FROM EVENT
19100		JUMPE	D,GFNIN(S)	;TABLET INPUT
19200		CAIN	D,1		;KEYS?
19300		 JRST	 FBXIN(S)	;YES
19400		MOVSI	B,(<8.0>)	;DISPLAY EVENT OF ONE KIND OR OTHER
19500		JRST	RECIN(S)	;GO PLOP IT DOWN.
19600	
19700	QEV99:	SUB	P,[XWD 3,3](S)	;PUT STACK BACK.
19800		ERR	<NO CORE FOR EVENT BUFFER>,15,@.RET(S)
19900	
20000	
20100	FBXIN:	HRRZS	A		;GET KEY BITS.
20200		JFFO	A,.+1(S)	;FIND THE BIT
20300		MOVEI	A,-=19(B)	;AND COPY THE NUMBER
20400		PUSHJ	P,@.FLOAT(S)	;FLOAT IT
20500		MOVSI	B,(<1.0>)	;KEY PUSH EVENT
20600		JRST	RECIN(S)
20700	
20800	GFNIN:	CAIN	A,-1		;PEN GOING DOWN?
20900		 JRST	 IGET(S)	;YES -- IGNORE
21000		CAIN	A,-2		;PEN COMING UP?
21100		 JRST	 PENUP(S)	;YES -- PROCESS SPECIALLY
21200		PUSH	P,A		;SAVE EVENT
21300		HLRZS	A
21400		PUSHJ	P,@.FLOAT(S)	;Y COORDINATE
21500		FSBR	A,.YPA(R)
21600		FDVR	A,.YPM(R)	;CONVERT TO 2D PAGE COORDINATES
21700		EXCH	A,(P)		;AND SAVE
21800		HRRZS	A		;X COORDINATE
21900		PUSHJ	P,@.FLOAT(S)
22000		FSBR	A,.XPA(R)
22100		FDVR	A,.XPM(R)
22200		POP	P,D		;RESTORE Y
22300		MOVEM	A,XGFN(R)		;SAVE X PAGE COORDINATE
22400		MOVEM	D,YGFN(R)		;AND Y COORDINATE
22500		MOVEI	E,4		;SEE IF ENABLED FOR MOVEMENT EVENTS
22600		TDNN	E,EVENTS(R)
22700		 JRST	 IGET(S)	;NO-- CONTINUE
22800		MOVSI	B,(<4.0>)	;EVENT # 4
22900		JRST	RECIN(S)	;YES -- RECORD FOR USER
23000	
23100	PENUP:	MOVEI	A,2		;SEE IF ENABLED FOR PEN PUSHES
23200		TDNN	A,EVENTS(R)
23300		 JRST	 IGET(S)	;NO -- CONTINUE
23400		MOVE	A,XGFN(R)		;YES -- RESTORE 'LAST TIME'S X
23500		MOVE	D,YGFN(R)		;AND Y
23600		MOVSI	B,(<2.0>)	;CODE FOR PENUP
23700	RECIN:	MOVEM	B,(C)		;EVENT NUMBER
23800		MOVEM	A,1(C)		;X
23900		MOVEM	D,2(C)		;Y
24000		JRST	@.RET(S)	;AND RETURN
24100	
24200	
24300	
24400	
24500	;DCODE OPERATION:
24600	;
24700	; THE ARGUMENT PASSED IN IS:
24800	;  OP-CODE (BITS 0-5)
24900	;  SUBOP CODE (BITS 6-17)
25000	;  OPERAND (BITS 18-35)
25100	
25200	QCODE:	POP	P,B
25300		HRRZ	A,B		;OPERAND
25400		LDB	C,[POINT 6,B,5](S) ;OP CODE.
25500		CAILE	C,CODMAX	;WITHIN RANGE?
25600		 ERR	 <NOT VALID OPERATION>,13,@.RET(S)
25700		ADDI	C,CODTAB(S)	;MAKE DISPATCH
25800		LDB	B,[POINT 12,B,17](S) ;GET SUB-OP CODE
25900		XCT	(C)		;DO THE THING!!!
26000		JRST	@.IRET(S)	;AND RETURN
26100	
26200	CODTAB:	PUSHJ	P,STOBYT(S)	;OP 0 -- CALL STOBYT
26300		PUSHJ	P,SNM(S)	;OP 1 -- CALL SNM
26400		PUSHJ	P,DEPOSL(S)	;OP 2 -- DEPOSIT LEFT
26500		PUSHJ	P,DEPOSR(S)	;OP 3 -- DEPOSIT RIGHT
26600		PUSHJ	P,EXMN(S)	;OP 4 -- EXAMINE
26700	CODMAX__.-CODTAB-1
26800	
26900	EXMN:	SKIPE	A		;IF OPERAND,
27000		JRST	.+3		;THEN EXAMINE IT
27100		MOVEI	A,XSTAT-1(R)	;STATUS ENTRY
27200		ADD	A,B		;DISPLACE BY VALUE OF OPCODE
27300		MOVE	A,(A)
27400		POPJ	P,
27500	
27600	
27700	DEPOSL: MOVSI	C,(<HRLM A,(B)>)
27800		SKIPA			;
27900	DEPOSR:	MOVSI	C,(<HRRM A,(B)>)
28000		ADDI	B,XSTAT-1(R)	;AND RELOCATE (XSTAT=1)
28100		XCT	C		;DO IT
28200		POPJ	P,
28300	
28400	
28500	
28600	
28700	
28800	
28900	;DRAST OPERATION
29000	;
29100	;DRAST IS USED BEFORE ANY DCODE WHICH PRODUCES RASTER
29200	;MODE INSTRUCTIONS. IT PUTS THE 340 IN RASTER MODE AND
29300	;ALLOCATES ENOUGH SPACE FOR THE RASTER MODE PICTURE.
29400	;THE ARGUMENT N IS THE NUMBER OF POINTS IN THE PICTURE,
29500	;AND THE NUMBER OF WORDS TO ALLOCATE IS COMPUTED FROM
29600	;N/10.
29700	
29800	;THIS ROUTINE IS INCLUDED TO SOLVE PROBLEMS WITH 340
29900	;RASTER MODE:
30000	;(1) IF THE FREE CORE AREA OVERFLOWS, PART OF THE
30100	;    PICTURE IS GARBAGED SINCE THE 340 DOESN'T
30200	;    REMEMBER THE PREVIOUS RIGHT MARGIN.
30300	;
30400	;(2) ANOTHER RASTER MODE PROBLEM FOUND AT THIS TIME WAS
30500	;    CAUSED WHEN THE USER FAILED TO GENERATE AN ESCAPE
30600	;    FROM RASTER MODE WHEN HE WISHED TO RETURN TO
30700	;    OMNIGRAPH CALLS. THIS IS SOLVED NOT BY ANY CHANGES
30800	;    TO OMNIGRAPH BUT BY HAVING THE USER GENERATE HIS
30900	;    OWN ESCAPE BACK TO PARAMETER MODE. THIS WILL NOT
31000	;    CONFUSE THE OMNIGRAPH ROUTINES AS THEY ALWAYS SET
31100	;    THEIR OWN MODE.
31200	
31300	
31400	
31500	
31600	QRAST:	MOVE	B,.XBEAM(R)	;GET X COORDINATE
31700		MOVE	C,.YBEAM(R)	;GET Y COORDINATE
31800		PUSHJ	P,CODE2(S)	;COMPUTE WHETHER IN WINDOW.
31900		JUMPN	A,QRAST1(S)	;NOT VISIBLE SO DO NOT CHANGE COORDINATES
32000		PUSHJ	P,CONV2(S)	;CONVERT TO SCREEN COORDS.
32100		TLZ	DISIFY		;DO NOT INTENSIFY
32200		PUSHJ	P,PGEN(S)	;MOVE BEAM TO WHERE OMNIGRAPH
32300					;THINKS IT IS
32400	QRAST1:	MOVEI	A,RAS	;SET RASTER MODE
32500		PUSHJ	P,SNM(S)
32600	
32700		POP	P,C	;GET ARG N=# PTS IN PICTURE
32800		IDIVI	C,12	;C_N/10 + 2, # WORDS FOR RASTER
32900		ADDI	C,2	;DISPLAY LIST (1 EXTRA FOR ROUNDOFF,
33000				;1 EXTRA FOR "PUT 340 IN RASTER MODE")
33100		MOVE	A,C	;A_# BYTES NEEDED
33200		LSH	A,1
33300		CAMGE	A,BYTCOUNT(R)	;ENOUGH SPACE IN CURRENT BLOCK?
33400		JRST	@.RET(S)	;YES
33500	
33600					;NO - GENERATE DJP AT END OF
33700					;CURRENT BLOCK
33800		PUSH	P,MODE(R)	;SAVE MODE
33900		MOVEI	A,SBR		;GET SUBROUTINE MODE
34000		PUSHJ	P,SNM(S)
34100		POP	P,MODE(R)	;RESTORE MODE
34200		MOVE	A,MODE(R)	;SETUP A TO CONTAIN DJP INSTR
34300		LSH	A,=13		;POSITION MODE PROPERLY IN WORD
34400		TRO	A,DJP		;COMPOSE JUMP TO NEXT BLOCK
34500		PUSHJ	P,STOBY1(S)	;OF CODE
34600		PUSHJ	P,STOBY1(S)	;DUMMY PLACE TO PATCH IN DJP
34700					;ADDR LATER
34800	
34900					;RETURN REMAINDER OF CURRENT
35000					;BLOCK
35100		PUSH	P,C		;SAVE C
35200		MOVE	B,CURCORGET(R)	;B ==> TO CURRENT BLOCK
35300		HRRZ	C,NXTBYT(R)	;C ==> TO LAST BYTE USED
35400		PUSHJ	P,PUTCOR(S)	;RETURN REST OF BLOCK
35500		POP	P,C		;RESTORE C
35600	
35700					;GET NEW BLOCK OF CORE
35800		PUSH	P,NXTBYT(R)	;SAVE OLD PTR WORD SO CAN
35900					;PATCH DJP ADDR IN
36000		PUSHJ	P,BLOCK1(S)	;GET NEW BLOCK OF (C) # WORDS	
36100		MOVE	A,NXTBYT(R)	;NEW SPOT TO BEGIN
36200		CLRBIT	(A)		;MAKE RELATIVE ADDRESS IF HISEG
36300		DPB	A,(P)		;FIXUP DJP ADDRESS
36400		POP	P,(P)		;CLEAR STACK
36500	
36600		JRST	@.RET(S)
36700	
36800	
36900	
37000	
37100	
37200	
