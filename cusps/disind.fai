00100	SUBTTL DISPLAY-INDEPENDENT CODE
00200	;INCLUDES DVMULT, DRCOMPOSE AND FRIENDS
00300	
00400	?SALONE__1		;DISPLAY CODE HAS OCCURRED.
00500	
00600	
00700	;******* REASONABLY DEVICE-INDEPENDENT CODE *******
00800	
00900	;FOLLOWING ARE:
01000	;	2-D ROUTINES AND WINDOWING
01100	;	WINDOW, VIEWPORT SETTING
01200	;	3-D ROUTINES AND WINDOWING
01300	;	TRANSFORM PUSHING, POPPING
01400	
01500	;	CORE ALLOCATION ROUTINES
01600	
01700	
01800	; THESE ROUTINES CALL ON TWO CODE-GENERATORS WHICH ARE DEVICE-DEPENDENT:
01900	; (1) PGEN -- PUT OUT POINT MODE INSTRUCTION. AC B HAS X COORDINATE;
02000	;		AC C HAS Y COORDINATE.  IT MAY DESTROY ALL
02100	;		ACCUMULATORS AS IT PUTS OUT THE INSTRUCTION.
02200	; (2) VGEN -- PUT OUT 'DRAW TO' INSTRUCTION. ARGUMENTS ARE IN
02300	;		STACK -- DELTA Y WILL BE AT -1(P); DELTA X AT -2(P).
02400	;		ALL ACCUMULATORS MAY BE DESTROYED.
02500	
02600	
02700	
02800	QMOVE:	TLZA	DISIFY		;MOVE TO A POINT (DARK)
02900	QDOT:	TLO	DISIFY		;DISPLAY A POINT
03000		POP	P,C		;Y
03100		POP	P,B		;X
03200		TLNE	USXFRM		;IS THERE A NON-IDENTITY TRANSFORMATION?
03300		 PUSHJ	 P,XFORM2(S)	;YES -- TRANSFORM THINGS.
03400		MOVEM	B,.XBEAM(R)	;SAVE XBEAM
03500		MOVEM	C,.YBEAM(R)	;AND YBEAM
03600		PUSHJ	P,CODE2(S)	;COMPUTE WHETHER IN WINDOW.
03700		JUMPN	A,@.FRET(S)	;NOT VISIBLE
03800		PUSHJ	P,CONV2(S)	;CONVERT TO SCREEN COORDS.
03900	PGO:	TLNN	DISIFY		;IF NOT INTENSIFYING,
04000		 JRST	 @.TRET(S)	;RETURN
04100		PUSHJ	P,PGEN(S)	;GO MAKE A POINT
04200		JRST	@.TRET(S)	;RETURN
04300	
04400	QVECT:	MOVE	C,-2(P)		;Y1
04500		MOVE	B,-3(P)		;X1
04600		TLNE	USXFRM		;NON-IDENTITY TRANSFORMATION?
04700		 PUSHJ	 P,XFORM2(S)	;YES -- DO IT.
04800		MOVEM	B,.XBEAM(R)	;SAVE X1
04900		MOVEM	C,.YBEAM(R)	;SAVE Y1
05000		POP	P,-2(P)		;REPLACE Y COORDINATE
05100		POP	P,-2(P)		;REPLACE X COORDINATE
05200	QDRAW:	POP	P,C		;Y2
05300		POP	P,B		;X2
05400		TLNE	USXFRM		;NON-IDENTITY TRANSFORMATION?
05500		 PUSHJ	 P,XFORM2(S)	;YES -- DO IT.
05600		MOVE	F,.XBEAM(R)	;X1
05700		MOVE	G,.YBEAM(R)	;Y1
05800		MOVEM	B,.XBEAM(R)	;X2
05900		MOVEM	C,.YBEAM(R)	;Y2
06000		PUSHJ	P,WINDOW(S)	;GO WINDOW THE LINE.
06100		JUMPN	A,@.FRET(S)	;NOTHING VISIBLE.
06200		PUSHJ	P,CONV2(S)	;CONVERT 2ND TO SCREEN COORDINATES
06300		EXCH	B,F
06400		EXCH	C,G		;AND NOW THE OTHER POINT
06500		PUSHJ	P,CONV2(S)	;FIRST POINT
06600	VGO:	SUB	F,B		;F HAS DELTAX
06700		SUB	G,C		;G HAS DELTAY (SCREEN COORDS)
06800		PUSH	P,F		;SAVE DELTAX
06900		PUSH	P,G		;AND DELTAY
07000		PUSHJ	P,PGEN(S)	;GO GENERATE POINT MODE INSTR (ONLY IF BEAM NEEDS MOVING)
07100		PUSHJ	P,VGEN(S)
07200		JRST	@.TRET(S)	;RETURN
07300	
07400	
07500	;NOW FOR THE 3-D USER ROUTINES.
07600	
07700	QBYP:	POP	P,A		;GET ARGUMENT
07800	IFDEF BYPOK,<			;ONLY DO THIS IF BYPASS CAN HAPPEN
07900		SKIPN	A
08000		 TLZA	 BYPASS
08100		TLO	BYPASS
08200	>
08300		JRST	@.RET(S)
08400	
08500	
08600	
08700	QMOVE3:	TLZA	DISIFY
08800	QDOT3:	TLO	DISIFY		;SET INTENSIFY.
08900		POP	P,D		;Z
09000		POP	P,C		;Y
09100		POP	P,B		;X
09200		TLNE	USXFRM		;NON-IDENTITY TRANSFORMATION?
09300		 PUSHJ	 P,XFORM3(S)	;YES -- DO IT.
09400		MOVEM	B,.XBEAM(R)
09500		MOVEM	C,.YBEAM(R)
09600		MOVEM	D,.ZBEAM(R)	;SAVE BEAM LOCATION.
09700	IFDEF BYPOK,<			;OK TO USE 3-D BYPASS
09800		TLNE	BYPASS		;IF BYPASSING
09900		 JRST	 BYPOINT(S)	;GO GENERATE POINT.
10000	>
10100		PUSHJ	P,CODE3(S)	;LOOK AT CODE.
10200		JUMPN	A,@.FRET(S)	;NOT INSIDE VIEWING PYRAMID
10300		PUSHJ	P,CONV3(S)	;AND CONVERT TO SCREEN COORDS.
10400		JRST	PGO(S)		;AND JOIN 2-D POINT CODE
10500	
10600	QVECT3:	MOVE	B,-5(P)		;X1
10700		MOVE	C,-4(P)		;Y1
10800		MOVE	D,-3(P)		;Z1
10900		TLNE	USXFRM		;NON-IDENTITY TRANSFORMATION?
11000		 PUSHJ	 P,XFORM3(S)	;YES -- CALL IT.
11100		MOVEM	B,.XBEAM(R)
11200		MOVEM	C,.YBEAM(R)	;SAVE BEAMS.
11300		MOVEM	D,.ZBEAM(R)
11400		POP	P,-3(P)
11500		POP	P,-3(P)
11600		POP	P,-3(P)
11700	QDRAW3:	POP	P,D
11800		POP	P,C
11900		POP	P,B		;X,Y,Z
12000		TLNE	USXFRM		;NON-IDENTITY TRANSFORMATION?
12100		 PUSHJ	 P,XFORM3(S)	;YES -- DO IT.
12200		MOVE	F,.XBEAM(R)	;NOW GET FIRST END OF THE LINE
12300		MOVE	G,.YBEAM(R)
12400		MOVE	H,.ZBEAM(R)
12500		MOVEM	B,.XBEAM(R)	;SECOND ENDPOINT
12600		MOVEM	C,.YBEAM(R)
12700		MOVEM	D,.ZBEAM(R)
12800	IFDEF BYPOK,<			;OK TO USE 3-D BYPASS
12900		TLNE	BYPASS
13000		 JRST	 BYVECTOR(S)	;GO GENERATE VECTOR
13100	>
13200		PUSHJ	P,WINDO3(S)	;DO THE THREE-D WINDOWING.
13300		JUMPN	A,@.FRET(S)	;NOTHING VISIBLE
13400		PUSHJ	P,CONV3(S)	;CONVERT POINT 2 TO SCREEN COORDS.
13500		EXCH	B,F
13600		EXCH	C,G
13700		MOVE	D,H		;
13800		PUSHJ	P,CONV3(S)	;AND CONVERT FIRST POINT.
13900		JRST	VGO(S)
14000	
14100	
     
00100	
00200	QWIND:	MOVE	A,[XWD -4,.YWT](S) ;PREPARE AOBJN POINTER
00300		ADDI	A,(R)		;RELOCATE
00400		POP	P,(A)		;SAVE PARAMETER
00500		AOBJN	A,.-1(S)	;LOOP FOR ALL 4
00600		JRST	WIN0(S)		;GO COMPUTE WINDOW/VIEWPORT PARMS.
00700	
00800	QPORT:	MOVE	A,[XWD -4,.YVT](S) ;PREPARE AOBJN POINTER
00900		MOVE	C,[YVIEW](S)	;GET LIMIT OF Y VIEWPORT
01000		ADDI	A,(R)
01100	WIN1:	POP	P,B
01200		SKIPL	B		;SEE IF WITHIN RANGE OF SCREEN
01300		CAMLE	B,C
01400		 ERR	 <VIEWPORT OUT OF BOUNDS>,7,<.+2> ;IF ERROR, DO NOT REPLACE OLD VALUE
01500		MOVEM	B,(A)		;SAVE IT.
01600		TLNE	A,1
01700		 MOVE	 C,[XVIEW](S)	;REPLACE WITH X LIMIT
01800		AOBJN	A,WIN1(S)	;LOOP
01900	WIN0:	MOVEI	A,.YPM(R)	;FIRST DO Y PARAMETERS
02000	WIN2:	MOVE	B,.YVT-.YPM(A)	;GET YT
02100		FSBR	B,.YVB-.YPM(A)	;YT-YB
02200		FMPR	B,[SMID](S)	;SMID*(YT-YB)
02300		MOVE	E,B		;SAVE
02400		MOVE	C,.YWT-.YPM(A)	;
02500		FSBR	C,.YWB-.YPM(A)	;WT-WB
02600		SKIPN	C		;MAKE SURE WE WILL NOT GET ZERO DIVIDES
02700		 TDZA	 B,B		;MULTIPLIER WILL BE ZERO.
02800		FDVR	B,C		;COMPUTE .YPM
02900		MOVEM	B,.YPM-.YPM(A)	;AND STORE IT.
03000		FMPR	B,.YWB-.YPM(A)	;WB*.YPM
03100		MOVE	C,.YVB-.YPM(A)	;VB
03200		FMPR	C,[SMID](S)	;SMID*VB
03300		MOVE	D,C		;SAVE
03400		FSBR	C,B		;...NOW HAVE .YPA
03500		MOVEM	C,.YPA-.YPM(A)	;SAVE IT.
03600		FDVRI	E,(<2.0>)	;GET VIEWPORT SIZE/2
03700		MOVEM	E,.Y3M-.YPM(A)	;SAVE AS MULTIPLIER
03800		FADR	D,E		;ADD TO SMID*VB
03900		MOVEM	D,.Y3A-.YPM(A)
04000		ADDI	A,.XPM-.YPM	;BUMP TO LOOK AT X
04100		CAIN	A,.XPM(R)	;OR HAVE WE ALREADY?
04200		 JRST	 WIN2(S)	;NO
04300		JRST	@.RET(S)	;YES
     
00100	
00200	QTEST2:	POP	P,C		;COMPUTE CODES FOR X,Y
00300		POP	P,B		;X
00400		TLNE	USXFRM		;NON-IDENTITY TRANSFORMATION?
00500		 PUSHJ	 P,XFORM2(S)	;YES -- DO IT.
00600		PUSHJ	P,CODE2(S)	;CALL IT.
00700		JRST	@.IRET(S)	;RETURN INTEGER
00800	
00900	CODE2:	SETZM	A
01000		TLZ	LAST3D		;LAST POSITION WAS A 2-D
01100		CAMGE	B,.XWL(R)	;X < WINDOW LEFT?
01200		 TRO	 A,1		;YES
01300		CAMLE	B,.XWR(R)	;X > WINDOW RIGHT?
01400		 TRO	 A,10		;YES
01500		CAMGE	C,.YWB(R)	;Y < WINDOW BOTTOM?
01600		 TRO	 A,100		;YES
01700		CAMLE	C,.YWT(R)	;Y > WINDOW TOP?
01800		 TRO	 A,1000		;YES
01900	CPOPJ:	POPJ	P,
02000	
02100	
02200	
02300	QTEST3:	POP	P,D		;Z
02400		POP	P,C		;Y
02500		POP	P,B		;X
02600		TLNE	USXFRM		;NON-IDENTITY TRANSFORMATION?
02700		 PUSHJ	 P,XFORM3(S)	;YES -- DO IT.
02800		PUSHJ	P,CODE3(S)	;CALL FOR CODES
02900		JRST	@.IRET(S)	;AND RETURN INTEGER.
03000	
03100	
03200	CODE3:	SETZM	A
03300		TLO	LAST3D		;LAST POSITION WAS A 3-D.
03400		MOVN	E,D		;E <== -Z
03500		CAMGE	B,E		;X < -Z ?
03600		 TRO	 A,1		;YES
03700		CAMLE	B,D		;X > Z ?
03800		 TRO	 A,10		;YES
03900		CAMGE	C,E		;Y < -Z ?
04000		 TRO	 A,100		;YES
04100		CAMLE	C,D		;Y > Z ?
04200		 TRO	 A,1000		;YES
04300		POPJ	P,
     
00100	
00200	;CONVERT PAGE COORDINATES IN AC B & C (ALSO D IF 3D) TO
00300	;SCREEN COORDINATES (FIXED POINT)
00400	;CONV3 DOES THE PERSPECTIVE DIVIDE; CONV2 DOES NOT.
00500	
00600	
00700	;MACRO FOR FIXING (EASILY)
00800	;X IS AN AC, > 0;  CLOBBERS AC X+1
00900	DEFINE FIXMAC (X) <
01000		MULI	X,400		;MAGIC ROUTINE
01100		TSC	X,X
01200		ASH	X+1,-242(X)
01300		ADDI	X+1,1		;ROUND IT UP.
01400		ASH	X+1,-1		;AND FINALLY SHIFT IT OUT.
01500		MOVE	X,X+1		;PUT BACK IN CORRECT AC
01600	>
01700	
01800	CONV3:	SKIPE	B		;DO NOT DIVIDE IF ALREADY 0
01900		FDVR	B,D		;X/Z
02000		SKIPE	C		;DITTO
02100		FDVR	C,D		;Y/Z  "PERSPECTIVE!!!!"
02200		PUSH	P,A		;SAVE AC.
02300		MOVEI	A,.Y3M(R)	;POINT TO 3D MULTIPLIERS
02400		JRST	CONVQ(S)	;AND CONVERT
02500	
02600	CONV2:	PUSH	P,A		;SAVE AC.
02700		MOVEI	A,.YPM(R)	;POINTER TO MULTIPLIERS.
02800	CONVQ:	PUSH	P,C		;SAVE SECOND ARG
02900		FMPR	B,.XPM-.YPM(A)	;CONVERT TO SCREEN COORDS.
03000		FADR	B,.XPA-.YPM(A)	;LIKE SO
03100		FIXMAC	B
03200		POP	P,C
03300		FMPR	C,.YPM-.YPM(A)	;CONVERT TO SCREEN COORDS.
03400		FADR	C,.YPA-.YPM(A)
03500		FIXMAC	C
03600	POPAJ:	POP	P,A		;RESTORE AC.
03700		POPJ	P,		;ALL DONE.
03800	
     
00100	
00200	;2-D WINDOW ROUTINE.  INPUT IS A LINE (X1,Y1) TO (X2,Y2).
00300	;	X1	AC B
00400	;	Y1	AC C
00500	;	X2	AC F
00600	;	Y2	AC G
00700	
00800	;THIS CLIPS THE LINE AGAINST THE 2-D WINDOW SPECIFIED BY THE
00900	;LAST DWIND CALL, AND RETURNS:
01000	
01100	;	AC A	NON-ZERO IF NO LINE VISIBLE; 0 IF SOMETHING VISIBLE
01200	;	(X1,Y1) AND (X2,Y2) AS ABOVE, MAYBE MODIFIED.
01300	
01400	;CLOBBERS A,D,E
01500	;MAY CHANGE B,C,F,G
01600	
01700	DEFINE EXLINE <
01800		EXCH	B,F
01900		EXCH	C,G
02000	>
02100	
02200	WINDOW:	PUSHJ	P,CODE2(S)	;FIND OUT WHETHER IT IS ON
02300		MOVEM	A,.COD1(R)	;SAVE ANSWER
02400		EXLINE
02500	WWM2:	PUSHJ	P,CODE2(S)	;FIND OUT ABOUT OTHER END.
02600		MOVEM	A,.COD2(R)	;SAVE IT TOO.
02700		EXLINE
02800	WWM:	SKIPE	A,.COD1(R)	;TEST POINT 1
02900		 JRST	 WWM1(S)	;IT IS OUTSIDE
03000		SKIPN	.COD2(R)	;TEST POINT 2
03100		 POPJ	 P,		;INSIDE -- RETURN WITH A=0
03200	WWM1:	TDNE	A,.COD2(R)	;SEE IF 'AND' IS NON-ZERO
03300		 POPJ	 P,		;YES -- RETURN WITH A NEQ 0
03400	
03500		JUMPE	A,WTS1(S)	;POINT 1 INSIDE?
03600		PUSHJ	P,WFIX2(S)	;FIX IT.
03700		PUSHJ	P,CODE2(S)	;GET ITS CODE.
03800		MOVEM	A,.COD1(R)
03900		JRST	WWM(S)		;AND GO CHECK AGAIN.
04000	
04100	WTS1:	SKIPN	A,.COD2(R)	;IS POINT 2 INSIDE ?
04200		 JRST	 WWM(S)		;YES -- GO LOOK AGAIN
04300		EXLINE
04400		PUSHJ	P,WFIX2(S)	;GO FIX IT.
04500		JRST	WWM2(S)		;CALL CODE, EXLINE, TEST.
04600	
04700	
04800	;CALLED BY WINDOW ROUTINE TO MOVE X1,Y1 TOWARD X2,Y2 UNTIL
04900	;AN EDGE IS INTERSECTED. WILL NOT WORK IF THERE IS NO INTERVENING
05000	;EDGE.  X1 AND Y1 ARE ALTERED.  X2 AND Y2 REMAIN UNALTERED.
05100	
05200	
05300	WFIX2:	TRNE	A,1100		;X OR Y OFF?
05400		 JRST	 WFIX23(S)	; Y
05500		TRNN	A,10		;X > RIGHT EDGE?
05600		 SKIPA	 E,.XWL(R)	;NO -- INTERSECT WITH LEFT EDGE
05700		MOVE	E,.XWR(R)	;YES -- INTERSECT WITH RIGHT EDGE.
05800		FSBR	C,G
05900		MOVE	D,E		;X = EDGE
06000		FSBR	D,F		;Y = ((EDGE-X2)/(X1-X2))*(Y1-Y2)+Y2
06100		FMPR	C,D
06200		FSBR	B,F
06300		FDVR	C,B
06400		FADR	C,G
06500		MOVE	B,E
06600		POPJ	P,		;TRY AGAIN.
06700	
06800	WFIX23:	TRNN	A,1000		;Y > TOP ?
06900		 SKIPA	 E,.YWB(R)	;NO -- INTERSECT WITH BOTTOM EDGE
07000		MOVE	E,.YWT(R)	;YES -- INTERSECT WITH TOP EDGE.
07100		FSBR	B,F
07200		MOVE	D,E		;X = ((EDGE-Y2)/(Y1-Y2))*(X1-X2)+X2
07300		FSBR	D,G		;Y = EDGE
07400		FMPR	B,D
07500		FSBR	C,G
07600		FDVR	B,C
07700		FADR	B,F
07800		MOVE	C,E
07900		POPJ	P,
08000	
08100	
     
00100	
00200	;THREED WINDOW ROUTINE.  INPUT IS A LINE (X1,Y1,Z1) TO (X2,Y2,Z2).
00300	;	X1	AC B
00400	;	Y1	AC C
00500	;	Z1	AC D
00600	;	X2	AC F
00700	;	Y2	AC G
00800	;	Z2	AC H
00900	
01000	;THIS CLIPS THE LINE AGAINST THE 3-D WINDOW SPECIFIED BY THE
01100	;LIMITS OF THE +- Z WINDOW, AND RETURNS:
01200	
01300	;	AC A	NON-ZERO IF NO LINE VISIBLE; 0 IF SOMETHING VISIBLE
01400	;	(X1,Y1,Z1) AND (X2,Y2,Z2) AS ABOVE, MAYBE MODIFIED.
01500	
01600	;CLOBBERS A,E
01700	;MAY CHANGE B,C,D,F,G,H
01800	
01900	DEFINE EXLINE <
02000		EXCH	B,F
02100		EXCH	C,G
02200		EXCH	D,H
02300	>
02400	
02500	WINDO3:	PUSHJ	P,CODE3(S)	;FIND OUT WHETHER IT IS ON
02600		MOVEM	A,.COD1(R)	;SAVE ANSWER
02700		EXLINE
02800	WWM23:	PUSHJ	P,CODE3(S)	;FIND OUT ABOUT OTHER END.
02900		MOVEM	A,.COD2(R)	;SAVE IT TOO.
03000		EXLINE
03100	WWM3:	SKIPE	A,.COD1(R)	;TEST POINT 1
03200		 JRST	 WWM13(S)	;IT IS OUTSIDE
03300		SKIPN	.COD2(R)	;TEST POINT 2
03400		 POPJ	 P,		;INSIDE -- RETURN WITH A=0
03500	WWM13:	TDNE	A,.COD2(R)	;SEE IF 'AND' IS NON-ZERO
03600		 POPJ	 P,		;YES -- RETURN WITH A NEQ 0
03700	
03800		JUMPE	A,WTS13(S)	;POINT 1 INSIDE?
03900		PUSHJ	P,WFIX3(S)	;FIX IT.
04000		PUSHJ	P,CODE3(S)	;GET ITS CODE.
04100		MOVEM	A,.COD1(R)
04200		JRST	WWM3(S)		;AND GO CHECK AGAIN.
04300	
04400	WTS13:	SKIPN	A,.COD2(R)	;IS POINT 2 INSIDE ?
04500		 JRST	 WWM3(S)	;YES -- GO LOOK AGAIN
04600		EXLINE
04700		PUSHJ	P,WFIX3(S)	;GO FIX IT.
04800		JRST	WWM23(S)	;CALL CODE, EXLINE, TEST.
04900	
05000	
05100	;CALLED BY WINDOW ROUTINE TO MOVE X1,Y1,Z1 TOWARD X2,Y2,Z2 UNTIL
05200	;AN EDGE IS INTERSECTED. WILL NOT WORK IF THERE IS NO INTERVENING
05300	;EDGE.  X1,Y1 AND Z1 ARE ALTERED.  X2,Y2 AND Z2 REMAIN UNALTERED.
05400	
05500	
05600	WFIX3:	HRLZS	A		;GET OUT CODE IN LEFT HALF.
05700		TLNN	A,11		;FIX UP X?
05800		 HRRI	 A,1		;NO -- Y
05900		CAML	D,B(A)		;DECIDE WHETHER TO INTERSECT WITH
06000		 TLO	 A,400000	;X=+Z OR X=-Z
06100		MOVE	E,D		;Z1
06200		FSBR	E,H		;Z1-Z2
06300		TLNE	A,400000	;SKIP IF A=+1
06400		 MOVNS	 E		;A*(Z1-Z2)
06500		FADR	E,F(A)	
06600		FSBR	E,B(A)		;A*(Z1-Z2)+X2-X1
06700		PUSH	P,E		;SAVE DIVISOR
06800		MOVE	E,D		;Z1
06900		TLNE	A,400000	;SKIP IF A=+1
07000		 MOVNS	 E		;-Z1
07100		FSBR	E,B(A)		;A*Z1-X1
07200		FDVRM	E,(P)		;COMPUTE T.
07300	
07400		MOVE	E,H
07500		FSBR	E,D		;Z2-Z1
07600		FMPR	E,(P)		;T*(Z2-Z1)
07700		FADRM	E,D		;Z1 _ T*(Z2-Z1)+Z1
07800	
07900		MOVEM	D,B(A)		;X1 _ A*Z1
08000		TLNE	A,400000	;SKIP IF A=+1
08100		 MOVNS	 B(A)
08200		
08300		TRC	A,1		;NOW UPDATE THE OTHER COORDINATE.
08400		MOVE	E,F(A)		;Y2
08500		FSBR	E,B(A)		;Y2-Y1
08600		FMPR	E,(P)		;T*(Y2-Y1)
08700		FADRM	E,B(A)		;Y1 _ T*(Y2-Y1)+Y1
08800		POP	P,A
08900		POPJ	P,		;RETURN.
     
00100	
00200	
00300	;TRANSFORM SETTING, PUSHING, POPPING.
00400	
00500	QAPPLY:	POP	P,A		;'NAME' OF MATRIX
00600		POP	P,B		;MATRIX POINTER.
00700		PUSHJ	P,@.GTMAT(S)	;TRANSFER MATRIX POINTED TO BY
00800					;B TO WORK-MATRIX
00900	MOVX:	HRLI	A,WORKM(R)	;TRANSFER WORK-MATRIX
01000		HRRI	A,MATRIX(R)	;TO CURRENT MATRIX
01100		BLT	A,MATRIX+=15(R) ;WITH A BLT!
01200	SET0:	TLO	USXFRM		;TENTATIVELY ASSUME NON-IDENTITY
01300		MOVEI	A,MATRIX(R)	;POINTER TO MATRIX ELEMENTS
01400		MOVEI	D,4		;A SPECIAL CLEVER LOOP TO DETECT UNIT MATRIX.
01500		MOVSI	B,(<1.0>)
01600	SET1:	CAME	B,(A)		;DIAGONAL POINT MUST BE 1
01700		 JRST	 @.RET(S)	;NOT A UNIT MATRIX.
01800		SOJE	D,SET2(S)	;DONE TESTING ?
01900		ADDI	A,1
02000		MOVEI	C,4		;THEN LOOK FOR 4 SUCCESSIVE ZEROES
02100		SKIPE	(A)
02200		 JRST	 @.RET(S)	;NOT ZERO.
02300		ADDI	A,1
02400		SOJG	C,.-3(S)	;LOOP
02500		JRST	SET1(S)
02600	SET2:	TLZ	USXFRM		;IT IS A UNIT MATRIX.
02700		JRST	@.RET(S)	;RETURN.
02800	
02900	QCOMPOS: POP	P,A		;MATRIX NAME
03000		POP	P,B		;MATRIX POINTER
03100		PUSHJ	P,@.GTMAT(S)	;TRANSFER TO WORKING MATRIX
03200	M0:	MOVEI	B,3		;MULTIPLY TWO MATRICES.
03300	M2:	MOVEI	A,3
03400	M1:	MOVEI	C,(A)		;GET ROW #
03500		LSH	C,2		;*4
03600		ADDI	C,WORKM(R)	;=> FIRST ONE IN ROW 'A'
03700		MOVEI	D,(B)
03800		ADDI	D,MATRIX(R)	;=> FIRST ONE IN COLUMN 'B'
03900		MOVE	E,(C)
04000		FMPR	E,(D)
04100		MOVE	F,1(C)
04200		FMPR	F,4(D)
04300		FADR	E,F
04400		MOVE	F,2(C)
04500		FMPR	F,=8(D)
04600		FADR	E,F
04700		MOVE	F,3(C)
04800		FMPR	F,=12(D)
04900		FADR	E,F
05000		PUSH	P,E		;SAVE ON STACK.
05100		SOJGE	A,M1(S)		;LOOP 1
05200		POP	P,(D)		;NOW UPDATE THE ENTIRE COLUMN
05300		POP	P,=4(D)
05400		POP	P,=8(D)
05500		POP	P,=12(D)
05600		SOJGE	B,M2(S)		;LOOP 2
05700		JRST	SET0(S)		;NOW CHECK ABOUT IDENTITY MATRIX.
05800	
05900	QRCOMP:	POP	P,A		;GET NAME
06000		MOVEI	B,MATRIX(R)	;WORKM_MATRIX
06100		PUSHJ	P,@.GTMAT(S)	;LIKE SO
06200		POP	P,C		;GET POINTER TO USER'S
06300		HRL	A,C		;NOW DO SWITCH...
06400		HRRI	A,MATRIX(R)	;MATRIX_USER'S MATRIX
06500		BLT	A,MATRIX+=15(R)	;LIKE SO
06600		JRST	M0(S)		;NOW DO COMPOSE STUFF!!
06700	
06800	
06900	QFLUSH:	MOVEI	D,1		;SET QFLUSH SWITCH
07000		JRST	QPOP0(S)	;GO DO IT
07100	
07200	QCURRE:	MOVEI	B,MATRIX(R)	;PUT CURRENT MATRIX INTO WORK
07300		PUSHJ	P,@.GTMAT(S)	;MATRIX (TRANSPOSE IF FORTRAN)
07400		POP	P,A		;PICK UP DESTINATION
07500		HRLI	A,WORKM(R)	;SET SOURCE
07600		BLT	A,=15(A)
07700		JRST	@.RET(S)	;BYE
07800	
07900	QVMULT:	POP	P,A		;GET ADDRESS OF SOURCE
08000		MOVE	B,(A)		;GET X
08100		MOVE	C,1(A)		;Y
08200		MOVE	D,2(A)		;Z
08300		PUSHJ	P,XFORM3(S)	;NOW MULT BY MATRIX
08400		POP	P,A		;GET ADDRESS OF DESTINATION
08500		MOVEM	B,(A)		;PUT BACK X'
08600		MOVEM	C,1(A)		;Y'
08700		MOVEM	D,2(A)		;Z'
08800		JRST	@.RET(S)	;BYE
08900	
09000	
09100	QPUSH:	POP	P,A		;MATRIX NAME
09200		MOVEI	C,=16		;GET CORE FOR 4X4 MATRIX.
09300		PUSHJ	P,GETCOR(S)	;CALL CORE ROUTINES
09400		JUMPE	B,[ERR <NO CORE FOR QPSHF>,11,<@.RET>](S)
09500		MOVE	C,.PSHLIST(R)	;GET POINTER TO LIST.
09600		HRRM	C,-1(B)		;CHAIN LIST ON CURRENT.
09700		MOVEM	B,.PSHLIST(R)	;SAVE CURRENT TOP OF STACK.
09800		HRLI	B,MATRIX(R)	;CURRENT MATRIX.
09900		MOVEI	C,=15(B)	;END OF AREA
10000		BLT	B,(C)		;AND BLT.
10100		JRST	@.RET(S)	;DONE.
10200	
10300	QPOP:	POP	P,A		;MATRIX NAME
10400		MOVEI	D,0		;UNSET QFLUSH SWITCH
10500	QPOP0:	SKIPN	B,.PSHLIST(R)	;SEE IF THERE IS A LIST.
10600		JRST	LOADI(S)	;IF EMPTY, LOAD IDENTITY
10700		HRRZ	C,-1(B)		;ELSE, POINTER TO REMAINDER.
10800		MOVEM	C,.PSHLIST(R)
10900		MOVS	C,B
11000		HRRI	C,MATRIX(R)	;PLACE TO PUT IT.
11100		BLT	C,MATRIX+=15(R) ;TRANSFER IT!
11200		PUSH	P,D		;DON'T LET RELCOR HURT IT
11300		PUSHJ	P,RELCOR(S)	;RELEASE CORE.
11400		POP	P,D		;THERE, ALL SAFE
11500		JUMPN	D,QPOP0(S)	;LOOP IF FROM QFLUSH
11600		JRST	SET0(S)		;GO SEE IF MATRIX IS UNITY.
11700	
11800	LOADI:	SETZM	MATRIX+1(R)	;FIRST ZERO OUT MATRIX
11900		HRRI	A,MATRIX+2(R)	;SET DESTINATION
12000		HRLI	A,MATRIX+1(R)	;SET SOURCE
12100		BLT	A,=13(A)	;CLEAR OUT REST, THEN
12200		MOVSI	A,(<1.0>)	;SET UP FLOATING ONE
12300		MOVEM	A,MATRIX(R)	;MATRIX[1,1]
12400		MOVEM	A,MATRIX+5(R)	;MATRIX[2,2]
12500		MOVEM	A,MATRIX+=10(R)	;MATRIX[3,3]
12600		MOVEM	A,MATRIX+=15(R)	;MATRIX[4,4]
12700		TLZ	USXFRM		;SAY IT'S IDENTITY MATRIX
12800		JRST	@.RET(S)	;BYE
12900	
13000	
13100	;TRANSFORMATION ROUTINES.
13200	;	X	ACCUMULATOR B
13300	;	Y	ACCUMULATOR C
13400	;	Z	ACCUMULATOR D (IF 3D TRANSFORM)
13500	;
13600	;TRANSFORMED VALUES RETURNED IN B,C,D
13700	;DESTROYS D,E,F
13800	
13900	XFORM2:	MOVEI	D,0		;ASSUME Z=0 FOR 2D XFORM
14000	XFORM3:
14100	DEFINE COM (I) <
14200		MOVE	F,B
14300		FMPR	F,I+MATRIX(R)	  ;X*M[1,I+1]
14400		MOVE	E,C
14500		FMPR	E,4+I+MATRIX(R)	  ;Y*M[2,I+1]
14600		FADR	F,E
14700		MOVE	E,D
14800		FMPR	E,=8+I+MATRIX(R)  ;Z*M[3,I+1]
14900		FADR	F,E
15000		FADR	F,=12+I+MATRIX(R)  ;+M[4,I]
15100	>
15200	
15300		COM (0)			;COMPUTE X
15400		PUSH	P,F
15500		COM (1)			;COMPUTE Y
15600		PUSH	P,F
15700		COM (2)			;COMPUTE Z
15800		MOVE	D,F		;C <== Z
15900		POP	P,C		;C <== Y
16000		POP	P,B		;B <== X
16100		POPJ	P,		;RETURN.
16200	
16300	
     
00100	
00200	;PLOTTING ROUTINES.
00300	; THIS ROUTINE DOES ALL THE SET-UP AND OPENS THE FILE.
00400	; THEN IT CALLS THE ROUTINE 'PLTIT', WHICH IS A DEVICE-DEPENDENT
00500	; SUBROUTINE FOR ACTUALLY DUMPING OUT DISPLAY FILE CODES.  IT MAY
00600	; CALL THE ROUTINE 'PL' TO OUTPUT A WORD IN AC 'A'.
00700	; THE ROUTINE 'PLTIT' SHOULD NOT  FIDDLE WITH ACS F,G,G+1(H)
00800	; BECAUSE 'PL' USES THESE.
00900	
01000	
01100	QPLOT:	POP	P,B		;FILE NAME
01200		POP	P,.COD1(R)	;A SAVE PLACE FOR THE POINTER TO A BUFFER.
01300		MOVEI	C,17
01400		MOVSI	D,'DSK'		;PREPARE ARGS IN AC'S
01500		SETZM	E
01600		OPEN	C		;OPEN THE CHANNEL
01700		 ERR	 <NO DISK TODAY>,10,<@.RET>
01800		MOVSI	C,'PLX'		;EXTENSION.
01900		JUMPN	B,PLARG(S)	;HE SPECIFIED A FILE NAME
02000		MOVEI	F,0		;START WITH THIS FILE NUMBER
02100	PLAG:	PUSH	P,F		;SAVE NUMBER
02200		MOVE	B,[SIXBIT / 00000/](S)
02300		IDIVI	F,=10		;DIVIDE
02400		DPB	G,[POINT 4,B,35](S) ;AND IN GOES THE NUMBER
02500		ROT	B,-6		;SHIFT AROUND
02600		JUMPN	F,.-3(S)	;LOOP UNTIL NUMBER EXHAUSTED
02700		POP	P,F		;RESTORE NUMBER
02800		ROT	B,-6		;SHIFT SOME MORE
02900		TLOE	B,200000	;UNTIL BACK HOME!
03000		 JRST 	 .-2(S)		;MORE TO GO!
03100		SETZM	E
03200		MOVE	A,[LOOKUP B](S)	;LOOKUP A FILE.
03300		XCT	A		;TRY TO LOOKUP
03400		 JRST	 PLOK(S)		;OK.
03500		TDC	A,[XWD 6000,B](S) ;CHANGE TO CLOSE
03600		XCT	A
03700		AOJA	F,PLAG(S)	;TRY AGAIN WITH HIGHER NUMBER.
03800	PLOK:	TDC	A,[XWD 6000,B](S)
03900		XCT	A		;CLOSE
04000	PLARG:	SETZB	D,E		;ZERO PPN AND CREATION DATE.
04100		ENTER	B		;ENTER
04200		 ERR	 <SHOULD NOT HAPPEN>,10,<@.RET>
04300		PUSHJ	P,OUTPL(S)	;SEND A BUFFER FULL OF USER INFO.
04400		MOVEI	A,DISNUM	;SEND OUR NUMBER.
04500		PUSHJ	P,PL(S)		;SEND IT.
04600		PUSHJ	P,PLTIT(S)	;AND PLOT THIS DISPLAY.
04700		MOVEI	A,0		;TERMINATE WITH A ZERO.
04800		PUSHJ	P,PL(S)		;LIKE SO.
04900		PUSHJ	P,OUTPL(S)	;DUMP LAST BUFFER
05000		RELEASE		;RELEASE I/O CHANNEL
05100		JRST	@.RET(S)	;RETURN.
05200	
05300	;PL	WRITE ONE WORD (IN A) ONTO THE PLOT FILE.  ASSUMES AC G
05400	;	IS SET UP WITH AOBJN WORD TO POINT TO BUFFER.  THIS
05500	;	ROUTINE CHANGES G; MAY ALSO CHANGE F.
05600	
05700	
05800	PL:	MOVEM	A,1(G)		;STORE WORD.
05900		AOBJN	G,CPOPJ(S)	;RETURN.
06000	OUTPL:	HRLI	G,-=128
06100		HRR	G,.COD1(R)	;ADDRESS
06200		SUBI	G,1		;MAKE IOWD
06300		SETZM	G+1		;END OF LIST.
06400		OUTPUT	G
06500		POPJ	P,		;RETURN.
     
00100	
00200	
00300	; ENVIRONMENT ENQUIRY CALL.
00400	
00500	QENQ:	MOVNI	A,1		;UPDATE CHARACTER NUMBERS
00600		PUSHJ	P,QTEXT(S)	;SINCE LAST DTSCAL CALL.
00700		POP	P,A		;POINTER TO USER DATA AREA.
00800		MOVEI	B,(A)		;COPY POINTER TO RIGHT HALF OF B.
00900		HRLI	B,ENQTAB(S)	;GET POINTER TO FIXED DATA AREA.
01000		BLT	B,7(A)		;STORE TOTAL OF =8 PARAMS.
01100		HRLI	A,-=15		;15 MORE THINGS COME FROM DATA ARE.
01200		MOVEI	B,CHARH(R)	;FIRST THING TO BE MOVED.
01300	ENQ1:	MOVE	C,(B)		;PICK UP ENTRY.
01400		MOVEM	C,=8(A)		;STORE IN USER ARRAY.
01500		SUBI	B,1		;BACK DOWN.
01600		AOBJN	A,ENQ1(S)	;LOOP FOR ALL VARBS.
01700		JRST	@.RET(S)
01800	
01900	
02000	QCHAR:	POP	P,A		;GET CHARACTER CODE.
02100		IDIVI	A,=18
02200		ADDI	A,CHARTB(S)	;RELOCATE
02300		MOVE	A,(A)		;GET WORD.
02400		LSH	B,1		;MULTIPLY REMAINDER BY 2
02500		ROT	A,2(B)		;AND GET 2-BIT IN POSITION
02600		ANDI	A,3		;GET TWO BITS.
02700		CAIN	A,3
02800		 MOVNI	 A,1		;-1
02900		JRST	@.IRET(S)
03000	
03100	
03200	QTSCAL:	POP	P,TSCAL(R)	;SAVE FOR DTEXT TO INTERPRET
03300		JRST	@.RET(S)	;AND RETURN.
03400	
     
00100	
00200	
00300	; CORE ROUTINES
00400	
00500	;THESE ARE FAIRLY DEVICE-INDEPENDENT.  HOWEVER,  THE 340 MUST BE
00600	;STOPPED BEFORE ATTEMPTING TO EXPAND CORE.  FOR A HIGH SEGMENT
00700	;DISPLAY FILE, THIS PIECE OF CODE IS INDICATED WITH $$$ BELOW.
00800	;IF THE DISPLAY FILE IS IN THE LOW SEGMENT, THEN THE LANGUAGE
00900	;OPERATING SYSTEM EXPANDS CORE AND CALLES ROUTINES IN THE OMNI
01000	;LANGUAGE DEPENDENT MODULE TO HANDLE STOPPING THE 340.
01100	
01200	;VARIABLES  USED BY THE OMNI CORE ALLOCATOR IF THERE IS A HISEG DISPLAY FILE:
01300	;	FRELST		FREE STORAGE LIST
01400	;	CORLO		LOWEST PIECE OF CORE (FIRST WORD)
01500	;	CORHI		HIGHEST PIECE OF CORE (LAST WORD)+1
01600	
01700	
01800	;LAYOUT OF A CORE BLOCK IS:
01900	
02000	;		XWD LENGTH,,0
02100	;	B ==>	...
02200	;		...
02300	;		...
02400	;		XWD LENGTH,,B-1
02500	
02600	;
02700	;LENGTH IS NEGATIVE WHEN BLOCK IS IN USE, POSITIVE OTHERWISE.
02800	;
02900	
03000	
03100	;IF THE DISPLAY FILE IS IN THE HIGH SEGMENT, THE FREE-STORAGE LIST
03200	;IS LINKED THROUGH THE WORD POINTED TO BY B. THIS WORD IS,
03300	;HOWEVER, AVAILABLE TO THE USER AFTER THE BLOCK HAS BEEN REMOVED
03400	;FROM THE FREE-STORAGE LIST.  THE LOW SEGMENT METHOD OF CORE
03500	;ALLOCATION DOES NOT MAINTAIN ITS OWN FREE SPACE LIST BUT DEPENDS
03600	;ON THE LANGUAGE OPERATING SYSTEM FOR THIS.
03700	;
03800	
03900	
04000	;THE ROUTINES GETCOR,RELCOR, AND PUTCOR ALL CLOBBER AC'S: B,C,D,E.  
04100	;
04200	;CALLS:
04300	;
04400	;SEIZE CORE:
04500	;	MOVE C,LENGTH-OF-CORE
04600	;	PUSHJ P,GETCOR(S)
04700	;	  == B HAS RESULT. 0 IF NO CORE AVAILABLE
04800	;
04900	;RELEASE CORE:
05000	;	MOVE B,GETCOR-RESULT
05100	;	PUSHJ P,RELCOR(S)
05200	;
05300	;CUT BACK PARTIALLY FULL BLOCK:
05400	;	MOVE B,GETCOR-RESULT-FOR-ORIGINAL-BLOCK
05500	;	MOVE C,LAST-ADDRESS-ACTUALLY-USED
05600	;	PUSHJ P,PUTCOR(S)
05700	
05800	
05900	?TRIVIAL __ =10	;PARAMETER FOR CORE ROUTINES.
06000	
06100	
06200	QCORGET: POP	P,C		;GET SIZE FIELD.
06300		PUSHJ	P,GETCOR(S)	;CALL FOR CORE.
06400		MOVE	A,B		;RETURN ADDRESS.
06500		JRST	@.IRET(S)
06600	
06700	QCORREL: POP	P,B		;GET ADDRESS OF CORE AREA.
06800		PUSHJ	P,RELCOR(S)	;RETURN IT.
06900		JRST	@.RET(S)
07000	
07100	
07200	;FIRST, THREE SUBROUTINES (REGSAV, REGRST, AND GETIT) WHICH ARE
07300	;USED WHEN THE DISPLAY FILE IS IN THE LOW SEG AND THE LANGUAGE
07400	;OPERATING SYSTEM HANDLES CORE ALLOCATION
07500	
07600	
07700	;REGSAV AND REGRST ARE USED TO SAVE AND RESTORE AC'S BEFORE
07800	;CALLING THE LANGUAGE CORE ALLOCATION ROUTINES . . .
07900	
08000	REGSAV:	MOVEM	P,.ACSAV+17(S)	;SAVE REG P TO BE USED IN BLT
08100		MOVEI	P,.ACSAV(S)	;SETUP BLT WORD
08200		BLT	P,.ACSAV+16(S)
08300		MOVE	P,.ACSAV+17(S)	;RESTORE P
08400		MOVE	A,S		;SAVE AC S IN AC A
08500					;S IS NEEDED TO CALL THE AC
08600					;RESTORE ROUTINE BUT S IS CHANGED
08700					;BY THE LANGUAGE . . . A IS NOT
08800	
08900	
09000		POPJ	P,
09100	
09200	REGRST:	MOVEM	P,.ACSAV+17(S)	;SAVE REG P TO BE USED IN BLT
09300		MOVSI	P,.ACSAV(S)	;SETUP BLT WORD
09400		BLT	P,16
09500		MOVE	P,.ACSAV+17(S)	;RESTORE P
09600		POPJ	P,
09700	
09800	
09900	
10000	
10100	;GETIT ---	ROUTINE TO SAVE AC'S , CALL LANGUAGE CORE
10200	;		ALLOCATOR, AND RESTORE AC'S 
10300	;		C HAS SIZE OF BLOCK WANTED.
10400	;		B ==> CORE, ON EXIT.  IF 0, NO CORE AVAILABLE.
10500	
10600	GETIT:
10700	
10800		PUSHJ	P,REGSAV(S)	;SAVE REGISTERS
10900		SKIPL	.LANG(S)	;IS THE LANGUAGE FORTRAN?
11000		JRST	GETFOR(S)	;YES
11100		PUSHJ 	P,@.GET(S)	;CALL SAIL CORE ALLOCATOR
11200					;ERROR RETURN
11300		JRST	GETF2(S)	;ERROR RETURN
11400		MOVE	S,A		;RESTORE S SO CALL TO REGRST WILL WORK
11500		MOVEM	B,.ACSAV+2(S)	;RETURN B
11600		PUSHJ	P,REGRST(S)	;RESTORE AC'S
11700	;CLEAR CORE RETURNED FROM SAIL
11800	;
11900		HRRZ	D,B		;GET PTR TO BLOCK OF CORE
12000		ADDI	D,-1(C)		;POINT TO LAST WORD OF BLOCK
12100	GETC1:	SETZM	(D)		;CLEAR WORD IN BLOCK
12200		SOS	D		;POINT TO NEXT WORD
12300		CAML	D,B		;DONE WITH BLOCK?
12400		JRST	GETC1(S)		;NO
12500	
12600		AOS	(P)	;SKIP RETURN
12700		POPJ	P,
12800	
12900	;HERE IF LANGUAGE IS FORTRAN
13000	
13100	GETFOR:	MOVEM	C,ARGBLK(S)	;SETUP ARGUMENT BLOCK
13200	        MOVEI	16,ADDR(S)		;SETUP CALL TO FORTRAN CORE ALLOCATOR
13300	        PUSHJ	P,@.GET(S)		;CALL FORTRAN
13400	        JUMPGE	0,GETF1(S)		;CORE ALLOCATED OK?
13500	GETF2:	MOVE	S,A		;NO-RESTORE REGS
13600		PUSHJ	P,REGRST(S)
13700	        JRST	NNCOR(S)		
13800	GETF1:	MOVE	S,A		;RESTORE REGS
13900		MOVEM	0,.ACSAV+2(S)	;SETUP B
14000		PUSHJ	P,REGRST(S)
14100	        AOS	(P)		;SKIP RETURN
14200	        POPJ	P,
14300	
14400	;ARGUMENT BLOCK FOR FORTRAN CORE ALLOCATION
14500	ADDR:	XWD	15,ARGBLK
14600		-1
14700	ARGBLK:	0
14800	
14900	
15000	NNCOR:	TTCALL	3,[ASCIZ /NO CORE FOR DISPLAY
15100	/](S)
15200		TLO	NOCORE!NOMOCOD	
15300		MOVEI	B,0		;RETURN 0
15400		PUSHJ	P,@.PADR(S)	;FIXUP PATCH ADDRESS
15500		POPJ	P,		;NO-SKIP RETURN
15600	
15700	
15800	
15900	;NOW, TWO SUBROUTINES (UNLINK AND RELINK) USED WHEN THE DISPLAY
16000	;FILE IS IN THE HISEG AND OMNI HANDLES CORE ALLOCATION
16100	
16200	
16300	;UNLINK --	B ==> BLOCK TO UNLINK FROM FS LIST.
16400	;		CLOBBERS AC'S D,E
16500	
16600	UNLINK:	HRRZ	D,1(B)		;NEXT POINTER
16700		HLRZ	E,1(B)		;PREVIOUS POINTER
16800		SKIPN	E
16900		 MOVEI	 E,FRELST-1(R)
17000		HRRM	D,1(E)		;PUT POINTER TO NEXT IN PREVIOUS
17100		SKIPE	D
17200		 HRLM	 E,1(D)		;AND POINTER TO PREVIOUS IN NEXT
17300		POPJ	P,
17400	
17500	;RELINK		B ==> BLOCK TO PUT ON FS LIST.
17600	;		C (LH) HAS SIZE OF BLOCK AS POSITIVE NUM
17700	;		CLOBBERS D
17800	
17900	RELINK:	HLRZ	D,C		;GET SIZE
18000		HRRI	C,(B)		;SAVE POINTER TO FIRST WORD
18100		ADDI	D,(B)		; D ==> LAST+1
18200		MOVEM	C,-1(D)		;STORE TOP WORD.
18300		HLLZM	C,(B)		;SAVE SIZE
18400		SKIPE	D,FRELST(R)	;IS THERE A FREE LIST?
18500		 HRLM	 B,1(D)		;IF SO MAKE THIS PREVIOUS
18600		HRRZM	D,1(B)		;MAKE REST OF LIST NEXT
18700		HRRZM	B,FRELST(R)	;AND THIS IS HEAD OF LIST
18800		POPJ	P,
18900	
19000	
19100	;GETCOR IS CALLED TO GET A PIECE OF CORE.
19200	; C   HAS SIZE OF PIECE DESIRED.
19300	; B ==> CORE ON EXIT.  IF 0, NO CORE WAS AVAILABLE.
19400	; CLOBBERS ACS: B,C,D,E
19500	
19600	GETCOR:	ADDI	C,2		;ACCOUNT FOR BLOCK STRUCTURE OVERHEAD
19700		SKIPE	.SEG(S)		;HISEG DISPLAY FILE?
19800		JRST	COR0(S)		;YES
19900		PUSHJ	P,GETIT(S)		;ACTUALLY GET CORE FROM LANGUAGE
20000					;CORE ALLOCATOR
20100		POPJ	P,		;ERROR RETURN - NOT ENOUGH CORE
20200		PUSH	P,B		;SAVE POINTER
20300		MOVNS	C		;GET NEGATIVE OF SIZE
20400		HRLM	C,(B)		;PUT IN SIZE FIELD OF BLOCK
20500		MOVE	E,B		;COMPUTE LAST ADDRESS
20600		SUB	E,C		;E ==> LAST ADDRESS + 1
20700		HRL	B,C		;SETUP LAST WORD OF BLOCK
20800		MOVEM	B,-1(E)		
20900		POP	P,B		;RESTORE POINTER
21000		ADDI	B,1		;POINT TO FIRST USABLE WORD
21100		HLLZS	(B)		;ZERO RIGHT HALF
21200		POPJ	P,
21300	
21400	
21500	;HERE IF HISEG DISPLAY FILE TO ALLOW OMNI TO HANDLE
21600	;CORE ALLOCATION
21700	
21800	
21900	COR0:	MOVEI	B,FRELST-1(R)	;SEARCH FREE LIST
22000	COR1:	HRRZ	B,1(B)		;FIND A BLOCK
22100		JUMPE	B,EXPAND(S)	;REACHED END OF LIST?
22200		HLRZ	D,(B)		;GET SIZE (+ NUMBER)
22300		CAMLE	C,D		;WILL IT SATISFY THE REQUEST?
22400		 JRST	 COR1(S)	;NO -- LOOK SOME MORE.
22500		PUSHJ	P,UNLINK(S)	;YES -- UNLINK IT FROM FRELIST
22600		HLRZ	D,(B)		;GET REAL BLOCK SIZE AGAIN.
22700		PUSH	P,B		;SAVE POINTER
22800		CAIGE	D,TRIVIAL(C)	;IS DIFFERENCE NEGLIGIBLE?
22900		 MOVE	 C,D		;YES -- ASSUME USER WANTS IT ALL
23000		MOVNS	C
23100		HRLM	C,(B)		;SIZE FIELD OF THIS BLOCK
23200		MOVE	E,B		;COMPUTE LAST ADDRESS
23300		SUB	E,C
23400		HRL	B,C
23500		MOVEM	B,-1(E)		;LAST POINTER.
23600		MOVE	B,E		;REMAINING BLOCK
23700		ADD	C,D
23800		MOVSS	C
23900		SKIPE	C		;BLOCK EMPTY?
24000		 PUSHJ	 P,RELINK(S)	;NO -- RELINK REMAINDER ON LIST
24100		POP	P,B		;RESTORE POINTER
24200		ADDI	B,1		;POINT TO FIRST USABLE WORD.
24300		HLLZS	(B)		;ZERO RIGHT HALF
24400		POPJ	P,
24500	
24600	
24700	;HERE WHEN DISPLAY FILE IS IN HISEG AND CORE MUST BE
24800	;EXPANDED
24900	
25000	EXPAND:
25100	IFDEF DEC340,< ;$$$$$$$ FOLLOWING CODE IS ONLY FOR 340 $$$$$$$$
25200		PUSH	P,C
25300		PUSH	P,XSTAT(R)		;SAVE DEVICE RUN BITS
25400		TLNN	DISRUN		;IS DISPLAY GOING?
25500		 JRST	 EXP0(S)	;NO
25600		MOVE	D,[XWD 4,400007](S) ;STOP AND UNLOCK
25700		DISCAL	D		;DO IT.
25800	EXP0:	HRRZ	B,.JBHRL	;GET CURRENT CORE HOLDINGS
25900		ADDI	B,2001		;BUMP BY 1K.
26000		MOVSI	D,-1(B)		;PREPARE FOR CORE CALL
26100		CALLI	D,11		;TRY FOR SOME MORE OF THE SAME
26200		 JRST	 NOCOR(S)	;NONE LEFT IT APPEARS
26300		EXCH	B,CORHI(R)	;AND MAKE IT CURRENT HIGH
26400		HRLI	B,-2000
26500		MOVEM	B,(B)		;MAKE IT LOOK LIKE A BLOCK
26600		MOVEM	B,1777(B)	;LAST POINTER, TOO.
26700		PUSHJ	P,CORRL(S)	;SOME NICE GUY IS RETURNING A LOT OF CORE!!
26800		POP	P,C		;RESTORE DEVICE RUN BITS
26900	
27000		TLNN	DISRUN		;SHOULD WE TRY TO GET GOING AGAIN?
27100		 JRST	 EXP1(S)	;NO
27200		MOVEI	B,XSTAT(R)
27300		HRLI	B,1
27400		DISCAL	B		;TRY TO SEIZE IT AGAIN
27500		 JRST	 EXP2(S)	;COULD NOT!!
27600		HRLI	C,3		;START DEVICES
27700		DISCAL	C		;WITH SYSTEM
27800	EXP1:	POP	P,C		;RESTORE SIZE
27900		JRST	COR0(S)		;AND TRY AGAIN.
28000	
28100	EXP2:	TTCALL 3,[ASCIZ /CANNOT RE-SEIZE DISPLAY
28200	/](S)
28300		TLZ	DISRUN		;SAY NO LONGER RUNNING
28400		JRST	EXP1(S)
28500	
28600	NOCOR:	TTCALL 3,[ASCIZ /NO CORE FOR DISPLAY
28700	/](S)
28800		TLO	NOCORE!NOMOCOD
28900		SUB	P,[XWD 2,2](S)	;GIVE UP ON STACK.
29000		MOVEI	B,0		;RETURN 0 AND HOPE
29100		POPJ	P,
29200	
29300	>		;$$$$$$$  END OF DEC340 STUFF
29400	
29500	
29600	IFNDEF DEC340, <	;$$$$$$$ NORMAL CORE EXPANSION CODE $$$$$$$
29700		TLNN	USECOR		;ARE WE ALLOWED TO EXPAND CORE?
29800		 JRST	 NOCOR(S)	;NO -- QUIT.
29900		HRRZ	B,.JBHRL	;GET CURRENT SECOND SEGMENT ASSIGNMENT
30000		ADDI	B,2001		;BUMP BY 1 K.
30100		MOVSI	D,-1(B)		;PREPARE FOR CORE CALL
30200		CALLI	D,11		;CORE UUO
30300		 JRST	 NOCOR(S)
30400		EXCH	B,CORHI(R)	;STORE NEW TOP.
30500		HRLI	B,-2000		;AND LENGTH
30600		MOVEM	B,(B)		;GIVE IT A BOTTOM POINTER
30700		MOVEM	B,1777(B)	;AND A TOP POINTER
30800		PUSH	P,C		;SAVE AC
30900		PUSHJ	P,CORRL(S)	;GIVE BACK SOME CORE?
31000		POP	P,C
31100		JRST	COR0(S)		;TRY AGAIN.
31200	
31300	NOCOR:	TTCALL	3,[ASCIZ /NO CORE FOR DISPLAY
31400	/](S)
31500		TLO	NOCORE!NOMOCOD
31600		MOVEI	B,0
31700		POPJ	P,
31800	
31900	>
32000	
32100	
32200	;RELCOR -- RELEASE CORE TO FREE STORAGE.
32300	;	B ==> CORE BLOCK, AS RETURNED FROM GETCOR
32400	
32500	RELCOR:	SUBI	B,1	;POINT TO FIRST WORD
32600		SKIPE	.SEG(S)	;HISEG DISPLAY FILE?
32700		JRST	CORRL(S)	;YES
32800		TLZ	NOCORE	;THIS SHOULD MAKE SOME MORE CORE
32900		PUSHJ	P,REGSAV(S)	;SAVE AC'S
33000		SKIPL	.LANG(S)		;IS THE LANGUAGE FORTRAN?
33100		JRST	[MOVEM	B,ARGBLK(S)	;YES-SETUP ARGBLK
33200			 MOVEI	16,ADDR(S)
33300			 JRST	.+1(S)](S)
33400		PUSHJ	P,@.REL(S)	;CALL LANGUAGE CORE ALLOCATION
33500					;ROUTINE TO FREE CORE
33600		MOVE	S,A		;RESTORE S SO CALL TO REGRST WILL WORK
33700		PUSHJ	P,REGRST(S)	;RESTORE AC'S
33800		POPJ	P,		
33900	
34000	
34100	;HERE IF HISEG DISPLAY FILE AND OMNI IS HANDLING CORE ALLOCATION
34200	
34300	CORRL:	TLZ	NOCORE		;THIS SHOULD MAKE SOME MORE CORE
34400		HLLZS	(B)		;JUST KEEP COUNT
34500		MOVN	C,(B)		;LEFT HALF IS SIZE
34600	CORR0:	HLRZ	D,C		;SIZE
34700		ADDI	D,(B)		;POINT TO LAST WORD +1
34800		CAML	D,CORLO(R)
34900		CAMLE	D,CORHI(R)
35000		 ERR	 <BAD CORE POINTER>,9
35100		CAME	B,CORLO(R)	;AT VERY BOTTOM OF CORE?
35200		SKIPGE	-1(B)		;OR PREVIOUS BLOCK IN USE?
35300		 JRST	 CORR1(S)	;YES -- CAN DO NOTHING HERE
35400		HRRZ	B,-1(B)		;GET POINTER TO LOWER BLOCK
35500		PUSHJ	P,UNLINK(S)	;REMOVE IT FROM FS.
35600		ADD	C,(B)		;AND BUMP SIZES.
35700		JRST	CORR0(S)
35800	CORR1:	CAME	D,CORHI(R)	;IF AT VERY TOP
35900		SKIPGE	(D)		;OR BLOCK ON TOP IN USE
36000		 JRST	 CORR2(S)	;NOTHING WE CAN DO
36100		PUSH	P,B
36200		HRRZ	B,D
36300		PUSHJ	P,UNLINK(S)	;UNLINK BLOCK ABOVE
36400		ADD	C,(B)		;AND BUMP SIZE.
36500		POP	P,B
36600	CORR2:	JRST	RELINK(S)	;PUT WHOLE THING ON FS LIST.
36700	
36800	
36900	;PUTCOR -- ROUTINE TO CUT DOWN A CORE BLOCK TO SIZE ACTUALLY
37000	;		USED.  ENTER WITH B==> CORE BLOCK,
37100	;		C HAS LAST ADDRESS USED.
37200	
37300	
37400	
37500	PUTCOR:	SKIPE	.SEG(S)		;HISEG DISPLAY FILE?
37600		JRST	PUTHI(S)	;YES
37700		SKIPL	.LANG(S)		;IS THE LANGUAGE FORTRAN?
37800	        JRST	PUTFOR(S)		;YES
37900		MOVN	E,-2(B)	;E_LNTH ALLOCATED BY SAIL (POS)
38000		SUBI	E,3	;SUBTRACT OUT 3 EXTRA WORDS FOR
38100				;SAIL OVERHEAD
38200		PUSH	P,E	;SAVE
38300		MOVEI	D,-1(B)	;COMPUTE LENGTH ACTUALLY USED (NEGATIVE)
38400		SUBI	D,2(C)	
38500		PUSH	P,D	;SAVE
38600		SUBI	B,1	;B==>1ST REAL WORD OF BLOCK
38700		HRLZM	D,(B)	;SAVE LNTH IN 1ST WORD OF BLOCK
38800		HRLM	D,1(C)	;AND IN NEW LAST WORD
38900		HRRM	B,1(C)	;SAVE PTR TO 1ST WORD
39000		SUBI	D,3	;FIXUP SAIL "SIZE" WORD
39100		MOVEM	D,-1(B)
39200		MOVSI	E,400000	;FIXUP SAIL TRAILER WORD
39300		HRRI	E,-2(B)
39400		MOVEM	E,2(C)	
39500		POP	P,D	
39600		MOVNS	D	;D_LNTH USED
39700		MOVE	E,(P)	;E_LNTH ALLOCATED
39800		SUB	D,E	;D_-LNTH OF BLOCK TO BE RETURNED
39900				;(COUNTING SAIL HEADER AND TRAILER)
40000		MOVEM	D,4(C)	;SAIL HEADER FOR BLOCK TO BE RETURNED
40100		POP	P,E	
40200		ADDI	E,(B)	;E==>LAST WORD OF SAIL BLOCK
40300		MOVSI	D,400000	;FIXUP SAIL TRAILER WORD
40400					;FOR BLOCK TO BE RETURNED
40500		HRRI	D,3(C)
40600		MOVEM	D,(E)
40700		MOVEI	B,6(C)	;B==> "OMNI" BLOCK TO BE RETURNED
40800		JRST RELCOR(S)
40900	
41000	PUTFOR:	HLR	E,-2(B)		;E_LNTH ALLOCATED BY FORTRAN(POSITIVE)
41100	        SUBI	E,1		;SUBTRACT OUT 1 EXTRA WORD FOR FORTRAN OVERHEAD
41200	        MOVEI	D,-1(B)		;COMPUTE LNTH ACTUALLY USED (NEG)
41300	        SUBI	D,2(C)		
41400	        SUBI	B,1		;B==>1ST REAL WORD OF BLOCK
41500	        HRLZM	D,(B)		;SAVE LNTH IN FIRST WORD OF BLOCK
41600	        HRLM	D,1(C)		;AND IN NEW LAST WORD
41700	        HRRM	B,1(C)		;SAVE PTR TO FIRST WORD
41800	        MOVNS	D		;D_LNTH ACTUALLY USED
41900	        AOS	D		;INCLUDING FORTRAN OVERHEAD WORD
42000	        HRLM	D,-1(B)		;FIXUP FORTRAN SIZE WORD
42100	        SOS	D		;D_LNTH USED
42200	        SUB	E,D		;E_LNTH OF BLOCK TO BE RETURNED
42300	        HRLM	E,2(C)		;FORTRAN HEADER FOR BLOCK TO BE RETURNED
42400	        MOVEI	B,4(C)		;B==>"OMNI" BLOCK TO BE RETURNED
42500	        JRST	RELCOR(S)
42600	
42700	
42800	;HERE IF HISEG DISPLAY FILE AND OMNI IS HANDLING CORE ALLOCATION
42900	
43000	
43100	PUTHI:	MOVEI	D,2(C)		;COMPUTE LENGTH
43200		SUBI	D,-1(B)		;D HAS LENGTH ACTUALLY USED.
43300		HLRE	E,-1(B)		;LENGTH ALLOCATED
43400		MOVNS	E
43500		CAIGE	E,TRIVIAL(D)	;USED+TRIVIAL < ALLOCATED?
43600		 POPJ	 P,		;NO -- DO NOT PUT ON FS LIST
43700		SUBI	E,(D)		;DIFFERENCE
43800		MOVSS	E
43900		PUSH	P,E
44000		MOVN	E,D		;NEW LENGTH
44100		SUBI	B,1		;B ==> FIRST REAL WORD.
44200		HRLZM	E,(B)		;SAVE IT HERE
44300		HRLM	E,1(C)		;AND HERE
44400		HRRM	B,1(C)		;POINTER TO FIRST OF USED BLOCK
44500		MOVEI	B,2(C)		;POINTER TO BLOCK FOR FS
44600		POP	P,C		;THIS IS THE LENGTH
44700		JRST	CORR0(S)	;JOIN RELCOR CODE TO MERGE
44800	
44900	
45000	;THE FOLLOWING LOCATIONS ARE NEEDED BY THE QINI ROUTINES (IF HISEG)
45100	;WHICH FUDGE THE HIGH SEGMENT TO LOOK LIKE A SHARABLE HISEG
45200	
45300	IFDEF DEC340,<
45400	SAV40:	0		;FOR SAVING LOC 40 WHICH IS USED TO SAVE AC S
45500	;THE SNAM BLOCK IS USED FOR THE ENTER OF THE FILE
45600	;THE FILENAME IS CREATED BASED ON THE JOB #
45700	SNAM:	SIXBIT	/DIS000/
45800		SIXBIT	/SHR/
45900		0
46000		0
46100	
46200	
46300	;THE SBLK BLOCK IS USED FOR THE OPEN
46400	
46500	SBLK:	17
46600		SIXBIT	/DSK/
46700		0
46800	
46900	BUFF:	BLOCK	10
47000	OUTIOW:	IOWD	10,BUFF		;CCL FOR DUMP MODE OUTPUT
47100		0
47200	
47300	;ARG BLOCK FOR GETSEG
47400	GETNAM:	SIXBIT	/DSK/
47500		0		;NAME FILLED IN BY CSIX ROUTINE BASED ON JOB #
47600		SIXBIT	/SHR/
47700		0
47800		0
47900		0
48000	
48100	
48200	;SETUP BLOCK FOR DELETING DISXXX.SHR FILE FROM USER AREA 
48300	;AFTER GETSEG
48400	
48500	DNAM:	BLOCK	4
48600	
48700	>	;END OF DEC340 KLUDGE
48800	
     
00100	
00200	;INITIALIZATION ROUTINE (PHASE 2)
00300	;  SET UP INITIAL STORAGE AREA
00400	
00500	QINI:
00600		POP	P,A		;GET SEG FLAG
00700		SETZM	.SEG(S)		;ASSUME LOSEG
00800		CAIN	A,1		;DID HE REQUEST LOSEG?
00900		SETOM	.SEG(S)		;NO
01000		SUB	P,[XWD 3,3](S)	;GET ALL PARMS OFF STACK
01100	
01200		SKIPE	.SEG(S)		;HISEG DISPLAY FILE?
01300		JRST	QINIH(S)	;YES
01400	
01450	IFNDEF EXPORT,<
01500	
01600	;340 MAY HAVE BEEN INIT'ED PREVIOUSLY BY THIS JOB
01700	;THIS CODE TAKES ADVANTAGE OF THE FACT THAT THE MONITOR WILL
01800	;NOT FREE THE DEVICES UNLESS IT IS THE CURRENT JOB WHICH HAS
01900	;THEM ASSIGNED
02000	
02100		MOVSI	B,5		;FREE ALL DISPLAY DEVICES IF
02200		DISCAL	B		;ASSIGNED TO THIS JOB
02250	>
02300	
02400		MOVEI	C,=500		;GET ENOUGH CORE FOR DATA AREA
02500		PUSHJ	P,GETIT(S)
02600		POPJ	P,0		;NO CORE - JUST RETURN
02700		MOVE	R,B		;SETUP R TO POINT TO BASE OF
02800					;DISPLAY FILE
02900		MOVEM	R,.DBASE(S)	;SAVE POINTER
03000		MOVE	0,0		;RESET FLAG REGISTER
03100		JRST	QINIP(S)	;GO ON TO PHASE 3
03200	
03300	;HERE IF HISEG DISPLAY FILE
03400	
03500	
03600	
03700	QINIH:	MOVEI	R,RB		;SECOND SEGMENT BASE ADDRESS
03800		SKIPN	.JBHRL		;DO WE HAVE ANY SECOND SEGMENT CORE?	
03900		 JRST	 QINI2(S)	;NO -- GET SOME AND INITIALIZE
04000					;YES -- SEE IF IT IS BECAUSE OF DISPLAY
04100		MOVEM	R,.DBASE(S)	;IN CASE OVERLAYING -- THIS IS ALL WE NEED.
04200		MOVEI	A,0
04300		CALLI	A,36		;MAKE IT WRITEABLE IN ANY CASE
04400		 JRST	 QINI3(S)	;DESTROY IT
04500		MOVE	A,RB-1		;PICK UP TEST WORD.
04600		CAMN	A,[XWD -1,DISNUM](S)	;FOR THIS DISPLAY?
04700		 JRST	 @.TRET(S)	;YES -- EXIT RIGHT NOW....
04800					;THIS FAST EXIT IS FOR BENEFIT OF OVERLAYS.
04900					;NOTHING HAS BEEN DISTURBED -- THE
05000					;FLAG REGISTER IS OK, AND R IS SET UP.
05100	QINI3:	MOVSI	A,377777	;GET ZERO HIGH-SEGMENT CORE
05200		CALLI	A,11		;FROM SYSTEM
05300		 JFCL
05400					;THIS REQUEST TO 'DESTROY' THE SECOND SEGMENT
05500					;HAS THE ADDED BENEFIT THAT IF THE PREVIOUS
05600					;DISPLAY WAS THE 340 WHICH HAD THE SECOND SEGMENT
05700					;LOCKED, THE 340 IS RELEASED BY THIS PROCESS.
05800					;THIS HAPPENS BECAUSE A REQUEST TO COMPLETELY
05900					;DESTROY THE SECOND SEGMENT CALLS
06000					;THE SUBROUTINE 'KILHGH' IN THE MONITOR,
06100					;WHICH ACTUALLY RELEASES THE 340.
06200	QINI2:	MOVSI	0,USECOR	;FLAG THAT WE ARE USING SECOND SEGMENT
06300	
06400	IFDEF DEC340,<
06500	;IF DEC340 MUST MAKE HISEG SHARABLE TO ALLOW LOCKING UNDER 6.01
06600	
06700		MOVEI	A,.ACSAV(S)	;SAVE AC'S
06800		BLT	A,.ACSAV+17(S)
06900	
07000	;FIRST WRITE OUT A SHARABLE FILE IN THE USER'S AREA
07100	;CALL ROUTINE TO FORM UNIQUE NAME FOR THE SHARABLE FILE
07200	;IN CASE 2 JOBS ARE RUNNING UNDER THE SAME PPN
07300	
07400		MOVNI	C,6		;SET UP COUNTER FOR RECURSIVE ROUTINE
07500		CALLI	A,30		;GET JOB #
07600		PUSHJ	P,CSIX(S)	;CALL RECURSIVE ROUTINE TO FORM
07700					;FILENAME FROM JOB #
07800	;OPEN CHANNEL AND ENTER FILE
07900		OPEN	SBLK(S)
08000		JRST	NOFIL(S)	;ERROR
08100		SETZM	SNAM+2(S)
08200		SETZM	SNAM+3(S)
08300		ENTER	SNAM(S)
08400		JRST	NOFIL(S)	;ERROR
08500	;SETUP VESTIGIAL JOB DATA AREA TO BE WRITTEN INTO HISEG FILE
08600		MOVE	A,120	
08700		MOVEM	A,BUFF(S)
08800		MOVE	A,41
08900		MOVEM	A,BUFF+1(S)
09000		MOVE	A,133
09100		MOVEM	A,BUFF+2(S)
09200		HRR	A,124
09300		HLL	A,115
09400		MOVEM	A,BUFF+3(S)
09500		MOVE	A,137
09600		MOVEM	A,BUFF+4(S)
09700		MOVE	A,SNAM(S)
09800		MOVEM	A,BUFF+5(S)
09900		SETZM	BUFF+6(S)
10000		SETZM	BUFF+7(S)
10100	;SETUP CCL FOR DUMP MODE OUTPUT
10200		MOVE	A,OUTIOW(S)	;MUST ADD IN RELOCATION
10300		ADDI	A,(S)
10400		MOVEM	A,OUTIOW(S)
10500		OUTPUT	OUTIOW(S)
10600		STATZ	740000
10700		JRST	NOFIL(S)	;ERROR ON OUTPUT
10800		RELEASE			;RELEASE DISPLAY
10900	
11000		MOVE	A,40		;SAVE CONTENTS OF LOC 40
11100		MOVEM	A,SAV40(S)
11200	
11300		MOVEM	S,40		;SAVE AC S IN LOC 40
11400		MOVE	A,SNAM(S)	;SETUP GETSEG ARG BLOCK WITH CORRECT FILE NAME
11500		MOVEM	A,GETNAM+1(S)
11600		MOVEI	A,GETNAM(S)
11700		CALLI	A,40		;GETSEG A DUMMY SHARABLE HISEG
11800		HALT			;ERROR
11900		MOVE	S,40		;RESTORE S
12000		MOVE	A,SAV40(S)	;RESTORE LOC 40
12100		MOVEM	A,40
12200		MOVSI	A,.ACSAV(S)	;RESTORE AC'S
12300		BLT	A,17
12400	;DELETE DISXXX.SHR FILE FROM USER'S AREA
12500		OPEN	SBLK(S)
12600		JRST	NOFIL(S)	;ERROR
12700		SETZM	SNAM+2(S)
12800		SETZM	SNAM+3(S)
12900		LOOKUP	SNAM(S)
13000		JRST	NOFIL(S)	;ERROR
13100		SETZM	DNAM(S)		;CLEAR 4 WORD BLOCK FOR RENAME
13200		SETZM	DNAM+1(S)
13300		SETZM	DNAM+2(S)
13400		SETZM	DNAM+3(S)
13500		RENAME	DNAM(S)
13600		JRST	NOFIL(S)	;ERROR
13700	;RELEASE CHANNEL
13800		RELEASE
13900	
14000	>	;END OF DEC340 DEPENDENT CODE
14100	
14200		MOVSI	A,377777+(=1024*2) ;GET 2 K TO START
14300		CALLI	A,11
14400		 JRST	 NCOR(S)	;SAY NO CORE AND RETURN
14500		MOVEI	A,0
14600		CALLI	A,36		;GET WRITE PRIVILEGES
14700		 JRST	 NCOR(S)
14800		
14900		HRROI	A,DISNUM	;DISPLAY DISNUM
15000		MOVEM	A,RB-1		;AND SAVE IT.
15100		MOVEI	C,377777+(=1024*2)+1 ;LAST LOCATION.
15200	QINI5:	MOVEM	R,.DBASE(S)	;SAVE POINTER FOR CALLER
15300		MOVEM	C,CORHI(R)	;SAVE TOP+1
15400		MOVEI	B,XRI(R)	;GET FIRST FREE LOCATION.
15500		MOVEM	B,CORLO(R)	;SAVE BOTTOM OF CORE.
15600		SUBI	C,(B)		;LENGTH
15700		JUMPL	C,@.FRET(S)	;IF TOP < BOTTOM, FAIL -- USER ARAY NOT BIG ENUF
15800		MOVSS	C
15900		PUSHJ	P,RELINK(S)	;PUT IT ON FREE STORAGE LIST.
16000	
16100	
16200	
16300	;INITIALIZATION (PHASE 3)
16400	;  SET UP ALL DEFAULTS, ETC.
16500	
16600	
16700	QINIP:
16800	IFDEF DEC340,<
16900	
17000		SETOM	MASK4(R)		;THIS IN ORDER TO MAKE LIGHTS STAY ON
17100		MOVEI	A,5
17200		MOVEM	A,DELTA(R)		;SET UP GRAPHACON DELTA
17300		MOVEI	A,TRCLOC(R)	;TRACKING LOCATION
17400		CLRBIT	(A)		;CLEAR 400000 BIT IF HISEG
17500		MOVEM	A,TRACLOC(R)	;AND SAVE IT.
17600	
17700		MOVEI	A,DISNOP(R)
17800		HRLI	A,DJPI!PRM
17900		MOVEM	A,DISNP1(R)	;INITIALIZE THIS.
18000	
18100		PUSHJ	P,MAKD(S)	;MAKE A DISPATCH TABLE.
18200	
18300		MOVEI	A,1
18400		MOVEM	A,SCALE(R)		;INITIALIZE SCALE
18500		MOVEI	A,117
18600		MOVEM	A,PARMSAV(R)	;SCALE 1, INTENSITY 7
18700	>
18800	
18900	;SET UP AS IF
19000	;	DWIND (-1,1,-1,1)
19100	;	DPORT (0,1,0,1)
19200	;HAD BEEN EXECUTED
19300		MOVE	A,[XWD -=8,.YPM](S)
19400		ADDI	A,(R)
19500		MOVE	B,[SMIDH](S)	;INITIALIZE MULTIPLIERS TO 1/2 SMID
19600		MOVEM	B,(A)		;STORE
19700		AOBJN	A,.-1(S)
19800		MOVSI	B,(<1.0>)	;AND INITIALIZE WINDOW, VIEWPORT EDGES
19900		HRLI	A,-4
20000		MOVEM	B,(A)
20100		MOVNM	B,1(A)
20200		ADDI	A,1
20300		AOBJN	A,.-3(S)
20400		SETZM	.YVB(R)		;LOWER BOUNDS ARE ZERO.
20500		SETZM	.XVL(R)		; "
20600	
20700	;INITIALIZE AS IF
20800	;	DCURSOR (0,.95)
20900	;HAD BEEN EXECUTED
21000	
21100		MOVSI	A,200746	;.94921875
21200		MOVEI	B,0		;ARGUMENTS
21300		PUSHJ	P,CURSET(S)	;TO SET CURSOR
21400	;	GO INITIALIZE PICTAB IF GT40, ELSE JUST RETURN BACK
21500	
21600		PUSHJ	P,IPICTA(S)	;SEE DIS340,DISDVS,DISGT4,...
21700	
21800		JRST	@.TRET(S)	;RETURN TRUE -- ALL DONE
21900	
22000	
22100	NCOR:	TTCALL	3,[ASCIZ /NO CORE FOR DISPLAY
22200	/](S)
22300		TLO	NOCORE!NOMOCOD
22400		JRST	@.FRET(S)	;RETURN.
22500	
22600	
22700	IFDEF DEC340,<
22800	NOFIL:	TTCALL	3,[ASCIZ /ERROR IN HIGH SEGMENT FILE
22900	/](S)
23000		CALLI	12		;EXIT
23100	
23200	;THE FOLLOWING ROUTINE IS USED BY THE CODE AT QINI2 WHICH
23300	;CREATES A DUMMY SHARABLE FILE TO MAKE OMNI WORK WITH 6.01
23400	;IT CREATES A UNIQUE FILENAME BASED ON THE JOB #
23500	;AC A CONTAINS THE JOB #
23600	
23700	CSIX:	ADDI	C,6		;INCREMENT COUNTER FOR SHIFTING
23800		IDIVI	A,=10		;PICK OFF THE DIGITS OF THE JOB #
23900		PUSH	P,B		;REMAINDER IS IN AC B
24000		SKIPE	A		;WHEN A IS 0 THE LEFTMOST DIGIT HAS BEEN PROCESSED
24100		PUSHJ	P,CSIX(S)	;CALLS ITSELF RECURSIVELY UNTIL ALL DIGITS PROCESSED
24200		POP	P,A		;GET FIRST DIGIT
24300		LSH	A,(C)		;POSITION PROPERLY IN REG
24400		IORM	A,SNAM(S)	;OR INTO WORD
24500		SUBI	C,6		;UPDATE SHIFT COUNT
24600		POPJ	P,
24700	
24800	>	;END OF DEC340 DEPENDENT CODE
24900	
     
00100	
00200	
00300	;THE NEXT FEW LINES ARE 'XLIST'ED SO THAT LESS LISTING IS
00400	;PRODUCED.  HOWEVER, THEY READ AS FOLLOWS:
00500	;	XLIST
00600	;	LIT
00700	;	VAR
00800	XLIST
00900		LIT
01000		VAR
01100	LIST
01200	DEPHASE
