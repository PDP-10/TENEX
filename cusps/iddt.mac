;<SOURCES>IDDT.MAC;31     1-APR-74 16:06:45	EDIT BY PLUMMER
; FIX THE ^T "RUNNING AT ?" BUG
;<SOURCES>IDDT.MAC;30    21-MAR-74 12:36:28	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;29    20-MAR-74 13:12:54	EDIT BY PLUMMER
; ADD "LOCKED BY USER" TYPEOUT TO ;A
;<SOURCES>IDDT.MAC;28    20-MAR-74 12:37:50	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;27    19-MAR-74 00:19:33	EDIT BY PLUMMER
; FIX ;S (MISSING INSTR DUE TO NEW ;? CODE)
; TEXT INPUT INTERRUPTIBLE
; DONT FLUSH BPT'S AFTER ^C REENTER OUT OF USER PROG.
; JSYS DEFS FOR JSYS TRAP INSTRS
; ADD ^T ROUTINE
;<SOURCES>IDDT.MAC;22    12-MAR-74 00:30:11	EDIT BY PLUMMER
; $$Z FIXED (AGAIN)
; $P AFTER HALTF, HFORK CONTINUES PROGRAM (AGAIN)
;<SOURCES>IDDT.MAC;21    11-MAR-74 23:59:16	EDIT BY PLUMMER
 ;?  COMMAND
; FIX ;M
; ADD VERSION NUMBER STUFF
;<SOURCES>IDDT.MAC;17    23-AUG-73 10:58:55	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;16    23-AUG-73 01:23:56	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;15    23-AUG-73 00:34:42	EDIT BY PLUMMER
; $X ETC, PUSHES THE BREAK INSTRUCTION
; PDL OVF DURING PUSHJ INTERPRET DOES IIC ON USER'S POV CHN
; FLUSH SFORKS
; FLUSH SYMP POINTER TO LOCATION CONTAINING SYMPTR
; POLISH FLOATING FRACTION GATHERING
;<SOURCES>IDDT.MAC;13    14-AUG-73 12:03:15	EDIT BY PLUMMER
; RUBOUT DOES CIS
; CIS'S RATHER THAN DEBRK TO .+1
; FORK TERMINATION NO LONGER AN INTERRUPT
; FIX FLOATING INPUT BUG IN "POWER"
;<SOURCES>IDDT.MAC;12     3-JUN-73 20:39:35	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;11     1-JUN-73 00:04:40	EDIT BY PLUMMER
; FIX FLSSYM -- HRL'S SHOULD HAVE BEEN HRLI'S
;<SOURCES>IDDT.MAC;10    17-APR-73 10:46:42	EDIT BY PLUMMER
; GET SYMS IF NONE BEFORE AT INIT3
; JOBSYM INITIALLY 0 IN LEFT HALF NOW
;<SOURCES>IDDT.MAC;9    13-APR-73 11:11:08	EDIT BY PLUMMER
; REPAIR ESCAPE CHR DETECTION IN GETC
; ADD CIS AT INTERRUPT OUT OF USER
;<SOURCES>IDDT.MAC;8    11-APR-73 15:35:39	EDIT BY PLUMMER
; FIX $$B
; FIX AUTO PROCEED SO THAT IT SEES INTERRUPTS
;<SOURCES>IDDT.MAC;7    10-APR-73 22:30:19	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;6    10-APR-73 13:38:34	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;5     4-APR-73 01:09:59	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;4     4-APR-73 00:23:33	EDIT BY PLUMMER
;<SOURCES>IDDT.MAC;3     4-APR-73 00:10:12	EDIT BY PLUMMER
; CLEANUP START/REENTER/SPLICD ENTRIES
;<SOURCES>IDDT.MAC;2     3-APR-73 23:53:32	EDIT BY PLUMMER
; ^A FEATURE FOR ATOMS
; REPAIR SEARCHS
; REPAIR BPT INSERT/REMOVE
; FLUSH TEST AND COMPARE MACROS, FIX EA CALC ON $P
; DO ATI IN ;E ROUTINE
; ALLOW ;E TO TYPE IN ESCAPE CHR
; REMOVE EXTRA INSTRUCTIONS AT TBRK
; USE SIN FOR ;O
; USE SOUT FOR ;W
; FIX ;O AND ;W TYPEOUTS
;<2SOURCES>IDDT.MAC;290     8-MAR-73 10:29:42	EDIT BY PLUMMER
;<2SOURCES>IDDT.MAC;289     7-MAR-73 23:06:11	EDIT BY PLUMMER
; REARRANGE CALLS TO TEXT TYPERS IN FILE COMMANDS
; MORE PATCH MODE STUFF
;<2SOURCES>IDDT.MAC;288     7-MAR-73 21:31:08	EDIT BY PLUMMER
; RUBDVOUT'S TYPED IN WHILE IN IDDT BEHAVE LIKE THE ESCAPE CHR
;<2SOURCES>IDDT.MAC;287     7-MAR-73 15:23:34	EDIT BY PLUMMER
;<2SOURCES>IDDT.MAC;285     5-MAR-73 22:49:06	EDIT BY PLUMMER
; PATCH MODE STUFF STARTED
;<2SOURCES>IDDT.MAC;279     1-MAR-73 13:40:55	EDIT BY PLUMMER
; "GETJFN" ROUTINE THAT ALLOWS ESCAPE CHAR TO BE TYPED IN
; ALLOW ^C ETC FOR ESCAPE CHR
; REMOVED OLD FLAG "SBF" -- NOT USED
;<2SOURCES>IDDT.MAC;277    28-FEB-73 17:41:08	EDIT BY PLUMMER
; SWITCH BACK TO ONLY ONE INTERRUPT CHR (MOBY CHANGE)
;<2SOURCES>IDDT.MAC;274    27-FEB-73 22:32:11	EDIT BY PLUMMER
; FLUSH UNCOMMON DEF A AC'S B AND C
;<2SOURCES>IDDT.MAC;273    23-FEB-73 17:15:55	EDIT BY PLUMMER
; RE-DID THE CFIBF/CFOBF AT INTERRUPT SITUATION
;<2SOURCES>IDDT.MAC;272    21-FEB-73 17:16:46	EDIT BY PLUMMER
; ;R CLEARS SEMI FLAGS, FORKSTAT CALLS TYPE, MOVE PATCH SPACE
; CHANGE RELOC'S, SAY "IDDT" UPON HALTF ETC FROM USER
; RUBOUT FROM USER AND ERRORS CLEAR TYPE-AHEAD
;<2SOURCES>IDDT.MAC;271    20-FEB-73 22:19:47	EDIT BY PLUMMER
; "." HANDLED PROPERLY WHEN INSIDE IDDT
; /, [, ], !, AND \ DON'T SAVE OLD SEQUENCE
; $X MOVED TO LOCATION 20
;<2SOURCES>IDDT.MAC;267    19-FEB-73 14:36:58	EDIT BY PLUMMER
; GET SYMS AFTER ANY KIND A ENTRY
; READY FOR BPT'S TO REPORT AS STATUS 6
; BACK TO OLD "SETUP" FOR $$Z
; FLUSH "ZLOW" PARAMETER
; SWITCH TO CALL AND RET
;<2SOURCES>IDDT.MAC;266     6-FEB-73 00:00:19	EDIT BY PLUMMER
; FIX $$Z
;<2SOURCES>IDDT.MAC;265     1-FEB-73 23:38:39	EDIT BY PLUMMER
; ADDED SEMICOLON SPACE COMMAND -- LIKE OLD ;
;<2SOURCES>IDDT.MAC;264    17-JAN-73 18:09:46	EDIT BY PLUMMER
; CHANGE DEPOSIT TO REMEMBER RIGHT ACCESS
; ADRSPC UNMAPS USER PAGE
;<2SOURCES>IDDT.MAC;263    14-JAN-73 21:55:27	EDIT BY PLUMMER
; HALTF, HFORK ARE PROCEDABLE
; CHANGE COC WORDS
; FIXED SWITCHING BETWEEN USER AND IDDT
; IDDT CHANGES ACCESS OF USER'S PAGE SO BPT'S ETC. NEVER FAIL
;  TO GO IN OR COME OUT
;<2SOURCES>IDDT.MAC;259    14-JAN-73 17:37:35	EDIT BY PLUMMER
;<2SOURCES>IDDT.MAC;257    14-JAN-73 16:26:55	EDIT BY PLUMMER
; ADDR;S  COMMAND
; PROVISIONS MADE FOR "SPLICED" ENTRY FROM EXEC
;<2SOURCES>IDDT.MAC;251     9-JAN-73 14:41:50	EDIT BY PLUMMER
; UPDATE JSYS TABLE TO STENEX.MAC;42
;<2SOURCES>IDDT.MAC;250     9-JAN-73 12:44:51	EDIT BY PLUMMER
; SEMICOLON DISPATCH INSTALLED
; XCT CHASER FIXED
;<2SOURCES>IDDT.MAC;249    27-DEC-72 16:05:13	EDIT BY PLUMMER
; FIXED  /  WITHOUT ARG
;<2SOURCES>IDDT.MAC;248     4-DEC-72 11:52:05	EDIT BY PLUMMER
; FILE LOGIC DEFAULTING CLEANED UP
;<2SOURCES>IDDT.MAC;245    19-OCT-72 11:00:27	EDIT BY PLUMMER
;<PLUMMER>IDDT.MAC;17    26-SEP-72 11:10:06	EDIT BY PLUMMER
; W, E, N SEARCHES TAKE COUNT    105$3W stopes on the 3rd find
; $$nZ fills core with n (assumed 0 if not given)
;<PLUMMER>IDDT.MAC;13    13-SEP-72 13:39:40	EDIT BY PLUMMER
; OPCODE TABLE EXPLAINATION CLEANED UP
; OLD TABLE DISCARDED
;<PLUMMER>IDDT.MAC;12    13-SEP-72 11:58:43	EDIT BY PLUMMER
; JSYS TABLE UPDATED
; ^S COMMAND TO STORE SYMBOLS
; NEW $$Y TO READ NEW STYLE SYMBOL FILES
; DEFAULT EXTENTIONS FOR FILE COMMANDS
;<PLUMMER>IDDT.MAC;8    12-SEP-72 17:47:54	EDIT BY PLUMMER
; SYMBOL FILE COMMAND
;<PLUMMER>IDDT.MAC;3    11-SEP-72 23:26:13	EDIT BY PLUMMER
; ENTRY VECTOR STUFF CLEANED UP (USES 0-LENGTH FEATURE)
; HALT, HALTF ARE SILENT RETURNS TO IDDT
;<PLUMMER>IDDT.MAC;2    11-SEP-72 22:19:55	EDIT BY PLUMMER
; SAVE/RESTORE USER'S TTY  TAB SETTINGS
; SAVE BREAKS-IN-PROGRESS WORD IN $I+3
; LEFT AND RIGHT HALF SYMBOL FIXUPS
; AUTOMATIC  $: AT STARTUP
; ALLOW TAGS WITH OPCODE NAMES
; ? COMMAND IMPROVED
;<2SOURCES>IDDT.MAC;243    25-AUG-72 17:52:06	EDIT BY PLUMMER
; SMACRO ASSEMBLY
; MOVED FROM 667000 TO 740000
;<2SOURCES>IDDT.MAC;242    26-JUL-72 19:51:00	EDIT BY PLUMMER
; FIX JSYS EVAL

	TITLE 	IDDT
	SUBTTL	W.W.PLUMMER, NOVEMBER 71
	SEARCH	STENEX

	HOME==740000		;WHERE IDDT LIVES

BLAST:	MOVEI 4,770-<HOME/1000>
	MOVE 2,[400000,,<HOME/1000>-1]
	SETOM 1
	AOS 2
	PMAP
	SOJN 4,.-2
	MOVE 0,[LOW,,HOME]
	BLT 0,DDTEND-1
	HRLZ 0,116
	HRRI 0,DDTEND
	HLRE 1,116
	MOVEI 2,DDTEND-1
	SUB 2,1
	BLT 0,0(2)

	MOVEI 0,DDTEND
	HLL 0,116
	MOVEM 0,116
	MOVEM 0,@770001

	HRLZI 1,400000
	HRROI 2,[ASCIZ /IDDT.SAV/]
	GTJFN
	 0
	MOVEM 1,JFN

	MOVEI 1,400000
	MOVE 2,[3,,EVEC]
	SEVEC

	MOVE 0,[PROTO,,1]
	BLT 0,16
	JRST 4


PROTO:	-1			;1
	400000-1,,-1		;2
	0			;3
	AOS 2			;4
	PMAP			;5
	CAME 2,16		;6
	JRST 4			;7
	HRR 1,JFN		;10
	HRLI 1,400000		;11
	MOVE 2,15		;12
	SSAVE			;13
	JRST 770000		;14
	-1000,,560000		;15
	400000,,<HOME/1000>-1	;16

	LIT

;DEFINE ACCUMULATORS

F=0		;FLAGS
R=<A==2>	;POINTERS TO TABLES, CORE, ETC.
S=3		;USED IN EVAL, FP1, FP4
W=4		;CONTAINS DISPATCH ADDRESS, USED IN FP1A, FP4
T=5		;TRANSFER DATA
W1=T+1
W2=7
SCH=10		;MODE CONTROL SWITCH FOR OUTPUT - CONTENT TYPER
AR=SCH+1	;MODE CONTROL SWITCH FOR OUTPUT - ADDRESS TYPER
ODF=AR+1	;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT=13		;TEMPORARY
TT1=TT+1	;TEMPORARY
TT2=15		;TEMPORARY
TT3=16		;TEMPORATY
P=17		;PUSH DOWN


;DEFINE BITS FOR USE IN LEFT HALF OF ACCUMULATOR F
COMF==200000	;COMMA TYPED FLAG
TIF==100000	;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
PTF==100	; +, -, OR * HAS BEEN TYPED
CTF==400
SF==4		;SYLLABLE FLAG
QF==1		;QUANTITY TYPED IN TO WORD ASSEMBLER

CF==40		; $  TYPED
CCF==10000	; $$  TYPED
MF==2		;MINUS SIGN TYPED IN
LTF==20		;LETTER TYPED IN TO CURRENT SYLLABLE
ROF==10		;REGISTER OPEN FLAG
STF==4000
FAF==1000	; < TYPED
SAF==2000	; > TYPED

FPF==20000	; . TYPED IN
FEF==400000	; E FLAG

MLF==200	;*FLAG
DVF==40000	;DIVIDE FLAG

;DEFINE BITS FOR USE IN RIGHT HALF OF ACCUMULATOR F

ITF==2		;INSTRUCTION TYPED IF ITF=1
OUTF==4		;OUTPUT IF OUTF=1
CF1==400	;OUTPUT 1 REGISTER AS CONSTANT
LF1==2000	;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
Q2F==1		;NUMBER TYPED AFTER ALT MODE 
NAF==200	;NEGATIVE ADDRESSES PERMISSABLE
POWF==4000	;ARGUMENT FOR EXPONENT COMING
XEQ==40		;WE'RE IN A $X
CONDX==1000	;WE'RE EXECUTING THE CONDITIONAL BREAK INSTR.
TEMF==10000	;TEMPORARY FLAG
TEM2F==10	;ANOTHER TEMPORARY, USED ONLY IN ;O STUFF
INTFLG==20000	;EXPR CONTAINS DDT INTERNAL REGISTER
SEMIF==100	;SEMICOLON TYPED
SEMIF2==100000	;TWO SEMICOLI TYPED
PBF==200000	;PATCH BEFORE MODE
PAF==400000	;PATCH AFTER MODE

;RANDOM THINGS
STRBFL==10	;STRING (ATOM) BUFFER LENGTH

;DEFINE PUSH DOWN LENGTH
LPDL==50	;MAX LENGTH PUSH DOWN LIST
PCSL==100	;OLD PC STACK LENGTH


;DEFINE SYMBOL TABLE SYMBOL TYPES
GLOBAL==040000	;GLOBAL SYMBOL
LOCAL==100000
PNAME==740000	;PROGRAM NAME
DELI==200000	;DELETE INPUT
DELO==400000	;DELETE OUTPUT

;DEFINE UDEFINED SYMBOL TABLE TYPES
STADD==1B0	;IF 1, THEN ADDITIVE REQUEST
STLH==1B1	;IF 1, THEN REQUEST FOR LEFT HALF
STNEG==1B4	;IF 1, THEN NEGATIVE REQUEST

;FLAG SAYING ADDRESS IS IN IDDT'S ADDRESS SPACE
;MUST BE DIFFERENT THAN UNDEFINED SYMTAB TYPE BITS
DDTINT==1B5

NBP==10		;NUMBER OF BREAKPOINTS
OPDEF TYO [PBOUT]
OPDEF TYI [PBIN]
OPDEF CALL [PUSHJ P,]
OPDEF RET [POPJ P,]

DEFINE INTOFF <
	MOVEI 1,400000
	MOVSI 2,(1B0)
	DIC>

DEFINE	INTON <
	MOVEI 1,400000
	MOVSI 2,(1B0)		;THE RUBOUT CHANNEL
	AIC>

LOW:	PHASE HOME
IDDT:

;ENTRY VECTOR
EVEC:	JRST INIT		;"START"
	JRST INIT		;"REENETER"
	JRST SPLICD		;INFERIOR HAS BEEN SPLICED BY EXEC
VERSN:	0
	^D105
PATVER:	0


;FORK HANDLE SUPPLIED IN AC1 FROM EXEC
SPLICD:	MOVEM 1,FORK		;SAY WE HAVE AN INFERIOR


INIT:	INTOFF			;PREVENT SURPRISES DURING INIT
	MOVE P,PCSTAK
	MOVEM P,PCSPTR		;RESET STACK OF PC'S
	MOVE P,PS		;MAIN STACK
INIT0:	SKIPLE FORK		;DOES USER ALREADY EXIST?
	JRST INIT3		;YES
INIT04:	MOVEI 1,100
	SIBE			;ANY TYPE AHEAD?
	 JRST INIT09		;YES
INIT05:	MOVEI 1,101
	HRROI 2,[ASCIZ / IDDT /]
	SETZ 3,
	SOUT
	MOVE 2,VERSN+1
	IDIVI 2,^D100
	PUSH P,3
	MOVEI 3,^D10
	NOUT
	 JFCL
	MOVEI 2,"."
	BOUT
	POP P,2
	MOVE 3,[140002,,^D10]
	NOUT
	 JFCL
	SKIPN PATVER
	 JRST INIT08
	MOVEI 2,"."
	BOUT
	MOVE 2,PATVER
	MOVEI 3,^D10
	NOUT
	 JFCL
INIT08:	CALL CRF
INIT09:	CALL NEWFRK		;GET A NEW FORK

;COPY TO INFERIOR FORK
INIT2:	MOVEI 1,400000
	GEVEC
	CAMN 2,[3,,EVEC]
	SETZM 2
	SEVEC
	HRLZI 1,410001
	HRROI 2,[ASCIZ /CORE-SWAP.IDDT/]
	GTJFN
	 0
	HRLI 1,400000
	MOVE 2,[-<HOME/1000>,,560000]
	SETZM 3
	SSAVE
	HRLZI 1,1
	HRROI 2,[ASCIZ /CORE-SWAP.IDDT/]
	CALL GETFIL		;GET INTO INFERIOR FORK
	MOVEI 1,400000
	MOVE 2,[3,,EVEC]
	SEVEC			;SET IT BACK AGAIN
	MOVSI 1,100001
	HRROI 2,[ASCIZ /CORE-SWAP.IDDT/]
	GTJFN
	 JRST INIT3
	DELF
	 JFCL

INIT3:	MOVNI 1,5
	RUNTM
	MOVEM 1,TIMUSD
	MOVEM 3,TIMCON
	MOVE 1,FORK
	FFORK			;FREEZE THE USER
	RFSTS			;GET HIS STATUS
	MOVEM 2,REALPC
	MOVEM 2,PC		;HIS PC
	AOSE USRFLG		;WERE WE IN THE USER BEFORE ^C, REE??
	 JRST INIT4		;NO, IDDT HAS USER INFO ALREADY
	CALL USTATE		;GET COMPLETE STATE OF USER FORK
	SKIPL SYMPTR		;DO WE ALREADY HAVE SYMBOLS?
	CALL SYMVEC		;GET SYMBOLS, ENT. VEC.

;SETUP INTERRUPT SYSTEM ON INFERIOR FORK
INIT4:	MOVEI 1,400000
	MOVE 2,[LEVTAB,,CHNTAB]
	SIR			;SETUP
	CIS
	EIR
	MOVSI 2,(1B0!1B1)	;RUBOUT AND ^T CHANS
	AIC
	RPCAP
	SETOM 3			;TRY FOR EVERYTHING
	EPCAP
	JRST DDT


;ENTRIES FROM USER

;RUBOUT HIT, MAKE BELIEVE INSTR TRAP HAPPEND
RUBOUT:	AOSE USRFLG	;WE'RE WE IN USER?
	JRST RENWRG	;NO, REENTER IDDT AT WRONG
	MOVEI 1,100
	CFIBF		;FLUSH TYPE-AHEAD
	MOVEI 1,400000
	CIS		;CLEAR OTHER WAITING INTERRUPTS


;INSTR. TRAP. COULD BE BPT, PSEUDO-BPT, ILL INSTR, ETC.
TRAP:	MOVNI 1,4	;ALL IMMEDIATE INFERIORS
	FFORK
	INTOFF
	CIS
TRAPD:	SETZM BPTFLG	;ASSUME NOT FROM BPT
	CALL USTATE	;GET USER STATE
	MOVE 1,FORK
	RFSTS
	MOVEM 2,REALPC
	TLNN 2,(1B5)	;MONITOR MODE PC?
	SOS 2		;YES, BACK IT UP SO . WILL APPEAR OK
	MOVEM 2,PC	;AND HIS PC
	TLZ 1,400000	;INTERRUPT --> 0
	MOVEM 1,WHY
	HLRZ W,1	;W HAS TERMINATION REASON
	HRRZS 1		;1 HAS REASON WHY ILLEGAL IF W NOT = 2
	SETZM TRAPWD
	SETZM WDATA
	CAIE W,6	;NEW BPT CLASS
	CAIN W,2	;HALTF, HFORK, BPT
	JRST TRAP2
	CAIN W,3	;ILL INST., ILL MEM REF, ETC
	JRST TRAP3

;INTERRUPT, IO WAIT, FORK WAIT
TR014:	MOVEI 1,10	;HANDLE AS INTERRUPT, WHY=10 FOR  XXX:
	HRRM 1,WHY
	JRST NOTMT	;GO TYPE BREAK MESSAGE


;FORCED TERMINATION CLASS
TRAP3:	CAIL 1,20
	CAILE 1,22
	JRST NOTMT	;NOT A MEMORY TRAP

;MEMORY ACCESS VIOLATION
MEMTRP:	MOVE 1,FORK
	GTRPW
	MOVEM 1,TRAPWD
	MOVEM 2,WDATA
	TLNN 1,12	;READ AND EXECUTE TRAPS LEAVE GOOD PC
	SOS PC		;WRITE LEAVES IT STEPPED, AND BIT-5 ON(R/W/X)

NOTMT:	TRNN F,CONDX	;ARE BPT'S IN?
	CALL REMOVB	;YES, PULL THEM OUT
	MOVEI 1,100
	CFIBF		;CLEAR TYPE-AHEAD AT ERROR
	JRST TBRK	;TYPE THE BREAK MESSAGE

;VOLUNTARY TERMINATION (HFORK, HALTF, BPT)
;GET ACTUAL INSTRUCTION THAT CAUSED TRAP
TRAP2:	HRRZ R,PC
TRAP21:	CALL FETCH	;FETCH AN INSTR
	 SETZM T	;PROTECTED, MAKE LIKE ILLEGAL INSTR.
TRAP22:	LDB W1,[POINT 9,T,8]
	CAIE W1,<<XCT 0>/1B8>	;IS THIS AN XCT?
	JRST TRAP23
TRAP29:	LDB R,[POINT 4,T,17]
	CAIE R,0	;ANY XR SPECIFIED?
	MOVE R,AC0(R)	;YES, GET IT
	ADD R,T		;DO INDEX ADDITION
	HRRZS R
	TLNN T,(@)	;ANY INDIRECTION?
	JRST TRAP21	;NO, CHECK FOR ANOTHER XCT
	CALL FETCH	;FETCH INDIRECT ADDR
	 SETZM T
	JRST TRAP29

TRAP23:	PUSH P,T	;SAVE IT
	PUSH P,R
	TRNN F,CONDX
	CALL REMOVB	;PULL OUT BPT'S IF THEY ARE IN
	POP P,R
	POP P,T
	CAMN T,[BPT]
	JRST CHKBPT	;POSSIBLE BPT HIT
	AOS PC		;SO A $P WILL CONTINUE
	CAME T,[HFORK]
	CAMN T,[HALTF]
	 JRST TRAP27
	SOS PC		;REALLY WANT TO SEE THE INSTRUCTION
	CALL CRF
	MOVEI W,16	;SOMETHING IS SCREWY, WHY HAS THE REAL REASON
	JRST TBRK1	;TYPE  HUH?  FOR THE BREAK MESSAGE

TRAP27:	MOVSI T,(1B5)	;USER MODE BIT
	IORM T,REALPC	;MAKE PC RIGHT FOR $P
	MOVE W1,[POINT 7,[ASCIZ /IDDT/]]
	CALL TYPE	;ANNOUNCE OURSELVES
	JRST DD1	;TO MAIN LOOP

CHKBPT:	TRNE F,CONDX	;HIT BPT, WERE THEY IN?
	JRST CHKBP2	;NO,  TRY FOR $X COMPLETION, ETC.

;SEE IF IT IS A BPT
	MOVEI T,BPTS
CHKBP1:	HRRZ W,0(T)	;WHERE THIS BPT IS PLANTED
	CAMN R,W	;WHERE ONE ENCOUNTERED
	JRST BCOM	;A HIT!
	ADDI T,NBPTV
	CAIE T,BPTS+NBP*NBPTV
	JRST CHKBP1

;IS IT A PSEUDO BPT -- $X COMPLETION, ETC
CHKBP2:	MOVEM R,TT
	HRRZ W1,XRG	;WHERE $X HAPPENS IN USER
	SUB TT,W1
	JUMPLE TT,ILLINS	;WITHIN ALLOWED RANGE OF SKIPS?
	CAILE TT,3
	JRST ILLINS	;NO, CALL IT ILLEGAL

;PSEUDO BPT HIT, SEE WHY
	TRNE F,XEQ	;IN $X?
	JRST XCOM	;YES.
	TRNE F,CONDX	;IN A CONDITIONAL BREAK EVAL?
	JRST CONCOM	;YES.
	JRST ILLINS	;HUH?

;TYPE SOFTWARE GENERATED (IDDT) ILLEGAL INSTRUCTION
ILLINS:	MOVEI W,17	;ILL:
	MOVEM W,WHY


;TYPE BREAK MESSAGE,  WHY SAYS WHICH
TBRK:	CALL CRF	;CARRIAGE RETURN
	HRRZ W,WHY
TBRK1:	MOVE W1,MSG(W)	;TEXT OF BREAK REASON
	CALL TEXT2	;TYPE IT
	HRRZ T,PC
	CALL LI1	;EXAMINE THE BREAK LOCATION, SETUP "."
	CALL LCT
	HRRZ W,WHY
	CAIE W,10	;INTERRUPT CODE
	TRNN F,XEQ!CONDX
	JRST DD2
	CALL UNSET	;POP PREVIOUS $X CONTEXT
	JRST DD1

;READ THE USER'S STATE
;SWITCH TTY AND SUBSYS TO IDDT

USTATE:	MOVEI 1,100
	RFMOD
	MOVEM 2,SAVTTY
	RFCOC
	MOVEM 2,SAVTT2
	MOVEM 3,SAVTT3
	MOVE 2,TTYCC2
	MOVE 3,TTYCC3
	SFCOC
	GTABS
	MOVEM 2,USRTB2
	MOVEM 3,USRTB3
	MOVEM 4,USRTB4
	MOVE 2,DDTTB2
	MOVE 3,DDTTB3
	MOVE 4,DDTTB4
	STABS
	GETNM
	MOVEM 1,SUBSYS
	MOVE 1,[SIXBIT /IDDT/]
	SETNM			;SET SUBSYSTEM NAME
	MOVE 1,FORK
	RWM
	MOVEM 1,USRPSI+0	;USER CHANNELS WITH WAITING REQ.
	MOVE 1,FORK
	RCM
	MOVEM 1,USRPSI+1	;ACTIVE USER CHANNELS
	MOVEM 2,USRPSI+2	;BREAKS IN PROGRESS
	MOVE 1,FORK
	SETOM USRPSI+3
	SKPIR			;SEE IF USR HAS INTERRUPTS ON
	SETZM USRPSI+3
	DIR
	MOVEI 2,AC0
	RFACS			;GET USER'S AC'S
	SETZM USRFLG		;WE'RE NOT IN THE USER.
	RET

DDT:	SETZM STRING	;GET COMMANDS FROM TTY, NOT STRING AT BPT
	CALL CHKSYM	;INITIALIZE SYMBOL TABLE
	CALL PGMST	;DO A $: IF POSSIBLE
DD1:	CALL CRF	;TYPE CAR.RET.  LINE FEED

;CARR. RET. ETC., COME BACK HERE
DD1.5:	TLZ F,ROF		;CLOSE ANY OPEN REGISTER
	MOVE T,[SCHM,,SCH]
	BLT T,ODF		;LOAD MODE CONTROL SWITCHES
DD2:	SETZM PRNC		;PARENTHESES COUNT
	INTOFF			;SOME COMMANDS DO INTON
	MOVE P,PS

;OPEN PAREN COMES BACK HERE
LIS:	MOVE T,ESTU
	MOVEM T,ESTUT		;INIT UNDEFINED SYM ASSEM
	MOVEI 1,100
	RFMOD
	ANDCMI 2,17B23!3B25!3B29
	IORI 2,16B23!2B25!1B29	;DON'T AWAKEN ON ALPHA
	SFMOD
	TDZ F,[777777-ROF-STF,,LF1+CF1+ITF+Q2F]

; < AND > COME BACK HERE
WHICH==SEMIF!SEMIF2!NAF!CONDX!TEMF!TEM2F!INTFLG
LIS0:	TDZ F,[777777-ROF-STF-FAF-SAF,,WHICH]
	SETZM WRD

;SPACE AND , HERE
LIS1:	SETZM FRASE

;+ - @ ETC. HERE
LIS2:	MOVEI T,1
	MOVEM T,FRASE1
	TLZ F,MLF+DVF

;* / HERE
L1:	TLZ F,CF+CCF+SF+FPF	;TURN OFF CONTROL, SYL, PERIOD FLAG
L1A:	SETZM SYL		;NO SYL YET

;^ ETC. HERE
L1RPR:	SETZM SYM
	MOVEI T,6
	MOVEM T,TEM		;INIT CHR PER SYMBOL COUNTER
	MOVE T,[POINT 7,TXT]
	MOVEM T,CHP		;SETUP FOR OPEVAL SYMBOL
	SETZM TXT
	SETZM TXT+1		;TO KEEP JSYS LOOKUP HAPPY
	SETZM DEN		;DECIMAL NUMBER ACCUMULATOR
	SETZM WRD2		;NUMBER TO RIGHT OF $ IN COMMAND
	MOVE T,[POINT 7,STRBUF-1,34]
	MOVEM T,STRIP
	MOVEM T,STROP		;INIT ATOM BUFFER POINTERS

;NUMBERS, LETTERS COME BACK HERE FOR MORE OF SYMBOL
L2:	MOVE 1,[^D20,,1]	;^T TO CHANNEL 1
	ATI
	MOVE 1,ESCCOD		;THE CURRENT ESCAPE CODE (RUBOUT)
	DTI
	CALL TIN		;PICK UP CHARACTER
	HRLZ 1,ESCCOD		;ASSIGN TO CHAN. 0
	ATI
	CAIL T,"A"+40		;LOWER CASE A
	CAILE T,"Z"+40		;LOWER CASE Z
	CAIA			;NOT LOWERCASE
	TRC T,40		;CHANGE LOWER CASE TO UPPER CASE
	TRNN F,SEMIF		;SEMICOLON CONTROL, OR...
	TLNE F,CF		;ALT. MODE CONTROL FLAG?
	JRST L21		;CONTROL
	CAIG T,"Z"		;Z
	CAIGE T,"A"		;A
	 JRST L21		;NOT A LETTER
	JRST LET


;CONTROL OR NOT-LETTER
L21:	CAILE T,137
	JRST ERR
	TRNE F,SEMIF
	ADDI T,140		;USE OTHER TABLE
	MOVE R,T
	IDIVI R,3		;REMAINDER GIVES COLUMN, QUOTIENT GIVES ROW
	LDB W,BDISP(R+1)	;GET 12 BIT ADDRESS FROM DISPATCH TABLE
	CAIGE W,MULT-DDT	;FIRST EVAL ROUTINE
	JRST DDT(W)		;NO EVAL


	MOVE T,SYL
	TLZN F,LTF
	JRST POWER

	CAIN W,SPACE-DDT	;IS TERMINATOR A SPACE?
	SKIPE WRD		;AND WORD SO FAR ZERO?
	SKIPA T,[OPEVAL,,EVAL]	;NO, SEARCH EVAL 1ST
	MOVS T,[OPEVAL,,EVAL]	;YES, DO OP SEARCH
	MOVEM T,TEM1
	JRST L213

L212:	HLRZS T,TEM1		;GET ADDRESS OF THE OTHER LOOKUP ROUTINE
	JUMPE T,UND1		;IF ADR=0, THEN SYMBOL UNDEFINED
L213:	CALL (T)		;CALL OPEVAL OR EVAL
	JRST L212		;SYMBOL NOT FOUND
	CAIN W,ASSEM-DDT	;DEFINED SYMBOL FOLLOWED BY #?
	JRST ERR

;EXPONENT ROUTINE COMES BACK HERE
L4:	TLZE F,MF
	MOVN T,T
	TLNN F,SF
	CAIE W,LPRN-DDT
	JRST .+2
	JRST LPRN

	EXCH T,FRASE1
	TLNN F,DVF
	IMULB T,FRASE1
	TLZE F,DVF
	IDIVB T,FRASE1
	CAIGE W,ASSEM-DDT
	JRST DDT(W)		;MULTIPLY OR DIVIDE
	ADDB T,FRASE
	CAIGE W,SPACE-DDT
	JRST DDT(W)		; + - @ ,

	ADD T,WRD
	TLNE F,TIF		;TRUNCATE INDICATOR FLAG
	HLL T,WRD		;TRUNCATE
	MOVEM T,WRD
	TLNN F,QF
	MOVE T,LWT
	SETZM R
	MOVE W1,ESTUT		;W1 IS USED IN DEPRA
	CAMN W1,ESTU
	JRST L5
	CAILE W,CARR-DDT
	JRST ERR
L5:	CAIG W,RPRN-DDT
	JRST DDT(W)
	PUSH P,[JRST RETX]
	SKIPN PRNC
	JRST DDT(W)

;GIVE GENERALIZED ERROR COMMENT
ERR:	SETZM STRING
	MOVEI W1,"?"
	JRST WRONG1


;UNDEFINED SYMBOL TYPED.
UNDEF:	MOVEI W1,"U"
	JRST WRONG1


;RUBOUT FROM INSIDE IDDT
;REENTER IDDT AT WRONG
RENWRG:	MOVEI 1,100
	CFIBF
	MOVEI 1,101
	CFOBF
WRONG:	CIS
	MOVE W1,[ASCII /XXX/]
WRONG1:	MOVE P,PS
	CALL TEXT
	TLNN F,ROF		;REG OPEN?
	JRST DD1		;NO, CR AND RESET


;COMMON RETURN
RETX:	MOVE P,PS
	CALL LCT		;COMMON RETURN FOR TAB;,JRST LIS
	JRST DD2

UND1:	MOVE R,ESTUT		;UNDEFINED SYM ASSEMBLER
	JUMPE R,UNDEF		;UNDEFINED IF NO UNDEF TAB
	HLRE S,ESTUT
	ASH S,-1		;SETUP EVAL END TEST
	HRLOI W1,37777+DELI+LOCAL
	CALL EVAL2
	CAIN W,ASSEM-DDT
	TLNN F,ROF
	JRST UNDEF
	SKIPE PRNC
	JRST UNDEF
	MOVEI T,"#"
	CAIE W,ASSEM-DDT
	CALL TOUT

	MOVN R,[2,,2]
	ADDB R,ESTUT
	MOVE T,SYM
	TLO T,GLOBAL
	MOVEM T,(R)
	HRRZ T,LLOCO
	TLNE F,MF
	TLO T,(STNEG)	;SET FLAG TO SHOW SUBTRACTIVE REQUEST
	TLO T,(STADD)	;SET FLAG TO SHOW UNCHAINED REQUEST
	MOVEM T,1(R)
	MOVEI T,0
	JRST L4


;? COMMAND
QUESTN:	CALL CRF	;LIST UNDEFINED SYMBOLS
	INTON
	TLNE F,LTF	;HAS A SYMBOL BEEN TYPED?
	JRST QLIST	;NO
	MOVE R,ESTU
QUEST1:	JUMPGE R,DD1
	MOVE T, (R)
	SKIPA W1,ESTU

QUEST2:	ADD W1,[2,,2]
	CAME T,(W1)
	JRST QUEST2
	CAME R,W1
	JRST QUEST4
	CALL SPT
	CALL CRF
QUEST4:	ADD R,[2,,2]
	JRST QUEST1

QLIST:	HLRE S,SYMPTR
	ASH S,-1	;NUMBER OF ENTRIES
	SKIPL R,SYMPTR
	JRST RETX	;NO SYM TAB
QLIST1:	SETZM QLPNT	;SAY NO REFERENCE YET
QLIST2:	MOVE T,(R)	;GET SYM
	TLZN T,PNAME	;A PROG NAME?
	JRST QLIST6	;YES
	CAMN T,SYM	;NO, IS AN OCCURANCE FOUND?
	HRRZM R,QLPNT	;YES, REMEMBER WHERE
QLIST3:	AOBJN R,.+1	;MOVE TO NEXT TAB ENTRY
	AOBJN R,QLIST4	;END OF TABLE?
	MOVE R,SYMPTR	;YES RING PTR
QLIST4:	AOJLE S,QLIST2	;DONE ALL SYMS?
	JRST DD1	;YES
QLIST6:	SKIPN QLPNT	;FOUND THE SYM?
	JRST QLIST3	;NO, KEEP LOOKING
	CALL SPT1	;PRINT PROGRAM NAME
	MOVE T,@QLPNT	;GET SYM BACK
	TLNN T,GLOBAL
	JRST QLIST7	;NOT GLOBAL
	CALL TSPC	;TYPE SPACE AND G
	MOVEI T,"G"
	CALL TOUT
QLIST7:	CALL CRF
	SETZM QLPNT	;RESET FIND FLG
	JRST QLIST3	;RESUME SEARCH

;DIGITS, ADD IN TO OCTAL
;ACCUMULATOR (SYL), FLOATING NUM (FH,SYL)
;AND DECIMAL NUMBER (DEN), THEN HANDLE AS A LETTER
NUM:	ANDI T,17		;T HOLDS CHARACTER
	TLNE F,CF+FPF		;$ TYPED OR EXPONENT
	JRST NM1		;FORM WRD2
	MOVE W,SYL
	LSH W,3
	ADD W,T
	MOVEM W,SYL
	MOVE W,DEN
	IMULI W,12		;CONVERT TO DECIMAL
	ADD W,T
	MOVEM W,DEN
	AOJA T,LE1A

;$ SIGN
DOLLAR:	SKIPA T,[46+"A"-13]	;RADIX 50 $ TO BE

;PER CENT SIGN
PERC:	MOVEI T,47+"A"-13	;PERCENT SIGN

;LETTERS, ADD IN TO SYMBOL (SYM) BEING TYPED IN
LET:	TLC F,SF+FPF		;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
	TLZN F,LTF+FEF+SF+FPF
	CAIE T,"E"
	TLOA F,LTF
	TLOA F,FEF
	JRST LET1
	TLZN F,MF
	SKIPA W1,SYL
	MOVN W1,SYL
	MOVEM W1,FSV
	SETZM DEN
LET1:	SUBI T,"A"-13		;FORM RADIX 50 SYMBOL
LE1A:	TLO F,SF+QF

;PACK CHARACTER INTO SYM
LE2:	MOVE W,SYM
	MOVEI R,"A"-13(T)
	IMULI W,50		;CONVERT TO RADIX 50
	ADD W,T
	SOSGE TEM		;IGNORE CHARACS AFTER 6
	JRST L2
	MOVEM W,SYM
	IDPB R,CHP
	JRST L2

;FORM NUMBER AFTER $
NUM1:	EXCH T,WRD2
	IMULI T,12
	ADDM T,WRD2
	TRO F,Q2F
	JRST L2

NM1:	TLNE F,CF
	JRST NUM1
	MOVEI W1,6		;FORM FLOATING POINT NUMBER
	AOS W2,NPWR10		;GET THE NEGATIVE POWER OF TEN
	MOVSI R,(1.0)
NM1A:	TRZE W2,1
	FMPR R,FT(W1)
	JUMPE W2,NM1B
	LSH W2,-1
	SOJG W1,NM1A
NM1B:	MOVSI W1,211000(T)	;UNNORMALIZED FP VALUE OF DIGIT
	FMPR R,W1		;COMPUTE VALUE OF NEW DIGIT
	FADRB R,FH		;ADD VALUE INTO FLOATING NO.
	MOVEM R,SYL
	AOJA T,LE1A

;THIS SEQUENCE INITIALIZES THE SYM TAB LOGIC
CHKSYM:	HLRZ T,ESTU
	SUB T,ESTU
	MOVE W,SYMPTR
	ADD T,W		;IF THE TOP OF THE UNDEFINED SYM TAB DOES
	TRNE T,-1	; NOT POINT TO BOTTOM OF REGULAR SYM TAB,THEN
	HRRZM W,ESTU	; RE-INIT UNDEFINED SYM TABLE POINTER, ESTU.


	MOVE T,PRGM
	SUB T,W		;IF THE SYM TABLE PNTR AND THE PROGRAM
	TSC T,T		; NAME (PRGM) PNTR DO NOT END UP IN THE
	MOVE W1,PRGM	; SAME PLACE, OR THEY DO NOT BOTH START ON
	XOR W1,W	; AN EVEN (OR BOTH ON ODD) LOCATION, OR
	TRNN W1,1	; PRGM .GE. 0, THEN RE-INIT PRGM.
	JUMPE T,CPOPJ
	SETZM PRGM
	SETZM BLOCK	;RESET WORLD
	RET

;AUTOMATIC $: FOR PROGRAM CONTAINING THE START ADDRESS
PGMST:	MOVE 1,FORK
	GEVEC
	JUMPE 2,CPOPJ		;NO ENTRY VECTOR
	HRRZ W,2		;SA
	SKIPL PRGM		;DON'T IF ALREADY SET
	SKIPL R,SYMPTR		;OR IF NO SYMTAB
	 RET
	MOVSI T,1		;BIG NUMBER
	JRST PGMS19

PGMST0:	MOVE T,0(R)		;GET ENTRY
	TLNE T,(17B3)		;PROGRAM NAME?
	JRST PGMST2		;NO, SKIP IT
PGMST1:	HRRZ T,1(R)		;LOW BREAK
	SUB T,W			;COMPARE WITH SA
	JUMPL T,PGMST2		;THIS PRGM'S BRK IS BELOW THE SA
	CAML T,TEM		;BREAK CLOSER THAN LAST ONE?
	JRST PGMST2		;NO
	MOVEM R,PRGM		;CURRENT BEST PROGRAM
PGMS19:	MOVEM T,TEM		;CUNNENT BEST DISTANCE
PGMST2:	AOBJN R,.+1
	AOBJN R,PGMST0		;TRY NEXT ENTRY
	SETZM BLOCK
	SKIPL R,PRGM		;DID IT GET SET?
	 RET
	MOVE T,0(R)		;THE PROGRAM NAME
	MOVEM T,SYM		;SETUP FOR SB1
	CALL SB1		;LOOK FOR BLK NAME = PRGM NAME
	 RET			;NONE(UGH! EVAL WILL LOOP AROUND EV2B)
	MOVEM R,BLOCK		;DO  $&  TOO
	RET

POWER:	TLNN F,FEF
	JRST L4		;NO EXPONENT
	CAIE W,PLUS-DDT
	CAIN W,MINUS-DDT
	TROE F,POWF
	TRZA F,POWF
	JRST DDT(W)	; E+-

	MOVE W2,DEN
	SETZM FRASE
	MOVEI W1,FT-1
	TLZE F,MF
	MOVEI W1,FT01
	SKIPA T,FSV
POW2:	LSH W2,-1
	TRZE W2,1
	FMPR T,(W1)
	JUMPE W2,L4
	SOJA W1,POW2

PERIOD:	MOVE T,DEN		;VALUE OF DECIMAL NUMBER
	TLNE F,SF		;SYLLABLE STARTED?
	JRST PERIO2		;YES, TAKE AS DECIMAL NUMBER
	MOVE T,LLOC		; VALUE OF "." IN CURRENT SEQUENCE
	TLNN T,(DDTINT)		; "." INTERNAL TO IDDT?
	JRST PERIO2		;NO
	TROE F,INTFLG		;SAY THIS EXPR IS INTERNAL
	 JRST ERR		;INTERNAL ARITHMETIC
PERIO2:	MOVEM T,SYL
	TLNE F,FPF		;HAS A PERIOD BEEN SEEN BEFORE?
	TLO F,LTF		;YES, TWO PERIODS MAKES A SYMBOL
	TLON F,FPF+SF+QF
	MOVEI T,0
	IDIVI T,400
	SKIPE T
	TLC T,243000
	TLC W1,233000
	FAD T,[0]		;NORMALIZE T AND W1
	FAD W1,[0]
	FADR T,W1
	MOVEM T,FH
	SETZM NPWR10		;NUM OF DIGITS PASSED THE DEC. PT.
	MOVEI T,45		;RADIX 50 PERIOD
	JRST LE2		;PROCESS AS SYMBOL CONSTITUENT


;$Q  VALUE OF LAST THING TYPED BY IDDT OR USER
QUAN:	TLNN F,CCF
	SKIPA T,LWT		;$Q, GET LAST WORD TYPED
	MOVS T,LWT		;$$Q, GET IT SWAPPED
	JRST QUAN1


;$V  LEVT HALF --  $$V TO GET SIGN EXTENDED
LEFT:	HLRE T,LWT
	TLNN F,CCF
	HRRZS T
	JRST QUAN1


;HERE TO EXAMINE INTERNAL REGISTER
;ADDRESS OF IT IN T
;USED BY $G  $X  ETC.
QUANIN:	TLO T,(DDTINT)		;MARK FOR ADR INTERNAL TO DDT
	TROE F,INTFLG		;DOES EXPR ALREADY CONTAIN INT SYM?
	JRST ERR		;YES.
	MOVEI W,1
	MOVEM W,FRASE1
QUAN1:	MOVEM T,SYL
QUAN2:	TLO F,SF+QF		;WRD,SYL STARTED
	TLZ F,CF+CCF
	JRST L2

;SEMICOLON TYPED
SEMIC:	TROE F,SEMIF		;SEEN ONE ALREADY?
	TRO F,SEMIF2		;YES
	JRST CONTR1


; $ TYPED
CONTRO:	TLOE F,CF		;HAVE ALREADY SEEN ONE?
	TLO F,CCF		;YES
CONTR1:	PUSH P,2
	MOVEI 1,100
	RFMOD
	IORI 2,17B23		;WAKEUP ON EVERYTHING
	SFMOD
	POP P,2
	JRST L2

;BIT 40 - DELETE OUTPUT
; 20 - DELETE INPUT
; 10 - LOCAL
; 04 -GLOBAL
; NO BITS - PROGRAM NAME
;LOCAL+GLOBAL=BLOCK NAME, VALUE IS BLOCK LEVEL
;S IS -NUMBER OF SYMBOLS LEFT TO BE CONSIDERED
;R IS CURRENT SYM TAB POINTER
;SYM HAS SYMBOL BEING LOOKED UP
;W1 HAS CODE BITS WHICH WILL CAUSE THE CURRENT
;	ENTRY TO BE SKIPPED OVER
;PRGM IS 0 OR POINTER TO CURRENT PROGRAM'S SYMBOLS
;BLOCK IS 0 OR POINTER TO CURRENT BLOCK'S SYMBOLS
;TBLK IS THE TEMPORARY BLOCK POINTER IF NOT 0
;BLVL IS THE HIGHEST LEVEL BLOCK ALREADY SCANNED


;LOOKUP LOCAL IN THIS PROGRAM, OR ELSE GLOBAL ANYWHERE
;FOR PURPOSE OF KILLING ($$K) A SYMBOL
EVAL0:	HRLOI W1,37777+DELI	;IGNORE HALF-KILLED SYMBOLS
	HLRE S,SYMPTR
	ASH S,-1	;SETUP END TEST (- NUM OF ENTRIES IN TABLE)
	JRST EVAL3

EVAL1:	ADD R,[2,,2]
EVAL2:	SKIPL R
	MOVE R,SYMPTR
	AOJG S,CPOPJ	;TRANSFER IF NO SYMBOL FOUND
EVAL3:	MOVE T,(R)
	XOR T,SYM
	TLNN T,PNAME	;WHEN PROGRAM NAME ENCOUNTERD,...
	TLOA W1,LOCAL	; STOP LOOKING AT LOCAL SYMS
	TDNE T,W1	;REJECT THIS ENTRY?
	JRST EVAL1	;YES, WRONG TYPE OR NAME DOESN'T MATCH
	TLNN T,340000	;IS THIS ENTRY DELETED?
	JRST EVAL1	;YES. FORGET IT
	MOVE T,1(R)	;GET DEFINITION
CPOPJ1:	AOS (P)		;FOUND SYMBOL, SKIP
CPOPJ:	RET

;MAIN SYMBOL LOOKUP.
EVAL:	CALL EVALA	;SEARCH UP THE SYMBOL TREE
	JRST EV9	;NOT FOUND. SEARCH WHOLE TREE
	JRST CPOPJ1	;FOUND, SKIP.

;SCAN UP THE SYMBOL TREE.
;DON'T CONSIDER SYMS IN BLKS ON
; SAME OR DEEPER LEVELS.
EVALA:	MOVSI W1,DELI	;IGNORE HALF-KILLED SYMS
	HLRE S,SYMPTR
	ASH S,-1	;END CHK.  - # OF TAB ENTRIES
	SKIPL R,TBLK
	JRST EVL1
	SETZM TBLK
	JRST EVL2

;NO BLOCK SET
EVL1:	SKIPL R,BLOCK
	JRST EV5	;NO PERM BLOCK EITHER.

;GET LEVEL FROM DEF OF CURRENT BLOCK
EVL2:	MOVE T,1(R)
	MOVEM T,BLVL	;BLKS DEEPER THAN BLVL WON'T BE CONSIDERED
	JRST EV1	;START SCAN WITH THIS BLOCK'S SYMS


EV3:	CAMN R,SYMPTR	;JUST CHECKED LOWEST ENTRY?
	JRST EV4	;YES, RING R TO TOP AND CONTINUE
	AOJGE S,CPOPJ	;NOTHING FOUND IF ALL ENTRIES SCANNED


;MAIN LOOP
EV1:	SUB R,[2,,2]	;MOVE TO NEXT ENTRY
	MOVE T,(R)	;GET NAME AND TYPE
	TDNE T,W1	;TEST TYPE BITS
	JRST EV3	;THIS TYPE BEING REJECTED
	LDB T,[POINT 4,(R),3]	;GET TYPE BITS
	CAIN T,3
	JRST EV2	;BLOCK NAME
	SKIPN T 	;PROGRAM NAME?
	TLOA W1,LOCAL	;YES. START REJECTING LOCALS
	SKIPA T,(R)	;RESTORE T IF NOT PRGM NAME
	JRST EV3	;RESUME SCAN AFTER PROGRAM NAME
	XOR T,SYM	;SEE IF ENTRY MATCHES KEY
	TLZ T,740000	;FLUSH TYPE BITS FROM CONSIDERATION
	JUMPN T,EV3	;NO MATCH. KEEP LOOKING
	MOVE T,1(R)	;GET DEFINITION
	JRST CPOPJ1	;SKIP.

;SCAN HIT BOTTOM OF TABLE, RING TO TOP
EV4:	HLRE R,SYMPTR
	MOVNS R		;GET POSITIVE LENGTH
	ADD R,SYMPTR	;ONE ENTRY PASSED TOP
	AOJL S,EV1	;KEEP SCANNING IF ALL NOT CHECKED
	RET		;NOT FOUND

;BLOCK NAME ENCOUNTERED
EV2:	MOVE T,1(R)	;DEF. IS LEVEL OF NEW BLOCK'S SYMBOLS
	CAMGE T,BLVL	;LEVEL < LEVELS ALREADY CONSIDERED?
	JRST EV2A	;YES. SCAN THEM
EV2B:	SUB R,[2,,2]	;NO. SKIP OVER THIS BLOCK
	ADDI S,1	;LOOK FOR ANOTHER BLOCK WHICH ENCLOSES THIS ONE
	LDB T,[POINT 4,(R),3]
	CAIE T,3
	JRST EV2B	;NOT A BLOCK NAME. KEEP LOOKING
	JRST EV2	;BLOCK NAME. CHECK ITS LEVEL
EV2A:	MOVEM T,BLVL	;SAVE LEVEL OF ENCLOSING BLOCK
	JRST EV3	;SO NO DEEPER BLOCKS WILL BE SCANNED


;HERE WHEN EVALA CALLED AND NO CURRENT TBLK OR BLOCK
EV5:	MOVEI T,1
	MOVEM T,BLVL	;SET LEVEL TO 1 (MAIN)
	SKIPGE R,PRGM	;IS THERE A PRGM SET?
	JRST EV1	;YES, SEARCH ITS SYMBOLS,ALL LEVELS
	HLRE R,SYMPTR	;RESET R TO TOP OF TAB
	MOVNS R
	ADD R,SYMPTR
	JRST EV1

;SCAN WHOLE SYMBOL TREE LOOKING FOR PROGRAM AND
; BLOCK WHICH CONTAIN SYM.  TYPE PRGM AND BLK
; IF APPROPRIATE.
EV9:	SETZM SVTB
	SETZM SVFB
	SETOM SVF	;INDICATE NO MATCH FOUND YET
	HLRE T,SYMPTR
	JUMPGE T,CPOPJ	; EMPTY SYMBOL TABLE
	MOVNS T
	ADD T,SYMPTR
	HRRZ R,T	;R POINTS AT END OF TABLE + 2
EV9A:	SUB R,[2,,2]	;MOVE DOWN ONE ENTRY
	CAMN R,SYMPTR	;LOOKING AT BOTTOM ENTRY?
	JRST EV9B	;YES
	LDB T,[POINT 4,(R),3]	;GET TYPE BITS
	CAIN T,3
	JRST EV9C	;BLOCK NAME
	CAIN T,0
	JRST EV9D	;PROGRAM NAME
	TRNE T,4
	JRST EV9A	;DELETED, IGNORE
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000	;FLUSH TYPE BITS FROM CONSIDERATION
	JUMPN T,EV9A	;DOESNT MATCH KEY, TRY NEXT
	AOSE SVF	;IS THIS THE FIRST FIND?
	JRST EV9E	;NO
	MOVEM R,BLVL	;YES. REMEMBER BLOCK LEVEL
	MOVE T,1(R)
	MOVEM T,SVBTS
	JRST EV9A	;RESUME SCAN

;NOT FIRST MATCH
EV9E:	MOVE T,1(R)
	CAME T,SVBTS	;DEFINITION SAME AS FIRST MATCH?
	RET		;NO, REPORT FAILURE
	SETZM SVF	;MUST BE -1 OR 0 (0 FOR ON)
	JRST EV9A	;RESUME SCAN


;BLOCK NAME ENCOUNTERED
EV9C:	SKIPN SVF	;HAS A MATCH BEEN SEEN ALREADY?
	JRST EV9A	;YES, KEEP LOOKING
	MOVEM R,SVFB	;NO, REMEMBER WHICH BLOCK WE'RE AT
	JRST EV9A	;IN CASE WE GET A FIND IN THIS ONE



;PROGRAM NAME ENCOUNTERED
EV9D:	SKIPN SVF	;HAS A MATCH BEENSEEN ALREADY?
	JRST EV9A	;YES. KEEP SCANNING
	MOVEM R,SVTB	;NO. REMEMBER IN CASE MATCH IS FOUND
	SETZM SVFB	;NEW PRGM. DON'T KNOW BLK YET
	JRST EV9A	;KEEP SCANNING

;SCAN HIT BOTTOM ENTRY IN TABLE
EV9B:	SKIPE SVF	;MATCH FOUND?
	RET		;NO. REPORT FAILURE
	AOS (P)		;SET FOR SKIP RETURN
	MOVSI T+1,(ASCIZ /[_/)
	CALL TEXT2
	SKIPE R,SVTB	;DO WE HAVE A PRGM NAME,
	CAMN R,PRGM	;AND IS IT SAME AS CURRENT ONE?
	JRST EV9B1	;YES. DON'T BOTHER PRINTING PRGM NAME
	MOVE T,(R)
	CALL SPT1
	MOVSI T+1,(ASCIZ /$:/)
	CALL TEXT2
EV9B1:	MOVE W1,BLVL
	CALL SPT0
	MOVEI T,"]"
	CALL TOUT
	MOVE R,BLVL	;RETURN WHERE IN TABLE
	MOVE T,1(R)	;AND VALUE
	RET


TEXI:	PUSH P,2
	INTON
	MOVEI 1,100
	RFMOD
	IORI 2,17B23		;WAKEUP ON EVERYTHING
	SFMOD
	POP P,2
	CALL TIN		;INPUT TEXT
	MOVEM T,SYL
	MOVEI W1,5
	MOVEI T-1,0
	CALL TIN
	CAIN T,33		;NEW ALT MODE, ESCAPE
	JRST QUAN2
	TLNN F,CCF
	TLNN F,CF
	JRST TEXI2+1
	AOJA W1,SIXBIN
TEXI2:	CALL TIN
	CAMN T,SYL
	JRST TEXI3
	ROT T,-7
	LSHC T-1,7
	SOJG W1,TEXI2
	CALL TEXDEP		; DEPOSIT THIS WORD OF TEXT
	JRST TEXI2+1		; AND CONTINUE

TEXI3:	LSHC T-1,-43
	JUMPLE W1,QUAN1
	LSH T,7
	SOJA W1,.-2

TEXDEP:	TLNN F,ROF		; IS A REGISTER OPEN?
	JRST TEXDE2
	CALL TIN
	CAMN T,SYL
	TLNE F,CCF
	JRST .+2
	RET
	PUSH P,T
	MOVE T,-1(P)
	XCT 1(T)
	MOVE R,LLOCO
	CALL DEP
	JRST ERR
	POP P,T
	AOS LLOCO
	MOVEI W1,5
	MOVEI T-1,0
	RET
TEXDE2:	MOVE T,SYL		; NO, TYPE TERMINATOR FOR THE GUY
	CALL TOUT
	JRST CPOPJ1		; AND SKIP RETURN

SIXBI1:	CALL TIN    	; INPUT TEXT (SIXBIT)
SIXBIN:	CAMN T,SYL
	JRST SIXBI2
	CAIL T,"A"+40		;IS CHAR BETWEEN LOWER CASE "A" AND
	CAILE T,"Z"+40		; LOWER CASE "Z"?
	SKIPA			;NO
	TRC T,40		;YES, CONVERT TO UPPER CASE
	CAIL T," "		;IS CHAR IN SIXBIT SET?
	CAILE T,"_"
	JRST ERR		;NO
	ANDI T,77		;YES, MASK TO 6 BITS
	TRC T,40		;CONVERT TO SIXBIT FORM
	ROT T,-6
	LSHC T-1,6
	SOJG W1,SIXBI1
	CALL TEXDEP		; DEPOSIT THIS WORD OF TEXT
	JRST SIXBIN
SIXBI2:	MOVE T,T-1
	JUMPLE W1,QUAN1
	LSH T,6
	SOJA W1,.-2

; ;R --  TAKE PRECEEDING SYMBOL AS RADIX 50

RDX50:	MOVE T,SYM
	MOVEM T,SYL
	TLZ F,FPF!FEF!LTF!SF
	TRZ F,SEMIF!SEMIF2	;ALLOW $ MODIFIERS
	JRST L1RPR


;<SYM>$K -- KILL SYMBOL FOR OUTPUT
;<SYM>$$K -- KILL FOR INPUT AND OUTPUT
;SYM HAS THE SYMBOL
KILL:	TLNN F,LTF		;DOES SYM CONTAIN A LETTER?
	JRST KILTAB		;NO
	CALL EVAL
	JRST KILL1		;CANT FIND A DEFINED SYM BY THAT NAME

;FOUND.  R POINTS AT NAME-VALUE PAIR IN SYM TAB
	MOVEI T,DELO/200000	;DELETE OUTPUT
	TLNE F,CCF
	MOVEI T,DELI/200000	;NO INPUT OR OUTPUT
	DPB T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
	JRST RETX


KILL1:	MOVE R,ESTU		;REMOVE UNDEFINED SYMS
	JUMPGE R,UNDEF		;EMPTY
KILL2:	CALL EVAL0
	JRST RETX
	CALL REMUN
	JRST KILL2



;REMOVE ONE SYMBOL FROM THE UNDEFINED TABLE
REMUN:	MOVE S,[2,,2]
	ADDB S,ESTU		;SHORTEN UNDEF TABLE AND MOVE ORG UP
	MOVE W,-2(S)		;PUT SYM WHICH FELL OFF BOTTOM
	MOVEM W,(R)		;IN PLACE OF SYM BEING DELETED
	MOVE W,-1(S)
	MOVEM W,1(R)
	RET

;$$K -- KILL ENTIRE SYMBOL TABLE
KILTAB:	TLNN F,CCF		;HOW MANY $'S
	JRST ERR		;NOT ENOUGH
	CALL FLSSYM
	JRST RETX

;SYMBOL TABLE FLUSHER
FLSSYM:	SKIPL T,SYMPTR	;OLD SYMBOL POINTER
	MOVE T,[-2,,HOME-2]
	MOVEM T,SYMPTR
	CAMN T,[-2,,HOME-2]
	JRST FLSUNS	;NO OLD SYMS PAGES TO WORRY ABOUT
	HRLZI R,0(T)
	TLZ R,777000
	SUB T,R
	ASH T,-11
	TRZ T,777000
FLSSP:	HRR 2,T		;PAGE
	HRLI 2,400000	;IDDT FORK
	SETOM 1		;DISMISS IT
	PMAP
	AOBJN T,FLSSP
	MOVE T,[-2,,HOME-2]	;"NULL" SYM PTR
	MOVEM T,SYMPTR
	SETZM PRGM
	SETZM BLOCK
	SETZM TBLK


;FLUSH UNDEFINED SYMBOL TABLE
FLSUNS:	SKIPL T,ESTU
	 RET			;NONE
	HRLZI R,0(T)
	TLZ R,777000
	SUB T,R
	ASH T,-11
	TRZ T,777000
FLSUN1:	HRR 2,T		;PAGE
	HRLI 2,400000	;IDDT FORK
	SETOM 1		;DISMISS IT
	PMAP
	AOBJN T,FLSUN1
	SETZM ESTU
	SETZM ESTUT
	RET

;SYM HAS SYMBOL TO LEFT OF :
;DEFV HAS VALUE OF A IN A<B:
TAG:	TLNN F,LTF   	; NO LETTERS IS ERROR
	JRST ERR   	; GO SAY ERROR
	TLNE F,FAF   	; DEFINE SYMBOLS
	JRST DEFIN	;A<B:
	TLNE F,CF	;$ TYPED?
	JRST SETNAM	;<PROGRAM>$:
	MOVE W,LLOCO	;<TAG>: COMMAND,  LLOCO=VALUE OF .
	TLNE F,(DDTINT)
	JRST ERR	; . WAS INSIDE OF IDDT
	HRRZM W,DEFV

DEFIN:	CALL EVALA	;DEFINED SYMBOL?
	 JRST DEF1	;NO - DEFINE
	 JRST DEF2	;YES, REDEFINE
DEF1:	MOVN R,[2,,2]
	ADDB R,SYMPTR	;MOVE UNDEFINED TABLE 2 REGISTERS
	HRRZ T,ESTU
	SUBI T,2
	HRL T,ESTU
	HRRM T,ESTU
	SKIPGE ESTU
	BLT T,-1(R)
DEF2:	MOVE T,DEFV
	MOVEM T,1(R)	;PUT IN NEW VALUE
	MOVSI T,GLOBAL
	IORB T,SYM
	MOVEM T,(R)	;PUT IN NEW SYM AS GLOBAL
	MOVE R,ESTU

DEF3:	JUMPGE R,RETX	;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE T,SYM
	TLO T,GLOBAL	;UNDEFINED TAB HAS GLOBAL ENTRIES
	CAME T,(R)
	JRST DEF4
	PUSH P,R	;SAVE PTR
	SKIPL R,1(R)	;IS ENTRY AN ADDITIVE REQUEST?
	JRST DEF7	;NO, CHAINED IN RIGHT HALF
	CALL FETCH
	 JRST ERR
	TLNN R,(STNEG)	;ADDITIVE OR SUBTRACTIVE?
	SKIPA S,DEFV	;ADDITIVE
	MOVN S,DEFV	;SUBTRACTIVE
	TLNE R,(STLH)	;RIGHT OR LEFT HALF?
	JRST DEF8	;LEFT
	ADD S,T		;RIGHT
	HRRM S,T
DEF5:	CALL DEP
	 JFCL
DEF6:	POP P,R
	CALL REMUN
DEF4:	ADD R,[2,,2]	;REMOVE THE NOW DEFINED SYMBOL
	JRST DEF3
DEF7:	JUMPE R,DEF6	;JUMP IF ALL DONE
	CALL FETCH
	 JRST ERR
	HRRZ S,T	;SAVE CHAIN PTR
	HRR T,DEFV	;REPLACE WITH NEW VALUE
	CALL DEP
	 JRST ERR	;LEAVES DANGLING CHAIN!!!
	HRRZ R,S
	JRST DEF7

DEF8:	HRLZS S		;LEFT HALF FIXUP
	ADD T,S
	JRST DEF5

;<PROGRAM>$: COMMAND
SETNAM:	MOVE R,SYMPTR	;SET PROGRAM NAME - DOLLAR COLON
SET1:	JUMPGE R,UNDEF
	MOVE T,(R)
	CAMN T,SYM
	JRST SET2
	ADD R,[2,,2]
	JRST SET1
SET2:	MOVEM R,PRGM
	SETZM BLOCK
	CALL SB1
	 JRST RETX
SBPRM:	MOVEM R,BLOCK
	JRST RETX


;SEARCH SYMBOLS IN PROGRAM BEGINNING AT R
;FOR BLOCK NAMED SYM
SB1:	CAMN R,SYMPTR
	RET		;HIT BOTTOM OF TAB.
	SUB R,[2,,2]
	LDB T,[POINT 4,(R),3]
	JUMPE T,CPOPJ	;BEGINNING OF NEXT PROGRAM
	CAIE T,3
	JRST SB1	;NOT A BLOCK NAME
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000
	JUMPN T,SB1	;NAME DOESN'T MATCH
	JRST CPOPJ1

SETBLK:	TLNE F,LTF
	SKIPL R,PRGM
	JRST ERR	;NO LETTERS IN NAME OR NO PROGRAM NAMED
	CALL SB1
	 JRST UNDEF
	TLNE F,CF	;$ OR $$ COMMAND?
	JRST SBPRM	;$: TO SET PROGRAM NAME
	MOVEM R,TBLK
	JRST L1RPR	;$$: TO SET BLOCK NAME


;FILE LOGIC

;THE FLAG TEMF IS USED TO CONTROL WHETHER OR NOT THE FORK IS
; TO BE STARTED AFTER THE GET ASSOCIATED WITH THE COMMAND (;Y, ;M
; ;L, OR $L). ON SUPPRESS RUNNING IT.

; ;Y -- YANK, BUT DON'T START A FILE
YANK:	MOVE W1,[POINT 7,[ASCIZ /ANK FILE: /]]
	TRO F,TEMF	;SUPPRESS RUNNING IT
	JRST LODFIL


; ;M -- MERGE FILE INTO CURRENT USER FORK
MERGE:	MOVE W1,[POINT 7,[ASCIZ /ERGE FILE: /]]
	TRO F,TEMF	;SUPPRESS RUNNING IT
	JRST LODFI1	;BYPASS NEWFORK GETTER

; ;L -- RUN THE NAMED FILE
LOADGO:	MOVE W1,[POINT 7,[ASCIZ /OADGO:   /]]
	TRZ F,TEMF	;ALLOW IT TO RUN

LODFIL:	CALL KILFRK
	CALL NEWFRK
LODFI1:	CALL TYPE
LODFI2:	HRROI 1,[ASCIZ /SAV/]
	MOVEM 1,DEFALT+5
	MOVSI 1,(1B2)
	MOVEM 1,DEFALT
	MOVEI 1,DEFALT
	MOVEI 2,0
	JRST ASJFN

;$L -- RUN THE LOADER
LOADER:	MOVE W1,[ASCII /OADER/]
	CALL TEXT
	CALL CRF
	CALL KILFRK
	CALL NEWFRK
	TRZ F,TEMF	;ALLOW IT TO RUN
	HRLZI 1,1
	HRROI 2,[ASCIZ /<SUBSYS>LOADER.SAV/]

; 1,2 ARE SET FOR GTJFN

ASJFN:	PUSH P,2
	PUSH P,1
	MOVE 1,FORK
	GEVEC		;MAYBE NULL
	POP P,1
	EXCH 2,0(P)	;SAVE OLD EV
	CALL GETFIL	;LOAD FILE
	CALL SYMVEC	;GET SYMS, ENT. VEC TO R
LODDN1:	SKIPE 0(P)	;USE OLD EV IF ANY
	 JRST LODDN3
	MOVEM R,0(P)
	MOVEI 2,0(R)
	TLO 2,(1B5)	;USERMODE
	MOVEM 2,PC
	MOVEM 2,REALPC

LODDN3:	POP P,2
	MOVE 1,FORK
	SEVEC
	TRNE F,TEMF	;ARE WE SUPPOSED TO RUN IT?
	 JRST DDT	;NO
	CALL CRF
	JRST TOUSER

; ;O -- OBTAIN SYMBOL FILE
OBTAIN:
YNKSYM:	MOVE W1,[POINT 7,[ASCIZ /BTAIN SYMBOL FILE: /]]
	CALL TYPE
	CALL FLSSYM	;FLUSH PAGES CONTAINING PREVIOUS SYMS
	HRROI 1,[ASCIZ /SYMBOLS/]
	MOVEM 1,DEFALT+5
	MOVSI 1,(1B2)
	MOVEM 1,DEFALT
	MOVEI 1,DEFALT
	MOVEI 2,0
	CALL GETJFN
	 JRST SYMSO4	;NO SYMBOLS??
	MOVEM 1,TEM1
	MOVE 2,[44B5!1B19]
	OPENF
	 JRST SYMSO3

YNKSY1:	BIN
	JUMPGE 2,YNKSY9		;NO DEFINED TAB
	HLRE 3,2		;THE NEGATIVE LENGTH

YNKSY2:	MOVEI T,HOME
	ADD T,3			;LOWEST ADDR OF DEF SYMTAB
	HRL T,3			;MAKE AOBJN PTR
	MOVEM T,SYMPTR		;THAT'S THE SYMTAB PTR
	MOVSI 2,(POINT 36,0)
	HRR 2,T			;36-BIT POINTER
	SIN

YNKSY3:	BIN			;UNDEF TAB IOWD
	JUMPGE 2,YNKSY8		;NO UNDEFINED TABLE
	HLRE 3,2		;GET NEG. LENGTH
	MOVE T,SYMPTR		;PUT UNDER DEFINED TAB
	ADD T,3			;BASE OF UNDEF TAB
	HRL T,3			;MAKE AOBJN PTR
	MOVEM T,ESTU		;THAT'S THE UNDEF. PTR
	MOVSI 2,(POINT 36,0)
	HRR 2,T
	SIN

YNKSY4:	MOVE 1,TEM1
	CLOSF
	 JRST ERR
	JRST DD1

YNKSY8:	SETZM ESTU	;SAY NO UNDEF SYMTAB
	JRST YNKSY4	;GO CLOSE FILE

YNKSY9:	MOVE T,[-2,,HOME-2]	;DUMMY UP A GOOD PTR
	MOVEM T,SYMPTR
	JRST YNKSY3	;LOOK FOR UNDEF. SYMTAB

;GET FILE, SYMBOLS, AND ENTRY VECTOR (IF ANY)
;1,2 ARE SETUP FOR GTJFN
GETFIL:	CALL UNMAP		;FLUSH PAGE IN WINDOW
	CALL GETJFN
	 JRST ERR
	HRRZM 1,JFN
	HRL 1,FORK
	GET
	RET


;DO A GTJFN, ALLOWING THE CURRENT ESCAPE CHARACTER
;TO BE TYPED IN.
GETJFN:	PUSH P,1
	MOVE 1,ESCCOD
	DTI			;ALLOW IT TO BE TYPED IN
	POP P,1
	GTJFN
	 JRST GETJF7		;SEE IF TERMINATOR WAS ESCAPE CHARACTER

GETJF5:	PUSH P,1
	HRLZ 1,ESCCOD
	ATI
	POP P,1
	JRST CPOPJ1		;SAY OK TO CALLER

GETJF7:	CAIE 1,GJFX4		;ILLEGAL CHR IS REASON FOR LOSAGE?
	 JRST GETJF8		;NO
	HLRZ 1,2		;GET INPUT JFN
	SKIPN 1
	HLRZ 1,DEFALT+1
	CAIN 1,100
	BKJFN
	 JRST GETJF8		;NOT TTY: OR BKJFN BAD
	BIN			;GET PREVIOUS CHR
	CAMN 2,ESCCHR		;IS IT THE ESCAPE CHR?
	 JRST WRONG		;YES (ATI WILL HAPPEN IN MAIN LOOP)

GETJF8:	HRLZ 1,ESCCOD
	ATI
	RET			;NO SKIP


;GET A NEW FORK
NEWFRK:	SETZ 1,
	CFORK
	 JRST ERR
	MOVEM 1,FORK
	FFORK			;IDDT DEALS ONLY WITH FROZEN FORKS
	MOVEI 1,400000		;IDDT
	RPCAP
	SETZ 3,			;PASS CAP'S BUT NOT ENABLED
	MOVE 1,FORK
	EPCAP
	MOVNI 1,5
	RUNTM
	MOVEM 1,TIMUSD
	MOVEM 3,TIMCON
	RET


KILFRK:	CALL UNMAP		;FLUSH ANY MAPPED PAGE
	MOVE 1,FORK
	KFORK
	SETZM FORK
	SETZM USRPSI
	SETZM USRPSI+1
	SETZM USRPSI+2
	SETZM USRPSI+3
	SETZM BPTFLG
	SETZM SYMPTR
	SETZM ESTU
	SETZM PRGM
	SETZM BLOCK
	SETZM TBLK
	MOVE 1,['(PRIV)']
	MOVEM 1,SUBSYS
	MOVE TT,PCSTAK
	MOVEM TT,PCSPTR
	RET

;GET NEW SYMBOLS, ENTRY VECTOR
;FLUSH BREAKPOINTS, AND PAGES CONTAINING OLD SYMTAB FIRST.
SYMVEC:	CALL FLSBPT		;FLUSH BREAKPOINTS
	MOVE T,['(PRIV)']
	MOVEM T,SUBSYS
	CALL FLSSYM		;FLUSH OLD SYMBOLS

NEWSYM:	MOVEI R,116		;JOBSYM
GTSYMS:	CALL FETCH		;ENTRY FROM ;S
	 MOVE T,[-2,,HOME-2]	;JOBSYM READ-PROTECTED??
	JUMPE T,.-1
	MOVEM T,SYMPTR
	CAMN T,[-2,,HOME-2]
	JRST ENTVEC		;NO SYMS LOADED
	HRLZI R,0(T)
	TLZ R,777000
	SUB T,R
	ASH T,-11
	TRZ T,777000
	MOVE W1,T


;SHARE THE SYMBOL TABLE
SHRTAB:	HRR 1,W1	;PAGE
	HRL 1,FORK	;USER'S FORK
	RPACS
	TLNE 2,(1B10)	;PRIVATE ?
	JRST SHRTA2	;YES, COPY IT

;SHARE THE PAGE
	RMAP
	HRR 2,W1	;SAME PAGE
	HRLI 2,400000	;IDDT'S FORK
	MOVSI 3,(1B2!1B4!1B9)	;R,C,X
	PMAP
SHRTA0:	AOBJN W1,SHRTAB
SHRTA1:	JRST ENTVEC	;NOW HANDLE THE ENTRY VECTOR

;COPY PRIVATE PAGE FROM USER TO IDDT
SHRTA2:	HRRZ R,W1	;PAGE NUMBER
	LSH R,11	;FIRST ADDRESS
	CAIGE R,20
	MOVEI R,20	;DON'T COPY AC'S.
SHRTA3:	CALL FETCH	;READ FROM USER FORK
	 JRST ENTVEC	;READ PROTECTED??
	MOVEM T,0(R)	;INTO IDDT FORK
	MOVEI R,1(R)
	TRNE R,777	;HIT NEXT PAGE?
	JRST SHRTA3	;NO, COPY ANOTHER WORD
	JRST SHRTA0	;YES, WORRY ABOUT IT

;HANDLE ENTRY VECTOR
ENTVEC:	CALL CHKSYM
	MOVE 1,FORK
	GEVEC
	RET

; ;U  UNLOAD THE CURRENT CORE IMAGE
; OPPOSITE OF ;Y

UNLOAD:
UNGET:	MOVE W1,[POINT 7,[ASCIZ /NGET TO FILE: /]]
	CALL TYPE
	HRROI 1,[ASCIZ /SAV/]
	MOVEM 1,DEFALT+5
	MOVSI 1,(1B0!1B3)
	MOVEM 1,DEFALT+0	;FLAGS
	MOVEI 1,DEFALT
	MOVEI 2,0
	CALL GETJFN
	 JRST ERR
	MOVEM 1,TT1

UNGET0:	MOVE 1,FORK
	GEVEC
	JUMPN 2,UNGET2

UNGET1:	MOVE W1,[POINT 7,[ASCIZ /
START ADDRESS IS /]]
	CALL TYPE
	HRRZ T,LLOCO
	MOVE 1,FORK
	HRLI 2,1	;LEN 1
	HRR 2,T		;AT "."
	SEVEC
	CALL PAD

UNGET2:	HRR 1,TT1
	HRL 1,FORK
	MOVE 2,[-1000,,520000]
	SETZM 3
	SSAVE
	JRST DD1

; ;W -- WRITE OUT SYMBOL FILE

SYMSOT:	MOVE W1,[POINT 7,[ASCIZ /RITE SYMBOLS ON FILE: /]]
	CALL TYPE
	TRO F,TEMF!TEM2F	;SAY BOTH TABS EXIST
	SKIPGE R,SYMPTR
	CAMN R,[-2,,HOME-2]
	 TRZ F,TEMF		;NO MAIN SYMTAB
	SKIPL R,ESTU
	 TRZ F,TEM2F		;NO UNDEF TAB
	TRNN F,TEMF!TEM2F
	JRST SYMSO4		;NOTHING TO WRITE

SYMSO1:	HRROI 1,[ASCIZ /SYMBOLS/]
	MOVEM 1,DEFALT+5
	MOVSI 1,(1B0!1B4)
	MOVEM 1,DEFALT
	MOVEI 1,DEFALT
	MOVEI 2,0
	CALL GETJFN
	 JRST ERR
	MOVEM 1,TEM1
	MOVE 2,[44B5!1B20]
	OPENF
	 JRST SYMSO3

SYMSO2:	TRNE F,TEMF
	SKIPL T,SYMPTR
	 SETZM T
	CALL WRTSYM
	TRNE F,TEM2F
	SKIPL T,ESTU
	 SETZM T
	CALL WRTSYM
	MOVE 1,TEM1
	CLOSF
	 JFCL
	JRST DD1

SYMSO3:	MOVE 1,TEM1
	CLOSF
	 JFCL
	JRST ERR

SYMSO4:	MOVE W1,[POINT 7,[ASCIZ/	NO SYMBOLS??/]]
	CALL TYPE
	JRST ERR


WRTSYM:	PUSH P,3
	HLL 2,T			;GET NEG. LENGTH
	HRRI 2,-1(T)		;MAKE IOWD
	BOUT
	HRLI 2,004400		;POINT 36,.-.,-1
	HLRE 3,T		;NEG. LENGTH
	SKIPGE 3
	SOUT
	POP P,3
	RET

; ;E COMMAND -- CHANGE ESCAPE CHARACTER

ESCAP:	MOVE W1,[POINT 7,[ASCIZ /SCAPE CHR IS: /]]
	CALL TYPE
	MOVE 1,ESCCOD		;THE OLD ESCAPE CODE
	DTI
	MOVEI 1,400000		;IDDT
	RPCAP
	MOVE TT,3

	MOVNI 1,5		;SAY WHOLE JOB
	RTIW			;GET CURRENT TIW
	PUSH P,2
	TLNE TT,(1B0)		;SEE IF ^C CAP IS ENABLED
	SETZB 2,3
	STIW			;ALLOW EVERYTHING TO BE TYPED IN
ESCAP0:	TYI
	MOVE T,1
	MOVNI 1,5
	SETZM 3
	POP P,2
	STIW			;RESTORE THINGS AS THEY WERE
	PUSH P,T
	CAIN T,177		;RUBOUT?
	MOVEI T,^D28		;YES
	CAIN T,40		;SPACE
	MOVEI T,^D29
	CAILE T,^D29		;REST ARE ILLEGAL
	JRST ERR

ESCAP1:	PUSH P,T		;SAVE FOR LATER
	MOVNS T
	MOVSI W,(1B0)		;A SINGLE BIT
	ROT W,0(T)		;CONVERT TO MASK
	TDNN W,[1B0!17B10!1B13!3B29]	;DID TENEX ECHO PROPERLY?
	JRST ESCAP3		;YES
	MOVEI T,"^"
	CALL TOUT
	MOVE T,-1(P)		;THE CHARACTER
	TRC T,100		;MAKE INTO NON-CONTROL EQUIVALENT
	CALL TOUT

ESCAP3:	POP P,ESCCOD		;NEW ESCAPE CODE
	POP P,ESCCHR		;NEW ESCAPE CHARACTER

ESCAP4:	MOVE R,SAVCOC		;COC CODE FOR OLD ESCCHR
	DPB R,COCPTR		;POINTER INTO CCOC WORDS

ESCAP5:	MOVE TT,ESCCHR		;NEW ESCAPE CHARACTER
	IDIVI TT,^D18
	ASH TT1,1
	MOVNS TT1
	ADDI TT1,^D34		;NUMBER OF BITS LEFT IN WHICHEVER WORD
	ADD TT,[2B11+TTYCC2]	;TWO BIT BYTE POINTER
	DPB TT1,[POINT 6,TT,5]	;INSERT POSITION
	MOVEM TT,COCPTR
	LDB R,TT		;GET CURRENT SETTING
	MOVEM R,SAVCOC
	MOVEI R,0
	DPB R,TT		;TURNOFF ECHOING FOR THAT CHAR

ESCAP6:	MOVEI 1,101
	MOVE 2,TTYCC2
	MOVE 3,TTYCC3
	SFCOC
	HRLZ 1,ESCCOD
	ATI
	JRST DD1

;***ROUTINES BEYOND HERE EVALUATE THEIR ARGUMENT***
MULT:	TLOA F,PTF+MLF		;*
DIVD:	TLO F,DVF+PTF		;SINGLE QUOTE
	JRST L1

ASSEM:	JRST PLUS		;#
MINUS:	TLO F,MF
PLUS:	TLO F,PTF
	JRST LIS2

LPRN:	CAML P,[LPDL-4,,0]	;LEFT PARENTHESIS
	JRST ERR
	PUSH P,F		;RECURSE FOR OPEN PAREN
	PUSH P,WRD
	PUSH P,FRASE
	PUSH P,FRASE1
	AOS,PRNC
	JRST LIS

INDIRE:	HRLZI W,20		;@
	IORB W,WRD
	TLO F,QF
	JRST LIS2

ACCF:	MOVE R,T		;COMMA PROCESSOR
ACCX:	XCT ACCCF		;MOVEI T,"A" AS IN A,,B
	TLOE F,COMF		;COMMA TYPED BEFORE?
	JRST ACCF1		;YES
	HRRM R,ACCCF		;NO, SAVE LEFT HALF OF A,,B
	HLLZ T,R
	LDB W1,[POINT 3,WRD,2]	;CHECK FOR IO INSTRUCTION
	IDIVI W1,7
	LSH R,27(W1)
	ADD T,R
	ADDB T,WRD
	JRST SPAC1

ACCF1:	ADD T,WRD		;SET LEFT HALF OF A,,B
	HRLZM T,WRD
	JRST SPAC1

SPACE:	TLNE F,QF
SPAC1:	TLO F,TIF
	TLZ F,MF+PTF
	JRST LIS1

RPRN:	TLNN F,QF		;)
	MOVEI T,0
	MOVS T,T
	SOSGE,PRNC
	JRST ERR
	POP P,FRASE1
	POP P,FRASE
	POP P,WRD
	POP P,F
	TLNE F,PTF
	TLNE F,SF
	JRST RPRN1
	MOVEM T,SYL
	TLO F,QF+SF
	JRST L1RPR
RPRN1:	ADDB T,WRD
	TLO F,QF
	JRST L1A

; ;S --  SNARF SYMBOLS
;ARGUMENT IS ADDRESS CONTAINING POINTER TO TABLE
;ARG IS TAKEN AS 116 IF NOT SUPPLIED

SNARF:	TLNN F,QF		;ARG?
	MOVEI T,116		;NO, DEFAULT
	MOVE R,T
	PUSH P,R
	CALL FETCH
	 JRST ERR		;READ PROTECTED
	JUMPGE T,ERR		;BAD PTR
	TLNE T,1		;MUST BE AN EVEN NUMBER LONG
	JRST ERR
	CALL FLSSYM		;FLUSH OLD SYMBOL TABLE
	POP P,R
	CALL GTSYMS		;GET AND CHECK NEW TABLE
	JRST DDT

;  ;?  TYPE THE MOST RECENT ERROR STRING
; NUM;?  TYPE VALUE OF NUM AS ERSTR

SEM.QU:	PUSH P,T
	CALL CRF
	POP P,T
	HRROI 1,STRBUF		;DUMP INTO STRING BUFFER FOR OUTPUT
	SETO 2,
	TLNE F,QF
	 MOVEI 2,0(T)
	HRL 2,FORK
	SETZ 3,
	ERSTR
	 JRST ERR
	 JRST ERR
	SETZ 2,
	IDPB 2,1		;MAKE ASCIZ
	MOVE W1,[POINT 7,STRBUF]
	CALL TYPE		;COMMON OUTPUT ROUTINE
	JRST DD1		;SO "OUTPUT TO FILE" WILL WORK

;REGISTER EXAMINATION LOGIC

;LLOCO  HAS CURRENTLY OPEN REGISTER. SET FROM C(LLOC) BY / ETC.
;LLOC   HAS CURRENT SEQUENCE. RESTORED FROM SAVLOC BY $LF ETC.
;SAVLOC HAS SAVED SEQUENCE. SET FROM LLOC BY TAB ETC.


;PRINT ADDRESS AND EXAMINE REGISTER
;ENTER HERE FROM TAB, ^, BS, LF, OR FROM $E, $N, OR $W
LI1:	MOVEM T,LLOC		;MAY HAVE DDTINT FLAG ON IN LEFT HALF
	MOVEM T,LLOCO
	INTON
	CALL PAD
	MOVEI T,"/"
	CAME SCH,SCHM		; TEMP MODE SAME AS PERM MODE?
	JRST LI3
LI4:	TLNE F,STF
	MOVEI T,"!"
	CALL TOUT

;ENTER HERE FROM /, [, ], !, \
;ADDRESS HAS BEEN PRINTED, EXAMINE CONTENTS
LI2:	TLZ F,ROF		;CLOSE REGISTER(IN CASE OF SEARCHES ETC)
	CALL LCT
	MOVE R,LLOCO
	CALL FETCH
	 JRST LINCR
	TLO F,ROF		;REGISTER IS NOW OPEN
	TLNE F,STF		;IN SUPPRESSED TYPE-OUT MODE?
	JRST DD2		;YES
	JRST CONSYM		;GO PRINT IN PROPER MODE AND RET


LI3:	CAIN SCH,FTOC		; NO, IF CONSTANT MODE
	MOVEI T,"["		; USE [
	CAIN SCH,PIN		; IF SYMBOLIC MODE
	MOVEI T,"]"		; USE ]
	JRST LI4

LINCR:	TLO F,ROF		;PAGE NOT ASSIGNED, PRETEND WAS OPENED
	MOVEI W1,"?"		;BUT TYPE OUT ?
	JRST TEXT		;RETURN IS A POPJ

;LINEFEED COMMAND
LINEF:	CALL DEPRA		;NEXT REGISTER
	CALL CRNRB		;HE TYPE THE LINEFEED, JUST NEED CAR RET
	AOS T,LLOC		;MOVE  . TO NEXT LOCATION
	JRST VARRW1

; ^ AND BACKSPACE COMMANDS
VARRW:	CALL DEPRA
	CALL CRF
	SOS T,LLOC		;MOVE . BACK TO PREVIOUS LOCATION
VARRW1:	TLNE F,CF		;$LF OR $^ OR $BS?
	 CALL PATEND		;LEAVE PATCH MODE
	INTON
	JRST LI1		;DO THE EXAMINE

;RETURN COMMAND
CARR:	CALL DEPRA		;CLOSE THE REGISTER
	TLNE F,CF		;$CR  CHANGES SEQUENCE
	 CALL PATEND		;TERMINATE PATCH, IN IN ONE
	JRST DD1.5

; [ COMMAND -- OPEN AS A CONSTANT
OCON:	TLNE F,QF		; QUANTITY TYPED?
	MOVEI SCH,FTOC		; YES SET TEMPORARY MODE
	TRO F,LF1+CF1		;OPEN AS CONSTANT
	JRST SLASH

; ] COMMAND -- OPEN SYMBOLICALLY
OSYM:	TLNE F,QF
	MOVEI SCH,PIN
	TRZ F,CF1		;OPEN SYMBOLICALLY
	TROA F,LF1

; !  COMMAND -- LIKE / BUT DOESN'T TYPE CONTENTS
SUPTYO:	TLOA F,STF		;SUPPRESS TYPEOUT

; / COMMAND
SLASH:	TLZ F,STF		;TYPE OUT REGISTER
	TLNN F,QF		;WAS ANY QUANTITY TYPED?
	JRST SLAS2		;NO. DO NOT CHANGE MAIN SEQUENCE
	TRNE F,INTFLG		;ARG IS WITHIN IDDT?
	TLOA T,(DDTINT)		;YES
	TLZ T,777777		;NO
	MOVEM T,LLOC		;VALUE OF "."
	TRNN F,PAF!PBF		;PATCH MODE?
	JRST SLAS1		;NO
	 CAMG T,PATPNT		;MAKING "." GO AFTER PATCH
	 CAMGE T,XRG		;OR BEFORE BEG OF PATCH
	  CALL PATEND		;MEANS TERMINATE THIS PATCH
SLAS1:	MOVEM T,LLOCO		;TEMP VALUE OF "."
	JRST LI2
SLAS2:	HRRZ T,LWT
	JRST SLAS1

; \ COMMAND -- LIKE / OR ! BUT DOESN'T CHANGE "."
ICON:	TLNN F,ROF		;REGISTER OPENED?
	JRST SUPTYO		;NO. MAKE LIKE !
	CALL DEPRS
	JRST SLAS2

;TAB -- SET LOC TO ADDRESS PART AND DO A / OPERATION
TAB:	MOVE R,LLOC		;CURRENT SEQUENCE
	HRRZM R,TEM		;IN CASE WE ARE IN PATCH MODE
	CALL DEPRS		;OPEN REGISTER OF Q
	CALL CRF
	MOVE T,LLOC		;SET UP NEW SEQUENCE AND
	MOVEM T,SAVLOC		;SAVE OLD SEQUENCE
	HRRZ T,LWT		;NEW VALUE FOR .
	TRNE F,PAF!PBF		;PATCH MODE?
	CALL PATEND		;YES, LEAVE IT
	JRST LI1

;  ;P -- PATCH BEFORE
; ;;P -- PATCH AFTER

;IF A REGISTER IS OPEN, ANY ARG TO ;P OR ;;P WILL BE TAKEN
; AS A REPLACEMENT VALUE AS IT WOULD BE FOR A TAB OR LINEFEED.

;IF THERE IS NO OPEN REGISTER, ANY ARG WILL BE TAKEN AS THE ADDRESS
; OF WHERE THE PATCH IS TO BE MADE.  NO ARG AT ALL MEANS .;P OR .;;P

PATCH:	MOVSI TT,(DDTINT)
	TDNN TT,LLOC		;TRYING TO PATCH INSIDE IDDT?
	TRNE F,PAF!PBF
	 JRST ERR		;ALREADY IN PATCH MODE
	TRNE F,SEMIF2		;SEE HOW MANY SEMICOLI THERE WERE
PATCHA:	TROA F,PAF		;  ;;P
PATCHB:	TRO F,PBF		;   ;P
	TLNN F,ROF		;ANY REG OPEN?
	JRST PATCH0		;NO
	 CALL DEPRA		;YES, STORE IF NEEDED
	 TLZ F,QF		;SAY WRD IS EMPTY
PATCH0:	CALL CRF
	MOVE R,WRD
	TLNN R,QF		;USE WRD IF ONE WAS TYPED IN
	MOVE R,LLOC		;USE "." OTHERWISE
	HRRZM R,PATLOC		;WHERE WE ARE INSERTING THE PATCH
	HRRZM R,SAVLOC		;SO A $LF WILL GET US BACK
	HRRZ R,XRG		;WHERE PATCH WILL BE LOCATED
	MOVEI R,-1(R)
	HRRZM R,PATPNT		;LAST FILLED LOCATION IN PATCH

PATCH1:	TRNE F,PAF		;PATCHING AFTER?
	 CALL CPYPIN		;COPY THE PATCH INSTR TO $X LOC
	HRRZ T,PATPNT
	MOVEI T,1(T)
	TLO F,STF		;SUPPRESSED TYPE-OUT MODE
	JRST LI1		;GO EXAMINE $X AND RET TO MAIN LOOP


;ANY SEQUENCE CHANGE REGISTER EXAMINATION COMMAND LIKE TAB OR $LF, BUT
; NOT LIKE LF OR BS, CALLS THIS TO TERMINATE THE PATCH.
; LLOC ETC HAVE ALREADY BEEN CHANGED TO NEW VALUES.
; PATPNT HAS THE LAST REGISTER IN THE PATCH, PATLOC HAS THE
; REGISTER BEING PATCHED

PATEND:	TRNN F,PAF!PBF		;ARE WE IN PATCH MODE?
	RET			;NO
	PUSH P,T
	MOVEI T,7
	CALL TOUT		;DING TO SIGNAL END OF PATCH
	TRNE F,PBF		;PATCHING BEFORE THE INSTR?
	 CALL CPYPIN		;COPY THE PATCH INSTR TO THERE
PATEN1:	HRRZ R,PATLOC
	HRRZ T,XRG
	HRLI T,(JRST)
	CALL DEP		;PLANT JRST TO PATCH
	 JRST ERR		;TELL HIM SOMETHING IS WRONG

PATEN2:	MOVEI W,3		;3 RETURN JRST'S IF PATCHING BEFORE
	TRNN F,PBF
	MOVEI W,1		;ELSE 1
PATEN3:	AOS R,PATPNT		;WHERE JRST BACK WILL GO
	AOS T,PATLOC		;WHERE IT SHOULD POINT
	HRLI T,(JRST)
	CALL DEP
	 JRST ERR
	SOJG W,PATEN3

PATEN4:	AOS R,PATPNT
	HRRZM R,XRG		;MOVE $X TO END OF PATCH
	POP P,T
	TRZ F,PAF!PBF		;LEAVE PATCH MODE
	TLZ F,STF		;AND SUPPRESSED TYPEOUT MODE
	RET



;COPY THE INSTRUCTION BEING PATCHED FROM PATLOC TO PATPNT

CPYPIN:	HRRZ R,PATLOC
	CALL FETCH
	 JRST ERR
	AOS R,PATPNT
	CALL DEP
	 JRST ERR
	RET

;FLUSH ALL UDEFINED SYMBOL REFERNECES TO THIS REGISTER.

DEPRA:	HRRZ R,LLOC		;WHERE "." IS NOW
	HRRZM R,TEM		;IN CASE WE ARE IN PATCH MODE
	MOVE R,SAVLOC
	TLNE F,CF		;RESTORE OLD SEQUENCE IF $CR,$LF, OR
	EXCH R,LLOC		;IF $^ OR $BS WAS TYPED
	MOVEM R,SAVLOC		;SETUP "NEW" OLD SEQUENCE
	TLNE F,ROF		;IF REGISTER IS BEING CHANGED
	TLNN F,QF		;REMOVE ALL PREVIOUS UNDEFINED
	JRST DEPRS		;SYMBOL REFERENCES TO IT
	MOVE R,ESTU
	MOVEM W1,ESTU		;INCLUDE ALL #-D SYMS IN UNDEF TAB
DEPRA2:	JUMPGE R,DEPRS
	HRRZ W,1(R)
	CAMN W,LLOCO
	CALL REMUN
	ADD R,[2,,2]
	JRST DEPRA2


;IF SOMETHING TYPED AND A REGISTER IS OPEN
;UPDATE THE OPEN REGISTER AND LWT
DEPRS:	MOVEM T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE R,LLOCO		;QUAN TYPED IN REGIS EXAM
	TLZE F,ROF		;TEST AND CLOSE REGISTER
	TLNN F,QF
	RET
	CALL DEP		;STORE AWAY
	 JRST ERR		;CAN'T STORE
	MOVE R,TEM		;PATCH SEQUENCE
	MOVEM R,PATPNT		;SAY THIS IS END OF CURRENT PATCH
	RET


EQUAL:	TROA F,LF1+CF1		;=
PSYM:	TRZ F,CF1		;@
	TRO F,LF1
	CALL CONSYM
	JRST RETX

R50PNT:	LSH T,-36		;RADIX 50 SYMBOL PRINTER
	TRZ T,3
	CALL TOC
	CALL TSPC
	SETZM SVFB
	MOVEI W1,LWT		;SETUP FOR SPT
	JRST SPT

SIXBP:	MOVNI W2,6		;SIXBIT PRINTER
	MOVE W1,LWT
SIXBP1:	MOVEI T,0
	ROTC T,6
	ADDI T,40
	CALL TOUT
	AOJL W2,SIXBP1
	RET

;MODE CONTROL SWITCHES

TEXO:	MOVEI R,TEXTT-HLFW	;$T ASSUME 7 BIT ASCII
	MOVE T,WRD2
	CAIN T,6		;CHECK FOR $6T
	MOVEI R,SIXBP-HLFW	;SET MODE SWITCH FOR SIXBIT
	CAIN T,5		;CHECK FOR $5T
	MOVEI R,R50PNT-HLFW	;SET MODE SWITCH FOR RADIX 50
HWRDS:	ADDI R,HLFW-TFLOT	;H
SFLOT:	ADDI R,TFLOT-PIN	;F
SYMBOL:	ADDI R,PIN-FTOC		;S
CON:	ADDI R,FTOC		;C
	HRRZM R,SCH		;TEMPORARY MODE
	JRST BASE1

RELA:	TRZE F,Q2F		;CHANGE ADDRESS MODE TO RELATIVE
	JRST BASECH
	MOVEI R,PADSO-TOC
ABSA:	ADDI R,TOC		;A
	HRRZM R,AR
	JRST BASE1

;VARIOUS  R  COMMANDS
BASECH:	MOVE T,WRD2		;$NR, CHANGE OUTPUT RADIX TO N
	CAIGE T,2
	JRST ERR
	HRRZM T,ODF		;TEMPORARY RADIX CELL
BASE1:	MOVS S,[SCHM,,SCH]	;MODE SWITCHES TO MEMORY
	TLNN F,CCF
	JRST LIS1
	BLT S,ODFM		;WITH $$, MAKE MODES PERMANENT
	JRST RETX


; SEMICOLON-SPACE COMMAND -- RETYPE ACCORDING TO CURRENT MODES

SEMSPA:	MOVEM T,LWT
	JRST @SCH

;VARIOUS "GO" COMMANDS
GO:	TRNE F,Q2F
	JRST GO1	;USE ENTRY VECTOR
	TLNE F,QF
	JRST GO5	;ARG TYPED IN
	TLNE F,CCF
	JRST GO0	;$$G MEANS $$0G
	MOVEI T,PC
	JRST QUANIN	;EXAMINE $G REGISTER

GO0:	SETZM WRD2
GO1:	TLNE F,QF
	JRST ERR	;FOO$$3G  ??
	MOVE 1,FORK
	GEVEC
	HLRZ 1,2	;EV LENGTH
	JUMPE 1,ERR
	CAIL 1,10000	;SKIP IF TENEX EV (1 HAS LENGTH)
	SKIPN 1,WRD2	;10/50, ALLOW ONLY $$0G
	CAMGE 1,WRD2	;EV LENGTH > THAN REQUESTED INDEX?
	 JRST ERR
	ADD 2,WRD2
	HRRZ T,2	;ENTRY ADDR

GO3:	HLL T,PC	;FLAGS
	MOVEM T,PC	;NEW PC
	MOVE 2,T
	TLNN F,CCF
	JRST GO4

;ENTRY FROM $L ETC.
GO2:	MOVE 1,FORK
	CIS		;$$G COMMANDS CLEAR INTERRUPTS
	SETZM USRPSI
	SETZM USRPSI+1
	SETZM USRPSI+2
	SETZM USRPSI+3
GO4:	TLO 2,(1B5)	;INSIST ON USERMODE PC
	MOVEM 2,REALPC
	MOVE TT,PCSTAK
	MOVEM TT,PCSPTR	;NOT UNDER $X ETC ANY MORE
	TRZ F,XEQ!CONDX
	CALL CRF
	JRST TOUSER

GO5:	TRNN F,INTFLG	;DID ADDR CONTAIN AN INTERNAL SYMBOL?
	JRST GO3	;NO, DO THE $G
	JRST ERR	;ATTEMPT TO GO INSIDE IDDT

; $X COMMAND -- EXECUTE AN INSTRUCTION
; INSTRUCTION TO EXECUTE IS IN T

XEC:	MOVEM T,R
	MOVEI T,XRG	;IN CASE ITS A $X EXAMINE
	TLNN F,QF	;WAS <INSTR> TYPED?
	JRST QUANIN	;NO, EXAMINE $X REGISTER
	MOVE T,R
	CALL SETESI	;SET UP USER'S MEMORY
	TRO F,XEQ	;WE'RE IN A $X
	CALL CRF
	JRST TOUSER

;$X COMMAND COMPLETION
;PSEUDO BPT HIT
;TT HAS NUMBER OF SKIPS
XCOM:	MOVEI W1,"$"
	CALL TEXT
	SOJG TT,.-2
	CALL UNSET	;POP BACK TO PREVIOUS $X CONTEXT
	JRST DD1

;GO TO USER
;PC SAYS WHERE
;XEQ, CONDX BITS SAY WHY
;AND TELL WHERE TO RETURN IN IDDT

TOUSER:	CALL UNMAP	;FLUSH THE USER'S PAGE
	TRNN F,CONDX	;USER WILL RUN FOR DDT'S PURPOSES,
				; NOT HIS. THEREFORE, DON'T
	CALL INSRTB	;PUT BPT'S BACK IN
	MOVEI 1,100
	MOVE 2,SAVTTY
	SFMOD
	MOVE 2,SAVTT2
	MOVE 3,SAVTT3
	SFCOC
	MOVE 2,USRTB2
	MOVE 3,USRTB3
	MOVE 4,USRTB4
	STABS
	MOVE 1,SUBSYS
	SETNM		;RESTORE USER'S SUBSYSTEM NAME
	MOVE 1,FORK
	MOVEI 2,AC0
	SFACS		;GIVE BACK HIS AC'S
	SETOM 2
	DIC		;DEASSIGN ALL CHANNELS
	MOVE 2,USRPSI+1	;TURN ON ONES WHICH SHOULD BE ACTIVE
	AIC
	SKIPE USRPSI+3
	EIR		;INTERRUPTS ARE SUPPOSED TO BE ON
TOUSR6:	MOVE 1,FORK
	RFSTS		;GET PC
	MOVE 1,FORK
	CAMN 2,REALPC	;SAME AS IT WAS AT ENTRY?
	 JRST TOUSR8	;YES, RFORK TO RESUME
	MOVE 2,REALPC	;NO, SET IT TO WHAT IT SHOULD BE
	SFORK		;IT IS FROZEN
TOUSR8:	TRNN F,XEQ!CONDX
	MOVEI 1,-4	;ALL INFERIORS
	RFORK
	SETOM USRFLG	;WE'RE NOW IN THE USER.
	INTON
	MOVE 1,FORK
	WFORK
	JRST TRAP	;FORK TERMINATED

;BREAK POINT LOGIC


;HERE WHEN BPT HIT
;T POINTS AT PRIVATE BLOCK FOR THE BPT

;PRIVATE BLOCK FORMAT IS:
;WORD-0:	LH HAS TRACE EXP., RH HAS ADDR. WHERE BPT SET
;WORD-1:	0 OR CONDITIONAL BREAK SKIP INSTR.
;WORD-2:	PROCEED COUNT
;WORD-3:	0 OR STRING POINTER, FED TO DDT WHEN BPT HIT
;WORD-4:	SAVED INSTRUCTION WHILE USER IS RUNNING
;WORD-5:	0 OR ELSE -1 IF AUTO-PROCEED
;WORD-6:	ASCII NAME OF THIS BPT, LIKE $3B

BCOM:	MOVEM T,BPTFLG	;INDICATE WHICH BPT WE'RE AT

;ARE WE GOING TO BREAK?
BCOM1:	SKIPE W1,1(T)	;DOES A CONDITIONAL INSTR. EXIST?
	 CALL DOCNDX	;DO THE CONDITIONAL IN THE USER
	  SOSG TT,2(T)	;GUNCH THE PROCEED COUNT
	   JRST BREAK	;YES!

;DON'T BREAK, PROCEED
BCOM2:	MOVE T,4(T)	;THE BREAK INSTRUCTION
	JRST PROC1

;DO THE CONDITIONAL BREAK INSTRUCTION FOR THE USER

DOCNDX:	MOVE T,1(T)		;GET THE INSTRUCTION
	CALL SETESI
	TRO F,CONDX		;WHY WE'RE GOING TO USER
	JRST TOUSER

;RETURN FROM USER HERE
;TT HAS THE NUMBER OF SKIPS
CONCOM:	TRNN TT,1		;ONLY THE LOW BIT COUNTS
	AOS 0(P)		;MAKE DOCNDX SKIP
	CALL UNSET		;POP BACK TO PREVIOUS CONTEXT
	MOVE T,BPTFLG		;GET BACK WHICH BPT WE'RE AT
	RET


;WE'RE REALLY BREAKING
BREAK:	PUSH P,T		;POINTER TO BPT PRV BLK
	TDZ F,[-1,,-1-XEQ]	;CLEAR ALL FLAGS EXECPT XEQ
	MOVE W1,6(T)		;ASCII NAME OF BREAK POINT -- $3B
	CALL TEXT2		;PRINT IT
	MOVSI W1,(<ASCIZ />/>)	;TYPE > FOR COND BREAK
	SKIPG 2(T)		;TEST PROCEED COUNTER
	MOVSI W1,(<ASCIZ />>/>)	;TYPE >> FOR PROCEED COUNTER BREAK
	CALL TEXT2
	MOVE W1,LLOC		;SAVE CURRENT SEQUENCE
	MOVEM W1,SAVLOC
	HRRZ T,PC
	HRRZM T,LLOC		;SET CURRENT SEQ TO BREAK ADR
	CALL PAD		;TYPE PC AT BREAK
	HLRZ T,@0(P)		;GET TRACE LOCATION
	JUMPE T,BREAK1		;TEST FOR REGISTER TO EXAMINE
	CALL LCT		;PRINT TAB
	HLRZ T,@0(P)
	CALL LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:	POP P,T			;GET BPT BLK PTR BACK
	SKIPN 5(T)		;SKIP IF AUTO
	JRST RETB		;DONT PROCEED
BREAK2:	MOVEI TT,2		;1 FOR SOS AT BCOM1, 1 FOR
	ADDB TT,2(T)		;PROCEEDING
	JUMPGE TT,BREAK3	;NOT AUTOPROCEEDING ANYMORE
	 CALL CRF
	 JRST PROC0		;DO THE PROCEED
BREAK3:	SETZM 5(T)		;CLEAR AUTO PROCEED

;START UP DDT, T POINTS AT BPT BLK
RETB:	SKIPE T,3(T)		;IS THERE A COMMAND STRING?
	HRLI T,(<POINT 7,0>)
	MOVEM T,STRING
	JRST RETX

;<NUM>$P -- PROCEED THROUGH THIS BPT NUM TIMES
;<NUM> IN T (IF ANY TYPED IN)
PROCED:	MOVE TT,T	;SO T CAN POINT TO BPT BLK
	CALL CRF
	SKIPN T,BPTFLG	;PROCEEDING FROM BPT?
	JRST TOUSER	;NO. JUST RUN HIM AT HIS PC.
	TLNE F,QF	;WAS AN ARG TYPED IN?
	JRST PROCD3	; YES, USE IT.
	MOVEI TT,1	; NO, ASSUME 1
	TLNE F,CCF	;IF $$P
	MOVSI TT,200000	;THEN VERY LARGE COUNT
PROCD3:	TLNE F,CCF	;IF AUTOPROC
	MOVNS TT		;NEGATE
	MOVEM TT,2(T)	;STORE COUNT FOR THIS BREAK IN $<N>B+1
	SETZM 5(T)	;ASSUME NOT AUTOPROCEED
	TLNE F,CCF
	SETOM 5(T)	;IT IS AUTOPROCEED

;ENTER HERE FROM AUTOPROCEED

;USER MAY HAVE CHANGED THE CONTENTS OF THE BREAK
;LOCATION BETWEEN THE TIME THE BPT WAS HIT AND THIS $P
PROC0:	HRRZ R,@BPTFLG	;ADDRESS OF LAST BPT HIT
	CALL FETCH	;GET INSTRUCTION TO PROCEED FROM
	 JRST ERR

;ENTER HERE FROM NON-BREAKING BPT HIT
PROC1:	MOVEM T,BINSTR		;INSTRUCTION TO LEAVE FROM
	RWM			;SEE IF RUBOUT INTERRUPT WAITING
	JUMPGE 1,PROC14		;NO, KEEP AUTOPROCEEDING
	INTON
	 WAIT			;LET IT RIP

PROC14:	MOVEI S,100	;MAX @ DEPTH ALLOWED FOR EA CALCULATION
	MOVEM S,TEM1
	LDB W1,[POINT 9,T,8]	;OPCODE.
	LDB W2,[POINT 4,T,12]	;GET AC FIELD
	CAIE W1,<XCT>/1B8
	CAIN W1,<PUSHJ>/1B8
	 JRST IXCT1		;CALCULATE EA AND INTERPRET
	CAIE W1,<JSR>/1B8
	CAIN W1,<JSA>/1B8
	 JRST IXCT1
	CAIN W1,<JSP>/1B8
	 JRST IXCT1
	TRNN W1,700
	JRST IUUO

;USE THE HARDWARE TO INTERPRET ALL ELSE.
;T HAS THE INSTRUCTION
PROC2:	HRRZ R,XRG	;LOCATION OF $X REGISTER
	CALL DEP
	 JRST ERR
	MOVEI S,3
	HRRZ T,PC	;WORK ON COPY IN CASE DEP FAILS
PROC3:	AOS T
	HRLI T,(JRST)
	AOS R
	CALL DEP
	 JRST ERR
	SOJG S,PROC3
	HLL R,PC	;FLAGS
	TLO R,(1B5)	;BE SURE IT'S USERMODE
	HRR R,XRG
	MOVEM R,REALPC	;WHAT FORK'S PC SHOULD BE
	JRST TOUSER

;THESE ROUTINES INTERPRET PC SAVING INSTRUCTIONS.

;R POINTS TO THE INSTRUCTION
;T,BINSTR HAVE THE INSTRUCTION
;W1 HAS THE OP CODE
;W2 HAS AC FIELD

;INTERPRET UUO
IUUO:	JUMPE T,PROC2		;ILLEGAL INSTRUCTION
	CAIL W1,40
	JRST PROC2		;DEC 10/50 UUO, USE HARDWARE.
	MOVEI R,40
	CALL DEP
	 JRST ERR
	MOVEI R,41		;NOW EXECUTE LOCATION 41.


;INTERPRET XCT
IXCT:	SOSL TEM1		;TOO MUCH @'ING?
	CALL FETCH		;CODE PROTECTED?
	 JRST ERR		;YES.
	MOVEM T,BINSTR


;GET EFFECTIVE ADDRESS
IXCT1:	MOVE T,BINSTR		;THE INSTRUCTION
IXCT2:	LDB W1,[POINT 4,T,17]	;GET INDEX FIELD
	CAIE W1,0		;USE 0 IF XR=0
	MOVE W1,AC0(W1)		;HIS XR
	ADD W1,T		;ADD IT IN
	TLNN T,(@)		;INDIRECT?
	JRST IXCT3		;NO, WE'RE DONE
	HRRZ R,W1
	SOSL TEM1		;TOO MUCH @'ING?
	CALL FETCH
	 JRST ERR
	JRST IXCT2

;CHECK XCT'D OR UUO'D INSTRUCTION TO SEE IF IT MUST BE INTERPRETED.
IXCT3:	HRRZS W1
	DPB W1,[POINT 23,BINSTR,35]	;SMASH WITH EA
	LDB W2,[POINT 4,BINSTR,12]	;AC FIELD
	LDB W1,[POINT 9,BINSTR,8]	;GET OP. CODE
	CAIN W1,<PUSHJ>/1B8
	 JRST IPUSHJ
	CAIN W1,<JSR>/1B8
	 JRST IJSR
	CAIN W1,<JSA>/1B8
	 JRST IJSA
	CAIN W1,<JSP>/1B8
	 JRST IJSP
	MOVE R,BINSTR
	CAIN W1,<XCT>/1B8
	 JRST IXCT
	TLNN T,700
	JRST IUUO		;ANOTHER ONE.  TEM1 WILL RUN OUT.
	JRST PROC2		;OK, USE HARDWARE

;INTERPRET PUSHJ
IPUSHJ:	MOVE T,AC0(W2)		;USER'S PUSH POINTER
	AOBJP T,IPJ3		;PDL OVF FOR HIM
IPJ1:	MOVEM T,AC0(W2)
	HRRZM T,R
	AOS T,PC
	CALL DEP		;DO PUSH FOR HIM
	 JRST ERR		;PROTECTED
	HRRZ R,BINSTR		;EA OF PUSHJ
IPJ2:	HLL R,PC		;HIS NEW PC
	TLO R,(1B5)		;MUST BE USERMODE
	MOVEM R,REALPC		;TOUSER WILL DO SFORK
	JRST TOUSER

IPJ3:	MOVE 1,FORK
	MOVSI 2,(1B9)
	IIC			;GOOSE USER'S CHN, LET HIM TRAP IT
	JRST IPJ1		;DOES INT HAPPEN BEFORE PUSHJ????

;INTERPRET JSA
IJSA:	AOS T,PC
	HRL T,BINSTR		;FORM  EA.RET
	EXCH T,AC0(W2)
	JRST IJSR2

;INTERPRET JSR
IJSR:	AOS T,PC
IJSR2:	HRRZ R,BINSTR
	CALL DEP
	 JRST ERR
	AOSA R,BINSTR
IJSR3:	MOVE R,BINSTR
IJSR4:	JRST IPJ2

;INTERPRET JSP
IJSP:	AOS W,PC
	MOVEM W,AC0(W2)
	JRST IJSR3

;INSERT BREAKPOINTS

INSRTB:	MOVEI W1,BPTS
INSRT1:	HRRZ R,0(W1)
	JUMPE R,INSRT3		;NOT IN USE
	CALL FETCH		;GET THE USER'S INSTRUCTION
	 JRST INSRT3		;MOVE TO NEXT BPT
	MOVEM T,4(W1)
	MOVE T,[BPT]
	CALL DEP		;STUFF IT INTO THE USER
	 JFCL			;WRITE PROTECTED
INSRT3:	ADDI W1,NBPTV		;MOVE TO NEXT BPT
	CAIE W1,<BPTS+<NBP*NBPTV>>
	JRST INSRT1
	RET

;REMOVE BREAKPOINTS

REMOVB:	MOVEI W1,<BPTS+<NBP*NBPTV>-NBPTV>	;ADDR OF LAST BPT
REMOV1:	MOVE T,4(W1)	;SAVED INSTRUCTION
	HRRZ R,0(W1)
	SKIPE R			;IF NOT IN USE
	CALL DEP
	 JFCL 0			;READ ONLY PAGE
	SUBI W1,NBPTV		;MOVE TO NEXT BPT
	CAIL W1,BPTS		;DONE ALL?
	JRST REMOV1		;NO
	RET

;ALL $B COMMANDS OF FORM <A>$<N>B

;A$NB  A$B  $NB  $B

BPS:	TLZE F,QF
	JRST BPS1	;A$NB OR A$B
	TRZE F,Q2F
	JRST BPS2	;$NB

;$B -- DELETE BREAK POINTS
	CALL FLSBPT
	JRST RETX

;A$NB  OR  A$B
BPS1:	TRZN F,Q2F
	JRST BPS3	;A$B
	MOVE R,T
	TRO F,TEMF

;PROCESS THE $NB
BPS2:	MOVE T,WRD2
	CAIL T,1
	CAILE T,NBP
	JRST ERR	;NO SUCH BPT NUMBER
	IMULI T,NBPTV
	ADDI T,BPTS-NBPTV
	TRZN F,TEMF
	JRST QUANIN	;$NB  EXAMINE
	JRST BPS5

;SEARCH FOR A FREE BPT TO USE
BPS3:	MOVE R,T	;ADDR TO R
	MOVEI T,BPTS	;PROCESS THE A$B
BPS4:	HRRZ W,(T)	;WHERE BPT IS TO BE PUT
	CAIE W,(R)	;IS THIS BPT ALREADY THERE?
	SKIPN (T)	;IS THIS BPT NOT IN USE?
	JRST BPS5	;YES, USE THIS BPT
	ADDI T,NBPTV	;NO, TRY NEXT
	CAIE T,<BPTS+<NBP*NBPTV>>
	JRST BPS4
	JRST ERR	;NONE AVAILABLE

;USE THE BREAKPOINT POINTED TO BY T
;ADDR AT WHICH TO SET IT IN R
BPS5:	HRRZ W,0(T)	;WHERE THIS BPT IS PLACED
	CAMN T,BPTFLG	;CHANGING BPT JUST HIT?
	CAIN W,0(R)	;TO A DIFFENERT PLACE?
	CAIA		;NO
	 CALL GOODPC	;YES. DON'T PROCEED FROM OLD ONE.
	MOVEM R,0(T)	;INSERT LOCATION
	SETZM 1(T)
	SETZM 2(T)
	SETZM 3(T)
	SETZM 5(T)	;ASSUME NOT AUTOPROCEED
	TLNN F,CCF
	 JRST RETX
	SETOM 5(T)	;IT IS AN AUTOPROCEED
	MOVSI R,600000	;A MODERATLY NEGATIVE INFINITY/2
	MOVEM R,2(T)	;FOR PROCEED COUNT
	JRST RETX

;FLUSH ALL BREAKPOINTS
FLSBPT:	MOVEI T,BPTS		;ADDRESS OF 1ST BPT BLK
	SETZM 0(T)		;DELETE THE BPT. 0-->ADDR
	ADDI T,NBPTV		;MOVE TO NEXT
	CAIE T,<BPTS+<NBP*NBPTV>>
	JRST .-3		;DO ANOTHER


;MAKE PC GOOD FOR $P
GOODPC:	SETZM BPTFLG	;NO LONGER AT A BPT
SETPC:	PUSH P,2
	MOVSI 2,(1B5)
	IORB 2,PC
	MOVEM 2,REALPC
	POP P,2
	RET

;UNPROTECT PAGES IN USER'S FORK
;A<B$NU		;GIVES PROTECTION N TO PAGES A THRU B
;A$NU		;GIVES PROTECTION M TO PAGE A
;$NU		;GIVES PROTECTION N TO THE CURRENT PAGE
;4-BIT OF N MEANS READ ACCESS
;2-BIT OF N MEANS WRITE ACCESS
;1-BIT OF N MEANS EXECUTE ACCESS
;N ASSUMED TO BE 7 IF NOT SPECIFIED

UNPRO:	TLNE F,CCF
	JRST ERR
	MOVE TT,WRD2	;NUMBER TO RIGHT OF $
	TRNN F,Q2F	;IF NOT GIVEN,
	MOVEI TT,7	; ASSUME RWX
	JUMPL TT,ERR
	CAILE TT,7
	JRST ERR
	ROT TT,-5	;STANDARD POSTION
	TLNE TT,(1B3)	;ASKING FOR WRITE ACCESS?
	TLO TT,(1B9)	;YES, GIVE WRITE COPY IF CAN'T GET WRITE
UNPRO1:	TLNE F,QF	;NUMBER TO LEFT OF $ ?
	JRST UNPRO2	; YES.
	MOVE T,LLOC	;.
	TLNE T,(DDTINT)
	 JRST ERR	;NICE TRY, RAY.
	LSH T,-11	;MAKE INTO PAGE NUMBER
UNPRO2:	TLNN F,FAF	; <  SEEN?
	MOVEM T,DEFV	;NO, MAKE FIRST AND LAST PAGES THE SAME
	CAIG T,777
	CAMGE T,DEFV
	JRST ERR	;TOO BIG, OR WRONG ORDER
	SKIPA 1,DEFV
UNPRO3:	AOS 1,DEFV
	CAMG 1,T
	JRST .+3
	CALL UNMAP	;FORCE CHKADR TO RE-READ ACCESS
	JRST DD1	;DONE
	HRL 1,FORK
	RPACS
	TLNN 2,(1B5)	;EXISTS?
	JRST UNPRO3
	MOVE 2,TT	;NEW ACCESS
	SPACS
	JRST UNPRO3

;DEPOSIT INTO MEMORY SUBROUTINE
;R HAS ADDRESS, T HAS VALUE
;LH OF R INDICATES IF IT IS INTERNAL TO DDT -- LIKE $3B, ETC.

DEP:	TLNE R,(DDTINT)
	JRST DEPINT		;DEPOSIT IN INTERNAL REGISTER
	TRNN R,777760
	JRST DEPAC		;DEPOSIT IN AC
	PUSH P,R		;SAVED FOR REST OF DDT
	CALL UNMAP
	JSP TT1,CHKADR		;CHECK ADDRESS, MAP INTO UCORE
	JUMPE TT,DEP2		;IF NO PAGE, OK TO STORE
	TLNE TT,(1B3+1B9)	;STORE OK IF WRITE OR WRITE-COPY
	JRST DEP2
	POP P,R
	RET
DEP2:	MOVEM T,UCORE(R)
	POP P,R			;USER'S ADDRESS
	JRST CPOPJ1		;SKIP RETURN

DEPAC:	MOVEM T,AC0(R)		;DEPOSIT IN AC
	JRST CPOPJ1		;SKIP RETURN

DEPINT:	MOVEI TT,PC
	CAIE TT,0(R)
	JRST DEPIN4		;NOT CHANGING PC

DEPIN1:	HRRZ TT,PC		;GET ADDRESS PART
	CAIE TT,0(T)		;CHANGING TO SOMETHING DIFFERENT?
	SETZM BPTFLG		;YES, DONT RESUME AT CURRENT BREAKPT.
	CAIE TT,0(T)
	JRST DEPIN3		;TURN ON USERMODE, TO GET SFORK

DEPIN2:	MOVSI TT,(1B5)
	TDNE TT,PC		;COPY USERMODE BIT FROM OLD PC WORD
DEPIN3:	TLO T,(1B5)
	MOVEM T,REALPC
	JRST DEPIN5

DEPIN4:	MOVEI TT,USRPSI		;SEE IF TRYING TO CHANGE REQUESTS.
	CAIN TT,0(R)
	RET			;CAN'T DO THAT.

DEPIN5:	MOVEM T,0(R)		;STORE INTO INTERNAL REGISTER
	JRST CPOPJ1		;SKIP RETURN

;FETCH FROM MEMORY SUBROUTINE
;R HAS ADDRESS. LH INDICATES INTERNAL OR NOT

FETCH:	TLNE R,(DDTINT)
	JRST FETINT		;INTERNAL REGISTER READ
	TRNN R,777760		;IN AC?
	JRST FETAC		;YES
	PUSH P,R		;SAVE USER'S ADDR
	JSP TT1,CHKADR
	TLNE TT,(1B2)		;READ ACCESS?
	JRST .+3		;YES
	POP P,R
	RET
	MOVE T,UCORE(R)	
	POP P,R			;GET USER'S ADDR BACK
	JRST CPOPJ1		;SKIP RETURN ONLY FOR LEGAL ADDRESS

FETAC:	MOVE T,AC0(R)
	JRST CPOPJ1

FETINT:	MOVE T,0(R)		;FROM INTERNAL REGISTER IN DDT
	JRST CPOPJ1

;CHECK USER'S ADDRESS IN R (=2)
;BRING IT INTO UCORE IF NOT ALREADY THERE
CHKADR:	PUSH P,1
	PUSH P,3
	PUSH P,2
	MOVEI 1,0(R)	;DESIRED ADDRESS
	ANDI 1,777000	;DESIRED USER PAGE
	MOVE 2,LASTPG	;LAST PAGE CHECKED AND ACCESSED
	TLNE 2,(1B5)	;DOES NOT EXIST, OR
	CAIE 1,0(2)	;DIFFERENT PAGE?
	JRST CHKA2	;YES


;PAGE IS IN, GRONK R TO POINT INTO UCORE
CHKA1:	POP P,R
	ANDI R,777
	HLLZ TT,IDPACS	;TT IS WHERE ACCESS INFO IS RETURNED
	POP P,3
	POP P,1
	JRST 0(TT1)

;MAP USER'S PAGE INTO DDT'S UCORE
CHKA2:	HRRZ 1,LASTPG	;PREVIOUS PAGE
	LSH 1,-11
	HRL 1,FORK
	HLLZ 2,LASTPG	;ACTUAL ACCESS
	TLNE 2,(1B5)	;DONT SET ACCESS IF IT DIDN'T EXIST
	SPACS		;READY TO BE MAPPED OUT

CHKA3:	HRRZ 1,0(P)	;NEW PAGE
	ANDI 1,777000
	HRRM 1,LASTPG	;SAVE FOR NEXT TIME
	LSH 1,-11
	HRL 1,FORK
	RPACS		;GET ITS REAL ACCESS
	HRLM 2,LASTPG	;SAVE FOR NEXT TIME
	TLO 2,(1B2!1B3!1B4!1B9)	;R,W,X,C
	TLNE 2,(1B5)	;DON'T SET IF IT DOESN'T EXIST
	SPACS		;UP ITS ACCESS

CHKA4:	MOVE 2,[400000,,UCORE/1000]	;IDDT'S FORK,,PAGE
	HRLI 3,(1B2!1B3!1B4)	;R,W,X
	PMAP
	RPACS		;GET ACCESS
	HLLM 2,IDPACS	;SAVE THE ACCESS
	JRST CHKA1

;UNMAP THE PAGE CURRENTLY MAPPED INTO UCORE
UNMAP:	PUSH P,1
	PUSH P,2
	HRRZ 1,LASTPG
	LSH 1,-11
	HRL 1,FORK
	HLL 2,LASTPG	;ACTUAL ACCESS BITS
	TLNE 2,(1B5)	;DON'T SPACS IF IT DOESN'T EXIST
	SPACS
	SETZM LASTPG	;CLEAR BIT 5
	SETOM 1
	MOVE 2,[400000,,UCORE/1000]
	PMAP		;AWAY!
	POP P,2
	POP P,1
	RET

; ;A --TYPE ADDRESS SPACE --  MEMSTAT
;JUST LIKE THE EXEC'S


ADRSPC:	CALL UNMAP

MEMSTA:	MOVE W1,[POINT 7,[ASCIZ /DDRESS SPACE
/]]
	CALL TYPE
	INTON
	HRLZ 1,FORK		;USER'S FORK
	PUSH P,[1000]		;HOW MANY PAGES TO DO
	SETZB T,W		;CURRENT PAGE
MEMS1:	RPACS
	TLNE 2,(1B5)		;EXISTS?
	AOS W,T			;YES,COUNT IT
	AOS 1			;NEXT PAGE
	SOSLE 0(P)		;COUNT DOWN NUMBER OF PAGES LEFT
	 JRST MEMS1
	SUB P,[1,,1]		;FLUSH JUNK
	CALL TOC		;T,W = NUMBER OF PAGES WHICH EXIST
	MOVE W1,[POINT 7,[ASCIZ / PAGES/]]
	CALL TYPE

MEMS2:	MOVE 1,FORK
	GEVEC
	JUMPE 2,MEMS3		;NO ENTRY VECTOR
	PUSH P,2
	MOVE W1,[POINT 7,[ASCIZ /, ENTRY VECTOR LOC /]]
	CALL TYPE
	HRRZ T,0(P)
	CALL TOC
	MOVE W1,[ASCII / LEN /]
	CALL TEXT2
	POP P,T
	HLRZS T
	CALL TOC

MEMS3:	CALL CRF
	JUMPE W,DD1
	CALL CRF

MMAP:	SETZM W
MMAP1:	HRL 1,FORK
MMAP2:	CAIL W,1000
	JRST DD1		;DONE
	HRR 1,W
	RPACS
	TLNN 2,(1B5!1B6)	;EXISTS OR @
	AOJA W,MMAP2		;NO, TRY NEXT
	CALL PAGID		;GET FULL IDENTITY
	 JRST .+2
	 JRST .+1
	MOVE TT,TT2		;SAVE ID FOR LATER
	MOVE TT1,TT3		;PRINTING, TESTING
	SETZM W2		;HOW MANY IN THIS GROUP
	HRRZ T,W
	CALL TOC		;GROUP START, PAGE NUMBER

;HAVE THE FIRST PAGE, LOOK AT NEXT ONE TO SEE IF IT IS SAME GROUP
	CALL NPAGID		;NEXT PAGE ID, STEPS W
	 SOJA W2,MMAP10		;DIFFERENT, TYPE OUT
	 JRST MMAP6		;NEXT(CONSECUTIVE) PAGE IN SAME GROUP

;2ND PAGE IDENTICAL TO FIRST PAGE, SEE HOW MANY MORE ARE
	CALL NPAGID
	 JRST .+3
	 JRST .+2
	JRST .-3		;IDENTICAL, KEEP GOING
	SETZM W2		;SAY IDENTICAL, NO CONSECUTIVE PAGES
	JRST MMAP7

;2ND PAGE IS NEXT HIGHER AFTER 1ST, IN SAME FORK/FILE. HOW MANY MORE
MMAP6:	CALL NPAGID
	 JRST .+2		;DIFFERENT
	 JRST .-2		;CONSECUTIVE, KEEP GOING

;PRINT LAST PAGE NUMBER OF GROUP
MMAP7:	MOVEI T,"-"
	CALL TOUT
	MOVEI T,-1(W)
	CALL TOC		;FINAL PAGE NUMBER

;PRINT IDENTITY OF PAGES(S) IN GROUP
MMAP10:	CALL LCT		;TAB
	CALL TSPC		;SPACE
	TLNE TT1,(1B6)
	JRST MMAP09
MMAP08:	TLNN TT1,(1B5)
	JRST MMAP70
	TLNE TT1,(1B10)
	JRST MMAP71
	CAMN TT,[-1]
	JRST MMAP72
	LDB 2,[POINT 9,TT,17]	;JFN OR FORK #
	TLNE TT,(1B0)		;ON IF FORK
	JRST MMAP69
	MOVEI 1,101		;TTY OUTPUT
	SETZM 3			;NO SPECAIL OPTIONS
	JFNS			;PRINT FILE NAME
MMAP11:	CALL LCT
	HRRZ T,TT
	CALL TOC		;PAGE # IN FORK/FILE
	JUMPLE W2,MMAP13	;0 => ONLY ONE PAGE
	MOVEI T,"-"
	CALL TOUT
	HRRZ T,TT
	ADDI T,-1(W2)
	CALL TOC		;LAST PAGE IN GROUP
	JRST MMAP13

MMAP09:	MOVSI W1,(ASCII /@ /)
	CALL TEXT2
	JRST MMAP08
MMAP69:	MOVE W1,[POINT 7,[ASCIZ /FORK /]]
	CALL TYPE
	MOVE T,2		;FORK NUMBER
	CALL TOC
	JRST MMAP11

MMAP70:	MOVE W1,[POINT 7,[ASCIZ /NO PAGE/]]
	JRST MMAP12

MMAP71:	MOVE W1,[POINT 7,[ASCIZ /PRIVATE/]]
	JRST MMAP12

MMAP72:	MOVE W1,[POINT 7,[ASCIZ /FORGOTTEN FILE/]]

MMAP12:	CALL TYPE
MMAP13:	TRZ F,TEMF		;SUPPRESS COMMA IN LIST
	MOVSI W1,(ASCII / R/)
	TLNE TT1,(1B2)
	CALL MMAP14
	MOVSI W1,(ASCII / W/)
	TLNE TT1,(1B3)
	CALL MMAP14
	MOVSI W1,(ASCII / C/)
	TLNE TT1,(1B9)
	CALL MMAP14
	MOVSI W1,(ASCII / X/)
	TLNE TT1,(1B4)
	CALL MMAP14
	MOVSI W1,(ASCII / L/)
	TLNE TT1,(1B7)
	CALL MMAP14
	CALL CRF
	JRST MMAP1		;DO NEXT GROUP

;TYPE ITEM IN ACCESS CAPABILITY LIST
MMAP14:	MOVEI 1,","
	TROE F,TEMF
	CALL TOUT+1
	JRST TEXT2

;NEXT PAGE ID
NPAGID:	ADDI W,1		;PAGE UNDER CONSIDERATION
	ADDI W2,1		;HOW MANY IN CURRENT GROUP

;GET PAGE IDENTIFICATION
PAGID:	MOVE 1,W
	SETZM TT2		;FOR NON-EXISTENT OR PRIVATE PAGE
	CAIL 1,1000
	JRST PAGID7
	HRL 1,FORK
	RPACS
	HLLZ TT3,2		;RETURN ACCESS
	TLNE 2,(1B5)		;DOESN'T EXIST?
	TLNE 2,(1B10)		;PRIVATE?
	JRST PAGID8		; ALL INFO REQUIRED
	RMAP
	MOVE TT2,1		;RETURN ID

;COMPARE PRINTING INFO AGAINS SAME FOR PREVIOUS PAGE
PAGID8:	MOVE 1,TT2
	XOR 1,TT
	TLNE 1,-1
	JRST PAGID9		;DIFFERENT FILES OR FORKS
	MOVE 2,TT3
	XOR 2,TT1
	TLNE 2,(37B6!1B7!3B10)
	JRST PAGID9		;DIFFERENT ACCESS
	TRNE 1,-1
	JRST PAGID6
	AOS (P)
	AOS (P)
PAGID9:	RET

PAGID6:	MOVE 1,W2
	ADD 1,TT
	SUB 1,TT2
	TRNE 1,-1
	RET
	JRST PAGID9-1

PAGID7:	HRLZI TT3,(1B5)	;PAGES > 777 DON'T EXIST
	JRST PAGID8

;SETUP TO EXECUTE A SINGLE INSTRUCTION
;T HAS THE INSTR.
;$X SAYS WHERE IN USER'S MEMORY TO DO IT

SETESI:	HRRZ R,XRG	;WHERE
	CALL DEP
	 JRST ERR	;CAN'T DO IT IN PROTECTED MEMORY
	MOVEI W1,3
SETES1:	MOVE T,[BPT]
	AOS R
	CALL DEP	;INSERT PSEUDO BREAKPOINTS
	 JRST ERR
	SOJG W1,SETES1
SETES2:	EXCH P,PCSPTR
	PUSH P,F
	PUSH P,LLOC
	PUSH P,LLOCO
	PUSH P,TRAPWD
	PUSH P,WDATA
	PUSH P,BPTFLG	;WHICH BREAKPOINT WERE AT
	PUSH P,BINSTR	;CURRENT BREAK INSTRUCTION
	MOVSI R,(1B5)	;USERMODE FLAG
	IORM R,PC
	PUSH P,PC	;SAVE HIS OLD PC
	EXCH P,PCSPTR
	HLL R,PC	;GET FLAGS
	HRR R,XRG	;WHERE $X SHOULD BE DONE
	MOVEM R,PC	;HIS TEMPORARY PC
	MOVEM R,REALPC
	RET


;UNSET THE ABOVE
UNSET:	EXCH P,PCSPTR
	HLL TT1,REALPC	;FLAGS RETURNED FROM $X ETC.
	POP P,PC
	HRR TT1,PC
	MOVEM TT1,PC	;WHAT TO TYPE FOR $G
	MOVEM TT1,REALPC	;WHERE TO DO SFORK (IN TOUSER)
	POP P,BINSTR
	POP P,BPTFLG
	POP P,WDATA
	POP P,TRAPWD
	POP P,LLOCO
	POP P,LLOC
	POP P,F
	EXCH P,PCSPTR
	RET

;F COMMAND -- FORKSTAT

FRKST:	JRST ERR	;UNTIL GFRKS IS IMPLEMENTED
REPEAT 0,<
FRKST:	CALL UNMAP	;WILL USE THAT AREA FOR BUFFER
	FRKTAB=UCORE
	MOVE W1,[POINT 7,[ASCIZ /ORK STATUS
/]]
	CALL TYPE
	INTON
	MOVE 2,[1B1+FRKTAB]
	GFRKS
	HRRZI W,FRKTAB	;WHAT TO PRINT
	SETZM TT	;LEVEL TO PRINT IT AT
	CALL PRFRK	;PRINT FORKS
	JRST DD1

PRFRK:	CALL CRF
	SKIPN S,TT	;LEVEL
	JRST PRHDL
	CALL TSPC	;TYPE A SPACE
	SOJG S,.-1
PRHDL:	HRRZ T,1(W)	;FORK HANDLE
	ANDI T,77
	CALL TOC	;PRINT IT
PRINF:	HRRZ T,0(W)	;POINTER TO INFERIORS
	JUMPE T,PRPAR	;NONE
	MOVE W,T
	AOS TT		;LEVEL OF INFERIORS
	CALL PRFRK	;PRINT THEM
	SOS TT		;NO BACK TO THIS LEVEL
PRPAR:	HLRZ T,0(W)	;PARALLEL FORKS
	JUMPE T,UP	;NONE
	MOVE W,T
	CALL PRFRK	;PRINT THEM
UP:	HLRZ W,1(W)	;SUPERIOR POINTER
	RET
>		;END REPEAT 0

;ARG<  COMMAND
FIRARG:	MOVEM T,DEFV		;VALUE OF ARG TO DEFINITION VALUE
	TLO F,FAF		;INDICATE A < HAS BEEN SEEN
	JRST ULIM1		;GIVE ERROR IF ARG NULL


;ARG> COMMAND
ULIM:	TLO F,SAF		;INDICATE A > HAS BEEN SEEN
	HRRZM T,ULIMIT		;UPPER LIMIT FOR $Z, $W ETC.


ULIM1:	TLNN F,QF		;ON IF ARG WAS TYPED
	JRST ERR
	JRST LIS0		;GET REST OF COMMAND


;$I COMMAND -- NAME OF INTERRUPT STUFF FOR USER PSI SYSTEM
INTRUP:	TLNN F,QF		;MUST HAVE NO ARG
	TLNE F,CCF		;AND ONLY ONE $ SIGN
	JRST ERR		;ELSE, DIFFERENT COMMAND
	MOVEI T,USRPSI
	JRST QUANIN

; ;H -- HALTF BACK TO EXEC
HALT:	MOVE 1,ESCCOD
	DTI
	HALTF			;LIKE @QUIT
	JRST DDT

;LOOK FOR BEST FIT FOR SYMBOL TYPE-OUT
LOOK:	TLNN T,-1		;IF LEFT HALF NON-0, OR
	CAIGE T,140		;VALUE LESS THAN 140,
LOOKE:	TLOA F,(1B2)		;SKIP LOCALS OUTSIDE CURRENT PGM
	TLZ F,(1B2)		;OTHERWISE, ALLOW LCLS AND SAVE CONTEXT
	SETZM SVFB
	SETZM SVTB
	SETOM BLVL
	HLRE S,SYMPTR
	ASH S,-1
	TLZ F,600000
	HRLZI W2,DELO+DELI
	MOVEM T,TEM
	SKIPL R,PRGM
	JRST TOPDWN
LOOK1:	SUB R,[2,,2]
	TDNE W2,(R)
	JRST LOOK3
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST BLNME
	JUMPE T,PNAM
	TRNE T,LOCAL/40000
	TLZA F,(1B1)
	TLO F,(1B1)
	MOVE T,TEM
	MOVE W,1(R)
	XOR W,T
	JUMPL W,LOOK3
	SUB T,1(R)
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,1(R)
	SUB W,1(W1)
	JUMPL W,LOOK3
	JUMPG W,LOOK2
	SKIPN SVTB		; THIS SYMBOL NO PREFIX
	SKIPN SVFB		; AND LAST SYMBOL WITH PREFIX?
	JRST LOOK3		; NO

LOOK2:	HRR W1,R
	TLO F,(1B0)		; REMEMBER WE HAVE FOUND SOME SYMBOL
	MOVE W,SVTB
	TLNE F,(1B1)		; IF THIS SYMBOL IS GLOBAL,
	MOVEI W,0		; THEN DON'T SAVE BLOCK
	MOVEM W,SVFB
	SKIPN W			; ANY PREFIX?
	JUMPE T,SPT0		; NO, THEN EXACT MATCH IS BEST
LOOK3:	CAMN R,SYMPTR
	JRST TOPDWN
LOOK3A:	AOJLE S,LOOK1
	MOVE T,TEM
	TLNE F,(1B0)
	SUB T,1(W1)
	JUMPE T,SPT0
	JRST CPOPJ1

TOPDWN:	TLNE F,(1B2)
	TLO W2,LOCAL
	HLRE R,SYMPTR
	MOVNS R
	ADD R,SYMPTR
	JRST LOOK3A

PNAM:	TLNE F,(1B2)
	TLO W2,LOCAL
	SKIPA T,[-1]		; PROGRAM NAMES LIKE BLOCKS OF LEVEL -1
BLNME:	MOVE T,1(R)		; GET BLOCK LEVEL
	MOVEM R,SVTB		; SAVE THIS BLOCK LOCATION
	CAMN R,BLOCK		; IS THIS THE CURRENT BLOCK?
	JRST BLNM1		; YES
	CAML T,BLVL		; IS BLOCK BELOW CURRENT?
	JRST LOOK3		; YES, RETAIN PREFIX
BLNM1:	SETZM SVTB		; THIS IS CURRENT OR ABOVE
	MOVEM T,BLVL
	JRST LOOK3

CONSYM:	MOVEM T,LWT
	TRNN F,LF1
	JRST (SCH)		;PIN OR FTOC
	TRNE F,CF1
	JRST FTOC

PIN:				;PRINT INSTRUCTION
	TLC T,700000
	TLCN T,700000
	JRST INOUT		;IN-OUT INSTRUCTION OR NEG NUM
	AND T,[777000,,0]	;EXTRACT OPCODE BITS
	JUMPE T,HLFW		;TYPE AS HALF WORDS
	HLLZS T
	CAMN T,[JSYS 0]
	JRST JSTYPE
PIN0:	HLLZ T,LWT
	TLZ T,777
	CALL OPTYPE
PIN1:	TRNE F,ITF		;INSTRUCTION TYPED?
	JRST PFULI1		;YES
	MOVE T,LWT		;TRY TO FIND FULL WORD MATCH
	TLNE T,777		;BUT NOT IF AC, @, OR X FIELDS NON-0
	JRST PFULI1
	CALL LOOK
	JRST PADS1		;FOUND
PFULI1:	MOVSI T,777000
	AND T,LWT
	TRNN F,ITF		;HAS INSTRUCTION BEEN TYPED?
	CALL LOOK		;NO, LOOK IN SYMBOL TABLE
	TROA F,NAF		;INSTRUCTION TYPED, ALLOW NEG ADDRESSES
	JRST HLFW		;NOT FOUND, OUTPUT AS HALFWORDS
	CALL TSPC
	LDB T,[POINT 4,LWT,12]	;GET AC FIELD
	JUMPE T,PI4
	CALL PAD
PI3A:	MOVEI W1,","
	CALL TEXT
PI4:	MOVE W1,LWT
	MOVEI T,"@"
	TLNE W1,20		;CHECK FOR INDIRECT BIT
	CALL TOUT
	HRRZ T,LWT
	LDB W,[POINT 9,LWT,8]	;INSTRUCTION BITS
	TLNE W1,20
	JRST PI8
	CAIL W,240
	CAILE W,247
	JRST PI8A		;ALL (EXCEPT ASH,ROT,LSH) HAVE SYMB. ADRS
	CAIN W,<JFFO>_-33
	JRST PI8		;JFFO AND @ GET SYMBOLIC ADDRESSES
	CALL PADS3A	;ONLY ABSOLUTE ADDRESSING FOR LSH, ASH, AND ROT
PI7:	TRZ F,NAF	
	LDB R,[POINT 4,LWT,17]	;INDEX REGISTER CHECK
	JUMPE R,PADS1		;EXIT
	MOVEI T,"("
	CALL TOUT
	MOVE T,R
	CALL PAD
	MOVEI T,")"
	JRST TOUT		;EXIT

PI8A:	CAIL W,600		; IS THIS A TEST INSTRUCTION?
	CAILE W,677
	JRST PI9
	TRNE W,10		; DIRECT OR SWAPPED?
	JRST PI8		; YES, PRINT SYMBOLIC ADDRESS
	CALL PADFLG		; TLXX OR TRXX, PRINT ADDRESS AS FLAGS
	JRST PI7

PI8:	CALL PAD
	JRST PI7

PI9:	LDB W,[POINT 13,LWT,12]
	ANDI W,16007
	CAIL W,16003		; OP GREATER THAN DATAO?
	CAIN W,16005		; AND NOT CONI?
	JRST PI8		; NO
	CALL PADFLG
	JRST PI7		; YES CONO, CONSZ AND CONSO PRINT BITS

HLFW:	HLRZ T,LWT		;PRINT AS HALF WORDS
	JUMPE T,HLFW1		;TYPE ONLY RIGHT ADR IF LEFT ADR=0
	TRO F,NAF		;ALLOW NEGATIVE ADDRESSES
	CALL PAD
	MOVSI W1,(ASCII /,,/)
	CALL TEXT2		;TYPE ,,
HLFW1:	HRRZ T,LWT

;PRINT ADDRESSES (ARG USUALLY 18 BITS BUT CAN BE 36 BITS)

PAD:	TLZE T,(DDTINT)
	JRST PADINT		;INTERNAL TO IDDT
	ANDI T,-1
	JRST @AR		;PADSO OR PAD1

PADSO:	JUMPE T,FP7B		;PRINT A ZERO
	CALL LOOK
PADS1:	RET
	JUMPGE F,PADS3		;PRINT NUMBER OF NO SYMBOL FOUND
	MOVE W2,1(W1)
	CAIGE T,100
	CAIGE W2,60
	JRST PADS3
	MOVEM T,TEM
	CALL SPT0
PADS0A:	MOVEI T,"+"
PADS1A:	CALL TOUT
	HRRZ T,TEM
PAD1:	JRST TOC		;EXIT

PADS3:	MOVE T,TEM
PADS3A:	TRNE F,NAF
	CAIGE T,776000
	JRST TOC
PADS3B:	MOVNM T,TEM
	MOVEI T,"-"
	JRST PADS1A

;PRINT INTERNAL ADDRESS
PADINT:	MOVEI TT,777777		;INITIAL DIFFERENCE = ./.
	MOVE S,[INTTAB-INTEND,,INTTAB]
PADIN1:	HRRZ R,0(S)
	SUBM T,R
	JUMPL R,PADIN0		;NEGATIVE IS NOT SMALLER THAN 0
	CAMLE R,TT
	JRST PADIN0		;NOT A BETTER MATCH
	MOVEM R,TT		;NEW DIFFERENCE
	HLRZ W1,0(S)		;NAME POINTER
PADIN0:	AOBJN S,PADIN1
PADIN2:	JUMPE TT,PADIN3		;EXACT MATCH
	CAIL T,FRSTIR		;LOWER THAN 1ST INTERNAL REGISTER
	CAIL T,LASTIR		;GREATER THAN LAST INTERNAL
	JRST ERR
	MOVEM TT,TEM
	CALL PADIN3
	JRST PADS0A
PADIN3:	MOVE W1,0(W1)		;GET ASCIZ
	CALL TEXT2
	RET

; PRINT ADDRESS AS FLAGS

PADFLG:	PUSH P,T		; SAVE ADDRESS
	MOVEI W1,3		;COUNT BITS TO SEE IF MORE THAN 3
	MOVN W2,T		;FIND RIGHTMOST ONE IN T
	TDZE T,W2		;SKIP IF NO MORE
	SOJGE W1,.-2		;STOP COUNTING IF MORE THAN 3
	JUMPL W1,PADFL6		;GO TYPE NUMBER IF MORE THAN 3 BITS
	MOVEI T,400000		; START WITH LEFT MOST BIT
PADFL1:	TDNN T,(P)		; IS THIS BIT IN THE THING
	JRST PADFL2		; NO, GO TO NEXT BIT
	CALL LOOKE		; LOOK UP THIS BIT
	JRST PADFL3		; EXACT MATCH FOUND AND PRINTED
	JRST PADFL4

PADFL3:	MOVE T,TEM
	ANDCAM T,(P)		; REMOVE BIT FROM ADDRESS
	SKIPN (P)		; ANY MORE TO BE OUTPUT?
	JRST PADFL5		; NO
	MOVEI T,"+"
	CALL TOUT		; YES, TYPE !
PADFL4:	MOVE T,TEM
PADFL2:	ASH T,-1		; SHIFT TO NEXT BIT
	CAILE T,10		;DONE BITS 18-31?
	JRST PADFL1		;NO, GO DO NEXT BIT
PADFL6:	POP P,T			; ELSE TYPE OUT THE REST AS A NUMBER
	JRST TOC

PADFL5:	POP P,T
	RET

INOUT:	TDC T,[-1,,400000]	;IO INSTRUCTION OR NEG NUM
	TDCN T,[-1,,400000]
	JRST PADS3B		;TYPE AS NEG NUM
	LDB R,[POINT 7,T,9]	;PICK OUT IO DEVICE BITS
	CAIL R,700_-2		;IF DEVICE .L. 700, THEN TYPE
	JRST HLFW		;TYPE AS HALF WORDS
	LDB R,[POINT 3,T,12]
	DPB R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	CALL OPTYPE
	CALL TSPC
	MOVSI T,077400
	AND T,LWT
	JUMPE T,PI4
	CALL LOOK		;LOOK FOR DEVICE NUMBER
	JRST PI3A
	MOVE T,TEM
	LSH T,-30
	CALL TOC
	JRST PI3A

;PRINT AS JSYS
; ONLY IF EXACT MATCH IS FOUND.
; IF NOT PRINTED, RETURNS TO PIN TO CALL OPTYPE TO
; GET THE INSTRUCTION PRINTED LIKE  JSYS 501
JSTYPE:	MOVE T,LWT
	CALL LOOK
	RET			;FOUND, EXIT FROM PIN
	HRRZ TT,LWT		;JSYS NUMBER
	MOVE T,TT
	IDIVI TT,<JSYEND-JSYTAB>/2
	ASH TT1,1
	MOVE TT3,TT1		;END CHECK

	MOVEI TT2,2
	HRRZ W1,JSYTAB+1(TT1)
	CAMG T,W1		;SEARCH FORWARD ?
	MOVNS TT2		;NO.

PJSN:	ADD TT1,TT2		;MOVE TO NEXT ENTRY
	SKIPGE TT1		;OFF BOTTOM
	MOVEI TT1,JSYEND-2-JSYTAB	;YES, RING TO TOP
	CAIL TT1,JSYEND-JSYTAB	;AT TOP?
	MOVEI TT1,0		;YES, RING TO BOTTOM
	HRRZ W1,JSYTAB+1(TT1)
	CAMN T,W1
	JRST PRJSY		;FOUND
	CAME TT1,TT3		;DONE ALL?
	JRST PJSN		;NO
	JRST PIN0		;CAN'T PRINT AS KNOWN JSYS

PRJSY:	MOVE W1,JSYTAB(TT1)
	JRST TEXT2		;PRINT NAME, EXIT FROM PIN

; $M COMMAND -- SET SEARCH MASK
MASK:	TLNE F,CCF		;HOW MANY $'S ?
	JRST ERR		;2
	MOVE R,T
	MOVEI T,MSK
	TLNN F,QF
	JRST QUANIN		;INTERNAL REGISTER EXAMINATION SETUP
	MOVEM R,MSK		;SET THE MASK
	JRST RETX

; $W -- WORD EQUALITY SEARCH
WORD:	TLNE F,QF		;ARG TYPED?
	JRST EFWRD		;YES, DO WORD SEARCH
	MOVEI T,TRAPWD		;NO, EXAMINE $W REGISTER
	JRST QUANIN

; $E -- EFFECTIVE ADDRESS SEARCH
EFFEC:	TLNE F,CCF		;HOW MANY $'S ?
	JRST ERR		;2
	TLO F,TEMF
	HRRZ T,T


EFWRD:	MOVEI R,(<JUMPE T,0>-<JUMPN T,0>)

; $N -- WORD NON-EQUALTIY SEARCH (R IS 0)
NWORD:	ADDI R,(<JUMPN T,0>)
	HRLM R,SEAR2
	INTON
	TLZN F,QF		;QUANTITY TYPED IN?
	 JRST ERR		;NO ARGUMENT
	SETCAM T,WRD
	MOVE T,ULIMIT		;WHAT TO USE IF SECOND ARG TYPED
	TLNE F,SAF		;IF 2ND ARG...
	 TLO F,QF		;FOOL SETUP
	CALL SETUP		;1ST ADDR TO DEFV, LAST TO ULIMIT
	CALL CRF
SEAR1:	CALL FETCH		;OF R
	 JRST SEAR2B
	TLNE F,TEMF		;CHECK FOR EFFECTIVE ADDRESS SEARCH
	JRST EFFEC0		;DO E.A. COMPARE, RETURN TO SEAR2X
	EQV T,WRD
	AND T,MSK

;GO TO SEAR3 IF A FIND HAS OCCURRED
SEAR2X:	XCT SEAR2		;A JUMPE T,SEAR3 OR JUMPN T,SEAR3
SEAR2A:	AOS R,DEFV		;GET NEXT LOCATION
	CAMG R,ULIMIT		;END OF SEARCH?
	JRST SEAR1		;NO, LOOK SOME MORE

;AT END OF SEARCH
SEARFN:	SETCMM LWT		;COMPLEMENT BITS BACK AND STOP SEARCH
	JRST DD1

SEAR2B:	MOVEI R,777
	IORB R,DEFV		;SKIP TO NEXT PAGE
	JRST SEAR2A

;FOUND A MATCH,  R IS WHERE
SEAR3:	MOVE R,DEFV
	CALL FETCH
	 JRST ERR
	TLZ F,STF		;GET RID OF SUPPRESS TYPEOUT MODE
	MOVE T,DEFV
	CALL LI1		;EXAMINE REGISTER
	CALL CRF
	SETCMM LWT
	SETCMM TEM
	TRNE F,Q2F		;IF ENABLED, STOP AT THE
	SOSLE WRD2		;N-TH FIND.
	JRST SEAR2A		;NO. KEEP LOOKING
	JRST SEARFN		;YES. STOP

;CALCULATE EFFECTIVE ADDRESS AND DO
;COMPARE FOR INSTRUCTION AT  R
EFFEC0:	MOVEI W,20		;@ CHAIN DEPTH, MAX.
	MOVEM W,TEM
EFFEC1:	MOVE W,T
	LDB R,[POINT 4,T,17]	;GET XR FIELD
	JUMPE R,EFFEC2		;NO XR SPECIFIED, TRY FOR @
	CALL FETCH		;THE XR
	 JRST ERR
	ADD T,W			;ADD IN THE XR

;T HAS THE INDEXED ADDRESS, SEE IF @
EFFEC2:	HRR R,T
	TLNN W,(@)		;INDIRECT BIT CHECK
	JRST EFFEC3		;NONE, R HAS EFFECTIVE ADDR
	SOSE TEM		;CHECK @ CHAIN LENGTH
	CALL FETCH		;GET INDIRECT WORD
	 JRST SEAR2A		;CAN'T GET IT => NO MATCH
	JRST EFFEC1		;GO BACK AND TRY TO INDEX

;GOT IT. DO COMPARE ON ADDRESS
EFFEC3:	EQV T,WRD
	ANDI T,777777
	JRST SEAR2X

;SETUP SEARCH LIMITS
;1ST ADDR (0) TO R AND DEFV, LAST TO ULIMIT
;USED BY SEARCHES (W,N,E) AND ZERO (Z)
SETUP:	TLNN F,QF		;QUANTITY TYPED (2ND ARG)?
	MOVEI T,777777		;NO, DEFAULT LAST ADDRESS
	HRRZM T,ULIMIT		;SAVE TOP OF SEARCH/ZERO
	HRRZS R,DEFV		;GET 1ST ADDRESS
	TLNN F,FAF		;WAS A 1ST ADR SPECIFIED?
	SETZB R,DEFV		;NO, MAKE IT ZERO
	CAMLE R,ULIMIT		;LIMITS IN A REASONABLE ORDER?
	JRST ERR		;NO
	RET			;YES, RETURN


;$$Z  ZERO MEMORY FROM ZLOW TO ULIMIT AND AC'S
ZERO:	TLNN F,CCF
	JRST ERR
	CALL UNMAP		;FORGET ABOUT ANY MAPPED PAGE
	CALL SETUP
ZERO0:	CAIL R,700000
	CAIL R,740000
	 JRST ZERO2		;NOT ZERO'ING COMPATIBILITY
	MOVE 1,FORK
	PUSH P,R
	SETZB 2,3
	SCVEC			;FLUSH PAT
	POP P,R
ZERO2:	MOVE T,WRD2		;0 (OR WHATEVER) TO STORE IN MEMORY
ZERO3:	CAMLE R,ULIMIT		;ABOVE LIMITS?
	 JRST DD1		;YES, STOP
	TRNN R,777		;START OF PAGE?
	JRST ZERO4		;YES, CHECK FOR EXISTENCE
ZERO33:	CALL DEP		;DEPOSIT T AT USER LOC IN R
	 JRST ZERO5		;WOULDN'T DEPOSIT
	AOJA R,ZERO0

ZERO4:	JUMPN T,ZERO33		;NOT REALLY ZEROING
	MOVE TT,ULIMIT
	SUB TT,R		;NUMBER OF WORDS LEFT TO ZERO
	CAIGE TT,777		;LESS THAN A PAGE?
	JRST ZERO33		;YES, ZERO THEM
ZERO5:	MOVE TT,R		;R=2
	HRRZS 2
	LSH 2,-11
	HRL 2,FORK
	SETOM 1
	PMAP
	MOVE R,TT
	IORI R,777		;TOP OF THIS PAGE
	AOJA R,ZERO0		;DO NEXT PAGE

;NUMERIC OUTPUT SUBROUTINE
FTOC:
TOC:	HRRZ W1,ODF
	CAIN W1,10		;IS OUPUT RADIX NOT OCTAL, OR
	TLNN T,-1		;ARE THERE  NO LEFT HALF BITS?
	JRST TOCA		;YES, DO NOTHING SPECIAL
	HRRM T,TOCS		;NO, TYPE AS HALF WORD CONSTANT
	HLRZS T			;GET LEFT HALF
	CALL TOC0		;TYPE LEFT HALF
	MOVSI W1,(ASCII /,,/)
	CALL TEXT2		;TYPE ,,
TOCSX:	XCT TOCS		;A MOVEI T,.-. TO GET RIGHT HALF BACK
TOCA:	HRRZ W1,ODF		;IS OUTPUT RADIX DECIMAL?
	CAIN W1,12
	JRST TOC4		;YES,TYPE SIGNED WITH PERIOD
TOC0:	LSHC T,-43
	LSH W1,-1		;W1=T+1
	DIVI T,@ODF
	HRLM W1,0(P)
	SKIPE T
	CALL TOC0
	HLRZ T,0(P)
	ADDI T,"0"
	JRST TOUT

TOC4:	MOVM A,T		;TYPE AS SIGNED DECIMAL INTEGER
	JUMPGE T,TOC5
	MOVEI T,"-"
	CALL TOUT
TOC5:	CALL FP7		;DECIMAL PRINT ROUTINE
TOC6:	MOVEI T,"."
	JRST TOUT

;SYMBOL OUTPUT SUBROUTINE

SPT0:	HRRZM W1,SPSAV		;SAVE POINTER TO TYPED SYM
SPT:	MOVE T,SVFB
	JUMPE T,SPT1W
	CAMN T,BLOCK
	JRST SPT1W
	PUSH P,W1
	LDB T,[POINT 32,(T),35]
	CALL SPT1
	MOVEI T,"&"
	CALL TOUT
	POP P,W1
SPT1W:	LDB T,[POINT 32,(W1),35]	;GET SYMBOL


;RADIX 50 SYMBOL PRINT
SPT1:	IDIVI T,50
	HRLM W1,0(P)
	JUMPE T,SPT2
	CALL SPT1
SPT2:	HLRZ T,0(P)
	JUMPE T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI T,260-1
	CAILE T,271
	ADDI T,301-272
	CAILE T,332
	SUBI T,334-244
	CAIN T,243
SPT3:	MOVEI T,256
	JRST TOUT

;$D ;DELETE LAST SYM & PRINT NEW
SYMD:	MOVEI T,DELO/200000
	HRRZ R,SPSAV		;PICK UP POINTER TO LAST SYM
	JUMPE R,ERR
	DPB T,[POINT 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL
	MOVE T,LWT
	JRST CONSYM		;PRINT OUT NEXT BEST SYMBOL

;FLOATING POINT OUTPUT

TFLOT:	MOVE A,T
	JUMPG A, TFLOT1
	JUMPE A,FP1A
	MOVNS A
	MOVEI T,"-"
	CALL TOUT
	TLZE A,400000
	JRST FP1A
TFLOT1:	TLNN A, 400
	JRST TOC5		;IF UNNORMALIZED, TYPE AS DECIMAL INTEGER

FP1:	MOVEI S,0
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA S,FP4
FP1A:	MOVEI W,0

FP3:	MULI A,400
	ASHC S,-243(A)
	SETZM TEM1		;INIT 8 DIGIT COUNTER
	SKIPE A,S		;DON'T TYPE A LEADING 0
	CALL FP7		;PRINT INTEGER PART OF 8 DIGITS
	CALL TOC6		;PRINT DECIMAL POINT
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,W
FP3A:	MOVE T,W1
	MULI T,12
	CALL FP7B
	SKIPE,W1
	AOJL A,FP3A
	RET

FP4:	MOVNI W,6
	MOVEI W2,0
FP4A:	ASH W2,1
	XCT,FCP(S)
	JRST FP4B
	FMPR A,@FCP+1(S)
	IORI W2,1
FP4B:	AOJN W,FP4A
	PUSH P,W2		;SAVE EXPONENT
	PUSH P,FSGN(S)		;SAVE "E+" OR "E-"
	CALL FP3		;PRINT OUT FFF.FFF PART OF NUMBER
	POP P,W1		;GET "E+" OR "E-" BACK
	CALL TEXT
	POP P,A			;GET EXPONENT BACK

FP7:	IDIVI A,12		;DECIMAL OUTPUT SUBROUTINE
	AOS,TEM1
	HRLM S,(P)
	JUMPE A,FP7A1
	CALL FP7

FP7A1:	HLRZ T,(P)
FP7B:	ADDI T,260
	JRST TOUT

FCP:	CAMLE A, FT0(W)
	CAMGE A, FT(W)
	Z FT0(W)

TEXTT:	MOVE W1,T
TEXT:	TLNN W1,774000		;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH W1,35
TEXT2:	MOVEI T,0		;7 BIT ASCII TEXT OUTPUT SUBROUTINE
	LSHC T,7
	CALL TOUT
	JUMPN W1,TEXT2
	RET


;STRING TYPER, ANY LENGTH
;W1 HAS BYTE POINTER
TYPE:	ILDB T,W1
	TRNN T,177
	RET
	CALL TOUT		;MAIN CHARACTER TYPER
	JRST TYPE

;TYPE CARRIAGE RETURN
CRN:	MOVEI T,15
	JRST TOUT

;TYPE CARRIAGE RETURN, AND RUBOUT
CRNRB:	CALL CRN
	MOVEI T,177
	JRST TOUT

;TYPE NEW LINE
CRF:	MOVEI T,37		;TENEX NEWLINE CHARACTER
	JRST TOUT

;TYPE LOWER CASE AND TAB, FROM PDP-1!!!
LCT:	CALL TSPC
	CALL TSPC

;TYPE SPACE
TSPC:	MOVEI T," "		;SPACE
	JRST TOUT


;CHARACTER OUTPUT FROM AC1
TOUT:	EXCH 1,T
	TYO
	EXCH 1,T
	RET


TIN:	SKIPE STRING		; ARE WE INPUTTING FROM A STRING?
	JRST TINST
TIN0:	TDNE F,[CF,,SEMIF]	;NEED TO SEE EACH CHR AS IT COMES IN?
	JRST TIN6		;YES
	MOVE T,STRIP		;IN PTR
	CAME T,STROP		;OUT PTR
	 JRST TIN4		;NON-EMPTY BUFFER
TIN1:	MOVE T,[POINT 7,STRBUF-1,34]
	MOVEM T,STRIP
	MOVEM T,STROP

TIN2:	CALL GETC
	CAIN T,"A"-100
	JRST TINCA		;^A
	CAIN T,"V"-100
	CALL TINCV		;^V
	IDPB T,STRIP		;STORE IT IN BUF
	MOVE T,STRIP
	CAMN T,[POINT 7,STRBUF+STRBFL-1,34]
	 JRST ERR		;BUFFER FULL

TIN3:	LDB T,STRIP		;GET BACK THE CHR
	CAIL T,"A"
	CAILE T,"Z"
	CAIA
	 JRST TIN2		;UPPERCASE LETTER, KEEP GOING
	CAIL T,"A"+40
	CAILE T,"Z"+40
	CAIA
	 JRST TIN2		;LOWERCASE LETTER
	CAIL T,"0"
	CAILE T,"9"
	CAIA
	 JRST TIN2
TIN4:	ILDB T,STROP		;RETURN NEXT CHR FROM BUFFER
TIN5:	CAIN T,37
	MOVEI T,15		;EOL BECOMES CR ON WAY OUT
	RET

TIN6:	CALL GETC
	JRST TIN5

;CONTROL V (QUOTE NEXT CHARACTER)
TINCV:	TYI			;CHARACTER INTO 1
	MOVE T,1
	CAIE T,33
	 RET
	MOVEI T,"$"
	CALL TOUT		;ECHO $ FOR ALTMODE
	MOVEI T,33
	RET

;CONTROL A (DELETE PREVIOUS CHARACTER)
TINCA:	MOVE T,STRIP
	CAME T,STROP
	 JRST TINCA1		;BUFFER NOT EMPTY
	MOVEI T,7		;DING
	CALL TOUT
	JRST TIN2

TINCA1:	MOVEI T,"\"
	CALL TOUT
	LDB T,STRIP
	CALL TOUT
	SOS STRIP		;UNDEX BYTE PTR
	REPEAT 4,<IBP STRIP>
	JRST TIN2

;INPUT FROM STRING AT BPT
TINST:	ILDB T,STRING
	JUMPN T,TINST1		;NOT END OF STRING
	SETZM STRING		;SAY NO MORE
	JRST TIN0		;GET FROM TTY

TINST1:	CAIE T,33
	CALL TOUT		;SAY WHAT WE READ
	JRST GOTC


;GET CHARACTER AND CHECK FOR ESCAPE CHR
GETC:	TYI
	MOVE T,1
GOTC:	CAIE T,33
	JRST GETC2
	MOVEI T,"$"
	CALL TOUT
	MOVEI T,33
GETC2:	CAIE T,177
	CAMN T,ESCCHR
	 JRST WRONG
	RET

BITO:	MOVEI	R,BITT		;BYTE OUTPUT SUBROUTINE
	HRRZI	AR,TOC
	TRZN	F,Q2F
	JRST	ERR
	MOVE	T,WRD2
	MOVEM	T,SVBTS
	MOVEI	T,^D36
	IDIV	T,WRD2
	SKIPE	T+1
	ADDI	T,1
	MOVEM	T,SVBTS2
	HRRZ	SCH,R
	JRST	BASE1

BITT:	MOVE	T,SVBTS2
	MOVEM	T,SVBT2
	MOVE	T+1,LWT
	MOVEM	T+1,SVBT3
	PUSH P,LWT
BITT2:	MOVEI	T,0
	MOVE	T+2,SVBTS
	LSHC	T,(T+2)
	MOVEM	T,LWT
	MOVEM	T+1,SVBT3
	CAIE	AR,PADSO
	PUSHJ	P,TOCA
	CAIE	AR,TOC
	PUSHJ	P,PIN
	SOSG	SVBT2
	JRST BITT4
	MOVEI	T,","
	PUSHJ	P,TOUT
	MOVE	T+1,SVBT3
	JRST	BITT2

BITT4:	POP P,LWT
	RET

;TYPE OP CODE OF INSTR IN LWT
;OP CODE EVALUATER.  TXT, TXT+1 HAVE 6 OR LESS ASCII
; CHARACTERS PACKED WITH A 7 BIT IDPB.  JSYS TABLE HAS SAME
; FORMAT WITH THE JSYS NUMBER IN THE RIGHT 9 BITS OF THE 2ND WORD.
OPEVAL:	MOVE S,[<JSYTAB-JSYEND>,,0]
OPTRY:	MOVE T,JSYTAB+0(S)	;FIRST WORD OF THIS ENTRY
	HLLZ TT,JSYTAB+1(S)	;SECOND
	CAMN T,TXT
	CAME TT,TXT+1
	JRST OPENXT
	HRRZ T,JSYTAB+1(S)	;FOUND. GET NUMBER
	HRLI T,(JSYS 0)		;MAKE INTO JSYS
	JRST CPOPJ1		;SKIP RETURN

OPENXT:	AOBJP S,.+1
	AOBJN S,OPTRY		;TRY NEXT ENTRY IN JSYSTABLE


OLDOEV:	MOVEI T,0		;NOT A JSYS SO DO USUAL OP EVAL
	IDPB T,CHP		;INSERT NULL IN TEXT FOR SYMBOL
	MOVEM P,SAVPDL
	TRZA F,OUTF
OPTYPE:	TRO F,OUTF		;TYPE AN OPCODE SYMBOLICALLY
	LSH T,-33
	MOVEM T,INST		;GET OPCODE INTO RIGHT 9 BITS
	MOVE T,[POINT 7,TXT]
	MOVEM T,CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	TRZ F,ITF		;CLEAR INSTRUCTION TYPED FLAG
	CLEARB R,W1
	MOVE W2,BTAB
DC1:	ILDB T,W2		;GET NEXT BYTE IN TBL
	CAILE T,40
	CAIL T,73
	SOJGE R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG R,DC1		;SKIP OVER ALPHA TEXT WITHOUT COUNTING
	SUBI T,40
	JUMPE T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG T,DC2
	DPB T,[340500,,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ T,-4
	AOS T
	DPB T,[300600,,PNTR]
	TRNN F,OUTF
	JRST DC6		;FOR OPEVAL ONLY
	LDB R,PNTR		;GET # BYTES TO SKIP OVER
	JRST DC1

DC2:	HRREI T,-33(T)
	JUMPL T,DECT		;TYPE OUT A LETTER
	MOVEI W1,FIR.(T)	;BYTE IS A TRANSFER
	IDIVI W1,4
	MOVE W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI W2,(W1)
	JRST DC1

DECT:	TRNE F,OUTF
	JRST DC8		;TYPE OUT A LETTER
	ILDB W1,CHP		;GET NEXT INPUT LETTER
	CAIE W1,133(T)		;COMPARE WITH ASSUMED NEXT LETTER
	JRST NOMAT		;DOESNT MATCH
	JRST DC1		;MATCHES, TRY NEXT

DECX:	TRNE F,OUTF		;STOP (CODE 40) HAS BEEN SEEN
	RET			;IF FOR OUTPUT, RETURN
	ILDB W1,CHP		;GET NEXT INPUT CHAR IF ANY
	JUMPE W1,DC7		;DOES # OF CHARS MATCH
NOMAT:	POP P,R			;NO, BACK UP AND TRY SOME MORE
	POP P,W2
	POP P,PNTR
	POP P,CHP
NOMAT1:	AOS R			;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB R,PNTR		;STUFF INTO ANSWER
	LDB R,PNTR
	JUMPN R,DC6AA		;IF =0, BYTE WAS TOO BIG
	CAME P,SAVPDL
	JRST NOMAT		;NOT AT TOP LEVEL
	RET			;UNDEFINED, FINALLY

DC6:	MOVEI R,0		;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB R,PNTR
DC6AA:	CAMN P,SAVPDL
	JRST DC6BB
	LDB T,-2(P)		;OLD VALUE OF PNTR
	CAME T,(P)
	JRST NOMAT1
DC6BB:	PUSH P,CHP
	PUSH P,PNTR
	PUSH P,W2
	PUSH P,R
	JRST DC1

DC7:	MOVE P,SAVPDL		;RESTORE PUSH DOWN POINTER
	MOVE T,INST
	LSH T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	LDB R,[POINT 3,T,8]
	TLC T,700000
	TLCN T,700000
	DPB R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST CPOPJ1		;SYMBOL FOUND, SKIP RETURN

DC8:	TRO F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI T,133(T)
	CALL TOUT		;OUTPUT A LETTER
	SETZM SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST DC1

	SUBTTL CONTROL-T INTERRUPT HANDLER

CT.PSI:	PUSH P,TEM
	PUSH P,TEM1
	PUSH P,SVFB
	PUSH P,SVTB
	PUSH P,SPSAV
	PUSH P,BLVL
	ADD P,[20,,20]
	JUMPGE P,CT.PSY
	MOVEM 0,-17(P)
	HRLI 0,1
	HRRI 0,-16(P)
	BLT 0,0(P)

CT.PS1:	MOVEI 1,-1		;CTY:
	RFCOC
	PUSH P,2
	PUSH P,3
	MOVE 2,TTYCC2
	MOVE 3,TTYCC3
	SFCOC			;SETUP TTY FOR IDDT

CT.PS2:	CALL CRF
	CALL FSTAT
	CALL LOADAV
	CALL USED		;RETURNS DELTA CPU AND CONSOLE IN 1,2
	CALL ACTIVY
	CALL CRF

CT.PS9:	POP P,3
	POP P,2
	MOVEI 1,-1
	SFCOC

CT.PSX:	HRLI 0,-16(P)
	HRRI 0,1
	BLT 0,17
	MOVE 0,-17(P)
CT.PSY:	SUB P,[20,,20]
	POP P,BLVL
	POP P,SPSAV
	POP P,SVTB
	POP P,SVFB
	POP P,TEM1
	POP P,TEM
	DEBRK

;DO FORK STATUS FOR INFERIOR

FSTAT:	MOVE 1,FORK
	RFSTS
	HLRZ 3,1
	CAIN 3,-1
	 JRST FSTATD
	PUSH P,2		;SAVE THE PC FOR LATER

FSTAT1:	TRZ 3,(1B0)		;FROZEN BIT
	CAIN 3,6
	 JRST FSTAT2
	CAIE 3,2
	CAIN 3,3
FSTAT2:	TLZ 1,(1B0)
	MOVE W1,[POINT 7,[ASCIZ /INT'D FROM /]]
	TLNE 1,(1B0)
	 CALL TYPE

FSTAT3:	MOVSI W1,(POINT 7,)
	HRR W1,[[ASCIZ /RUNNING/]
		[ASCIZ /IO WAIT/]
		[ASCIZ /HALT/]
		[ASCIZ /HALT: /]
		[ASCIZ /FORK WAIT/]
		[ASCIZ /SLEEP/]
		[ASCIZ /BREAKPOINT/]](3)
	CALL TYPE
	MOVE 1,WHY
	MOVE W1,MSG(1)
	CAIN 3,3
	 CALL TEXT2

FSTAT4:	MOVE W1,[ASCIZ / AT /]
	CALL TEXT
	POP P,T			;THE PC
	MOVEI T,0(T)		;ONLY THE PC BITS!
	CALL PAD
	RET


FSTATD:	MOVE W1,[POINT 7,[ASCIZ /FORK DISAPPEARED/]]
	CALL TYPE
	RET

;TYPE THE LOAD AVERAGE

LOADAV:	MOVE 1,['SYSTAT']
	SYSGT
	MOVSI 1,14
	HRRI 1,0(2)
	GETAB
	 RET
	PUSH P,1
	CALL LCT		;PRINT TAB

LOADA1:	MOVE W1,[ASCIZ /  LA=/]
	CALL TEXT
	MOVEI 1,-1
	POP P,2
	MOVE 3,[00B1!00B3!1B4!1B6!00B8!1B11!04B17!04B23!02B29]
	FLOUT
	 JFCL
	RET



;TYPE TIME USED ETC SINCE LAST RESET
; RETURNS  DELTA CPU TIME IN 1 AND DELTA CONSOLE TIME IN 2

USED:	CALL LCT
	MOVNI 1,5
	RUNTM
	SUB 1,TIMUSD
	PUSH P,1		;CPU
	PUSH P,2		;TICK/SEC
	SUB 3,TIMCON
	PUSH P,3		;CONSOLE

USED1:	MOVE W1,[ASCIZ /USED /]
	CALL TEXT
	MOVE T,-2(P)
	MOVE TT,-1(P)
	CALL TIMPRT

USED3:	MOVE W1,[ASCIZ / IN /]
	CALL TEXT
	MOVE T,0(P)
	MOVE TT,-1(P)
	CALL TIMPRT

USEDX:	POP P,2
	SUB P,[1,,1]
	POP P,1
	RET

;TIME PRINTER

;	T:	TIME TO BE PRINTED IN SECONDS
;	TT:	NUMBER OF TICKS PER SECOND

TIMPRT:	PUSH P,T
	PUSH P,TT
	IDIVI T,0(TT)		;GET SECONDS
	PUSH P,T+1
	CALL TOC4		;DECIMAL PRINT OF T, WITH "."

TIMPR1:	MOVE 1,-1(P)
	IDIVI 1,^D10		;TICKS PER 1/10 TH OF A SECOND
	MOVE T,0(P)		;FRACTION OF SEC IN TICKS
	IDIVI T,0(1)		;FIND OUT HOW MANY TENTHS
	ADDI T,"0"		;ASCIIFICATE
	CALL TOUT
	SUB P,[3,,3]
	RET

;PRINT THE ACTIVITY INDEX

;	THIS IS THE RATIO OF CONSOLE TIME TO CPU TIME FOR THE JOB.
;	THUS IF THERE IS ONE FORK JRST'ING POINT ON A MACHINE WITH
;	NO OVERHEAD, THE RATIO SHOULD BE EXACTLY 1.0  .
;	ANOTHER JOB ALSO JRST'ING POINT WILL CAUSE THIS JOB TO
;	GET 1/2 OF THE MACHINE AND THE ACTIVITY INDEX WILL BE 2.0  .
;	OVERHEAD DUE TO JOB0 AND INTERRUPTS ETC CAUSE THE USER TO
;	NEVER BE ABLE TO GET ALL OF THE MACHINE, SO THE INDEX
;	WILL ALWAYS BE HIGHER THAN "PERFECT".

;	N.B.:  ACTIVITY INDEX IS WHAT LOAD AVERAGE PROBABLY SHOULD BE.

;AT ENTRY	1:	DELTA CPU USE
;		2:	DELTA CONSOLE TIME

ACTIVY:	PUSH P,1
	PUSH P,2
	CALL LCT
	MOVE W1,[ASCII /AR=/]
	CALL TEXT
	POP P,2
	POP P,1
	FSC 1,233
	FSC 2,233
	FDVR 2,1
	MOVEI 1,-1
	MOVE 3,[00B1!00B3!1B4!1B6!00B8!1B11!4B23!2B29]
	FLOUT
	 JFCL
	RET

;READ-ONLY AREA
RO:
;INTERNAL REGISTER MAP
;LH HAS POINTER TO TEXT FOR NAME
;RH HAS POINTER TO VALUE
DEFINE	INTDIS (X) <
	$'X'B+6,,$'X'B>

	QZ==1
	RADIX 10
INTTAB:	REPEAT NBP,<
	INTDIS \QZ
	QZ==QZ+1>
	RADIX 8
	[ASCIZ /$X/],,XRG
	[ASCIZ /$G/],,PC
	[ASCIZ /$W/],,TRAPWD
	[ASCIZ /$M/],,MSK
	[ASCIZ /$I/],,USRPSI
INTEND:


	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1



BDISP:	POINT 12,DISP(R),11
	POINT 12,DISP(R),23
	POINT 12,DISP(R),35


DEFINE D (Z1,Z2,Z3)<
IFG <Z1-DDT-7777>,<PRINTX Z1 TOO FAR FROM DDT>
IFG <Z2-DDT-7777>,<PRINTX Z2 TOO FAR FROM DDT>
IFG <Z3-DDT-7777>,<PRINTX Z3 TOO FAR FROM DDT>
<Z1-DDT>_30+<Z2-DDT>_14+Z3-DDT>
	;THIS MACRO PACKS 3 ADDRESSES INTO ONE WORD
	; EACH ADR IS 12 BITS, RELATIVE TO DDT

DISP:	
D ERR,ERR,ERR		;-    -    -
D ERR,ERR,ERR		;-    -    -
D ERR,ERR,VARRW		;-    -    BACKSPACE(^H)
D TAB,LINEF,ERR		;TAB LINEFEED  -
D ERR,CARR,ERR		;-  CARRIAGE RETURN   -
D ERR,ERR,ERR		;-    -    -
D ERR,ERR,ERR		;-    -    -
D ERR,ERR,ERR		;-    -    -
D ERR,ERR,ERR		;-    -    -
D CONTROL,ERR,ERR	;ESCAPE  -   -
D ERR,ERR,SPACE		;-    -   SPACE
D SUPTYO,TEXI,ASSEM	;!    "    #
D DOLLAR,PERC,SETBLK	;$    %    &
D DIVD,LPRN,RPRN	;'    (    )
D MULT,PLUS,ACCF	;*    +    ,
D MINUS,PERIOD,SLASH	;-    .    /
D NUM,NUM,NUM		;0    1    2
D NUM,NUM,NUM		;3    4    5
D NUM,NUM,NUM		;6    7    8
D NUM,TAG,SEMIC		;9    :    ;
D FIRARG,EQUAL,ULIM	;<    =    >
D QUESTN,INDIRECT,ABSA	;?    @    A
D BPS,CON,SYMD		;B    C    D
D EFFEC,SFLOT,GO	;E    F    G
D HWRDS,INTRUP,ERR	;H    I    J
D KILL,LOADER,MASK	;K    L    M
D NWORD,BITO,PROCEDE	;N    O    P
D QUAN,RELA,SYMBOL	;Q    R    S
D TEXO,UNPRO,LEFT	;T    U    V
D WORD,XEC,ERR		;W    X    Y
D ZERO,OCON,ICON	;Z    [    \
D OSYM,VARRW,PSYM	;]    ^    _

;SEMICOLON DISPATCH
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,ERR			;-    -    -
D ERR,ERR,SEMSPA		;-    -  SPACE
D ERR,ERR,ERR			;!    "    #
D ERR,ERR,ERR			;$    %    &
D ERR,ERR,ERR			;'    (    )
D ERR,ERR,ERR			;*    +    ,
D ERR,ERR,ERR			;-    .    /
D NUM,NUM,NUM			;0    1    2
D NUM,NUM,NUM			;3    4    5
D NUM,NUM,NUM			;6    7    8
D NUM,ERR,SEMIC			;9    :    ;
D ERR,EQUAL,ERR			;<    =    >
D SEM.QU,INDIRECT,ADRSPC	;?    @    A
D ERR,ERR,ERR			;B    C    D
D ESCAP,FRKST,ERR		;E    F    G
D HALT,ERR,ERR			;H    I    J
D ERR,LOADGO,MERGE		;K    L    M
D ERR,OBTAIN,PATCH		;N    O    P
D ERR,RDX50,SNARF		;Q    R    S
D ERR,UNLOAD,ERR		;T    U    V
D SYMSOT,ERR,YANK		;W    X    Y
D ERR,ERR,ERR			;Z    [    \
D ERR,ERR,ERR			;]    ^    _

;DESCRIPTION OF OP DECODER FOR DDT:
;
;THE ENTIRE INSTRUCTION SET FOR THE PDP-10 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-10.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;
;0-37(8)
;       THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INST.  N+1 IS THE NUMBER OF BITS IN INST WHICH ARE
;       TO BE CONSIDERED.  P GIVES THE
;	POSITION (NUMBER OF BITS FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;	C(INST) = .010 101 100(2)
;
;	THE RESULT = D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT, 41-72(8)) ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.

;41(8)-72(8)      THE ALPHABET IS ENCODED INTO THIS RANGE.
;	        41- A
;	        42- B
;	        72- Z
;	        WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	        LETTER IS TYPED.
;
;73(8)-777(8)     THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	        CONSIDERED TO BE A, TRANSFER INTERPRETATION
;		TO THE A-73(8) BYTE IN THE TABLE.
;
;MACROS TO ASSEMBLE THE OPCODE TREE
;
;.TRA FOO	CAUSES INTERPRETER TO TRANSFER TO THE POINT IN THE
;		TREE TAGGED "FOO".
;
;.ADR FOO	CAUSES THIS POINT IN THE TREE TO BE TAGGED "FOO".
;
;.END 		MARKS A LEAF (A DEEPEST POINT) IN THE TREE. 
;		INTERPRETATION RESUMES AT THE NEXT HIGHEST
;		BRANCH.
;
;.TXT STUFF	CAUSES THE TEXT "STUFF" TO BE PACKED AS ONE ASCII
;		CHARACTER PER 9-BIT BYTE IN THE TREE.  THE
;		INTERPRETER TAKES NO ACTION IF IT ENCOUNTERS TEXT.
;
;.DIS MN	WHERE M AND N ARE TWO ONE-DIGIT INTEGERS.  M IS THE
;		NUMBER OF BITS TO THE RIGHT OF THE FIELD OF INTEREST.
;		N  IS THE NUMBER OF BITS TO CONSIDER.  FOR INSTANCE
;		.DIS 63  WILL CONSIDER THE LEFT THREE BITS OF A 9-BIT
;		OPCODE STORED IN  INST.  THE INTERPRETER DISPATCHES
;		0 TO 7 BYTES TO THE RIGHT DEPENDING ON THE VALUE
;		OF THE SELECTED FIELD.
;
;
;WHEN USED TO LOOKUP AN OPCODE (OPEVAL),  THE INTERPRETER
;OPERATES BY TYPING OUT ALL OPCODES A CHARACTER AT A TIME,
;CHECKING EACH CHARACTER FOR EQUALITY AGAINST THE KEY THAT IS
;BEING LOOKED UP.  THUS, TO LOOK UP "JRST", THE INTERPRETER
;TRIES ALL TOP LEVEL BRANCHES UNTIL IT FINDS ONE WHICH WILL TYPE OUT
;A "J",  AND THEN PROCEEDS TO SEE IF THE REST OF THAT BRANCH WILL
;TYPE OUT  "RST".  ETC.

SUBTTL	OP DECODER

DEFINE BYT9 (A) <IRP A,<
A>>

IF1,<

DEFINE	.ADR	(A) <
%'A==	CLOC
FIR.==	CLOC
DEFINE	.ADR	(X) <
%'X==	CLOC
IFGE	<LASTB==CLOC+73-FIR.>-1000, <PRINTX OPTABLE TOO LONG>>>

DEFINE	.TRA	<
CLOC==	CLOC+1 ;>

SYN	.TRA,	.DIS

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>
CLOC==	CLOC+1>

>	;END OF IF1
IF2,<

DEFINE .ADR (A)<IFN %'A-CLOC,<PRINTX PHASE ERR AT: %'A>>

DEFINE	.TRA	(A) <
OUTP	%'A+73-FIR.>

DEFINE	.DIS	(A) <
OUTP	A&70/2+A&7-1>

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>
OUTP	40>

DEFINE OUTP (A)<
BINRY==	BINRY+<A>_<BINC==BINC-9>
IFE BINC, <
		+BINRY
BINRY==0
BINC==^D36 >
CLOC==CLOC+1 >

>

TBL:  ;OPDECODER BYTE TABLE

BINRY== 0
CLOC== 0 ;SET BYTE LOCATION COUNTER TO 0
BINC== ^D36 ;INIT BYTES/WORD COUNTER

;**********THE ARGUMENT FOR THE FOLLOWING "BYT9" MACRO
;**************TERMINATES AT THE NEXT COMMENT WITH: **************

BYT9 <

.DIS 63,.END,.TRA FLO,.TRA HAK,.TRA ACCP,.TRA BOOLE
	.TXT H,.TRA HWT,.TXT T,.TRA ACBM


;IO INSTRUCTIONS

.DIS 21,.TRA BD,.TXT CON,.DIS 11,.TRA OI,.TXT S,.DIS 01,.TRA Z,.TRA O
.ADR BD,.DIS 01,.TXT BLK,.TRA IO,.TXT DATA,.ADR IO,.DIS 11,.TRA I,
	.ADR O,.END O,.ADR OI,.DIS 01,.TRA O,.TRA I
;UUOS

.ADR F,.END F,.ADR Z,.END Z

;BYTE AND FLOATING INSTRUCTIONS

.ADR FLO,.DIS 51,.TRA BYTE,.TXT F,.DIS 32,.TXT,.TXT AD,.TRA A,.TXT SB
	.TRA A,.TXT MP,.TRA A,.TXT DV,.ADR A
.DIS 21,.TRA LMB,.TXT R,.TRA IMB,.ADR LMB,.DIS 02,.END,.TXT
	.ADR L,.END L,.TXT,.ADR M,.END M,.TXT
.ADR B,.END B,.TXT,.ADR BYTE,.DIS 32,.TRA BBN,.END,.END,.TXT
	.DIS 03,.TXT UF,.TRA PA,.TXT DF,.TRA N
.TXT FS,.TRA C,.TXT IB,.ADR P,.END P,.TXT,.TXT I,.TRA LD
	.ADR LD,.TXT LD,.TRA B,.TXT I,.TRA DP,.ADR DP,.TXT DP,.TRA B

;BBN ADDED INSTRUCTIONS

.ADR BBN,.DIS 21,.TXT U,.TRA MV,.DIS 02,.TRA JSY,
	.END,.END,.END,.ADR JSY,.TXT JSYS,.END

;FWT-FIXED POINT ARITH-MISC

.ADR HAK,.DIS 33,.TRA MV,.ADR MV,.TXT MOV,.TRA MO,.TRA ML,.TRA DV
	.TRA SH,.TRA H1,.TRA JP
.DIS 21,.TXT ADD,.TRA IMB,.TXT SU,.ADR BIMB,.TXT B,.ADR IMB,.DIS 02,.END,.TXT
	.ADR I,.END I,.TXT,.TRA M,.TRA B,.ADR MO,.DIS 22
.ADR EIMS,.TXT E,.TRA IMS,.TXT S,.TRA IMS,.TXT N,.TRA IMS,.TXT M
	.ADR IMS,.DIS 02,.END,.TXT,.TRA I,.TRA M,.ADR S,.END S,.TXT
.ADR ML,.DIS 21,.TXT I,.TRA ML1,.ADR ML1,.TXT MUL,.TRA IMB
	.ADR DV,.DIS 21,.TXT I,.TRA DV1
.ADR DV1,.TXT DI,.ADR DV2,.TXT V,.TRA IMB,.ADR H1,.DIS 03,.TXT EXC,.TRA S3,.TXT BL
	.ADR T,.END T,.TXT,.TRA AO,.ADR AO,.TXT AOBJ
.TRA AOB,.TXT JRS,.TRA T,.TXT JFC,.TRA L,.TXT XC,.TRA T,.END
	.ADR AOB,.DIS 01,.TRA P,.TRA N
.ADR JP,.DIS 03,.TRA PU,.ADR PU,.TXT PUSH,.TRA PUS,.TRA PO
	.ADR PO,.TXT POP,.TRA POP,.TXT JS,.ADR R,.END R,.TXT
.TXT JS,.TRA P,.TXT JS,.ADR PA,.END A,.TXT,.TXT JR,.TRA PA
	.ADR PUS,.DIS 01,.ADR J,.END J,.END,.TXT,.ADR POP
.DIS 01,.END,.TXT,.TRA J,.ADR SH,.DIS 02,.TXT A,.TRA S2,.TXT ROT,.TRA S1,.TXT L
	.ADR S2,.TXT S,.ADR S3,.TXT H,.TRA S1,.TXT JFF,.TRA O
	.ADR S1,.DIS 21,.END,.TXT,.ADR C,.END C,.TXT

;ARITH COMP-SKIP-JUMP

.ADR ACCP,.DIS 42,.TXT CA,.TRA CA1,.TRA SJ,.TXT A,.TRA JS,.TXT S
	.ADR JS,.TXT O,.DIS 31
.TXT J,.TRA COMP,.TXT S,.TRA COMP,.ADR CA1,.DIS 31,.TXT I,.TRA COMP,.TXT M,.TRA COMP
.ADR SJ,.DIS 31,.TXT JUM,.TRA PSJ,.TXT SKI,.ADR PSJ,.TXT P,.ADR COMP
.DIS 03,.END,.TXT,.TRA L,.ADR E,.END E,.TXT,.TXT L,.TRA E,.TRA PA,.TXT G,.TRA E
	.ADR N,.END N,.TXT,.END G,.TXT

;HALF WORDS

.ADR HWT,.DIS 51,.TRA HW1,.DIS 21,.TXT R,.TRA HW2,.TXT L,.ADR HW2,.TXT R,.TRA HW3
.ADR HW1,.DIS 21,.TXT L,.TRA HW4,.TXT R,.ADR HW4,.TXT L
	.ADR HW3,.DIS 32,.TRA IMS,.TXT Z,.TRA IMS,.TXT O,.TRA IMS,.TRA EIMS

;TEST INSTRUCTIONS

.ADR ACBM,.DIS 31,.TRA AC1,.DIS 01,.TXT D,.TRA AC2,.TXT S,.TRA AC2
	.ADR AC1,.DIS 01,.TXT R,.TRA AC2,.TXT L
.ADR AC2,.DIS 42,.TXT N,.TRA EAN,.TXT Z,.TRA EAN,.TXT C,.TRA EAN,.TXT O
	.ADR EAN,.DIS 12,.END,.TXT,.TRA E,.TRA PA,.TRA N

;BOOLEAN

.ADR BOOLE,.DIS 24,.TRA ST,.ADR AN,.TXT AND,.TRA B2,.TRA AN,.TRA ST,.TRA AN,.TRA ST
.TXT X,.ADR OR,.TXT OR,.TRA B2,.TXT I,.TRA OR,.TRA AN,.TXT EQ
	.TRA DV2,.TRA ST,.TRA OR,.TRA ST,.TRA OR,.TRA OR
.ADR ST,.TXT SET,.ADR B2,.DIS 24,.TXT Z,.TRA IMB,.TRA IMB
	.ADR CA,.TXT C,.TRA TA,.ADR TM,.TXT M,.TRA IMB
.ADR CM,.TXT C,.TRA TM,.ADR TA,.TXT A,.TRA IMB,.TRA IMB,.TRA IMB
	.ADR CB,.TXT C,.TRA BIMB,.TRA IMB,.TRA CA
.TRA CA,.TRA CM,.TRA CM,.TRA CB,.TXT O,.TRA IMB

;**********THIS TERMINATES THE "BYT9" MACRO ARGUMENT******
>


IF1,<	BLOCK	<CLOC+3>/4>

IF2,<	IFN BINC-^D36,<	+BINRY>>



IFNDEF CLOC.,<CLOC.==CLOC>
IFN CLOC.-CLOC,<PRINTX PHASE ERROR IN OPTABLE>

BTAB:	POINT 9,TBL	;TABLE USED TO GET NEXT BYTE POINTER
	POINT 9,TBL,8	;FOR TRANSFER BYTE
	POINT 9,TBL,17
	POINT 9,TBL,26
FSGN:	ASCII .E-.
	ASCII .E+.

;JSYS INSTRUCTIONS

DEFINE DEFJS (NAME,NUM)<
	ASCII /'NAME'/
	NUM>


JSYTAB:
DEFJS LOGIN,1
DEFJS CRJOB,2
DEFJS LGOUT,3
DEFJS CACCT,4
DEFJS EFACT,5
DEFJS SMON,6
DEFJS TMON,7
DEFJS GETAB,10
DEFJS ERSTR,11
DEFJS GETER,12
DEFJS GJINF,13
DEFJS TIME,14
DEFJS RUNTM,15
DEFJS SYSGT,16
DEFJS GNJFN,17
DEFJS GTJFN,20
DEFJS OPENF,21
DEFJS CLOSF,22
DEFJS RLJFN,23
DEFJS GTSTS,24
DEFJS STSTS,25
DEFJS DELF,26
DEFJS SFPTR,27
DEFJS JFNS,30
DEFJS FFFFP,31
DEFJS RDDIR,32
DEFJS CPRTF,33
DEFJS CLZFF,34
DEFJS RNAMF,35
DEFJS SIZEF,36
DEFJS GACTF,37

DEFJS STDIR,40
DEFJS DIRST,41
DEFJS BKJFN,42
DEFJS RFPTR,43
DEFJS CNDIR,44
DEFJS RFBSZ,45
DEFJS SFBSZ,46
DEFJS SWJFN,47
DEFJS BIN,50
DEFJS BOUT,51
DEFJS SIN,52
DEFJS SOUT,53
DEFJS RIN,54
DEFJS ROUT,55
DEFJS PMAP,56
DEFJS RPACS,57
DEFJS SPACS,60
DEFJS RMAP,61
DEFJS SACTF,62
DEFJS GTFDB,63
DEFJS CHFDB,64
DEFJS DUMPI,65
DEFJS DUMPO,66
DEFJS DELDF,67
DEFJS ASND,70
DEFJS RELD,71
DEFJS CSYNO,72
DEFJS PBIN,73
DEFJS PBOUT,74
DEFJS PSIN,75
DEFJS PSOUT,76
DEFJS MTOPR,77
DEFJS CFIBF,100
DEFJS CFOBF,101
DEFJS SIBE,102
DEFJS SOBE,103
DEFJS DOBE,104
DEFJS GTABS,105
DEFJS STABS,106
DEFJS RFMOD,107
DEFJS SFMOD,110
DEFJS RFPOS,111
DEFJS RFCOC,112
DEFJS SFCOC,113
DEFJS STI,114
DEFJS DTACH,115
DEFJS ATACH,116
DEFJS DVCHR,117

DEFJS STDEV,120
DEFJS DEVST,121
DEFJS MOUNT,122
DEFJS DSMNT,123
DEFJS INIDR,124
DEFJS SIR,125
DEFJS EIR,126
DEFJS SKPIR,127
DEFJS DIR,130
DEFJS AIC,131
DEFJS IIC,132
DEFJS DIC,133
DEFJS RCM,134
DEFJS RWM,135
DEFJS DEBRK,136
DEFJS ATI,137
DEFJS DTI,140
DEFJS CIS,141
DEFJS SIRCM,142
DEFJS RIRCM,143
DEFJS RIR,144
DEFJS GDSTS,145
DEFJS SDSTS,146
DEFJS RESET,147
DEFJS RPCAP,150
DEFJS EPCAP,151
DEFJS CFORK,152
DEFJS KFORK,153
DEFJS FFORK,154
DEFJS RFORK,155
DEFJS RFSTS,156
DEFJS SFORK,157
DEFJS SFACS,160
DEFJS RFACS,161
DEFJS HFORK,162
DEFJS WFORK,163
DEFJS GFRKH,164
DEFJS RFRKH,165
DEFJS GFRKS,166
DEFJS DISMS,167
DEFJS HALTF,170
DEFJS GTRPW,171
DEFJS GTRPI,172
DEFJS RTIW,173
DEFJS STIW,174

DEFJS SOBF,175
DEFJS RWSET,176
DEFJS GETNM,177
DEFJS GET,200
DEFJS SFRKV,201
DEFJS SAVE,202
DEFJS SSAVE,203
DEFJS SEVEC,204
DEFJS GEVEC,205
DEFJS GPJFN,206
DEFJS SPJFN,207
DEFJS SETNM,210
DEFJS FFUFP,211
DEFJS DIBE,212
DEFJS FDFRE,213
DEFJS GDSKC,214
DEFJS LITES,215
DEFJS TLINK,216
DEFJS STPAR,217
DEFJS ODTIM,220
DEFJS IDTIM,221
DEFJS ODCNV,222
DEFJS IDCNV,223
DEFJS NOUT,224
DEFJS NIN,225
DEFJS STAD,226
DEFJS GTAD,227
DEFJS ODTNC,230
DEFJS IDTNC,231
DEFJS FLIN,232
DEFJS FLOUT,233
DEFJS DFIN,234
DEFJS DFOUT,235

DEFJS CRDIR,240
DEFJS GTDIR,241
DEFJS DSKOP,242
DEFJS SPRIW,243
DEFJS DSKAS,244
DEFJS SJPRI,245

DEFJS ASNDP,260
DEFJS RELDP,261
DEFJS ASNDC,262
DEFJS RELDC,263
DEFJS STRDP,264
DEFJS STPDP,265
DEFJS STSDP,266
DEFJS RDSDP,267
DEFJS WATDP,270

DEFJS ATPTY,274
DEFJS CVSKT,275
DEFJS CVHST,276
DEFJS FLHST,277
DEFJS GCVEC,300
DEFJS SCVEC,301
DEFJS STTYP,302
DEFJS GTTYP,303
DEFJS BPT,304
DEFJS GTDAL,305
DEFJS WAIT,306
DEFJS HSYS,307
DEFJS USRIO,310
DEFJS PEEK,311
DEFJS MSFRK,312
DEFJS ESOUT,313
DEFJS SPLFK,314
DEFJS ADVIZ,315
DEFJS JOBTM,316
DEFJS DELNF,317
DEFJS SWTCH,320
DEFJS TFORK,321
DEFJS RTFRK,322
DEFJS UTFRK,323
JSYEND:


;LEVEL TABLE FOR INTERRUPTS FROM USER
LEVTAB:	IPC1
	IPC2
	IPC3

;CHANNEL TABLE FOR USER INTERRUPTS
CHNTAB:	2,,RUBOUT	;RUBOUT
	1,,CT.PSI	;^T INTERRUPT
	0,,ERR
	0,,ERR
	0,,ERR
	0,,ERR
	0,,ERR	;INTEGER OVERFLOW
	0,,ERR	;FLOATING POINT OVERFLOW
	0,,ERR
	0,,ERR	;PUSHDOWN OVERFLOW
	0,,ERR	;END OF FILE
	0,,ERR	;DATA TRANSMISSION ERROR
	0,,ERR
	0,,ERR
	0,,ERR	;TIME OF DAY
	0,,ERR	;ILLEGAL INSTRUCTION
	0,,ERR	;ILLEGAL MEMORY READ
	0,,ERR	;ILLEGAL MEMORY WRITE
	0,,ERR	;ILLEGAL MEMORY EXECUTE
	0,,ERR	;SUBSIDIARY FORK TERMINATION
	0,,ERR	;MACHINE SIZE EXCEEDED
	REPEAT CHNTAB+36-.,<0,,ERR>

;TRAP MESSAGE TABLE -- OFFSET BY 6, SEE TBRK
MSG=.-6
	ASCII /IOV:/	;INTEGER OVERFLOW
	ASCII /FOV:/	;FLOATING POINT OVERFLOW
	ASCII /XXX:/	;RUBOUT (FAKE BREAK)
	ASCII /POV:/	;PUSHDOWN OVERFLOW
	ASCII /EOF:/	;END OF FILE
	ASCII /DTE:/	;DATA TRANSMISSION ERROR
	ASCII /HUH?/	;HUH
	ASCII /HUH?/	; "
	ASCII /HUH?/	; "
	ASCII /ILL:/	;ILLEGAL INSTRUCTION
	ASCII /IMR:/	;ILLEGAL MEMORY READ
	ASCII /IMW:/	;ILLEGAL MEMORY WRITE
	ASCII /IMX:/	;ILLEGAL MEMORY EXECUTE
	ASCII /FKT:/	;SUBSIDIARY FORK TERMINATION
	ASCII /MSE:/	;MACHINE SIZE EXCEEDED


	LIT

;READ/WRITE/EXECUTE AREA
		QZQZ==<.+777>&777000
		DEPHASE
		RELOC QZQZ-IDDT+LOW
		PHASE QZQZ
RWX:
TBLK:	0
TEM:	0	;GENERAL TEMPORARY
BLOCK:	0
SVF:	0
SW1:	0
SVFB:	0
SVTB:	0
BLVL:	0	;CURRENT BLOCK LEVEL IN SYM TAB
WRD:	0	;VALUE OF EXPRESSION TYPED
WRD2:	0	;VALUE OF EXPRESSION TO RIGHT OF $
PRNC:	0	;PAREN COUNT
NPWR10:	0	;NEG POWER OF 10 DURING FRACTION PART OF FP NUM

FRASE:	0	;****DONT CHANGE ORDER, SEE  SEARC+3***********
SYL:	0	;NUMBER TYPED, TAKEN AS OCTAL
LWT:	0	;LAST WORD TYPED IN OR OUT
TEM2:	0
FRASE1:
TEM3:	0
DEN:	0	;NUMBER TYPED, TAKEN AS DECIMAL

PRGM:	0	;0 OR POINTER TO THIS PROGRAM'S SYMBOLS
ESTU:	0	;BEGINNING OF UNDEFINED SYMBOL TABLE
ESTUT:	0
FSV:	0
FH:	0
SYM:	0	;RADIX 50 SYMBOL BEING GATHERED
SPSAV:	0	;POINTER TO LAST SYMBOL TYPED
DEFV:	0	;DEFINITION VALUE FOR SYMBOLS, FA FOR SEARCH
ULIMIT:	0	;LA FOR SEARCH, ETC.
LLOC:	0	;TEMPORARY VALUE OF .
LLOCO:	0	;VALUE OF .
SAVLOC:	0	;THE ADR OF OLD REGISTER EXAMINATION SEQUENCE
PATLOC:	0	;LOCATION ON INSTRUCTION BEING PATCHED UPON
PATPNT:	0	;"." DURING A PATCH
STRING:	0	;0 OR POINTER TO STORED COMMAND STRING

STRIP:	0	;STRING BUFFER INPUT PTR
STROP:	0	;STRING BUFFER OUTPUT PTR
STRBUF:	BLOCK STRBFL

TIMUSD:	0	;CPU TIME USED AT LAST RESET
TIMCON:	0	;CONSOLE TIME USED AT LAST RESET

JFN:	0		;JFN FOR PROGRAM UNDER $L,$Y
IPC1:	0		;INTERRUPT PC'S
IPC2:	0
IPC3:	0
SYMPTR:	0,,HOME		;INITIAL (EMPTY) SYM. TAB. PTR.


;THE USER'S TTY STATE
SAVTTY:	0
SAVTT2:	0		;TTY CONTROL CHARACTER MODES
SAVTT3:	0
USRTB2:	0		;TTY TAB SETTINGS
USRTB3:	0
USRTB4:	0

;DDT'S TTY STATE (CHANGE TTYCC2,3 MEAN CHANGE TO LITERAL AFTER ESCAP2)
TTYCC2:	BYTE (2) 0,0,1,1,1,1,1,2,0,0,2,1,1,2,1,1,1,1
TTYCC3:	BYTE (2) 1,1,0,1,1,1,1,1,1,0,1,1,1,2
DDTTB2:	401002,,4010	;IDDT'S TTY TAB SETTINGS
DDTTB3:	20040,,100200
DDTTB4:	401002,,4010

TOCS:	MOVEI T,.-.	;GET RIGHT HALF BACK
SEAR2:	JUMPE T,SEAR3	;OR JUMPN T,SEAR3
ACCCF:	MOVEI T,.-.	;LEFT HALF OF A,,B

BPTFLG:	0		;ADDR OF BPT BLK IF A $P WILL BE FROM A BPT
QLPNT:	0		;USED IN ? COMMAND AS PTR
			;0 IF IT WILL BE FROM ILLINST OR RUBOUT
USRFLG:	-1		;-1 WHILE USER RUNNING, >=0 IF IN DDT
LASTPG:	0		;ACCESS,,PAGE  CURRENTLY MAPPED IN
IDPACS:	0		;ACCESS SEEN BY IDDT.  .GE. LASTPG
REALPC:	0		;WHAT FORK'S PC SHOULD BE WHEN NEXT RUN

;ESCAPE CHARACTER CONTROL
ESCCHR:	177		;THE ASCII CHARACTER
ESCCOD:	^D28		; AND TERM CODE (RUBOUT INITIALLY)
SAVCOC:	00		;SAVED CCOC (2-BIT) FIELD
COCPTR:	POINT 2,TTYCC3,19	;POINTER TO ABOVE FIELD


;DEFAULT VALUES FOR FILE GTJFN'S
DEFALT:	0		;OR 1B0
	100,,101
	0
	0
	0
	0		;SYMBOLS OR SAV
	0
	0
	0

;INTERNAL REGISTERS


;BREAK POINTS
DEFINE BPTBLK(Z.)<
$'Z.'B:	0
	0
	0
	0
	0
	0
	ASCIZ /$'Z.'B/
>
	RADIX 10


FRSTIR==.		;MARKS BEGINNING OF INTERNAL  REGISTER LIST
	QZ==1
BPTS:	REPEAT NBP,<BPTBLK \QZ
	QZ==QZ+1>
NBPTV==<.-BPTS>/NBP	;NUMBER OF BPT VARIABLES
	RADIX 8
TRAPWD:	0		;TRAP STATUS WORD
WDATA:	0		;WRITE DATA DURNING INSTR TRAP
XRG:	20		;LOCATION WHERE $X IS DONE
PC:	0		;INDICATED USER'S PC
MSK:	-1,,-1		;MASK FOR SEARCHES
USRPSI:	0
	0
	0
	0
FORK:	-1		;FORK HANDLE OF USER
SUBSYS:	'(PRIV)'		;SUBSYSTEM NAME FOR USER
LASTIR==.		;MARKS END OF INTERNAL REGISTERS

BINSTR:	0		;INSTR. TO INTERPRET WHEN PROCEEDING

WHY:	0		;WHY IDDT ENTERED, RH OF FORK STATUS

;USER'S ACCUMULATORS, WHILE IN DDT
AC0:	BLOCK 20

;PERMANENT CONTROL SWITCHES (AC'S 10,11,12 ARE TEMP EQUIV'S)
SCHM:	PIN		;DO NOT CHANGE ORDER
ARM:	PADSO
ODFM:	10


TEM1:	0

SVBTS:	0
SVBTS2:	0
SVBT3:	0
SVBT2:	0

PNTR:	EXP INST	;POINTER TO BITS IN INST
INST:	0		;BINARY FOR INSTRUCTION
CHP:	0		;CHAR POINTER INTO TXT, TXT+1
TXT:	BLOCK 2		;STORE INPUT TEXT FOR OPEVAL
SAVPDL:	0		;PDL PTR SAVED DURING OPEVAL
LITS:	LIT
	VAR


PS:	IOWD LPDL,.+1
	BLOCK LPDL
PCSPTR:	0		;OLD PC STACK POINTER
PCSTAK:	IOWD PCSL,.+1
	BLOCK PCSL

PATCHS:PAT:		;PATCH SPACE

	QZQZ==<.+777>&777000
	DEPHASE
	RELOC QZQZ-DDT+LOW
	PHASE QZQZ


;WINDOW INTO USER'S CORE
UCORE:	BLOCK 1000

DDTEND:	DEPHASE


	END BLAST

