ENTRY CBLANK,CUNBLANK,DRAW,WINDOWP,
      INSCRIBE,UNSCRIBE,IMAGE,WDELET,CDELET,WINTYP,WINSAV,WINUSE,
        CURTYP,CURVEMATS;
BEGIN "GRAPH"
COMMENT

	GRAPHICS ROUTINES FOR MLAB/MODELAB

;




COMMENT  LINKAGE TO MAIN PROGRAM;

DEFINE DUMMY="1";

SAFE EXTERNAL INTEGER ARRAY IDX[0:DUMMY],A[0:DUMMY],VALUE[0:DUMMY],TYPE[0:DUMMY];
SAFE EXTERNAL STRING ARRAY NAME[0:DUMMY];
SAFE EXTERNAL STRING ARRAY ST[1:DUMMY];
EXTERNAL INTEGER DISINIT,RELDIS,TEMPCHR,POSTNUMBER;

EXTERNAL STRING CURRENTDIS;

SAFE INTERNAL REAL ARRAY DISINFO[1:23];  COMMENT ARRAY FOR DISPLAY ENVIRONMENT STUFF;

DEFINE MAXVIEWX="DISINFO[7]",MAXVIEWY="DISINFO[8]",INCHESPERVIEWPORT="DISINFO[6]";

DEFINE NEWTEMP="SYMTABENTRY("" ""&TEMPCHR); TEMPCHR_TEMPCHR+1";


DEFINE STUFFST(J,B) = "BEGIN J_1; WHILE LENGTH(ST[J]) NEQ 0 DO J_J+1;
			ST[J]_B END";
DEFINE ROWSIZE(A)="ARRINFO(A,2)";
DEFINE COLSIZE(A)="ARRINFO(A,4)";
DEFINE SIZE(A)="(ARRINFO(A,0))";

DEFINE DEFAULT ="-2.222222@22";
DEFINE CRLF = "('15&'12)";

DEFINE SYMTABSIZE="311";
DEFINE SYMTABSIZEM1="(SYMTABSIZE-1)";

COMMENT "*******  TYPES(IN SYMTAB) ******";

DEFINE OPERATOR="3";
DEFINE SCALAR="4";
DEFINE UNKNOWN="1 ";
DEFINE FUNCTION="5 ";
DEFINE MATRIX="6 ";
DEFINE WINDOW="7 ";
DEFINE CURVE="8 ";
DEFINE DIFFEQ="9 ";
DEFINE CONSTANT="2 ";
DEFINE COLON="10 ";
DEFINE ROW="12 ";
DEFINE COL="13 ";
DEFINE SUBSCR="14 ";
DEFINE TEXT="15";
COMMENT 
	DESCRIPTION OF CURVE ENTRY IN SYMTAB:

----------------------------------------------------------
NAME		TYPE		VALUE		IDX

---------------------------------------------------------

CURVE NAME	CURVE		POINTER TO	INDEX OF A
				NEXT CURVE	NODE IN
				IN THIS		ARRAY A
				WINDOW OR TO
				WINDOW

----------------------------------------------------------


NODE IN ARRAY A:

	0:	FLAGS, ETC. SEE BELOW
CSP =   1:	CURVE PICTURE ID	STRING PICTURE ID
CP2 =   2:	PT LBL PICTURE ID	PT LBL SKIP PARAM
CM  =   3:	PT LBL MATRIX ITEM #	CURVE MATRIX ITEM #
CPTLX = 4:		POINT LABEL X
CPTLY = 5:		POINT LABEL Y
CSTW1 = 6:		SETWIN PARAMETER 1
CSTW2 = 7:		SETWIN PARAMETER 2
CSTW3 = 8:		SETWIN PARAMETER 3
CSTW4 = 9:		SETWIN PARAMETER 4
CSTR = 10:		INDEX TO STRING IN ARRAY ST
CSTRX =11:		STRING X
CSTRY =12:		STRING Y
CINT  =13:	POINTTYPE	INTENSITY



DESCRIPTION OF WORD 0:

BLANKSW		= '200000000000 	IS ON IF CURVE IS BLANKED
INSW		= '100000000000	IS ON IF CURVE IS INSCRIBED
XFLTSW		= '000040000000 INDICATES X FLOATING POINTLABELS
YFLTSW		= '000020000000 INDICATES Y FLOATING POINTLABELS
		  '007700000000 POINT LABEL SIZE SAVED IN THESE BITS
LTYPEM		= '000000770000 LINE TYPE SAVED IN THESE BITS
STRM		= '000000000077 STRING SIZE SAVED IN THESE BITS
VTEXTSW         = '000000000100 VERTICAL TEXT SWITCH IS ON FOR VERTICAL TEXT











	DESCRIPTION OF WINDOW ENTRY IN SYMTAB


--------------------------------------------------------------
NAME		TYPE		VALUE		IDX
--------------------------------------------------------------
WINDOW NAME	WINDOW		POINTER TO	POINTER TO
				FIRST CURVE	NODE IN
						ARRAY A

--------------------------------------------------------------


DESCRIPTION OF NODE IN ARRAY A:


WSTW1	=0:	SETWIN PARAMS FOR NON-INSCRIBED CURVES
WSTW2	=1:			"
WSTW3	=2:			"
WSTW4	=3:			"
WSTP1	=4:	SETPOR PARAMS FOR ALL CURVES
WSTP2	=5:
WSTP3	=6:			"
WSTP4	=7:			"



;
COMMENT    DEFINITIONS OF SYMBOLS;


DEFINE CSP = "1";
DEFINE CP2 = "2";
DEFINE CM = "3";
DEFINE CPTLX = "4";
DEFINE CPTLY = "5";
DEFINE CSTW1 = "6";
DEFINE CSTW2 = "7";
DEFINE CSTW3 = "8";
DEFINE CSTW4 = "9";
DEFINE CSTR = "10";
DEFINE CSTRX = "11",
	CSTRY = "12",
	CINT  =  "13",
	CTLEN = "14",
	WSTW1 = "0";
DEFINE WSTW2 = "1";
DEFINE WSTW3 = "2";
DEFINE WSTW4 = "3";
DEFINE WSTP1 = "4";
DEFINE WSTP2 = "5";
DEFINE WSTP3 = "6";
DEFINE WSTP4 = "7",
	WTLEN = "8";

DEFINE	BLANKSW = "'200000000000",
	BLANKSWI = "'577777777777",
	INSW = "'100000000000",
	INSWI = "'677777777777",
	SBLNKSW = "'040000000000",
	SBLNKSWI = "'737777777777",
	XFLTSW = "'000040000000",
	YFLTSW = "'000020000000",
	
	LTYPEM = "'770000",
	LTYPEP = "-12",
	STRM = "'77",
        VTEXTSW= "'100",

	INT(X) = "(0 XOR (X))",
	REL(X) = "(0.0 XOR (X))";

INTEGER INTENSITY,CALLEDFROMCDRAW;
REAL HUNPERIN,VUNPERIN;
EXTERNAL PROCEDURE DPORT(REAL L,R,B,T);
EXTERNAL PROCEDURE DWIND(REAL L,R,B,T);
EXTERNAL PROCEDURE DDRAW(REAL X,Y);
EXTERNAL PROCEDURE DDOT(REAL X,Y);
EXTERNAL PROCEDURE DMOVE(REAL X,Y);
EXTERNAL PROCEDURE DVECT(REAL X1,Y1,X2,Y2);
EXTERNAL PROCEDURE DOPEN (INTEGER I);
EXTERNAL INTEGER PROCEDURE DPOST(INTEGER I);
EXTERNAL INTEGER PROCEDURE DUNPOST(INTEGER I);
EXTERNAL PROCEDURE DINT(REAL INTENSITY);
EXTERNAL INTEGER PROCEDURE DINI (INTEGER A,B,C,D);
EXTERNAL INTEGER PROCEDURE DGET;
EXTERNAL PROCEDURE DREL;
EXTERNAL PROCEDURE DCURSOR (REAL A,B);
EXTERNAL PROCEDURE DCLOSE;
EXTERNAL PROCEDURE DKILL(INTEGER I);
EXTERNAL PROCEDURE DTEXT(STRING S);
EXTERNAL PROCEDURE DTSCAL (REAL X);
EXTERNAL PROCEDURE DSTAT (INTEGER MODES);
EXTERNAL BOOLEAN PROCEDURE DTEST2(REAL X,Y);
EXTERNAL PROCEDURE DENQ (REFERENCE REAL X);

EXTERNAL SIMPLE PROCEDURE OUTSCR(STRING S);
EXTERNAL SIMPLE PROCEDURE OUTCR(INTEGER C;STRING S);
EXTERNAL SIMPLE PROCEDURE OUTSTL(STRING S);
EXTERNAL SIMPLE PROCEDURE LOUT(INTEGER C; STRING S);
EXTERNAL PROCEDURE ERROR(STRING S);
EXTERNAL PROCEDURE TYPEFORMERROR(INTEGER I);
EXTERNAL INTEGER PROCEDURE SYMTABENTRY(STRING X);
EXTERNAL PROCEDURE NEWNODE(REFERENCE INTEGER A;
                           SAFE INTEGER ARRAY STACK);
EXTERNAL PROCEDURE FREENODE(INTEGER A; SAFE INTEGER ARRAY STACK);
EXTERNAL PROCEDURE SAVSTR(STRING S);
EXTERNAL STRING PROCEDURE USESTR;
EXTERNAL STRING PROCEDURE FANCYNUM(REAL R);
EXTERNAL PROCEDURE MATOUT(INTEGER I);
EXTERNAL INTEGER PROCEDURE MATIN;





FORWARD SIMPLE PROCEDURE CDRAW(INTEGER C,W);
FORWARD SIMPLE PROCEDURE GLINE(SAFE REAL ARRAY M; INTEGER LTYPE);
FORWARD SIMPLE PROCEDURE GPOINT(SAFE REAL ARRAY X;INTEGER PTYPE);
FORWARD SIMPLE PROCEDURE PDELETE(INTEGER PIC);
FORWARD INTEGER SIMPLE PROCEDURE HI(INTEGER I);
FORWARD INTEGER SIMPLE PROCEDURE LOW(INTEGER I);
FORWARD SIMPLE PROCEDURE LOADHI(REFERENCE INTEGER TO; INTEGER FROM);
FORWARD SIMPLE PROCEDURE LOADLOW(REFERENCE INTEGER TO; INTEGER FROM);
FORWARD SIMPLE PROCEDURE CURGEN(INTEGER WIND);
COMMENT
***************************************************************************************************

	MISCELLANEOUS SIMPLE PROCEDURES FOR HANDLING THE DISPLAY.


PPOST (INT)	ADD A PICTURE TO THE DISPLAY:
		CALL:	'INT' IS A PICTURE ID.
		EFFECT:	IF 'INT' IS ZERO, DO NOTHING, OTHERWISE
			CALL DPOST TO DISPLAY THE PICTURE NUMBERED 'INT'.

PDELETE (INT)	DELETE A PICTURE FROM THE DISPLAY:
		CALL:	'INT' IS PICTURE ID NUMBER.
		EFFECT:	IF 'INT' IS NON-ZERO, THEN UNPOST THE PICTURE OF THAT
			NUMBER, AND DELETE IT FROM THE DISPLAY FILES.

PBLANK (INT)	BLANK A PICTURE BEING DISPLAYED:
		CALL:	'INT' IS PICTURE ID NUMBER
		EFFECT:	IF 'INT' IS NON-ZERO, THEN UNPOST THE PICTURE OF THAT
			NUMBER.

GINIT		INITIALIZE THE DISPLAY:
		EFFECT:	INITIALIZE THE DISPLAY PACKAGE FOR THE 340.
			SET 'DISINIT' TO TRUE, INDICATING THAT THE DISPLAY IS INITIALIZED.
			IF THE USER HAS NOT TYPED 'RELEASE DISPLAY', THEN ACTUALLY SEIZE THE DISPLAY.
			FILL THE ARRAY 'DISINFO' WITH THE PARAMETERS OF THIS DISPLAY.

SETPIC (@INT)	INITIALIZE GENERATION OF A PICTURE:
		CALL:   'INT'= PICTURE ID OF PICTURE TO BE GENERATED.
		EFFECT:	IF 'INT' IS NON-ZERO, OLD PICTURE IS DELETED FIRST.
			NEW PICTURE STARTED, INTENSITY INITIALIZED
		RETURN: 'INT' HAS BEEN STUFFED WITH A NEW PICTURE ID
			OF AN INITIALIZED PICTURE.

SETWIND (INT)	INITIALIZE THE WINDOW PARAMETERS:
		CALL:   'INT' IS INDEX OF A-NODE CONTAINING WINDOW PARMS.
		EFFECT: SETS UP WINDOW VALUES FROM A[INT+CSTW1], A[INT+CSTW2], ETC.
		RETURN: IF THE WINDOW IS EMPTY, 'TRUE', ELSE 'FALSE'

SETPORT (INT)	INITIALIZE VIEWPORT PARAMETERS:
		CALL:  'INT' IS INDEX OF A-NODE CONTAINING VIEWPORT
			INFORMATION.
		EFFECT: DISPLAY PACKAGE VIEWPORT PARAMETERS ARE
			SET UP FROM A[INT+WSTP1], A[INT+WSTP2], ETC.


THE DISPLAY IS ALWAYS RELEASED WHEN THERE ARE NO UNBLANKED (I.E. VISIBLE)
PICTURES BEING DISPLAYED.
***************************************************************************************************
;

INTERNAL SIMPLE PROCEDURE GINIT (STRING DIS);
BEGIN REAL R;
      INTEGER I,J,K,N;

       IF NOT EQU(CURRENTDIS,DIS) OR NOT DISINIT THEN 
        BEGIN
	DINI (CVSIX(DIS),'12,0,0);  			"INITIALIZE DISPLAY PACKAGE"
        I_TRUE END  ELSE I_FALSE;
        CURRENTDIS_DIS;
	DISINIT_TRUE;
	DENQ (DISINFO[1]);  			"FILL ARRAY WITH GOODIES ABOUT OUR DISPLAY"

        IF NOT RELDIS THEN IF (RELDIS_LNOT DGET) THEN  OUTSCR("[DISPLAY NOT AVAILABLE]");
  "THE PURPOSE OF THE LOOP BELOW IS TO MARK ALL EXTANT PICTURES
   AS DESTROYED.  INDEED THE DINI CALL ABOVE HAS DKILLED THEM EFFECTIVELY.
   AND THEN REDRAW THE CURRENT DISPLAY (IF ANY).  THUS A DISPLAY
   CHANGE WILL WORK JUST RIGHT! "

     IF I THEN 
        FOR I_1 STEP 1 UNTIL SYMTABSIZEM1 DO 
            IF TYPE[I]=WINDOW THEN BEGIN
               J_I;
               WHILE (J_VALUE[J]) NEQ I DO BEGIN
                     A[(N_IDX[J])+CSP]_0;
                     LOADHI(A[N+CP2],0)    END;
              CURGEN(I)            END;


	DCURSOR (0,.95*MAXVIEWY);		"PUT CURSOR AT TOP"
END;

SIMPLE PROCEDURE PPOST(INTEGER I);
IF I THEN BEGIN
	POSTNUMBER_DPOST(I);			"POST THE PICTURE OF ID I"
END;


SIMPLE PROCEDURE PDELETE(INTEGER I);
IF I THEN BEGIN
	POSTNUMBER_DUNPOST(I);  		"FIRST UNPOST THE PICTURE, IF IT WAS UP"
	DKILL(I);				"NOW RECLAIM PICTURE STORAGE"
END;

SIMPLE PROCEDURE PBLANK(INTEGER I);
IF I THEN BEGIN
	POSTNUMBER_DUNPOST(I);  		"UNPOST THE PICTURE"
END;


INTEGER PICCOUNT;

SIMPLE PROCEDURE SETPIC(REFERENCE INTEGER PIC);
BEGIN
	PDELETE(PIC);				"DELETE OLD ONE, IF ANY"
	DINT (INTENSITY/7);			"SET DEFAULT INTENSITY"
	DOPEN (PIC_PICCOUNT_PICCOUNT+1);	"CREATE NEW ID, NEW PICTURE"
END;


INTEGER SIMPLE PROCEDURE SETWIND (INTEGER I);
BEGIN REAL AA,BB,CC,DD;
	AA_REL(A[I+CSTW1]);  			"GET ALL WINDOW PARAMETERS"
	BB_REL(A[I+CSTW2]);
	CC_REL(A[I+CSTW3]);
	DD_REL(A[I+CSTW4]);
	IF AA GEQ BB OR CC GEQ DD THEN RETURN (TRUE);  "EMPTY WINDOW"

	DWIND (AA,BB,CC,DD);  			"TELL DISPLAY ROUTINES ABOUT WINDOW"
	RETURN (FALSE)
END;

SIMPLE PROCEDURE SETPORT (INTEGER I);
DPORT (REL(A[I+WSTP1]), REL(A[I+WSTP2]), REL(A[I+WSTP3]), REL(A[I+WSTP4]));

COMMENT
***************************************************************************************************

	SIMPLE PROCEDURES FOR HALF WORD MANIPULATION


HI (INT)	GET THE LEFT-HALF OF A WORD:
		CALL:	'INT' IS A 36-BIT WORD.
		RETURN: RETURNS LEFT-HALF 18 BITS OF 'INT', SIGN-EXTENDED.

LOW (INT)	GET THE RIGHT-HALF OF A WORD:
		CALL:	'INT' IS A 36-BIT WORD.
		RETURN:	RETURNS RIGHT-HALF 18 BITS OF 'INT', SIGN-EXTENDED.

LOADLOW (@INT[TO],INT[FROM])	FILLS IN RIGHT-HALF OF A WORD:
		CALL:	@INT[TO] IS ADDRESS OF PLACE TO PUT
			INT[FROM].
		EFFECT: RIGHT-HALF OF INT[FROM] IS STORED IN RIGHT-HALF OF @INT[TO]

LOADHI (@INT[TO],INT[FROM])     FILLS IN LEFT-HALF OF A WORD:
		CALL:	@INT[TO] IS ADDRESS OF PLACE TO PUT
			INT[FROM]
		EFFECT:	RIGHT-HALF OF INT[FROM] IS STORED IN LEFT-HALF OF @INT[TO]

***************************************************************************************************
;



 INTEGER SIMPLE PROCEDURE HI (INTEGER X);
BEGIN START!CODE
	HLRE	1,X;
END END	"HI";


 INTEGER SIMPLE PROCEDURE LOW (INTEGER X);
BEGIN START!CODE
	HRRE	1,X;
END END	"LOW";


 SIMPLE PROCEDURE LOADLOW (REFERENCE INTEGER TO;INTEGER FROM);
BEGIN START!CODE
	MOVE	1,FROM;
	HRRM	1,TO;
END END	"LOADLOW";


 SIMPLE PROCEDURE LOADHI (REFERENCE INTEGER TO;INTEGER FROM);
BEGIN START!CODE
	MOVE	1,FROM;
	HRLM	1,TO;
END END	"LOADHI";

COMMENT
***************************************************************************************************

		MISCELLANEOUS ROUTINES

MAPC (INT,@PROC)	PERFORMS SIMPLE PROCEDURE PROC FOR A BUNCH OF CURVES:
	CALL:	IF TYPE[I] IS CURVE, THEN CALL PROC(I)
		IF TYPE[I] IS WINDOW, CALL PROC(I) FOR ALL CURVES I IN THE WINDOW.

NUMSTR (REAL)	PUTS TOGETHER AN ASCII STRING TO TYPE 'REAL'.
		THE STRING IS 'PRETTIFIED', SUITABLE FOR DISPLAYING
		AS A POINT LABEL ON THE DISPLAY SCREEN


CURVEMATS (C,OP)  FOR COPYING CURVE MATRICES:
	CALL:	C IS A SYMTABENTRY OF A CURVE.
		OP = 1 TO RETURN A COPY OF POINT LABEL MATRIX.
		OP = 0 TO RETURN A COPY OF CURVE MATRIX.

	RETURN:	INTEGER NUMBER OF NEW SYMTABENTRY.

***************************************************************************************************
;

SIMPLE PROCEDURE MAPC (INTEGER I; REFERENCE SIMPLE PROCEDURE P);
BEGIN INTEGER J;
	IF TYPE[I] = CURVE THEN P(I) ELSE
	IF TYPE[I] = WINDOW THEN BEGIN
		J_VALUE[I];			"GET FIRST CURVE"
		WHILE J NEQ I DO BEGIN P(J); J_VALUE[J]; END
	END ELSE TYPEFORMERROR (I)
END;


STRING SIMPLE PROCEDURE NUMSTR (REAL R);
BEGIN
STRING S,T;
INTEGER EXP,B;

	IF R = 0 THEN RETURN(" 0");
	SETFORMAT(10,3);
	S_CVE(R);		"TRY FOR THIS TYPE OF REPRESENTATION"
	T_LOP(S);
	T_S[7 TO INF];		"FETCH EXPONENT"
	EXP_INTSCAN(T,B);
	"IF EXPONENT > 6 OR EXPONENT < -3, CVE FORMAT IS BEST."
	IF EXP < -3 OR EXP > 6 THEN
	BEGIN
	   B_LENGTH(S);
	   S_S[1 TO 5]&"E"&S[7 TO INF];
	   WHILE S[B FOR 1] =" " DO B_B-1;
	   RETURN(S[1 TO B]);
	END;

	IF EXP = 0 THEN S_S[1 TO 5] ELSE BEGIN
		T_S[3 FOR 3];
		IF EXP < 0 THEN BEGIN
			S_S[1 FOR 2];
			FOR B_1 STEP 1 UNTIL ABS(EXP) DO S_S&"0";
			S_S&T;
		END ELSE BEGIN
			T_T&"000";
			S_S[1 FOR 1];
			S_S&T[1 FOR EXP]&".";
			IF EXP < 6 THEN S_S&T[EXP+1 TO INF];
		END
	END;
	B_LENGTH(S);
	WHILE S[B FOR 1] ="0" DO B_B-1;
	IF S[B FOR 1] ="." THEN B_B-1;
	RETURN(S[1 FOR B])
END;




INTERNAL INTEGER SIMPLE PROCEDURE CURVEMATS(INTEGER C,OP);
BEGIN
SAFE REAL ARRAY ITEMVAR Q;
OWN SAFE REAL ARRAY EMPTY[0:-1,0:-1];
INTEGER I;

	IF TYPE[C] NEQ CURVE THEN TYPEFORMERROR(C);
	I_A[IDX[C]+CM];
	I_IF OP=0 THEN LOW(I) ELSE HI(I);
	Q_IF I=0 THEN NEW(EMPTY) ELSE CVI(I);
	I_NEWTEMP;
	TYPE[I]_MATRIX;
	VALUE[I]_CVN(NEW(DATUM(Q)));
	RETURN(I);
END "CURVEMATS";
COMMENT
***************************************************************************************************

		ROUTINES FOR BLANKING AND UNBLANKING:
			INDIVIDUAL CURVES
			ALL CURVES IN A WINDOW.

CBLANK (INT)
CUNBLANK (INT)
		CALL:	'INT' IS INDEX OF WINDOW OR CURVE IN SYMTAB.
		EFFECT: IF TYPE[INT] IS CURVE, BLANK (UNBLANK) THE ONE CURVE.
			IF TYPE[INT] IS WINDOW, BLANK (UNBLANK) ALL CURVES IN THE
				WINDOW.
			THE 'BLANKSW' BIT IS TURNED ON (OFF) IN EACH CURVE
				PROCESSED.

***************************************************************************************************
;


INTERNAL SIMPLE PROCEDURE CBLANK(INTEGER C);
BEGIN
SIMPLE PROCEDURE BLANKCURVE (REFERENCE INTEGER I);
BEGIN INTEGER J;
	J_IDX[I];
	A[J]_A[J] LOR BLANKSW;
	PBLANK(HI(A[J+CSP])); 			"BLANK THE CURVE, IF ANY"
	PBLANK(HI(A[J+CP2])); 			"BLANK THE POINT LABELS, IF ANY"
	PBLANK(LOW(A[J+CSP])); 			"BLANK THE STRINGS, IF ANY"
END   "BLANKCURVE";

	MAPC (C, BLANKCURVE);			"BLANK ALL CURVES"
END   "CBLANK";


INTERNAL SIMPLE PROCEDURE CUNBLANK (INTEGER C);
BEGIN
SIMPLE PROCEDURE UNBLANKCURVE (REFERENCE INTEGER I);
BEGIN INTEGER J;
	J_IDX[I];
	IF (A[J] LAND BLANKSW) = 0 THEN RETURN; "ALREADY UNBLANKED"
	A[J]_A[J] LAND BLANKSWI;
	PPOST(HI(A[J+CSP]));			"UNBLANK THE CURVE, IF ANY"
	PPOST(HI(A[J+CP2]));			"UNBLANK THE POINT LABELS, IF ANY"
	PPOST(LOW(A[J+CSP]));			"UNBLANK THE STRING, IF ANY"
END   "UNBLANKCURVE";

	MAPC (C,UNBLANKCURVE);			"UNBLANK ALL CURVES"
END   "CUNBLANK";
COMMENT
***************************************************************************************************

	ROUTINES FOR DELETING WINDOWS AND CURVES


CDELET (INT)	DELETE A CURVE ENTRY:
		CALL:	'INT' IS INDEX OF CURVE IN SYMTAB.
		EFFECT: REMOVE CURVE FROM CURVE LIST FOR THIS WNDOW,
			DELETE ANY DISPLAYS GENERATED ON BEHALF OF THIS CURVE,
			DELETE ANY MATRICES (CURVE,POINT LABEL) ATTACHED TO THIS CURVE,
			FREE THE A-NODE FOR THE CURVE, AND THE SYMBOL-TABLE ENTRY.

WDELET (INT)	DELETE A WINDOW AND ALL ITS CURVES:
		CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
		EFFECT:	DELETE ALL CURVES IN THIS WINDOW VIA CDELET.
			FREE THE A-NODE FOR THE WINDOW, AND THE SYMBOL-TABLE ENTRY.


***************************************************************************************************
;


INTERNAL SIMPLE PROCEDURE CDELET(INTEGER I);
BEGIN
INTEGER J,K,L;

	"DELETE ENTRY FROM LIST OF CURVES IN THIS WINDOW"
	
	K_J_VALUE[I]; 				"J = INDEX OF NEXT CURVE"
	WHILE VALUE[K] NEQ I DO K_VALUE[K];
	VALUE[K]_J;

	K_IDX[I];				"DELETE ANY DISPLAYS"
	PDELETE(HI(A[K+CSP]));
	PDELETE(LOW(A[K+CSP]));
	PDELETE(HI(A[K+CP2]));

	IF (L_HI(A[K+CM])) THEN DELETE (CVI(L));  "DELETE CURVE AND POINT LABEL MATRICES"
	IF (L_LOW(A[K+CM])) THEN DELETE (CVI(L));
	IF (L_A[K+CSTR]) THEN ST[L]_NULL; 	"DELETE STRING"
	FREENODE(K,A);				"FREE AREA IN ARRAY A"
	NAME[I]_" ";				"REMOVE SYMTAB ENTRY"
END;


INTERNAL SIMPLE PROCEDURE WDELET(INTEGER I);
BEGIN ;					"LOOP DELETING CURVES UNTIL WINDOW POINTS TO ITSELF"
	WHILE NOT (VALUE[I]=I) DO CDELET (VALUE[I]);
	FREENODE(IDX[I],A);
	NAME[I]_" ";
END;
COMMENT
***************************************************************************************************

	DRAW OR REDRAW A CURVE OR STRING

DRAW (C,U,W,LTYPE,PTYPE,FLOATL,PLSZE,N,LABELSKIP,ATX,ATY,INTQ)
	CALL:
	IF U>0 AND TYPE[U] = MATRIX THEN DRAW A CURVE WITH

	     	C = INDEX OF CURVE IN SYMTAB
		U = INDEX OF CURVE MATRIX IN SYMTAB
		W = INDEX OF WINDOW IN SYMTAB
		LTYPE = LINE TYPE CODE (0-5)
		PTYPE = POINT TYPE CODE (0-7) OR "*"
			FOLLOWED BY AN ASCII CHARACTER
			TO BE PLOTTED AT EACH POINT
		FLOATL = FLOATING LABEL SWITCH
		       = +1 FOR X FLOATING LABELS
		       = -1 FOR Y FLOATING LABELS
		       = 0 OTHERWISE
		PLSZE = POINT LABEL SIZE (1-4)
		N = INDEX OF PT LBL MATRIX IN SYMTAB
		LABELSKIP: POINT LABEL EVERY LABELSKIP-TH POINT
		ATX = X LOCATION FOR POINT LABEL
		ATY = Y LOCATION FOR POINT LABEL
		INTQ = INTENSITY (0-7)

	IF U > 0 AND TYPE[U] = TEXT THEN CREATE CURVE C IF
	IT DOES NOT ALREADY EXIST AND ADD TO IT THE STRING
	SPECIFIED BY

		C = INDEX OF CURVE IN SYMTAB
		NAME[U][2 TO INF] = STRING
		W = INDEX OF WINDOW IN SYMTAB
                FLOATL = VERTICAL TEXT SWITCH
                       = 0 FOR HORIZONTAL TEXT
                       = 1 FOR VERTICAL TEXT
		PLSZE = SIZE OF STRING (1-4)
		ATX = X-COORDINATE OF STRING (WINDOW COORDINATES)
		ATY = Y-COORDINATE OF STRING
		INTQ = INTENSITY (0-7)
		[OTHER PARAMS IGNORED]

	IF U = 0 THEN REDRAW THE STRING OF CURVE C AS FOLLOWS:

		PLSZE = STRING SIZE (1-4)
		ATX,ATY = IF ATX = DEFAULT THE STRING IS NOT MOVED.
			  OTHERWISE STRING MOVED TO ATX,ATY
		INTQ = INTENSITY (0-7)

	IF U < 0 THEN REDRAW THE CURVE USING THE SAME MATRIX
	AND WINDOW.

		PARAMETERS AS IN CASE 1 ABOVE, EXCEPT THAT
		DEFAULT VALUES FOR PTYPE, LTYPE, AND PLSZE
		WILL BE THE PREVIOUS VALUES - NOT THE
		STANDARD DEFAULTS.



DEFAULT VALUES WHEN CREATING NEW CURVES:
	LINE TYPE = 1
	POINT TYPE = 0
	POINT LABEL SIZE = 2
	POINT LABEL SKIP = 1
	POINT LABEL X = 0
	POINT LABEL Y = 0
	STRING SIZE = 2
	STRING X = 0
	STRING Y = 0
	INTENSITY = 5
	UNBLANKED, UNINSCRIBED, NO POINT LABELS

***************************************************************************************************
;

DEFINE DEFBLANKINSCR = "0",DEFPTLBLSZ = "2",DEFXYFLTSW = "0",DEFLINETYPE = "1",
	DEFSTRSZ = "2",	DEFPTLBLSKIP = "1",DEFPTLBLX = "0",DEFPTLBLY = "0",
	DEFSTRINGX = "0",DEFSTRINGY = "0",DEFPTTYPE = "0",DEFINTENSITY = "5";

COMMENT NOW AN OWN ARRAY WITH THE DEFAULT VALUES ALL SET UP;

PRELOAD!WITH
	((((((DEFBLANKINSCR LSH 6) + DEFPTLBLSZ) LSH 6 + DEFXYFLTSW) LSH 6 +
	DEFLINETYPE) LSH 6 + 0) LSH 6 + DEFSTRSZ),
	0,
	DEFPTLBLSKIP,
	0,
	DEFPTLBLX,
	DEFPTLBLY,
	[4] 0,
	0,
	DEFSTRINGX,
	DEFSTRINGY,
	(DEFPTTYPE LSH 18) + DEFINTENSITY;
OWN SAFE INTEGER ARRAY DEFCRV[1:15];


INTERNAL SIMPLE PROCEDURE DRAW(INTEGER C, U;
			INTEGER W, LTYPE, PTYPE, FLOATL, PLSZE, N;
			REAL LABELSKIP,ATX,ATY;INTEGER INTQ);
BEGIN
INTEGER I,J,ANODE,PTR;
SAFE REAL ARRAY ITEMVAR Q;


	IF TYPE[C] NEQ CURVE THEN BEGIN "MAKE A NEW CURVE"
		IF TYPE[W] NEQ WINDOW THEN TYPEFORMERROR(W);
		IF TYPE[C] NEQ UNKNOWN THEN TYPEFORMERROR(C);

		NEWNODE(J,A);			"GET A NEW A-NODE"
		IDX[C]_J;			"POINT SYMTAB AT IT"
		TYPE[C]_CURVE;
		ARRBLT(A[J],DEFCRV[1],15);   	"FILL WITH DEFAULTS"

						"PLACE CURVE IN LIST OF CURVES FOR THIS WINDOW"
		J_VALUE[W];	VALUE[W]_C;	VALUE[C]_J;

	END "MAKE A NEW CURVE" ELSE
	IF W > 0 THEN BEGIN "DRAW THE CURVE IN WINDOW W THIS TIME"
			"IF W IS NOT THE OLD WINDOW OF C, FIXUPS ARE NEEDED"

		IF TYPE[W] NEQ WINDOW THEN TYPEFORMERROR(W);
		I_VALUE[C];			"FIND OLD WINDOW"
		WHILE TYPE[I] NEQ WINDOW DO I_VALUE[I];
		IF I NEQ W THEN BEGIN "TO BE DRAWN IN A NEW WINDOW"
		   WHILE VALUE[I] NEQ C DO I_VALUE[I];
	   	   VALUE[I]_VALUE[C];		"DELETE THIS CURVE FROM OLD WINDOW LIST"
						"PLACE CURVE IN LIST FOR NEW WINDOW"
		   I_VALUE[W];	VALUE[C]_I;	VALUE[W]_C;
		END "TO BE DRAWN IN A NEW WINDOW"
	END ELSE
	BEGIN "MUST FIND THE ACTUAL WINDOW OF C"
		W_VALUE[C];
		WHILE TYPE[W] NEQ WINDOW DO W_VALUE[W];
	END;

	
	ANODE_IDX[C];

	IF U=0 OR (U>0 AND TYPE[U] = TEXT) THEN BEGIN "UPDATE STRING"
		IF U>0 THEN BEGIN "REPLACE STRING"
		   I_A[ANODE+CSTR];
		   IF I>0 THEN ST[I]_NULL;
		   IF LENGTH(NAME[U]) = 1 THEN BEGIN "DELETE STRING"
			I_0;
		   END "DELETE STRING" ELSE BEGIN "NEW STRING"
			STUFFST(I,NAME[U][2 TO INF]);
		   END "NEW STRING";
		   A[ANODE+CSTR]_I;
		END "REPLACE STRING";

		IF 0 < PLSZE < 5 THEN BEGIN
			PTR_POINT(6,A[ANODE],35);
			DPB(PLSZE,PTR);
		END;
                "SET VERTICAL TEXT SWITCH"
                DPB(FLOATL,POINT(1,A[ANODE],29));

		IF ATX NEQ DEFAULT THEN BEGIN
			A[ANODE+CSTRX]_INT(ATX);
			A[ANODE+CSTRY]_INT(ATY);
		END;

	END "UPDATE STRING" ELSE BEGIN "WORK ON CURVE"

		IF U > 0 AND TYPE[U] = MATRIX THEN BEGIN "REPLACE CURVE MATRIX"
			I_LOW(A[ANODE+CM]);		"DELETE OLD POINT MATRIX"
			IF I THEN DELETE(CVI(I));
			Q_CVI(VALUE[U]);		"THIS IS THE NEW MATRIX"
			LOADLOW(A[ANODE+CM],CVN(NEW(DATUM(Q))));
		END "REPLACE CURVE MATRIX"
		ELSE IF U>0 THEN TYPEFORMERROR (U);	"NONSENSE"

		PTR_POINT (6,A[ANODE],11);	"INITIALIZE BYTE POINTER"
						"INSTALL POINT LABEL SIZE"
		IF 0 < PLSZE < 5 THEN DPB(PLSZE,PTR);
						"AND XFLOATING/YFLOATING FLAGS"
		IF N>0 THEN
		   IDPB(IF FLOATL > 0 THEN '40 ELSE IF FLOATL < 0 THEN '20 ELSE 0,PTR)
		   ELSE IBP(PTR);

						"LINE TYPE"
		IF -1 < LTYPE < 6 THEN IDPB(LTYPE,PTR);

						"POINT TYPE"
		IF -1 < PTYPE < 8 THEN LOADHI(A[ANODE+CINT],PTYPE)
		ELSE BEGIN "FIND THE ASCII CHAR"
			STRING S;
			S_CVSTR(PTYPE);
			IF S = "*" THEN LOADHI(A[ANODE+CINT],S[2 FOR 1]);
		END;

		IF N>0 THEN BEGIN "REPLACE POINT-LABEL MATRIX"
			I_HI(A[ANODE+CM]);
			IF I NEQ 0 THEN DELETE(CVI(I));
			Q_CVI(VALUE[N]);
			Q_NEW(DATUM(Q));
			LOADHI(A[ANODE+CM],CVN(Q));
			IF LABELSKIP > 0 THEN LOADLOW(A[ANODE+CP2],LABELSKIP);
		END;

		IF ATX NEQ DEFAULT THEN BEGIN
			A[ANODE+CPTLX]_INT(ATX);
			A[ANODE+CPTLY]_INT(ATY);
		END;
	END "WORK ON CURVE";

	IF -1 < INTQ < 8 THEN LOADLOW(A[ANODE+CINT],INTQ);

	IF (A[ANODE] LAND INSW) = 0 THEN
	   ARRBLT(A[ANODE+CSTW1],A[IDX[W]+WSTW1],4);
	CDRAW(C,W);

END	"DRAW";
COMMENT
***************************************************************************************************

	DISPLAY A CURVE

CDRAW (INT,WIND)
	CALL:	INT = INDEX OF CURVE ENTRY IN SYMTAB
		WIND = INDEX OF WINDOW IN SYMTAB
	EFFECT:	A COMPONENT PICTURE CONTAINING THE 
		 INFORMATION CORRESPONDING TO THIS CURVE
		HAS BEEN GENERATED

***************************************************************************************************
;


SIMPLE PROCEDURE CDRAW (INTEGER I,WIND);
BEGIN "CDRAW"
INTEGER PIC1,PIC2,PIC3,LTYPE,PTYPE,Q,J,K,L,M,N,WINDX,SC,C1,WIN;
REAL X,Y,Z,XDEL,YDEL,AD1,AD2,FACT;
SAFE REAL ARRAY ITEMVAR IV1, IV2;


	IF NOT DISINIT THEN BEGIN CALLEDFROMCDRAW_TRUE; 
                                  GINIT(CURRENTDIS);		"INITIALIZE DISPLAY"
                                  CALLEDFROMCDRAW_FALSE  END;
	C1_I;					"SAVE CURVE INDEX"
	I_IDX[I];				"I IS A-NODE POINTER"
	INTENSITY_LOW(A[I+CINT]);		"INTENSITY"

	PIC1_HI(A[I+CSP]);			"CURVE PICTURE"
	PIC2_LOW(A[I+CSP]);			"STRING PIC"
	PIC3_HI(A[I+CP2]);			"POINT LABEL PIC"
	WIN_SETWIND (I);			"SET UP WINDOW AND REMEMBER IF EMPTY"
	SETPORT (WINDX_IDX[WIND]);		"SET UP VIEWPORT FROM WINDOW BLOCK"

	IF NOT WIN AND LOW(A[I+CM]) THEN BEGIN "REGENERATE CURVE MATRIX"
	   SETPIC(PIC1);			"START A PICTURE GOING"
	   DENQ (DISINFO[1]);			"THEN GET CURRENT WINDOW,VIEWPORT AS SET UP"
	   HUNPERIN_(DISINFO[21]-DISINFO[20])/((DISINFO[17]-DISINFO[16])*INCHESPERVIEWPORT);
	   VUNPERIN_(DISINFO[23]-DISINFO[22])/((DISINFO[19]-DISINFO[18])*INCHESPERVIEWPORT);

						"NOW GENERATE POINTS OR LINES, AS NEEDED"
	   IV1_CVI(LOW(A[I+CM]));		"ITEM NUMBER OF CURVE MATRIX"
	   LTYPE_(A[I] LAND LTYPEM) LSH LTYPEP;	"GET LINE TYPE"
	   IF LTYPE THEN GLINE(DATUM(IV1),LTYPE);
	   PTYPE_HI(A[I+CINT]);			"GET POINT TYPE"
	   IF PTYPE THEN GPOINT(DATUM(IV1),PTYPE);

	   DCLOSE; 				"FINISH PICTURE"
	   IF NOT (A[I] LAND BLANKSW) THEN PPOST(PIC1);			"AND POST IT ON DISPLAY IF UNBLANKED"

	   Q_HI(A[I+CM]);			"Q = ITEM # OF PT LBL MATRIX"
	   IF Q THEN BEGIN "POINT LABELS" 
		SETPIC(PIC3);
		DENQ(DISINFO[1]);
		AD1_AD2_0; FACT_1.;
		IF A[I] LAND INSW THEN BEGIN "INSCRIBED"
		IF A[I] LAND XFLTSW THEN BEGIN
		   AD1_REL(A[WINDX+WSTW1]);
		   AD2_REL(A[I+CSTW1]);
		   FACT_(REL(A[WINDX+WSTW2])-REL(A[WINDX+WSTW1]))
		       /(DISINFO[21]-DISINFO[20])
		END ELSE
		IF A[I] LAND YFLTSW THEN BEGIN
		   AD1_REL(A[WINDX+WSTW3]);
		   AD2_REL(A[I+CSTW3]);
		   FACT_(REL(A[WINDX+WSTW4])-REL(A[WINDX+WSTW3]))
		       /(DISINFO[23]-DISINFO[22])
		END END "INSCRIBED";
		K_(A[I] LSH -24) LAND STRM;	"GET POINT-LABEL SIZE"
		IF K<1 OR K>4 THEN K_2;
		SC_1 LSH (K-1); DTSCAL (SC * -.0068); "USE NEGATIVE TO DISPLAY ANYWAY"
                DENQ(DISINFO[1]);                     "GET CURRENT CHAR SIZES READY IN DISINFO"
		IV1_CVI(Q);			"DATUM(IV1) = PT LBL MATRIX"
		IV2_CVI(LOW(A[I+CM]));		"DATUM(IV2) = CURVE MAT"
		XDEL_(REL(A[I+CPTLX])*HUNPERIN-DISINFO[10]);
		YDEL_(REL(A[I+CPTLY])*VUNPERIN-.5*DISINFO[9]);
		J_LOW(A[I+CP2]);		"J= PT LBL SKIP PARAMETER"
		K_0;
		M_ROWSIZE("DATUM(IV2)");
		N_ROWSIZE("DATUM(IV1)");
		FOR L_1 STEP J UNTIL M DO
		BEGIN
		   K_K+1;
		   IF K>N THEN DONE;
		   X_DATUM(IV2)[L,1];
		   Y_DATUM(IV2)[L,2];
		   IF NOT DTEST2(X,Y) THEN BEGIN
                      X_X+XDEL; Y_Y+YDEL;
		      Z_DATUM(IV1)[K,1];
		      Z_AD1+(Z-AD2)*FACT;
		      DMOVE (X, Y);
		      DTEXT (NUMSTR(Z));
		   END
		END;

		DCLOSE;
		IF NOT (A[I] LAND BLANKSW) THEN PPOST(PIC3);		"DONE WITH POINT LABEL MATRIX - POST IF UNBLANKED"
	   END "POINT LABELS"
	END "REGENERATE CURVE MATRIX" ELSE BEGIN
		PDELETE (PIC1);			"DELETE ALL PICTURES"
		PDELETE (PIC3);
		PIC1_PIC3_0;
	END;

	IF A[I+CSTR] THEN BEGIN "NON-EMPTY STRING"
	   SETPIC(PIC2);
	   SC_1 LSH ((A[I] LAND STRM)-1);       "SIZE"
	   X_REL(A[I+CSTRX]);			"SPOT WHERE STRING IS TO GO"
	   Y_REL(A[I+CSTRY]);
	   DTSCAL (-.0068*SC );                "SET STRING SIZE"
           DENQ(DISINFO[1]);                    "GET CHAR SIZE INFO"
           IF A[I] LAND VTEXTSW THEN BEGIN
              DSTAT(32); 
              DMOVE(X-.5*DISINFO[10],Y);  "THIS IS ONLY OK FOR THE 340 TEMPORARILY (12/13/74)."
                                     END 
           ELSE
	   DMOVE (X,Y-.5*DISINFO[9]);	       "MOVE BEAM TO STARTING POINT"
	   DTEXT (ST[A[I+CSTR]]);		"AND DISPLAY TEXT"
           DSTAT(-32);                          "SET VERTICAL TEXT OFF"
	   DCLOSE;
	   IF NOT(A[I] LAND BLANKSW) THEN PPOST (PIC2);		"DONE WITH STRING PICTURE - POST IF UNBLANKED"
	END "NON-EMPTY STRING" ELSE BEGIN
		PDELETE (PIC2);
		PIC2_0;
	END;

	LOADHI (A[I+CSP],PIC1);			"FILL IN CURVE PICTURE ID"
	LOADLOW (A[I+CSP],PIC2);		"FILL IN STRING PICTURE ID"
	LOADHI (A[I+CP2],PIC3);			"FILL IN POINT LABEL PICTURE"

END "CDRAW";
COMMENT
***************************************************************************************************

	DRAW SOLID OR DASHED LINES

GLINE (REAL ARRAY M: LTYPE)
	CALL:	M = MATRIX OF COORDINATES OF POINTS ON CURVE
		LTYPE = 1 FOR SOLID LINE
		      = 2 FOR .1" DASHES
		      = 3 FOR .5" DASHES
		      = 4 FOR ALTERNATE .1" AND .5"
			  DASHES
			= 5 FOR SOLID LINE BETWEEN EVERY
			    SECOND SET OF POINTS
	EFFECT:	LINES ARE ADDED TO CURRENT PICTURE

***************************************************************************************************
;


SIMPLE PROCEDURE GLINE(SAFE REAL ARRAY M;INTEGER LTYPE);
BEGIN
INTEGER IMAX,I,J;
REAL XOLD, YOLD;
LABEL NXLINE,MORLINE,MORSPAC;
REAL DOT,DASH,DLEN,DX,DY,TLEN,TTLEN,THETA,R,DXI,DYI;
	IMAX_ROWSIZE(M); 			"GET TOTAL NUMBER OF POINTS"
	IF IMAX < 2 THEN RETURN;		"IF 0 OR 1 POINTS, NO GOOD"
	DMOVE(XOLD_M[1,1],YOLD_M[1,2]);  	"START BEAM AT FIRST PNT"
	DOT_DASH_.1;				"COMPUTE DOT-DASH SIZES"
	CASE LTYPE-1 OF
	BEGIN
	   BEGIN "LINE TYPE 1 -- SOLID"
		FOR I_2 STEP 1 UNTIL IMAX DO DDRAW (M[I,1],M[I,2]);
		RETURN
	   END;
	   ;
	   DOT_DASH_.5;
	   DASH_.5;
	   BEGIN "LINE TYPE 5 -- ALTERNATING SOLID AND BLANK"
		FOR I_2 STEP 2 UNTIL IMAX DO DVECT (M[I-1,1],M[I-1,2],M[I,1],M[I,2]);
		RETURN
	   END
	END;
	DLEN_DOT;
	I_2;					"START INDEX INTO DATA ARRAY"
NXLINE:	IF DLEN= DOT THEN DLEN_DASH ELSE DLEN_DOT;
	TLEN _ 0.;				"TOTAL LENGTH OF LINE DRAWN SO FAR"
MORLINE:
	IF DTEST2(M[I-1,1],M[I-1,2]) LAND DTEST2(M[I,1],M[I,2]) THEN
	BEGIN "LINE IS TRIVIALLY REJECTABLE"
		DMOVE (XOLD_M[I,1],YOLD_M[I,2]);
		IF (I_I+1) > IMAX THEN RETURN; "BUMP TO LOOK AT NEXT LINE"
	END ELSE BEGIN "TRY TO SHOW SOME OF THE LINE"
		DX_M[I,1]-XOLD;
		DY_M[I,2]-YOLD;
		DXI_DX/HUNPERIN;
		DYI_DY/VUNPERIN;
		TTLEN_SQRT(DXI^2+DYI^2);  "LENGTH OF HYPOTENUSE"
		IF TLEN+TTLEN<DLEN THEN BEGIN
			   TLEN_TLEN+TTLEN;
			   DDRAW (XOLD_XOLD+DX,YOLD_YOLD+DY);
			   IF (I_I+1)>IMAX THEN RETURN;
			   GO TO MORLINE;
		END;
		THETA_ATAN2(DYI,DXI);
		R_DLEN-TLEN;
		DX_HUNPERIN*R*COS(THETA);
		DY_VUNPERIN*R*SIN(THETA);
		DDRAW (XOLD_XOLD+DX,YOLD_YOLD+DY);
		TLEN_0.;
MORSPAC:
		DX_M[I,1]-XOLD;
		DY_M[I,2]-YOLD;
		DXI_DX/HUNPERIN;
		DYI_DY/VUNPERIN;
		TTLEN_SQRT(DXI^2+DYI^2);
		IF TLEN + TTLEN < .1 THEN BEGIN
			   TLEN_TLEN+TTLEN;
			   IF (I_I+1) > IMAX THEN RETURN;
			   DMOVE (XOLD_XOLD+DX,YOLD_YOLD+DY);
			   GO TO MORSPAC;
		END;
		THETA_ATAN2(DYI,DXI);
		R_.1-TLEN;
		DX_HUNPERIN*R*COS(THETA);
		DY_VUNPERIN*R*SIN(THETA);
		DMOVE (XOLD_XOLD+DX,YOLD_YOLD+DY);
	END;
	GO TO NXLINE;

END;
COMMENT
***************************************************************************************************

	PLOT POINT SYMBOLS

GPOINT (REAL ARRAY M: PTYPE: HUNPERIN: VUNPERIN)
	CALL:	M = MATRIX OF COORDINATES OF POINTS
		PTYPE = SYMBOL CODE
			1 FOR VERTICAL LINE
			2 FOR CROSS
			3 FOR TRIANGLES
			4 FOR SQUARE
			5 FOR HORIZONTAL LINE
			6 FOR SMALL O SYMBOL
                        7 FOR TINY DOT
		HUNPERIN = NUMBER OF UNITS PER IN IN THE
			HORIZONTAL DIRECTION
		VUNPERIN = NUMBER OF UNITS PER INCH IN THE
			VERTICAL DIRECTION

	EFFECT:	POINT SYMBOLS ARE ADDED TO THE CURRENT PICTURE

***************************************************************************************************
;


SIMPLE PROCEDURE GPOINT (SAFE REAL ARRAY M; INTEGER PTYPE);
BEGIN
INTEGER IMAX,I;
REAL X,Y,XD1,XD2,YD1,YD2,SIZEQ;
STRING S;
	IMAX_ROWSIZE(M);			"GET NUMBER OF POINTS TO PLOT"
	XD1 _ .1*HUNPERIN;
	XD2 _ XD1+XD1;
	YD1 _ .1*VUNPERIN;
	YD2 _ YD1+YD1;
	S_"O"; SIZEQ_-.0068;
	IF PTYPE > 7 THEN BEGIN	S_PTYPE; PTYPE_6; SIZEQ_-.0127 END;
	DTSCAL (SIZEQ);				"SET DISPLAY TEXT SIZE"
       DENQ(DISINFO[1]);                        "GET CURRENT CHAR SIZES IN DISINFO"
	FOR I_1 STEP 1 UNTIL IMAX DO BEGIN "LOOP"
	X_M[I,1]; Y_M[I,2];
	CASE PTYPE OF
	   BEGIN
		;
		BEGIN "VERTICAL LINE"
		  DVECT (X,Y-YD1,X,Y-YD1+YD2);
		END;
		BEGIN "CROSS"
		  DVECT (X,Y-YD1,X,Y-YD1+YD2);
		  DVECT (X-XD1,Y,X-XD1+XD2,Y);
		END;
		BEGIN "TRIANGLE"
		  DVECT (X,Y,X,Y_Y+YD1);
		  DDRAW (X_X-XD1,Y_Y-YD2);
		  DDRAW (X_X+XD2,Y);
		  DDRAW (X-XD1,Y+YD2);
		END;
		BEGIN "SQUARE"
		  DVECT (X,Y,X,Y_Y+YD1);
		  DDRAW (X_X-XD1,Y);
		  DDRAW (X,Y_Y-YD2);
		  DDRAW (X_X+XD2,Y);
		  DDRAW (X,Y_Y+YD2);
		  DDRAW (X-XD1,Y);
		END;
		BEGIN "HORIZONTAL LINE"
		  DVECT (X-XD1,Y,X-XD1+XD2,Y);
		END;
		BEGIN "SMALL O"
		  IF NOT DTEST2 (X,Y) THEN BEGIN
			DMOVE (X-.5*DISINFO[10], Y-.5*DISINFO[9]);
			DTEXT (S);
		  END;
		END;
                BEGIN "SMALL DOT"
                  DDOT(X,Y)
                END
	   END;
	END "LOOP";
END;
SIMPLE PROCEDURE CURGEN (INTEGER WIND);
COMMENT
	FIND ALL CURVES IN A WINDOW
	UPDATE THEIR WINDOW PARAMETERS
	REGENERATE CURVES IF DISPLAY IS ON

	CALL:	WIND = INDEX OF WINDOW IN SYMTAB
;

BEGIN
INTEGER I,N;

	I_WIND;
	WHILE (I_VALUE[I]) NEQ WIND DO BEGIN
		N_IDX[I];
		IF (A[N] LAND INSW = 0) THEN ARRBLT(A[N+CSTW1],A[IDX[WIND]+WSTW1],4);
		CDRAW(I,WIND)
	END
END;
COMMENT
***************************************************************************************************

		SIMPLE PROCEDURES FOR REVISING THE WINDOW OR VIEWPORT PARAMETERS

WINDOWP (INT,U,V,X,Y)   UPDATE A WINDOW:
	CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
	    	U = WIDTH OF WINDOW IN DATA UNITS
		V = HEIGHT OF WINDOW IN DATA UNITS
		X = X COORDINATE OF LOWER LEFT HAND CORNER OF 
		     WINDOW
		Y = Y COORDINATE OF LOWER LEFT HAND CORNER OF
		      WINDOW
	EFFECT:	UPDATE WINDOW PARAMETERS IN THE A-NODE, AND
		REGENERATE THE DISPLAY FOR ALL CURVES IN THAT WINDOW.


IMAGE (INT,U,V,X,Y)	UPDATE VIEWPORT PARAMETERS:
	CALL:	INT = INDEX OF WINDOW IN SYMTAB
		U = WIDTH OF WINDOW IMAGE IN INCHES
		V = HEIGHT OF WINDOW IMAGE IN INCHES
		X = X COORDINATE OF  LOWER LEFT CORNER OF IMAGE
		Y = Y COORDINATE OF LOWER LEFT CORNER OF IMAGE
	EFFECT:	VIEWPORT PARAMETERS ARE UPDATED.  ALL CURVES IN THE
		WINDOW ARE REGENERATED.



IF, FOR EITHER SIMPLE PROCEDURE, THERE IS NO EXISTING WINDOW, A NEW ONE
IS CREATED WITH DEFAULT VALUES:
		IMAGE:  ENTIRE SCREEN.
		WINDOW:	10 BY 10 AT 0,0

IF THE NEW VALUES (PARAMETERS U,V,X,Y) ARE EQUAL TO 'DEFAULT', THE
OLD VALUES IN THOSE POSITIONS ARE RETAINED.



***************************************************************************************************
;

INTEGER SIMPLE PROCEDURE DEFWIND (INTEGER I);
BEGIN INTEGER K;
	PRELOAD!WITH 0,10,0,10,0,1,0,1;
	OWN SAFE REAL ARRAY DEFWIN[1:8];
	K_IDX[I];				"GET A-NODE POINTER"
	IF TYPE[I] = UNKNOWN THEN BEGIN "NO PREVIOUS WINDOW"
		TYPE[I] _ WINDOW;
		VALUE[I]_0;			"IN CASE NEWNODE HAS NONE TO GIVE"
		NEWNODE(K,A);
		ARRBLT(A[K],DEFWIN[1],8);	"FILL WITH DEFAULTS"
		IDX[I]_K;
		VALUE[I]_I;
	END ELSE IF TYPE[I] NEQ WINDOW THEN TYPEFORMERROR(I);
	RETURN (K);  				"A-NODE INDEX"
END;



INTERNAL SIMPLE PROCEDURE WINDOWP (INTEGER I; REAL U,V,X,Y);
BEGIN
INTEGER K,J; 
	K_DEFWIND (I);				"CHECK TO SEE IF WINDOW, CREATE DEFAULT ONE"
	IF X = DEFAULT THEN 
	BEGIN
	   X_REL(A[K+WSTW1]);
	   Y_REL(A[K+WSTW3]);
	END;
	IF U = DEFAULT THEN
	BEGIN
	   U_REL(A[K+WSTW2])-REL(A[K+WSTW1]);
	   V_REL(A[K+WSTW4])-REL(A[K+WSTW3]);
	END;
	A[K+WSTW1]_INT(X);
	A[K+WSTW2]_INT(X+U);
	A[K+WSTW3]_INT(Y);
	A[K+WSTW4]_INT(Y+V);
	CURGEN(I);
END;



INTERNAL SIMPLE PROCEDURE IMAGE (INTEGER I;REAL U,V,X,Y);
BEGIN
INTEGER K,J;REAL Q;
	K_DEFWIND (I);				"LOOK UP WINDOW, CREATE DEFAULT"
	IF NOT DISINIT THEN GINIT(CURRENTDIS);		"TO GET DISINFO FILLED UP"
	IF X = DEFAULT THEN BEGIN
	   X_REL(A[K+WSTP1]);
	   Y_REL(A[K+WSTP3]);
	END ELSE BEGIN
	   X_X/INCHESPERVIEWPORT;
	   Y_Y/INCHESPERVIEWPORT;
	END;
	IF U = DEFAULT THEN BEGIN
	   U_(REL(A[K+WSTP2])-REL(A[K+WSTP1]));
	   V_(REL(A[K+WSTP4])-REL(A[K+WSTP3]));
	END ELSE BEGIN
	   U_U/INCHESPERVIEWPORT;
	   V_V/INCHESPERVIEWPORT;
	END;
	IF X<0 OR U<0 OR X+U>MAXVIEWX+.00001 OR Y<0 OR V<0 OR Y+V>MAXVIEWY+.00001 THEN 
		ERROR("ILLEGAL IMAGE BOUNDS");
	A[K+WSTP1]_INT(X);
	A[K+WSTP3]_INT(Y);
	A[K+WSTP2]_INT(X+U);
	A[K+WSTP4]_INT(Y+V);
	CURGEN(I);
END;
COMMENT
***************************************************************************************************

	SIMPLE PROCEDURES FOR INSCRIBING AND UNSCRIBING CURVES.

INSCRIBE (INT)	MARK A CURVE OR CURVES AS INSCRIBED:
	CALL:	'INT' IS INDEX OF CURVE OR WINDOW IN SYMTAB.
	EFFECT:	IF 'INT' POINTS TO A CURVE, INSCRIBE THAT CURVE,
		OTHERWISE, IF 'INT' IS A WINDOW, INSCRIBE ALL THE
		CURVES IN THAT WINDOW.

		THE DISPLAY IS NOT REGENERATED.

UNSCRIBE (INT)	REMOVE A CURVE OR CURVES FROM INSCRIBED STATUS:
	CALL:	'INT' IS INDEX OF CURVE OR WINDOW IN SYMTAB.
	EFFECT:	IF 'INT' IS A CURVE, MERELY TURNS OFF 'INSW' BIT IN CURVE DESCRIPTION
		IF 'INT' IS A WINDOW, BIT IS TURNED OFF FOR ALL CURVES IN
			THE WINDOW
		ANY AFFECTED CURVES ARE REGENERATED

***************************************************************************************************
;

INTERNAL SIMPLE PROCEDURE INSCRIBE(INTEGER I);
BEGIN
SIMPLE PROCEDURE INSCRIBE1 (REFERENCE INTEGER I);
BEGIN INTEGER J;
	J_IDX[I];				"GET A-NODE POINTER"
	A[J]_A[J] LOR INSW;			"TURN ON THE INSCRIBED BIT"
END;
IF TYPE[I] NEQ WINDOW AND TYPE[I] NEQ CURVE THEN TYPEFORMERROR(I);
	MAPC (I,INSCRIBE1);			"DO FOR APPROPRIATE CURVES"
END;


INTERNAL SIMPLE PROCEDURE UNSCRIBE (INTEGER W);
BEGIN INTEGER WE;
SIMPLE PROCEDURE UNSCRIBE1 (REFERENCE INTEGER I);
BEGIN INTEGER K;
	K_IDX[I];
	A[K]_A[K] LAND INSWI;			"TURN OFF INSCRIBED BIT"
	ARRBLT(A[CSTW1+K],A[WSTW1+IDX[WE]],4);  "SHOVE IN WINDOW PARMS"
	CDRAW(I,WE);				"REDRAW THE CURVE"
END;
IF (WE_TYPE[W]) NEQ WINDOW AND WE NEQ CURVE THEN TYPEFORMERROR(W);
	WE_W;
	WHILE TYPE[WE] NEQ WINDOW DO WE_VALUE[WE];  "FIND WINDOW"
	MAPC (W,UNSCRIBE1);			"DO FOR ALL APPROPRIATE WINDOWS"
END;
COMMENT
***************************************************************************************************

		SIMPLE PROCEDURES FOR TYPING OUT INFORMATION ABOUT WINDOWS AND CURVES

WINTYP (INT,CHL)	TYPES OUT INFORMATION ABOUT A WINDOW:
	CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
		'CHL' IS AN I/O CHANNEL NUMBER ON WHICH TO TYPE.
	EFFECT:	THE CURVES IN THE WINDOW ARE LISTED,
		THE WINDOW AND VIEWPORT PARAMETERS ARE LISTED.

CURTYP (INT,CHL)	TYPES OUT INFORMATION ABOUT A CURVE:
	CALL:	'INT' IS INDEX OF CURVE IN SYMTAB.
		'CHL' IS AN I/O CHANNEL NUMBER ON WHICH TO TYPE.
	EFFECT:	THE NAME OF THE CURVE IS LISTED.
		IF THERE IS A CURVE MATRIX, THE NAME OF THE WINDOW IT IS IN,
			THE POINTTYPE, LINETYPE AND INTENSITY ARE LISTED.
		IF THERE IS A POINT LABEL MATRIX, THE POINT LABEL PARAMETERS ARE LISTED.
		IF THERE IS A STRING, ITS CHARACTERS, POSITION, AND SIZE ARE LISTED.

***************************************************************************************************
;


INTERNAL SIMPLE PROCEDURE WINTYP(INTEGER I,CHANNEL);
BEGIN
INTEGER K;
REAL W,L,X,Y;
	K_VALUE[I];
	LOUT(CHANNEL,NAME[I]&CRLF&"CURVES: ");
	WHILE K NEQ I DO 
	BEGIN
	   LOUT(CHANNEL,NAME[K]&" ");
	   K_VALUE[K];
	END;
	LOUT(CHANNEL,CRLF);

	K_IDX[I];
	X_REL(A[K+WSTW1]);
	Y_REL(A[K+WSTW3]);
	W_REL(A[K+WSTW2])-X;
	L_REL(A[K+WSTW4])-Y;
	OUTCR(CHANNEL,FANCYNUM(W)&" BY "&FANCYNUM(L)&" AT "&FANCYNUM(X)&
	","&FANCYNUM(Y));

	X_REL(A[K+WSTP1])*INCHESPERVIEWPORT;
	Y_REL(A[K+WSTP3])*INCHESPERVIEWPORT;
	W_REL(A[K+WSTP2])*INCHESPERVIEWPORT-X;
	L_REL(A[K+WSTP4])*INCHESPERVIEWPORT-Y;

	OUTCR(CHANNEL," IMAGE "&NAME[I]&CRLF&" "&FANCYNUM(W)&" BY "&
	FANCYNUM(L)&" AT "&FANCYNUM(X)&","&FANCYNUM(Y));
END;



INTERNAL SIMPLE PROCEDURE CURTYP(INTEGER I,CHANNEL);
BEGIN
STRING S;
INTEGER K,L,M,AK;

	K_IDX[I]; AK_A[K];  			"FLAG WORD"
	S_NAME[I];
	L_VALUE[I];
	WHILE TYPE[L] NEQ WINDOW DO L_VALUE[L];

	IF LOW(A[K+CM]) THEN BEGIN "TELL ALL ABOUT CURVE"
		M_HI(A[K+CINT]);
		S_S&" IN "&NAME[L]&
		    ", LINETYPE "&FANCYNUM((AK LAND LTYPEM) LSH -12)&
		    ", POINTTYPE "&
		    (IF M LEQ 7 THEN FANCYNUM(M) ELSE M)&
		    ", INTENSITY "&FANCYNUM(LOW(A[K+CINT]));
	IF HI(A[K+CM]) THEN BEGIN "TELL ALL ABOUT POINT LABELS"
		S_S&(IF AK LAND XFLTSW THEN " XFLOATING"
		     ELSE IF AK LAND YFLTSW THEN " YFLOATING" ELSE NULL)&
		    " LABEL AT "&FANCYNUM(REL(A[K+CPTLX]))&","&
		    FANCYNUM(REL(A[K+CPTLY]))&" SIZE "&
		   FANCYNUM((AK LSH -24) LAND STRM);
	END "TELL ALL ABOUT POINT LABELS"
	END "TELL ALL ABOUT CURVE";
	OUTCR(CHANNEL,S);

	IF A[K+CSTR] THEN BEGIN "THERE IS A STRING IN THIS CURVE"
		S_"STRING "&NAME[I]&" '"&ST[A[K+CSTR]]&"', IN "&
		   NAME[L]&", SIZE "&FANCYNUM((AK LAND STRM))&
		   ", AT "&FANCYNUM(REL(A[K+CSTRX]))&","&
		   FANCYNUM(REL(A[K+CSTRY]));
		OUTCR(CHANNEL,S);
	END "THERE IS A STRING IN THIS CURVE";

	IF AK LAND INSW THEN OUTCR(CHANNEL,"[INSCRIBED]");
	IF AK LAND BLANKSW THEN OUTCR(CHANNEL,"[BLANKED]");
END;
COMMENT
***************************************************************************************************

	SIMPLE PROCEDURES FOR SAVING AND USING WINDOWS.

WINSAV (INT)	SAVES A BINARY COPY OF INFORMATION ABOUT A WINDOW:
	CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
	EFFECT:	BINARY GOODIES ARE SAVED ON I/O CHANNEL 1.
		THE A-NODE FOR THE WINDOW IS SAVED,  AND FOR EACH CURVE IN THE WINDOW:
			THE NAME OF THE CURVE.
			THE A-NODE FOR THE CURVE.
			THE CURVE MATRIX.
			THE POINT-LABEL MATRIX.
			THE STRING.
		THE LIST OF CURVES IS TERMINATED WITH A 0.

		A COLLECTION OF SUBROUTINES IS USED:
			MATOUT	-- DUMPS BINARY FORM OF A MATRIX.
			SAVSTR  -- DUMPS BINARY FORM OF A STRING.

WINUSE (INT)	RETRIEVES A BINARY COPY OF INFORMATION ABOUT A WINDOW:
	CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
	EFFECT:	READS GOODIES FROM I/O CHANNEL 1.
		AN A-NODE FOR THE NEW WINDOW IS CREATED.
		FOR EACH CURVE STORED ON THE BINARY FILE,
			THE NAME IS ENTERED IN THE SYMBOL TABLE.
				(NOTE: NAME MAY HAVE TO BE CHANGED TO AVOID CONFLICT)
			AN A-NODE IS CREATED FOR THE CURVE INFO.
			THE CURVE AND POINT-LABEL MATRICES ARE RETRIEVED.
			THE STRING IS ENTERED IN THE ST ARRAY.

		A COLLECTION OF SUBROUTINES IS USED:
			MATIN   -- RETRIEVES A MATRIX FROM A FILE, AND
				   CREATES AN APPROPRIATE LEAP ITEM.
			USESTR  -- READS A BINARY REPRESENTATION OF A STRING.


***************************************************************************************************
;


INTERNAL SIMPLE PROCEDURE WINSAV(INTEGER I);
BEGIN
INTEGER K,L,CA,M;

	K_IDX[I];
	ARRYOUT(1,A[K],WTLEN);   		"WRITE OUT THE WINDOW STUFF"
	K_VALUE[I];
	WHILE K NEQ I DO BEGIN
		CA_IDX[K];
		SAVSTR(NAME[K]);  		"THE NAME OF THE CURVE"
		ARRYOUT(1,A[CA],CTLEN);  	"THE DESCRIPTOR OF THE CURVE"
		MATOUT(HI(A[CA+CM]));		"THE POINT LABEL MATRIX"
		MATOUT(LOW(A[CA+CM]));		"THE CURVE MATRIX"
		L_A[CA+CSTR];
		SAVSTR(IF L=0 THEN NULL ELSE ST[L]);   "THE STRING, IF ANY"
		K_VALUE[K];			"NEXT CURVE"
	END;
	WORDOUT(1,0);				"TERMINATE LIST"
END;


INTERNAL SIMPLE PROCEDURE WINUSE(INTEGER I);
BEGIN
INTEGER K,L,PC,N;
STRING S;

	NEWNODE(K,A);				"GET A NODE FOR THE WINDOW"
	ARRYIN(1,A[K],WTLEN);			"AND STUFF WITH  WINDOW INFO"
	IDX[I]_K;
	TYPE[I]_WINDOW;
	VALUE[I]_I;
	PC_I;
	WHILE TRUE DO BEGIN "GET ALL CURVES"
		S_USESTR;			"GET CURVE NAME"
		IF LENGTH(S) = 0 THEN DONE;
		DO BEGIN
			N_SYMTABENTRY(S);	"TRY TO MAKE A TABLE ENTRY"
			S_S&"A";		"PREPARE TO TRY ANOTHER NAME"
		END UNTIL TYPE[N] = UNKNOWN;
		VALUE[N]_I;
		NEWNODE(K,A);			"GET A-NODE FOR THE CURVE"
		IDX[N]_K;
		ARRYIN(1,A[K],CTLEN);		"AND READ IN CURVE STUFF"
		LOADHI(A[K+CM],MATIN);		"READ MATRICES FOR ... PT LABEL MATRIX"
		LOADLOW(A[K+CM],MATIN);		".. CURVE MATRIX"
		LOADHI(A[K+CP2],0);		"NO PICTURE IDS"
		A[K+CSP]_0;
		S_USESTR;			"GET CURVE STRING, IF ANY"
		IF LENGTH(S) = 0 THEN L_0 ELSE STUFFST(L,S);
		A[K+CSTR]_L;
		VALUE[PC]_N;
		PC_N;
		TYPE[N]_CURVE;
	END "GET ALL CURVES";
	CURGEN (I);				"REGENERATE PICTURE"
END;


END "GRAPH"
