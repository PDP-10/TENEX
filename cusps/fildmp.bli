00100	MODULE FILDMP(RESERVE(1,2,3),BREG=#15,FREG=#16,VREG=#17,STACK)=
00200	
00300	BEGIN
00400	  REGISTER R1=1, R2=2, R3=3 ;  !TENEX SYSTEM REGS
00500	
00600	  OWN SRCJFN; !JFN OF SOURCE FILE
00700	  OWN SRCJFK; !FORK HANDLE OF SOURCE (OR JFN)
00800	  OWN DSTJFN; !DESTINATION FILE JFN
00900	  OWN FMTFLG; !FORMAT FLAG WORD (BIT CODED)
01000	  OWN LINE;   !LINE NUMBER (USED FOR PAGE HEADERS)
01100	  OWN SOPTAB; !TABLE OF SPECIAL OPS (OP+REG)
01200	  OWN OPTAB;  !TABLE OF MORMAL OPS
01300	  OWN SYMFG;  !TRUE IF SYMBOL TABLE PRESENT (UNUSED)
01400	  OWN WDLFT;  !WORDS LEFT IN CURRENT PAGE
01500	  OWN WDTL;   !TALLY TO CURRENT WORD
01600	  OWN NADDRS; !NEXT ADDRESS
01700	  OWN EOFFG;  !END OF FILE IF TRUE
01800	  OWN NPGFG;  !PAGE SKIP FLAG
01900	  OWN MPGS;   !PAGES SKIPPED WORD (FROM,,TO)
02000	  OWN ADDRSS; !ADDRESS OF CURRENT WORD
02100	  OWN HLMT;   !CURRENT HIGH PAGE LIMIT
02200	  OWN LMTCNT; !LIMIT TABLE POINTER
02300	  OWN LMTTB[50]; !LIMIT TABLE
02400	  OWN TRM;    !TERMINATOR FROM LAST COMMAND
02500	  OWN WPL;    !WORDS PER LINE ON OCTAL DUMP
02600	
02700	
02800	%   BITS DEFINED FOR FMTFLG WORD--ON MEANS PRINT%
02900	
03000	  BIND BITO=#400000, !OCTAL (INCOMPATIBLE WITH REST)
03100	       BITA=#200000, !ADDRESS
03200	       BITH=#100000, !HALF WORDS OF OCTAL
03300	       BITD=#040000, !DECIMAL
03400	       BITF=#020000, !FLOATING POINT
03500	       BITT=#010000, !TEXT--ASCII
03600	       BIT6=#004000, !SIXBIT ASCII
03700	       BIT5=#002000, !RADIX50
03800	       BITS=#001000; !SYMBOLIC
03900	
04000	  BIND MXLPP=52; !MAX NUMBER OF LINES PER PAGE
04100	
     

00100	
00200	%   MACHINE OP CODE DEFINITIONS %
00300	
00400	  MACHOP EXCH=#250,
00500	         FSC=#132,
00600	         JSYS=#104,
00700	         JSP=#265,
00800	         BLT=#251;
00900	
01000	  MACRO BKJFN=JSYS(,#42)$,
01100	        BIN=JSYS(,#50)$,
01200	        BOUT=JSYS(,#51)$,
01300	        CFORK=JSYS(,#152)$,
01400	        CLOSF=JSYS(,#22)$,
01500	        ERSTR=JSYS(,#11)$,
01600	        FFUFP=JSYS(,#211)$,
01700	        FLOUT=JSYS(,#233)$,
01800	        GET=JSYS(,#200)$,
01900	        GTJFN=JSYS(,#20)$,
02000	        HALTF=JSYS(,#170)$,
02100	        KFORK=JSYS(,#153)$,
02200	        NIN=JSYS(,#225)$,
02300	        NOUT=JSYS(,#224)$,
02400	        OPENF=JSYS(,#21)$,
02500	        PBIN=JSYS(,#73)$,
02600	        PBOUT=JSYS(,#74)$,
02700	        PMAP=JSYS(,#56)$,
02800	        PSOUT=JSYS(,#76)$,
02900	        RESET=JSYS(,#147)$,
03000	        RLJFN=JSYS(,#23)$,
03100	        RPACS=JSYS(,#57)$,
03200	        SOUT=JSYS(,#53)$;
03300	
03400	
03500	  MACRO PSTR=PLIT ASCIZ$;
03600	
03700	  MACRO FMTTST(BIT)=(.FMTFLG AND BIT) NEQ 0$;
03800	
03900	  MACRO UPPER=18,18$,
04000	        LOWER=0,18$;
04100	
04200	  FORWARD OTEOL;
04300	
     

00100	ROUTINE ERROR(MES,TYP)=
00200	
00300	%   PRINT ERROR MESSAGE OF TYPE GIVEN.  THE MESSAGE IS EITHER
00400	       POINTED TO BY .MES OR IS THE TENEX MESSAGE WITH THAT
00500	       NUMBER. %
00600	
00700	BEGIN
00800	  IF (.TYP AND 1) EQL 0 THEN
00900	    BEGIN
01000	      R2_#400000000000+.MES;
01100	      R1_#37;
01200	      PBOUT;
01300	      R1_#101;
01400	      R3_0;
01500	      ERSTR; !PRINT TENEX ERROR MESSAGE
01510	      R1_0; R1_0;
01600	    END
01700	                       ELSE
01800	    BEGIN
02000	      R1_#37;
02100	      PBOUT;
02200	      R1_.MES;
02300	      R1<UPPER>_-1;
02400	      PSOUT; !PRINT GIVEN MESSAGE
02500	    END;
02600	
02700	  R1_#37;
02800	  PBOUT;
02900	  IF (.TYP AND 2) NEQ 0 THEN HALTF; !HALT IF TERMINAL
03000	
03100	END;
03200	
     

00100	ROUTINE OTCHR(CHR)=
00200	
00300	%   PRINT CHARACTER IN OUTPUT STREAM%
00400	
00500	BEGIN
00600	  R1_.DSTJFN;
00700	  R2_.CHR;
00800	  BOUT;
00900	END;
01000	
01100	
01200	
01300	ROUTINE OTNUM(VAL,RDX,BTS)=
01400	
01500	%   PRINT NUMBER (.VAL) IN THE RADIX (.RDX) WITH THE FORMAT
01600	       SPECIFIED BY .BTS (SEE TENEX NOUT DESCRIPTION) %
01700	
01800	BEGIN
01900	  R1_.DSTJFN;
02000	  R2_.VAL;
02100	  R3_.BTS^18+.RDX;
02200	  NOUT;
02300	END;
02400	
02500	
02600	
02700	ROUTINE TAB(CNT)=
02800	
02900	%   PRINT .CNT SPACES IN OUTPUT STREAM %
03000	
03100	BEGIN
03200	  R1_.DSTJFN;
03300	  R2_" ";
03400	  INCR I FROM 1 TO .CNT DO BOUT;
03500	END;
03600	
03700	
03800	
03900	ROUTINE OTSTR(STR)=
04000	
04100	%   PRINT TEXT POINTED TO ON ENTRY IN OUTPUT STREAM %
04200	
04300	BEGIN
04400	  R1_.DSTJFN;
04500	  R2_.STR;
04600	  R2<UPPER>_-1;
04700	  R3_0;
04800	  SOUT;
04900	END;
05000	
     

00100	ROUTINE OTHDR=
00200	
00300	%   THIS ROUTINE PRINTS THE HEADER ON A NEW PAGE AND RESETS
00400	       THE LINE COUNT. %
00500	
00600	BEGIN
00700	  OTCHR(#014); !SLEW TOP OF PAGE
00800	  LINE_0; !RESET LINE COUNT
00900	  
01000	  IF FMTTST(BITO) THEN RETURN; !NO HDR FOR OCTAL
01100	
01200	  OTCHR(" ");
01300	  IF FMTTST(BITA) THEN OTSTR(PSTR 'ADDRESS   ');
01400	  IF FMTTST(BITH) THEN OTSTR(PSTR '    OCTAL HALF    ');
01500	  IF FMTTST(BITD) THEN OTSTR(PSTR '       DECIMAL  ');
01600	  IF FMTTST(BITF) THEN OTSTR(PSTR '  FLOATING POINT  ');
01700	  IF FMTTST(BITT) THEN OTSTR(PSTR '   ASCII   ');
01800	  IF FMTTST(BIT6) THEN OTSTR(PSTR '   SIXBIT   ');
01900	  IF FMTTST(BIT5) THEN OTSTR(PSTR '   RADIX50   ');
02000	  IF FMTTST(BITS) THEN OTSTR(PSTR '  SYMBOLIC INSTRUCTION   ');
02100	  OTEOL();
02200	  OTEOL();
02300	
02400	END;
02500	
     

00100	ROUTINE OTEOL=
00200	
00300	%   THIS ROUTINE ENDS THE CURRENT LINE, PROCEDING TO A NEW
00400	       PAGE IF NECESSARY. %
00500	
00600	BEGIN
00700	  OTCHR(#37);
00800	  LINE_.LINE+1;
00900	  IF .LINE GEQ MXLPP THEN OTHDR(); !NEW PAGE
01000	END;
01100	
     

00100	ROUTINE RDX50(CHR)=
00200	
00300	%   CONVERTS A RADIX 50 CHR TO ASCII AND RETURNS THE ASCII VALUE %
00400	
00500	BEGIN
00600	  REGISTER CH;
00700	
00800	  CH_.CHR;
00900	  IF .CH EQL 0 THEN RETURN(" ");
01000	  IF .CH LEQ 10 THEN RETURN("0"+.CH-1);
01100	  IF .CH LEQ 36 THEN RETURN("A"+.CH-11);
01200	  IF .CH EQL #45 THEN RETURN(".");
01300	  IF .CH EQL #46 THEN RETURN("$");
01400	  IF .CH EQL #47 THEN RETURN("%");
01500	  RETURN("??");
01600	END;
01700	
     

00100	ROUTINE OTSYM(WORD,FLG,CNT)=
00200	
00300	%   THIS ROUTINE PRINTS A RADXI50 SYMBOL GIVEN IN WORD.  IF FLAG
00400	       IF NON-ZERO THEN 6 CHRS ARE PRINTED ELSE ONLY THE ACTIVE
00500	        CHRS ARE PRINTED.  .CNT IS INCREMENTED ONCE FOR EACH 
00600	       CHARACTER PRINTED. %
00700	
00800	BEGIN
00900	  REGISTER X,VAL,CH;
01000	  X_PLIT(40*40*40*40*40,40*40*40*40,40*40*40,40*40,40,1);
01100	  VAL_.WORD<0,32>;
01200	
01300	  INCR I FROM 1 TO 6 DO
01400	    BEGIN
01500	      CH_.VAL / @.X;
01600	      VAL_.VAL MOD @.X;
01700	      CH_RDX50(.CH);
01800	
01900	      IF .CH NEQ " " OR .FLG NEQ 0 THEN
02000	            (FLG_1; OTCHR(.CH); .CNT_@.CNT+1);
02100	      X_.X+1;
02200	    END;
02300	
02400	END;
02500	
     

00100	ROUTINE OTOP(VAL,NVAL,CNT)=
00200	
00300	%   THIS ROUTINE PRINTS THE OPCODE OF THE INSTRUCTION GIVEN IN
00400	       .VAL AND RETURNS THE REMAINDER OF THE INSTRUCTION IN NVAL.
00500	       CNT IS INCREMENTED ONCE FOR EACH CHR PRINTED. %
00600	
00700	BEGIN
00800	  REGISTER X,PT;
00900	  LOCAL SYM;
01000	
01100	  X_.VAL AND #777740000000; !LOOK FOR SPECIAL OP
01200	  PT_.SOPTAB+1;
01300	  SYM_0;
01400	  INCR I FROM 1 TO @.SOPTAB DO
01500	    IF @.PT EQL .X THEN
01600	        (SYM_.(.PT+1); .NVAL_.VAL-.X; EXITLOOP);
01700	
01800	  IF .SYM EQL 0 THEN
01900	    BEGIN
02000	      X_.VAL<27,9>; !FIND NORMAL OP IF SPECIAL NOT FOUND
02100	      SYM_@(.OPTAB+.X);
02200	      .NVAL_.VAL<0,27>;
02300	    END;
02400	
02500	  IF .SYM EQL 0 THEN
02600	    BEGIN
02700	      OTCHR("/");
02800	      OTNUM(.VAL<27,9>,8,#140003); !HANDLE UNDEF OP
02900	      .CNT_@.CNT+4;
03000	    END
03100	                ELSE
03200	    WHILE .SYM NEQ 0 DO
03300	      BEGIN
03400	        X_.SYM<30,6>; !HANDLE SIXBIT OP
03500	        SYM_.SYM^6;
03600	        OTCHR(.X+#40);
03700	        .CNT_@.CNT+1;
03800	      END;
03900	
04000	END;
04100	
     

00100	ROUTINE OCTSIZ(NUM)=
00200	
00300	%   THIS ROUTINE RETURNS THE NUMBER OF DIGITS NEEDED TO PRINT
00400	       THE NUMBER .NUM IN OCTAL.%
00500	
00600	BEGIN
00700	  IF (R1_.NUM) EQL 0 THEN RETURN (1); !HANDLE 0
00800	
00900	  RETURN((36+2-FIRSTONE(.R1))/3); !RETURN RESULT
01000	END;
01100	
     

00100	ROUTINE LOOKUP(VAL,MDL,SYM,DEL)=
00200	
00300	%   THIS ROUTINE TAKES VAL AND ATTEMPTS TO MATCH IT WITH A SYMBOL
00400	       AND A DELTA FROM THAT SYMBOL (SYM,DEL).  THE MAX
00500	       DELTA ALLOWED IS GIVEN IN MDL.  CURRENTLY IT DOES
00600	       NOTHING. %
00700	
00800	BEGIN
00900	  .SYM_0;
01000	  .DEL_0;
01100	END;
01200	
     

00100	ROUTINE FOTSYM(VAL,MDL,CNT)=
00200	
00300	%   THIS ROUTINE TAKES VAL AND PRINTS IT EITHER AS AN OCTAL
00400	      NUMBER OR AS A SYMBOL WITH A DELTA (MAX DELTA IS MDL). IT
00500	      UPDATES CNT BY ADDING ONE FOR EACH CHR PRINTED. %
00600	
00700	BEGIN
00800	  LOCAL SYM,DEL;
00900	
01000	  SYM_0;
01100	  IF .SYMFG NEQ 0 THEN LOOKUP(.VAL,.MDL,SYM,DEL); !FIND SYMBOL
01200	
01300	  IF .SYM NEQ 0 THEN
01400	    BEGIN
01500	      OTSYM(.SYM,0,.CNT); !PRINT SYMBOL AND DELTA
01600	      IF .DEL NEQ 0 THEN
01700	        BEGIN
01800	          OTCHR("+");
01900	          OTNUM(.DEL,8,#000003);
02000	          .CNT_@.CNT+1+OCTSIZ(.DEL);
02100	        END;
02200	    END
02300	                ELSE
02400	    BEGIN
02500	      OTNUM(.VAL,8,#000000); !PRINT OCTAL VALUE
02600	      .CNT_@.CNT+OCTSIZ(.VAL);
02700	    END;
02800	
02900	END;
03000	
     

00100	ROUTINE CHKLMT=
00200	
00300	%   THIS ROUTINE MAKES SURE THAT THE NEXT PAGE TO BE PRINTED
00400	       FALLS WITHIN THE LIMITS TO BE DUMPED GIVEN BY THE USER.
00500	       IF NOT, IT PROCEDES TO THE NEXT GOOD PAGE. %
00600	
00700	IF .SRCJFK<LOWER> GTR .HLMT THEN
00800	  BEGIN
00900	    NPGFG_-1;
01000	    LMTCNT_.LMTCNT+1;
01100	    IF .LMTTB[.LMTCNT] EQL -1 THEN
01200	      BEGIN
01300	        NPGFG_0;
01400	        EOFFG_1; !NO MORE TO DO--FAKE EOF
01500	        RETURN;
01600	      END;
01700	    SRCJFK<LOWER>_.LMTTB[.LMTCNT]<UPPER>; !GET NEXT VALID PG
01800	    HLMT_.LMTTB[.LMTCNT]<LOWER>;
01900	  END;
02000	
     

00100	ROUTINE NXTUSD(PGN)=
00200	
00300	%   THIS ROUTINE FINDS THE NEXT USED PAGE IN THE FILE AND RETURNS
00400	       THE NUMBER OF THAT PAGE.  IF NO MORE EXISTS, THEN -1 IS
00500	       RETURNED. %
00600	
00700	BEGIN
00800	  IF .SRCJFK GTR 0 THEN
00900	    BEGIN
01000	      R1_.SRCJFK;
01100	      FFUFP;  !FIND FREE PAGE IN FILE
01200	      R1_0;
01300	      SRCJFK<LOWER>_.R1<LOWER>;
01400	      IF .R1 EQL 0 THEN RETURN(-1)
01500	          ELSE RETURN(.R1<LOWER>-1);
01600	    END;
01700	
01800	  WHILE (SRCJFK_.SRCJFK+1; .SRCJFK<LOWER>) LSS 512 DO
01900	    BEGIN
02000	      R1_.SRCJFK;
02100	      RPACS;    !FIND NEXT FREE PAGE IN FORK
02200	      IF (.R2 AND #010000000000) NEQ 0 THEN RETURN(.R1<LOWER>-1);
02300	    END;
02400	
02500	  RETURN(-1); !PAGE NOT FOUND
02600	END;
02700	
     

00100	ROUTINE NEXTPG=
00200	
00300	%   THIS ROUTINE MAPS THE NEXT PAGE INTO CORE AND SETS THE
00400	       VARIOUS PARAMETERS FOR READING FROM IT.  THE FLAGS NPGFG
00500	       AND EOFFG ARE SET WHEN PAGES ARE SKIPPED OR THE END OF
00600	       FILE IS REACHED. %
00700	
00800	WHILE 1 DO
00900	  BEGIN
01000	    LOCAL FFRE,LFRE;
01100	    CHKLMT(); !CHECK USER LIMITS GIVEN FOR PAGES
01200	
01300	    R1_.SRCJFK;
01400	    RPACS; !CHECKIF CURRENT PAGE EXISTS
01500	    IF (.R2 AND #100000000000) NEQ 0 THEN
01600	      BEGIN
01700	        R2_#400000000000+#677;
01800	        R3_#100000000000; !MAP PAGE INTO CORE TO READ
01900	        PMAP;
02000	        WDLFT_511; !FULL PAGE
02100	        WDTL_#677000<36,36>;
02200	        NADDRS_.SRCJFK<0,18>^9-1;
02300	        SRCJFK_.SRCJFK+1;
02400	        RETURN;
02500	      END;
02600	
02700	    WDTL_#677000<36,36>;
02800	    FFRE_.SRCJFK<LOWER>; !FIRST FREE PAGE
02900	    LFRE_NXTUSD(.FFRE); !LAST FREE PAGE
03000	
03100	    IF .LFRE LSS 0 THEN (EOFFG_1; RETURN); !HANDLE EOF
03200	
03300	    MPGS_.FFRE^18+.LFRE; !SAVE FOR MESSAGE
03400	    NPGFG_1;
03500	  END;
03600	
     

00100	ROUTINE NEXTWD=
00200	
00300	%   THIS ROUTINE RETURNS THE NEXT WORD IN THE FILE/FORK.  IT KEEPS
00400	      ONE WORD AHEAD SO THAT EOFFG INDICATES THAT THIS IS THE LAST
00500	      WORD AND NPGFG INDICATES THAT THERE IS A BREAK AFTER THIS
00600	      WORD. %
00700	
00800	BEGIN
00900	  OWN NEWWD,NEWADD;
01000	  REGISTER WD;
01100	
01200	  IF .EOFFG THEN
01300	    BEGIN
01400	      OTEOL(); !HANDLE PAST END OF FILE
01500	      OTSTR(PSTR '***END OF DATA');
01600	      RETURN(0);
01700	    END;
01800	
01900	  IF .NPGFG NEQ 0 THEN
02000	    BEGIN
02100	      OTEOL();
02200	      ADDRSS_.NADDRS;
02300	      IF .NPGFG LSS 0 THEN NPGFG_0 ELSE
02400	        BEGIN
02500	          IF .MPGS<UPPER> EQL .MPGS<LOWER> THEN
02600	              OTSTR(PSTR '***MISSING PAGE ') ELSE
02700	              BEGIN
02800	                OTSTR(PSTR '***MISSING PAGES ');
02900	                OTNUM(.MPGS<UPPER>,8,0);
03000	                OTCHR("-");
03100	              END;
03200	          OTNUM(.MPGS<LOWER>,8,0);
03300	          NPGFG_0;
03400	          OTEOL();
03500	          OTEOL();
03600	        END;
03700	    END;
03800	
03900	  WDLFT_.WDLFT-1;
04000	  IF .WDLFT LSS 0 THEN NEXTPG();
04100	  ADDRSS_.ADDRSS+1;
04200	  WD_SCANI(WDTL); !GET NEXT WORD
04300	  EXCH(WD,NEWWD); !SAVE FOR NEXT TIME, GET PREVIOUS
04400	  RETURN(.WD);
04500	
04600	END;
04700	
     

00100	ROUTINE DMPA=
00200	
00300	%  PRINT THE CURRENT ADDRESS. %
00400	
00500	  BEGIN
00600	    OTNUM(.ADDRSS,8,#100010);
00700	    TAB(2);
00800	  END;
00900	
     

00100	ROUTINE DMPH(WORD)=
00200	
00300	%   PRINT THE WORD GIVEN IN OCTAL HALF WORDS. %
00400	
00500	BEGIN
00600	  TAB(2);
00700	  OTNUM(.WORD<UPPER>,8,#540006);
00800	  OTCHR(",");
00900	  OTCHR(",");
01000	  OTNUM(.WORD<LOWER>,8,#540006);
01100	  TAB(2);
01200	END;
01300	
     

00100	ROUTINE DMPD(WORD)=
00200	
00300	%   PRINT THE WORD GIVEN AS DECIMAL. %
00400	
00500	BEGIN
00600	  OTNUM(.WORD,10,#100016);
00700	  TAB(2);
00800	END;
00900	
     

00100	ROUTINE DMPF(WORD)=
00200	
00300	%   PRINT THE WORD GIVEN AS FLOATING POINT. %
00400	
00500	BEGIN
00600	  LOCAL NRMFG; !INDICATE IF NORMALIZED
00700	  NRMFG_" ";      !SPACE--YES; '#'--NO
00800	
00900	  TAB(2);
01000	  R1_.DSTJFN;
01100	  R2_.WORD;
01200	  FSC(R2,0);
01300	  IF .R2 NEQ .WORD THEN NRMFG_"#";
01400	
01500	  R3_#225207020604;
01600	  FLOUT;
01700	    R1_0; !IGNORE FAIL
01800	
01900	  OTCHR(.NRMFG);
02000	  TAB(2);
02100	END;
02200	
     

00100	ROUTINE DMPT(WORD)=
00200	
00300	%   PRINT THE WORD GIVEN AS ASCII TEXT %
00400	
00500	BEGIN
00600	  LOCAL ITAL;
00700	  REGISTER CH;
00800	
00900	  ITAL_WORD<36,7>;
01000	  TAB(2);
01100	  OTCHR("'");
01200	
01300	  DECR I FROM 4 TO 0 DO
01400	    BEGIN
01500	      CH_SCANI(ITAL);
01600	      IF .CH LSS " " THEN CH_"??";
01700	      IF .CH EQL #177 THEN CH_"??";
01800	      OTCHR(.CH);
01900	    END;
02000	
02100	  OTCHR("'");
02200	  TAB(2);
02300	END;
02400	
     

00100	ROUTINE DMP6(WORD)=
00200	
00300	%   PRINT THE WORD GIVEN AS SIXBIT TEXT %
00400	
00500	BEGIN
00600	  LOCAL ITAL;
00700	  REGISTER CH;
00800	
00900	  ITAL_WORD<36,6>;
01000	  TAB(2);
01100	  OTCHR("'");
01200	
01300	  DECR I FROM 5 TO 0 DO
01400	    BEGIN
01500	      CH_SCANI(ITAL);
01600	      OTCHR(.CH+#40);
01700	    END;
01800	
01900	  OTCHR("'");
02000	  TAB(2);
02100	END;
02200	
     

00100	ROUTINE DMP5(WORD)=
00200	
00300	%   PRINT THE WORD GIVEN AS RADIX50 %
00400	
00500	BEGIN
00600	  LOCAL TMP;
00700	
00800	  TAB(2);
00900	  OTNUM(.WORD<32,4>^2,8,#140002);
01000	  OTCHR(",");
01100	  OTSYM(.WORD,1,TMP);
01200	  TAB(2);
01300	END;
01400	
     

00100	ROUTINE DMPS(WORD)=
00200	
00300	%   THIS ROUTINE PRINTS THE WORD GIVEN AS SYMBOLIC INSTRUCTION. %
00400	
00500	BEGIN
00600	  REGISTER X;
00700	  LOCAL CNT,NWRD;
00800	
00900	  TAB(2);
01000	  CNT_0;
01100	  OTOP(.WORD,NWRD,CNT); !PRINT THE OP CODE
01200	
01300	  IF .CNT LSS 7 THEN (TAB(7-.CNT); CNT_7);
01400	
01500	  X_.NWRD<23,4>;
01600	  IF .X NEQ 0 THEN
01700	    BEGIN
01800	      OTNUM(.X,8,#000000); !PRINT REG FIELD
01900	      OTCHR(",");
02000	      CNT_.CNT+1+(IF .X GEQ 8 THEN 2 ELSE 1);
02100	    END;
02200	
02300	  X_.NWRD<22,1>;
02400	  IF .X NEQ 0 THEN (OTCHR("@"); CNT_.CNT+1); !PRINT INDIRECT FLG
02500	
02600	  X_.NWRD<LOWER>;
02700	  FOTSYM(.X,63,CNT); !PRINT THE ADDRESS
02800	
02900	  X_.NWRD<18,4>;
03000	  IF .X NEQ 0 THEN
03100	    BEGIN
03200	      OTCHR("(");
03300	      OTNUM(.X,8,#000000); !PRINT INDEX FIELD
03400	      OTCHR(")");
03500	      CNT_.CNT+2+(IF .X GEQ 8 THEN 2 ELSE 1);
03600	    END;
03700	
03800	  TAB(25-.CNT);
03900	END;
04000	
     

00100	ROUTINE NRMDMP=
00200	
00300	%   NRMDMP IS THE MAIN DRIVER DUMP ROUTINE FOR A MIXED MODE DUMP
00400	      OF SOME KIND.  IT DUMPS THE SPECIFIED WORDS OF THE
00500	      FILE IN THE SPECIFIED FORMAT. %
00600	
00700	BEGIN
00800	  OWN LSTWD;
00900	  LOCAL WORD,MTCHFG;
01000	
01100	  MTCHFG_-1;
01200	
01300	  WHILE .EOFFG EQL 0 DO
01400	    BEGIN
01500	      WORD_NEXTWD();
01600	      IF (.EOFFG EQL 0) AND
01700	         (.NPGFG EQL 0) AND
01800	         (.MTCHFG GEQ 0) AND
01900	         (.WORD EQL .LSTWD) THEN
02000	             (IF .MTCHFG EQL 0 THEN OTEOL(); MTCHFG_1)
02100	                           ELSE
02200	          BEGIN
02300	            IF .MTCHFG GTR 0 THEN OTCHR("*") ELSE OTCHR(" ");
02400	            IF FMTTST(BITA) THEN DMPA();
02500	            IF FMTTST(BITH) THEN DMPH(.WORD);
02600	            IF FMTTST(BITD) THEN DMPD(.WORD);
02700	            IF FMTTST(BITF) THEN DMPF(.WORD);
02800	            IF FMTTST(BITT) THEN DMPT(.WORD);
02900	            IF FMTTST(BIT6) THEN DMP6(.WORD);
03000	            IF FMTTST(BIT5) THEN DMP5(.WORD);
03100	            IF FMTTST(BITS) THEN DMPS(.WORD);
03200	            OTEOL();
03300	            MTCHFG_(IF .EOFFG OR .NPGFG THEN -1 ELSE 0);
03400	            LSTWD_.WORD;
03500	          END;
03600	      END;
03700	END;
03800	
     

00100	ROUTINE OCTDMP=
00200	
00300	%   THIS IS THE DRIVER ROUTINE FOR PRODUCING AN OCTAL DUMP.  THIS
00400	      IS A DUMP WITH EIGHT WORDS PER LINE, ALL OCTAL.  %
00500	
00600	BEGIN
00700	  OWN OLDBF[8],BF[8];
00800	  LOCAL ADDR,MTCHFG;
00900	
01000	  MTCHFG_-1;
01100	  WHILE .EOFFG EQL 0 DO
01200	    BEGIN
01300	      BF[0]_NEXTWD();
01400	      ADDR_.ADDRSS;
01500	      INCR I FROM 1 TO .WPL DO BF[.I]_NEXTWD();
01600	
01700	      IF (.MTCHFG GEQ 0) AND (.EOFFG EQL 0) AND (.NPGFG EQL 0) THEN
01800	        BEGIN
01900	          INCR I FROM 0 TO .WPL DO
02000	            IF .BF[.I] NEQ .OLDBF[.I] THEN EXITCOND[2];
02100	          IF .MTCHFG EQL 0 THEN (OTEOL(); MTCHFG_1);
02200	          EXITCOMPOUND[2];
02300	        END;
02400	
02500	      IF .MTCHFG EQL 1 THEN OTCHR("*") ELSE OTCHR(" ");
02600	      OTNUM(.ADDR,8,#560006);
02700	      TAB(1);
02800	      INCR I FROM 0 TO .WPL DO
02900	        BEGIN
03000	          TAB(3);
03100	          OTNUM(.BF[.I],8,#540014);
03200	        END;
03300	
03400	      OTEOL();
03500	      MTCHFG_(IF .EOFFG OR .NPGFG THEN -1 ELSE 0);
03600	      R1<UPPER>_BF;
03700	      R1<LOWER>_OLDBF;
03800	      BLT(R1,OLDBF+.WPL);
03900	    END;
04000	
04100	END;
04200	
     

00100	ROUTINE INIT=
00200	
00300	%   INITIALIZES VARIABLES NEEDED BY PROGRAM. %
00400	
00500	BEGIN
00600	  RESET;
00700	  SRCJFN_SRCJFK_DSTJFN_FMTFLG_0;
00800	  LINE_0;
00900	  SYMFG_0;
01000	  WDLFT_0;
01100	  NADDRS_WDTL_0;
01200	  EOFFG_NPGFG_MPGS_0;
01300	  ADDRSS_-2;
01400	  WPL_7;
01500	
01600	  R1_#37; !PRINT HEADER
01700	  PBOUT;
01800	  R1_PSTR 'FILE DUMPER';
01900	  R1<UPPER>_-1;
02000	  PSOUT;
02100	  R1_#37;
02200	  PBOUT;
02300	  PBOUT;
02400	END;
02500	
     

00100	ROUTINE GETJFN(FLGS,MESS,SVJ)=
00200	
00300	%   THIS ROUTINE PRINTS THE MESSAGE GIVEN AND REQUESTS A FILE
00400	      NAME FROM THE USER AND RETURNS THE JFN OF THAT FILE TO SVJ
00500	      FOR THE USER. %
00600	
00700	BEGIN
00800	  DO
00900	    BEGIN
01000	      R1<LOWER>_.MESS;
01100	      R1<UPPER>_-1;
01200	      PSOUT;
01300	      R1<UPPER>_.FLGS+3;
01400	      R1<LOWER>_0;
01500	      R2<UPPER>_#100;
01600	      R2<LOWER>_#101;
01700	      GTJFN; !GET FILE FROM TTY FROM USER
01800	      R2_-1;
01900	      IF .R2 LSS 0 THEN (ERROR(.R1,0); R2_-1);
02000	    END
02100	      UNTIL .R2 GTR 0;
02200	
02300	  .SVJ_.R1; !SAVE NEW JFN
02400	  R1_#100;
02500	  !   BKJFN; R3_0;
02600	  PBIN; !GET TERMINATOR
02700	  TRM_.R1; !SAVE TERMINATOR
02800	END;
02900	
     

00100	ROUTINE GETSRC=
00200	
00300	%   THIS ROUTINE ASKS THE USER F0OR THE SOURCE FILE AND SETS IT
00400	      UP AS A FORK/JFN FOR FUTURE READING. %
00500	
00600	BEGIN
00700	  GETJFN(#140000,PSTR 'FROM--',SRCJFN); !GET JFN OF SOURCE
00800	  SRCJFK_.SRCJFN^18;
00900	
01000	
01100	  IF .TRM EQL "/" THEN
01200	    BEGIN
01300	      PBIN;
01400	      SELECT .R1 OF NSET
01500	        "S": BEGIN
01600	               R1_#200000000000;
01700	               CFORK;  !GET A FORK FOR SAV FILES
01800	               R2_0;
01900	               SRCJFK_R1_.R1^18;
02000	               R1<LOWER>_.SRCJFN;
02100	               GET;
02200	             END;
02300	        OTHERWISE: ERROR(PSTR 'ILLEGAL FLAG--IGNORED',1);
02400	      TESN;
02500	      PBIN; !GET NEXT CHR
02600	      TRM_.R1; !SAVE AS TERM
02700	    END
02800	                  ELSE
02900	    BEGIN
03000	      R1_.SRCJFN;
03100	      R2_#440000010000;
03200	      OPENF; !OPEN FOR READING
03300	      R2_0;
03400	      IF .R2 EQL 0 THEN ERROR(.R1,2);
03500	    END;
03600	  
03700	  R1_#37;
03800	  PBOUT;
03900	END;
04000	
     

00100	ROUTINE GETDST=
00200	
00300	%   THIS ROUTINE ASKS THE USER FOR THE DESTINATION FILE AND GETS
00400	      A JFN FOR IT AND OPENS IT FOR WRITING TO. %
00500	
00600	BEGIN
00700	  GETJFN(#440000,PSTR 'TO--',DSTJFN); !GET JFN
00800	  R1_.DSTJFN;
00900	  R2_#070000120000;
01000	  OPENF; !OPEN FOR APPEND
01100	  R2_0;
01200	  IF .R2 EQL 0 THEN ERROR(.R1,2);
01300	
01400	  R1_#037;
01500	  PBOUT;
01600	END;
01700	
     

00100	ROUTINE GETFMT=
00200	
00300	%   THIS ROUTINE ASKS THE USER FOR A FORMAT SPEC AND SETS THE
00400	      WORD FMTFLG ACCORDINGLY. %
00500	
00600	BEGIN
00700	  R1_PSTR 'FORMAT(S)--';
00800	  R1<UPPER>_-1;
00900	  PSOUT;
01000	
01100	  FMTFLG_0;
01200	  WHILE (PBIN; .R1) NEQ #37 DO
01300	    SELECT .R1 OF
01400	      NSET
01500	        "O": FMTFLG_.FMTFLG OR BITO;
01600	        "S": (FMTFLG_.FMTFLG OR BITS; WPL_3);
01700	        "H": FMTFLG_.FMTFLG OR BITH;
01800	        "D": FMTFLG_.FMTFLG OR BITD;
01900	        "F": FMTFLG_.FMTFLG OR BITF;
02000	        "T": FMTFLG_.FMTFLG OR BITT;
02100	        "6": FMTFLG_.FMTFLG OR BIT6;
02200	        "5": FMTFLG_.FMTFLG OR BIT5;
02300	        "A": FMTFLG_.FMTFLG OR BITA;
02400	        "N": 0;
02500	        "??": OTSTR(PSTR '?_
02600	
02700	O--OCTAL DUMP?_
02800	    S--SHORT FORM (4 WORDS PER LINE)?_
02900	?_
03000	N--NORMAL DUMP ("N" OPTIONAL)?_
03100	    A--ADDRESS?_
03200	    H--HALF WORD?_
03300	    D--DECIMAL?_
03400	    F--FLOATING POINT?_
03500	    T--ASCII TEXT?_
03600	    6--SIXBIT TEXT?_
03700	    5--RADIX50?_
03800	    S--SYMBOLIC INSTRUCTION?_
03900	?_
04000	JUST A CARRIABE RETURN IMPLIES "N"--ALL NORMAL DUMP?_
04100	    FORMATS.?_
04200	?_
04300	JUST TYPE IN A STRING OF FLAGS--I.E.?_
04400	?_
04500	FORMAT--AHD6S?_
04600	?_
04700	?_
04800	?_
04900	?_
05000	FORMAT--');
05100	
05200	        " ": 0;
05300	        OTHERWISE: ERROR(PSTR 'ILLEGAL FORMAT--IGNORED',1);
05400	      TESN;
05500	
05600	  IF .FMTFLG EQL 0 THEN FMTFLG_BITS+BITH+BITD+BITF+BITT+BIT6+BIT5+BITA;
05700	  IF FMTTST(BITO) THEN FMTFLG_BITO;
05800	END;
05900	
     

00100	ROUTINE GETLMT=
00200	
00300	%   THIS ROUTINE GETS THE PAGE NUMBERS TO BE DUMPED FROM THE USER
00400	      AND RECORDS THEM FOR THE PROGRAM. %
00500	
00600	BEGIN
00700	  LOCAL NUM;
00800	  
00900	  LMTCNT_0;
01000	  R1_PSTR 'PAGE LIMITS--';
01100	  R1<UPPER>_-1;
01200	  PSOUT;
01300	
01400	  R1_#100;
01500	  BIN;
01600	  BKJFN; R3_0;
01700	
01800	  WHILE .R2 NEQ #37 DO
01900	    BEGIN
02000	      BIN;
02100	      IF (.R2 GEQ "0") AND (.R2 LEQ "7") THEN
02200	        BEGIN
02300	          BKJFN; R3_0;
02400	          R3_8;
02500	          NIN; !GET LIMIT ONE
02600	            R1_0;
02700	          IF .R1 EQL 0 THEN ERROR(.R3,2);
02800	          NUM<UPPER>_.R2;
02900	          BKJFN; R3_0;
03000	          BIN;
03100	
03200	          SELECT .R2 OF
03300	            NSET
03400	              ">":NUM<LOWER>_777777;
03500	              "-":BEGIN
03600	                    R3_8;
03700	                    NIN; R1_0;
03800	                    IF .R1 EQL 0 THEN ERROR(.R3,2);
03900	                    NUM<LOWER>_.R2;
04000	                    BKJFN; R3_0;
04100	                  END;
04200	              OTHERWISE: (NUM<LOWER>_.NUM<UPPER>; BKJFN; R3_0);
04300	            TESN;
04400	
04500	          BIN;
04600	          LMTTB[.LMTCNT]_.NUM;
04700	          LMTCNT_.LMTCNT+1;
04800	        END;
04900	    END;
05000	
05100	  IF .LMTCNT EQL 0 THEN (LMTTB_#777777; LMTCNT_1);
05200	  LMTTB[.LMTCNT]_-1;
05300	  LMTCNT_0;
05400	
05500	  HLMT_.LMTTB[.LMTCNT]<LOWER>;
05600	  SRCJFK<LOWER>_.LMTTB[.LMTCNT]<UPPER>;
05610	  ADDRSS_(.SRCJFK<LOWER>)^9-2
05700	END;
05800	
     

00100	ROUTINE TERM=
00200	
00300	%   THIS ROUTINE HANDLES ALL TERMINATION DUTIES INCLUDING
00400	      CLOSING FILES, ETC. %
00500	
00600	BEGIN
00700	  OTEOL();
00800	  OTSTR(PSTR '***END OF DATA');
00900	  OTEOL();
01000	  R1_-1;
01100	  CLOSF;
01200	  IF .SRCJFK LSS 0 THEN
01300	    BEGIN
01400	      R1_.SRCJFK<18,18>;
01500	      KFORK;
01600	    END;
01700	  HALTF;
01800	END;
01900	
     

00100	%
00200	
00300	  OPCODE TABLE DEFINITIONS
00400	
00500	%
00600	
00700	OPTAB_ PLIT (
00800	  SIXBIT '                                                ',
00900	  SIXBIT '                                                ',
01000	  SIXBIT '                                                ',
01100	  SIXBIT '                                                ',
01200	  SIXBIT 'CALL  INIT                                CALLI ',
01300	  SIXBIT 'OPEN  TTCALL                  RENAMEIN    OUT   ',
01400	  SIXBIT 'SETSTSSTATO STATUSGETSTSSTATZ INBUF OUTBUFINPUT ',
01500	  SIXBIT 'CLOSE RELEASMTAPE UGETF USETI USETO LOOKUPENTER ',
01600	  SIXBIT 'UJEN                    JSYS                    ',
01700	  SIXBIT 'DFAD  DFSB  DFMP  DFDV                          ',
01800	  SIXBIT 'DMOVE DMOVN FIX         DMOVEMDMOVNMFIXR  FLTR  ',
01900	  SIXBIT 'UFA   DFN   FSC   IBP   ILDB  LDB   IDPB  DPB   ',
02000	  SIXBIT 'FAD   FADL  FADM  FADB  FADR  FADRI FADRM FADRB ',
02100	  SIXBIT 'FSB   FSBL  FSBM  FSBB  FSBR  FSBRI FSBRM FSBRB ',
02200	  SIXBIT 'FMP   FMPL  FMPM  FMPB  FMPR  FMPRI FMPRM FMPRB ',
02300	  SIXBIT 'FDV   FDVL  FDVM  FDVB  FDVR  FDVRI FDVRM FDVRB ',
02400	  SIXBIT 'MOVE  MOVEI MOVEM MOVES MOVS  MOVSI MOVSM MOVSS ',
02500	  SIXBIT 'MOVN  MOVNI MOVNM MOVNS MOVM  MOVMI MOVMM MOVMS ',
02600	  SIXBIT 'IMUL  IMULI IMULM IMULB MUL   MULI  MULM  MULB  ',
02700	  SIXBIT 'IDIV  IDIVI IDIVM IDIVB DIV   DIVI  DIVM  DIVB  ',
02800	  SIXBIT 'ASH   ROT   LSH   JFFO  ASHC  ROTC  LSHC        ',
02900	  SIXBIT 'EXCH  BLT   AOBJP AOBJN JRST  JFCL  XCT   MAP   ',
03000	  SIXBIT 'PUSHJ PUSH  POP   POPJ  JSR   JSP   JSA   JRA   ',
03100	  SIXBIT 'ADD   ADDI  ADDM  ADDB  SUB   SUBI  SUBM  SUBB  ',
03200	  SIXBIT 'CAI   CAIL  CAIE  CAILE CAIA  CAIGE CAIN  CAIG  ',
03300	  SIXBIT 'CAM   CAML  CAME  CAMLE CAMA  CAMGE CAMN  CAMG  ',
03400	  SIXBIT 'JUMP  JUMPL JUMPE JUMPLEJUMPA JUMPGEJUMPN JUMPG ',
03500	  SIXBIT 'SKIP  SKIPL SKIPE SKIPLESKIPA SKIPGESKIPN SKIPG ',
03600	  SIXBIT 'AOJ   AOJL  AOJE  AOJLE AOJA  AOJGE AOJN  AOJG  ',
03700	  SIXBIT 'AOS   AOSL  AOSE  AOSLE AOSA  AOSGE AOSN  AOSG  ',
03800	  SIXBIT 'SOJ   SOJL  SOJE  SOJLE SOJA  SOJGE SOJN  SOJG  ',
03900	  SIXBIT 'SOS   SOSL  SOSE  SOSLE SOSA  SOSGE SOSN  SOSG  ',
04000	  SIXBIT 'SETZ  SETZI SETZM SETZB AND   ANDI  ANDM  ANDB  ',
04100	  SIXBIT 'ANDCA ANDCAIANDCAMANDCABSETM  SETMI SETMM SETMB ',
04200	  SIXBIT 'ANDCM ANDCMIANDCMMANDCMBSETA  SETAI SETAM SETAB ',
04300	  SIXBIT 'XOR   XORI  XORM  XORB  IOR   IORI  IORM  IORB  ',
04400	  SIXBIT 'ANDCB ANDCBIANDCBMANDCBBEQV   EQVI  EQVM  EQVB  ',
04500	  SIXBIT 'SETCA SETCAISETCAMSETCABORCA  ORCAI ORCAM ORCAB ',
04600	  SIXBIT 'SETCM SETCMISETCMMSETCMBORCM  ORCMI ORCMM ORCMB ',
04700	  SIXBIT 'ORCB  ORCBI ORCBM ORCBB SETO  SETOI SETOM SETOB ',
04800	  SIXBIT 'HLL   HLLI  HLLM  HLLS  HRL   HRLI  HRLM  HRLS  ',
04900	  SIXBIT 'HLLZ  HLLZI HLLZM HLLZS HRLZ  HRLZI HRLZM HRLZS ',
05000	  SIXBIT 'HLLO  HLLOI HLLOM HLLOS HRLO  HRLOI HRLOM HRLOS ',
05100	  SIXBIT 'HLLE  HLLEI HLLEM HLLES HRLE  HRLEI HRLEM HRLES ',
05200	  SIXBIT 'HRR   HRRI  HRRM  HRRS  HLR   HLRI  HLRM  HLRS  ',
05300	  SIXBIT 'HRRZ  HRRZI HRRZM HRRZS HLRZ  HLRZI HLRZM HLRZS ',
05400	  SIXBIT 'HRRO  HRROI HRROM HRROS HLRO  HLROI HLROM HLROS ',
05500	  SIXBIT 'HRRE  HRREI HRREM HRRES HLRE  HLREI HLREM HLRES ',
05600	  SIXBIT 'TRN   TLN   TRNE  TLNE  TRNA  TLNA  TRNN  TLNN  ',
05700	  SIXBIT 'TDN   TSN   TDNE  TSNE  TDNA  TSNA  TDNN  TSNN  ',
05800	  SIXBIT 'TRZ   TLZ   TRZE  TLZE  TRZA  TLZA  TRZN  TLZN  ',
05900	  SIXBIT 'TDZ   TSZ   TDZE  TSZE  TDZA  TSZA  TDZN  TSZN  ',
06000	  SIXBIT 'TRC   TLC   TRCE  TLCE  TRCA  TLCA  TRCN  TLCN  ',
06100	  SIXBIT 'TDC   TSC   TDCE  TSCE  TDCA  TSCA  TDCN  TSCN  ',
06200	  SIXBIT 'TRO   TLO   TROE  TLOE  TROA  TLOA  TRON  TLON  ',
06300	  SIXBIT 'TDO   TSO   TDOE  TSOE  TDOA  TSOA  TDON  TSON  ',
06400	  SIXBIT '                                                ',
06500	  SIXBIT '                                                ',
06600	  SIXBIT '                                                ',
06700	  SIXBIT '                                                ',
06800	  SIXBIT '                                                ',
06900	  SIXBIT '                                                ',
07000	  SIXBIT '                                                ',
07100	  SIXBIT '                                                ');
07200	
     

00100	%
00200	
00300	   TABLE OF SPECIAL OP CODES
00400	
00500	%
00600	
00700	SOPTAB_PLIT(8,
00800	
00900	  #254200000000,SIXBIT 'HALT  ',
01000	  #255300000000,SIXBIT 'JCRY  ',
01100	  #255200000000,SIXBIT 'JCRY0 ',
01200	  #255100000000,SIXBIT 'JCRY1 ',
01300	  #254600000000,SIXBIT 'JEN   ',
01400	  #255040000000,SIXBIT 'JFOV  ',
01500	  #255500000000,SIXBIT 'JOV   ',
01600	  #254100000000,SIXBIT 'JRSTF ');
01700	
01800	
     

00100	%
00200	
00300	   MAIN PROGRAM
00400	
00500	%
00600	
00700	INIT(); !INITIALIZE
00800	GETSRC(); !GET SOURCE FILE
00900	GETDST(); !GET DESTINATION FILE
01000	GETFMT(); !GET FORMATS TO USE
01100	GETLMT(); !GET PAGE LIMITS
01200	
01300	NEXTWD(); !PRIME SOURCE FILE
01400	
01500	OTHDR(); !HEAD OF FIRST PAGE
01600	
01700	IF FMTTST(BITO) THEN OCTDMP() ELSE NRMDMP(); !PRODUCE DUMP
01800	
01900	TERM(); !TERMINATE
02000	
02100	END
02200	
02300	ELUDOM
