00100	
00200	IFNDEF SALONE,<
00300		TITLE DISSAI -- SAIL DRIVER FOR DISPLAY ROUTINES
00400	>
00500	
00600	
00700	
00800	COMMENT $
00900	
01000	THIS IS A DRIVER FOR THE DISPLAY ROUTINES FOR USE WITH SAIL
01100	PROGRAMS.  IT INCLUDES CODE FOR READING IN THE APPROPRIATE
01200	DEVICE-DEPENDENT SEGMENT OF CODE, AND SUBSEQUENTLY DISPATCHING
01300	ALL CALLS TO THAT SEGMENT.
01400	
01500	IT DEPENDS ON A FEW DEFINITIONS EXTRACTED FROM THE FILE 'HEAD' WHICH
01600	PREFACES ANY ASSEMBLY OF SAIL PROGRAMS.  THESE DEFINITIONS
01700	ARE GIVEN IMMEDIATELY BELOW.
01800	
01900	THIS PROGRAM IS TO BE ASSEMBLED WITH DISDEF.FAI, THE GLOBAL
02000	DEFINITIONS OF CALLS, ETC. FOR THE DISPLAY ROUTINES.
02100	
02200	$
02300	
02400	BEGIN SAIL
02500	
02600	;TAKEN FROM 'HEAD'
02700	
02800	FLOAT_2B8	OPDEF	FLOAT	[2B8]
02900	FIX_3B8		OPDEF	FIX	[3B8]
03000	DECPNT_11B8	OPDEF	DECPNT	[11B8]
03100	OCTPNT_12B8	OPDEF	OCTPNT	[12B8]
03200	
03300	;END OF STUFF FROM 'HEAD'
03400	
03500	IFNDEF SALONE,<
03600		INTERNAL PPNRJF,DEVRJF;
03700	>
03800	
03900	EXTERNAL CORGET,CORREL		;USE SAIL CORE ALLOCATION ROUTINES
04000	EXTERNAL .EXPINT
04100	
04200	
04300	
04400	
04500	;THE TYPICAL ENTRY POINT LOOKS LIKE (SAY, DDOT3):
04600	;
04700	;	SIXBIT /DOT3/
04800	;DDOT3:	PUSHJ P,DISP
04900	;	JRST @23(S)		(INDEX INTO DISPATCH TABLE)
05000	
05100	DISP:	POP	P,LASTDIS		;SAVE LAST DISPLAY CALL
05200		POP	P,RETLOC		;SAVE RETURN ADDRESS
05300		MOVEI	S,T			;POINTER TO DISPATCH
05400	
05500		MOVE	R,.DBASE(S)		;GET POINTER TO DATA AREA
05600		MOVE	0,.0SAV(S)		;AND RESTORE AC0
05700		XCT	@LASTDIS		;CALL ROUTINE WITH JRST
05800	
05900	FRET:	TDZA	A,A			;RETURN 0
06000	TRET:	MOVNI	A,1			;RETURN TRUE
06100	RET:	MOVEM	0,.0SAV(S)		;SAVE THE AC
06200		JRST	@RETLOC			;AND RETURN TO USER
06300	
06400	LASTDIS:	0
06500	RETLOC:		0
06700	
06800	;NOW USE THE 'CALLS' MACRO TO ASSEMBLE ALL THE ENTRY POINTS
06900	
07000	III__CLBASE
07100	
07200	DEFINE CL & (NAM,ARGS,ROUT) <
07300		INTERNAL D&NAM
07400		SIXBIT /NAM/			;DISPLAY SUBROUTINE NAME
07500	D&NAM:	PUSHJ	P,DISP			;CALL DISPATCHER.
07600		IFDIF <ROUT><>,<JRST ROUT>
07700		IFIDN <ROUT><>,<JRST @III(S)
07800			III__III+1
07900		>
08000	>
08100	
08200	DEFINE CI & (NAM) <
08300		.&NAM __ III
08400		III__III+1
08500	>
08600	
08700	;MACRO CALL ON 'CALLS' IS XLISTED
08800	XLIST
08900	CALLS					;PUT IN ALL THE SUBROUTINES
09000	LIST
     
00100	; FIX AND FLOAT ROUTINES ARE HANDLED BY SAIL
00200	; UUO INTERPRETER (IT SEEMED AWFULLY SIMPLE!)
00300	
00400	
00500	
00600	WFIXW:	FIX	A,A			;USE SAIL FIXER
00700		POPJ	P,
00800	
00900	WFLOAT:	FLOAT	A,A
01000		POPJ	P,			;USE SAIL FLOATER
01100	
01200	
01300	
01400	;ERROR MESSAGE PRINTER
01500	INTERNAL DERRHL
01600	
01700	WERROR:	PUSH	P,A		;SAVE AN AC
01800		PUSH	P,B
01900		TTCALL	3,[ASCIZ /?DISPLAY ERROR #/]
02000		MOVE	A,-2(P)		;ADDRESS
02100		MOVE	A,-1(A)		;LITERAL LOCN.
02200		TLZ	A,777760	;ONLY SAVE INDEX FIELD.
02300		MOVEM	A,ERRLOC#	;SAVE IT. (IT WILL HAVE INDEX AC, MAYBE)
02400		LDB	A,[POINT 12,@ERRLOC,12] ;GET ERROR NUMBER
02500		DECPNT	A
02600		TTCALL	3,[ASCIZ /; ROUTINE D/]
02700		MOVE	B,LASTDIS
02800		MOVE	B,-2(B)		;SIXBIT NAME.
02900	W0:	SETZM	A
03000		LSHC	A,6
03100		JUMPE	A,W1
03200		ADDI	A,40
03300		TTCALL	1,A		;TYPE CHAR
03400		JRST	W0
03500	W1:	SKIPG	@ERRLOC		;ONLY PRINT IF FATAL
03600		TTCALL	3,[ASCIZ /
03700	 CALLED FROM /]
03800		HRRZ	A,RETLOC
03900		SUBI	A,1
04000		SKIPG	@ERRLOC		;ONLY PRINT IF FATAL
04100		OCTPNT	A
04200		TTCALL	3,[ASCIZ /
04300	/]
04400		POP	P,B
04500		POP	P,A
04600	DERRHL:	SKIPL	@ERRLOC		;FATAL?
04700		 POPJ	 P,		;NO -- IT WILL HANDLE IT.
04800		CALLI	12		;EXIT.
04900	
     
00100	; LANGUAGE-DEPENDENT PARTS OF ROUTINES
00200	
00300	
00400	
00500	PUTMAT:	HRRI	C,WORKM(R)	;BLT MATRIX POINTED TO BY
00600		HRL	C,B		;ACCUMULATOR B INTO THE
00700		BLT	C,WORKM+=15(R)	;WORKING MATRIX
00800		POPJ	P,
00900	
01000	
01100	STRING:	HRRZS	-1(16)		;RESET COUNT.
01200		MOVNI	A,1		;GET -1
01300		PUSHJ	P,@.TEXT(S)	;START STRING
01400	SLOP:	SOSGE	-1(16)		;MORE CHARS LEFT?
01500		 JRST	 STRD		;NO
01600		ILDB	A,(16)		;GET CHAR
01700		PUSHJ	P,@.TEXT(S)	;CALL ROUTINE.
01800		JRST	SLOP
01900	STRD:	MOVNI	A,2		;END OF STRING.
02000		PUSHJ	P,@.TEXT(S)	;CALL ROUTINE.
02100		SUB	16,[XWD 2,2]
02200		JRST	RET		;AND RETURN.
02300	
02400	
02500	
02600	INIGO:
02610		MOVE	A,(P)		;IF USER WANTS HISEG DISPLAY
02615		CAIN	A,1		;FILE, SKIP INITIALIZATION
02620		JRST	INIG1		;YES - HISEG
02650		SETOM	.LANG(S)		;SAY THIS IS SAIL
02700	;PATCH IN ADDRESSES OF SAIL RUNTIME CORE ALLOCATION ROUTINES
02800	
02900		MOVEI	A,CORGET
03000		MOVEM	A,.GET(S)
03100		MOVEI	A,CORREL
03200		MOVEM	A,.REL(S)
03300	
03510		MOVEI	A,PATADR	;FIXUP ADDRESS FOR PATCHING
03520		MOVEM	A,.PADR(S)
03530	
03600	
03700	IFDEF SALONE,<
03800		MOVEI	A,DISNUM
03900		SKIPN	A		;IF STAND-ALONE FOR 340
04000		PUSHJ	P,PATADR	;THEN PATCH
04100		JRST	INIG1
04200	>
04300	
04310		MOVE	A,-3(P)		;GET DISPLAY # OR NAME
04320		CAMN	A,[SIXBIT /DEC340/]	;IS IT THE 340?
04330		MOVEI	A,0		;YES
04400		SKIPN	A		;IS THIS THE 340?
04500		PUSHJ	P,PATADR	;YES - PATCH
04900	INIG1:
05100	IFNDEF SALONE,<    ; CODE TO READ-IN THE APPROPRIATE SEGMENT
05200	
05300		MOVE	B,-3(P)		;GET DISPLAY NUMBER
05400		OPEN	OBLK	;TRY TO GET THE CHANNEL OPEN
05700		 JRST	 NODIS		;NO DISK == NO DISPLAY
05800		MOVE	A,PPNRJF
05900		MOVEM	A,INAM+3	;PPN
06000		LOOKUP	INAM		;LOOKUP .SEG FILE
06300		 JRST	 NODIS		;NO SEGMENT FILE == NO DISPLAY
06400	AG:	INPUT	[IOWD ROUTSIZ,<TT+PCHBRK>
06500					0]
06800		STATZ	20000		;LOOK FOR END OF FILE
07100		 JRST	 NODIS
07200		CAME	B,.DISN(S)	;CORRECT DISPLAY NUMBER
07300		CAMN	B,.DISNM(S)	;OR CORRECT SIXBIT NAME?
07400		 JRST	 GOTIT		;YES
07500		JRST	AG		;NO -- LOOK FARTHER
07600	
07700	INAM:	SEGNAM			;SIXBIT NAME OF SEGMENT.
07800		SIXBIT	/SEG/
07900		BLOCK	2
08000	
08100	PPNRJF:	SEGPPN
08200	
08300	OBLK:	17
08400	DEVRJF:	SEGDEV
08500		0
08600	
08700	
08800	NODIS:	PUSHJ	P,@[XWD S+(=14*40),.ERRGO]
08900		SUB	P,[XWD 4,4]	;GET RID OF ALL ARGS.
09000		JRST	FRET		;RETURN FALSE, FALSE, FALSE
09100	
09220	GOTIT:	RELEASE		;GET RID OF CHANNEL
09500	
09600	>
09700	IFDEF SALONE,<     ; CODE TO MOVE LOW PART OF DISPATCH TABLE
09800			   ; BACK WHERE IT BELONGS.
09900	^T_CBEG			;BEGINNING OF CODE AREA
10000	
10100		MOVE	A,[XWD TT+.FIX,CBEG+.FIX]
10200		BLT	A,CBEG+PCHBRK-1
10300	>
10400		JRST @.INI(S)		;NOW GO DO PHASE 2 IN DISPLAY-DEPENDENT
10500	
10600	
10700	
10800	
10900	;ROUTINE CALLED BY SAIL WHEN IT MUST EXPAND CORE AND THE
11000	;340 IS INIT'D. THIS ALLOWS OMNIGRAPH TO TAKE CARE OF
11100	;STOPPING THE 340 AND UNLOCKING BEFORE CORE IS EXPANDED.
11200	
11300	SAILB:	PUSH	P,S
11400		MOVEI	S,T		;SETUP S
11500		MOVE	0,.0SAV(S)	;RESTORE 0
11600		MOVE	R,.DBASE(S)
11700		SKIPN	.RUN(S)		;IS THE DISPLAY GOING?
11800		JRST	OMN1		;NO
11900		MOVE	A,OXSTAT(R)	;SAVE STATUS
12000		MOVEM	A,SAVSTAT
12100		MOVE	A,[XWD 4,400007]	;STOP 340 AND UNLOCK
12200		DISCAL	A
12300	OMN1:	MOVEI	A,SAILA
12400		MOVEM	A,.EXPINT
12500	RST1:	POP	P,S
12600		POP	P,A
12700		SUB	P,[XWD 4,4]
12800		PUSH	P,A
12900		POPJ	P,
13000	
13100	
13200	;ROUTINE CALLED BY SAIL AFTER IT HAS EXPANDED CORE TO 
13300	;START 340 UP AGAIN
13400	
13500	SAILA:	PUSH	P,S
13600		MOVEI	S,T		;RESTORE S
13700		MOVE	0,.0SAV(S)	;RESTORE 0
13800		MOVE	R,.DBASE(S)
13900		SKIPN	.RUN(S)		;SHOULD WE TRY TO GET STARTED AGAIN
14000		JRST	OMN2		;NO
14100		MOVEI	A,OXSTAT(R)	
14200		HRLI	A,1		;TRY TO RE-SEIZE DISPLAY
14300		DISCAL	A
14400		JRST	OMN3		;CANNOT
14500		MOVE	A,SAVSTAT	;RESTORE DEVICE RUN BITS
14600		HRLI	A,3
14700		DISCAL	A		;RESTART DEVICES
14800	OMN2:	PUSHJ	P,PATADR
14900		JRST	RST1
15000	OMN3:	TTCALL	3,[ASCIZ /CANNOT RE-SEIZE DISPLAY
15100	/]
15200		TLZ	DISRUN		;SAY NO LONGER RUNNING
15350		MOVEM	.0SAV(S)
15375		MOVEM	.ACSAV(S)
15400		SETZM	.RUN(S)
15500		JRST	OMN2
15600	
15700	
15800	PATADR:	MOVEI 	A,SAILB  ;YES - PATCH IN ADDR
15900		MOVEM	A,.EXPINT     ;FOR CORE EXPANSION
16000		POPJ	P,
16100	
16200	
16300	
16400	SAVSTAT:	0	;FOR SAVING DEVICE RUN BITS
16500	
     
00100	
00200	
00300	IFNDEF SALONE,<
00400	^T:
00500	>
00600	TT:			;HERE BEGINS THE DISPATCH TABLE.
00700		0		;SAVE CELL FOR REGISTER 0
00800		0		;POINTER TO DATA AREA
01000		WFIXW		;FIX ROUTINE
01100		WFLOAT		;FLOAT ROUTINE
01200		PUTMAT		;TRANSFER MATRIX TO WORK MATRIX
01300		TRET		;RETURN TRUE
01400		FRET		;RETURN FALSE
01500		RET		;RETURN INTEGER
01600		RET		;RETURN
01700		JRST 	WERROR	;.ERRGO
01705		0		;DEFINES WHICH CORE ALLOCATION METHOD
01707				;0 IF LOW SEG, -1 IF HISEG
01710	;THE FOLLOWING ENTRIES ARE USED ONLY BY THE LOW SEGMENT
01720	;CORE ALLOCATION METHOD
01730	
01800		CORGET		;FOR ADDRESS OF CORGET
01900		CORREL		;FOR ADDRESS OF CORREL
01910		PATADR		;FOR ADDRESS OF PATCH ROUTINE
02000		0		;FLAG IF DISPLAY IS RUNNING
02050		-1		;FLAG WHICH LANGUAGE
02100		BLOCK 20	;FOR AC SAVE AREA
02200	
02300	
02400	IFNDEF SALONE, <
02500	
02600	;IF THESE ARE NOT STAND-ALONE ROUTINES, HERE IS WHERE WE LEAVE
02700	;A BLOCK OF STORAGE FOR THE ROUTINES TO BE READ INTO.
02800	
02900	BLOCK	ROUTSIZE
03000	
03100	>
03200	BEND
03300	END
03400	
