	TITLE	EXTR

p__17

;***************************************************************
; "EXTRACTOR"	THIS PROGRAM PROCESSES MACRO AND FAIL SOURCE FILES
;		AND PRODUCES A LISTING OF LABELS DEFINED
;****************************************************************


ENTRY:	RESET
	MOVE	17,[IOWD 20,PDL]	;SET PDL POINTER
; ASK FOR,GET AND OPEN AN OUTPUT FILE
 	HRRZI	1,101
	HRROI	2,[ASCIZ /
OUTPUT: /]
	SETZ	3,
	SOUT
	HRRZI	1,OUTTBL
	SETZ	2,
	GTJFN
	  JRST	ENTRY		;FOR NOW
	MOVEM	1,OUTJFN
	MOVE 	2,[XWD 070000,100000]
	OPENF
	  JRST	ENTRY
	MOVEI	6,TABLE		;SET POINTER TO LABEL TABLE
	MOVE	7,[XWD 440700,FILES]	;SET FILE STRING TABLE POINTER
; ASK FOR, GET AND OPEN AN INPUT FILE (FILE OF FILE NAMES)
INPUT:	HRRZI	1,101
	HRROI	2,[ASCIZ /
INPUT: /]
	SETZ	3,
	SOUT
	HRRZI	1,FLSTBL
	SETZ	2,
	GTJFN
	  JRST	[PUSHJ	17,ERR
		JRST	INPUT]	;GO RETRY
	MOVEM	1,FLSJFN		;SAVE THE INPUT JFN
	MOVE	2,[XWD 070000,203000]
	OPENF			;OPEN THE INPUT FILE
	  JRST	[PUSHJ	17,ERR
		JRST	INPUT]	;GO RETRY
	HRRZI	1,101
	MOVEI	2,37		;;NEW LINE
	BOUT

INPUT1:	MOVE	4,[POINT 7,FILE]
	MOVE	1,FLSJFN
	GTSTS
	TLNE	2,1000
	JRST	INPUT2		;EOF
	BIN			;GET A BYTE
	CAIN	2,0
	JRST	INPUT1+1	;IGNORE ZEROES
	IDPB	2,4		;PUT IN NAME STRING
	CAIN	2,12		;EOL?
	JRST	INPUT3		;GO GET JFN
	CAIN	2,37		;OTHER EOL
	JRST	INPUT3
	CAIN	2,32		;TTY "EOF" ^Z
	JRST	INPUT2
	JRST 	INPUT1+1
;;;	MOVE	1,FLSJFN	;CHECK FOR EOF
;;;	GTSTS
;;;	TLNE	2,1000		;SKIP IF NO EOF
INPUT2:	JRST	[MOVE	1,FLSJFN
		CLOSF		;CLOSE FILES-FILE
		  HALTF		; FOR NOW
		PUSHJ	17,SORT	;GO SORT LABEL TABEL
		PUSHJ	17,TBLOUT	;AND OUTPUT DATA
		MOVE	1,OUTJFN
		CLOSF
		  HALTF 			;FOR NOW
		HALTF]
;;;	JRST	INPUT1+1		;GO GET ANOTHER BYTE
INPUT3:	MOVE	1,[XWD 100001,0]
	HRROI	2,FILE		;LOAD STRING POINTER
	GTJFN
	  JRST	[PUSHJ	17,ERR
		JRST	INPUT]
	MOVEM	1,INJFN		;SAVE JFN
	HRRZI	1,101		;TYPE NAMES OF FILE BACK TO HIM AFTER OPEN
	MOVE	2,INJFN
	MOVE	3,[XWD 011110,1]
	JFNS
	MOVEI	2,37
	BOUT
	MOVE	1,INJFN
	MOVE	2,[XWD 440000,203000]
	OPENF
	  JRST	[PUSHJ	17,ERR
		JRST	INPUT]		;GIVE HIM ANOTHER CHANCE
	move	1,[point 7,bytwd]	;set up byte pointer
	movem 	1,bytptr
	setzm	bytwd
	MOVEM	7,FILEAD	;SET ENTRY POINTER TO THIS FILE
	MOVE	1,7		;GET TENEX TO WRITE STRING IN TABLE
	MOVE	2,INJFN
	MOVE	3,[XWD 001110,1]	;FORMAT WORD
	JFNS
	SETZ	3,
	IDPB	3,1		;MAKE IT AN ASCIZ STRING
	MOVE	7,1		;SAVE UPDATED POINTER
	SETZM	PAGES
	AOS	PAGES

READ:	MOVE	2,[ASCIZ /     /]	;LOAD 5 SPACES
	MOVEM	2,LABEL		;SET LABEL _ NULL
	MOVEM	2,LABEL+1
	MOVEI	2,12		;ONLY TAKE TEN BYTES FOR LABEL AREA
	MOVEM	2,COUNT
	PUSHJ	17,GETSTR	;GO GET A STRING
	  JRST	INPUT1	;EOF RETURN
	SETZM	MACFLG		;SET MACRO FLAG OFF
	MOVE	3,[XWD 440700,LABEL]	;LOAD POINTER TO LABEL AREA
READ1:	ILDB	2,4
	pushj	17,chklow	;test lower case
	CAIN	2,14		;IS IT FORM FEED?
	JRST	[AOS	PAGES	;BUMP PAGE COUNT
	JRST	READ]		;GET NEXT LINE
	CAIN	2,12		;IGNORE EXTRA LINES
	JRST	READ
	CAIN	2,15
	JRST	READ 
	CAIN	2," "		;PASSLEADING SPACES
	JRST	READ1		;IF NOT READ NEXT LINE
	CAIN	2,11		;SKIP IF NOT TAB
	JRST	READ1		;PASS LEADING TABS ALSO
	CAIN	2,";"		;IGNORE COMMENTS
	JRST	READ
	CAIN	2,"<"		;START OF DEFINE OR LITERAL
	JRST	CHKASC		;GO LOOK FOR POSSIBLE ASCII STRING
	CAIN	2,"("		;TERMINATOR ?
	JRST	CHKASC

; OUTPUT LABEL OR DEFINITION
BYTEO:	SOSLE	COUNT		;DONT DEPOSIT IF TEN ALREADY
	IDPB	2,3		;STORE BYTE IN LABEL AREA
	ILDB	2,4		;GET NEXT CHAR
	pushj	17,chklow
	CAIN	2,12		;EOL SAYS QUIT
	JRST	READ		;NO ASCII (Z) IF EOL
	CAIN	2," "
	JRST	CHKMAC		;GO CHECK IF GS,TS,LS,JS
	CAIN	2,"("
	JRST	CHKMAC		;CHECK FOR  GS,LS,TS,JS
	CAIN	2,","		;IF COMMA CHECK IF IN "MACRO" MODE
	JRST	[SKIPN	MACFLG		;SKIP IF YES
		JRST	CHKASC		;IF NOT THE GO CHECK ASCIZ
		SETZM	MACFLG		;RESET FLAG
		JRST	TABO]		;AND TREAT AS LABEL
	CAIN	2,11		;TAB ENDS- GO CHECK FOR LITERAL
	JRST	CHKASC
	CAIN	2,"="		;EQUATES TOO IF NOT REQUESTED
	JRST	TABO		;EQUATES ARE LABELS TOO
	CAIN	2,"_"		;FAIL EQUATES TOO
	JRST	TABO
	CAIN	2,"<"		;START OF DEFINE STUFF
	JRST	CHKASC		;GO PASS IT
	CAIN	2,"["		;LITERAL?
	JRST	CHKASC		;PASS ALSO
	CAIE	2,":"		;END OF LABEL
	JRST	BYTEO		;IF NOT END OUTPUT IT
TABO:	HRLI	1,LABEL		;CONSTRUCT BLT POINTER
	HRR	1,6		;TABLE POINTER
	ADDI	6,4		;POINT TO NEXT SLOT IN TABLE
	HRRM	6,.+1		;SET BLT STOP ADDRESS
	BLT	1,.		;MOVE ENTRY TO TABLE
	JRST	CHKASC		;GO GET NEXT LINE

chklow:	caile	2,140
	caile	2,172		;check lower case
	popj	17,0
	subi	2,40		;convert to upper
	popj	17,0


; CHECK FOR TENEX SYSTEM MACROS TS,GS AND LS

CHKMAC:	MOVE	2,[ASCII /JS   /]
	CAMN	2,LABEL
	JRST	CHKMC1
	MOVE	2,[ASCII /GS   /]
	CAMN	2,LABEL		;COMPARE LABEL (SO FAR)
	JRST	CHKMC1		;GO SET FOUND FLAG
	MOVE	2,[ASCII /TS   /]
	CAMN	2,LABEL
	JRST	CHKMC1
	MOVE	2,[ASCII /LS   /]
	CAME	2,LABEL
	JRST	CHKASC		;NONE OF THE ABOVE CHECK ASCIZ
CHKMC1:	SETOM	MACFLG		;SET FOUND FLAG
	JRST	READ1-1		;AND TREAT FOLLOWING AS LABEL
;  CHECK FOR APPARENT LABELS IN ASCIZ STRINGS

CHKASC:	MOVE	4,[POINT 7,STRING]
	ILDB	2,4		;GET A BYTE
	pushj	17,chklow
	CAIN	2,";"		;IGNORE COMMENTS
	JRST	READ
	CAIN	2,12		;EOL ENDS SEARCH
	JRST	READ
	CAIN	2,37		;OTHER KIND TOO
	JRST	READ
	CAIE	2,"A"		;SKIP IF "A"
	JRST	CHKASC+1	;IF NOT LOOK AT NEXT
	ILDB	2,4		;GET ANOTHER
	pushj	17,chklow
	CAIE	2,"S"
	JRST	CHKASC+2
	ILDB	2,4		;GET ANOTHER
	pushj	17,chklow
	CAIE	2,"C"
	JRST	CHKASC+2
	ILDB	2,4
	pushj	17,chklow
	CAIE	2,"I"
	JRST	CHKASC+2
	ILDB	2,4
	pushj	17,chklow
	CAIE	2,"Z"
	CAIN	2,"I"
	JRST	.+2
	JRST	CHKASC+2	;GO CHECK SOME MORE
CHKAS2:	ILDB	2,4		;SEARCH FOR DELIMITER
	pushj	17,chklow
	CAIN	2," "		;PASS SPACES
	JRST	chkas2
	CAIN	2,11		;AND TABS
	JRST	CHKAS2	;KEEP LOOKING
	MOVEM	2,TERM		;SAVE IT
CHKAS3:	ILDB	2,4		;GET ANOTHER
	pushj	17,chklow
	CAMN	2,TERM		;SKIP IF NOT IT
	JRST	READ		;IF YES THEN GET NEXT LINE
	CAIE	2,12		;EOL?
	JRST	CHKAS3		;IF NOT KEEP LOOKING
	PUSHJ	17,GETSTR	;GET ANOTHER STRING
	JRST	INPUT1		;GO GET NEXT FILE IF EOF
	JRST	CHKAS3		;IF NEW RECORD CONTINUE
; IF TENEX ERROR TYPE ERROR STRING AND RETURN


ERR:	MOVE	2,1		;MOVE ERROR CODE TO 
	HRLI	2,400000	;THIS FORK
	HRRZI	1,101		;CONTROLING TTY
	SETZ	3,
	ERSTR			;TYPE ERROR STRING
	  JFCL
	  JFCL	;IGNORE FOR NOW
	POPJ	17,0		;RETURN

getbyt:	push	p,1
	hrli	2,440700
	push	p,2
	push	p,3
getlop:	ildb	2,bytptr
	jumpe	2,getb1
	idpb	2,-1(p)
	sosle	0(p)
	cain	2,12
	jrst	getret
	jrst	getlop
getret:	pop	p,3
	pop	p,2
	pop	p,1
	popj	p,0

getb1:	move	1,-2(p)
	gtsts
	tlne	2,1000
	jrst	getret
	bin
	movem	2,bytwd
	move	3,[point 7,bytwd]
	movem	3,bytptr
	trnn	2,1
	jrst	getlop
getb2:	move	3, 2		;save word with bit 35
	bin
	trne	2,1
	jrst	getb2	
	movem	2,bytwd
	camn	3, stopgm	;was this stopgap page mark??
	 ildb	2, bytptr	;then get rid of extra cr also
	ildb	2,bytptr
	jrst	getlop

stopgm:	201004020101		;magic stopgap page mark preceder 
				;5 spaces with bit 35 on


; GET A STING FROM INFILE AND SET STRING POINTER

GETSTR:	MOVE	1,INJFN
	HRROI	2,STRING	;MAKE A BYTE POINTER
	MOVE	3,[XWD 0,200]
	HRRZI	4,12		;END ON EOL
;;;	SIN			;GET A STRING
	pushj	p,getbyt
	MOVE	1,INJFN
	GTSTS
	TLNE	2,1000	;TEST IF EOF ENCOUNTERED
	JRST	[MOVE	1,INJFN
		CLOSF
		  HALTF
		POPJ	17,0]		;TAKE EOF RETURN
	MOVE	4,[XWD 440700,STRING]	;LOAD A BYTE POINTER
	AOS	(17)		;TAKE NORMAL RETURN
	POPJ	17,0		;RETURN TO CALLER

; A SIMPLE SORT ROUTINE

SORT:	MOVEI	1,TABLE		;SET POINTERS
	MOVEI	2,TABLE+4
SORT1:	MOVE	3,0(1)		;LOAD 1ST PART OF LABEL
	CAME	3,0(2)		;SAME AS NEXT IN TABLE?
	JRST	[CAMG	3,0(2)		;SKIP IF GREATER
		JRST	SORT2	;IF NOT THEN JUST BUMP POINTERS
		JRST	SORT3]	;IF SECOND GREATER THEN SWAP ENTRIES
	MOVE	3,1(1)		;PICK UP SECOND HALF OF 1ST ENTRY
	CAME	3,1(2)		;GO BUMP POINTERS IF SAME
	JRST	[CAMG	3,1(2)		;SKIP IF GREATER
		JRST	SORT2		;JUST BUMP POINTERS IF LESS
		JRST	SORT3]		;SWAP IF 2ND GREATER
SORT2:	ADDI	1,4		;BUMP POINTERS
	ADDI	2,4
	SKIPE	0(2)		;SKIP IF END OF TABLE
	JRST	SORT1		;KEEP LOOKING IF NOT
	SKIPN	SWAPD		;SKIP IF ANY WERE SWAPPED
	POPJ	17,0		;RETURN IF NONE SWAPPED
	SETZM	SWAPD		;RESET SWAP COUNTER
	JRST	SORT		;TRY AGAIN
;HERE IF SWAP REQUIRED
SORT3:	MOVE	3,0(1)		;LOAD 1ST OF 1ST
	EXCH	3,0(2)		;SWAP WITH 1ST OF 2ND
	MOVEM	3,0(1)		;AND PUT IT BACK
	MOVE	3,1(1)
	EXCH	3,1(2)
	MOVEM	3,1(1)
	MOVE	3,2(1)
	EXCH	3,2(2)
	MOVEM	3,2(1)
	MOVE	3,3(1)
	EXCH	3,3(2)
	MOVEM	3,3(1)
	AOS	SWAPD		;INDICATE A SWAP
	JRST	SORT2		;GO BUMP POINTERS


;OUTPUT THE CONTENTS OF THE LABEL TABLE

TBLOUT:	MOVE	1,OUTJFN
	HRROI	2,[ASCIZ /

	LABEL CROSS REFERENCE LIST

/]
	SETZ	3,
	SOUT
	MOVEI	6,TABLE	;POINT TO START OF TABLE
TBLOT1:	SKIPN	0(6)		;SKIP IF NOT END OF TABLE
	POPJ	17,0		;EXIT IF END
	MOVE	1,[ASCIZ /     /]
	MOVEM	1,LINE		;SET SPACES TO PRINT LINE
	MOVE	1,[XWD	LINE,LINE+1]
	BLT	1,LINE+24	;CLEAR PRINT LINE
	HRROI	1,LINE		;POINT TO PRINT LINE BUFFER
	HRRO	2,6		;POINT  TO LABEL
	HRROI	3,-11		;TEN (DEC)
	SOUT			;OUTPUT LABEL
	MOVE	2,2(6)		;LOAD FILE NAME STRING POINTER
	SETZ	3,		;SIGNIFY ASCIZ
	SOUT
	MOVEI	2," "		;GET RID OF ASCIZ
	IDPB	2,1
	HRROI	1,LINE+5	;NEW BYTE POINTER
	HRROI	2,[ASCIZ /PG /]
	SETZ	3,
	SOUT
	MOVE	2,3(6)		;LOAD PAGE NUMBER
	MOVEI	3,12		;DECIMAL
	NOUT
	  JRST	[PUSHJ	17,ERR
		POPJ	17,0]	;EXIT IF ERROR
	MOVEI	2," "
	IDPB	2,1		;GET RID OF ASCIZ
	ADDI	6,4		;POINT TO NEXT TABLE ENTRY
	SKIPN	0(6)		;SKIP IF THERE IS ONE
	JRST	[PUSHJ	17,PRINT	;PRINT IT
		POPJ	17,0]		;EXIT
;;;	HRROI	1,LINE+10	;SECOND ENTRY
	MOVE	1,[POINT 7,LINE+7,13]
	HRRO	2,6		;POINT TO LABEL
	HRROI	3,-11		;TEN BYTES
	SOUT
	MOVE	2,2(6)		;LOAD FILE NAME STRING
	SETZ	3,
	SOUT
	MOVEI	2," "
	IDPB	2,1		;GET RID OF ASCIZ

	HRROI	1,LINE+15
	HRROI	2,[ASCIZ /PG /]
	SETZ	3,
	SOUT
	MOVE	2,3(6)		;LOAD PAGE NUMBER
	MOVEI	3,12
	NOUT
	  JRST	[PUSHJ	17,ERR
		POPJ	17,0]
	PUSHJ	17,PRINT
	ADDI	6,4		;POINT TO NEXT ENTRY
	JRST	TBLOT1

; PRINT A LINE

PRINT:	MOVEI	2,15		;NEW LINE
	BOUT			;PUT IT IN THE PRINT LINE
	MOVEI	2,12
	BOUT
	MOVE	1,OUTJFN	;OUTPUT DEVICE
	HRROI	2,LINE		;POINT TTO PRINT LINE
	HRRZI	3,200		;COUNT
	MOVEI	4,12		;END ON EOL
	SOUT
	POPJ	17,0


; CONTANTS VARIABLES AND JUNK

INJFN:	0		;INPUT JFN
OUTJFN:	0		;OUTPUT JFN
FLSJFN:	0		;FILE OF FILES JFN
FLSTBL:	XWD	100000,0
	XWD	100,101
	BLOCK	7
OUTTBL:	XWD	400000,0
	XWD	100,101
	BLOCK	7
SWTCH:	0	;FLIP FLOP
MACFLG:	0		;LOOKING FOR TENEX MACROS
TERM:	0	;LIST ON LINE TERMINATOR
TERM2:	0	;ALTERNATE TERMINATOR (FOR MACRO/FAIL DIFFERENCE)
SWAPD:	0	;SORT COUNTER
COUNT:	0	;GENERAL COUNTER
LABEL:	0	;TEMP AREA FOR LABEL STRING
	0
FILEAD:	0	;STRING POINTER TO FILE NAME STRING
PAGES:	0	;PAGE NUMBER WITHIN CURRENT INPUT FILE
	0	;END OF TABLE INDICATOR
bytwd:	0
	0
bytptr:	0	;byte ptr for bin on input file
STRING:	BLOCK	200
PDL:	BLOCK	21	;PUSH DOWN STACK
PATCH:	BLOCK	200	;PATCH AREA
	LIT
LINE:	BLOCK	26
FILE:	BLOCK	40
FILES:	BLOCK	400
TABLE:	0		;LABEL TABLE** (MUST BE LAST )

	END 	ENTRY

