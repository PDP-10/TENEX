00100	ENTRY CBLANK,CUNBLANK,DRAW,WINDOWP,
00200	      INSCRIBE,UNSCRIBE,IMAGE,WDELET,CDELET,WINTYP,WINSAV,WINUSE,
00300	        CURTYP,CURVEMATS;
00400	BEGIN "GRAPH"
00500	COMMENT
00600	
00700		GRAPHICS ROUTINES FOR MLAB/MODELAB
00800	
00900	;
01000	
01100	
01200	
01300	
01400	COMMENT  LINKAGE TO MAIN PROGRAM;
01500	
01600	DEFINE DUMMY="1";
01700	
01800	SAFE EXTERNAL INTEGER ARRAY IDX[0:DUMMY],A[0:DUMMY],VALUE[0:DUMMY],TYPE[0:DUMMY];
01900	SAFE EXTERNAL STRING ARRAY NAME[0:DUMMY];
02000	SAFE EXTERNAL STRING ARRAY ST[1:DUMMY];
02100	EXTERNAL INTEGER DISINIT,RELDIS,TEMPCHR,POSTNUMBER;
02200	
02300	EXTERNAL STRING CURRENTDIS;
02400	
02500	SAFE INTERNAL REAL ARRAY DISINFO[1:23];  COMMENT ARRAY FOR DISPLAY ENVIRONMENT STUFF;
02600	
02700	DEFINE MAXVIEWX="DISINFO[7]",MAXVIEWY="DISINFO[8]",INCHESPERVIEWPORT="DISINFO[6]";
02800	
02900	DEFINE NEWTEMP="SYMTABENTRY("" ""&TEMPCHR); TEMPCHR_TEMPCHR+1";
03000	
03100	
03200	DEFINE STUFFST(J,B) = "BEGIN J_1; WHILE LENGTH(ST[J]) NEQ 0 DO J_J+1;
03300				ST[J]_B END";
03400	DEFINE ROWSIZE(A)="ARRINFO(A,2)";
03500	DEFINE COLSIZE(A)="ARRINFO(A,4)";
03600	DEFINE SIZE(A)="(ARRINFO(A,0))";
03700	
03800	DEFINE DEFAULT ="-2.222222@22";
03900	DEFINE CRLF = "('15&'12)";
04000	
04100	DEFINE SYMTABSIZE="311";
04200	
04300	COMMENT "*******  TYPES(IN SYMTAB) ******";
04400	
04500	DEFINE OPERATOR="3";
04600	DEFINE SCALAR="4";
04700	DEFINE UNKNOWN="1 ";
04800	DEFINE FUNCTION="5 ";
04900	DEFINE MATRIX="6 ";
05000	DEFINE WINDOW="7 ";
05100	DEFINE CURVE="8 ";
05200	DEFINE DIFFEQ="9 ";
05300	DEFINE CONSTANT="2 ";
05400	DEFINE COLON="10 ";
05500	DEFINE ROW="12 ";
05600	DEFINE COL="13 ";
05700	DEFINE SUBSCR="14 ";
05800	DEFINE TEXT="15";
     
00100	COMMENT 
00200		DESCRIPTION OF CURVE ENTRY IN SYMTAB:
00300	
00400	----------------------------------------------------------
00500	NAME		TYPE		VALUE		IDX
00600	
00700	---------------------------------------------------------
00800	
00900	CURVE NAME	CURVE		POINTER TO	INDEX OF A
01000					NEXT CURVE	NODE IN
01100					IN THIS		ARRAY A
01200					WINDOW OR TO
01300					WINDOW
01400	
01500	----------------------------------------------------------
01600	
01700	
01800	NODE IN ARRAY A:
01900	
02000		0:	FLAGS, ETC. SEE BELOW
02100	CSP =   1:	CURVE PICTURE ID	STRING PICTURE ID
02200	CP2 =   2:	PT LBL PICTURE ID	PT LBL SKIP PARAM
02300	CM  =   3:	PT LBL MATRIX ITEM #	CURVE MATRIX ITEM #
02400	CPTLX = 4:		POINT LABEL X
02500	CPTLY = 5:		POINT LABEL Y
02600	CSTW1 = 6:		SETWIN PARAMETER 1
02700	CSTW2 = 7:		SETWIN PARAMETER 2
02800	CSTW3 = 8:		SETWIN PARAMETER 3
02900	CSTW4 = 9:		SETWIN PARAMETER 4
03000	CSTR = 10:		INDEX TO STRING IN ARRAY ST
03100	CSTRX =11:		STRING X
03200	CSTRY =12:		STRING Y
03300	CINT  =13:	POINTTYPE	INTENSITY
03400	
03500	
03600	
03700	DESCRIPTION OF WORD 0:
03800	
03900	BLANKSW		= '200000000000 	IS ON IF CURVE IS BLANKED
04000	INSW		= '100000000000	IS ON IF CURVE IS INSCRIBED
04100	XFLTSW		= '000040000000 INDICATES X FLOATING POINTLABELS
04200	YFLTSW		= '000020000000 INDICATES Y FLOATING POINTLABELS
04300			  '007700000000 POINT LABEL SIZE SAVED IN THESE BITS
04400	LTYPEM		= '000000770000 LINE TYPE SAVED IN THESE BITS
04500	STRM		= '000000000077 STRING SIZE SAVED IN THESE BITS
04600	VTEXTSW         = '000000000100 VERTICAL TEXT SWITCH IS ON FOR VERTICAL TEXT
04700	
04800	
04900	
05000	
05100	
05200	
05300	
05400	
05500	
05600	
05700	
05800		DESCRIPTION OF WINDOW ENTRY IN SYMTAB
05900	
06000	
06100	--------------------------------------------------------------
06200	NAME		TYPE		VALUE		IDX
06300	--------------------------------------------------------------
06400	WINDOW NAME	WINDOW		POINTER TO	POINTER TO
06500					FIRST CURVE	NODE IN
06600							ARRAY A
06700	
06800	--------------------------------------------------------------
06900	
07000	
07100	DESCRIPTION OF NODE IN ARRAY A:
07200	
07300	
07400	WSTW1	=0:	SETWIN PARAMS FOR NON-INSCRIBED CURVES
07500	WSTW2	=1:			"
07600	WSTW3	=2:			"
07700	WSTW4	=3:			"
07800	WSTP1	=4:	SETPOR PARAMS FOR ALL CURVES
07900	WSTP2	=5:
08000	WSTP3	=6:			"
08100	WSTP4	=7:			"
08200	
08300	
08400	
08500	;
     
00100	COMMENT    DEFINITIONS OF SYMBOLS;
00200	
00300	
00400	DEFINE CSP = "1";
00500	DEFINE CP2 = "2";
00600	DEFINE CM = "3";
00700	DEFINE CPTLX = "4";
00800	DEFINE CPTLY = "5";
00900	DEFINE CSTW1 = "6";
01000	DEFINE CSTW2 = "7";
01100	DEFINE CSTW3 = "8";
01200	DEFINE CSTW4 = "9";
01300	DEFINE CSTR = "10";
01400	DEFINE CSTRX = "11",
01500		CSTRY = "12",
01600		CINT  =  "13",
01700		CTLEN = "14",
01800		WSTW1 = "0";
01900	DEFINE WSTW2 = "1";
02000	DEFINE WSTW3 = "2";
02100	DEFINE WSTW4 = "3";
02200	DEFINE WSTP1 = "4";
02300	DEFINE WSTP2 = "5";
02400	DEFINE WSTP3 = "6";
02500	DEFINE WSTP4 = "7",
02600		WTLEN = "8";
02700	
02800	DEFINE	BLANKSW = "'200000000000",
02900		BLANKSWI = "'577777777777",
03000		INSW = "'100000000000",
03100		INSWI = "'677777777777",
03200		SBLNKSW = "'040000000000",
03300		SBLNKSWI = "'737777777777",
03400		XFLTSW = "'000040000000",
03500		YFLTSW = "'000020000000",
03600		
03700		LTYPEM = "'770000",
03800		LTYPEP = "-12",
03900		STRM = "'77",
04000	        VTEXTSW= "'100",
04100	
04200		INT(X) = "(0 XOR (X))",
04300		REL(X) = "(0.0 XOR (X))";
04400	
04500	INTEGER INTENSITY,CALLEDFROMCDRAW;
04600	REAL HUNPERIN,VUNPERIN;
     
00100	EXTERNAL PROCEDURE DPORT(REAL L,R,B,T);
00200	EXTERNAL PROCEDURE DWIND(REAL L,R,B,T);
00300	EXTERNAL PROCEDURE DDRAW(REAL X,Y);
00400	EXTERNAL PROCEDURE DDOT(REAL X,Y);
00500	EXTERNAL PROCEDURE DMOVE(REAL X,Y);
00600	EXTERNAL PROCEDURE DVECT(REAL X1,Y1,X2,Y2);
00700	EXTERNAL PROCEDURE DOPEN (INTEGER I);
00800	EXTERNAL INTEGER PROCEDURE DPOST(INTEGER I);
00900	EXTERNAL INTEGER PROCEDURE DUNPOST(INTEGER I);
01000	EXTERNAL PROCEDURE DINT(REAL INTENSITY);
01100	EXTERNAL INTEGER PROCEDURE DINI (INTEGER A,B,C,D);
01200	EXTERNAL INTEGER PROCEDURE DGET;
01300	EXTERNAL PROCEDURE DREL;
01400	EXTERNAL PROCEDURE DCURSOR (REAL A,B);
01500	EXTERNAL PROCEDURE DCLOSE;
01600	EXTERNAL PROCEDURE DKILL(INTEGER I);
01700	EXTERNAL PROCEDURE DTEXT(STRING S);
01800	EXTERNAL PROCEDURE DTSCAL (REAL X);
01900	EXTERNAL PROCEDURE DSTAT (INTEGER MODES);
02000	EXTERNAL BOOLEAN PROCEDURE DTEST2(REAL X,Y);
02100	EXTERNAL PROCEDURE DENQ (REFERENCE REAL X);
02200	
02300	EXTERNAL PROCEDURE OUTSCR(STRING S);
02400	EXTERNAL PROCEDURE OUTCR(INTEGER C;STRING S);
02500	EXTERNAL PROCEDURE ERROR(STRING S);
02600	EXTERNAL PROCEDURE TYPEFORMERROR(INTEGER I);
02700	EXTERNAL INTEGER PROCEDURE SYMTABENTRY(STRING X);
02800	EXTERNAL PROCEDURE NEWNODE(REFERENCE INTEGER A;
02900	                           SAFE INTEGER ARRAY STACK);
03000	EXTERNAL PROCEDURE FREENODE(INTEGER A; SAFE INTEGER ARRAY STACK);
03100	EXTERNAL PROCEDURE SAVSTR(STRING S);
03200	EXTERNAL STRING PROCEDURE USESTR;
03300	EXTERNAL STRING PROCEDURE FANCYNUM(REAL R);
03400	EXTERNAL PROCEDURE MATOUT(INTEGER I);
03500	EXTERNAL INTEGER PROCEDURE MATIN;
03600	
03700	
03800	
03900	
04000	
04100	FORWARD SIMPLE PROCEDURE CDRAW(INTEGER C,W);
04200	FORWARD SIMPLE PROCEDURE GLINE(SAFE REAL ARRAY M; INTEGER LTYPE);
04300	FORWARD SIMPLE PROCEDURE GPOINT(SAFE REAL ARRAY X;INTEGER PTYPE);
04400	FORWARD SIMPLE PROCEDURE PDELETE(INTEGER PIC);
04500	FORWARD INTEGER SIMPLE PROCEDURE HI(INTEGER I);
04600	FORWARD INTEGER SIMPLE PROCEDURE LOW(INTEGER I);
04700	FORWARD SIMPLE PROCEDURE LOADHI(REFERENCE INTEGER TO; INTEGER FROM);
04800	FORWARD SIMPLE PROCEDURE LOADLOW(REFERENCE INTEGER TO; INTEGER FROM);
04900	FORWARD SIMPLE PROCEDURE CURGEN(INTEGER WIND);
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		MISCELLANEOUS SIMPLE PROCEDURES FOR HANDLING THE DISPLAY.
00500	
00600	
00700	PPOST (INT)	ADD A PICTURE TO THE DISPLAY:
00800			CALL:	'INT' IS A PICTURE ID.
00900			EFFECT:	IF 'INT' IS ZERO, DO NOTHING, OTHERWISE
01000				CALL DPOST TO DISPLAY THE PICTURE NUMBERED 'INT'.
01100	
01200	PDELETE (INT)	DELETE A PICTURE FROM THE DISPLAY:
01300			CALL:	'INT' IS PICTURE ID NUMBER.
01400			EFFECT:	IF 'INT' IS NON-ZERO, THEN UNPOST THE PICTURE OF THAT
01500				NUMBER, AND DELETE IT FROM THE DISPLAY FILES.
01600	
01700	PBLANK (INT)	BLANK A PICTURE BEING DISPLAYED:
01800			CALL:	'INT' IS PICTURE ID NUMBER
01900			EFFECT:	IF 'INT' IS NON-ZERO, THEN UNPOST THE PICTURE OF THAT
02000				NUMBER.
02100	
02200	GINIT		INITIALIZE THE DISPLAY:
02300			EFFECT:	INITIALIZE THE DISPLAY PACKAGE FOR THE 340.
02400				SET 'DISINIT' TO TRUE, INDICATING THAT THE DISPLAY IS INITIALIZED.
02500				IF THE USER HAS NOT TYPED 'RELEASE DISPLAY', THEN ACTUALLY SEIZE THE DISPLAY.
02600				FILL THE ARRAY 'DISINFO' WITH THE PARAMETERS OF THIS DISPLAY.
02700	
02800	SETPIC (@INT)	INITIALIZE GENERATION OF A PICTURE:
02900			CALL:   'INT'= PICTURE ID OF PICTURE TO BE GENERATED.
03000			EFFECT:	IF 'INT' IS NON-ZERO, OLD PICTURE IS DELETED FIRST.
03100				NEW PICTURE STARTED, INTENSITY INITIALIZED
03200			RETURN: 'INT' HAS BEEN STUFFED WITH A NEW PICTURE ID
03300				OF AN INITIALIZED PICTURE.
03400	
03500	SETWIND (INT)	INITIALIZE THE WINDOW PARAMETERS:
03600			CALL:   'INT' IS INDEX OF A-NODE CONTAINING WINDOW PARMS.
03700			EFFECT: SETS UP WINDOW VALUES FROM A[INT+CSTW1], A[INT+CSTW2], ETC.
03800			RETURN: IF THE WINDOW IS EMPTY, 'TRUE', ELSE 'FALSE'
03900	
04000	SETPORT (INT)	INITIALIZE VIEWPORT PARAMETERS:
04100			CALL:  'INT' IS INDEX OF A-NODE CONTAINING VIEWPORT
04200				INFORMATION.
04300			EFFECT: DISPLAY PACKAGE VIEWPORT PARAMETERS ARE
04400				SET UP FROM A[INT+WSTP1], A[INT+WSTP2], ETC.
04500	
04600	
04700	THE DISPLAY IS ALWAYS RELEASED WHEN THERE ARE NO UNBLANKED (I.E. VISIBLE)
04800	PICTURES BEING DISPLAYED.
04900	***************************************************************************************************
05000	;
05100	
05200	INTERNAL SIMPLE PROCEDURE GINIT (STRING DIS);
05300	BEGIN REAL R;
05400	      INTEGER I,J,K,N;
05500	
05600	       IF NOT EQU(CURRENTDIS,DIS) OR NOT DISINIT THEN 
05700	        BEGIN
05800		DINI (CVSIX(DIS),'12,0,0);  			"INITIALIZE DISPLAY PACKAGE"
05900	        I_TRUE END  ELSE I_FALSE;
06000	        CURRENTDIS_DIS;
06100		DISINIT_TRUE;
06200		DENQ (DISINFO[1]);  			"FILL ARRAY WITH GOODIES ABOUT OUR DISPLAY"
06300	
06400	        IF NOT RELDIS THEN IF (RELDIS_LNOT DGET) THEN  OUTSCR("[DISPLAY NOT AVAILABLE]");
06500	  "THE PURPOSE OF THE LOOP BELOW IS TO MARK ALL EXTANT PICTURES
06600	   AS DESTROYED.  INDEED THE DINI CALL ABOVE HAS DKILLED THEM EFFECTIVELY.
06700	   AND THEN REDRAW THE CURRENT DISPLAY (IF ANY).  THUS A DISPLAY
06800	   CHANGE WILL WORK JUST RIGHT! "
06900	
07000	     IF I THEN 
07100	        FOR I_1 STEP 1 UNTIL SYMTABSIZE DO 
07200	            IF TYPE[I]=WINDOW THEN BEGIN
07300	               J_I;
07400	               WHILE (J_VALUE[J]) NEQ I DO BEGIN
07500	                     A[(N_IDX[J])+CSP]_0;
07600	                     LOADHI(A[N+CP2],0)    END;
07700	              CURGEN(I)            END;
07800	
07900	
08000		DCURSOR (0,.95*MAXVIEWY);		"PUT CURSOR AT TOP"
08100	END;
08200	
08300	SIMPLE PROCEDURE PPOST(INTEGER I);
08400	IF I THEN BEGIN
08500		POSTNUMBER_DPOST(I);			"POST THE PICTURE OF ID I"
08600	END;
08700	
08800	
08900	SIMPLE PROCEDURE PDELETE(INTEGER I);
09000	IF I THEN BEGIN
09100		POSTNUMBER_DUNPOST(I);  		"FIRST UNPOST THE PICTURE, IF IT WAS UP"
09200		DKILL(I);				"NOW RECLAIM PICTURE STORAGE"
09300	END;
09400	
09500	SIMPLE PROCEDURE PBLANK(INTEGER I);
09600	IF I THEN BEGIN
09700		POSTNUMBER_DUNPOST(I);  		"UNPOST THE PICTURE"
09800	END;
09900	
10000	
10100	INTEGER PICCOUNT;
10200	
10300	SIMPLE PROCEDURE SETPIC(REFERENCE INTEGER PIC);
10400	BEGIN
10500		PDELETE(PIC);				"DELETE OLD ONE, IF ANY"
10600		DINT (INTENSITY/7);			"SET DEFAULT INTENSITY"
10700		DOPEN (PIC_PICCOUNT_PICCOUNT+1);	"CREATE NEW ID, NEW PICTURE"
10800	END;
10900	
11000	
11100	INTEGER SIMPLE PROCEDURE SETWIND (INTEGER I);
11200	BEGIN REAL AA,BB,CC,DD;
11300		AA_REL(A[I+CSTW1]);  			"GET ALL WINDOW PARAMETERS"
11400		BB_REL(A[I+CSTW2]);
11500		CC_REL(A[I+CSTW3]);
11600		DD_REL(A[I+CSTW4]);
11700		IF AA GEQ BB OR CC GEQ DD THEN RETURN (TRUE);  "EMPTY WINDOW"
11800	
11900		DWIND (AA,BB,CC,DD);  			"TELL DISPLAY ROUTINES ABOUT WINDOW"
12000		RETURN (FALSE)
12100	END;
12200	
12300	SIMPLE PROCEDURE SETPORT (INTEGER I);
12400	DPORT (REL(A[I+WSTP1]), REL(A[I+WSTP2]), REL(A[I+WSTP3]), REL(A[I+WSTP4]));
12500	
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		SIMPLE PROCEDURES FOR HALF WORD MANIPULATION
00500	
00600	
00700	HI (INT)	GET THE LEFT-HALF OF A WORD:
00800			CALL:	'INT' IS A 36-BIT WORD.
00900			RETURN: RETURNS LEFT-HALF 18 BITS OF 'INT', SIGN-EXTENDED.
01000	
01100	LOW (INT)	GET THE RIGHT-HALF OF A WORD:
01200			CALL:	'INT' IS A 36-BIT WORD.
01300			RETURN:	RETURNS RIGHT-HALF 18 BITS OF 'INT', SIGN-EXTENDED.
01400	
01500	LOADLOW (@INT[TO],INT[FROM])	FILLS IN RIGHT-HALF OF A WORD:
01600			CALL:	@INT[TO] IS ADDRESS OF PLACE TO PUT
01700				INT[FROM].
01800			EFFECT: RIGHT-HALF OF INT[FROM] IS STORED IN RIGHT-HALF OF @INT[TO]
01900	
02000	LOADHI (@INT[TO],INT[FROM])     FILLS IN LEFT-HALF OF A WORD:
02100			CALL:	@INT[TO] IS ADDRESS OF PLACE TO PUT
02200				INT[FROM]
02300			EFFECT:	RIGHT-HALF OF INT[FROM] IS STORED IN LEFT-HALF OF @INT[TO]
02400	
02500	***************************************************************************************************
02600	;
02700	
02800	
02900	
03000	 INTEGER SIMPLE PROCEDURE HI (INTEGER X);
03100	BEGIN START!CODE
03200		HLRE	1,X;
03300	END END	"HI";
03400	
03500	
03600	 INTEGER SIMPLE PROCEDURE LOW (INTEGER X);
03700	BEGIN START!CODE
03800		HRRE	1,X;
03900	END END	"LOW";
04000	
04100	
04200	 SIMPLE PROCEDURE LOADLOW (REFERENCE INTEGER TO;INTEGER FROM);
04300	BEGIN START!CODE
04400		MOVE	1,FROM;
04500		HRRM	1,TO;
04600	END END	"LOADLOW";
04700	
04800	
04900	 SIMPLE PROCEDURE LOADHI (REFERENCE INTEGER TO;INTEGER FROM);
05000	BEGIN START!CODE
05100		MOVE	1,FROM;
05200		HRLM	1,TO;
05300	END END	"LOADHI";
05400	
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400			MISCELLANEOUS ROUTINES
00500	
00600	MAPC (INT,@PROC)	PERFORMS SIMPLE PROCEDURE PROC FOR A BUNCH OF CURVES:
00700		CALL:	IF TYPE[I] IS CURVE, THEN CALL PROC(I)
00800			IF TYPE[I] IS WINDOW, CALL PROC(I) FOR ALL CURVES I IN THE WINDOW.
00900	
01000	NUMSTR (REAL)	PUTS TOGETHER AN ASCII STRING TO TYPE 'REAL'.
01100			THE STRING IS 'PRETTIFIED', SUITABLE FOR DISPLAYING
01200			AS A POINT LABEL ON THE DISPLAY SCREEN
01300	
01400	
01500	CURVEMATS (C,OP)  FOR COPYING CURVE MATRICES:
01600		CALL:	C IS A SYMTABENTRY OF A CURVE.
01700			OP = 1 TO RETURN A COPY OF POINT LABEL MATRIX.
01800			OP = 0 TO RETURN A COPY OF CURVE MATRIX.
01900	
02000		RETURN:	INTEGER NUMBER OF NEW SYMTABENTRY.
02100	
02200	***************************************************************************************************
02300	;
02400	
02500	SIMPLE PROCEDURE MAPC (INTEGER I; REFERENCE SIMPLE PROCEDURE P);
02600	BEGIN INTEGER J;
02700		IF TYPE[I] = CURVE THEN P(I) ELSE
02800		IF TYPE[I] = WINDOW THEN BEGIN
02900			J_VALUE[I];			"GET FIRST CURVE"
03000			WHILE J NEQ I DO BEGIN P(J); J_VALUE[J]; END
03100		END ELSE TYPEFORMERROR (I)
03200	END;
03300	
03400	
03500	STRING SIMPLE PROCEDURE NUMSTR (REAL R);
03600	BEGIN
03700	STRING S,T;
03800	INTEGER EXP,B;
03900	
04000		IF R = 0 THEN RETURN(" 0");
04100		SETFORMAT(10,3);
04200		S_CVE(R);		"TRY FOR THIS TYPE OF REPRESENTATION"
04300		T_LOP(S);
04400		T_S[7 TO INF];		"FETCH EXPONENT"
04500		EXP_INTSCAN(T,B);
04600		"IF EXPONENT > 6 OR EXPONENT < -3, CVE FORMAT IS BEST."
04700		IF EXP < -3 OR EXP > 6 THEN
04800		BEGIN
04900		   B_LENGTH(S);
05000		   S_S[1 TO 5]&"E"&S[7 TO INF];
05100		   WHILE S[B FOR 1] =" " DO B_B-1;
05200		   RETURN(S[1 TO B]);
05300		END;
05400	
05500		IF EXP = 0 THEN S_S[1 TO 5] ELSE BEGIN
05600			T_S[3 FOR 3];
05700			IF EXP < 0 THEN BEGIN
05800				S_S[1 FOR 2];
05900				FOR B_1 STEP 1 UNTIL ABS(EXP) DO S_S&"0";
06000				S_S&T;
06100			END ELSE BEGIN
06200				T_T&"000";
06300				S_S[1 FOR 1];
06400				S_S&T[1 FOR EXP]&".";
06500				IF EXP < 6 THEN S_S&T[EXP+1 TO INF];
06600			END
06700		END;
06800		B_LENGTH(S);
06900		WHILE S[B FOR 1] ="0" DO B_B-1;
07000		IF S[B FOR 1] ="." THEN B_B-1;
07100		RETURN(S[1 FOR B])
07200	END;
07300	
07400	
07500	
07600	
07700	INTERNAL INTEGER SIMPLE PROCEDURE CURVEMATS(INTEGER C,OP);
07800	BEGIN
07900	SAFE REAL ARRAY ITEMVAR Q;
08000	OWN SAFE REAL ARRAY EMPTY[0:-1,0:-1];
08100	INTEGER I;
08200	
08300		IF TYPE[C] NEQ CURVE THEN TYPEFORMERROR(C);
08400		I_A[IDX[C]+CM];
08500		I_IF OP=0 THEN LOW(I) ELSE HI(I);
08600		Q_IF I=0 THEN NEW(EMPTY) ELSE CVI(I);
08700		I_NEWTEMP;
08800		TYPE[I]_MATRIX;
08900		VALUE[I]_CVN(NEW(DATUM(Q)));
09000		RETURN(I);
09100	END "CURVEMATS";
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400			ROUTINES FOR BLANKING AND UNBLANKING:
00500				INDIVIDUAL CURVES
00600				ALL CURVES IN A WINDOW.
00700	
00800	CBLANK (INT)
00900	CUNBLANK (INT)
01000			CALL:	'INT' IS INDEX OF WINDOW OR CURVE IN SYMTAB.
01100			EFFECT: IF TYPE[INT] IS CURVE, BLANK (UNBLANK) THE ONE CURVE.
01200				IF TYPE[INT] IS WINDOW, BLANK (UNBLANK) ALL CURVES IN THE
01300					WINDOW.
01400				THE 'BLANKSW' BIT IS TURNED ON (OFF) IN EACH CURVE
01500					PROCESSED.
01600	
01700	***************************************************************************************************
01800	;
01900	
02000	
02100	INTERNAL SIMPLE PROCEDURE CBLANK(INTEGER C);
02200	BEGIN
02300	SIMPLE PROCEDURE BLANKCURVE (REFERENCE INTEGER I);
02400	BEGIN INTEGER J;
02500		J_IDX[I];
02600		A[J]_A[J] LOR BLANKSW;
02700		PBLANK(HI(A[J+CSP])); 			"BLANK THE CURVE, IF ANY"
02800		PBLANK(HI(A[J+CP2])); 			"BLANK THE POINT LABELS, IF ANY"
02900		PBLANK(LOW(A[J+CSP])); 			"BLANK THE STRINGS, IF ANY"
03000	END   "BLANKCURVE";
03100	
03200		MAPC (C, BLANKCURVE);			"BLANK ALL CURVES"
03300	END   "CBLANK";
03400	
03500	
03600	INTERNAL SIMPLE PROCEDURE CUNBLANK (INTEGER C);
03700	BEGIN
03800	SIMPLE PROCEDURE UNBLANKCURVE (REFERENCE INTEGER I);
03900	BEGIN INTEGER J;
04000		J_IDX[I];
04100		IF (A[J] LAND BLANKSW) = 0 THEN RETURN; "ALREADY UNBLANKED"
04200		A[J]_A[J] LAND BLANKSWI;
04300		PPOST(HI(A[J+CSP]));			"UNBLANK THE CURVE, IF ANY"
04400		PPOST(HI(A[J+CP2]));			"UNBLANK THE POINT LABELS, IF ANY"
04500		PPOST(LOW(A[J+CSP]));			"UNBLANK THE STRING, IF ANY"
04600	END   "UNBLANKCURVE";
04700	
04800		MAPC (C,UNBLANKCURVE);			"UNBLANK ALL CURVES"
04900	END   "CUNBLANK";
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		ROUTINES FOR DELETING WINDOWS AND CURVES
00500	
00600	
00700	CDELET (INT)	DELETE A CURVE ENTRY:
00800			CALL:	'INT' IS INDEX OF CURVE IN SYMTAB.
00900			EFFECT: REMOVE CURVE FROM CURVE LIST FOR THIS WNDOW,
01000				DELETE ANY DISPLAYS GENERATED ON BEHALF OF THIS CURVE,
01100				DELETE ANY MATRICES (CURVE,POINT LABEL) ATTACHED TO THIS CURVE,
01200				FREE THE A-NODE FOR THE CURVE, AND THE SYMBOL-TABLE ENTRY.
01300	
01400	WDELET (INT)	DELETE A WINDOW AND ALL ITS CURVES:
01500			CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
01600			EFFECT:	DELETE ALL CURVES IN THIS WINDOW VIA CDELET.
01700				FREE THE A-NODE FOR THE WINDOW, AND THE SYMBOL-TABLE ENTRY.
01800	
01900	
02000	***************************************************************************************************
02100	;
02200	
02300	
02400	INTERNAL SIMPLE PROCEDURE CDELET(INTEGER I);
02500	BEGIN
02600	INTEGER J,K,L;
02700	
02800		"DELETE ENTRY FROM LIST OF CURVES IN THIS WINDOW"
02900		
03000		K_J_VALUE[I]; 				"J = INDEX OF NEXT CURVE"
03100		WHILE VALUE[K] NEQ I DO K_VALUE[K];
03200		VALUE[K]_J;
03300	
03400		K_IDX[I];				"DELETE ANY DISPLAYS"
03500		PDELETE(HI(A[K+CSP]));
03600		PDELETE(LOW(A[K+CSP]));
03700		PDELETE(HI(A[K+CP2]));
03800	
03900		IF (L_HI(A[K+CM])) THEN DELETE (CVI(L));  "DELETE CURVE AND POINT LABEL MATRICES"
04000		IF (L_LOW(A[K+CM])) THEN DELETE (CVI(L));
04100		IF (L_A[K+CSTR]) THEN ST[L]_NULL; 	"DELETE STRING"
04200		FREENODE(K,A);				"FREE AREA IN ARRAY A"
04300		NAME[I]_" ";				"REMOVE SYMTAB ENTRY"
04400	END;
04500	
04600	
04700	INTERNAL SIMPLE PROCEDURE WDELET(INTEGER I);
04800	BEGIN ;					"LOOP DELETING CURVES UNTIL WINDOW POINTS TO ITSELF"
04900		WHILE NOT (VALUE[I]=I) DO CDELET (VALUE[I]);
05000		FREENODE(IDX[I],A);
05100		NAME[I]_" ";
05200	END;
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		DRAW OR REDRAW A CURVE OR STRING
00500	
00600	DRAW (C,U,W,LTYPE,PTYPE,FLOATL,PLSZE,N,LABELSKIP,ATX,ATY,INTQ)
00700		CALL:
00800		IF U>0 AND TYPE[U] = MATRIX THEN DRAW A CURVE WITH
00900	
01000		     	C = INDEX OF CURVE IN SYMTAB
01100			U = INDEX OF CURVE MATRIX IN SYMTAB
01200			W = INDEX OF WINDOW IN SYMTAB
01300			LTYPE = LINE TYPE CODE (0-5)
01400			PTYPE = POINT TYPE CODE (0-7) OR "*"
01500				FOLLOWED BY AN ASCII CHARACTER
01600				TO BE PLOTTED AT EACH POINT
01700			FLOATL = FLOATING LABEL SWITCH
01800			       = +1 FOR X FLOATING LABELS
01900			       = -1 FOR Y FLOATING LABELS
02000			       = 0 OTHERWISE
02100			PLSZE = POINT LABEL SIZE (1-4)
02200			N = INDEX OF PT LBL MATRIX IN SYMTAB
02300			LABELSKIP: POINT LABEL EVERY LABELSKIP-TH POINT
02400			ATX = X LOCATION FOR POINT LABEL
02500			ATY = Y LOCATION FOR POINT LABEL
02600			INTQ = INTENSITY (0-7)
02700	
02800		IF U > 0 AND TYPE[U] = TEXT THEN CREATE CURVE C IF
02900		IT DOES NOT ALREADY EXIST AND ADD TO IT THE STRING
03000		SPECIFIED BY
03100	
03200			C = INDEX OF CURVE IN SYMTAB
03300			NAME[U][2 TO INF] = STRING
03400			W = INDEX OF WINDOW IN SYMTAB
03500	                FLOATL = VERTICAL TEXT SWITCH
03600	                       = 0 FOR HORIZONTAL TEXT
03700	                       = 1 FOR VERTICAL TEXT
03800			PLSZE = SIZE OF STRING (1-4)
03900			ATX = X-COORDINATE OF STRING (WINDOW COORDINATES)
04000			ATY = Y-COORDINATE OF STRING
04100			INTQ = INTENSITY (0-7)
04200			[OTHER PARAMS IGNORED]
04300	
04400		IF U = 0 THEN REDRAW THE STRING OF CURVE C AS FOLLOWS:
04500	
04600			PLSZE = STRING SIZE (1-4)
04700			ATX,ATY = IF ATX = DEFAULT THE STRING IS NOT MOVED.
04800				  OTHERWISE STRING MOVED TO ATX,ATY
04900			INTQ = INTENSITY (0-7)
05000	
05100		IF U < 0 THEN REDRAW THE CURVE USING THE SAME MATRIX
05200		AND WINDOW.
05300	
05400			PARAMETERS AS IN CASE 1 ABOVE, EXCEPT THAT
05500			DEFAULT VALUES FOR PTYPE, LTYPE, AND PLSZE
05600			WILL BE THE PREVIOUS VALUES - NOT THE
05700			STANDARD DEFAULTS.
05800	
05900	
06000	
06100	DEFAULT VALUES WHEN CREATING NEW CURVES:
06200		LINE TYPE = 1
06300		POINT TYPE = 0
06400		POINT LABEL SIZE = 2
06500		POINT LABEL SKIP = 1
06600		POINT LABEL X = 0
06700		POINT LABEL Y = 0
06800		STRING SIZE = 2
06900		STRING X = 0
07000		STRING Y = 0
07100		INTENSITY = 5
07200		UNBLANKED, UNINSCRIBED, NO POINT LABELS
07300	
07400	***************************************************************************************************
07500	;
07600	
07700	DEFINE DEFBLANKINSCR = "0",DEFPTLBLSZ = "2",DEFXYFLTSW = "0",DEFLINETYPE = "1",
07800		DEFSTRSZ = "2",	DEFPTLBLSKIP = "1",DEFPTLBLX = "0",DEFPTLBLY = "0",
07900		DEFSTRINGX = "0",DEFSTRINGY = "0",DEFPTTYPE = "0",DEFINTENSITY = "5";
08000	
08100	COMMENT NOW AN OWN ARRAY WITH THE DEFAULT VALUES ALL SET UP;
08200	
08300	PRELOAD!WITH
08400		((((((DEFBLANKINSCR LSH 6) + DEFPTLBLSZ) LSH 6 + DEFXYFLTSW) LSH 6 +
08500		DEFLINETYPE) LSH 6 + 0) LSH 6 + DEFSTRSZ),
08600		0,
08700		DEFPTLBLSKIP,
08800		0,
08900		DEFPTLBLX,
09000		DEFPTLBLY,
09100		[4] 0,
09200		0,
09300		DEFSTRINGX,
09400		DEFSTRINGY,
09500		(DEFPTTYPE LSH 18) + DEFINTENSITY;
09600	OWN SAFE INTEGER ARRAY DEFCRV[1:15];
09700	
     
00100	
00200	INTERNAL SIMPLE PROCEDURE DRAW(INTEGER C, U;
00300				INTEGER W, LTYPE, PTYPE, FLOATL, PLSZE, N;
00400				REAL LABELSKIP,ATX,ATY;INTEGER INTQ);
00500	BEGIN
00600	INTEGER I,J,ANODE,PTR;
00700	SAFE REAL ARRAY ITEMVAR Q;
00800	
00900	
01000		IF TYPE[C] NEQ CURVE THEN BEGIN "MAKE A NEW CURVE"
01100			IF TYPE[W] NEQ WINDOW THEN TYPEFORMERROR(W);
01200			IF TYPE[C] NEQ UNKNOWN THEN TYPEFORMERROR(C);
01300	
01400			NEWNODE(J,A);			"GET A NEW A-NODE"
01500			IDX[C]_J;			"POINT SYMTAB AT IT"
01600			TYPE[C]_CURVE;
01700			ARRBLT(A[J],DEFCRV[1],15);   	"FILL WITH DEFAULTS"
01800	
01900							"PLACE CURVE IN LIST OF CURVES FOR THIS WINDOW"
02000			J_VALUE[W];	VALUE[W]_C;	VALUE[C]_J;
02100	
02200		END "MAKE A NEW CURVE" ELSE
02300		IF W > 0 THEN BEGIN "DRAW THE CURVE IN WINDOW W THIS TIME"
02400				"IF W IS NOT THE OLD WINDOW OF C, FIXUPS ARE NEEDED"
02500	
02600			IF TYPE[W] NEQ WINDOW THEN TYPEFORMERROR(W);
02700			I_VALUE[C];			"FIND OLD WINDOW"
02800			WHILE TYPE[I] NEQ WINDOW DO I_VALUE[I];
02900			IF I NEQ W THEN BEGIN "TO BE DRAWN IN A NEW WINDOW"
03000			   WHILE VALUE[I] NEQ C DO I_VALUE[I];
03100		   	   VALUE[I]_VALUE[C];		"DELETE THIS CURVE FROM OLD WINDOW LIST"
03200							"PLACE CURVE IN LIST FOR NEW WINDOW"
03300			   I_VALUE[W];	VALUE[C]_I;	VALUE[W]_C;
03400			END "TO BE DRAWN IN A NEW WINDOW"
03500		END ELSE
03600		BEGIN "MUST FIND THE ACTUAL WINDOW OF C"
03700			W_VALUE[C];
03800			WHILE TYPE[W] NEQ WINDOW DO W_VALUE[W];
03900		END;
04000	
04100		
04200		ANODE_IDX[C];
04300	
04400		IF U=0 OR (U>0 AND TYPE[U] = TEXT) THEN BEGIN "UPDATE STRING"
04500			IF U>0 THEN BEGIN "REPLACE STRING"
04600			   I_A[ANODE+CSTR];
04700			   IF I>0 THEN ST[I]_NULL;
04800			   IF LENGTH(NAME[U]) = 1 THEN BEGIN "DELETE STRING"
04900				I_0;
05000			   END "DELETE STRING" ELSE BEGIN "NEW STRING"
05100				STUFFST(I,NAME[U][2 TO INF]);
05200			   END "NEW STRING";
05300			   A[ANODE+CSTR]_I;
05400			END "REPLACE STRING";
05500	
05600			IF 0 < PLSZE < 5 THEN BEGIN
05700				PTR_POINT(6,A[ANODE],35);
05800				DPB(PLSZE,PTR);
05900			END;
06000	                "SET VERTICAL TEXT SWITCH"
06100	                DPB(FLOATL,POINT(1,A[ANODE],29));
06200	
06300			IF ATX NEQ DEFAULT THEN BEGIN
06400				A[ANODE+CSTRX]_INT(ATX);
06500				A[ANODE+CSTRY]_INT(ATY);
06600			END;
06700	
06800		END "UPDATE STRING" ELSE BEGIN "WORK ON CURVE"
06900	
07000			IF U > 0 AND TYPE[U] = MATRIX THEN BEGIN "REPLACE CURVE MATRIX"
07100				I_LOW(A[ANODE+CM]);		"DELETE OLD POINT MATRIX"
07200				IF I THEN DELETE(CVI(I));
07300				Q_CVI(VALUE[U]);		"THIS IS THE NEW MATRIX"
07400				LOADLOW(A[ANODE+CM],CVN(NEW(DATUM(Q))));
07500			END "REPLACE CURVE MATRIX"
07600			ELSE IF U>0 THEN TYPEFORMERROR (U);	"NONSENSE"
07700	
07800			PTR_POINT (6,A[ANODE],11);	"INITIALIZE BYTE POINTER"
07900							"INSTALL POINT LABEL SIZE"
08000			IF 0 < PLSZE < 5 THEN DPB(PLSZE,PTR);
08100							"AND XFLOATING/YFLOATING FLAGS"
08200			IF N>0 THEN
08300			   IDPB(IF FLOATL > 0 THEN '40 ELSE IF FLOATL < 0 THEN '20 ELSE 0,PTR)
08400			   ELSE IBP(PTR);
08500	
08600							"LINE TYPE"
08700			IF -1 < LTYPE < 6 THEN IDPB(LTYPE,PTR);
08800	
08900							"POINT TYPE"
09000			IF -1 < PTYPE < 8 THEN LOADHI(A[ANODE+CINT],PTYPE)
09100			ELSE BEGIN "FIND THE ASCII CHAR"
09200				STRING S;
09300				S_CVSTR(PTYPE);
09400				IF S = "*" THEN LOADHI(A[ANODE+CINT],S[2 FOR 1]);
09500			END;
09600	
09700			IF N>0 THEN BEGIN "REPLACE POINT-LABEL MATRIX"
09800				I_HI(A[ANODE+CM]);
09900				IF I NEQ 0 THEN DELETE(CVI(I));
10000				Q_CVI(VALUE[N]);
10100				Q_NEW(DATUM(Q));
10200				LOADHI(A[ANODE+CM],CVN(Q));
10300				IF LABELSKIP > 0 THEN LOADLOW(A[ANODE+CP2],LABELSKIP);
10400			END;
10500	
10600			IF ATX NEQ DEFAULT THEN BEGIN
10700				A[ANODE+CPTLX]_INT(ATX);
10800				A[ANODE+CPTLY]_INT(ATY);
10900			END;
11000		END "WORK ON CURVE";
11100	
11200		IF -1 < INTQ < 8 THEN LOADLOW(A[ANODE+CINT],INTQ);
11300	
11400		IF (A[ANODE] LAND INSW) = 0 THEN
11500		   ARRBLT(A[ANODE+CSTW1],A[IDX[W]+WSTW1],4);
11600		CDRAW(C,W);
11700	
11800	END	"DRAW";
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		DISPLAY A CURVE
00500	
00600	CDRAW (INT,WIND)
00700		CALL:	INT = INDEX OF CURVE ENTRY IN SYMTAB
00800			WIND = INDEX OF WINDOW IN SYMTAB
00900		EFFECT:	A COMPONENT PICTURE CONTAINING THE 
01000			 INFORMATION CORRESPONDING TO THIS CURVE
01100			HAS BEEN GENERATED
01200	
01300	***************************************************************************************************
01400	;
01500	
01600	
01700	SIMPLE PROCEDURE CDRAW (INTEGER I,WIND);
01800	BEGIN "CDRAW"
01900	INTEGER PIC1,PIC2,PIC3,LTYPE,PTYPE,Q,J,K,L,M,N,WINDX,SC,C1,WIN;
02000	REAL X,Y,Z,XDEL,YDEL,AD1,AD2,FACT;
02100	SAFE REAL ARRAY ITEMVAR IV1, IV2;
02200	
02300	
02400		IF NOT DISINIT THEN BEGIN CALLEDFROMCDRAW_TRUE; 
02500	                                  GINIT(CURRENTDIS);		"INITIALIZE DISPLAY"
02600	                                  CALLEDFROMCDRAW_FALSE  END;
02700		C1_I;					"SAVE CURVE INDEX"
02800		I_IDX[I];				"I IS A-NODE POINTER"
02900		INTENSITY_LOW(A[I+CINT]);		"INTENSITY"
03000	
03100		PIC1_HI(A[I+CSP]);			"CURVE PICTURE"
03200		PIC2_LOW(A[I+CSP]);			"STRING PIC"
03300		PIC3_HI(A[I+CP2]);			"POINT LABEL PIC"
03400		WIN_SETWIND (I);			"SET UP WINDOW AND REMEMBER IF EMPTY"
03500		SETPORT (WINDX_IDX[WIND]);		"SET UP VIEWPORT FROM WINDOW BLOCK"
03600	
03700		IF NOT WIN AND LOW(A[I+CM]) THEN BEGIN "REGENERATE CURVE MATRIX"
03800		   SETPIC(PIC1);			"START A PICTURE GOING"
03900		   DENQ (DISINFO[1]);			"THEN GET CURRENT WINDOW,VIEWPORT AS SET UP"
04000		   HUNPERIN_(DISINFO[21]-DISINFO[20])/((DISINFO[17]-DISINFO[16])*INCHESPERVIEWPORT);
04100		   VUNPERIN_(DISINFO[23]-DISINFO[22])/((DISINFO[19]-DISINFO[18])*INCHESPERVIEWPORT);
04200	
04300							"NOW GENERATE POINTS OR LINES, AS NEEDED"
04400		   IV1_CVI(LOW(A[I+CM]));		"ITEM NUMBER OF CURVE MATRIX"
04500		   LTYPE_(A[I] LAND LTYPEM) LSH LTYPEP;	"GET LINE TYPE"
04600		   IF LTYPE THEN GLINE(DATUM(IV1),LTYPE);
04700		   PTYPE_HI(A[I+CINT]);			"GET POINT TYPE"
04800		   IF PTYPE THEN GPOINT(DATUM(IV1),PTYPE);
04900	
05000		   DCLOSE; 				"FINISH PICTURE"
05100		   IF NOT (A[I] LAND BLANKSW) THEN PPOST(PIC1);			"AND POST IT ON DISPLAY IF UNBLANKED"
05200	
05300		   Q_HI(A[I+CM]);			"Q = ITEM # OF PT LBL MATRIX"
05400		   IF Q THEN BEGIN "POINT LABELS" 
05500			SETPIC(PIC3);
05600			DENQ(DISINFO[1]);
05700			AD1_AD2_0; FACT_1.;
05800			IF A[I] LAND INSW THEN BEGIN "INSCRIBED"
05900			IF A[I] LAND XFLTSW THEN BEGIN
06000			   AD1_REL(A[WINDX+WSTW1]);
06100			   AD2_REL(A[I+CSTW1]);
06200			   FACT_(REL(A[WINDX+WSTW2])-REL(A[WINDX+WSTW1]))
06300			       /(DISINFO[21]-DISINFO[20])
06400			END ELSE
06500			IF A[I] LAND YFLTSW THEN BEGIN
06600			   AD1_REL(A[WINDX+WSTW3]);
06700			   AD2_REL(A[I+CSTW3]);
06800			   FACT_(REL(A[WINDX+WSTW4])-REL(A[WINDX+WSTW3]))
06900			       /(DISINFO[23]-DISINFO[22])
07000			END END "INSCRIBED";
07100			K_(A[I] LSH -24) LAND STRM;	"GET POINT-LABEL SIZE"
07200			IF K<1 OR K>4 THEN K_2;
07300			SC_1 LSH (K-1); DTSCAL (SC * -.0068); "USE NEGATIVE TO DISPLAY ANYWAY"
07400	                DENQ(DISINFO[1]);                     "GET CURRENT CHAR SIZES READY IN DISINFO"
07500			IV1_CVI(Q);			"DATUM(IV1) = PT LBL MATRIX"
07600			IV2_CVI(LOW(A[I+CM]));		"DATUM(IV2) = CURVE MAT"
07700			XDEL_(REL(A[I+CPTLX])*HUNPERIN-DISINFO[10]);
07800			YDEL_(REL(A[I+CPTLY])*VUNPERIN-.5*DISINFO[9]);
07900			J_LOW(A[I+CP2]);		"J= PT LBL SKIP PARAMETER"
08000			K_0;
08100			M_ROWSIZE("DATUM(IV2)");
08200			N_ROWSIZE("DATUM(IV1)");
08300			FOR L_1 STEP J UNTIL M DO
08400			BEGIN
08500			   K_K+1;
08600			   IF K>N THEN DONE;
08700			   X_DATUM(IV2)[L,1];
08800			   Y_DATUM(IV2)[L,2];
08900			   IF NOT DTEST2(X,Y) THEN BEGIN
09000	                      X_X+XDEL; Y_Y+YDEL;
09100			      Z_DATUM(IV1)[K,1];
09200			      Z_AD1+(Z-AD2)*FACT;
09300			      DMOVE (X, Y);
09400			      DTEXT (NUMSTR(Z));
09500			   END
09600			END;
09700	
09800			DCLOSE;
09900			IF NOT (A[I] LAND BLANKSW) THEN PPOST(PIC3);		"DONE WITH POINT LABEL MATRIX - POST IF UNBLANKED"
10000		   END "POINT LABELS"
10100		END "REGENERATE CURVE MATRIX" ELSE BEGIN
10200			PDELETE (PIC1);			"DELETE ALL PICTURES"
10300			PDELETE (PIC3);
10400			PIC1_PIC3_0;
10500		END;
10600	
10700		IF A[I+CSTR] THEN BEGIN "NON-EMPTY STRING"
10800		   SETPIC(PIC2);
10900		   SC_1 LSH ((A[I] LAND STRM)-1);       "SIZE"
11000		   X_REL(A[I+CSTRX]);			"SPOT WHERE STRING IS TO GO"
11100		   Y_REL(A[I+CSTRY]);
11200		   DTSCAL (-.0068*SC );                "SET STRING SIZE"
11300	           DENQ(DISINFO[1]);                    "GET CHAR SIZE INFO"
11400	           IF A[I] LAND VTEXTSW THEN BEGIN
11500	              DSTAT(32); 
11600	              DMOVE(X+.5*DISINFO[9],Y);  "THIS IS ONLY OK FOR THE 340 TEMPORARILY (12/13/74)."
11700	                                     END 
11800	           ELSE
11900		   DMOVE (X,Y-.5*DISINFO[9]);	       "MOVE BEAM TO STARTING POINT"
12000		   DTEXT (ST[A[I+CSTR]]);		"AND DISPLAY TEXT"
12100	           DSTAT(-32);                          "SET VERTICAL TEXT OFF"
12200		   DCLOSE;
12300		   IF NOT(A[I] LAND BLANKSW) THEN PPOST (PIC2);		"DONE WITH STRING PICTURE - POST IF UNBLANKED"
12400		END "NON-EMPTY STRING" ELSE BEGIN
12500			PDELETE (PIC2);
12600			PIC2_0;
12700		END;
12800	
12900		LOADHI (A[I+CSP],PIC1);			"FILL IN CURVE PICTURE ID"
13000		LOADLOW (A[I+CSP],PIC2);		"FILL IN STRING PICTURE ID"
13100		LOADHI (A[I+CP2],PIC3);			"FILL IN POINT LABEL PICTURE"
13200	
13300	END "CDRAW";
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		DRAW SOLID OR DASHED LINES
00500	
00600	GLINE (REAL ARRAY M: LTYPE)
00700		CALL:	M = MATRIX OF COORDINATES OF POINTS ON CURVE
00800			LTYPE = 1 FOR SOLID LINE
00900			      = 2 FOR .1" DASHES
01000			      = 3 FOR .5" DASHES
01100			      = 4 FOR ALTERNATE .1" AND .5"
01200				  DASHES
01300				= 5 FOR SOLID LINE BETWEEN EVERY
01400				    SECOND SET OF POINTS
01500		EFFECT:	LINES ARE ADDED TO CURRENT PICTURE
01600	
01700	***************************************************************************************************
01800	;
01900	
02000	
02100	SIMPLE PROCEDURE GLINE(SAFE REAL ARRAY M;INTEGER LTYPE);
02200	BEGIN
02300	INTEGER IMAX,I,J;
02400	REAL XOLD, YOLD;
02500	LABEL NXLINE,MORLINE,MORSPAC;
02600	REAL DOT,DASH,DLEN,DX,DY,TLEN,TTLEN,THETA,R,DXI,DYI;
02700		IMAX_ROWSIZE(M); 			"GET TOTAL NUMBER OF POINTS"
02800		IF IMAX < 2 THEN RETURN;		"IF 0 OR 1 POINTS, NO GOOD"
02900		DMOVE(XOLD_M[1,1],YOLD_M[1,2]);  	"START BEAM AT FIRST PNT"
03000		DOT_DASH_.1;				"COMPUTE DOT-DASH SIZES"
03100		CASE LTYPE-1 OF
03200		BEGIN
03300		   BEGIN "LINE TYPE 1 -- SOLID"
03400			FOR I_2 STEP 1 UNTIL IMAX DO DDRAW (M[I,1],M[I,2]);
03500			RETURN
03600		   END;
03700		   ;
03800		   DOT_DASH_.5;
03900		   DASH_.5;
04000		   BEGIN "LINE TYPE 5 -- ALTERNATING SOLID AND BLANK"
04100			FOR I_2 STEP 2 UNTIL IMAX DO DVECT (M[I-1,1],M[I-1,2],M[I,1],M[I,2]);
04200			RETURN
04300		   END
04400		END;
04500		DLEN_DOT;
04600		I_2;					"START INDEX INTO DATA ARRAY"
04700	NXLINE:	IF DLEN= DOT THEN DLEN_DASH ELSE DLEN_DOT;
04800		TLEN _ 0.;				"TOTAL LENGTH OF LINE DRAWN SO FAR"
04900	MORLINE:
05000		IF DTEST2(M[I-1,1],M[I-1,2]) LAND DTEST2(M[I,1],M[I,2]) THEN
05100		BEGIN "LINE IS TRIVIALLY REJECTABLE"
05200			DMOVE (XOLD_M[I,1],YOLD_M[I,2]);
05300			IF (I_I+1) > IMAX THEN RETURN; "BUMP TO LOOK AT NEXT LINE"
05400		END ELSE BEGIN "TRY TO SHOW SOME OF THE LINE"
05500			DX_M[I,1]-XOLD;
05600			DY_M[I,2]-YOLD;
05700			DXI_DX/HUNPERIN;
05800			DYI_DY/VUNPERIN;
05900			TTLEN_SQRT(DXI^2+DYI^2);  "LENGTH OF HYPOTENUSE"
06000			IF TLEN+TTLEN<DLEN THEN BEGIN
06100				   TLEN_TLEN+TTLEN;
06200				   DDRAW (XOLD_XOLD+DX,YOLD_YOLD+DY);
06300				   IF (I_I+1)>IMAX THEN RETURN;
06400				   GO TO MORLINE;
06500			END;
06600			THETA_ATAN2(DYI,DXI);
06700			R_DLEN-TLEN;
06800			DX_HUNPERIN*R*COS(THETA);
06900			DY_VUNPERIN*R*SIN(THETA);
07000			DDRAW (XOLD_XOLD+DX,YOLD_YOLD+DY);
07100			TLEN_0.;
07200	MORSPAC:
07300			DX_M[I,1]-XOLD;
07400			DY_M[I,2]-YOLD;
07500			DXI_DX/HUNPERIN;
07600			DYI_DY/VUNPERIN;
07700			TTLEN_SQRT(DXI^2+DYI^2);
07800			IF TLEN + TTLEN < .1 THEN BEGIN
07900				   TLEN_TLEN+TTLEN;
08000				   IF (I_I+1) > IMAX THEN RETURN;
08100				   DMOVE (XOLD_XOLD+DX,YOLD_YOLD+DY);
08200				   GO TO MORSPAC;
08300			END;
08400			THETA_ATAN2(DYI,DXI);
08500			R_.1-TLEN;
08600			DX_HUNPERIN*R*COS(THETA);
08700			DY_VUNPERIN*R*SIN(THETA);
08800			DMOVE (XOLD_XOLD+DX,YOLD_YOLD+DY);
08900		END;
09000		GO TO NXLINE;
09100	
09200	END;
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		PLOT POINT SYMBOLS
00500	
00600	GPOINT (REAL ARRAY M: PTYPE: HUNPERIN: VUNPERIN)
00700		CALL:	M = MATRIX OF COORDINATES OF POINTS
00800			PTYPE = SYMBOL CODE
00900				1 FOR VERTICAL LINE
01000				2 FOR CROSS
01100				3 FOR TRIANGLES
01200				4 FOR SQUARE
01300				5 FOR HORIZONTAL LINE
01400				6 FOR SMALL O SYMBOL
01500	                        7 FOR TINY DOT
01600			HUNPERIN = NUMBER OF UNITS PER IN IN THE
01700				HORIZONTAL DIRECTION
01800			VUNPERIN = NUMBER OF UNITS PER INCH IN THE
01900				VERTICAL DIRECTION
02000	
02100		EFFECT:	POINT SYMBOLS ARE ADDED TO THE CURRENT PICTURE
02200	
02300	***************************************************************************************************
02400	;
02500	
02600	
02700	SIMPLE PROCEDURE GPOINT (SAFE REAL ARRAY M; INTEGER PTYPE);
02800	BEGIN
02900	INTEGER IMAX,I;
03000	REAL X,Y,XD1,XD2,YD1,YD2,SIZEQ;
03100	STRING S;
03200		IMAX_ROWSIZE(M);			"GET NUMBER OF POINTS TO PLOT"
03300		XD1 _ .1*HUNPERIN;
03400		XD2 _ XD1+XD1;
03500		YD1 _ .1*VUNPERIN;
03600		YD2 _ YD1+YD1;
03700		S_"O"; SIZEQ_-.0068;
03800		IF PTYPE > 7 THEN BEGIN	S_PTYPE; PTYPE_6; SIZEQ_-.0127 END;
03900		DTSCAL (SIZEQ);				"SET DISPLAY TEXT SIZE"
04000	       DENQ(DISINFO[1]);                        "GET CURRENT CHAR SIZES IN DISINFO"
04100		FOR I_1 STEP 1 UNTIL IMAX DO BEGIN "LOOP"
04200		X_M[I,1]; Y_M[I,2];
04300		CASE PTYPE OF
04400		   BEGIN
04500			;
04600			BEGIN "VERTICAL LINE"
04700			  DVECT (X,Y-YD1,X,Y-YD1+YD2);
04800			END;
04900			BEGIN "CROSS"
05000			  DVECT (X,Y-YD1,X,Y-YD1+YD2);
05100			  DVECT (X-XD1,Y,X-XD1+XD2,Y);
05200			END;
05300			BEGIN "TRIANGLE"
05400			  DVECT (X,Y,X,Y_Y+YD1);
05500			  DDRAW (X_X-XD1,Y_Y-YD2);
05600			  DDRAW (X_X+XD2,Y);
05700			  DDRAW (X-XD1,Y+YD2);
05800			END;
05900			BEGIN "SQUARE"
06000			  DVECT (X,Y,X,Y_Y+YD1);
06100			  DDRAW (X_X-XD1,Y);
06200			  DDRAW (X,Y_Y-YD2);
06300			  DDRAW (X_X+XD2,Y);
06400			  DDRAW (X,Y_Y+YD2);
06500			  DDRAW (X-XD1,Y);
06600			END;
06700			BEGIN "HORIZONTAL LINE"
06800			  DVECT (X-XD1,Y,X-XD1+XD2,Y);
06900			END;
07000			BEGIN "SMALL O"
07100			  IF NOT DTEST2 (X,Y) THEN BEGIN
07200				DMOVE (X-.5*DISINFO[10], Y-.5*DISINFO[9]);
07300				DTEXT (S);
07400			  END;
07500			END;
07600	                BEGIN "SMALL DOT"
07700	                  DDOT(X,Y)
07800	                END
07900		   END;
08000		END "LOOP";
08100	END;
     
00100	SIMPLE PROCEDURE CURGEN (INTEGER WIND);
00200	COMMENT
00300		FIND ALL CURVES IN A WINDOW
00400		UPDATE THEIR WINDOW PARAMETERS
00500		REGENERATE CURVES IF DISPLAY IS ON
00600	
00700		CALL:	WIND = INDEX OF WINDOW IN SYMTAB
00800	;
00900	
01000	BEGIN
01100	INTEGER I,N;
01200	
01300		I_WIND;
01400		WHILE (I_VALUE[I]) NEQ WIND DO BEGIN
01500			N_IDX[I];
01600			IF (A[N] LAND INSW = 0) THEN ARRBLT(A[N+CSTW1],A[IDX[WIND]+WSTW1],4);
01700			CDRAW(I,WIND)
01800		END
01900	END;
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400			SIMPLE PROCEDURES FOR REVISING THE WINDOW OR VIEWPORT PARAMETERS
00500	
00600	WINDOWP (INT,U,V,X,Y)   UPDATE A WINDOW:
00700		CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
00800		    	U = WIDTH OF WINDOW IN DATA UNITS
00900			V = HEIGHT OF WINDOW IN DATA UNITS
01000			X = X COORDINATE OF LOWER LEFT HAND CORNER OF 
01100			     WINDOW
01200			Y = Y COORDINATE OF LOWER LEFT HAND CORNER OF
01300			      WINDOW
01400		EFFECT:	UPDATE WINDOW PARAMETERS IN THE A-NODE, AND
01500			REGENERATE THE DISPLAY FOR ALL CURVES IN THAT WINDOW.
01600	
01700	
01800	IMAGE (INT,U,V,X,Y)	UPDATE VIEWPORT PARAMETERS:
01900		CALL:	INT = INDEX OF WINDOW IN SYMTAB
02000			U = WIDTH OF WINDOW IMAGE IN INCHES
02100			V = HEIGHT OF WINDOW IMAGE IN INCHES
02200			X = X COORDINATE OF  LOWER LEFT CORNER OF IMAGE
02300			Y = Y COORDINATE OF LOWER LEFT CORNER OF IMAGE
02400		EFFECT:	VIEWPORT PARAMETERS ARE UPDATED.  ALL CURVES IN THE
02500			WINDOW ARE REGENERATED.
02600	
02700	
02800	
02900	IF, FOR EITHER SIMPLE PROCEDURE, THERE IS NO EXISTING WINDOW, A NEW ONE
03000	IS CREATED WITH DEFAULT VALUES:
03100			IMAGE:  ENTIRE SCREEN.
03200			WINDOW:	10 BY 10 AT 0,0
03300	
03400	IF THE NEW VALUES (PARAMETERS U,V,X,Y) ARE EQUAL TO 'DEFAULT', THE
03500	OLD VALUES IN THOSE POSITIONS ARE RETAINED.
03600	
03700	
03800	
03900	***************************************************************************************************
04000	;
04100	
04200	INTEGER SIMPLE PROCEDURE DEFWIND (INTEGER I);
04300	BEGIN INTEGER K;
04400		PRELOAD!WITH 0,10,0,10,0,1,0,1;
04500		OWN SAFE REAL ARRAY DEFWIN[1:8];
04600		K_IDX[I];				"GET A-NODE POINTER"
04700		IF TYPE[I] = UNKNOWN THEN BEGIN "NO PREVIOUS WINDOW"
04800			TYPE[I] _ WINDOW;
04900			VALUE[I]_0;			"IN CASE NEWNODE HAS NONE TO GIVE"
05000			NEWNODE(K,A);
05100			ARRBLT(A[K],DEFWIN[1],8);	"FILL WITH DEFAULTS"
05200			IDX[I]_K;
05300			VALUE[I]_I;
05400		END ELSE IF TYPE[I] NEQ WINDOW THEN TYPEFORMERROR(I);
05500		RETURN (K);  				"A-NODE INDEX"
05600	END;
05700	
05800	
05900	
06000	INTERNAL SIMPLE PROCEDURE WINDOWP (INTEGER I; REAL U,V,X,Y);
06100	BEGIN
06200	INTEGER K,J; 
06300		K_DEFWIND (I);				"CHECK TO SEE IF WINDOW, CREATE DEFAULT ONE"
06400		IF X = DEFAULT THEN 
06500		BEGIN
06600		   X_REL(A[K+WSTW1]);
06700		   Y_REL(A[K+WSTW3]);
06800		END;
06900		IF U = DEFAULT THEN
07000		BEGIN
07100		   U_REL(A[K+WSTW2])-REL(A[K+WSTW1]);
07200		   V_REL(A[K+WSTW4])-REL(A[K+WSTW3]);
07300		END;
07400		A[K+WSTW1]_INT(X);
07500		A[K+WSTW2]_INT(X+U);
07600		A[K+WSTW3]_INT(Y);
07700		A[K+WSTW4]_INT(Y+V);
07800		CURGEN(I);
07900	END;
08000	
08100	
08200	
08300	INTERNAL SIMPLE PROCEDURE IMAGE (INTEGER I;REAL U,V,X,Y);
08400	BEGIN
08500	INTEGER K,J;REAL Q;
08600		K_DEFWIND (I);				"LOOK UP WINDOW, CREATE DEFAULT"
08700		IF NOT DISINIT THEN GINIT(CURRENTDIS);		"TO GET DISINFO FILLED UP"
08800		IF X = DEFAULT THEN BEGIN
08900		   X_REL(A[K+WSTP1]);
09000		   Y_REL(A[K+WSTP3]);
09100		END ELSE BEGIN
09200		   X_X/INCHESPERVIEWPORT;
09300		   Y_Y/INCHESPERVIEWPORT;
09400		END;
09500		IF U = DEFAULT THEN BEGIN
09600		   U_(REL(A[K+WSTP2])-REL(A[K+WSTP1]));
09700		   V_(REL(A[K+WSTP4])-REL(A[K+WSTP3]));
09800		END ELSE BEGIN
09900		   U_U/INCHESPERVIEWPORT;
10000		   V_V/INCHESPERVIEWPORT;
10100		END;
10200		IF X<0 OR U<0 OR X+U>MAXVIEWX+.00001 OR Y<0 OR V<0 OR Y+V>MAXVIEWY+.00001 THEN 
10300			ERROR("ILLEGAL IMAGE BOUNDS");
10400		A[K+WSTP1]_INT(X);
10500		A[K+WSTP3]_INT(Y);
10600		A[K+WSTP2]_INT(X+U);
10700		A[K+WSTP4]_INT(Y+V);
10800		CURGEN(I);
10900	END;
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		SIMPLE PROCEDURES FOR INSCRIBING AND UNSCRIBING CURVES.
00500	
00600	INSCRIBE (INT)	MARK A CURVE OR CURVES AS INSCRIBED:
00700		CALL:	'INT' IS INDEX OF CURVE OR WINDOW IN SYMTAB.
00800		EFFECT:	IF 'INT' POINTS TO A CURVE, INSCRIBE THAT CURVE,
00900			OTHERWISE, IF 'INT' IS A WINDOW, INSCRIBE ALL THE
01000			CURVES IN THAT WINDOW.
01100	
01200			THE DISPLAY IS NOT REGENERATED.
01300	
01400	UNSCRIBE (INT)	REMOVE A CURVE OR CURVES FROM INSCRIBED STATUS:
01500		CALL:	'INT' IS INDEX OF CURVE OR WINDOW IN SYMTAB.
01600		EFFECT:	IF 'INT' IS A CURVE, MERELY TURNS OFF 'INSW' BIT IN CURVE DESCRIPTION
01700			IF 'INT' IS A WINDOW, BIT IS TURNED OFF FOR ALL CURVES IN
01800				THE WINDOW
01900			ANY AFFECTED CURVES ARE REGENERATED
02000	
02100	***************************************************************************************************
02200	;
02300	
02400	INTERNAL SIMPLE PROCEDURE INSCRIBE(INTEGER I);
02500	BEGIN
02600	SIMPLE PROCEDURE INSCRIBE1 (REFERENCE INTEGER I);
02700	BEGIN INTEGER J;
02800		J_IDX[I];				"GET A-NODE POINTER"
02900		A[J]_A[J] LOR INSW;			"TURN ON THE INSCRIBED BIT"
03000	END;
03100	IF TYPE[I] NEQ WINDOW AND TYPE[I] NEQ CURVE THEN TYPEFORMERROR(I);
03200		MAPC (I,INSCRIBE1);			"DO FOR APPROPRIATE CURVES"
03300	END;
03400	
03500	
03600	INTERNAL SIMPLE PROCEDURE UNSCRIBE (INTEGER W);
03700	BEGIN INTEGER WE;
03800	SIMPLE PROCEDURE UNSCRIBE1 (REFERENCE INTEGER I);
03900	BEGIN INTEGER K;
04000		K_IDX[I];
04100		A[K]_A[K] LAND INSWI;			"TURN OFF INSCRIBED BIT"
04200		ARRBLT(A[CSTW1+K],A[WSTW1+IDX[WE]],4);  "SHOVE IN WINDOW PARMS"
04300		CDRAW(I,WE);				"REDRAW THE CURVE"
04400	END;
04500	IF (WE_TYPE[W]) NEQ WINDOW AND WE NEQ CURVE THEN TYPEFORMERROR(W);
04600		WE_W;
04700		WHILE TYPE[WE] NEQ WINDOW DO WE_VALUE[WE];  "FIND WINDOW"
04800		MAPC (W,UNSCRIBE1);			"DO FOR ALL APPROPRIATE WINDOWS"
04900	END;
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400			SIMPLE PROCEDURES FOR TYPING OUT INFORMATION ABOUT WINDOWS AND CURVES
00500	
00600	WINTYP (INT,CHL)	TYPES OUT INFORMATION ABOUT A WINDOW:
00700		CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
00800			'CHL' IS AN I/O CHANNEL NUMBER ON WHICH TO TYPE.
00900		EFFECT:	THE CURVES IN THE WINDOW ARE LISTED,
01000			THE WINDOW AND VIEWPORT PARAMETERS ARE LISTED.
01100	
01200	CURTYP (INT,CHL)	TYPES OUT INFORMATION ABOUT A CURVE:
01300		CALL:	'INT' IS INDEX OF CURVE IN SYMTAB.
01400			'CHL' IS AN I/O CHANNEL NUMBER ON WHICH TO TYPE.
01500		EFFECT:	THE NAME OF THE CURVE IS LISTED.
01600			IF THERE IS A CURVE MATRIX, THE NAME OF THE WINDOW IT IS IN,
01700				THE POINTTYPE, LINETYPE AND INTENSITY ARE LISTED.
01800			IF THERE IS A POINT LABEL MATRIX, THE POINT LABEL PARAMETERS ARE LISTED.
01900			IF THERE IS A STRING, ITS CHARACTERS, POSITION, AND SIZE ARE LISTED.
02000	
02100	***************************************************************************************************
02200	;
02300	
02400	
02500	INTERNAL SIMPLE PROCEDURE WINTYP(INTEGER I,CHANNEL);
02600	BEGIN
02700	INTEGER K;
02800	REAL W,L,X,Y;
02900		K_VALUE[I];
03000		OUT(CHANNEL,NAME[I]&CRLF&"CURVES: ");
03100		WHILE K NEQ I DO 
03200		BEGIN
03300		   OUT(CHANNEL,NAME[K]&" ");
03400		   K_VALUE[K];
03500		END;
03600		OUT(CHANNEL,CRLF);
03700	
03800		K_IDX[I];
03900		X_REL(A[K+WSTW1]);
04000		Y_REL(A[K+WSTW3]);
04100		W_REL(A[K+WSTW2])-X;
04200		L_REL(A[K+WSTW4])-Y;
04300		OUTCR(CHANNEL,FANCYNUM(W)&" BY "&FANCYNUM(L)&" AT "&FANCYNUM(X)&
04400		","&FANCYNUM(Y));
04500	
04600		X_REL(A[K+WSTP1])*INCHESPERVIEWPORT;
04700		Y_REL(A[K+WSTP3])*INCHESPERVIEWPORT;
04800		W_REL(A[K+WSTP2])*INCHESPERVIEWPORT-X;
04900		L_REL(A[K+WSTP4])*INCHESPERVIEWPORT-Y;
05000	
05100		OUTCR(CHANNEL," IMAGE "&NAME[I]&CRLF&" "&FANCYNUM(W)&" BY "&
05200		FANCYNUM(L)&" AT "&FANCYNUM(X)&","&FANCYNUM(Y));
05300	END;
05400	
05500	
05600	
05700	INTERNAL SIMPLE PROCEDURE CURTYP(INTEGER I,CHANNEL);
05800	BEGIN
05900	STRING S;
06000	INTEGER K,L,M,AK;
06100	
06200		K_IDX[I]; AK_A[K];  			"FLAG WORD"
06300		S_NAME[I];
06400		L_VALUE[I];
06500		WHILE TYPE[L] NEQ WINDOW DO L_VALUE[L];
06600	
06700		IF LOW(A[K+CM]) THEN BEGIN "TELL ALL ABOUT CURVE"
06800			M_HI(A[K+CINT]);
06900			S_S&" IN "&NAME[L]&
07000			    ", LINETYPE "&FANCYNUM((AK LAND LTYPEM) LSH -12)&
07100			    ", POINTTYPE "&
07200			    (IF M LEQ 7 THEN FANCYNUM(M) ELSE M)&
07300			    ", INTENSITY "&FANCYNUM(LOW(A[K+CINT]));
07400		IF HI(A[K+CM]) THEN BEGIN "TELL ALL ABOUT POINT LABELS"
07500			S_S&(IF AK LAND XFLTSW THEN " XFLOATING"
07600			     ELSE IF AK LAND YFLTSW THEN " YFLOATING" ELSE NULL)&
07700			    " LABEL AT "&FANCYNUM(REL(A[K+CPTLX]))&","&
07800			    FANCYNUM(REL(A[K+CPTLY]))&" SIZE "&
07900			   FANCYNUM((AK LSH -24) LAND STRM);
08000		END "TELL ALL ABOUT POINT LABELS"
08100		END "TELL ALL ABOUT CURVE";
08200		OUTCR(CHANNEL,S);
08300	
08400		IF A[K+CSTR] THEN BEGIN "THERE IS A STRING IN THIS CURVE"
08500			S_"STRING "&NAME[I]&" '"&ST[A[K+CSTR]]&"', IN "&
08600			   NAME[L]&", SIZE "&FANCYNUM((AK LAND STRM))&
08700			   ", AT "&FANCYNUM(REL(A[K+CSTRX]))&","&
08800			   FANCYNUM(REL(A[K+CSTRY]));
08900			OUTCR(CHANNEL,S);
09000		END "THERE IS A STRING IN THIS CURVE";
09100	
09200		IF AK LAND INSW THEN OUTCR(CHANNEL,"[INSCRIBED]");
09300		IF AK LAND BLANKSW THEN OUTCR(CHANNEL,"[BLANKED]");
09400	END;
     
00100	COMMENT
00200	***************************************************************************************************
00300	
00400		SIMPLE PROCEDURES FOR SAVING AND USING WINDOWS.
00500	
00600	WINSAV (INT)	SAVES A BINARY COPY OF INFORMATION ABOUT A WINDOW:
00700		CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
00800		EFFECT:	BINARY GOODIES ARE SAVED ON I/O CHANNEL 1.
00900			THE A-NODE FOR THE WINDOW IS SAVED,  AND FOR EACH CURVE IN THE WINDOW:
01000				THE NAME OF THE CURVE.
01100				THE A-NODE FOR THE CURVE.
01200				THE CURVE MATRIX.
01300				THE POINT-LABEL MATRIX.
01400				THE STRING.
01500			THE LIST OF CURVES IS TERMINATED WITH A 0.
01600	
01700			A COLLECTION OF SUBROUTINES IS USED:
01800				MATOUT	-- DUMPS BINARY FORM OF A MATRIX.
01900				SAVSTR  -- DUMPS BINARY FORM OF A STRING.
02000	
02100	WINUSE (INT)	RETRIEVES A BINARY COPY OF INFORMATION ABOUT A WINDOW:
02200		CALL:	'INT' IS INDEX OF WINDOW IN SYMTAB.
02300		EFFECT:	READS GOODIES FROM I/O CHANNEL 1.
02400			AN A-NODE FOR THE NEW WINDOW IS CREATED.
02500			FOR EACH CURVE STORED ON THE BINARY FILE,
02600				THE NAME IS ENTERED IN THE SYMBOL TABLE.
02700					(NOTE: NAME MAY HAVE TO BE CHANGED TO AVOID CONFLICT)
02800				AN A-NODE IS CREATED FOR THE CURVE INFO.
02900				THE CURVE AND POINT-LABEL MATRICES ARE RETRIEVED.
03000				THE STRING IS ENTERED IN THE ST ARRAY.
03100	
03200			A COLLECTION OF SUBROUTINES IS USED:
03300				MATIN   -- RETRIEVES A MATRIX FROM A FILE, AND
03400					   CREATES AN APPROPRIATE LEAP ITEM.
03500				USESTR  -- READS A BINARY REPRESENTATION OF A STRING.
03600	
03700	
03800	***************************************************************************************************
03900	;
04000	
04100	
04200	INTERNAL SIMPLE PROCEDURE WINSAV(INTEGER I);
04300	BEGIN
04400	INTEGER K,L,CA,M;
04500	
04600		K_IDX[I];
04700		ARRYOUT(1,A[K],WTLEN);   		"WRITE OUT THE WINDOW STUFF"
04800		K_VALUE[I];
04900		WHILE K NEQ I DO BEGIN
05000			CA_IDX[K];
05100			SAVSTR(NAME[K]);  		"THE NAME OF THE CURVE"
05200			ARRYOUT(1,A[CA],CTLEN);  	"THE DESCRIPTOR OF THE CURVE"
05300			MATOUT(HI(A[CA+CM]));		"THE POINT LABEL MATRIX"
05400			MATOUT(LOW(A[CA+CM]));		"THE CURVE MATRIX"
05500			L_A[CA+CSTR];
05600			SAVSTR(IF L=0 THEN NULL ELSE ST[L]);   "THE STRING, IF ANY"
05700			K_VALUE[K];			"NEXT CURVE"
05800		END;
05900		WORDOUT(1,0);				"TERMINATE LIST"
06000	END;
06100	
06200	
06300	INTERNAL SIMPLE PROCEDURE WINUSE(INTEGER I);
06400	BEGIN
06500	INTEGER K,L,PC,N;
06600	STRING S;
06700	
06800		NEWNODE(K,A);				"GET A NODE FOR THE WINDOW"
06900		ARRYIN(1,A[K],WTLEN);			"AND STUFF WITH  WINDOW INFO"
07000		IDX[I]_K;
07100		TYPE[I]_WINDOW;
07200		VALUE[I]_I;
07300		PC_I;
07400		WHILE TRUE DO BEGIN "GET ALL CURVES"
07500			S_USESTR;			"GET CURVE NAME"
07600			IF LENGTH(S) = 0 THEN DONE;
07700			DO BEGIN
07800				N_SYMTABENTRY(S);	"TRY TO MAKE A TABLE ENTRY"
07900				S_S&"A";		"PREPARE TO TRY ANOTHER NAME"
08000			END UNTIL TYPE[N] = UNKNOWN;
08100			VALUE[N]_I;
08200			NEWNODE(K,A);			"GET A-NODE FOR THE CURVE"
08300			IDX[N]_K;
08400			ARRYIN(1,A[K],CTLEN);		"AND READ IN CURVE STUFF"
08500			LOADHI(A[K+CM],MATIN);		"READ MATRICES FOR ... PT LABEL MATRIX"
08600			LOADLOW(A[K+CM],MATIN);		".. CURVE MATRIX"
08700			LOADHI(A[K+CP2],0);		"NO PICTURE IDS"
08800			A[K+CSP]_0;
08900			S_USESTR;			"GET CURVE STRING, IF ANY"
09000			IF LENGTH(S) = 0 THEN L_0 ELSE STUFFST(L,S);
09100			A[K+CSTR]_L;
09200			VALUE[PC]_N;
09300			PC_N;
09400			TYPE[N]_CURVE;
09500		END "GET ALL CURVES";
09600		CURGEN (I);				"REGENERATE PICTURE"
09700	END;
09800	
09900	
10000	END "GRAPH"
