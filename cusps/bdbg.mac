;<SOURCES>BDBG.MAC;4    15-OCT-74 15:30:50    EDIT BY LIEB
;[EDIT] CHANGE  REGISTER REFS TO MAKE SENSE --LIEB
TITLE BDBG -- BASIC DEBUGGER
SUBTTL ASSEMBLY CONTROL
;
SEARCH BGBL,BRSYMS,STENEX
;
;
;
EXTERNAL TSET.,SETTY.,LNSTR.,STOP.,PSTR.,PEOL.,PNUM.
EXTERNAL DLOC.,BLOC.,OTCHR.,CNTOF.,INTST.
EXTERNAL INSET.,INDON.,STTIM.,RGSV.,BYPWD.,SALOC.,STCPY.
;
;
;
ENTER DBGR.,DBST.,DBBK.,DBSB.,DBSX.,DBLX.,DBER.,DBSTP.,DBSTR.
;
;
SUBTTL SYMBOL DEFINITIONS--TRACE TABLE
;
;   TRACE TABLE IS DEFINED TO CONTAIN THOSE VARIABLES THAT
;      ARE CURRENTLY BEING TRACED.  IT CONTAINS ENOUGH INFO
;      TO DETERMINE IF THE VARIABLE CHANGED AND TO PRINT
;      OUT ITS NAME AND NEW VALUE IF SO.
;
;
TRCID==  0 ;WORD 0--BITS 0-11--ID NUMBER (LEVEL)
TRCBTS== 0 ;WORD 0--BITS 12---BITS
  TRCSTR== 40 ;IF ON, THEN STRING
TRCADD== 0 ;WORD 0--BITS 13--35--ADDRESS
;
TRCVAL== 1 ;WORD 1--OLD VALUE
TRCNAM== 2 ;WORD 2--ASCIZ NAME
TRCDMS== 3 ;WORD 3--DIMS IF MAT (-1,N) OR (N,M)
;
;
TRCLN== 4 ;LENGTH OF ENTRY IN TABLE
;
;
;
MXNTV== 50 ;MAX NUMBER OF ENTRYS IN TABLE
;
;
SUBTTL ENTRY ROUTINES--DBGR.
;
;   DBGR.--THIS IS THE MAIN ENTRY.  IT IS CALLED FROM EACH
;      LINE OF OBJECT CODE THAT DOES NOT CONTAIN A BREAKPOINT.
;      IT DETERMINES IF WE SHOULD SENTER THE DEBUGGER NOW OR SHOULD
;      JUST CONTINUE EXECUTING.
;
;
DBGR.: Z
;
  SKIPE TRCFG	;CHECK IF TRACING
  PUSHJ P,TRCCHK	;HANDLE IF SO
  MOVEM T,LSTENT	;SAVE T FOR ERROR RECOVERY
  HLL L,0(T)	;GET LINE NUMBER OF NEW LINE
  AOSE SKPCT.	;CHECK IF SKIP TERMINATING
    JRA T,1(T)	;NO--EXECUTE THIS LINE
  SKIPN FSTFLG	;YES--CHECK IF FIRST LINE
    JRST DENTRA	;NO--SKIP ENTRY
  MOVEM T,DBGDT.(V)	;YES--SAVE PTR TO IT
  MOVE R1,SSKPCT	;GET SAVED SKIP COUNT
  MOVEM R1,SKPCT.	;SAVE AGAIN
  MOVE R1,FSTFLG	;CHECK FLAG
  SETZM FSTFLG	;NEXT TIME WON'T BE FIRST
  SKIPL R1		;CHECK FOR INITIAL/SUB ENTRY
    JRST DENTRD		;NO--DO ENTRY
  TRNE R1,400000	;DIFFERENTIATE BETWEEN SUB/INITIAL
    JRST DENTRI		;INITIAL
  TRNN R1,-1		;SUB--CHECK IF BOC
    JRA T,1(T)	;NO--RETURN
    JRST DENTRS		;YES--ENTER
;
;
SUBTTL ENTRY ROUTINES--DBBK.
;
;   DBBK.--THIS ROUTINE IS ENTERED ON A LINE CONTAINING A
;      BREAKPOINT.  IT CAUSES A DEBUGGER ENTRY TO OCCUR.
;
;
DBBK.: Z
;
  SKIPE TRCFG	;CHECK IF TRACING
    PUSHJ P,TRCCHK ;HANDLE IF SO
  MOVEM T,LSTENT	;SAVE T FOR ERROR RECOVERY
  SETZM FSTFLG		;CLERA FLAGS
  SETZM SKPCT.		;DEALING WITH ENTRY
  HLL L,0(T)	;FIRST GET LINE NUMBER
  JRST DENTRB	;THEN ENTER DEBUGGER
;
;
SUBTTL ENTRY ROUTINES--DBST.
;
;   DBST.--THIS ROUTINE IS CALLED AT THE START OF THE PROGRAM
;      BEFORE THE FIRST LINE IS EXECUTED.  IT SETS UP TO ENTER
;      THE DEBUGGER ON THE FIRST LINE.
;
;
DBST.: Z
;
  SETZM DBGXFG		;NOT EXECUTING LINE
  SETZM BOCFG		;RESET BOC FLAG
  SETOM FSTFLG	;MARK AS FIRST TIME
  SETOM SKPCT.	;FORCE HALT AT NEXT LINE
  SETZM SSKPCT		;NO SSAVED SKIP COUNT
  PUSHJ P,UTRALL	;GET RID OF TRACES
  MOVE R1,[XWD DBER.,DBSTP.]	;ENTRYS FOR RTP TO USE
  MOVEM R1,DBGENT	;SAVE IN GLOBAL AREA
;
  SETZM CURSYM		;NO SYMBOL TABLE
  MOVNI R1,1		;GET RID OF ANY SYMBOL TABLE THAT DOES EXIST
  HRLI R2,400000	;CURRENT FORK
  HRRI R2,SYMPGN	;PROPER PAGE
  PMAP			;GOODBYE PAGE
  HLRZ R1,SYMJFN	;OLD SYMBOL TABLE JFN
  SKIPE R1		;CHECK IF ANY GOOD
  CLOSF			;IF IT MAY BE, CLOSE IT
    TRN			;WHO CARES IF WE FAIL
  SETZM SYMJFN		;CLEAR JFN SO WE REOPEN
  JRA T,0(T)	;JURST RETRN FOR NOW--GET ALL SET UP
;
;
SUBTTL ENTRY ROUTINES--DBSB.
;
;   DBSB.--THIS ROTUINE IS CALLED AT THE START OF A SUBPROGRAM.
;      IT MUST SET FLAGS TO TELL THE DEBUGGER ABOUT THE SUB
;      PROGRAM.
;
;
DBSB.: Z
;
  MOVE R1,BOCFG	;CHECK FOR BREAK ON CALL
  HLROM R1,FSTFLG	;SAVE FLAG
  MOVE R1,SKPCT.	;GET SKIP COUNT
  MOVEM R1,SSKPCT	;SAVE
  SETOM SKPCT.	;FORCE SEMI-DEBUGGER ENTRY AT LEAST
  AOS IDNUM	;BUMP LEVEL COUNTER
  JRA T,0(T)	;AND RETURN
;
;
SUBTTL ENTRY ROUTINES--DBER.
;
;   DBER.--THIS ROUTINE IS ENTERED FROM THE RUN TIME PACKAGE WHEN
;      AN ERROR MESSAGE IS PRINTED THAT WOULD NORMALLY BE FATAL.
;      IT GOES BACK TO THE LAST LINE AND HALTS THERE.
;
;
DBER.:
;
  MOVE T,LSTENT		;GET LAST ENTRY T
  HLL L,0(T)		;GET LINE NUMBER
  SETZM SKPCT.		;CLERA ENTRY FLAGS
  SETZM FSTFLG
  JRST DENTRA		;AND ENTER
;
;
SUBTTL ENTRY ROUTINES--DBSTP.
;
;   DBSTP.--THIS ROUTINE IS ENTERED FROM BRTP WHEN A STOP
;      IS EXECUTED.  IT PRIMARY PURPOSE IS TO CLEAN UP THE
;      MESS CAUSED BY THE DEBUGGER--IE DEFS IN THE SYMBOL
;      TABLE.
;
;
DBSTP.: Z
;
  MOVEM R2,DBGRGS+2	;SAVE R2
  MOVEM R3,DBGRGS+3	;R3
  MOVEM R4,DBGRGS+4	;R4
  MOVEI R4,SUBTBL	;GET PTR TO SUB TABLE
;
 DBSTP1:
  SKIPN R1,SUBBTS(R4)	;DONE IN SUB TABLE?
    JRST DBSTP3		;YES--EXIT
  TLZN R1,SBBDFB	;CHECK IF THIS SUB USES DEF
    JRST DBSTP2		;NO--SKIP
  MOVEM R1,SUBBTS(R4)	;SAVE NEW BITS
  MOVE R1,R4		;GET PTR TO SUB
  PUSHJ P,GTSSYM	;GET SYMBOL TABLE
  PUSHJ P,CLRDEF	;GET RID OF DEF
;
 DBSTP2:
  ADDI R4,SUBBLN	;NEXT ENTRY
  JRST DBSTP1		;AND LOOP
;
 DBSTP3:
  SETZM CURSYM		;NO SYMBOL TABLE PAGE
  HRLI R2,400000	;CURRENT FORK
  HRRI R2,SYMPGN	;SYMTAB PAGE
  MOVNI R1,1		;SHOULD BE DELETED
  PMAP
  HLRZI R1,SYMJFN	;SO WE CAN CLOSE THE FILE
  SKIPE R1		;FROM WHENCE IT CAME
  CLOSF			;IF IT WAS OPEN
    TRN			;AND MAYBE EVEN IF NOT
  SETZM SYMJFN		;INDICATE CLOSED
;
  MOVE R4,DBGRGS+4	;RESTORE REGWS
  MOVE R3,DBGRGS+3
  MOVE R2,DBGRGS+2
;
  JRA T,0(T)		;RETURN TO STOP
;
;
SUBTTL ENTRY ROUTINES--DBRET
;
;   DBRET--THIS IS THE ROUTINE ENTERED WHEN A RETURN IS EXECUTED
;      FROM A DEBUGGER TYPE 'GOSUB'.  IT REENTERS THE DEBUGGER
;      AND PRINTS NO MESSAGE.
;
;
DBRET:
;
  POP P,T		;GET OLD T OFF STACK
  SETOM SKPCT.		;FORCE A HALT
  JRST DBGR.+1		;FAKE NORMAL ENTRY
;
;
SUBTTL ENTRY ROUTINES--DBSX.
;
;   DBSX.--THIS ROUTINE IS CALLED AFTER A SUB RETURNS.  ITS JOB
;      IS TO CLEAN UP WHAT IS LEFT FROM THE OLD SUB AND TO
;      RESTORE FOR THE NEW CURRENT ONE.
;
;
DBSX.: Z
;
  HRRZ R1,TRCFG	;CHECK IF TRACING
  JUMPE R1,DBSX5	;NO--SKIP
  PUSH P,R2	;YES--SAVE R2
  MOVEI R2,TRCTBL	;GET PTR TO TRACES
;
 DBSX3:
  SKIPN TRCADD(R2)	;CHECK IF TRACE ENTRY EXISTS
    JRST DBSX2		;IF NOT, JUMP
  LDB R0,[POINT 12,TRCID(R2),11]	;IF SO, GET ID NO OF IT
  CAML R0,IDNUM	;CHECK VERSUS CURRENT
    PUSHJ P,DOUTRC	;GET RID OF OLD ITEM
;
 DBSX4:
  SOJLE R1,DBSX1	;IF DONE IN TABLE, SKIP
;
 DBSX2:
  ADDI R2,TRCLN		;ELSE LOOK AT NEXT ENTRY
  JRST DBSX3
;
;
 DBSX1:
  POP P,R2		;RESTORE OLD R2
;
 DBSX5:
  SOS IDNUM		;DECREMENT ID NUMBER
  JRA T,0(T)		;AND RETURN
;
;
SUBTTL ENTRY ROUTINES--DBSTR.
;
;   DBSTR.--THIS ROUTINE IS CALLED FROM COMPILED CODE FOR ONE
;      LINERS (EXECUTABLE DEBUGGER COMMANDS) WHICH USE A CONSTAT
;      STRING.  THIS CODE ALLOCATES A STRING BLOCK AND COPYS
;      THE STRING INTO IT, RETURNING A PTR TO THE NEW STRING IN
;      R1.  THIS IS NEEDED AS THE CONSTANT STRING WOULD OTHERWISE
;      QUICKLY DISAPPEAR.
;
;
DBSTR.: Z
;
  SKIPN R1,@0(T)	;GET STRING TO COPY, CHECK FOR NULL
    JRA T,0(T)	;NULL--DONE ALREADY
;
  MOVEM R2,RGSV.	;SAVE R2
  MOVEM R3,RGSV.+1	;AND R3
  MOVEI R0,5		;BYTES PER WORD
  MOVEM R0,BYPWD.	;SAVE
  HLRZ R0,-1(R1)	;CHR COUNT
  JSA T,SALOC.		;ALLOCATE THIS STRING
  MOVE R2,@0(T)		;RESTORE STRING TALLY
  MOVEM R1,RGSV.+2	;SAVE NEW TALLY
  JSA T,STCPY.		;COPY OVER THE STRING
  MOVE R1,RGSV.+2	;RESTORE NEW TALLY TO R1
  MOVE R2,RGSV.		;RESTORE R2
  MOVE R3,RGSV.+1	;AND R3
  JRA T,1(T)		;THEN DONE
;
;
SUBTTL ENTRY ROUTINES--DENTR--ACTUAL ENTRY
;
;   DENTR--THIS ROUTINE ACTUALLY ENTERS THE DEBUGGER FROM THE OBJECT
;      CODE.  IT SAVES THE REGISTERS AND RETURN, SETS UP A NEW PDL,
;      ETC. FOR THE DEBUGGER, PRINTS THE ENTRY MESSAGE, AND GOES
;      TO THE COMMAND SCAN.
;
;
DENTRA:
  ERR E.DENA		;STEP ENTRY
  JRST DENTR
;
 E.DENA: ER WRN,ENTRY
;
;
DENTRB:
  ERR E.DENB		;BREAK ENTRY
  JRST DENTR
;
 E.DENB: ER WRN,BREAK
;
;
DENTRI:
  SUBI T,2		;REEXECUTE LINE ENTRY
  ERR E.DENI		;START UP ENTRY
  JRST DENTR
;
 E.DENI: ER <CRB,CRA,RET,MES>,DEBUGGER HERE
;
;
DENTRS:
  ERR E.DENS		;BREAK ON CALL ENTRY
  JRST DENTR
;
 E.DENS: ER WRN,BREAK ON CALL
;
;
DENTRD:
  MOVE T,DOSVT		;RESTORE T FROM LAST DO
  JRST DENTR	
;
;
;
DENTR:
  SKIPN DBGPDL		;CHECK IF CURRENTLY IN DEBUGGER
    JRST .+3		;NO--SKIP
  HRLZI R17,DBGRGS	;YES--RELOAD PREVIOUS ENTRY REGS
  BLT R17,R17
  MOVEM R17,DBGRGS+R17	;SAVE REGS
  MOVEM P,DBGPDL	;INDICATE IN DEBUGGER
  HRRZI R17,DBGRGS
  BLT R17,DBGRGS+R17-1
  MOVE P,[IOWD 40,PDLBF]	;SET UP NEW PDL
  JSA T,TSET.		;USE TTY
  SETZM F.CPOS(FL)	;BEGINING OF LINE
  JRST CMND		;AND ENTER COMMAND SCAN
;
;
SUBTTL ENTRY ROUTINES--TRACING--TRCCHK
;
;   TRCCHK--THIS ROUTINE CHECKS IF ANY TRACE OUTPUT IS NEEDED
;      AND PRINTS IT IF SO.  IT IS ENTERED WITHOUT FORMALLY
;      ENTERING THE DEBUGGER, SO CARE IS TAKEN WITH REGISTERS,
;      ETC.
;
;
TRCCHK:
  PUSH P,R2		;NOT EMPTY--COUNT IN R1--SAVE R2
  HLLZ R1,TRCFG		;CHECK IF TRACEING LINES
  MOVEM R1,TRLPFG	;SET LINE PRINTED FLAG ACCORDINGLY
  HRRZ R1,TRCFG		;CHECK FOR EMPTY TRACE TABLE
  JUMPE R1,TRCCK1	;EMPTY--SKIP
  MOVEI R2,TRCTBL	;GET TABLE PTR
;
 TRCCK4:
  SKIPN TRCADD(R2)	;DO WE HAVE AN ENTRY
    JRST TRCCK2 	;NO--SKIP
  MOVE R0,@TRCADD(R2)	;GET CURRENT VALUE
  CAME R0,TRCVAL(R2)	;COMPARE TO SAVED VALUE
    PUSHJ P,PRTRC	;HANDLE CHANGED
  SOJLE R1,TRCCK1	;CHECK IF DONE ALL ENTRIES
;
 TRCCK2:
  ADDI R2,TRCLN		;NEXT ENTRY
  JRST TRCCK4		;AND LOOP
;
 TRCCK1:
  HLRZ R2,0(T)		;GET 0(T)INE NUMBER TO TRACE
  HLRZ R1,TRCFG		;CHECK FOR LINE TRACE
  SKIPE R1
    PUSHJ P,PRTRLN	;DO LINE TRACE IF CALLED FOR
  POP P,R2		;RESTORE R2
  POPJ P,		;AND DONE CHECKING TRACE
;
;
SUBTTL ENTRY ROUTINES--TRACING--PRTRC
;
;   PRTRC--THIS ROUTINE PRINTS THE NEW VALUE FOR THE ITEM
;      WHOSE TRACE TABLE PTR IS IN R2 ON ENTRY AND WHOSE
;      VALUE IS IN R0.
;
;
PRTRC:
  PUSH P,R1		;SAVE R1
  SKIPE TRLPFG		;HAVE WE PRINTED LINE YET?
    JRST PRTRC5		;YES--SKIP
  PUSH P,R2		;SAVE R2
  SETOM TRLPFG		;INDICATE PRINTED NOW
  MOVE R2,LSTENT	;GET LOC OF LAST LINE
  HLRZ R2,0(R2)		;GET LINE NUMBER
  PUSHJ P,PRTRLN	;TRACE THE LINE
  POP P,R2		;RESTORE R2
;
 PRTRC5:
  MOVEM R0,TRCVAL(R2)	;SAVE NEW VAUE
  HRROI R1,TRCNAM(R2)	;GET STRING PTR TO NAME
  PSOUT			;PRINT
  MOVE R1,TRCDMS(R2)	;CHECK IF DIMED
  AOJE R1,PRTRC1	;SKIP IF NOT
  MOVEI R1,"("		;IF SO, PRINT SUBSCRIPTS
  PBOUT
  HLRE R1,TRCDMS(R2)	;FIRST DIM
  JUMPL R1,PRTRC2	;IGNORE IF ONLY ONE DIM
  PUSHJ P,PRTRNM	;PRINT DIM
  MOVEI R1,","
  PBOUT
;
 PRTRC2:
  HRRZ R1,TRCDMS(R2)	;SECOND DIM
  PUSHJ P,PRTRNM	;PRINT IT
  MOVEI R1,")"		;END CHR
  PBOUT
;
;
 PRTRC1:
  HRROI R1,[ASCIZ / = /]	;EQUALS SIGN
  PSOUT
  PUSH P,R2		;SAVE R2
  MOVE R1,TRCBTS(R2)	;GET ADDRESS
  TLNE R1,TRCSTR	;CHECK FOR STRING
    JRST PRTRC3		;HANDLE STRING
  MOVEI R1,101		;NUMBER TO TTY:
  MOVE R2,TRCVAL(R2)	;GET NUMBER
  MOVEI R3,0		;FREE FORMAT
  FLOUT			;PRINT NUMBER
    BLOWUP
  JRST PRTRC4		;AND DONE
;
 PRTRC3:
  MOVEI R1,42		;QUOTE CHR
  PBOUT
  SKIPE R1,TRCVAL(R2)	;GET STRING
  PSOUT			;PRINT IT IF NON-NULL
  MOVEI R1,42		;QUOTE CHR
  PBOUT
;
 PRTRC4:
  MOVEI R1,37		;EOL
  PBOUT
  POP P,R2 		;RESTORE R2
  POP P,R1		;RESTORE R1
  POPJ P,		;DONE PRINTING TRACE VAR
;
;
SUBTTL ENTRY ROUTINES--TRACING--PRTRLN
;
;   PRTRLN--THIS ROUTINE HANDLES THE LINE TRACE FEATURE.
;
;
PRTRLN:
;
  MOVEI R1,"*"		;LEAD CHR
  PBOUT
  HRRZ R1,R2		;GET LINE
  PUSHJ P,PRTRNM	;PRINT NUMBER
  MOVEI R1,37		;EOL
  PBOUT
  POPJ P,		;AND DONE
;
;
SUBTTL ENTRY ROUTINES--TRACING--PRTRNM
;
;   PRTRNM--THIS ROUTINE PRINTS THE INTEGER IN R1 ONENTRY,
;      PRESERVING R2 AND R3.  IT IS USED MAINLY BY THE TRACE
;      ROUTINES.
;
;
PRTRNM:
;
  PUSH P,R2 		;SAVE R2
  PUSH P,R3		;SAVE R3
  MOVE R2,R1		;GET NUMBER TO PRINT
  MOVEI R1,101		;TO TTY
  MOVEI R3,12		;DECIMAL FREE FORMAT
  NOUT			;PRINT
    BLOWUP
  POP P,R3		;RESTORE R3,R2
  POP P,R2
  POPJ P,		;AND RETURN
;
;
SUBTTL EXIT ROUTINES--RETRN
;
;   RETRN--THIS ROUTINE IS USED TO RETURN TO THE OBJECT CODE
;     AFTER AN ACTUAL DEBUGGER ENTRY.  IT IS CALLED FROM
;      THE VARIOUS COMMAND ROUTINES THAT GO TO/CONTINUE.
;
;
RETRN:
;
  HRLZI R17,DBGRGS	;RESTORE THE REGISTERS
  BLT R17,R17		;TO WHAT THEY WERE BEFORE
  SETZM DBGPDL		;NO LONGER CONSIDERED IN DEBUGGER
;
  MOVEM T,LSTENT	;SAVE T IN CASE OF GOTO
  JRA T,1(T)		;AND RETURN
;
;
SUBTTL COMMAND ROUTINES--CMND
;
;   CMND--THIS IS THE MAIN LOOP IN THE DEBUGGER, FINDING A
;      COMMAND IN THE USER INPUT, AND BRANCHING TO THE PROPER
;      ROUTIE TO HANDLE IT.
;
;
CMND:
;
  JSA T,TSET.		;USE THE TTY
  SETZM CNTOF.		;ALLOW TTY OUTPUT
  HRRZ R1,F.JFN(FL)	;GET JFN OF TTY
  SKIPN F.CPOS(FL)	;CHECK IF AT START OF LINE
    JRST CMND1		;SKIP IF SO
  JSA T,PEOL.		;FORCE THERE IF NOT
;
 CMND1:
  MOVEI R2,"*"		;FIRST PROMPT CHR
  JSA T,OTCHR.		;PRINT IT
  JSA T,INSET.		;SET UP FOR INPUT
  JSA T,LNSTR.		;LINPUT COMMAND
    JUMP CMDSTR
  JSA T,INDON.		;CLEAN UP AFTER INPUT
;
  MOVE R1,CMDSTR	;GET TALLY TO STRING
  JUMPE R1,CMND	;IGNORE NULL INPUT
  MOVEM R1,CMDTL	;SAVE TALLLY TO COMMAND
  MOVEM R1,NCMDTL	;ONCE FOR RESTART
;
 CMND2:
  MOVE R1,[IOWD NCMDS+1,CMDTB]	;PTR FOR FINDING COMMAND
  PUSHJ P,FNDCMD	;FIND THE COMMAND
  JRST CMDJTB+1(R1)	;BRANCH TO COMMAND ROUTINE (-1==>ILLEGAL)
;
;
SUBTTL COMMAND ROUTINES--CMDEND
;
;   CMDEND--THIS ROUTINE IS ENTERED AFTER A COMMAND IS PROCESSED.
;      IT CHECKS FOR A VALID TERMINATOR AND EITHER GETS A NEW
;      COMMAND LINE, OR PROCESSES THE NEXT COMMAND ON THE
;      CURRENT LINE.
;
;
CMDEND:
;
  LDB R1,CMDTL		;GET TERMINATOR
  JUMPE R1,CMND		;END OF STRING-->NEW LINE
  CAIE R1,33		;CHECK FOR ESCAPE
    JRST ER.IFT		;ONLY OTHER VALID TERMINATOR HERE
  MOVE R1,CMDTL 	;IF SO, GET TALLY
  MOVEM R1,NCMDTL	;SAVE FOR RESCAN
  JRST CMND2		;AND SCA NEXT COMMAND
;
;
SUBTTL COMMAND ROUTINES--FNDCMD
;
;   FNDCMD--THIS ROUTINE IS ENTERED WITH AN IOWD POINTER
;      TO THE COMMAND TABLE.  IT RETURNS THE ENTRY NUMBER OF THAT
;      TABLE THAT THE COMMAND STRING (CMDTL) MATCHES, OR -1 IF
;      NONE ARE MATCHED.  STRINGS MUST BE MATCHED IN FULL.
;
;
FNDCMD:
;
  MOVEI R0,0		;COUNTER TO 0
;
 FNCMD2:
  AOBJP R1,FNCMD1	;CHECK IF DONE YET
  MOVE R2,CMDTL		;GET TALLY TO COMMAND
  MOVE R3,0(R1)		;GET TALLY TO TABLE
;
 FNCMD3:
  ILDB R5,R3		;NEXT CHR FROM TABLE
  JUMPE R5,FNCMD4	;HANDLE DONE--MATCH FOUND
;
 FNCMD5:
  ILDB R4,R2		;NEXT CHR FROM INPUT
;[EDIT] CHANGE  REGISTER REFS TO MAKE SENSE --LIEB
  CAIE R4," "		;CHECK FOR SPACE
  CAIN R4,11		;OR TAB
    JRST FNCMD5		;IGNORE IF EITHER OF THESE
  CAIL R4,140		;CHECK IF LOWER CASE
    SUBI R4,40		;CONVERT TO UPPER
  CAMN R4,R5		;COMPARE RELEVANT CHRS
    JRST FNCMD3		;LOOK FOR MORE ON MATCH
  AOJA R0,FNCMD2	;HANDLE NO MATCH
;
;
 FNCMD1:
  MOVNI R1,1		;FAIL RETURN
  POPJ P,		;RETURN
;
;
 FNCMD4:
  MOVEM R2,CMDTL	;SAVE TALLY WHEN DONE
  MOVE R1,R0		;GET COUNTER
  POPJ P,		;RETURN WITH IT
;
;
SUBTTL COMMAND ROUTINES--COMMAND NAME TABLE
;
;  THESE ENTRYS CONSIST OF POINTERS TO ASCIZ STRINGS OF
;      THE NAMES OF THE COMMANDS.
;
;
  DEFINE CM (NAME)
<
	POINT 7,[ASCIZ /NAME/]
>
;
;
;
CMDTB:
  CM CONTINUE
  CM CON
  CM BREAK
  CM UNBREAK
  CM TRACE
  CM GOTO
  CM GOSUB
  CM STOP
  CM STEP
  CM LET
  CM PRINT
  CM CALL
  CM CHAIN
  CM CHANGE
  CM FILE
  CM INPUT
  CM LINPUT
  CM MARGIN
  CM MAT
  CM RANDOMIZE
  CM READ
  CM RESET
  CM RETURN
  CM SCRATCH
  CM WRITE
  CM FILSTAT
  CM JOBSTAT
  CM DEF
  CM DO
  CM START
  CM COMPILE
  CM EDIT
  CM TBASIC
  CM TB
  CM TECO
  CM SOS
 CM TV
;
;
 NCMDS== .-CMDTB	;NUMBER OF COMMANDS
;
;
SUBTTL COMMAND ROUTINES--COMMAND JUMP TABLE
;
;   THIS TABLE CONTAINS THE JUMP ADDRESSES FOR THE ROUTINES
;      THAT HANDLE THE COMMANDS MENTIONED IN THE NAME TABLE.  THE
;      ORDER OF THESE TWO TABLES MUST CORRESPOND.
;
;
CMDJTB:
  JRST ER.CMD		;ILLEGAL COMMAND (-1)
  JRST C.CON		;CONTINUE
  JRST C.CON		;CON
  JRST C.BRE		;BREAK
  JRST C.UNB		;UNBREAK
  JRST C.TRA		;TRACE
  JRST C.GOT		;GOTO
  JRST C.GOS		;GOSUB
  JRST C.STO		;STOP
  JRST C.STE		;STEP
  JRST CMPCMD		;LET
  JRST CMPCMD		;PRINT
  JRST CMPCMD		;CALL
  JRST CMPCMD		;CHAIN
  JRST CMPCMD		;CHANGE
  JRST CMPCMD		;FILE
  JRST CMPCMD		;INPUT
  JRST CMPCMD		;LINPUT
  JRST CMPCMD		;MARGIN
  JRST CMPCMD		;MAT
  JRST CMPCMD		;RANDOMIZE
  JRST CMPCMD		;READ
  JRST CMPCMD		;RESET
  JRST CMPCMD		;RETURN
  JRST CMPCMD		;SCRATCH
  JRST CMPCMD		;WRITE
  JRST C.FIL		;FILSTAT
  JRST C.JOB		;JOBSTAT
  JRST C.DEF		;DEF
  JRST C.DO		;DO
  JRST C.STA		;START
  JRST C.COM		;COMPILE
  JRST C.EDIT		;EDIT
  JRST C.COM		;TBASIC
  JRST C.COM		;TB
  JRST C.TECO		;TECO
  JRST C.SOS		;SOS
  JRST C.TV		;TV
;
;
SUBTTL COMMAND ROUTINES--COMPILER COMMANDS--CMPCMD
;
;   CMPCMD--THIS ROUTINE IS ENTERED FOR ALL THOSE COMMANDS
;      WHICH ARE HANDLED BY CALLING THE COMPILER TO COMPILE
;      THE ONE LINE AND THE EXECUTING IT.  IT
;      BASICALLY MUST INTERFACE WITH THE COMPILER.
;
;
CMPCMD:
;
  MOVE R1,NCMDTL	;GET ORIGINAL LINE TALLY
  MOVEM R1,CMDTL	;RESCAN LINE
  MOVE R1,[XWD SRCBUF,SRCBUF+1] ;CLEAR SOURCE BUFFER
  SETZM SRCBUF
  BLT R1,SRCBUF+777
  MOVE R2,[POINT 7,SRCBUF]	;GET TALLY TO SOURCE BUFFER
  MOVEM R2,IFLTL	;SAVE TALLY FOR COMPILER
  MOVEI R1,"0"		;DUMMY LINE NUMBER
  IDPB R1,R2		;SAVE
  MOVEI R1," "		;AFTER LINE NUM DELIM
  IDPB R1,R2
  MOVEI R3,2		;GET CHARACTER COUNT
;
 CMPCM2:
  ILDB R1,CMDTL		;GET NEXT CHR
  CAIE R1,33		;CHECK FOR END OF COMMAND
  CAIN R1,0		;AS ESCAPE OR EOL
    JRST CMPCM1		;HANDLE END
  IDPB R1,R2		;SAVE CHR OTHERWISE
  AOS R3		;BUMP CHAR COUNT
  JRST CMPCM2		;AND LOOP
;
 CMPCM1:
  MOVEI R1,37		;EOL CHR
  IDPB R1,R2 		;SAVE ONCE
  IDPB R1,R2		;TWICE FOR SAFETY
  IDPB R1,R2		;THRICE FOR GOOD LUCK
  ADDI R3,3+1		;FINISH CHARACTER COUNT
  MOVEM R3,IFLCNT	;SAVE CHR COUNT
;
  PUSHJ P,GETSYM	;MAKE SURE WE HAVE THE SYMBOL TABLE
  MOVE R1,PGDAT.(V)	;GET PTR TO PROGRAM DATA AREA
  HLRZ R2,PGNVRL(R1)	;GET NUM VAR LENGTH
  MOVEM R2,VADDN	;SAVE FOR STRING OFFSET
  HRRZ R2,PGPBAS(R1)	;GET PROGRAM BASE
  MOVEM R2,PRGBAS	;SAVE IN GLOBAL AREA FOR FCT CALLS
  JRST DOCMEX		;AND ENTER THE COMPILER
;
;
SUBTTL COMMAND ROUTINES--COMPILER COMMANDS--DOCMEX
;
;   DOCMEX--THIS PART OF CMPCMD ENTERS THE COMPILER TO PREPARE
;      THE CODE FOR EXECUTION.  IT MAKES SURE THERE IS A COMPILER
;      AND SETS UP FOR AND ENTERS IT CORRECTLY.
;
;
DOCMEX:
;
  PUSH P,DEBFG		;SAVE THE DEBUG FLAG
  SETZM DEBFG		;CLEAR FOR DUMMY LINE
  SETZM LSTJFN		;NO FILES
  SETZM BINJFN
  SETZM SAVJFN
  MOVEI R2,400000	;SOURCE FILE OF CURRENT FORK
  MOVEM R2,SRCJFN	;SAVE
;
  SKIPN COMENT		;CHECK IF COMPILER PRESENT
    JRST ER.COM		;BETTER BE FOR US
;
 DCMEX1:
  MOVEM R17,DCMRGS+17	;SAVE REGS
  HRRZI R17,DCMRGS
  BLT R17,DCMRGS+16
;
  MOVEI R1,400000	;FOR CURRENT FORK
  DIR			;TURN OFF INTERRUPTS
  MOVE R1,COMENT	;GET COMPILER ENTRY
  MOVEI R2,DCMEXA	;EXIT LOCATION
  MOVEM R2,ONELIN	;SAVE FOR COMPILER EXIT
  JRST 2(R1)		;ENTER COMPILER FOR 1-LINE COMPILATION
;
;
 DCMEXA:
  JRST DCMERR		;ERROR RETURN
  JRST DCMEOK		;SUCCESS RETURN
;
;
 DCMERR:
  JSA T,INTST.		;TURN INTERRUPTS BACK ON FOR RTP
  HRLZI R17,DCMRGS	;RESTORE DEBUGGER REGS
  BLT R17,R17
  POP P,DEBFG		;RESTORE DEBUG FLAG
  JRST ER.CMP		;AND EXIT VIA ERROR ROUTINE
;
;
 DCMEOK:
  JSA T,INTST.		;TURN INTERRUPTS BACK ON FOR RTP
  MOVE P,DCMRGS+P	;GET DEBUGGER STACK
  POP P,DEBFG	;RESTORE DEBUG FLAG
  MOVEM P,DCMRGS+P	;RESTORE DEBUGGER STACK
  HRLZI R17,DBGRGS	;RELOAD ENTRY REGS
  BLT R17,R17
  SETOM DBGXFG		;INDICATE EXECUTING LINE
  SETZM DBGPDL		;AND NOT IN DEBUGGER
  JRST SRCBUF+1		;AND EXECUTE CODE
;
;
 DBLX.:
  MOVEM P,DBGPDL	;SAVE DEBUGGER PDL AGAIN
  MOVE R1,[JRST DBLX.]	;GET EXIT INSTRUCTION
  MOVEM R1,SRCBUF	;SAVE IN SOURCE BUFFER
  MOVE R1,[XWD SRCBUF,SRCBUF+1]
  BLT R1,SRCBUF+777	;SAVE THROUGHOUT SOURCE BUFFER
  HRLZI R17,DCMRGS	;RESTORE INTERNAL REGS
  BLT R17,R17
  SETZM DBGXFG		;INDICATE END OF EXECUTE
  JRST CMDEND		;ENTER HERE WHEN DONE EXECUTING
;
;
SUBTTL COMMAND ROUTINES--BREAK POINTS--C.BRE
;
;   C.BRE--THIS COMMAND HANDLES A BREAK POINT REQUEST.
;      ITS FORMAT IS BREAK <#>,<#>,...
;
;
C.BRE:
;
  PUSHJ P,DOBRK		;CALL COMMON ROUTINE
    XWD 1,%DBBK.	;TO SET BREAKPOINTS
;
;
SUBTTL COMMAND ROUTINES--BREAK POINTS--C.UNB
;
;   C.UNB--THIS COMMAND HANDLES REMOVAL OF BREAKPOINTS.
;      IT MAY BE FOLLOWED BY A LIST OF BREAKPOINTS OR, IF
;      ALONE, CAUSES ALL BREAK POINTS TO BE REMOVED.
;
;
C.UNB:
;
  PUSHJ P,NXICH		;GET NEXT CHR
  CAIE R1,33		;CHECK FOR ESCAPE
  CAIN R1,0		;OR EOL
    JRST UBKALL		;UNBREAK ALL IF SO
  PUSHJ P,BKICH		;ELSE RESCAN CHR
  PUSHJ P,DOBRK		;AND USE COMMON ROUTINE
    XWD 0,%DBGR.		;TO REMOVE BREAKS
;
;
SUBTTL COMMAND ROUTINES--BREAK POINTS--DOBRK
;
;   DOBRK--THIS IS THE ROUTINE USED TO SCAN A LIST OF
;      LINE NUMBERS AND TO SET/UNSET BREAKS (DEPENDING
;      ON WORD AFTER CALL) IN THOSE LINES.
;
;
DOBRK:
;
  PUSHJ P,CMLNM	;SCAN A LINE NUMBER
  JUMPE R3,DOBRK1	;NO NUMBER--CHECK FOR ONCALL
  MOVE R1,R2		;# TO R1
  PUSHJ P,FNDLIN	;FIND LINE IN OBJECT CODE
  MOVE R1,@0(P)		;GET INST TO USE
  HRRM R1,-1(R2)	;SAVE PROPER ENTRY ADDRESS
;
 DOBRK2:
  LDB R1,CMDTL		;CHECK TERM
  CAIN R1,","		;FOR COMMA
    JRST DOBRK		;GET MORE IN LIST IF SO
  CAIN R1,";"		;FOR SEMICOLON
    JRST DOBRK		;MORE IN LIST IF SO
  POP P,R1		;ELSE RESTORE RETURN FROM STACK
  JRST CMDEND		;AND DONE
;
 DOBRK1:
  LDB R1,CMDTL		;CHECK LAST CHR
  CAIE R1,"O"		;FOR 'O'
    JRST ER.IFT		;MUST BE
  MOVE R2,[POINT 7,[ASCIZ /NCALL/]] ;LOOK FOR 'NCALL'
  PUSHJ P,SPELL		;OR ELSE ERROR
  PUSHJ P,NXICH		;GET TERM CHR
  MOVE R1,@0(P)		;GET FLAG WORD FROM CALL
  HLLZM R1,BOCFG	;SET FLAG ACCORDINGLY
  JRST DOBRK2		;AND CHECK TERMINATOR
;
;
SUBTTL COMMAND ROUTINES--BREAK POINTS--UBKALL
;
;   UBKALL--THIS ROUTINE IS ENTERED WHEN UNBREAK IS FOUND
;      ALONE.  IT SHOULD REMOVE ALL THE BREAKPOINTS CURRENTLY
;      IN THE CURRENT PROGRAM
;
;
UBKALL:
;
  PUSHJ P,CKTRM		;MAKE SURE IT IS ALONE
  MOVEI R1,%DBGR.	;NORMAL ENTRY
  HRRZ R2,DBGDT.(V)	;GET STARTING LINE PTR
;
 UBKAL1:
  HRRM R1,-1(R2)	;MAKE SURE NOT BREAK PT ROUTINE ENTRY
  HRRZ R2,0(R2)		;GET NEXT LINE
  JUMPN R2,UBKAL1	;IF MORE, LOOP
  JRST CMDEND		;ELSE DONE
;
;
SUBTTL COMMAND ROUTINES--DEF--C.DEF
;
;   C.DEF--THIS IS THE DEF COMMAND.  THIS COMMAND ALLOWS
;      THE USER TO SPECIFY A FUNCTION NAME AND ARG
;      LIST FOR USE IN COMPILER RELATED (AND TRACE RELATED)
;      COMMANDS.  IT MODIFIES THE SYMBOL TABLE ACCORDING
;       TO THE NAMES GIVEN.
;
;
C.DEF:
;
  SETZM DEFCNT		;NOTHING SCANNED YET
  PUSHJ P,GETSYM	;MAKE SURE WE HAVE PROPER SYMBOL TABLE
  PUSHJ P,NXICH		;GET NEXT CHR
  JUMPE R1,DEF20	;NULL LINE--HANDLE UNDEF
  CAIN R1,33		;NULL LINE
    JRST DEF20
  PUSHJ P,BKICH		;RESCAN CHR
;
  PUSHJ P,CMVAR		;GET FCT NAME
    JRST ER.IFT		;MUST BE THERE
  CAIGE R2,32+414	;MAKE SURE IT IS A FCT
    JRST ER.IFT		;MUST BE
  AOS DEFCNT		;ONE ITEM SCANNED
  HLL R2,R1		;GET STRING BIT
  MOVEM R2,TDFCNT	;SAVE  FCT WORD
  PUSH P,R2		;SAVE R2 ON STACK
  LDB R1,CMDTL		;GET NEXT CHR
  CAIE R1,"("		;CHECK FOR '('
    JRST DEF10		;NO--NO ARGS GIVEN
;
 DEF1:
  PUSHJ P,CMVAR		;GET NEXT ARG
    JRST ER.IFT		;MUST BE THERE
  AOJN R5,ER.IFT	;CANT BE DIMED
  HLL R2,R1		;GET STRING FLAG
  AOS DEFCNT 		;KEEP TRACK OF NUMBER
  PUSH P,R2		;PUT ITEM ON STACJK
  LDB R1,CMDTL		;GET TERMINATOR
  CAIN R1,","		;MORE?
    JRST DEF1		;YES--HANDLE
  CAIE R1,")"		;DONE?
    JRST ER.IFT		;NO--ERROR
  PUSHJ P,NXICH		;YES--GET FINAL TERMINATOR
;
;
 DEF10:
  PUSHJ P,CLRDEF	;DELETE OLD DEF
  MOVE R2,TDFCNT	;GET INITIAL FCT NUM
  MOVEI R1,-32-414(R2)	;GET ACTUAL NUMBER FOR FUNCTION
  HRLI R1,410000	;BITS FOR NUMERIC FUNCTION
  TLNE R2,TRCSTR	;CHECK FOR STRING
    TLC R1,600000	;MARK AS STRING FUNCTION
  MOVEM R1,CURFCT	;SAVE CURRENT FCT NUMBER
;
  MOVE R0,DEFCNT	;NUMBER OF ARGS
  MOVEM R0,TDFCNT	;SAVE
  LSH R0,1		;TIME 2
  ADDI R0,2		;PLUS 2
  JSA T,BLOC.		;ALLOCATE BLOCK FOR OLD VALUES
  MOVEM R1,SYMDBF	;SAVE BLOCK PTR
  HRRZI R0,1(R1)	;GET PDL TO BLOCK
  MOVE R2,DEFCNT	;GET NUMBER OF ARGS
  MOVEM R2,1(R1)	;SAVE IN BLOCK
;
 DEF12:
  SOSGE R2,DEFCNT	;CHECK IF DONE
    JRST DEF11		;HANDLE IF SO
  SOSGE R2		;CHECK IF FUNCTION NAME
    MOVE R2,TDFCNT	;SPECIAL NUMBER (PAST ARGS) IF SO
  POP P,R1		;GET ITEM OFF STACK
  PUSH R0,SYMTAB(R1)	;SAVE OLD SYMTAB VALUE
  PUSH R0,R1		;SAVE ITEM
  TRO R2,VRFCT		;MAKE R2 INTO FCT TYPE ADDRESS
  TLNN R1,TRCSTR	;CHECK IF STRING
    HRRM R2,SYMTAB(R1)	;SAVE NUMERIC
  TLNE R1,TRCSTR	;CHECK IF STRING
    HRLM R2,SYMTAB(R1)	;SAVE STRING
  JRST DEF12		;LOOP UNTIL DONE
;
 DEF11:
  HRRZM R0,@SYMDBF	;SAVE END PDL IN BLOCK
  MOVE R1,PGDAT.(V)	;GET PGDATA PTR
  MOVE R1,PGLNK(R1)	;GET SUB BLOCK PTR
  MOVSI R2,SBBDFB	;GET BIT FOR DEF TABLE
  IORM R2,SUBBTS(R1)	;TURN ON
  JRST CMDEND		;AND DONE
;
;
 DEF20:
  MOVE R1,PGDAT.(V)	;GET PGDATA PTR
  MOVE R1,PGLNK(R1)	;GET SUB BLOCK PTR
  MOVSI R2,SBBDFB	;GET BIT FOR DEF TABLE
  ANDCAM R2,SUBBTS(R1)	;TURN OFF
  PUSHJ P,CLRDEF	;IF NOTHING GIVEN, CLEAR OLD DEF
  JRST CMDEND		;AND EXIT
;
;
SUBTTL COMMAND ROUTINES--DEF--CLRDEF
;
;   CLRDEF--THIS ROUTINE WILL GET RID OF ANY DEF BLOCKS IN THE
;      CURRENT SYMBOL TABLE.
;
;
CLRDEF:
;
  SKIPN CURSYM		;MAKE SURE THERE IS A SYMBOL TABLE
    POPJ P,		;RETURN IF NOT
  SETZM CURFCT		;CLERA THIS FLAG
  SKIPN R2,SYMDBF	;CHECK FOR DEF
    POPJ P,		;NONE--DONE ALREADY
  SKIPN 0(R2)		;CHECK IF NOTHING THERE
    JRST CLRDF1		;HANDLE THAT CASE
;
  HRRO R0,0(R2)		;GET TALLY TO END OF BLOCK
  MOVE R1,1(R2)		;GET NUMBER OF ITEMS
  POP R0,R2		;GET NEXT ITEM
  POP R0,SYMTAB(R2)	;RESTORE ITS VALUE
  SOJG R1,.-2		;AND LOOP UNTIL DONE
;
  MOVE R0,SYMDBF	;GET BLOCK PTR
  JSA T,DLOC.		;DEALLOCATE IT
;
 CLRDF1:
  SETZM SYMDBF		;CLEAR PTR
  POPJ P,		;AND DONE
;
;
SUBTTL COMMAND ROUTINES--COMPILE--C.COM
;
;   C.COM--THIS ROUTINE STARTS THE COMPILER AT THE NORMAL
;      ENTRY FOR COMPILING.  IF THE USER REALLY WANTS TO
;      SPECIFY A PROGRAM NAME, HE CAN CHAIN.
;
;
C.COM:
;
  PUSHJ P,NXICH		;GET TERM CHR
  PUSHJ P,CKTRM		;MAKE SURE THA'S WHAT USER WANTS
  PUSHJ P,GETCOM	;GET THE COMPILER IN CORE
  MOVE R2,COMENT	;GET ENTRY ADDRESS
  HRLI R2,4		;EVEC LENGTH
  MOVEI R1,400000	;CURRENT FORK
  SEVEC			;SET ENTRY VECTOR
  JRST 1(R2)		;AND ENTER THE COMPILER
;
;
SUBTTL COMMAND ROUTINES--EXITING--C.CON
;
;   C.CON--THIS CODE HANDLES THE CONTINUE COMMAND, WHICH
;      RETURNS US TO WHERE WE LEFT OFF.
;
;
C.CON:
;
  PUSHJ P,NXICH		;GET NEXT CHR
  PUSHJ P,CKTRM	;CHECK THE TERMINATOR
  JRST RETRN		;AND RETURN
;
;
SUBTTL COMMAND ROUTINES--EXITING--C.GOT
;
;   C.GOT--THIS CODE HANDLES THE GOTO COMMAND, WHICH
;      RETURNS US TO THE GIVEN LINE.
;
;
C.GOT:
;
  PUSHJ P,CMLNM	;SCAN LINE NUMBER
  PUSHJ P,CKTRM		;THAT BETTER BE ALL ON LINE
  MOVE R1,R2		;GET LINE NUMBER IN R1
  PUSHJ P,FNDLIN	;FIND IN OBJECT
  HRRM R2,DBGRGS+T	;SAVE IT
  JRST RETRN		;AND RETURN
;
;
SUBTTL COMMAND ROUTINES--EXITING--C.GOS
;
;   C.GOS--THIS CODE HANDLES THE GOSUB COMMAND, WHICH
;      DOES A GOSUB TO THE SPECIFIED LINE, RETURNING
;      TO THE DEBUGGER WHEN DONE.
;
;
C.GOS:
;
  MOVE R1,DBGRGS+P	;GET RT PDL
  MOVEI R2,DBRET	;GET RETURN ADDRESS
  PUSH R1,DBGRGS+T	;FIRST SAVE T
  PUSH R1,R2		;THEN RETURN
  MOVEM R1,DBGRGS+P	;SAVE PDL PTR
  JRST C.GOT		;AND TREAT LIKE GOTO
;
;
SUBTTL COMMAND ROUTINES--EXITING--DO
;
;   C.DO--THIS ROUTINE HANDLES THE DO COMMAND.  THIS COMMAND
;      EXECUTES THE SPECIFIED LINE AND THEN RETURNS TO THE
;      DEBUGGER.
;
;
C.DO:
;
  MOVE R1,SKPCT.	;GET SKIP COUNT
  MOVEM R1,SSKPCT	;SAVE FOR RESTORING
  SETOM SKPCT.		;BREAK NEXT TIME
  MOVEI R1,1		;MARK AS DO
  MOVEM R1,FSTFLG
  MOVE R1,DBGRGS+T	;GET CURRENT RETURN
  MOVEM R1,DOSVT	;SAVE FOR US
  JRST C.GOT		;TREAT LIKE GOTO
;
;
SUBTTL COMMAND ROUTINES--EDITING
;
;   EDITS--THIS ROUTINE RUNS THE EDITOR WHOSE STRING NAME
;     IS IN R2 ON ENTRY IN A LOWER FORK, CONTINUEING WHEN
;      SAID EDITOR TERMINATES.  IF A FILENAME IS GIVEN AFTER
;      THE COMMAND, THE FILE IS OPENED AND PASSED TO THE EDITOR
;      VIA THE CCL ENTRY.
;
;
C.SOS:
C.EDIT:
  HRROI R2,[ASCIZ /<SUBSYS>SOS.SAV/] ;ENTRY FOR SOS
  JRST EDITS
;
;
C.TECO:
  HRROI R2,[ASCIZ /<SUBSYS>TECO.SAV/] ;ENTRY FOR TECO
  JRST EDITS
;
;
C.TV:
  HRROI R2,[ASCIZ /<SUBSYS>TV.SAV/] ;ENTRY FOR TV
  JRST EDITS
;
;
;
 EDITS:
  MOVEM R2,RGSV.	;SAVE NAME PTR
  PUSHJ P,NXICH		;GET NEXT CHR
  SETZM EDTJFN		;CLEAR JFN OF FILE
  CAIE R1,0		;CHECK FOR EOL
  CAIN R1,33		;OR END OF COMMAND
    JRST EDIT1		;HANDLE IF SO
;
  MOVE R2,CMDTL	;ELSE GET PTR TO COMMAND
  ADD R2,[XWD 070000,0] ;BACK UP A CHR
  HRLZI R1,1		;OLD OR NEW FILE
  GTJFN			;GET A JFN
    JRST ER.EDT		;ERROR IF CAN'T GET
  MOVEM R2,CMDTL	;SAVE END TALLY
  PUSH P,R1		;SAVE JFN
  MOVE R2,[XWD 070000,200000] ;OPEN PARAMETERS
  OPENF			;OPEN THE FILE
    JRST EDIT2		;HANDLE FAILING OPEN
  HRLI R1,400000	;DON'T RELEASE
  CLOSF			;EDITOR WILL REALLY OPEN IT
    BLOWUP
  POP P,EDTJFN		;POP AND SAVE JFN
;
 EDIT1:
  HRLZI R1,100001	;OLD FILE
  MOVE R2,RGSV.		;NAME OF EDITOR
  GTJFN			;GET THE EDITOR
    BLOWUP		;BETTER WORK
  MOVEM R1,EDTSYS	;SAVE THE JFN
  MOVSI R1,240000	;NEW CLEAN FORK
  MOVEI R2,EDTJFN-R1	;WITH JFN AS REG 1
  CFORK			;CREATE THE FORK
    BLOWUP
  HRLM R1,EDTSYS	;SAVE FORK NUMBER
  MOVE R1,EDTSYS	;GET FORM/FILE
  GET			;GET EDITOR IN OUR FORK
  HLRZ R1,EDTSYS	;GET FORK NUMBER
  MOVEI R2,2		;GUESS CCL ENTRY
  SKIPN EDTJFN		;UNLESS NO FILE GIVEN
    MOVEI R2,0		;THEN NORMAL ENTRY
  SFRKV			;START THE FORK
  HLRZ R1,EDTSYS	;GET THE FORK HANDLE
  WFORK		;AND WAIT FOR IT
;
  HLRZ R1,EDTSYS	;GET FORK HANDLE
  KFORK			;GOODBYE
  HRRZ R1,EDTSYS	;AND THE FILE
  RLJFN			;GOODBYE
    TRN
  SKIPE R1,EDTJFN	;DO WE HAVE A FILE
  RLJFN			;IF SO, GET RID OF IT
    TRN
  PUSHJ P,SETTY.	;RESET TTY AFTER EDITING
  JRST CMDEND		;THEN DONE
;
 EDIT2:
  POP P,R1		;RESTORE JFN
  CLOSF			;AND CLOSE THE FILE
    TRN
  JRST ER.EDT		;THEN FAIL
;
;
SUBTTL COMMAND ROUTINES--STATUS--FILSTAT
;
;   C.FIL--THIS ROUTINE TYPES OUT THE STATUS OF ALL OPEN FILES
;      IN ALL SUBPROGRAMS.
;
;
C.FIL:
;
  PUSHJ P,NXICH		;GET NEXT CHR
  PUSHJ P,CKTRM		;CHECK TERMIATOR
  JSA T,TSET.		;PREPARE TO USE TTY
  JSA T,PEOL.		;NEW LINE
  HRRZ R6,V		;DUMMY V
;
 FILE0:
  MOVE R2,PGDAT.(R6)	;CHECK NAME
  SKIPE PGNAME(R2)
    JRST FILE1
  HRROI R1,[ASCIZ /MAIN:/]
  PSOUT
  JRST FILE2
;
 FILE1:
  HRROI R1,[ASCIZ /Sub: /]
  PSOUT
  HRROI R1,PGNAME(R2)
  PSOUT
;
 FILE2:
  JSA T,PEOL.		;NEW LINE
  JSA T,PEOL.		;WITH SPACE
  HLRZ R5,FILTB.(R6)	;NUMBER OF FILES
  HRRZ R7,FILTB.(R6)	;PTR TO FILES
  JUMPE R5,FILE9	;NO FILES--SKIP
  AOS R7		;START WITH FIRST REAL FILE
;
 FILE4:
  MOVE R4,0(R7)		;GET FILE PTR
  JUMPE R4,FILE8	;NULL--SKIP
  HRROI R1,[ASCIZ /   File#/]
  PSOUT
  MOVEI R1,101		;PRINT NUMBER
  HLRZ R2,0(R7)
  ANDI R2,7777
  MOVEI R3,12		;IN DECIMAL
  NOUT		
    BLOWUP
  HRROI R1,[ASCIZ /: "/]
  PSOUT
;
  MOVEI R1,101		;PRINT FILE NAME
  HRRZ R2,F.JFN(R4)
  CAIN R2,101		;CHECK FOR TTY
    JRST FILE5		;HANDLE SPECIAL IF SO
  MOVEI R3,0
  JFNS
;
 FILE6:
  HRROI R1,[ASCIZ /"   TYP=/]
  PSOUT
  MOVE R2,F.BTS(R4)	;GET AND PRINT FILE TYPE
  HRROI R1,[ASCIZ /?/]
  TLNE R2,FB.ASC
    HRROI R1,[ASCIZ /Terminal/]
  TLNE R2,FB.TTY
    HRROI R1,[ASCIZ /TTY/]
  TLNE R2,FB.RST
    HRROI R1,[ASCIZ /String/]
  TLNE R2,FB.RNM
    HRROI R1,[ASCIZ /Numeric/]
  TLNE R2,FB.EPY
    HRROI R1,[ASCIZ /Empty/]
  PSOUT
;
  JSA T,PEOL.		;NEW LINE
;
 FILE8:
  AOS R7		;NEXT FILE
  SOJG R5,FILE4		;CHECK IF DONE--LOOP IF NOT
;
 FILE9:
  JSA T,PEOL.		;NEW LINE FOR END OF SUB
  HRRZ R6,CALLV.(R6)	;CHECK FOR PREVIOUS SUB
  JUMPN R6,FILE0	;IF SO, LOOP WITH IT
  JRST CMDEND		;ELSE END
;
 FILE5:
  HRROI R1,[ASCIZ /TTY:/]	;NAME FOR TTY
  PSOUT			;PRINT IT
  JRST FILE6		;AND CONTINUE
;
;
SUBTTL COMMAND ROUTINES--STATUS--JOBSTAT
;
;   C.JOB--THIS ROUTINE PRINTS A CONSIE SUMMARY OF THE STATUS
;      OF THE USER'S JOB.
;
;
C.JOB:
;
  PUSHJ P,NXICH		;CHECK NEXT CHR
  PUSHJ P,CKTRM		;FOR TERMINATOR
  JSA T,TSET.		;USE TTY
  JSA T,PEOL.		;NEW LINE
;
  HRROI R1,[ASCIZ /Run time = /]
  PSOUT
  HRRZI R1,400000	;GET AND PRINT RUN TIME
  RUNTM
  SUB R1,STTIM.		;SINCE START OF RUN
  FSC R1,233
  FSC R2,233
  FDVM R1,R2
  MOVEI R1,101		;TO TTY
  MOVEI R3,0
  FLOUT
    BLOWUP
  JSA T,PEOL.		;NEW LINE
;
  ERR E.JOB		;TELL WHERE WE ARE
  JSA T,PEOL.		;EOL
  JSA T,PEOL.		;TWICE
  JRST CMDEND		;AND DONE
;
;
 E.JOB: EXP EB.TRC!EB.CRA!EB.CRB!EB.RET ;NO MESSAGE, BUT TRACE
;
;
SUBTTL COMMAND ROUTINES--START
;
;   C.STA--THIS ROUTINE RESTARTS THE USER PROGRAM WITHOUT
;      HIM HAVING TO TYPE ^C AND START.
;
;
C.STA:
;
  PUSHJ P,NXICH		;GET NEXT CHR
  PUSHJ P,CKTRM		;MAKE SURE IT WAS A TERMINATOR
  JSA T,DBSTP.		;CLEAN UP SYMBOL TABLE
  MOVEI R1,400000	;CURRENT FORK
  GEVEC			;GET ENTRY VECTOR
  JRST 0(R2)		;AND ENTER AT START UP ADDRESS
;
;
SUBTTL COMMAND ROUTINES--TRACE--C.TRA
;
;   C.TRA--THIS IS THE PRIMARY ROUTINE FOR TRACING.  IT DECIDES
;      WHETHER THE USER WANTS TO TURN ITEMS ON OR OFF, AND BRANCHES
;      ACCORDINGLY.
;
;
C.TRA:
;
  PUSHJ P,GETSYM	;GET SYMBOL TABLE FOR PROGRAM
  PUSHJ P,NXICH		;GET NEXT CHR
  CAIE R1,"O"		;MUST BE 'O'
    JRST CMDEND		;IF NOT, THEN END
  PUSHJ P,NXICH		;GET NEXT CHR
  CAIN R1,"N"		;CHECK FOR 'ON'
    JRST SETTRC		;HANDLE IF SO
  CAIE R1,"F"		;CHECK FOR 'OFF'
    JRST ER.IFT		;MUST BE
  PUSHJ P,NXICH		;OF'F
  CAIE R1,"F"		;CHECK FOR IT
    JRST ER.IFT		;MUST BE
  JRST USTTRC		;HANDLE TRACE OFF
;
;
 SETTRC:
  HRROI R1,DOSTRC	;PTR TO ROUTINE TO TURN TRACE N
  JRST DOTRC		;DO THE TRACE SCAN
;
;
 USTTRC:
  PUSHJ P,NXICH		;CHECK NEXT CHR
  CAIN R1,0		;CHECK FOR EOL
    JRST USTRAL		;TRACE OFF ALL
  CAIN R1,";"		;CHECK FOR END OF TYPE
    JRST USTRAL		;TRACE OFF ALL
  CAIN R1,33		;CHECK FOR ESCAPE
    JRST USTRAL		;TRACE OFF ALL IF SO
  PUSHJ P,BKICH		;ELSE RESCAN THE CHR
  HRRZI R1,DOUTRC	;ROUTINE TO UNTRACE
  JRST DOTRC		;TRACE SCAN
;
;
SUBTTL COMMAND ROUTINES--TRACEING--DOTRC
;
;   DOTRC--THIS IS THE COMMAND SCAN FOR THE TRACE COMMAND.  IT
;      PICKS OFF VARIABLE NAMES AND 'LINE' AND TAKES ACTION
;      APPROPRIATELY.  THE ROUTINE TO SET/UNSET THE TRACE IS IN
;      R1 ON ENTRY AS IS A SET/UNSET FLAG.
;
;
DOTRC:
;
  PUSH P,R1		;SAVE FLAG
;
 DOTRC3:
  PUSHJ P,CMVAR		;GET VARIABLE
    JRST DOLTR		;HANDLE 'LINE'
;
  SKIPN R1		;MAKE SURE WE GOT OLD VARIABLE
    JRST ER.IVR		;ERROR IF NOT
  MOVE R0,IDNUM		;GET THE CURRENT LEVEL
  DPB R0,[POINT 12,R1,11] ;SAVE IN ADDRESS WORD
  PUSHJ P,FNTVR		;FIND IN TRACE TABLE
    JRST DOTRC1		;FOUND--SKIP
  MOVE R0,0(P)		;NOT FOUND--CHECK FOR UNSET
  TLNN R0,1		;BY LOOKING AT FLAG
    JRST ER.UTR		;ILLEGAL IF UNTRACE
  PUSHJ P,NWTVR		;NEW TRACE VARIABLE
;
 DOTRC1:
  MOVE R6,0(P)		;GET FLAG WORD
  PUSHJ P,0(R6)		;BRANCH TO PROPER ROUTINE
;
 DOTRC2:
  LDB R1,CMDTL		;CHECK TERM
  CAIN R1,","		;FOR COMMA
    JRST DOTRC3		;HANDLE MORE IN LIST
  POP P,R0		;ELSE RESTORE FLAG
  CAIN R1,";"		;CHECK FOR ANOTHER LIST
    JRST C.TRA		;HANDLE THAT
  JRST CMDEND		;ELSE END OF COMMAND
;
;
 DOLTR:
  HLLZ R0,0(P)		;GET FLAG
  HLLM R0,TRCFG		;SET TRACE LINE FLAG ACCORDINGLY
  JRST DOTRC2		;AND LOOP
;
;
 DOSTRC:
  MOVEM R1,TRCADD(R4)	;SAVE ADDRESS
  MOVEM R3,TRCNAM(R4)	;SAVE NAME OF VARIABLE
  MOVEM R5,TRCDMS(R4)	;SAVE DIMS
  MOVE R0,0(R1)		;GET CURRENT VALUE
  MOVEM R0,TRCVAL(R4)	;SAVE VALUE
  AOS TRCFG		;UPDATE COUNT
  POPJ P,		;AND RETURN
;
;
 DOUTRC:
  SETZM 0(R4)		;CLEAR BLCOK
  SETZM 1(R4)
  SETZM 2(R4)
  SETZM 3(R4)
  SOS TRCFG		;DECREMENT COUNT OF ACTIVE BLOCKS
  POPJ P,		;AND RETURN
;
;
SUBTTL COMMAND ROUTINES--TRACING--USTRAL
;
;   USTRAL--THIS ROUTINE CLEARS THE TRACE TABLE OFF ALL ACTIVE
;      TRACES.  IT DOES NOT AFFECT TRACE LINE.
;
;
USTRAL:
  PUSHJ P,UTRALL	;UNTRACE ALL
  JRST CMDEND		;THEN DONE
;
;
;
UTRALL:
  HLLZS TRCFG		;CLEAR VARIABLE PART OF TRACE FLAG
  SETZM TRCTBL		;CLEAR TRACE TABLE
  MOVE R1,[XWD TRCTBL,TRCTBL+1]
  BLT R1,TRCTBL+MXNTV*TRCLN-1
;
  LDB R1,CMDTL		;CHECK TERMINATOR
  CAIN R1,";"		;FOR MORE TRACE LISTS
    JRST C.TRA		;HANDLE IF SO
  POPJ P,		;AND RETURN
;
;
SUBTTL COMMAND ROUTINES--TRACING--FNTVR
;
;   FNTVR--THIS ROUTINE TAKES THE REGISTERS SET UP BY THE CMVAR
;      ROUTINE AND FINDS THE CORRESPONDING ENTRY IN THE TRACE TABLE
;      IF FOUND IT RETURNS TO 0(P); ELSE IT RETURNS TO 1(P).
;
;
FNTVR:
  HRRZ R0,TRCFG		;COUNT OF ACTIVE ENTRIES
  MOVEI R4,TRCTBL	;TABLE PTR
;
 FNTVR3:
  SOJL R0,FNTVR1	;CHECK IF DONE
;
 FNTVR4:
  SKIPN TRCADD(R4)	;CHECK FOR ACTIVE ENTRY
    JRST FNTVR2		;HANDLE IF NOT
  CAMN R1,TRCADD(R4)	;IS IT THE ONE WE WANT?
    POPJ P,		;RETURN OK IF SO
  ADDI R4,TRCLN		;IF NOT, NEXT ENTRY
  JRST FNTVR3		;LOOP COUNTING
;
 FNTVR2:
  ADDI R4,TRCLN		;NEXT ENTRY
  JRST FNTVR4		;LOOP WITHOUT COUNTING
;
 FNTVR1:
  AOS 0(P)		;BUMP RETURN FOR FAILURE
  POPJ P,		;AND RETURN
;
;
SUBTTL COMMAND ROUTINES--TRACING--NWTVR
;
;   NWTVR--THIS ROUTINE FINDS AN ENPTY HOLE IN THE TRACE TABLE
;      FOR A NEW ENTRY.
;
;
NWTVR:
;
  HRRZ R0,TRCFG		;GET ENTRY COUNT
  CAILE R0,MXNTV	;CHECK IF TOO MANY
    JRST ER.TVR		;HANDLE IF TOO MANY
;
  MOVEI R4,TRCTBL	;TABLE PTR
  SKIPN 0(R4)		;CHECK FOR EMPTY ENTRY
    POPJ P,		;RETURN WHEN FOUND
  ADDI R4,4		;NEXT ENTRY
  JRST .-3		;AND LOOP
;
;
SUBTTL COMMAND ROUTINE--STEP
;
;   C.STE--THIS ROUTINE HANDLES THE STEP COMMAND.  IT TAKES
;      ZERO OR ONE ARGUMENTS, THE STEP COUNT.
;
;
C.STE:
;
  PUSHJ P,CMLNM		;SCAN NUMBER
  PUSHJ P,CKTRM		;CHECK TERMINATOR
  SKIPN R3		;CHECK IF NUMBER GIVEN
    MOVEI R2,1		;IF NOT, USE 1
  MOVNM R2,SKPCT.	;SAVE STEP COUNT
  JRST RETRN		;AND RETURN
;
;
SUBTTL COMMAND ROUTINES--STOP--C.STO
;
;   CS.TO--THIS ROUTINE HANDELS THE STOP COMMAND.  IT EXECUTES
;      A BASIC STOP STATEMENT BASICALLY BY ENTERING THE STOP
;      ROUTINE IN THE RTP.
;
;
C.STO:
;
  PUSHJ P,NXICH		;GET NEXT CHR
  PUSHJ P,CKTRM		;MAKE SURE THIS IS WHAT THE USER WANTED
  JSA T,STOP.		;IF SO, STOP
;
;
SUBTTL ERROR PROCESSING--ENTRYS
;
;   THESE ARE THE VARIOUS ENTRYS TO THE ERROR ROUTINES.  THEY
;      CHOOSE A MESSAGE TO PRINT AS THE ERROR MESSAGE AND ENTER THE
;      MAIN ROUTINE.
;
;
ER.CMD:
  HRROI R1,[ASCIZ /Illegal command/]
  JRST DBERR
;
;
ER.NLN:
  HRROI R1,[ASCIZ /Line not found/]
  JRST DBERR
;
;
ER.IFT:
  HRROI R1,[ASCIZ /Incorrect format/]
  JRST DBERR
;
;
ER.UTR:
  HRROI R1,[ASCIZ /Trace variable not found/]
  JRST DBERR
;
;
ER.TVR:
  HRROI R1,[ASCIZ /Too many trace items/]
  JRST DBERR
;
;
ER.IVR:
  HRROI R1,[ASCIZ /Illegal variable name/]
  JRST DBERR
;
;
ER.SBC:
  HRROI R1,[ASCIZ /Subscript error/]
  JRST DBERR
;
;
ER.NSY:
  HRROI R1,[ASCIZ /No symbol table available/]
  JRST DBERR
;
;
ER.CMP:
  MOVEI R1,0
  JRST DBERR
;
;
ER.EDT:
  HRROI R1,[ASCIZ /Couldn't open file to edit/]
  JRST DBERR
;
;
ER.COM:
  HRROI R1,[ASCIZ /Can't execute compiler type command from saved file/]
  JRST DBERR
SUBTTL ERROR PROCESSING--DBERR
;
;   DBERR--THIS IS THE ERROR PROCESSOR.  IT PRINTS THE MESSAGE GIVEN
;      IN R1 ON ENTRY AND RESETS EVERYTHING NECESSARY TO CONTINUE.
;
;
DBERR:
;
  SKIPE R1		;CHECK IF ANYTHING GIVEN
    HRLI R1,440700	;IF SO, SET TALLY CORRECTLY
  MOVE R3,R1		;TO R3
  JSA T,TSET.		;SET UP FOR OUTPUT
  JSA T,PEOL.		;PRINT NEW LINE
  JSA T,PSTR.		;PRINT STRING
    JUMP R3		;IN R3
  JSA T,PEOL.		;NEW EOL
  MOVE P,[IOWD 40,PDLBF] ;RESTORE PDL
  JRST CMND		;AND GET A NEW COMMAND
;
;
SUBTTL CHARACTER ROUTINES--NXICH
;
;   NXICH--THIS ROUTINE GETS THE NEXT CHRACTER FROM THE COMMAND
;      STRING, IGNORING SPACES, ETC.
;
;
NXICH:
;
  ILDB R1,CMDTL		;GET CHR
  CAIE R1," "		;CHECK FOR A SPACE
  CAIN R1,11		;OR A TAB
    JRST NXICH		;IGNORE IF SO
  CAIL R1,140		;CHECK FOR LOWER CASE
    SUBI R1,40		;MAP TO UPPER
  POPJ P,		;ELSE RETURN
;
;
SUBTTL CHARACTER ROUTINES--BKICH
;
;   BKICH--THIS ROUTINE BACKS UP THE TALLY ONE CHR SO WE RESCAN THE
;      CURRENT CHARACTER IN THE COMMAND STRING.
;
;
BKICH:
;
  MOVSI R1,070000	;COUNT TO BACK UP
  ADDM R1,CMDTL		;WILL ONLY WORK ONCE
  POPJ P,		;AND RETURN
;
;
SUBTTL CHARACTER ROUTINES--CKTRM
;
;   CKTRM--THIS ROUTINE CHECKS THE CURRENT CHR FOR A COMMAND TERMINATOR
;      --A EOL (0) OR AN ESCAPE.
;
;
CKTRM:
;
  LDB R1,CMDTL		;GET LAST CHR
  CAIN R1,33		;CHECK FOR ESCAPE
    POPJ P,		;RETURN IF SO--OKAY
  CAIN R1,0		;CHECK FOR EOL
    POPJ P,		;OK IF SO
  JRST ER.IFT		;ELSE ERROR
;
;
SUBTTL CHARACTER ROUTINES--SPELL
;
;   SPELL--THIS ROUTINE TAKES A TALLY IN R2 AND CHECKS TO SEE IF
;      THE NEXT FEW CHARACTERS IN THE INPUT STREAM MATCH THE CHRS
;      POINTED TO IN THE TALLY.
;
;
SPELL:
;
  ILDB R0,R2		;GET NEXT TALLY CHR
  JUMPE R0,SPELL1	;IF 0 THEN DONE
  PUSHJ P,NXICH		;GET NEXT CHR FROM COMMAND
  CAMN R0,R1		;CHECK FOR MATCH
    JRST SPELL		;IF SO, CONTINUE LOOKING
  JRST ER.IFT		;ELSE INCORRECT FORMAT
;
 SPELL1:
  POPJ P,		;RETURN IF OK
;
;
SUBTTL SCANNING ROUTIENS--CMLNM
;
;   CMLNM--THIS ROUTINE SCANS THE COMMAND LINE FOR A LINE
;      NUMBER, RETURNING THE NUMBER IN R2 ON EXIT AND THE NUMBER
;      OF DIGITS IN R3.
;
;
CMLNM:
;
  SETZB R2,R3		;CLEAR R2,R3
;
 CMLNM1:
  PUSHJ P,NXICH		;GET NEXT CHR
  CAIL R1,"0"		;CHECK FOR DIGIT
  CAILE R1,"9"
    POPJ P,		;DONE IF NOT
  IMULI R2,12		;ACCUMULATE NUMBER IF DIGIT
  ADDI R2,-"0"(R1)	
  AOJA R3,CMLNM1	;AND LOOOP
;
;
SUBTTL SCANNING ROUTINES--CMVAR
;
;   CMVAR--THIS ROUTINE SCANS A VARIABLE FROM THE COMMAND LINE.  IT
;      IS USED FOR DEF AND TRACE..  IF 'LINE' IS FOUND IT RETURNS
;     TO CALL+1; IF A VARIABLE IS FOUND IT RETURNS TO CALL+2.
;
;   FOR VARIABLES IT RETURNS:
;      R1--ADDRESS OF VARIABLE (0 IF NOT ALLOCATED)
;      R2--SYMBOL TABLE NUMBER OF ADDRESS
;      R3--ASCIZ NAME OF VARIABLE
;      R5--DIMENSIONS OF VARIABLE (OR -1)
;
;
CMVAR:
;
  SETZM STRFG		;NOT STRING
  SETZB R2,R3		;CLERA R2,R3
  MOVE R4,[POINT 7,R3]	;TALLY FOR NAME
  PUSHJ P,NXICH		;GET FIRST CHR
  CAIL R1,"A"		;CHECK FOR LETTER
  CAILE R1,"Z"
    JRST ER.IVR		;MUST BE
  MOVEI R2,-"A"(R1)	;GET NUMBER IF SINGLE LETTER VAR
  IDPB R1,R4		;SAVE IN NAME
;
  PUSHJ P,NXICH		;GET SECOND CHR
  CAIL R1,"0"		;CHECK FOR DIGIT
  CAILE R1,"9"
    JRST CMVR1		;NO--HANDLE
  IDPB R1,R4		;SAVE IN NAME
  IMULI R2,12		;COMPUTE NEW VARIABLE NUMBER
  ADDI R2,32-"0"(R1)
  PUSHJ P,NXICH		;GET TERMINATING CHR
  JRST CMVR3		;AND SKIP
;
 CMVR1:
  CAIL R1,"A"		;CHECK FOR LETTER
  CAILE R1,"Z"
    JRST CMVR3		;IF NOT, END OF NAME
  IDPB R1,R4		;ELSE SAVE IN NAME
  CAMN R3,[ASCII /LI/]	;CHECK FI 'LINE'
    JRST CMVR4		;HANDLE IF SO
  CAMN R3,[ASCII /FN/]	;CHECK FOR 'FN'
    JRST CMFCT		;HANDLE IF SO
  JRST ER.IVR		;ELSE ERROR
;
 CMVR4:
  MOVE R2,[POINT 7,[ASCIZ /NE/]] ;TALLY TO LI'NE
  PUSHJ P,SPELL		;MAKE SURE WE HAVE IT
  PUSHJ P,NXICH		;GET EXTRA CHR
  POPJ P,		;RETURN FOR LINE
;
 CMVR3:
  AOS 0(P)		;BUMP RETURN FOR VARIABLE
  CAIE R1,"$"		;CHECK FOR STRING
    JRST CMVR3A		;SKIP IF NOT
  SETOM STRFG		;MARK AS STRING
  IDPB R1,R4		;SAVE '$' IN NAME
  PUSHJ P,NXICH		;GET NEXT CHR
;
 CMVR3A:
  CAIN R1,"("		;CHECK FOR SUBSCRIPT
  CAIL R2,32		;MAKE SURE LEGAL
    SKIPA		;IF NOT, IGNORE
  JRST CMSBC		;HANDLE SUBSCRIPT
;
  HRRZ R1,SYMTAB(R2)	;GUESS NUMERIC
  SKIPE STRFG		;CHECK
    HLRZ R1,SYMTAB(R2)	;STRING
  TRZE R1,VRGBL		;CHECK FOR GLOBAL
    JRST CMVR6		;HANDLE GLOBAL
  TRZE R1,VRFCT		;CHECK IF FCT VAR
    JRST CMVR7		;HANDLE IF SO
  MOVE R5,PGDAT.(V)	;GET PROGRAM DATA AREA PTR
  HLRZ R5,PGNVRL(R5)	;STRING OFFSET
  SKIPN STRFG		;CHECK IF STRING
    MOVEI R5,0		;NUMERIC OFFSET OF ZERO
  ADDI R5,0(V)		;REAL OFFSET
  SKIPE R1		;CHECK IF DEFINED
    ADD R1,R5		;IF SO, ADD IN OFFSET
;
 CMVR5:
  MOVNI R5,1		;NO DIMS
  SKIPE STRFG		;CHECK IF STRING
    TLO R1,TRCSTR	;MARK IF SO
  POPJ P,		;AND RETURN
;
 CMVR6:
  ADD R1,V		;RELOCATE GLOBAL
  HRRZ R1,0(R1)		;GET REAL ADDRESS
  JRST CMVR5		;AND DONE
;
 CMVR7:
  ADD R1,F		;RELOCATE FCT VAR
  HRRZS R1		;ADDRESS ONLY
  JRST CMVR5		;AND DONE
;
;
SUBTTL SCANNING ROUTINES--CMFCT
;
;   CMFCT--THIS IS REALLY A PORTION OF THE CMVAR ROUTINE WHOSE
;      SOLE PURPOSE IS TO SCAN FCT VARS (FNX)
;
;
CMFCT:
;
  PUSHJ P,NXICH		;GET THIRD CHR
  CAIL R1,"A"		;CHECK FOR LETTER
  CAILE R1,"Z"	
    JRST ER.IVR		;MUST BE
  MOVEI R2,-"A"+32+414(R1)	;CONVERT TO SYMBOL TABLE NUMBER
  IDPB R1,R4		;SAVE CHR IN NAME
  PUSHJ P,NXICH		;AND SCAN NEXT CHR
  JRST CMVR3		;HANDLE AS VARIABLE
;
;
SUBTTL SCANNING ROUTINES--CMSBC
;
;   CMSBC--THIS IS REALLY A PORTION OF THE CMVAR ROUTINE WHOSE
;      SOLE PURPOSE IS TO SCAN SUBSCRIPTS OF SUBSCRIPTED ITEMS.
;
;
CMSBC:
;
  HRROI R5,0		;-1,0 FOR DEFAULT 1D
  SKIPE STRFG		;CHECK IF STRING MAT
    ADDI R2,32		;CHANGE PTR IF SO
;
 CMSBC4:
  MOVEI R6,0		;CLEAR ACCUM FOR NEXT DIM
;
 CMSBC2:
  PUSHJ P,NXICH		;GET NEXT CHR
  CAIL R1,"0"		;CHECK FOR DIGIT
  CAILE R1,"9"
    JRST CMSBC1		;HANDLE IF NOT--DONE
  IMULI R6,12		;ACCUMULATE IF SO
  ADDI R6,-"0"(R1)
  AOJA R5,CMSBC2	;AND LOOP
;
 CMSBC1:
  TRNN R5,-1		;MAKE SURE WE HAD SOME DIGITS
    JRST ER.IVR		;ERROR IF NOT
  HRR R5,R6		;SAVE THE NEW DIM
  CAIN R1,","		;CHECK FOR ANOTHER DIM
    JRST CMSBC3		;HANDLE IF SO
  CAIE R1,")"		;CHECK IF DONE
    JRST ER.IVR		;MUST BE
  PUSHJ P,NXICH		;SCAN AN EXTRA CHR
  SKIPN R4,MATPTB(R2)	;GET MAT PTR WORD
    JRST ER.IVR		;BETTER BE DEFINED ARRAY
  ADDI R4,0(V)		;RELOCATE IT
  PUSHJ P,SBCMPT	;COMPUTE ADDRESS
  SKIPE STRFG		;CHECK FOR STRING MAT
    TLO R1,TRCSTR	;MARK AS SUCH
  POPJ P,		;AND RETURN ALL SET UP
;
 CMSBC3:
  HLRZ R1,R5		;CHECK IF FIRST TIME
  CAIE R1,-1		;CAUSE WE ONLY WANT 2 DIMS
    JRST ER.IVR		;ELSE ERROR
  HRLZS R5		;POSITION FOR SECOND DIM
  JRST CMSBC4		;AND GET IT
;
;
SUBTTL SCANNING ROUTINES--SBCMPT
;
;   SBCMPT--THIS IS A CALLED-ONCE-ONLY SUBROUTINE FOR CMSBC
;      WHICH COMPUTES THE ADDRESS OF A SUBSCRIPTED VARIABLE
;      GIVEN THE BASE AND THE DIMS.
;
;
SBCMPT:
;
  TLNE R4,MTGBL		;CHECK IF GLOBAL
    HRRI R4,@0(R4)	;GET ACTUAL;
  HLRE R0,R5		;GET FIRSST DIM
  HRRZ R1,R5		;AND SECOND
  CAMLE R1,1(R4)	;CHECK BOUNDS
    JRST ER.SBC		;CAN'T BE OUTSIDE
  SKIPGE 2(R4)		;CHECK IF 1D
    JRST SBCMP1		;SKIP IF SO
  CAMLE R0,2(R4)	;CHECK 2ND DIM
    JRST ER.SBC		;WHICH MUST BE IN BOUNDS
  IMUL R1,2(R4)		;COMPUTE 2D OFFSET
  ADD R1,R0
;
 SBCMP1:
  ADD R1,0(R4)		;GET COMPLETE ADDRESS
  HRRZS R1		;ALONE
  POPJ P,		;AND RETURN
;
;
SUBTTL UTILITY ROUTINES--FNDLIN
;
;   FNDLIN--THIS ROUTINE TAKES A LINE NUMBER IN R1 AND RETURNS
;      A POINTER IN R2 TO THE ADDRESS IN THE OBJECT CODE
;      CORRESPONDING TO THAT LINE.  THE LINE MUST EXIST OR AN
;      ERROR OCCURS.
;
;
FNDLIN:
;
  HRRZ R2,DBGDT.(V)	;GET FIRST PTR TO PRGM
;
 FNDLN1:
  HLRZ R0,0(R2)		;GET LINE NUMBER OF CURRENT LOC
  CAMN R0,R1		;CHECK FOR MATCH
    JRST FNDLN2		;HANDLE MATCH
  HRRZ R2,0(R2)		;ELSE GET NEXT
  JUMPN R2,FNDLN1	;LOOP IF MORE
  JRST ER.NLN		;ERROR IF NOT
;
 FNDLN2:
  POPJ P,		;RETURN WHEN DFOUND
;
;
SUBTTL UTILITY ROUTINES--GETCOM
;
;   GETCOM--THIS ROUTINE MAKES SURE THE COMPILER IS ACTIVE
;      IN CORE.
;
;
GETCOM:
;
  SKIPE R2,COMENT	;CHECK IF COMPILER PRESENT
    POPJ P,		;DONE IF ALREADY THERE
  HRLZI R1,100001	;GET OLD FILE
  HRROI R2,[ASCIZ /<SUBSYS>TBASIC.SAV/] ;COMPILER NAME
  GTJFN
    BLOWUP
  PUSH P,R1		;SAVE JFN
  MOVEI R1,400000	;CURRENT FORK
  GEVEC			;GET CURRENT ENTRY VECTOR
  POP P,R1		;RESTORE R1 (JFN)
  PUSH P,R2		;SAVE OLD ENTRY VECTOR
  PUSH P,JOBSYM		;SAVE OUR SYMTAB PTR
  HRLI R1,400000	;MERGE INTO OUR FORK
  GET
  POP P,JOBSYM		;RESTORE SYMTAB PTR
  MOVEI R1,400000	;CURRENT FORK
  GEVEC			;GET ITS ENTRY ADDRESS
  MOVEM R2,COMENT	;SAVE IT
  POP P,R2		;RESTORE ENTRY VECOT
  SEVEC			;RESET TO OLD VECTOR
  MOVE R2,R1		;GET INTO R2
  POPJ P,		;AND RETURN
;
;
SUBTTL UTILITY ROUTINES--GETSYM
;
;   GETSYM--THIS ROUTINE MAKES SURE THAT THE SYMBOL TABLE PAGE
;      CONTAINS THE SYMBOL TABLE FOR THE PROGRAM WE ARE CURRETNLY
;      WORKING ON.
;
;
GETSYM:
;
  PUSHJ P,OPNSYM	;OPEN SYMBOL TABLE FILE IF NOT OPEN
  MOVE R1,PGDAT.(V)	;GET PROGRAM DATA PTR
  MOVE R1,PGLNK(R1)	;GET SUB BLOCK PTR
;
 GTSSYM:
  HLRZ R1,SUBSYM(R1)	;GET SYMTAB PAGE NUMBER
  JUMPE R1,ER.NSY	;CHECK IF ONE IS AVAILABLE
  HLL R1,SYMJFN		;AND JFN
  CAMN R1,CURSYM	;IS THAT WHAT WE HAVE?
    POPJ P,		;YES--JUST RETURN
;
  HRLI R2,400000	;ELSE TO CURRENT FORK
  HRRI R2,SYMPGN	;FOR SYMBOL TABLE
  MOVSI R3,140000	;FOR READ AND WRITE
  PMAP			;GET PROPER PAGE
  MOVEM R1,CURSYM	;SAVE AS THE ONE WE HAVE
  POPJ P,		;AND RETURN
;
;
SUBTTL UTILITY ROUTINE--OPNSYM
;
;   OPNSYM--THIS ROUTINE MAKES SURE THAT THE SYMBOL TABLE FILE IS
;      OPEN.  IF IT ISN'T IT OPENS IT.
;
;
OPNSYM:
;
  SKIPE SYMJFN		;CHECK IF ALREADY OPEN
    POPJ P,		;JURST RETURN IF SO
;
  PUSH P,R3		;SAVE R3,R4
  PUSH P,R4
  GJINF			;GET JOB NUMBER
  MOVE R1,R3		;TO R1
  POP P,R4		;RESTORE R3,R4
  POP P,R3
;
  HRLI R1,110001	;OPEN THE FILE (OLD)
  HRROI R2,[ASCIZ /BASIC.SYMTABS/]
  GTJFN			;FIRST DO GTJFN
    JRST ER.NSY		;CAN'T FIND IT
  HRLZM R1,SYMJFN	;SAVE JFN
  MOVE R2,[XWD 440000,300000]	;OPEN BITS
  OPENF			;OPEN THE FILE
    BLOWUP
;
  POPJ P,		;AND DONE
;
;
SUBTTL STORAGE
;
;   THE DEBUGGER CONTAINS A BIT OF PRIVATE STORAGE:
;
;
TRCFG:	BLOCK 1		;TRACE FLAG
TRLPFG:	BLOCK 1		;TRACE LINE PRINTED FLAG
FSTFLG:	BLOCK 1		;FIRST TIME FLAG
BOCFG:	BLOCK 1		;BREAK ON CALL FLAG
DBGXFG:	BLOCK 1		;EXECUTING LINE FLAG
;
IDNUM:	BLOCK 1		;ID NUMBER (LEVEL)
CMDSTR:	BLOCK 1		;COMMAND STRING
CMDTL:	BLOCK 1		;CURRENT TALLY
NCMDTL:	BLOCK 1		;RESCAN TALLY
DEFCNT:	BLOCK 1		;NUMBER OF VARS FOR DEF
TDFCNT:	BLOCK 1		;TEMP FOR DEF
STRFG:	BLOCK 1		;VARIABLE STRING/NUMERIC
LSTENT:	BLOCK 1		;LAST ENTRY T REG
DOSVT:	BLOCK 1		;T REG FOR LAST DO
SSKPCT:	BLOCK 1		;SAVED SKIP COUNT
EDTJFN:	BLOCK 1		;JFN OF FILE TO EDIT
EDTSYS:	BLOCK 1		;FORK HANDLE, SYSTEM JFN OF EDITOR
;
DBGRGS:	BLOCK 20	;ENTRY REGS
DCMRGS:	BLOCK 20	;COMPILER CALL-SAVE REGS
;
TRCTBL:	BLOCK MXNTV*TRCLN	;TRACE TABLE
;
PDLBF:	BLOCK 40	;PDL
;
PATCH:	BLOCK 40	;OUR OWN LITTLE PATCH AREA
;
;
SUBTTL END OF ASSEMBLY
;
;
;
VARS: VAR
;
;
LITS: LIT
;
;
END
