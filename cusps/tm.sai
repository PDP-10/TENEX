BEGIN "MAIN"
COMMENT
"THIS PROGRAM IS THE EXECUTIVE PART OF THE MODELING-LABORATORY
SYSTEM.  THE VARIOUS FUNCTIONS OF EACH PROCEDURE ARE
DESCRIBED IN THE PROCEDURES THEMSELVES, AS WELL AS IN THE
CALLING ROUTINES.

THE OVER-ALL STRUCTURE OF THE SYSTEM IS AS FOLLOWS.

THE MAIN DATA STRUCTURE IS THE SYMBOL TABLE WHICH CONSISTS
OF A COLLECTION OF ENTRIES, ONE FOR EACH EXTANT SYMBOL.

         SYMTAB ENTRY
---------------------------------

NAME        TYPE          VALUE             IDX
..........................................................
IDENT       UNKNOWN       -                 -
.............................................................
IDENT       SCALAR        REAL #            -
......................................................
CODED       CONSTANT      REAL #            -
SYMBOL
FOR
CONSTANT
.....................................................
OPERATOR    OPERATOR       INTEGER          -
SYMBOL                    CODE FOR
                          OPERATOR
.....................................................
BUILTIN     -CASE #       # OF ARGS
FUNCTION    (0 OR LESS)   (THIS VALUE IS NEGATIVE
NAME                       IF THE FCT CANNOT RECEIVE
                           OR RETURN "RAW" VALUES).
................................................................
IDENT       MATRIX        ITEM# HAVING      -
                          MATRIX DATUM      
..............................................................
IDENT       ROW           SYMTAB INDEX      SYMTAB INDEX
(TEMPORARY)               OF MATRIX ENTRY   OF MATRIX ENTRY
                          (VALUES)          (ROW INDICES)
..............................................................
IDENT       COL           SYMTAB INDEX      SYMTAB INDEX
(TEMPORARY)               OF MATRIX ENTRY   OF MATRIX ENTRY
                          (VALUES)          (COL INDICES)
...........................................................
IDENT       SUBSCR        PACKED PAIR OF    SYMTAB INDEX OF
                          INTEGER SUBSCRIPTS SUBSCRIPTED SYMBOL
..............................................................
IDENT       COLON	    -                 INDEX TO NODE
                                              CONTAINING VALUES
                                              A,B,C REPRESENTING
                                             A:B:C.
.................................................................
IDENT       FUNCTION      VALUE ON    INDEX TO NODE SUCH THAT
                          LAST        NODE(IDX) POINTS TO A TREE
                          EVAL        STRUCTURED EXPRESSION OF
                                      NODES. NODE(IDX+1) POINTS TO
                                      AN ARGUMENT TABLE.
.................................................................
IDENT       INITIAL       VALUE ON    INDEX TO NODE SUCH THAT
                          LAST EVAL   NODE(IDX) POINTS TO A
                                     TREE-STRUCTURED EXPRESSION
                                      OF NODES REPRESENTING AN
                                 INITIAL VALUE EXPRESSION.
                                      NODE(IDX+1) POINTS TO AN
                                       A NODE WHICH HOLDS AN
                                   ARGUMENT TABLE. ACTUALLY
                                 THERE CAN BE JUST ONE ARGUMENT
                                      AND ITS VALUE IS USED WHEN
                                      USING THE INITIAL CONDITION
                                 THUS THAT ARG MAY WELL BE A
                                   CONSTANT TOKEN!
..................................................................
IDENT      CURVE                                     
   
...........................................................
IDENT      WINDOW
   
............................................................


";





COMMENT "******** COMPILATION SWITCHES ********";


DEFINE TENEXSW="TRUE";


COMMENT "HERE VARIOUS MACROS ARE DEFINED.";




COMMENT "******* TOKENS *******";

DEFINE STACKBOTTOM="68";
DEFINE TTYDRAW="64";
DEFINE CR="51";
DEFINE ENDOP="78";
DEFINE FUNCTIONF="20";
DEFINE FCTTOKEN="30";
DEFINE SAVETOKEN="49";
DEFINE FORTOKEN="67";
DEFINE STRINGTOKEN="47";
DEFINE PRINTTOKEN="77";
DEFINE TYPETOKEN="41";
DEFINE DRAWTOKEN="36";
DEFINE DIFFOP = "58";
DEFINE POWEROP="3";
DEFINE CLOSEBRACKET="22";
DEFINE OPENBRACKET="19";
DEFINE LEQOP="10";
DEFINE GEQOP="11";
DEFINE TRANSP="28";
DEFINE CATTRANSP="25";
DEFINE ROWOP="26";
DEFINE COLOP="27";
DEFINE GREATEROP="12";
DEFINE IFOP="69";
DEFINE THENOP="70";
DEFINE ELSEOP="71";
DEFINE DOOP="66";
DEFINE FITOP="31";
DEFINE MINUS="7";
DEFINE ABSUOP = "60";
DEFINE COMMA="17";
DEFINE SEMICOLON="74";
DEFINE INITIALTOKEN="29";
DEFINE NOTOP = "13",
       EQUALOP = "8",
       UPLUS = "18";
DEFINE UMINUS="53";
DEFINE PLUS="6";
DEFINE MULTSIGN="4";
DEFINE DIVIDESIGN="5";
DEFINE PLOT="52";
DEFINE EXIT="65";
DEFINE QUIET="45";
DEFINE VERTICAL="45";
DEFINE HELP="42";
DEFINE ID="1";
DEFINE CONST="2";


COMMENT "*******  TYPES(IN SYMTAB) ******";

DEFINE OPERATOR="3";
DEFINE SCALAR="4";
DEFINE UNKNOWN="1 ";
DEFINE FUNCTION="5 ";
DEFINE MATRIX="6 ";
DEFINE WINDOW="7 ";
DEFINE CURVE="8 ";
DEFINE INITIAL="9 ";
DEFINE CONSTANT="2 ";
DEFINE COLON="10 ";
DEFINE ROW="12 ";
DEFINE COL="13 ";
DEFINE SUBSCR="14 ";
DEFINE TEXT="15";
DEFINE CONSTRAINTS="16";
DEFINE SAVEBUNDLE="17"; COMMENT IN SAVE FILES ONLY;

 

COMMENT "**** OTHER SYMBOLS *******";

DEFINE DEFAULTAT="-2.222222@22";
DEFINE DEFAULTBY="-2.222222@22";
DEFINE DEFAULTSIZE="10";
DEFINE DEFAULTINTENSITY="10";
DEFINE DEFAULTPTTYPE="10";
DEFINE DEFAULTLINETYPE="10";
DEFINE DEFAULTPTLABELIDX="0";
DEFINE DEFAULTXYFLOATING="0";
DEFINE DEFAULTLABELSKIP="-1";
DEFINE CRLF="('15&'12)";
DEFINE POLISHPREFIXOP="0";
DEFINE SIZEA="1050";
DEFINE SIZEAM1="(SIZEA-1)";
DEFINE SIZENODE="3300";
DEFINE SIZENODEM1="(SIZENODE-1)";
DEFINE SIZEABLOCK="15";
DEFINE SIZENODEBLOCK="3";
DEFINE SIZEP="140";
DEFINE SYMTABSIZE="311";
DEFINE SYMTABSIZEM1="(SYMTABSIZE-1)";
DEFINE MAXFITDIM="13";
DEFINE MARK="1010101";
DEFINE MARKED="9999";
DEFINE NINITSYMS="97";
DEFINE NBUILTINS="37";
DEFINE MAXNOLOOPS="4";


IFC  NOT TENEXSW THENC
DEFINE MASTERDEVICE="""SYS""";
DEFINE MASTERPPN="NULL";

ELSEC
DEFINE MASTERDEVICE="""DSK""";
DEFINE MASTERPPN="""[SYS,SUP]""";
ENDC


DEFINE HASH(X) ="(((ABS CVASC(X)) MOD SYMTABSIZEM1)+1)";

DEFINE ROWSIZE(A)="(IF ARRINFO(A,0)=0 THEN 0 ELSE ARRINFO(A,2))";
DEFINE COLSIZE(A)="(IF ARRINFO(A,0)=0 THEN 0 ELSE ARRINFO(A,4))";
DEFINE SIZE(A)="(ARRINFO(A,0))";

DEFINE MAKEDIFFNAME(F,X)=""".""&NAME[F]&"".""&NAME[X]";

DEFINE MAX(A,B) = "IF A<B THEN B ELSE A";


DEFINE 	NUMBER(A) = "(A=SCALAR OR A=CONSTANT)";

DEFINE	NEWTEMP = "SYMTABENTRY("" ""&TEMPCHR); TEMPCHR_TEMPCHR+1";

DEFINE REL(X)="(0.0 XOR (X))";
DEFINE INT(X)="(0 XOR (X))";

DEFINE UNARYOP(X)="(X=UMINUS OR X=UPLUS OR X=ABSUOP OR X=TRANSP OR X=NOTOP )";


DEFINE STUFFST(J,B) = "BEGIN J_1; WHILE LENGTH(ST[J]) DO J_J+1;
			ST[J]_B END";

INTEGER VSW,
        J,
        U,
        TV,
        V,
        FCTSW,
        ARROWSW,
        FIRSTF,
        RTV,
	ACTNO,
        D1,D2,I1,J1,
        PTTYPEVAL,
        LINETYPEVAL,
        WINDOWIDX,
        PTLABELIDX,
        XYFLOATINGVAL,
        INTENSITY,
	SIZEVAL,
	FORSWITCH,
	MASTERFORSW,
	PRINTSW,
	LPLEVEL,
	TEMP1,
        CURVENO,
        IFSW,
        OPSYM,
        HIFREE,
        SPANFREE;

INTERNAL INTEGER DISINIT,
		 POSTNUMBER,
                 QUIETSW,
                 BRCHAR,
                 EOF,
		 RELDIS,
         I,
         TEMPH,TEMPDH,
         NARGS,
         TEMPCHR,
         ONE,
         ZERO,
         FITN,
         INTEGRALOP,SUMOP,IGRATEOP,LLOKUPOP,ROOTOP,
         VALSW;

INTERNAL REAL DEQRELERR;

COMMENT THESE OCCUR IN THE SAIL RUNTIME CODE;
EXTERNAL INTEGER GOGTAB;
COMMENT EXTERNAL INTEGER HASTAB;
DEFINE HASTAB="'311";
EXTERNAL INTEGER CORREL;
EXTERNAL INTEGER !ERRP!, !ERRJ!;

LABEL START,
      HOME,
      R,
      SETUP,
      SETVSW,
      FORSTART,
      READST,
      ACTION;

SAFE INTEGER ARRAY ITEMVAR ITM;

INTERNAL STRING B, CURRENTDIS;
STRING TEMPSTRING;


REAL ATX,
     ATY,
     BYW,
     BYH,
     DWATX,DWATY,
     LABELSKIP;


INTEGER ARRAY LPV[1:4],
              LPLIST[1:4],
              LPPTR[1:4];
SAFE STRING ARRAY LPSTRING[1:4];

INTERNAL INTEGER ARRAY FITW[1:MAXFITDIM+1],
                       FITF[1:MAXFITDIM],
                       FITM[1:MAXFITDIM];

PRELOAD!WITH 
          "EXP","LOG","LOG10","SQRT","SIN","SIND",
          "COS","COSD","SINH","COSH","TANH","ASIN","ACOS",
          "ATAN","RAN","LOGGAMMA","INT","ATAN2","MOD",
          "NROWS","NCOLS",
         "POINTS","INTERPOLATE","SORT",
          "READ", "DIAG", "CURVEMATRIX", "LABELMATRIX","HISTO",
         "SMOOTH","SVD","COMPRESS","TYPEOUT","CROSS","MESH","ROTATE",

"NOT","AND","OR","LIST","ROW","COL","INIT","INITIAL","FCT","FUNCTION",
"FIT","TO","BY","WT","WEIGHT","IN","DRAW","AT","IMAGE","WINDOW","DELETE","DEL",
"TYPE","HELP","INSCRIBE","UNSCRIBE","BLANK","QUIET","VERTICAL",
"UNBLANK","STRING","TEXT","SIZE","SAVE","USE","PLOT",
"PT","POINTTYPE","LINETYPE","LINE","LABEL","WITH","ABS","XFLOATING",
"YFLOATING","PRINTERDRAW","TTYDRAW","EXIT","DO","FOR","DIFF",
"IF","THEN","ELSE","GET","CONSTRAINTS","RELEASE",
"ON","INTENSITY","PRINT","END";

INTERNAL STRING ARRAY ST[1:NINITSYMS];


PRELOAD!WITH -99,
              1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,1,1,-2,-2,-2,
             -1,-1,-1,-1,-1,-1,-1,-1,1,-2,-2,-2,

             13,14,15,21,26,27,29,29,30,30,31,32,33,34,34,35,36,
             37,38,39,40,40,41,42,43,44,45,45,45,46,47,47,48,49,50,52,
             54,54,55,55,56,57,60,61,62,63,64,65,66,67,58,69,70,71,
             72,59,73,75,76,77,78;

SAFE INTEGER ARRAY OP[0:NINITSYMS];

SAFE INTERNAL INTEGER ARRAY P[0:SIZEP];

SAFE INTERNAL INTEGER ARRAY TYPE[0:SYMTABSIZEM1];

SAFE INTERNAL INTEGER ARRAY VALUE[0:SYMTABSIZEM1],
	               IDX[0:SYMTABSIZEM1],
                       A[0:SIZEA],
                       NODE[0:SIZENODE];


COMMENT " PRELOAD!WITH [SYMTABSIZE]NULL - THIS IS AUTOMATICALLY THE CASE";
INTERNAL SAFE OWN STRING ARRAY NAME[0:SYMTABSIZEM1];

  

PRELOAD!WITH

-1,-1,1,3,3,4,4,5,5,5,5,5,6,7,8,9,10,-1,16,15,

14,-1,13,11,11,12,12,-1,-1,-1,18,20,23,17,19,26,

24,22,22,22,22,22,22,22,22,22,26,21,22,22,-1,22,

2,27,27,28,29,31,22,2,28,28,26,26,22,22,-1,30,32,32,33,22,22,

10,20,27,22,-1;

SAFE OWN INTEGER ARRAY ROWTOKVAL[1:78];




PRELOAD!WITH 
-1,-1,1,3,3,4,4,5,5,5,5,5,6,7,8,9,10,-1,-1,15,

-1,14,13,11,11,12,12,16,0,0,-1,19,22,17,18,-1,

23,21,21,21,21,21,21,21,21,21,-1,20,21,21,27,

21,2,24,24,25,26,28,21,2,25,25,-1,-1,21,17,0,-1,-1,29,29,21,21,

30,15,24,21,-1;

SAFE OWN INTEGER ARRAY COLTOKVAL[1:78];


PRELOAD!WITH
0,0,5,7,8,4,4,4,4,4,4,4,45,4,4,6,1,0,0,13,42,0,

14,11,12,9,9,10,3,3,15,22,23,26,24,27,25,29,28,18,17,16,

30,31,20,21,27,32,33,34,43,41,44,35,36,37,38,51,49,2,39,40,

46,46,48,57,50,0,52,53,54,55,56,0,47,19,58,0;

SAFE OWN INTEGER ARRAY OPSWITCH[1:78];



COMMENT ARRAYS ARE STORED BY COLUMNS;


PRELOAD!WITH 

'122222222221,'212220022222,'022000122000,
'212222222221,'202220022222,'022000022000,
'111222222221,'212220022222,'022000122000,
'111122222221,'212220022222,'022020122000,
'111122222221,'212220022222,'062002122000,
'111111222221,'202220022222,'022000022000,
'111111122221,'212220022222,'022000122000,
'111111112221,'212220022222,'022000122000,
'111111111201,'112200000000,'330002122000,
'111111112211,'112212111212,'221116100000,
'111121112211,'112220022222,'020000022000,
'222222222221,'112220022222,'020022022000,
'111121112220,'122220020200,'020020000000,
'111111111111,'114500010000,'000000101000,
'222222222222,'222220020222,'022022122000,
'333333333331,'313330030333,'030000033000,
'111141114111,'110002010000,'000000000000,
'111111110211,'110000010200,'220000100000,
'000000000200,'000002010000,'000000100000,
'111111112111,'010000100001,'220110000000,
'000000000000,'000000000000,'000002000000,
'111111110111,'111000000202,'020000000000,
'111111112111,'111000101210,'221110000000,
'111111110111,'110000100001,'021010000000,
'111111110111,'110000100001,'021020000000,
'111111110211,'110062161001,'021100000000,
'111111111111,'110011111111,'011116101000,
'222222222222,'222202000200,'100002100000,
'111111111111,'110000000000,'000000071000,
'111111111111,'112211111111,'111116101000,

'0;

SAFE OWN INTEGER ARRAY ACTM[0:99];





PRELOAD!WITH
0,1,4,7,2,3,6,-1,8,9;
SAFE OWN INTEGER ARRAY BINOPSCODE[6:15];

SAFE EXTERNAL REAL ARRAY DISINFO[1:23];

EXTERNAL PROCEDURE DPLOT (REFERENCE REAL A; INTEGER FILE);


FORWARD INTERNAL INTEGER SIMPLE PROCEDURE SYMTABENTRY(STRING S);
FORWARD INTERNAL SIMPLE PROCEDURE ERROR(STRING S);
FORWARD INTERNAL PROCEDURE DELETEENTRY(INTEGER E);
FORWARD INTERNAL PROCEDURE PROCESS;
FORWARD INTERNAL INTEGER PROCEDURE E(INTEGER I);
FORWARD REAL SIMPLE PROCEDURE GETLINEAR(SAFE INTEGER ARRAY A; INTEGER I);



REQUIRE "TMG" LOAD!MODULE;
REQUIRE "TMF" LOAD!MODULE;

IFC NOT TENEXSW THENC
REQUIRE "APRFIX" LOAD!MODULE;
REQUIRE "SYS:DISSAI" LOAD!MODULE;

ELSEC
REQUIRE "<LIBRARY>DISSAI" LOAD!MODULE;
REQUIRE "APRFIX" LOAD!MODULE;
REQUIRE "<LIBRARY>SAIPAT" LOAD!MODULE;

ENDC


EXTERNAL PROCEDURE CBLANK(INTEGER I);
EXTERNAL PROCEDURE CUNBLANK(INTEGER I);
EXTERNAL PROCEDURE DRAW(INTEGER C,M,W,LTYPE,PTYPE,FLOATL,PLSZE,PTLABELIDX;
                         REAL LABELSKIP,ATX,ATY;INTEGER INTQ);
EXTERNAL PROCEDURE WINDOWP(INTEGER I;REAL U,V,X,Y);
EXTERNAL PROCEDURE INSCRIBE(INTEGER I);
EXTERNAL PROCEDURE UNSCRIBE(INTEGER W);
EXTERNAL PROCEDURE IMAGE(INTEGER I;REAL U,V,X,Y);
EXTERNAL PROCEDURE WDELET(INTEGER I);
EXTERNAL PROCEDURE CDELET(INTEGER I);
EXTERNAL PROCEDURE WINTYP(INTEGER I,CHANNEL);
EXTERNAL PROCEDURE CURTYP(INTEGER I,CHANNEL);
EXTERNAL PROCEDURE WINUSE(INTEGER I);
EXTERNAL PROCEDURE WINSAV(INTEGER I);

EXTERNAL PROCEDURE DREL;
EXTERNAL INTEGER PROCEDURE DGET;
EXTERNAL PROCEDURE GINIT (STRING S);
EXTERNAL PROCEDURE DDONE;


DEFINE INPUT0="INPUT";

COMMENT EXTERNAL PROCEDURE INPUT0(INTEGER CHANNEL,BKTABLE);

   
IFC NOT TENEXSW THENC
EXTERNAL PROCEDURE APRFIX;
  
ELSEC
EXTERNAL PROCEDURE APRFXO;
EXTERNAL PROCEDURE APRFXF;
  
ENDC
   
   

EXTERNAL PROCEDURE FITDRIVER(SAFE INTEGER ARRAY PARM);
EXTERNAL PROCEDURE DOFUNC;
EXTERNAL STRING PROCEDURE FCTTYPE(INTEGER I);
EXTERNAL STRING PROCEDURE DEEPDIFF(STRING S);
EXTERNAL PROCEDURE DOVECTORF(INTEGER F,C,H; SAFE REAL ARRAY M,FVAL);
EXTERNAL STRING PROCEDURE FIXNAME(STRING S);
EXTERNAL STRING PROCEDURE FANCYNUM(REAL R);

REQUIRE 1100 SYSTEM!PDL;
REQUIRE 70 NEW!ITEMS;
REQUIRE 160 STRING!PDL;
REQUIRE 512 STRING!SPACE; COMMENT THIS IS THE BUFFER-SIZE FOR EXPANSION!;


INTERNAL SIMPLE PROCEDURE OUTSCR(STRING S);
COMMENT
	APPEND A CARRIAGE RETURN AND LINE FEED TO S
	AND CALL OUTSTR WITH THE RESULT.
;
BEGIN
	OUTSTR(S&CRLF);
END "OUTSCR";


INTERNAL SIMPLE PROCEDURE OUTCR(INTEGER C;STRING S);
COMMENT
	APPEND A CARRIAGE RETURN AND LINE FEED TO S
	AND OUTPUT THE RESULT ON CHANNEL C.
;
BEGIN
	OUT(C,S&CRLF);
END "OUTCR";




INTERNAL SIMPLE PROCEDURE TYPEFORMERROR(INTEGER I);
BEGIN
	ERROR((IF I<0 THEN "ARGUMENT" ELSE (IF NAME[I] = " "
		THEN "TEMP" ELSE IF TYPE[I]=CONSTANT THEN
                FANCYNUM(REL(VALUE[I])) ELSE NAME[I]))&
		" IS NOT OF THE APPROPRIATE TYPE OR FORM!");
END;


INTERNAL INTEGER SIMPLE PROCEDURE STORECON(REAL R);
BEGIN INTEGER V;
                               V_SYMTABENTRY('15&CVXSTR(INT(R)));
                               VALUE[V]_INT(R);
                               TYPE[V]_CONSTANT;
      RETURN(V);
END "STORECON";




SIMPLE PROCEDURE SYNTAXERROR(INTEGER I);
BEGIN
SETFORMAT(0,0);
ERROR("BAD SYNTAX! (ERROR#"&CVS(I)&(")"&CRLF))
END;



COMMENT "                   GETTOKEN(U,V)
                   -------------



 THIS SIMPLE PROCEDURE EXTRACTS THE NEXT TOKEN FROM THE STRING B,
REMOVING IT FROM THE FRONT OF B, AND PASSES THE NUMERIC CODE
FOR THE TOKEN BACK IN U.  WHEN THE TOKEN IS A CONSTANT OR
AN IDENTIFIER, THE ASSOCIATED SYMBOL TABLE INDEX IS PASSED
BACK IN V.

B IS ASSUMED TO BE A COMPLETE MLAB STATEMENT TERMINATED
BY A CR.  THUS B IS NOT NULL.


THE VARIOUS TOKENS ARE:

PROCESS  ROW,COL TOKEN
CASE     TOKVAL  CODE
SWITCH   VALUE
-------------------------------------
          
   -      --,--   1 IDX     IDENTIFIERS (LETTER&(LETTER+DIGIT)*)
   -      --,--   2 IDX     CONSTANTS (INT,INT.,INT.INT,.INT - ALL REAL VALUES)
   5       1, 1   3          **     ^
   7       3, 3   4          *
   8       3, 3   5          /
   4       4, 4   6          +
   4       4, 4   7          -
   4       5, 5   8          =
   4       5, 5   9          <
   4       5, 5   10         <=    =<
   4       5, 5   11         >=    =>
   4       5, 5   12         >
  45       6, 6   13         NOT
   4       7, 7   14         AND
   4       8, 8   15         OR
   6       9, 9   16         _
   1      10,10   17         , 
  --      --,--   18         UNARY+ <NOP> 
  --      16,--   19         (       [
  13      15,15   20         F      (INTERNALLY GENERATED)
  42      14,--   21         LIST   
  --      --,14   22         )      ]
  14      13,13   23         :
  11      11,11   24         &
  12      11,11   25         &'
   9      12,12   26         ROW
   9      12,12   27         COL
  10      --,16   28         '
   3      --, 0*  29         INIT   INITIAL  * MEANS THE TOKEN IS A PREFIX OPERATOR.  IT GOES RIGHT TO PROCESSS!
   3      --, 0*  30         FCT    FUNCTION
  15      18,--   31         FIT
  22      20,19   32         TO
  23      23,22   33         BY
  26      17,17   34         WT     WEIGHT
  24      19,18   35         IN
  27      26,--   36         DRAW  
  25      24,23   37         AT
  29      22,21   38         IMAGE
  28      22,21   39         WINDOW
  18      22,21   40         DELETE DEL
  17      22,21   41         TYPE
  16      22,21   42         HELP
  30      22,21   43         INSCRIBE
  31      22,21   44         UNSCRIBE
  20      22,21   45         BLANK  QUIET
  21      22,21   46         UNBLANK
  27      26,--   47         STRING
  32      21,20   48         SIZE
  33      22,21   49         SAVE
  34      22,21   50         USE
  43      --,27   51         CR (INTERNALLY ^A IS USED)
  41      22,21   52         PLOT
  44       2, 2   53         UNARY-
  35      27,24   54         PT         POINTTYPE
  36      27,24   55         LINE       LINETYPE
  37      28,25   56         LABEL      
  38      29,26   57         WITH
  51      31,28   58         DIFF    
  49      22,21   59         CONSTRAINTS
   2       2, 2	  60	     ABS
  39      28,25   61         XFLOATING
  40      28,25   62         YFLOATING
  46      26,--   63         PRINTERDRAW
  46      26,--   64         TTYDRAW    
  48      22,21   65         EXIT
  57      22,17   66         DO  
  50      --, 0*  67         FOR
          30,--   68         <STACKBOTTOM> (INTERNALLY GENERATED)
  52      32,--   69         IF
  53      32,29   70         THEN
  54      33,29   71         ELSE
  55      22,21   72         GET
  56      22,21   73         RELEASE
  --      10,30   74         <SEMICOLON>
  47      20,15   75         ON
  19      27,24   76         INTENSITY
  58      22,21   77         PRINT
  --      --,--   78         END
";





INTERNAL SIMPLE PROCEDURE GETTOKEN(REFERENCE INTEGER U,V);
BEGIN
INTEGER T,XT;
STRING TSTR;
REAL R;
INTEGER I;
LABEL L1,L2,L3,L4,X,OUT;

PRELOAD!WITH 3,4,5,6,7,8,9,
             12,16,17,74,19,22,23,24,28;

SAFE OWN INTEGER ARRAY TOKCODE[1:16];


DEFINE OPST="""^*/+-=<>_,;():&'""";

L1: IF B='40 OR B='11 THEN BEGIN T_LOP(B);GO TO L1 END;

    IF ("0" LEQ B  LEQ "9") OR B="." THEN BEGIN
    R_REALSCAN(B,BRCHAR); 
    IF BRCHAR > 0 THEN BEGIN
                               U_CONST;
                               V_STORECON(R);
                               RETURN         END;
    SYNTAXERROR(1) END;

    TSTR_SCAN(B,2,BRCHAR);
    IF LENGTH(TSTR) THEN BEGIN V_SYMTABENTRY(TSTR); 
                            IF TYPE[V]=OPERATOR THEN 
                            U_VALUE[V] ELSE 
                            U_ID;  RETURN      END;
    T_LOP(B);
    IF T="*" THEN IF B="*" THEN BEGIN U_POWEROP; GOTO L2  END;
   



   IF T="=" THEN IF B="<" THEN BEGIN L3:U_LEQOP;GOTO L2 END
   ELSE IF B=">" THEN BEGIN L4:U_GEQOP; GOTO L2  END;


   IF T="&" THEN IF B="'" THEN BEGIN U_CATTRANSP;
                                  L2: XT_LOP(B);  RETURN  END;

   IF T="[" THEN T_"(";
   IF T="]" THEN T_")";
   IF T = '01 THEN BEGIN U_CR; RETURN END;

   IF T="""" THEN
                BEGIN STRING Q;
                     TSTR_"*";
                   X:IF B='01 THEN SYNTAXERROR(2);
                     Q_LOP(B);
                     IF Q="""" THEN IF B NEQ """" THEN GOTO OUT
                               ELSE XT_LOP(B);
                     TSTR_TSTR&Q;
                     GOTO X;
                 OUT:V_SYMTABENTRY(TSTR);
                     TYPE[V]_TEXT;
                     U_ID;
                     RETURN
               END;

   IF B="=" THEN IF T=">" THEN GOTO L4 ELSE IF T="<" THEN GOTO L3;


   "   CODE THE SINGLE CHAR TOKEN IN T"


    FOR I_1 STEP 1 UNTIL LENGTH(OPST) DO
        IF OPST[I FOR 1]=T THEN BEGIN
                                U_TOKCODE[I]; RETURN END;

    SYNTAXERROR(3)

END "GETTOKEN";
INTERNAL SIMPLE PROCEDURE PUSH(INTEGER ARG);
COMMENT
	PUSH ARG ONTO STACK.
	CHECK FOR OVERFLOW.
;
BEGIN
	IF (I_I+1) > SIZEP THEN
		ERROR("OPERAND STACK OVERFLOW");
	P[I]_ARG;
END;



INTERNAL SIMPLE PROCEDURE POP( REFERENCE INTEGER ARG);
COMMENT
	POP STACK INTO ARG.
	CHECK FOR BOUNDS ERROR.
;
BEGIN
	IF I < 0 THEN SYNTAXERROR(13);
	ARG_P[I];
	I_I-1;
END;



INTERNAL SIMPLE PROCEDURE NEWNODE(REFERENCE INTEGER Q;SAFE INTEGER ARRAY A);
COMMENT
	RETURN THE ADDRESS OF A NEW NODE IN ARRAY.
;
BEGIN
	IF (Q_A[0])=0 THEN ERROR("NO SPACE") ELSE A[0]_A[Q];
END;



INTERNAL SIMPLE PROCEDURE FREENODE(INTEGER Q;SAFE INTEGER ARRAY A);
COMMENT
	FREE THE NODE IN A INDEXED BY Q.
;
BEGIN
	A[Q]_A[0]; A[0]_Q;
END;
INTERNAL SIMPLE PROCEDURE FREET(INTEGER I);
COMMENT
	FREE A SYMTAB ENTRY IF IT IS A TEMPORARY.
	CALL:	I = INDEX OF SYMTAB ENTRY
;

BEGIN
        LABEL FREEIT;
       INTEGER T;

	IF (TEMPSTRING_NAME[I]) NEQ " " THEN IF TEMPSTRING="*" THEN GOTO FREEIT ELSE RETURN;
          IF LENGTH(TEMPSTRING)>1 THEN T_NAME[I][2 FOR 1] ELSE 
             BEGIN OUTSCR("FISHY TEMP FREEING!"); GOTO FREEIT END;
	IF TYPE[I] = MATRIX THEN DELETE(CVI(VALUE[I]));
	IF TYPE[I] = COLON THEN FREENODE(IDX[I],NODE);
          IF T=TEMPCHR-1 THEN BEGIN
                         TEMPCHR_TEMPCHR-1;
                         IF T=HIFREE+1 THEN BEGIN
                                  TEMPCHR_TEMPCHR-SPANFREE;
                         HIFREE_SPANFREE_0  END
                              END
                         ELSE BEGIN
                              SPANFREE_SPANFREE+1;
                              IF HIFREE <T THEN HIFREE_T
                              END;
          FREEIT:NAME[I]_" ";
END;




RECURSIVE PROCEDURE WALK(INTEGER I);
IF I LEQ 0 THEN 
BEGIN
      INTEGER J,K;
       LABEL M;

I_-I;

IF (K_NODE[I])=FUNCTIONF THEN BEGIN J_I; WHILE (J_NODE[J+1]) DO
                                     BEGIN WALK(NODE[J]);
                                           NODE[J]_NODE[J]+MARK
                                     END;
                                     GOTO M
                              END;
WALK(NODE[I+1]);
IF K=IFOP THEN BEGIN WALK(-NODE[I+2]); GOTO M END;
IF NOT UNARYOP(K) THEN WALK(NODE[I+2]);

M:
NODE[I]_K+MARK;
END "WALK";



SIMPLE PROCEDURE CLEANUP;
BEGIN
      INTEGER I,J,K;
      STRING S;

FOR I_0 STEP 1 UNTIL SYMTABSIZEM1 DO
BEGIN IF LENGTH(S_NAME[I])>0 AND NOT(EQU(S," ")) THEN
      BEGIN
            IF (I1_TYPE[I])=FUNCTION OR I1=INITIAL THEN BEGIN J_IDX[I];
                                           IF (D2_A[D1_NODE[J+1]+14])<MARKED THEN A[D1]_D2+MARK;
                                           K_NODE[J];
                                           NODE[J]_K+MARK;
                                           WALK(-K)
                                     END
            ELSE IF I1=WINDOW OR I1=CURVE THEN
               A[IDX[I]+14]_A[IDX[I]+14]+MARK
      ELSE IF S=" " THEN BEGIN
                         IF I1=ROW THEN TYPE[I]_COL;
                         "MUST DO THIS TO AVOID GRATUITOUS DELETION OF ROWS!"
                         DELETEENTRY(I) END;
      END
END;

NODE[0]_0;
FOR I_1 STEP 3 UNTIL SIZENODEM1 DO
    IF NODE[I]>MARKED THEN NODE[I]_NODE[I]-MARK
                      ELSE BEGIN FREENODE(I,NODE);
                                 NODE[I+2]_0
                           END;
A[0]_0;
FOR I_1 STEP 15 UNTIL SIZEAM1 DO IF A[I+14]>MARKED THEN
                                   A[I+14]_A[I+14]-MARK  ELSE FREENODE(I,A);

END "CLEANUP";
COMMENT "                 SYMTABENTRY(X)
                  ---------------


THIS SIMPLE PROCEDURE HASHES THE IDENTIFIER(OR CONSTANT)
 X AND FINDS THE MATCHING SYMTAB INDEX, OR IF NECESSARY
 ASSIGNS A NEW INDEX, THUS CREATING A NEW ENTRY.

NAME[I] IS THE KEY FIELD OF THE ITH ENTRY.

NAME[I]=NULL IF THE I TH ENTRY IS EMPTY.
NAME[I]=" " IF THE I TH ENTRY HAS BEEN DELETED.
NAME[I]= A NAME STRING OTHERWISE.

LINEAR VARIABLE STEPSIZE OPEN ADDRESSING COLLISION
RESOLUTION IS USED.


";

INTERNAL INTEGER SIMPLE PROCEDURE SYMTABENTRY(STRING X);

BEGIN
INTEGER I,J,K;

K_0;
J_(I_HASH(X));
WHILE NOT(LENGTH(NAME[I])=0 OR EQU(NAME[I],X)) DO
      BEGIN IF EQU(NAME[I]," ") AND K=0 THEN K_I;
      I_(I+J)MOD SYMTABSIZE  END;

IF I=0 AND  K=0 THEN ERROR("SYMTAB FULL");
IF LENGTH(NAME[I])=0 THEN BEGIN  IF K THEN I_K; NAME[I]_X;
                                TYPE[I]_UNKNOWN; VALUE[I]_'400000000001;    END;

RETURN(I)

END "SYMTABENTRY";
SIMPLE PROCEDURE INITSYMTAB;
BEGIN
FOR I_1 STEP 1 UNTIL NINITSYMS DO BEGIN VALUE[J_SYMTABENTRY(ST[I])]_OP[I];
                                         ST[I]_NULL;
                                         TYPE[J]_IF I LEQ NBUILTINS THEN -I+1 ELSE OPERATOR
                                 END;
ZERO_SYMTABENTRY('15&CVXSTR(0.)); VALUE[ZERO]_INT(0.); TYPE[ZERO]_CONSTANT;
ONE_SYMTABENTRY('15&CVXSTR(INT(1.))); VALUE[ONE]_INT(1.); TYPE[ONE]_CONSTANT;
TEMPH_SYMTABENTRY("1H"); TYPE[TEMPH]_INITIAL;
TEMPDH_SYMTABENTRY(".1H.1T"); TYPE[TEMPDH]_FUNCTION;
SUMOP_SYMTABENTRY("SUM");
INTEGRALOP_SYMTABENTRY("INTEGRAL");
IGRATEOP_SYMTABENTRY("INTEGRATE");
LLOKUPOP_SYMTABENTRY("LOOKUP");
ROOTOP_SYMTABENTRY("ROOT");
END;
PROCEDURE GOHOME; GOTO HOME;

SIMPLE INTEGER PROCEDURE ERRHANDLER(INTEGER ADR; STRING SAILMSG,USERERRRESPONSESTRING);
BEGIN

SIMPLE INTEGER PROCEDURE ERRNO(STRING S);
BEGIN
DEFINE NMSGS="8";
PRELOAD!WITH "Invalid index for array",
             "DATUM OF ARRAY NOT",
             "NO ROOM FOR ARRAY",
	     "ARRAY no room",
             "I-O DEVICE ERROR",
             "LOOKUP OR ENTER: INVALID",
             "NUMIN:",
             "ARRAY lower bound gtr",
             NULL;
SAFE OWN STRING ARRAY MSGS[0:NMSGS];
INTEGER I,L; 

FOR I_0 STEP 1 UNTIL NMSGS DO IF LENGTH(S) GEQ (L_LENGTH(MSGS[I])) 
                                 AND EQU(S[1 FOR L],MSGS[I]) THEN RETURN(I);
END "ERRNO";

LABEL CALLGOHOME;
INTEGER CONTINUABLE;
STRING S;

CONTINUABLE_FALSE;

CASE ERRNO(S_SAILMSG[3 TO INF]) OF BEGIN
OUTSCR("ILLEGAL INDEX FOR MATRIX");
OUTSCR("BAD TYPE:NOT A MATRIX");
OUTSCR("CORE NOT AVAILABLE");
OUTSCR("CORE NOT AVAILABLE");
OUTSCR("READ ERROR");
OUTSCR("ILLEGAL FILE NAME. FIX AND RETRY");
OUTSCR("TRYING TO SCAN ILLEGAL NUMBER STRING");
BEGIN CONTINUABLE_TRUE; "DO NOTHING" END;
BEGIN OUTSTR(S);
IF (MEMORY[ADR] LAND '40000000) NEQ 0 THEN CONTINUABLE_TRUE;  
END
                       END;
!ERRJ!_IF CONTINUABLE THEN 0 ELSE LOCATION(CALLGOHOME);
RETURN('3000000+"C"); "THIS TELLS THE ERRMSG CODE TO SHUT-UP AND RETURN (TO CALLGOHOME IF WE HAVE SO CHOSEN!)"
CALLGOHOME:GOHOME
END "ERRHANDLER";

COMMENT
"                 ERROR
                 -----


 THE ERROR PROCEDURE PRINTS ITS ERROR MESSAGE ARGUMENT
 ON THE USERS TTY AND THEN CLIMBS OUT OF WHATEVER
 PROCEDURES ARE CURRENTLY ACTIVE SO AS TO ALLOW THE
 SYSTEM TO START AFRESH IN PROCESSING THE NEXT COMMAND.


";

SIMPLE INTERNAL PROCEDURE ERROR(STRING S); USERERR(0,0,S);

IFC NOT TENEXSW THENC

INTEGER REENTERFLAG;

SIMPLE PROCEDURE REENTER;
 BEGIN LABEL T; 
	REENTERFLAG_TRUE;
 START!CODE
T:	PUSH '17,0;
	JRST T;
 END;END;

SIMPLE PROCEDURE PDLOVHANDLER;
 BEGIN INTEGER APRP,APRF; 

       EXTERNAL INTEGER JOBTPC,APRACS;

 LABEL Q;
IF NOT REENTERFLAG THEN OUTSTR("RECURSION TOO DEEP"&CRLF);

JOBTPC_LOCATION(Q);  "WAY TO GET OUT"


   "GET P STACK, AND PEAR BACK TO ITS END"
 APRP_MEMORY[LOCATION(APRACS)+'17];
 APRP_(APRP LAND '777777)-((APRP LSH -18) LAND '777777);
 APRF_MEMORY[LOCATION(APRACS)+'12] LAND '777777;
 IF APRP-APRF < 9 THEN BEGIN "UNWIND ONE RECORD BY HAND"
	APRF_MEMORY[APRF];  "BACK UP F REGISTER"
	MEMORY[LOCATION(APRACS)+'12]_APRF;
 END;
 APRF_APRP-APRF-3; "AMOUNT TO SUBTRACT FROM STACK"
 APRF_(APRF LSH 18)+APRF;
 MEMORY[LOCATION(APRACS)+'17]_APRP-APRF;
 RETURN;  "ALL DONE"
 Q: GOHOME;   "PROCEDURE THAT DOES A GOTO TO TOP LEVEL"
END "PDLOVHANDLER";

ELSEC

COMMENT TENEX VERSION OF THE REENTER CODE.

	It is really quite unnecessary to cause a push-down
overflow just to get back to the top level of a program.
We can do that quite easily, as the following code indicates.

	Note that PDLOVHANDLER is implemented as a procedure
that now traps to the SAIL error handler, on the occasion of
an honest PDL overflow, not just a way to do a reenter.

			R. Smith

;

SIMPLE PROCEDURE REENTER;
BEGIN
INTEGER NEWP,NEWRF;
OWN INTEGER ARRAY ACS[0:'17];

START!CODE
	MOVEM	'17,ACS['17];
	MOVEI	'17,ACS[0];
	BLT	'17,ACS['16];
	HRRZ	1,ACS['17];
	HLRE	2,ACS['17];
	SUB	1,2;			COMMENT 2 is negative;
	MOVEM	1,NEWP;			COMMENT this has the effect of
					  the PDL overflow;
END;
COMMENT note this code is actually liberation from SAIL, since
	we have no stacks set up.  However, care is taken that
	we generate no subroutine calls.  (All of this could
	and perhaps should have been written in START!CODE.;

NEWRF _ ACS['12] LAND '777777;		COMMENT right hand of RF register;
IF NEWP-NEWRF < 9 THEN 
    BEGIN
	COMMENT back up one record;
	NEWRF _ MEMORY[NEWRF];
	ACS['12] _ NEWRF;
    END;
NEWRF _ NEWP - NEWRF - 3;
NEWRF _ (NEWRF LSH 18) + NEWRF;
ACS['17] _ NEWP - NEWRF;
START!CODE
	MOVSI	'17,ACS[0];
	BLT	'17,'17;
END;
GOHOME;					COMMENT now return to top-level;
END;

INTEGER REENTERFLAG;			COMMENT here for code below;

SIMPLE PROCEDURE PDLOVHANDLER;
USERERR(0,0,"Push-down overflow -- is the recursion too deep??");


ENDC  COMMENT OF TENEXSW;
SIMPLE PROCEDURE CONTYP(INTEGER I,CHANNEL);
COMMENT
	TYPE A SET OF CONSTRAINTS

	I = INDEX OF CONSTRAINTS IN SYMTAB
	CHANNEL = NUMBER OF OPEN CHANNEL FOR OUTPUT
;
BEGIN
SAFE REAL ARRAY ITEMVAR Q;
INTEGER NPARMS,J,K;
STRING S;
PRELOAD!WITH  "<","=",">"; SAFE OWN STRING ARRAY OPSTR[-1:1];


	OUTCR(CHANNEL,NAME[I]&CRLF);
	Q_CVI(VALUE[I]);
	NPARMS_COLSIZE("DATUM(Q)")-2;

	FOR J_2 STEP 1 UNTIL ROWSIZE("DATUM(Q)") DO
	BEGIN

	   S_NULL;
	   FOR K_1 STEP 1 UNTIL NPARMS DO
	   BEGIN
	   REAL R;
		IF (R_DATUM(Q)[J,K]) THEN BEGIN
		IF R>0 AND LENGTH(S)>0 THEN S_S&"+";
		IF ABS R NEQ 1.0 THEN S_S&FANCYNUM(R)&"*" ELSE IF R=-1 THEN S_S&"-";
		S_S&ST[INT("DATUM(Q)[1,K]")];
                                          END
	   END;
	   S_S&OPSTR[DATUM(Q)[J,NPARMS+1]]
		&FANCYNUM(DATUM(Q)[J,NPARMS+2])&CRLF;
	   OUT(CHANNEL,S);
	END;
END;
INTEGER SIMPLE PROCEDURE ENTEROK(STRING S);
COMMENT
	IF A FILE WITH NAME S DOES NOT EXIST ON THE DEVICE
	OPEN ON CHANNEL 1, ENTER S AND RETURN TRUE.

	IF S EXISTS, ASK THE USER WHETHER HE WANTS TO REPLACE
	IT. ENTER FILE AND RETURN TRUE IF SO. OTHERWISE,
	RETURN FALSE.
;
BEGIN
INTEGER X;
	LOOKUP(1,S,X);
	IF NOT X THEN
	BEGIN
	   OUTSTR(S&" ALREADY EXISTS! TYPE 'R' TO REPLACE,'C' TO PRESERVE:");
	   IF INCHWL NEQ "R" THEN RETURN(FALSE);
	END;
	ENTER(1,S,X); IF X THEN ERROR(S&" CANNOT BE SAVED");
	RETURN(TRUE);
END "ENTEROK";


SIMPLE PROCEDURE TYPOUT;
COMMENT

TYPE OUT THE VALUE OF EVERY ENTITY ON P STACK, OR IF NONE, THEN EVERYTHING!


        PRINTSW IS A GLOBAL INTEGER
	        = TRUE IF OUTPUT TO PRINTER REQUIRED
 		= FALSE IF OUTPUT TO TTY REQUIRED


;
BEGIN
INTEGER TYP,CHANNEL,EE,K,II,FILNUM;
STRING S;
SAFE REAL ARRAY ITEMVAR Q;
PRELOAD!WITH 
"BUILTIN",
"UNKNOWN","CONSTANT","OPERATOR","SCALAR","FUNCTION","MATRIX",
"WINDOW","CURVE","INITIAL","COLON"," ","ROW","COL","SUBSCR",
"","CONSTRAINTS";
SAFE OWN STRING ARRAY TYPLST[0:16];
COMMENT NOTE THE 'TITLE' OF THE TYPE 'TEXT' IS BLANK!  THIS MAKES
FOR NICE PRINTING OF MESSAGES.;
LABEL START,VALTYPE,FCTOUT,ENDUP,FINISHALLSYMS;

	IF PRINTSW THEN
	BEGIN
	   CHANNEL_1;
	   OPEN(CHANNEL,"DSK",0,0,2,0,0,EE);
           IF WINDOWIDX NEQ 0 THEN 
BEGIN S_NAME[WINDOWIDX];IF TYPE[WINDOWIDX]=UNKNOWN THEN DELETEENTRY(WINDOWIDX) END 
ELSE S_CVS(FILNUM_FILNUM+1);
           ENTER(CHANNEL,S&".LST",EE);  "OK FOR LPT IN ANY EVENT"
	END
	ELSE CHANNEL_6;

IF I<0 THEN FOR II_0 STEP 1 UNTIL SYMTABSIZEM1 DO
                BEGIN 
               IF LENGTH(S_NAME[II])>0 THEN 
               IF NOT(EQU(S," ")) THEN
               IF (D1_TYPE[II]) NEQ OPERATOR AND D1>UNKNOWN THEN GOTO START;
FINISHALLSYMS:END;

   FOR K_0 STEP 1 UNTIL I DO
      BEGIN
       II_E(P[K]);
START:
        TYP_TYPE[II];  S_NAME[II];
        IF TYP=UNKNOWN AND S="." THEN
           BEGIN
           DEEPDIFF(S);
           GOTO START
           END;

        IF EQU(S,"SYMBOLS") THEN BEGIN
           DELETEENTRY(II);
           FOR I1_0 STEP 1 UNTIL SYMTABSIZEM1 DO
               IF LENGTH(S_NAME[I1])>0 THEN 
               IF NOT(EQU(S," ")) THEN
               IF (D1_TYPE[I1]) NEQ OPERATOR AND D1>0 THEN
               BEGIN
               IF S=" " THEN S_S&", ERROR! ***";
               IF D1=CONSTANT THEN S_FANCYNUM(REL(VALUE[I1]));
               IF D1=FUNCTION THEN S_FIXNAME(S);
                  OUT(CHANNEL,CRLF&S&", "&TYPLST[D1]);
               END;
           OUT(CHANNEL,CRLF);
           GO TO ENDUP   END;


       IF TYP LEQ 0 THEN TYP_0;
	OUT(CHANNEL,CRLF&TYPLST[TYP]&" ");
        SETFORMAT(0,7);
	CASE TYP OF 
	BEGIN
		COMMENT BUILTIN (CASE 0); OUT(CHANNEL,S);
		GOTO VALTYPE;
	VALTYPE:   OUT(CHANNEL,"="&CVG(REL(VALUE[II])));
		COMMENT OPERATOR;  ;
		OUT(CHANNEL,(IF S = " " THEN NULL ELSE S)&
		      " = "&CVG(REL(VALUE[II])));
                COMMENT FUNCTION;
	FCTOUT:	OUT(CHANNEL,FCTTYPE(II));
		BEGIN
		   OUTCR(CHANNEL,(IF S = " " THEN NULL ELSE S)
		   &":"&CRLF);
		   Q_CVI(VALUE[II]);
		   FOR D1_1 STEP 1 UNTIL ROWSIZE("DATUM(Q)") DO
		   BEGIN
			S_" *"&CRLF;
			FOR D2_COLSIZE("DATUM(Q)") STEP -1 UNTIL 1 DO
			   S_CVG(DATUM(Q)[D1,D2])&S;
			OUT(CHANNEL,S);
		   END;
		END;
		WINTYP(II,CHANNEL);
		COMMENT CURVE;	CURTYP(II,CHANNEL);
		COMMENT INITIAL;	GOTO FCTOUT;
		COMMENT COLON;	;
		COMMENT COLON2;	;
		COMMENT ROW;	;
		COMMENT COL;	;
		COMMENT SUBSCR;	;
		COMMENT TEXT; OUT(CHANNEL,S[2 TO INF]);
		COMMENT CONSTRAINTS;	CONTYP(II,CHANNEL);
	END;
        OUT(CHANNEL,CRLF);
        IF I<0 THEN GOTO FINISHALLSYMS;
	FREET(II);
      END;
ENDUP: I_-1;
	IF PRINTSW THEN RELEASE(CHANNEL);
END "TYPOUT";
INTERNAL SIMPLE PROCEDURE SAVSTR(STRING S);
COMMENT  SAVE THE STRING S ON THE DEVICE OPEN ON CHANNEL 1
;
BEGIN
INTEGER L,I;

L_LENGTH(S);
WORDOUT(1,L);
FOR I_1 STEP 5 UNTIL L DO WORDOUT(1,CVASC(S[I TO INF]));
END "SAVSTR";





INTERNAL STRING SIMPLE PROCEDURE USESTR;
COMMENT  RECOVER THE STRING S FROM THE DEVICE OPEN ON CHANNEL 1
;
BEGIN
INTEGER L,I;
STRING S;

L_WORDIN(1);
COMMENT  IF WE ARE AT EOF, L IS RETURNED AS 0.;
S_NULL;
FOR I_1 STEP 5 UNTIL L DO S_S&CVSTR(WORDIN(1));
IF L>0 THEN S_S[1 TO L];
RETURN(S);
END "USESTR";

INTERNAL SIMPLE PROCEDURE MATOUT(INTEGER M);
COMMENT
	SAVE A MATRIX

	M = NUMBER OF ITEM WITH DATUM = MATRIX

	IF M = 0 THEN OUTPUT ARRAY BOUNDS = 0.
;
BEGIN
SAFE REAL ARRAY ITEMVAR Q;
LABEL L;

	IF M = 0 THEN BEGIN L: WORDOUT(1,0); RETURN END;

	Q_CVI(M);
	IF SIZE("DATUM(Q)") = 0 THEN GO TO L;
	WORDOUT(1,ROWSIZE("DATUM(Q)"));
	WORDOUT(1,COLSIZE("DATUM(Q)"));
	ARRYOUT(1,DATUM(Q)[1,1],SIZE("DATUM(Q)"));
END;


INTERNAL INTEGER PROCEDURE MATIN;
COMMENT
	INPUT A MATRIX

	RETURN:	NUMBER OF ITEM WITH DATUM = MATRIX 
		OR 0 IF NO MATRIX SAVED
;
BEGIN
SAFE REAL ARRAY ITEMVAR Q;
INTEGER I,J;

	I_WORDIN(1);
	IF I = 0 THEN RETURN(0);
	J_WORDIN(1);
	BEGIN
	SAFE REAL ARRAY AR[1:I,1:J];

	   ARRYIN(1,AR[1,1],I*J);
	   Q_NEW(AR);
	   RETURN(CVN(Q));
	END;
END;



STRING SIMPLE PROCEDURE DIFFFILENAME(STRING S);
BEGIN STRING G;
      G_NULL;
      FOR D1_1 STEP 1 UNTIL LENGTH(S) DO G_G&(IF (D2_S[D1 FOR 1])="." THEN "0" ELSE D2);
       RETURN(G)
END;
SIMPLE PROCEDURE DSKSAV;
COMMENT
	SAVE THE ENTITIES IN LOCATIONS 0 THRU I ON THE P 
	STACK.  IF WINDOWIDX NEQ 0 SAVE EVERYTHING IN A
        FILE NAMED NAME[WINDOWIDX]&".DAT".  OTHERWISE,
        FOR EACH ENTITY K USE NAME[K]&".DAT" AS THE FILE
 	NAME.
        IF I=-1 THEN SAVE EVERYTHING!
;
BEGIN
SIMPLE PROCEDURE DSKSAVER(INTEGER I);
COMMENT

SAVE THE INFORMATION ASSOCIATED WITH A SYMTAB
ENTRY ON "DSK"

	I = SYMTAB INDEX

        THE APPROPRIATE FILE SHOULD BE ENTERED ON CHANNEL 1
        WHEN DSKSAVER IS CALLED.
;
BEGIN
INTEGER IJ,TYP;
SAFE REAL ARRAY ITEMVAR Q;
LABEL ENDUP;


	TYP_TYPE[I];
	WORDOUT(1,TYP);
	IF TYP=SCALAR THEN
	BEGIN
	   WORDOUT(1,VALUE[I]);
	   GO TO ENDUP;
	END;

	IF TYP=MATRIX THEN
	BEGIN
	Q_CVI(VALUE[I]);
        WORDOUT(1,1);
        WORDOUT(1,ROWSIZE("DATUM(Q)"));
        WORDOUT(1,1);
        WORDOUT(1,COLSIZE("DATUM(Q)"));
	ARRYOUT(1,DATUM(Q)[1,1],SIZE("DATUM(Q)"));
	GO TO ENDUP;
	END;
        IF TYP=WINDOW THEN BEGIN WINSAV(I); GOTO ENDUP END;

        IF TYP=FUNCTION OR TYP=INITIAL THEN BEGIN
           COMMENT OUTPUT STRING OF FUNCTION;
      SAVSTR(FCTTYPE(I));
	GO TO ENDUP;
                             END;
	IF TYP = CONSTRAINTS THEN
	BEGIN
	   SAFE INTEGER ARRAY ITEMVAR Q1;
	   IJ_VALUE[I];
	   MATOUT(IJ);
	   Q1_CVI(IJ);
	   FOR I_1 STEP 1 UNTIL COLSIZE("DATUM(Q1)")-2 DO
		SAVSTR(ST[DATUM(Q1)[1,I]]);
	END;


ENDUP: END;


INTEGER K,Z,TYP,J,Y;
STRING N,DEVICE;
LABEL L,L1;


	FOR K_0 STEP 1 UNTIL I DO
	BEGIN
	   COMMENT CHECK FOR ILLEGAL THINGS TO SAVE;
	   J_P[K];
	   WHILE (TYP_TYPE[J])=UNKNOWN AND (N_NAME[J])="." DO DEEPDIFF(N);
;
	   IF (TYP < SCALAR OR TYP=CURVE OR TYP
               > INITIAL AND TYP NEQ CONSTRAINTS) THEN
              TYPEFORMERROR(J);
	   IF NAME[J] = " " THEN 
	   BEGIN
	      FREET(J);  TYPEFORMERROR(J)
	   END;
	END;

	IF WINDOWIDX = 0 THEN
	BEGIN	COMMENT INDIVIDUAL FILES;
	   FOR K_0 STEP 1 UNTIL I DO
	   BEGIN
	      J_P[K];
	      N_DIFFFILENAME(NAME[J])&".DAT";
	      COMMENT OPEN CHANNEL 1 IN IMAGE MODE;
	      OPEN(1,"DSK",'13,0,2,Z,Z,Z);
              IF NOT ENTEROK(N) THEN GO TO L;
              DSKSAVER(J);
	      CLOSE(1);RENAME(1,N,'155,Z);RELEASE(1);
              L:
           END;
	   I_-1;
	   RETURN;
	END;


	COMMENT SAVE EVERYTHING ON ONE FILE;
	IF (N_NAME[WINDOWIDX]) = "*" THEN Y_LOP(N);
	DEVICE_SCAN(N,2,Y);
	IF Y = ":" THEN Y_LOP(N) ELSE
	BEGIN
   	   N_DEVICE&N;
	   DEVICE_"DSK";
	END;
	N_N&".DAT";

	IF TYPE[WINDOWIDX] = UNKNOWN OR TYPE[WINDOWIDX] = TEXT
          THEN DELETEENTRY(WINDOWIDX);
	OPEN(1,DEVICE,'13,0,2,Z,Z,Z);
	IF NOT ENTEROK(N) THEN GO TO L1;
	WORDOUT(1,SAVEBUNDLE);

	FOR K_0 STEP 1 UNTIL I DO
	BEGIN
          J_P[K];
	   SAVSTR(NAME[J]);
	   DSKSAVER(J);
	END;

        COMMENT IF I=-1 THEN THE COMMAND WAS: SAVE IN F (I.E. SAVE EVERYTHING!);
        IF I<0 THEN FOR K_0 STEP 1 UNTIL SYMTABSIZEM1 DO
           IF (DEVICE_NAME[K]) NEQ " " AND
              (SCALAR LEQ (J_TYPE[K]) LEQ WINDOW OR J=INITIAL OR J=CONSTRAINTS)
              AND NOT (EQU(DEVICE,"1H") OR EQU(DEVICE,".1H.1T"))  THEN
              BEGIN SAVSTR(NAME[K]); DSKSAVER(K) END;

	CLOSE(1);RENAME(1,N,'155,Z);RELEASE(1);L1: I_-1;
END;
PROCEDURE DSKUSE;
COMMENT
	USE THE ENTITIES IN LOCATIONS 0 THRU I ON THE
	P STACK.
;
BEGIN
PROCEDURE DSKUSER(INTEGER I,TYP);
COMMENT

RETRIEVE THE INFORMATION ASSOCIATED WITH A SYMTAB
ENTRY FROM "DSK"

	I = SYMTAB INDEX
	TYP = TYPE OF SYMTAB ENTRY

;
BEGIN
INTEGER II,L,RBD,CBD;
STRING S;
SAFE REAL ARRAY ITEMVAR Q;
LABEL ENDUP;
        IF TYP>SAVEBUNDLE THEN ERROR(NAME[I]&" ILLEGAL SAVE FILE");
        WHILE TYPE[I] NEQ UNKNOWN DO I_SYMTABENTRY(NAME[I]&"A");
      TYPE[I]_TYP;
	IF NUMBER(TYP) THEN
	BEGIN
	   VALUE[I]_WORDIN(1);
	   GO TO ENDUP;
	END;
	IF TYP = MATRIX THEN
	BEGIN
        RBD_WORDIN(1); RBD_WORDIN(1);
        CBD_WORDIN(1); CBD_WORDIN(1);
	BEGIN
	SAFE REAL ARRAY P[1:RBD,1:CBD];
	   II_RBD*CBD;
	   ARRYIN(1,P[1,1],II);
	   Q_NEW(P);
	   VALUE[I]_CVN(Q);
	END;
	GO TO ENDUP;
	END;
  
        IF TYP=WINDOW THEN BEGIN WINUSE(I); GOTO ENDUP END;

        IF TYP=FUNCTION OR TYP=INITIAL THEN BEGIN
           COMMENT READ IN FUNCTION STRING AND STICK IT ON
                   THE FRONT OF B FOLLOWED BY A SEMICOLON
                   OR INTERNAL CR CODE;
        S_USESTR;
           B_(IF TYP=FUNCTION THEN "FCT " ELSE "INITIAL ")&S&(IF LENGTH(B) NEQ 0 THEN ";"&B ELSE '01);
           U_SEMICOLON;
           TYPE[I]_UNKNOWN;
	GO TO ENDUP;
                             END;
	IF TYP = CONSTRAINTS THEN
	BEGIN
	   L_VALUE[I]_MATIN;
	   Q_CVI(L);
	   FOR TYP_1 STEP 1 UNTIL COLSIZE("DATUM(Q)") -2 DO
	   BEGIN
		STUFFST(L,USESTR);
	 	DATUM(Q)[1,TYP]_REL(L);
	   END;
	END;



ENDUP:	
END "DSKUSER";


INTEGER L,K,II,EOF1,TYP,J;
LABEL ERR;
STRING N,S,T,DEVICE;


	FOR K_0 STEP 1 UNTIL I DO
	BEGIN

        J_P[K];
	IF (S_NAME[J]) = " " THEN ERR:SYNTAXERROR(16); 

        N_DIFFFILENAME(S);

        IF N="*" THEN BEGIN
                         II_LOP(N);
                         DEVICE_SCAN(N,2,II);
                         IF II = ":" THEN II_LOP(N) ELSE BEGIN N_DEVICE&N; DEVICE_"DSK" END;
                         L_LENGTH(N);  II_1; TYP_TRUE;
                      WHILE II LEQ L AND N[II FOR 1] NEQ "["
                            DO BEGIN IF N[II FOR 1]="." THEN BEGIN TYP_FALSE; DONE END; II_II+1; END;
                      S_N[1 TO II-1];
                      DELETEENTRY(J);
                     IF TYP THEN N_S&".DAT"&(IF II LEQ L THEN N[II TO INF]
                                 ELSE NULL);
                      END
                  ELSE BEGIN N_N&".DAT"; DEVICE_"DSK" END;





COMMENT OPEN CHANNEL 1 IN IMAGE MODE;
	OPEN(1,DEVICE,'13,2,0,II,II,EOF1);
COMMENT LOOK UP ENTRY;
	LOOKUP(1,N,II);
	IF II THEN ERROR(N&" NOT SAVED");
	TYP_WORDIN(1);
	IF TYP NEQ SAVEBUNDLE THEN
            BEGIN IF TYPE[J_SYMTABENTRY(S)] NEQ UNKNOWN THEN BEGIN DELETEENTRY(J); OUT(6,"(REPLACING)") END;
	  DSKUSER(SYMTABENTRY(S),TYP) END
	ELSE
        BEGIN
           OUT(6,"USING:");
           II_FALSE;
           WHILE LENGTH((T_USESTR)) NEQ 0 DO
           BEGIN
            OUT(6,IF II THEN "," ELSE NULL);
           IF TYPE[J_SYMTABENTRY(T)] NEQ UNKNOWN THEN BEGIN DELETEENTRY(J); OUT(6,"(REPLACING)") END;
 	   DSKUSER(SYMTABENTRY(T),WORDIN(1));
           OUT(6,IF T="." THEN FIXNAME(T) ELSE T);
           II_TRUE;
           END;
	END;
           OUT(6,CRLF);
        END;
	I_-1;
        CLOSE(1); RELEASE(1);
END;
SIMPLE PROCEDURE HELPPAGE(INTEGER G,BATCH);
COMMENT  
         TYPE PAGE G FROM THE SOS FILE SYS:MLABD.TXT.
         START WITH BLOCK NUMBER BATCH.
        STOP EVERY BLOCK AND WAIT FOR A GOAHEAD CHAR
         TO BE TYPED.  "Q" MEANS QUIT TYPING AND RETURN.
         N,M MEANS PUSH DOWN TO PAGE N, BLOCK M.
    "R" MEANS POP UP TO THE PREVIOUS PENDING PAGE.
         ANYTHING ELSE (CR) MEANS TYPE THE NEXT BLOCK.
;

BEGIN
LABEL POPUP,READ,DONE,SETUP;
STRING S;
INTEGER EOF,I,W,J,K,LCT;
OWN SAFE INTEGER ARRAY STACK[1:12];

J_0;

OPEN(1,MASTERDEVICE,0,1,0,200,W,EOF);
SETUP:
LOOKUP(1,"MLABD.TXT"&MASTERPPN,EOF);
IF EOF THEN ERROR("CANNOT READ HELP FILE");

FOR I_1 STEP 1 UNTIL G-1 DO BEGIN
    DO INPUT0(1,11) UNTIL W='14 OR EOF;
    IF EOF THEN ERROR("CANNOT GET PAGE IN HELP FILE")
                            END;

    FOR K_2 STEP 1 UNTIL BATCH DO BEGIN
         LCT_0;
         DO BEGIN LCT_LCT+1; S_INPUT(1,11) END UNTIL (S=" " OR S='14) AND LCT GEQ 6;
                                  END;
LCT_0;
READ:
    S_INPUT(1,11); LCT_LCT+1;
    IF W='14 OR EOF THEN GOTO POPUP;
    OUT(6,S);
    IF LCT<6 OR (S NEQ " " AND LENGTH(S) NEQ 0) THEN GOTO READ;
    BATCH_BATCH+1; LCT_0;

S_INPUT(6,1);

IF S="Q" THEN BEGIN DONE:RELEASE(1); OUTSCR("EXIT FROM HELP FILE."); RETURN END;
IF S="R" THEN BEGIN POPUP:IF J=0 THEN GOTO DONE;
                    BATCH_STACK[J];
                    G_STACK[J_J-1];
                    J_J-1;
                    OUTSCR("PAGE "&CVS(G));
                    CLOSIN(1);
                    GOTO SETUP
              END;

IF (I_INTSCAN(S,K))>0 THEN BEGIN STACK[J_J+1]_G;
                               STACK[J_J+1]_BATCH;
                               G_I;
                               IF LENGTH(S)>1 THEN
                                 BATCH_INTSCAN(S,K) ELSE
                               BATCH_1;
                               CLOSIN(1);
                               GOTO SETUP
                           END;
GOTO READ
END "HELPPAGE";

INTERNAL INTEGER SIMPLE PROCEDURE UPUTANS(INTEGER ARG,RESULT,TYP);
COMMENT
	UNARY OPERATOR CLEANUP
	CALL:	ARG = INDEX OF ARGUMENT IN SYMTAB
		RESULT = RESULT OF OPERATION (TO BE
		         PLACED IN VALUE ARRAY)
	RETURN:	INDEX OF (TEMPORARY) RESULT ENTRY IN SYMTAB
		IF ARG IS TEMPORARY, IT IS REUSED FOR RESULT
;
BEGIN
LABEL L1,L2;
     COMMENT  THIS CODE NEEDS TO BE LIKE THIS INSTEAD
              OF USING FREET FOR AN OBSCURE REASON
              INVOLVING NON-STACK DISCIPLINE TEMPS IN
              COLCON.  BUT WITH THE SECONDARY SPAN
              BOOKEEPING IN FREET WE CAN NOW USE FREET
              ANYWAY - AND WE NEED TO FOR DOFUNCS SAKE
;

COMMENT OLD CODE 
        IF NAME[ARG] NEQ " " THEN GO TO L1.,
        IF TYPE[ARG] = MATRIX THEN DELETE(CVI(VALUE[ARG])).,
	I1_ARG.,
	GO TO L2.,
  END COMMENT;

        FREET(ARG);

L1:	I1_NEWTEMP;
L2:	VALUE[I1]_RESULT;
	TYPE[I1]_TYP;
	RETURN(I1);
END;


INTERNAL INTEGER SIMPLE PROCEDURE BPUTANS(INTEGER ARG1,ARG2,RESULT,TYP,INDEX);
COMMENT
	BINARY OPERATOR CLEANUP.
	CALL:	ARG1 = INDEX OF FIRST ARGUMENT IN SYMTAB
		ARG2 = INDEX OF SECOND ARGUMENT IN SYMTAB
		RESULT =  INTEGER TO BE PLACED IN VALUE CELL
		TYP = INTEGER TO BE PLACED IN TYPE CELL
		INDEX = INTEGER TO BE PLACED IN IDX CELL

	RETURN:	INDEX OF TEMPORARY ENTRY IN SYMTAB
	TEMPORARY ARGUMENT ENTRIES ARE FREED
;
BEGIN
        FREET(ARG1);
	FREET(ARG2);
	I1_NEWTEMP;
	VALUE[I1]_RESULT;
	TYPE[I1]_TYP;
	IDX[I1]_INDEX;
	RETURN(I1);
END;
SIMPLE PROCEDURE MATMULT(SAFE REAL ARRAY M1,M2,PROD);
COMMENT
	MATRIX PRODUCT ROUTINE
	CALCULATES PROD = M1*M2
;
BEGIN
INTEGER I,J,K,L,M,N;
REAL Q;
	I_ROWSIZE(M1);
	J_COLSIZE(M2);
	K_COLSIZE(M1);
	FOR M_1 STEP 1 UNTIL I DO
	   FOR N_1 STEP 1 UNTIL J DO
	BEGIN
	   Q_0;
	   FOR L_1 STEP 1 UNTIL K DO
	      Q_Q+M1[M,L]*M2[L,N];
	   PROD[M,N]_Q;
	END;
END;
INTERNAL  PROCEDURE SVD(INTEGER M,N;SAFE REAL ARRAY A,Q,U,V);
COMMENT
   COMPUTATION OF THE SINGULAR VALUES AND COMPLETE ORTHOGONAL
DECOMPOSITION OF A REAL RECTANGULAR MATRIX A,
                           T    T     T
            A = U DIAG(Q) V ,  U U = V V = I,
WHERE THE ARRAYS A[1:M,1:N], U[1:M,1:N], V[1:N,1:N], Q[1:N]
REPRESENT A,U,V,Q RESPECTIVELY.  M GEQ N IS ASSUMED;

BEGIN
   
   INTEGER I,J,K,L,L1,COUNT;
   REAL    C,F,G,H,S,X,Y,Z,EPS,TOL;
   SAFE REAL ARRAY E[1:N];
   LABEL TESTFSPLITTING,CANCELLATION,TESTFCONVERGENCE,CONVERGENCE;

   EPS_REL('147400000000);  COMMENT MACHINE DEPENDENT CONSTANTS;
   TOL_REL('000400000000);
   ARRBLT(U[1,1],A[1,1],M*N);

COMMENT HOUSEHOLDER'S REDUCTION TO BIDIAGONAL FORM;

   G_X_0;
   FOR I_1 STEP 1 UNTIL N DO
   BEGIN
      E[I]_G; S_0; L_I+1;
      FOR J_I STEP 1 UNTIL M DO S_S + U[J,I]^2;
      IF S < TOL THEN G_0 ELSE
      BEGIN
         F_U[I,I]; G_ IF F<0 THEN SQRT(S) ELSE -SQRT(S);
         H_F*G-S; U[I,I]_F-G;
         FOR J_L STEP 1 UNTIL N DO
         BEGIN
            S_0;
            FOR K_I STEP 1 UNTIL M DO S_S+U[K,I]*U[K,J];
            F_S/H;
            FOR K_I STEP 1 UNTIL M DO U[K,J]_U[K,J]+F*U[K,I]
         END
      END;
     Q[I]_G; S_0;
     FOR J_L STEP 1 UNTIL N DO S_S+U[I,J]^2;
     IF S < TOL THEN G_0 ELSE
     BEGIN
         IF I<N THEN BEGIN F_U[I,I+1]; G_ IF F < 0 THEN SQRT(S) ELSE -SQRT(S);
        H_F*G-S; U[I,I+1]_F-G;END;
        FOR J_L STEP 1 UNTIL N DO E[J]_U[I,J]/H;
        FOR J_L STEP 1 UNTIL M DO
        BEGIN
           S_0;
           FOR K_L STEP 1 UNTIL N DO S_S+U[J,K]*U[I,K];
           FOR K_L STEP 1 UNTIL N DO U[J,K]_U[J,K] + S*E[K];
        END
     END;
     Y_ABS(Q[I])+ABS(E[I]); IF Y > X THEN X_Y
  END;

COMMENT ACCUMULATION OF RIGHT-HAND TRANSFORMATIONS;

   FOR I_N STEP -1 UNTIL 1 DO
   BEGIN
      IF G NEQ 0 THEN
      BEGIN
         H_U[I,I+1]*G;
         FOR J_L STEP 1 UNTIL N DO V[J,I]_U[I,J]/H;
         FOR J_L STEP 1 UNTIL N DO
         BEGIN
            S_0;
            FOR K_L STEP 1 UNTIL N DO S_S+U[I,K]*V[K,J];
            FOR K_L STEP 1 UNTIL N DO V[K,J]_V[K,J] + S*V[K,I]
         END
      END;
      FOR J_L STEP 1 UNTIL N DO V[I,J]_V[J,I]_0;
      V[I,I]_1; G_E[I]; L_I;
   END;
COMMENT ACCUMULATION OF LEFT-HAND TRANSFORMATIONS;

   FOR I_N STEP -1 UNTIL 1 DO
   BEGIN
      L_I+1; G_Q[I];
      FOR J_L STEP 1 UNTIL N DO U[I,J]_0;
      IF G NEQ 0 THEN
      BEGIN
         H_U[I,I]*G;
         FOR J_L STEP 1 UNTIL N DO
         BEGIN
            S_0;
            FOR K_L STEP 1 UNTIL M DO S_S+U[K,I]*U[K,J];
            F_S/H;
            FOR K_I STEP 1 UNTIL M DO U[K,J]_U[K,J]+F*U[K,I];
         END;
         FOR J_I STEP 1 UNTIL M DO U[J,I]_U[J,I]/G
      END
      ELSE FOR J_I STEP 1 UNTIL M DO U[J,I]_0;
      U[I,I]_U[I,I]+1
   END;

COMMENT DIAGONALIZATION OF THE BIDIAGONAL FORM;

   EPS_EPS*X;
   FOR K_N STEP -1 UNTIL 1 DO
   BEGIN
   COUNT_0;
      TESTFSPLITTING:
         IF (COUNT_COUNT+1)>30 THEN ERROR("MATRIX INVERSION FAILS");
         FOR L_K STEP -1 UNTIL 1 DO
         BEGIN
            IF ABS(E[L]) LEQ EPS THEN GO TO TESTFCONVERGENCE;
            IF ABS(Q[L-1]) LEQ EPS THEN GO TO CANCELLATION
         END;


COMMENT CANCELLATION OF E[L] IF L > 1;

   CANCELLATION:
      C_0; S_1; L1_L-1;
      FOR I_L STEP 1 UNTIL K DO
      BEGIN
         F_S*E[I]; E[I]_C*E[I];
         IF ABS(F) LEQ EPS THEN GO TO TESTFCONVERGENCE;
         G_Q[I]; H_Q[I]_SQRT(F*F+G*G); C_G/H; S_-F/H;
         FOR J_1 STEP 1 UNTIL M DO
         BEGIN
            Y_U[J,L1]; Z_U[J,I];
            U[J,L1]_Y*C + Z*S; U[J,I]_ -Y*S + Z*C;
         END
      END;

   TESTFCONVERGENCE:
      Z_Q[K]; IF L=K THEN GO TO CONVERGENCE;

COMMENT SHIFT FROM BOTTOM 2*2 MINOR;

      X_Q[L]; Y_Q[K-1]; G_E[K-1]; H_E[K];
      F_((Y-Z)*(Y+Z) + (G-H)*(G+H)) / (2*H*Y); G_SQRT(F*F+1);
      F_((X-Z)*(X+Z) + H*(Y/(IF F < 0 THEN F-G ELSE F+G) - H))/X;
COMMENT  NEXT QR TRANSFORMATION;

      C_S_1;
      FOR I_L+1 STEP 1 UNTIL K DO
      BEGIN
         G_E[I]; Y_Q[I]; H_S*G; G_C*G;
         E[I-1]_Z_SQRT(F*F+H*H); C_F/Z; S_H/Z;
         F_X*C + G*S; G_-X*S + G*C; H_Y*S; Y_Y*C;
         FOR J_1 STEP 1 UNTIL N DO
         BEGIN
            X_V[J,I-1]; Z_V[J,I];
            V[J,I-1]_X*C + Z*S; V[J,I]_-X*S + Z*C;
         END;
         Q[I-1]_Z_SQRT(F*F + H*H); C_F/Z; S_H/Z;
         F_C*G + S*Y; X_-S*G + C*Y;
         FOR J_1 STEP 1 UNTIL M DO
         BEGIN
            Y_U[J,I-1]; Z_U[J,I];
            U[J,I-1]_Y*C + Z*S; U[J,I]_-Y*S + Z*C
         END
      END;
      E[L]_0; E[K]_F; Q[K]_X; GO TO TESTFSPLITTING;
   
   CONVERGENCE:

      IF Z < 0 THEN
      BEGIN
              COMMENT Q[K] IS MADE NON-NEGATIVE;
        Q[K]_-Z;
        FOR J_1 STEP 1 UNTIL N DO V[J,K]_-V[J,K]
      END
   END
END   "SVD";

REAL ARRAY ITEMVAR PROCEDURE INVERT(SAFE REAL ARRAY ITEMVAR X);
COMMENT
	CALCULATE INVERSE OR PSEUDO-INVERSE OF A MATRIX
	BY USING SINGULAR VALUE DECOMPOSITION ROUTINE SVD
;
BEGIN
   INTEGER M,N,TP,I,J,K;
  
   N_COLSIZE("DATUM(X)");
   M_ROWSIZE("DATUM(X)");
   IF M < N THEN
   BEGIN
      TP_TRUE; M SWAP N;
   END
   ELSE TP_FALSE;
   BEGIN
      SAFE REAL ARRAY A[1:M,1:N];
      BEGIN
         SAFE REAL ARRAY Q[1:N],U[1:M,1:N],V[1:N,1:N];
         IF TP THEN 
         BEGIN
            FOR I_1 STEP 1 UNTIL N DO
            FOR J_1 STEP 1 UNTIL M DO
            A[J,I]_DATUM(X)[I,J]
         END
         ELSE ARRBLT(A[1,1],DATUM(X)[1,1],M*N);
         SVD(M,N,A,Q,U,V);  "GET SINGULAR VALUE DECOMP."
         FOR I_1 STEP 1 UNTIL N DO
         FOR J_1 STEP 1 UNTIL N DO
         IF Q[I]=0 THEN V[J,I]_0 ELSE V[J,I]_V[J,I]/Q[I];
         A[1,1]_0; ARRBLT(A[1,2],A[1,1],M*N-1);
         FOR I_1 STEP 1 UNTIL N DO
         FOR J_1 STEP 1 UNTIL M DO
         FOR K_1 STEP 1 UNTIL N DO
         A[J,I]_A[J,I]+V[I,K]*U[J,K];
      END;
      IF TP THEN RETURN(NEW(A));
      BEGIN
         SAFE REAL ARRAY AT[1:N,1:M];
         FOR I_1 STEP 1 UNTIL N DO
         FOR J_1 STEP 1 UNTIL M DO
         AT[I,J]_A[J,I];
         RETURN(NEW(AT));
      END;
   END;
END;
INTERNAL SAFE REAL ARRAY ITEMVAR PROCEDURE ESM(INTEGER ROWS,COLS;REAL VAL);
COMMENT
	PRODUCE A MATRIX WITH ALL ELEMENTS EQUAL
	CALL:	ROWS = # ROWS FOR MATRIX
	        COLS = # COLUMNS
		VAL = VALUE OF MATRIX ELEMENTS
	RETURN: ITEM WITH DATUM = MATRIX
;
BEGIN
SAFE REAL ARRAY Q[1:ROWS,1:COLS];
	FOR ROWS_ROWS STEP -1 UNTIL 1 DO
	   FOR TEMP1_COLS STEP -1 UNTIL 1 DO
	   Q[ROWS,TEMP1]_VAL;
	RETURN(NEW(Q));
END;





INTERNAL SAFE REAL ARRAY ITEMVAR PROCEDURE EMM(INTEGER ROWS,COLS;SAFE REAL ARRAY M);
COMMENT
	ADD ROWS AND/OR COLUMNS OF ZEROS TO A MATRIX
	CALL:	ROWS = # ROWS FOR RESULT
		COLS = # COLUMNS FOR RESULT
		M = MATRIX TO BE EXPANDED
	RETURN:	ITEM WITH DATUM = MATRIX
;
BEGIN
INTEGER I,J;
SAFE REAL ARRAY Q[1:ROWS,1:COLS];
	FOR I_ROWSIZE(M) STEP -1 UNTIL 1 DO
	   FOR J_COLSIZE(M)  STEP -1 UNTIL 1 DO
	   Q[I,J]_M[I,J];
	RETURN(NEW(Q));
END;
INTEGER PROCEDURE BINOPS( INTEGER ARG1,ARG2,OP );
COMMENT
	BINARY OPERATORS
	EACH ARGUMENT MAY BE A MATRIX OR A SCALAR
	CALL:	ARG1 = INDEX OF FIRST ARGUMENT IN SYMTAB
		ARG2 = INDEX OF SECOND ARG IN SYMTAB
		OP = OP CODE
		   = 0 FOR +
		   = 1 FOR -
		   = 2 FOR <=
		   = 3 FOR >=
		   = 4 FOR =
		   = 5 FOR NOT =
		   = 6 FOR >
		   = 7 FOR <
		   = 8 FOR AND
		   = 9 FOR OR
;
BEGIN
INTEGER I,J,RM1,RM2,RM,CM1,CM2,CM,TYP1,TYP2;
LABEL E;
REAL X,Y,Z;
SAFE REAL ARRAY ITEMVAR U,V,M1,M2,R;
	TYP1_TYPE[ARG1];
	TYP2_TYPE[ARG2];
	IF NUMBER(TYP1) AND NUMBER(TYP2) THEN
	BEGIN
	   X_REL(VALUE[ARG1]);
	   Y _ REL(VALUE[ARG2]);
	   Z_CASE OP OF (
		X+Y,
		X-Y,
		IF X LEQ Y THEN 1 ELSE 0,
		IF X GEQ Y THEN 1 ELSE 0,
		IF X = Y THEN 1 ELSE 0,
		IF X NEQ Y THEN 1 ELSE 0,
		IF X > Y THEN 1 ELSE 0,
		IF X < Y THEN 1 ELSE 0,
		IF X NEQ 0 AND Y NEQ 0 THEN 1 ELSE 0,
		IF X NEQ 0 OR Y NEQ 0 THEN 1 ELSE 0
	);
	   RETURN(BPUTANS(ARG1,ARG2,INT(Z),SCALAR,0));
	END;
COMMENT COMPUTE DIMENSIONS OF RESULT MATRIX;
	IF TYP1 = MATRIX THEN
	BEGIN
	   U_CVI(VALUE[ARG1]);
	   RM1_ROWSIZE("DATUM(U)");
	   CM1_COLSIZE("DATUM(U)");
	END
	ELSE IF NUMBER(TYP1) THEN RM1_CM1_1
                ELSE E: TYPEFORMERROR(ARG1);

	IF TYP2 = MATRIX THEN
	BEGIN
	   V_CVI(VALUE[ARG2]);
	   RM2_ROWSIZE("DATUM(V)");
	   CM2_COLSIZE("DATUM(V)");
	END
	ELSE IF NUMBER(TYP2) THEN RM2_CM2_1
                ELSE TYPEFORMERROR(ARG2);

	RM_MAX(RM1,RM2);
	CM_MAX(CM1,CM2);

	IF TYP1 = MATRIX THEN 
	   M1_IF RM1=RM AND CM1=CM THEN U ELSE EMM(RM,CM,DATUM(U))
	  ELSE M1_ESM(RM,CM,REL(VALUE[ARG1]));

	IF TYP2 = MATRIX THEN
	   M2_ IF RM=RM2 AND CM=CM2 THEN V ELSE EMM(RM,CM,DATUM(V))
	    ELSE M2_ESM(RM,CM,REL(VALUE[ARG2]));
	BEGIN
	   SAFE REAL ARRAY AR[1:RM,1:CM];
	   FOR I_1 STEP 1 UNTIL RM DO
	   FOR J_1 STEP 1 UNTIL CM DO
	   BEGIN
		X_DATUM(M1)[I,J];
		Y_DATUM(M2)[I,J];
		AR[I,J]_CASE OP OF (
		   X+Y,
		   X-Y,
		   IF X LEQ Y THEN 1 ELSE 0,
		   IF X GEQ Y THEN 1 ELSE 0,
		   IF X = Y THEN 1 ELSE 0,
		   IF X NEQ Y THEN 1 ELSE 0,
		   IF X > Y THEN 1 ELSE 0,
		   IF X < Y THEN 1 ELSE 0,
		   IF (X NEQ 0 AND Y NEQ 0  ) THEN 1 ELSE 0,
		   IF (X NEQ 0 OR Y NEQ 0) THEN 1 ELSE 0
		   );
		END;
	   R_NEW(AR);
	   END;
	IF CVN(M1) NEQ CVN(U) THEN DELETE(M1);
	IF CVN(M2) NEQ CVN(V) THEN DELETE(M2);
	RETURN(BPUTANS(ARG1,ARG2,CVN(R),MATRIX,0));
END;
INTEGER PROCEDURE TIMES( INTEGER ARG1,ARG2);
COMMENT
	ARG1*ARG2
	CALL:	ARG1 = INDEX OF FIRST ARG IN SYMTAB
		ARG2 = INDEX OF SECOND ARG IN SYMTAB
	RETURN:	INDEX OF (TEMPORARY) RESULT IN SYMTAB
;
BEGIN
INTEGER I,J,RM1,RM2,CM1,CM2;
REAL X;
SAFE REAL ARRAY ITEMVAR M1,M2,R;
LABEL E,MS;

	I_TYPE[ARG1];
	J_TYPE[ARG2];
	IF NUMBER(I) THEN
	   IF NUMBER(J) THEN
	   BEGIN
		X_REL(VALUE[ARG1])*REL(VALUE[ARG2]);
		RETURN(BPUTANS(ARG1,ARG2,INT(X),SCALAR,0));
	   END
	   ELSE IF MATRIX = J THEN
	   BEGIN
		M1_CVI(VALUE[ARG2]);
		X_REL(VALUE[ARG1]);
		GO TO MS;
	   END
     	   ELSE E:TYPEFORMERROR(-1)
	   ELSE IF MATRIX=I THEN
	   	IF MATRIX = J THEN
		BEGIN
		   M1_CVI(VALUE[ARG1]);
		   M2_CVI(VALUE[ARG2]);
		   RM1_ROWSIZE("DATUM(M1)");
		   RM2_ROWSIZE("DATUM(M2)");
		   CM1_COLSIZE("DATUM(M1)");
		   CM2_COLSIZE("DATUM(M2)");
COMMENT FORCE MATRICES TO BE CONFORMAL;
		   IF CM1<RM2 THEN M1_EMM(RM1,RM2,DATUM(M1))
		      ELSE IF RM2<CM1 THEN 
		       M2_EMM(CM1,CM2,DATUM(M2));
		   BEGIN
		   SAFE REAL ARRAY Q[1:RM1,1:CM2];
		   MATMULT(DATUM(M1),DATUM(M2),Q);
		   R_NEW(Q);
		   END;
		   IF CVN(M1) NEQ VALUE[ARG1] THEN DELETE(M1);
	  	   IF CVN(M2) NEQ VALUE[ARG2] THEN DELETE(M2);
		   RETURN(BPUTANS(ARG1,ARG2,CVN(R),MATRIX,0));
		END
		ELSE IF NUMBER(J) THEN 
		BEGIN
		   M1_CVI(VALUE[ARG1]);
		   X_REL(VALUE[ARG2]);
		   GO TO MS;
		END ELSE GOTO E
               ELSE GOTO E;


MS:	RM1_ROWSIZE("DATUM(M1)");
	CM1_COLSIZE("DATUM(M1)");
	BEGIN
	SAFE REAL ARRAY Q[1:RM1,1:CM1];
	   FOR I_1 STEP 1 UNTIL RM1 DO
		FOR J_1 STEP 1 UNTIL CM1 DO
		Q[I,J]_DATUM(M1)[I,J]*X;
	   R_NEW(Q);
	END;
	RETURN(BPUTANS(ARG1,ARG2,CVN(R),MATRIX,0));
END;
INTEGER SIMPLE PROCEDURE DIVIDE(INTEGER ARG1,ARG2);
COMMENT
	ARG1/ARG2
	CALL:	ARG1 = INDEX OF FIRST ARGUMENT IN SYMTAB
		ARG2 = INDEX OF SECOND ARG IN SYMTAB
	RETURN:	INDEX OF (TEMPORARY) RESULT 
	RESTRICTIONS: MATRICES NOT ALLOWED AS ARGUMENTS
;
BEGIN
INTEGER I,J;
REAL X;
	I_TYPE[ARG1];
	J_TYPE[ARG2];
        IF I=MATRIX THEN IF NUMBER(J) THEN
                    BEGIN J_VALUE[ARG2];
                    VALUE[ARG2]_INT("1/REL(J)");
                    I_TIMES(ARG1,ARG2);
                    IF NOT(NAME[ARG2]=" ") THEN VALUE[ARG2]_J; 
                    RETURN(I)
                    END;

	IF NOT (NUMBER(I) AND NUMBER(J)) THEN
   	   TYPEFORMERROR(-1);
	X_REL(VALUE[ARG1])/REL(VALUE[ARG2]);
	RETURN(BPUTANS(ARG1,ARG2,INT(X),SCALAR,0));
END;
INTEGER PROCEDURE POWER( INTEGER ARG1,ARG2);
COMMENT
	ARG1 ^ ARG2
	CALL:	ARG1 = INDEX OF FIRST ARGUMENT IN SYMTAB
		ARG2 = INDEX OF SECOND ARGUMENT IN SYMTAB
	RESTRICTION: ARG2 MUST NOT BE A MATRIX
	
	SPECIAL CASES: IF "A" A MATRIX, "B" NOT AN INTEGER
		       THEN A ^ B RESULTS IN A ^ INTEGER PART(B)
		       
	               IF "A" A MATRIX, "B" < 0
		       THEN A ^ B RESULTS IN A ^ ABS(B)

;
BEGIN
LABEL MAT,A2,A5,ENDUP,ERR,I1;
INTEGER I,J,K,INV;
REAL X;
SAFE REAL ARRAY ITEMVAR Q,R,Y,ISCR,Z;
	I_TYPE[ARG2];
	IF NOT (NUMBER(I)) THEN ERR:TYPEFORMERROR(-1);
	I_TYPE[ARG1];
	IF NOT(NUMBER(I)) THEN
	BEGIN
	   IF I = MATRIX THEN GO TO MAT
           ELSE GOTO ERR;
	END;
COMMENT CALCULATE NUMBER TO A POWER;
	X_REL(VALUE[ARG1]) ^ REL(VALUE[ARG2]);
	RETURN(BPUTANS(ARG1,ARG2,INT(X),SCALAR,0));

COMMENT CALCULATE MATRIX TO A POWER
	ALGORITHM: KNUTH, VOL II, P. 399;

MAT:	I_REL(VALUE[ARG2]);
	Q_CVI(VALUE[ARG1]);
        IF I<0 THEN
        BEGIN
           INV_TRUE;
           Q_INVERT(Q);
           I_-I;
        END
        ELSE INV_FALSE;
	IF I = 1 THEN
	BEGIN
	   Y_NEW(DATUM(Q));
	   GO TO I1;
	END;
	J_ROWSIZE("DATUM(Q)");
	K_COLSIZE("DATUM(Q)");
	IF NOT (J=K) THEN
	BEGIN
	   J_MAX(J,K);
	   Z_EMM(J,J,DATUM(Q));
	END
	ELSE Z_NEW(DATUM(Q));
	BEGIN
	SAFE REAL ARRAY A[1:J,1:J];
	INTEGER K;
	   FOR K_1 STEP 1 UNTIL J DO
	   A[K,K]_1;
	   Y_NEW(A);
	   ISCR_NEW(A);
	END;
        IF I=0 THEN GOTO ENDUP;
A2:	K_I;
	I_I LSH -1; COMMENT I_INTEGER PART[I/2];
	IF (K = I LSH 1) THEN GO TO A5;
	MATMULT(DATUM(Z),DATUM(Y),DATUM(ISCR));
	ISCR SWAP Y;
	IF I = 0 THEN GO TO ENDUP;
A5:	MATMULT(DATUM(Z),DATUM(Z),DATUM(ISCR));
	ISCR SWAP Z;
	GO TO A2;
ENDUP:	DELETE(ISCR);
	DELETE(Z);
I1:     IF INV THEN DELETE(Q);
	RETURN(BPUTANS(ARG1,ARG2,CVN(Y),MATRIX,0));
END;
INTEGER PROCEDURE TRANSPOSE(INTEGER I);
COMMENT
	TRANSPOSE OF A MATRIX
	CALL:	I = INDEX OF MATRIX IN SYMTAB
	RETURN:	INDEX OF (TEMPORARY) RESULT
;
BEGIN
SAFE REAL ARRAY ITEMVAR U,V;
INTEGER J,K,L,M;
	IF TYPE[I] NEQ MATRIX THEN RETURN(I);
	U_CVI(VALUE[I]);
	L_ROWSIZE("DATUM(U)");
	M_COLSIZE("DATUM(U)");
	BEGIN
	   SAFE REAL ARRAY Q[1:M,1:L];
	   FOR J_L STEP -1 UNTIL 1 DO
	   FOR K_M STEP -1 UNTIL 1 DO
	   Q[K,J]_DATUM(U)[J,K];
	   V_NEW(Q);
	END;
	RETURN(UPUTANS(I,CVN(V),MATRIX));
END;
INTEGER PROCEDURE ROWCON(INTEGER ARG1,ARG2);
COMMENT
	ROW CONCATENATION OF MATRICES

	-------     -------     -------
     	I     I     I     I     I     I
        I  1  I  &  I  2  I  =  I  1  I
	I     I     I     I     I     I
  	-------     -------     I     I
                                I  2  I
                                I     I
                                -------


	CALL:	ARG1 = INDEX OF FIRST ARG IN SYMTAB
	        ARG2 = INDEX OF SECOND ARG IN SYMTAB
	RETURN:	INDEX OF (TEMPORARY) RESULT IN SYMTAB
;
BEGIN
INTEGER I,J;
SAFE REAL ARRAY ITEMVAR I1,I2,IR;
INTEGER RM1,RM2,CM1,CM2,RM,CM;
	I_TYPE[ARG1];
	IF NOT(NUMBER(I) OR MATRIX = I) THEN
	   TYPEFORMERROR(ARG1);
	J_TYPE[ARG2];
	IF NOT(NUMBER(J) OR MATRIX = J) THEN
	   TYPEFORMERROR(ARG2);
	IF I = MATRIX THEN
	BEGIN
	   I1_CVI(VALUE[ARG1]);
	   RM1_ROWSIZE("DATUM(I1)");
	   CM1_COLSIZE("DATUM(I1)");
	END
	ELSE RM1_CM1_1;
	IF J = MATRIX THEN
	BEGIN
	   I2_CVI(VALUE[ARG2]);
	   RM2_ROWSIZE("DATUM(I2)");
	   CM2_COLSIZE("DATUM(I2)");
	END
	ELSE
	   RM2_CM2_1;
	RM_RM1+RM2;
	CM_MAX(CM1,CM2);
	IF I = MATRIX THEN
	BEGIN
	   IF CM1 NEQ CM THEN I1_EMM(RM1,CM,DATUM(I1));
	END
	ELSE I1_ESM(1,CM,REL(VALUE[ARG1]));
	IF J = MATRIX THEN
	BEGIN

	   IF CM2 NEQ CM THEN I2_EMM(RM2,CM,DATUM(I2));
	END
	ELSE I2_ESM(1,CM,REL(VALUE[ARG2]));
	BEGIN
	SAFE REAL ARRAY Q[1:RM,1:CM];
	INTEGER K,L;
	FOR K_1 STEP 1 UNTIL RM1 DO
	   FOR L_1 STEP 1 UNTIL CM DO
	   Q[K,L]_DATUM(I1)[K,L];
	FOR K_1 STEP 1 UNTIL RM2 DO
	   FOR L_1 STEP 1 UNTIL CM DO
	   Q[RM1+K,L]_DATUM(I2)[K,L];
	   IR_NEW(Q);
	END;
	IF (I NEQ MATRIX OR CVN(I1) NEQ VALUE[ARG1])
	   THEN DELETE(I1);
	IF (J NEQ MATRIX OR CVN(I2) NEQ VALUE[ARG2])
	   THEN DELETE(I2);
	RETURN(BPUTANS(ARG1,ARG2,CVN(IR),MATRIX,0));
END;
INTEGER PROCEDURE COLCON(INTEGER ARG1,ARG2);
COMMENT
	COLUMN CONCATENATION OF MATRICES

	-------      -------     --------------
	I     I      I     I     I            I
  	I  1  I  &'  I  2  I  =  I  1      2  I
   	I     I      I     I     I            I
 	-------      -------     --------------

	CALL:	ARG1 = INDEX OF FIRST ARG IN SYMTAB
		ARG2 = INDEX OF SECOND ARG IN SYMTAB
	RETURN:	INDEX OF (TEMPORARY) RESULT

;
BEGIN
RETURN(TRANSPOSE(ROWCON(TRANSPOSE(ARG1),TRANSPOSE(ARG2))));
END;




INTEGER SIMPLE PROCEDURE ABSOP(INTEGER ARG);
COMMENT
	ABSOLUTE VALUE OF A SCALAR OR OF EACH ELEMENT
	OF A MATRIX

	ARG = INDEX OF ARGUMENT IN SYMTAB

;
BEGIN
SAFE REAL ARRAY ITEMVAR Q;
INTEGER TYP,K,L;

	TYP_TYPE[ARG];
	IF NUMBER(TYP) THEN
	   RETURN(UPUTANS(ARG,ABS(VALUE[ARG]),SCALAR));

	IF TYP NEQ MATRIX THEN TYPEFORMERROR(ARG);
	
	Q_CVI(VALUE[ARG]);
	Q_NEW(DATUM(Q));
	FOR K_ROWSIZE("DATUM(Q)") STEP -1 UNTIL 1 DO
	   FOR L_COLSIZE("DATUM(Q)") STEP -1 UNTIL 1 DO
		DATUM(Q)[K,L]_ABS(DATUM(Q)[K,L]);
	RETURN(UPUTANS(ARG,CVN(Q),MATRIX));
END;
PROCEDURE CONPROC(INTEGER M);
COMMENT
	BUILD A CONSTRAINT MATRIX

	M = INDEX FOR CONSTRAINT MATRIX IN SYMTAB
;
BEGIN
INTEGER TOKEN,SYMIDX,NPARMT,NPARMS,FSNODE,B1,B2,C1,CC,L,N;
LABEL READST,L0,BUILDMAT;
SAFE REAL ARRAY ITEMVAR R;

BOOLEAN SIMPLE PROCEDURE NEWP(INTEGER P);
COMMENT
	SEARCH THE CONSTRAINS EXPRESSION STRUCTURE TO DETERMINE
	WHETHER PARAMETER P HAS BEEN SPECIFIED BEFORE

	RETURN TRUE IF P IS A NEW PARAMETER
;
BEGIN

BOOLEAN SIMPLE PROCEDURE SEARCHS(INTEGER P,B);
COMMENT
	SEARCH THE SUBEXPRESSION STRUCTURE B FOR AN INSTANCE OF
	PARAMETER P. 
	RETURN FALSE IF SUCH AN INSTANCE IS FOUND
;
BEGIN
	WHILE B NEQ 0 DO
	BEGIN
	   IF NODE[B+2] = P THEN RETURN(FALSE);
	   B_NODE[B];
	END;
	RETURN(TRUE);
END;

INTEGER K;

COMMENT SEARCH SUBEXPRESSIONS IN PROGRESS;

	IF NOT (SEARCHS(P,B1)) THEN RETURN(FALSE);
	IF NOT (SEARCHS(P,FSNODE)) THEN RETURN(FALSE);

COMMENT SEARCH COMPLETED EXPRESSIONS;

	K_C1;
	WHILE K NEQ 0 DO
	BEGIN
	   IF NOT (SEARCHS(P,NODE[K+2])) THEN RETURN(FALSE);
	   K_NODE[K];
	END;

	RETURN(TRUE);
END;








SIMPLE PROCEDURE LFREE(INTEGER B);
COMMENT
	FREE A LIST OF NODE ELEMENTS
;
BEGIN
INTEGER A;
	WHILE B > 0 DO
	BEGIN
	   A_NODE[B];
	   FREENODE(B,NODE);
	   B_A;
	END;
END;


FORWARD INTEGER SIMPLE PROCEDURE SUBX;
FORWARD INTEGER SIMPLE PROCEDURE GETTERM;
INTEGER SIMPLE PROCEDURE EXPR;
COMMENT
	GET CONSTRAINT EXPRESSION

	EXPR:=   SUBX<SUBX
	    	 SUBX<=SUBX
	 	 SUBX>=SUBX
		 SUBX>SUBX
		 SUBX=SUBX
	
	RETURN:	INDEX INTO NODE ARRAY

		IDX:      0
		          OP
		          SUBEXPRESSION

		-1 FOR ILLEGAL SYNTAX
;
BEGIN
INTEGER OP,K,L;

COMMENT FOLLOWING STATEMENT REQUIRED FOR NEWP TO WORK CORRECTLY;

	NPARMT_B1_B2_0;
	B1_SUBX;
	COMMENT REQUIRED FOR NEWP,LFREE; FSNODE_0;
	IF B1<0 THEN RETURN(-1);

	IF TOKEN < EQUALOP OR TOKEN > GREATEROP THEN
		RETURN(-1);
	IF TOKEN > LEQOP THEN OP_INT(1.0) ELSE 
	OP_IF TOKEN = EQUALOP THEN 0 ELSE INT(-1.0);
	GETTOKEN(TOKEN,SYMIDX);
	B2_SUBX;
	IF TOKEN NEQ CR OR B2 LEQ 0 THEN RETURN(-1);

	L_B2;
	WHILE NOT L = 0 DO
	BEGIN
	   NODE[L+1]_-NODE[L+1];
	   L_NODE[L];
	END;
	L_B1;
	WHILE NODE[L] NEQ 0 DO L_NODE[L];
	NODE[L]_B2;
	NEWNODE(K,NODE);
	NODE[K]_0;
	NODE[K+1]_OP;
	NODE[K+2]_B1;
	NPARMS_NPARMS+NPARMT;
	RETURN(K);
END;


INTEGER SIMPLE PROCEDURE SUBX;
COMMENT
	GET A CONSTRAINT SUBEXPRESSION

	SUBX:=	SUBX + TERM
		SUBX - TERM
		+TERM
		- TERM
		TERM

	RETURN:	INDEX OF FIRST NODE IN LINKED LIST OF TERM NODES
		-1 FOR ILLEGAL SYNTAX
;
BEGIN
INTEGER CNODE,OP,L;
LABEL NODEGET;

	OP_1;
	IF TOKEN = PLUS THEN GETTOKEN(TOKEN,SYMIDX)
	ELSE IF TOKEN = MINUS THEN
	BEGIN
	   OP_-1;
	   GETTOKEN(TOKEN,SYMIDX);
	END;

COMMENT FOLLOWING REQUIRED BY NEWP;

	FSNODE_0;

	FSNODE_CNODE_GETTERM;
	IF CNODE < 0 THEN RETURN(-1);
	IF OP < 0 THEN NODE[CNODE+1]_-NODE[CNODE+1];

NODEGET:	IF TOKEN = PLUS THEN OP_1
		ELSE IF TOKEN = MINUS THEN OP_-1
		ELSE RETURN(FSNODE);

	GETTOKEN(TOKEN,SYMIDX);
	L_GETTERM;
	IF L LEQ 0 THEN RETURN(-1);
	IF OP < 0 THEN NODE[L+1]_-NODE[L+1];
	NODE[CNODE]_L;
	CNODE_L;
	GO TO NODEGET;
END;

INTEGER SIMPLE PROCEDURE GETTERM;
COMMENT
	GET THEN NEXT TERM

	TERM:= 	CONST*PARM
		PARM*CONST
		PARM/CONST
		PARM
		CONST

	RETURN:	INDEX INTO NODE ARRAY
		IDX:	0
			CONSTANT
			SYMTAB IDX OF PARM

		0 IF NO TERM PRESENT
		-1 IF ILLEGAL SYNTAX

;
BEGIN
INTEGER K,VAL,PIDX;
LABEL RETNODE;

COMMENT CONSTANT OR CONSTANT*PARAMETER;

	IF TOKEN = CONST THEN BEGIN
	   VAL_ - VALUE[SYMIDX];
	   GETTOKEN(TOKEN,SYMIDX);
	   IF TOKEN = MULTSIGN THEN
	   BEGIN
		GETTOKEN(TOKEN,SYMIDX);
		IF TOKEN NEQ ID THEN RETURN(-1);
		PIDX_SYMIDX;
		GETTOKEN(TOKEN,SYMIDX);
		IF NEWP(PIDX) THEN NPARMT_NPARMT+1;
		VAL_-VAL;
	   END
	   ELSE PIDX_0;
	   GO TO RETNODE;
	END;

COMMENT PARAMETER   PARAMETER*CONSTANT  PARAMETER/CONSTANT;

	IF TOKEN NEQ ID THEN RETURN(0);

	PIDX_SYMIDX;
	IF NEWP(PIDX) THEN NPARMT_NPARMT+1;
	GETTOKEN(TOKEN,SYMIDX);
	IF TOKEN = MULTSIGN THEN
	BEGIN
	   GETTOKEN(TOKEN,SYMIDX);
	   IF TOKEN NEQ CONST THEN RETURN(-1);
	   VAL_VALUE[SYMIDX];
	   GETTOKEN(TOKEN,SYMIDX);
	END
	ELSE IF TOKEN = DIVIDESIGN THEN
	BEGIN
	   GETTOKEN(TOKEN,SYMIDX);
	   IF TOKEN NEQ CONST THEN RETURN(-1);
	   VAL_INT(1./REL(VALUE[SYMIDX]));
	   GETTOKEN(TOKEN,SYMIDX);
	END
	ELSE VAL_INT(1.0);
RETNODE:	
	NEWNODE(K,NODE);
	NODE[K]_0;
	NODE[K+1]_VAL;
	NODE[K+2]_PIDX;
	RETURN(K);
END "GETTERM";


	IF TYPE[M] = CONSTRAINTS THEN BEGIN R_CVI(VALUE[M]); DELETE(R); TYPE[M]_UNKNOWN END
	ELSE IF TYPE[M] NEQ UNKNOWN THEN TYPEFORMERROR(M);

	CC_C1_0;
	NPARMS_0;
	N_0;

READST:	B_NULL;
L0:	OUTSTR(CRLF&"!");

	B_B&INPUT(6,1);

	IF BRCHAR = '175 THEN GO TO L0;
	
	IF LENGTH(B) = 0 THEN GO TO BUILDMAT;
	B_B&'1;
	GETTOKEN(TOKEN,SYMIDX);
	L_EXPR;
	IF L LEQ 0 THEN 
	BEGIN
	   COMMENT FREE NODES IN ILLEGAL EXPRESSION;
	   LFREE(B1);LFREE(B2);LFREE(FSNODE);
	   OUTSCR("ILLEGAL CONSTRAINT");
	   GO TO READST;
	END;

	N_N+1;
	IF CC NEQ 0 THEN NODE[CC]_L ELSE C1_L;
	CC_L;
	GO TO READST;

BUILDMAT:	
	IF N = 0 THEN BEGIN DELETEENTRY(M); RETURN END;
	IF NPARMS = 0 THEN ERROR("CONSTRAINT: NO PARAMETERS");
	BEGIN
	INTEGER ROWX,B,A,I,J;
	SAFE INTEGER ARRAY ITEMVAR Q;
	SAFE INTEGER ARRAY AR[1:N+1,1:NPARMS+2];
	
	INTEGER SIMPLE PROCEDURE FINDCOL(INTEGER P);
	COMMENT
	  	RETURN THE NUMBER OF THE COLUMN IN AR
		CORRESPONDING TO PARAMETER P;
	BEGIN
		IF P = 0 THEN RETURN(NPARMS+2);
		I_1;
		WHILE AR[1,I] NEQ 0 DO
		BEGIN
		   IF P = AR[1,I] THEN RETURN(I);
		   I_I+1;
		END;
		AR[1,I]_P;
		RETURN(I);
	END "FINDCOL";

	ROWX_1;
	WHILE C1 NEQ 0 DO
	BEGIN
	   ROWX_ROWX+1;
	   B_NODE[C1+2];
	   WHILE B NEQ 0 DO
	   BEGIN
		REAL X;
		J_FINDCOL(NODE[B+2]);
		X_REL("AR[ROWX,J]");
		   AR[ROWX,J]_INT("X+REL(NODE[B+1])");
		A_B;
		B_NODE[B];
		FREENODE(A,NODE);
	   END;

	   A_C1;
	   AR[ROWX,NPARMS+1]_NODE[C1+1];
	   C1_NODE[C1];
	   FREENODE(A,NODE);
	END;

	FOR I_1 STEP 1 UNTIL NPARMS DO
	BEGIN
	   STUFFST(J,"NAME[AR[1,I]]");
	   AR[1,I]_J;
	END;
	Q_NEW(AR);
	VALUE[M]_CVN(Q);
	TYPE[M]_CONSTRAINTS;
	RETURN;
END;
END;
INTERNAL PROCEDURE DELETEENTRY(INTEGER E);
COMMENT
	DELETE A SYMBOL TABLE ENTRY

   OR IN THE CASE OF "M ROW R", DELETE ROWS FROM THE MATRIX M.
	E = INDEX OF SYMTAB ENTRY

;
BEGIN
INTEGER TYP,I,J,K,A;
SAFE REAL ARRAY ITEMVAR Q;
LABEL FCTDEL,DELTA,COLDEL;

        IF EQU(NAME[E]," ") THEN RETURN;

	IF (TYP_TYPE[E])<UNKNOWN THEN TYP_0;
	CASE TYP OF 
	BEGIN
		;		COMMENT (0) BUILT-IN;
		;		COMMENT (1) UNKNOWN;
		BEGIN  		COMMENT (2) CONSTANT;
                IF E=ONE OR E=ZERO THEN RETURN
                END;
		RETURN;		COMMENT (3) OPERATOR;
		;		COMMENT (4) SCALAR;
	FCTDEL:	BEGIN		COMMENT (5) FUNCTION;
                        STRING S;
                        LABEL L;
                        INTEGER PROCEDURE INNERHEAD(STRING F,C);
                        BEGIN
                        IF LENGTH(C)=0 OR C=" " THEN RETURN(FALSE);
                        IF C="." THEN 
                          RETURN(INNERHEAD(F[(IF F="." THEN 2 ELSE 1) TO INF], C[2 TO INF]));
                       IF ((J_LENGTH(F)) LEQ LENGTH(C)) AND
                          EQU(F,C[1 TO J]) THEN
                          IF LENGTH(C)=J THEN RETURN(TRUE)
                          ELSE IF C[J+1 FOR 1]="." THEN RETURN(TRUE)
                          ELSE RETURN(FALSE)   ELSE RETURN(FALSE);

                       END "INNERHEAD";

                        S_NAME[E];
                        FOR I_0 STEP 1 UNTIL SYMTABSIZEM1 DO
                           IF INNERHEAD(S,NAME[I]) THEN BEGIN
                           IF TYPE[I]=UNKNOWN THEN GOTO L;
                           IF TYPE[I] = INITIAL OR
                              (TYPE[E] NEQ INITIAL AND
                              TYPE[I]=FUNCTION) THEN BEGIN
                     L: NAME[I]_" ";
                                                    END;
                                                          END;
                        CLEANUP;
                        RETURN
                  END;

		BEGIN		COMMENT (6) MATRIX;
		   Q_CVI(VALUE[E]);
		   DELETE(Q);
		END;
		WDELET(E);	COMMENT (7) WINDOW;
		CDELET(E);	COMMENT (8) CURVE;
		GOTO FCTDEL;    COMMENT (9) INITIAL;
		;		COMMENT (10) COLON;
		;		COMMENT (11) COLON2;
BEGIN
IF TYPE[VALUE[E]] NEQ MATRIX OR TYPE[IDX[E]] NEQ MATRIX THEN GOTO COLDEL;
Q_CVI(VALUE[VALUE[E]]);
ITM_CVI(VALUE[IDX[E]]);
TYP_COLSIZE("DATUM(Q)"); A_ROWSIZE("DATUM(Q)");
NEEDNEXT FOR I_1 STEP 1 UNTIL SIZE("DATUM(ITM)") DO BEGIN
    IF (J_GETLINEAR(DATUM(ITM),I))<1 OR (J>ROWSIZE("DATUM(Q)")) THEN BEGIN OUTSCR("BAD INDEX IGNORED"); NEXT END;
    DATUM(Q)[J,1]_REL(MARK); 
                                           END;

I_1;  WHILE DATUM(Q)[I,1] NEQ REL(MARK) AND I<A DO I_I+1;
J_I;
DO BEGIN
IF DATUM(Q)[J,1] NEQ REL(MARK) THEN 
                  BEGIN FOR K_1 STEP 1 UNTIL TYP DO DATUM(Q)[I,K] SWAP DATUM(Q)[J,K];
                        I_I+1
                  END;
                  J_J+1; 
END UNTIL J>A;

I_I-1;
BEGIN
SAFE REAL ARRAY T[1:I,1:TYP];

ARRBLT(T[1,1],DATUM(Q)[1,1],I*TYP);
DELETE(Q);
VALUE[VALUE[E]]_CVN(NEW(T));
END;
DELTA:      FREET(VALUE[E]); FREET(IDX[E]); FREET(E);
                           END;	COMMENT (12) ROW;
COLDEL:
BEGIN  OUTSCR("DELETION NOT OK.");
       GOTO DELTA END;         COMMENT (13) COL;
		;		COMMENT (14) SUBSCR;
		;		COMMENT (15) TEXT;
		BEGIN		COMMENT (16) CONSTRAINTS;
		SAFE INTEGER ARRAY ITEMVAR Q;
		INTEGER J,K;

		   Q_CVI(VALUE[E]);
		   J_COLSIZE("DATUM(Q)")-2;
		   FOR K_1 STEP 1 UNTIL J DO
			ST[DATUM(Q)[1,K]]_NULL;
		   DELETE(Q);
		END;
	END;

	NAME[E]_" ";
END;
INTEGER SIMPLE PROCEDURE PCOLON(INTEGER A,B);
COMMENT
	PROCESS A:B

          NOTE THE NON-STACK DISCIPLINE FREETING OF B, BUT NOT A         
          THE "INNER" DELETE SEQUENCE IN FREET WILL COVER FOR US!

;
BEGIN
INTEGER I,J;
LABEL C2;

	I_TYPE[A];
	J_TYPE[B];
	IF NOT(NUMBER(J) AND (NUMBER(I) OR I = COLON
	   )) THEN TYPEFORMERROR(-1);

	IF I = COLON THEN GO TO C2;
        NEWNODE(J,NODE); NODE[J]_VALUE[A];
                         NODE[J+1]_VALUE[B];
                         NODE[J+2]_INT(1.0);
	RETURN(BPUTANS(A,B,0,COLON,J));

C2:     NODE[IDX[A]+2]_VALUE[B];
        FREET(B);
        RETURN(A);
END;
INTEGER PROCEDURE LIST(SAFE INTEGER ARRAY ARGS);
COMMENT
	PROCESS "LIST A,B,C,...,N"
	
	CALL:	ARGS = ARRAY OF ARGUMENT SYMTAB ENTRIES
	RETURN:	SYMTAB ENTRY OF A K X 1 MATRIX [M]
		WHERE K IS DETERMINED BY THE FOLLOWING:
		AN ARGUMENT OF TYPE NUMBER IS PLACED IN ONE
		ELEMENT OF M.
		AN ARGUMENT OF TYPE  A:B CAUSES
		A,A+1,...,B-1,B TO BE PLACED IN M.
		AN ARGUMENT OF TYPE A:B:C CAUSES
		A,A+C,A+2*C,...,B TO BE PLACED IN M.
		IF AN ARGUMENT IS OF TYPE MATRIX, ITS
		FIRST ELEMENT IS PLACED IN M.

;
BEGIN
SAFE REAL ARRAY ITEMVAR Q;
INTEGER I,J,K,L,M,NN,TNARGS;
REAL STV,INC;
	K_0;
        TNARGS_SIZE(ARGS);
	FOR I_1 STEP 1 UNTIL TNARGS DO
	BEGIN
	   J_ARGS[I];
	   L_TYPE[J];
	   IF NUMBER(L) THEN K_K+1 ELSE
           IF MATRIX = L THEN
		BEGIN
		   Q_CVI(VALUE[J]);
		   K_K+SIZE("DATUM(Q)");
		END ELSE
            IF COLON = L THEN
		BEGIN
		   M_IDX[J];
		   NN_(REL(NODE[M+1])-REL(NODE[M]))/REL(NODE[M+2])+1;
                 IF NN LEQ 0 THEN BEGIN OUTSCR("AN EMPTY A:B LIST!"); NN_0  END;
                   K_K+NN;
		END ELSE
             TYPEFORMERROR(J);
	END;
	BEGIN
	SAFE REAL ARRAY M[1:K,1:1];
	INTEGER P,IND;

	   IND_0;
	   FOR I_1 STEP 1 UNTIL TNARGS DO
	   BEGIN
		J_ARGS[I];
		L_TYPE[J];
		IF NUMBER(L) THEN M[IND_IND+1,1]_REL(VALUE[J])
		   ELSE IF MATRIX = L THEN
		   BEGIN
                   Q_CVI(VALUE[J]);
			ARRBLT(M[IND+1,1],DATUM(Q)[1,1], NN_SIZE("DATUM(Q)"));
                        IND_IND+NN;
		   END
		   ELSE IF COLON = L THEN
		BEGIN
		   NN_IDX[J];
		   STV_REL(NODE[NN]);
		   INC_REL(NODE[NN+2]);
		   NN_(REL(NODE[NN+1])-STV)/INC+1;
		   FOR P_1 STEP 1 UNTIL NN DO
		   BEGIN
			M[IND_IND+1,1]_STV;
			   STV_STV+INC;
		   END;
		END;
	   END;
		Q_NEW(M);
COMMENT FREE ANY TEMPORARY ARGUMENTS;
	   FOR I_TNARGS STEP -1 UNTIL 1 DO FREET(ARGS[I]);
	   J_NEWTEMP;
	   TYPE[J]_MATRIX;
	   VALUE[J]_CVN(Q);
	   RETURN(J);
	END;

END;
PROCEDURE EXPANDARRAY(REFERENCE SAFE INTEGER ARRAY ITEMVAR  R;
		INTEGER ROWN,COLN);
COMMENT
	EXPAND THE ARRAY DATUM OF R TO BE OF SIZE AT LEAST
	ROWN BY COLN
;
BEGIN
INTEGER RT,CT;

RT_ROWSIZE("DATUM(R)");
CT_COLSIZE("DATUM(R)");

IF RT < ROWN OR CT < COLN THEN
BEGIN
	SAFE INTEGER ARRAY T[1:MAX(RT,ROWN),1:MAX(CT,COLN)];
	INTEGER I,J;
	FOR I_1 STEP 1 UNTIL RT DO
	FOR J_1 STEP 1 UNTIL CT DO
	T[I,J]_DATUM(R)[I,J];

COMMENT THE NEW ITEM IN R WILL BE THE OLD ITEM NUMBER;

	DELETE(R);
	R_NEW(T);
END
END "EXPANDARRAY";

PROCEDURE TYPLOT(SAFE REAL ARRAY XY;INTEGER LINES,SPACES,XTIC,YTIC,
XLAB,YLAB,CHANNEL;REAL XMAX,XMIN,YMAX,YMIN;STRING SYM);

BEGIN
COMMENT
	TELETYPE PLOTTER

	CALL:	XY = ARRAY OF POINTS TO BE PLOTTED
		     FIRST COLUMN = X COORDINATES
		     OTHER COLUMNS = CORRESPONDING Y COORDINATES
		LINES = NUMBER OF LINES IN PLOT
			(ALLOW 3 MORE FOR LABELS)
		SPACES = NUMBER OF SPACES IN PLOT
			(ALLOW 10 MORE FOR LABELS)
		XTIC = EVERY XTIC-TH SPACE IS MARKED WITH A "+"
		YTIC = EVERY YTIC-TH LINE IS MARKED WITH A "+"
		XLAB = EVERY XLAB-TH "+" IS LABEL WITH A NUMBER
		YLAB = EVERY YLAB-TH "+" IS LABELED WITH A NUMBER
		CHANNEL = AN OPEN CHANNEL TO BE USED FOR OUTPUT
		XMAX,XMIN,YMAX,YMIN = BOUNDS OF COORDINATES TO BE PLOTTED
		SYM = STRING TO BE USED FOR PLOT SYMBOLS ONE CHARACTER PER COLUMN OF XY

;
SAFE STRING ARRAY OUTL[1:SPACES];
STRING S,T,U;
INTEGER NOX,NOY,MAXLINE,I,J,NYTIC,NLSPAC;
REAL YDEL,XDEL,XCOL,YC,XSC,XK;

SIMPLE PROCEDURE XAXIS(INTEGER SPACES,CHANNEL,XTIC);
COMMENT PRODUCE STRING FOR TOP AND BOTTOM OF GRAPH;

BEGIN
INTEGER I,J;
STRING S;

	S_"         .";
	J_SPACES-1;
	FOR I_0 STEP 1 UNTIL J DO
	  S_S& (IF I MOD XTIC = 0 THEN "+" ELSE ".");
	OUTCR(CHANNEL,S&".");
	RETURN;
	END;
SIMPLE PROCEDURE YSORT(INTEGER YN;SAFE INTEGER ARRAY XS;SAFE REAL ARRAY XY);
COMMENT
	SORT THE Y COORDINATES IN DECREASING ORDER
	CALL:	XY = ARRAY OF POINTS TO BE PLOTTED
		     1ST COLUMN = X-COORDINATES
		     SUBSEQUENT COLUMNS = Y COORDINATES

		YN = NUMBER OF THE COLUMN IN XY TO BE SORTED

	RETURN:	SPECIFIED COLUMN IN XY SORTED IN
			DECREASING ORDER

		 	ARRAY OF ORIGINAL SUBSCRIPTS IN 
			COLUMN YN-1 OF XS
;
BEGIN
INTEGER I,J,K,L,M,N;
	K_ROWSIZE(XY);
	N_YN-1;
	FOR I_1 STEP 1 UNTIL K DO 
	XS[I,N]_I;
	L_K-1;
	FOR I_1 STEP 1 UNTIL L DO 
	BEGIN
	   M_I;
	   FOR J_I+1 STEP 1 UNTIL K DO
		IF XY[J,YN] > XY[M,YN] THEN M_J;
	XS[I,N] SWAP XS[M,N];
	XY[I,YN] SWAP XY[M,YN];
END;
	RETURN;
	END;
	IF COLSIZE(XY) < 2 THEN TYPEFORMERROR(-1);
BEGIN
SAFE INTEGER ARRAY XS[1:ROWSIZE(XY), 1:(COLSIZE(XY)-1)];
SAFE INTEGER ARRAY YP[1:COLSIZE(XY)-1];
SAFE REAL ARRAY XYC[1:ROWSIZE(XY),1:COLSIZE(XY)];
LABEL L1,L2;
	ARRTRAN(XYC,XY);
	SETFORMAT(9,3);
	NYTIC_0;
	NOY_COLSIZE(XY)-1;
	XAXIS(SPACES,CHANNEL,XTIC);
	YDEL_(YMAX-YMIN)/LINES;
	XDEL_(XMAX-XMIN)/SPACES;
	MAXLINE_LINES-1;
	YC_YMAX;
	FOR I_1 STEP 1 UNTIL NOY DO YP[I]_1;
	FOR I_NOY+1 STEP -1 UNTIL 2 DO YSORT(I,XS,XYC);
	NOX_ROWSIZE(XY);
	FOR I_0 STEP 1 UNTIL MAXLINE DO
	BEGIN
	   YC_YC-YDEL;
	   FOR J_1 STEP 1 UNTIL SPACES DO
		OUTL[J]_" ";
		FOR J_1 STEP 1 UNTIL NOY DO 
	   BEGIN
		INTEGER K1,K2,INDEX;
		LABEL N1,N2;
		K1_J+1;
	   N1:	K2_YP[J];
		IF K2>NOX OR (I<MAXLINE AND XYC[K2,K1] < YC) THEN GO TO N2;
		INDEX_(XYC[XS[K2,J],1]-XMIN)/XDEL+1;
		IF INDEX < 1 THEN INDEX_1 ELSE
		   IF INDEX > SPACES THEN INDEX_SPACES;
		OUTL[INDEX]_IF OUTL[INDEX] = " " OR OUTL[INDEX] = SYM[J FOR 1] THEN SYM[J FOR  1] ELSE "*";
		YP[J]_K2+1;
		GO TO N1;
	   N2:	END;
		U_"         ";
		IF I MOD YTIC NEQ 0 THEN T_"."
		ELSE BEGIN
		   T_"+";
		   IF NYTIC MOD YLAB  = 0 THEN
			U_CVG(YC+.5*YDEL);
		   NYTIC_NYTIC+1;
		END;
		S_U&T;
		FOR J_1 STEP 1 UNTIL SPACES DO
		   S_S&OUTL[J];
		OUTCR(CHANNEL,S&T);
	   END;
	   XAXIS(SPACES,CHANNEL,XTIC);
L1:	   NLSPAC_XTIC*XLAB;
	   IF NLSPAC < 9 THEN
	   BEGIN
		XLAB_XLAB*2;
		GO TO L1;
	   END;
	S_"    ";
	SETFORMAT(NLSPAC,3);
	XSC_(XMAX-XMIN)/SPACES*NLSPAC;
	XK_XMIN;
	DO
	BEGIN
	   S_S&CVG(XK);
	   XK_XK+XSC;
	END UNTIL XK>XMAX+XDEL OR XSC LEQ 0;

L2:	OUT(CHANNEL,S);
END;
END "TYPLOT";
REAL SIMPLE PROCEDURE GETLINEAR(SAFE INTEGER ARRAY A;INTEGER I);

COMMENT  GETLINEAR RETURNS THE ITH CELL OF A, REGARDLESS
         OF WHETHER A IS A ROW VECTOR OR COL VECTOR
	 ONE ORIGIN INDEXING IS USED.;

BEGIN
START!CODE
    MOVE 1,A;
    ADD 1,I;
    MOVE 1,'777777(1);
    END;
END "GETLINEAR";
INTERNAL INTEGER PROCEDURE E(INTEGER I);
COMMENT  I IS A TOKEN, I.E. AN INDEX TO SYMTAB.  E EVALUATES
         THE TOKEN I WHICH IS A DEFERRED SUBSCRIPTED ARRAY
         ELEMENT OR ARRAY SELECTION.  THE VALUE OF I IN
                 THE SYMBOL TABLE IS UPDATED AND THE CORRECT TYPE
         IS ASSIGNED, WHEREUPON I IS RETURNED;


BEGIN
INTEGER D1,D2,K,J;

SAFE INTEGER ARRAY ITEMVAR PROCEDURE SELECT(INTEGER TYPE;
      INTEGER ARRAY ITEMVAR M;SAFE INTEGER ARRAY ITEMVAR W);
COMMENT  SELECT COMPUTES M ROW W OR M COL W, WHERE M
         IS AN ITEM WITH MATRIX DATUM AND W IS AN ITEM
         WITH A VECTOR (LIST) DATUM WHICH SPECIFIES A
         LIST OF SUBSCRIPTS;

BEGIN

D1_IF TYPE=ROW THEN SIZE("DATUM(W)") ELSE ROWSIZE("DATUM(M)");
D2_IF TYPE=COL THEN SIZE("DATUM(W)") ELSE COLSIZE("DATUM(M)");

BEGIN
SAFE INTEGER ARRAY A[1:D1,1:D2];

FOR K_1 STEP 1 UNTIL D1 DO
FOR J_1 STEP 1 UNTIL D2 DO
    A[K,J]_DATUM(M)[IF TYPE=ROW THEN GETLINEAR(DATUM(W),K) ELSE K,
                    IF TYPE=COL THEN GETLINEAR(DATUM(W),J) ELSE J];

RETURN(NEW(A));
END 

END "SELECT";


INTEGER SIMPLE PROCEDURE EVALSUBSCR(INTEGER I);
BEGIN
INTEGER ARRAY ITEMVAR R;

IF TYPE[J_IDX[I]] NEQ MATRIX THEN TYPEFORMERROR(J);
R_CVI(VALUE[J]);
J_VALUE[I];
VALUE[I]_DATUM(R)[(J ROT 18) LAND '777777, J LAND '777777];
TYPE[I]_SCALAR;
RETURN(I)
END "EVALSUBSCR";



INTEGER SIMPLE PROCEDURE EVALROWCOL(INTEGER I);
BEGIN
D1_VALUE[I];
D2_IDX[I];
IF TYPE[D1] NEQ MATRIX THEN TYPEFORMERROR(D1);
IF TYPE[D2] NEQ MATRIX THEN TYPEFORMERROR(D2);

K_CVN(SELECT(TYPE[I],CVI(VALUE[D1]),CVI(VALUE[D2])));
FREET(VALUE[I]); FREET(IDX[I]); FREET(I);
I_NEWTEMP; VALUE[I]_K;
TYPE[I]_MATRIX;
RETURN(I)
END "EVALROWCOL";

COMMENT  TEST HERE TO GET OUT FAST;

IF (J_TYPE[I])=SCALAR OR J=CONSTANT OR J=MATRIX  THEN RETURN(I);

IF J=COLON THEN BEGIN
            SAFE INTEGER ARRAY ARGS[1:1];
              ARGS[1]_I;
              RETURN(LIST(ARGS))
                                        END;

IF J=SUBSCR THEN RETURN(EVALSUBSCR(I));
IF J=ROW OR J=COL THEN RETURN(EVALROWCOL(I));

RETURN(I)
END "E";
SIMPLE PROCEDURE FCTBODYPROC ;

BEGIN

INTEGER I1,IA,JA,K,FN,N,LAST;

LABEL ONEARG, ERR;

IF OPSYM=FUNCTIONF THEN BEGIN "CASE F"

K_I-NARGS;
IF (FN_P[K]) LEQ 0 THEN GOTO ERR;
I1_TYPE[FN];
IF NOT(I1 LEQ UNKNOWN OR I1 = FUNCTION OR I1 = MATRIX OR I1=INITIAL) THEN TYPEFORMERROR(FN);

COMMENT "****** CASE (F) ******";

IF NOT FIRSTF THEN BEGIN

COMMENT "BUILD AN F-NODE IN THE DEVELOPING
         LIST STRUCTURE.";

NEWNODE(IA,NODE); LAST_IA;
NODE[IA]_OPSYM; NODE[IA+2]_FN;
FOR I1_K+1 STEP 1 UNTIL I DO
BEGIN
	NEWNODE(JA,NODE);
	NODE[JA]_P[I1];
	NODE[LAST+1]_JA;
	LAST_JA
END;
NODE[LAST+1]_0;
I_K-1;
PUSH(-IA);
NARGS_1;
  RETURN   END;



COMMENT "HERE WE PROCESS THE HEAD OF A
         FUNCTION OR DERIVATIVE OF A FUNCTION BY
         ENTERING THE APPROPRIATE STUFF IN THE
         SYMTAB ENTRY FOR THE FUNCTION.";





BEGIN "FCTHEAD"
           IF TYPE[FN] NEQ UNKNOWN 
              THEN BEGIN OUTSCR((TEMPSTRING_NAME[FN])&" WAS IN USE. IT HAS BEEN REDEFINED.");
                         DELETEENTRY(FN); FN_SYMTABENTRY(TEMPSTRING) END;
         IF K NEQ 0 THEN SYNTAXERROR(12);

        IF NARGS GEQ SIZEABLOCK THEN ERROR("TOO MANY ARGUMENTS");
        NEWNODE(IA,A); NEWNODE(IDX[FN],NODE);
        NODE[IDX[FN]]_0;
	NODE[IDX[FN]+2]_0;
        NODE[IDX[FN]+1]_IA;
          A[IA]_NARGS;

          FOR I1_K+1 STEP 1 UNTIL I DO BEGIN
		COMMENT WE COULD DELETE ARGS WHICH ARE OF
			TYPE UNKNOWN;
                            IA_IA+1;
                          IF NAME[P[I1]]=" " THEN TYPEFORMERROR(-1);
                            A[IA]_P[I1];  END;

           I_K;
           COMMENT NEGATE FCT HEAD TOKEN IN STACK.
                   WE WILL TEST IT LATER TO BE SURE WE'VE BEEN HERE!;
           P[I]_-P[I];

	   NARGS_1;
           FIRSTF_FALSE;

    END "FCTHEAD";




END "CASE F" ELSE IF OPSYM=COMMA THEN BEGIN

COMMENT "****** CASE (,) ******";

      NARGS_NARGS+1

END ELSE IF (OPSYM GEQ 3 AND OPSYM LEQ 18) OR OPSYM = UMINUS
            OR OPSYM=ABSUOP OR OPSYM=IFOP OR OPSYM=THENOP 
    THEN BEGIN

COMMENT "****** CASE (MAIN-EQUALS OR UNARY OP OR BINARY OP = * / + - _      ) *****";

IF I = 1 AND OPSYM = EQUALOP AND J=0 THEN 
	BEGIN
        IF U=CLOSEBRACKET THEN GOTO ERR;
        IF NOT(U=CR OR U=SEMICOLON) THEN BEGIN
        COMMENT --NOT A MAIN-EQUAL AFTER ALL! PUT THE = BACK
                ON OP, AND "PROTECT" IT TIL THE END WITH A
                COMMA. ;
        OP[J_J+1]_OPSYM; OP[J_J+1]_COMMA; RETURN;
                                         END;
	IF P[I] > 0 THEN BEGIN NEWNODE(IA,NODE);
		               NODE[IA]_UPLUS;
			       NODE[IA+1]_P[I];
			       P[I]_-IA
			 END;
        FN_-P[I-1];
        IF FN LEQ 0 THEN GOTO ERR;
        TYPE[FN]_IF FCTSW=1 THEN INITIAL ELSE FUNCTION;
	NODE[IDX[FN]]_-P[I]; I_-1;
	RETURN;
	END;

COMMENT AVOID UNARY MINUS OF A CONSTANT;

	IF OPSYM = UMINUS AND (IA_P[I])>0 AND TYPE[IA]=CONSTANT
	THEN
	BEGIN
	   P[I]_STORECON(-REL(VALUE[IA]));
	   RETURN;
	END;
  NEWNODE(IA,NODE);
  NODE[IA]_OPSYM;
  NODE[IA+2]_0;
IF UNARYOP(OPSYM) 
   OR OPSYM=IFOP OR OPSYM=THENOP  THEN GO TO ONEARG;
       POP(NODE[IA+2]);
ONEARG: POP(NODE[IA+1]);
        PUSH(-IA);
RETURN
 END

ELSE IF OPSYM=ELSEOP THEN
BEGIN POP(IA); POP(JA);
       NODE[-JA+2]_IA; NODE[-P[I]+2]_-JA
END

ELSE IF OPSYM=DIFFOP THEN
BEGIN  POP(IA); POP(JA);
       PUSH(SYMTABENTRY(MAKEDIFFNAME(JA,IA)))
END

ELSE ERR:SYNTAXERROR(4)
END "FCTBODYPROC";

INTERNAL PROCEDURE PROCESS;
COMMENT                    
                     -------
THIS PROCEDURE INTERPRETIVELY EXECUTES THE PHRASE
 ON THE TOP OF THE POLISH STACK.

;

BEGIN "PROCESS"

INTEGER V1,V2;
INTEGER XLINES,XTIC,XLABL,
        YLINES,YTIC,YLABL,
        CHANNEL;

SAFE REAL ARRAY ITEMVAR R1;
SAFE INTEGER ARRAY ITEMVAR R;
  INTEGER SHI,
        SLOW;
REAL XMIN,XMAX,YMIN,YMAX,XT;
STRING PLOTSYMBOLS;

LABEL ASSIGN,DELL,APPLYF,GETSIZE,ASGNM,ASGNS,DEFGET,DRAWCURVE;

REAL PROCEDURE EXTREMEVAL(SAFE REAL ARRAY M; INTEGER COLUMN; REAL FACTOR);
BEGIN
     INTEGER I;  REAL T,J;

     T_M[1,COLUMN]*FACTOR;
     FOR I_2 STEP 1 UNTIL ROWSIZE(M) DO BEGIN
             IF (J_FACTOR*M[I,COLUMN])>T THEN T_J  END;
     RETURN(FACTOR*T)
END;


POP(OPSYM);

IF I=-1 THEN IF OPSYM NEQ FCTTOKEN AND
                OPSYM NEQ INITIALTOKEN AND
                OPSYM NEQ TYPETOKEN AND 
                OPSYM NEQ PRINTTOKEN AND 
                OPSYM NEQ SAVETOKEN AND
                OPSYM NEQ FORTOKEN        THEN SYNTAXERROR(10);

IF FCTSW THEN BEGIN FCTBODYPROC; RETURN  END;

CASE OPSWITCH[OPSYM] OF BEGIN 

COMMENT "****** CASE 0 (ERROR) *****";

         BEGIN SYNTAXERROR(5) END;

COMMENT "****** CASE 1 (,) ******";

         BEGIN NARGS_NARGS+1 END;

COMMENT "****** CASE 2 (ABS) ******";

         BEGIN POP(V1); PUSH(ABSOP(E(V1))) END;

COMMENT "****** CASE 3 (FCT) ******";

         BEGIN FCTSW_IF OPSYM=INITIALTOKEN THEN 1 ELSE -1; FIRSTF_TRUE  END;

COMMENT "****** CASE 4 (+ - <= >= = NOT= > < AND OR) ******";

BEGIN IF OPSYM=EQUALOP AND (U=CR OR U=SEMICOLON OR U=DOOP) 
          THEN IF I=1 AND J=0 THEN GOTO ASSIGN;
       POP(V2); POP(V1);
        PUSH(BINOPS(E(V1),E(V2),BINOPSCODE[OPSYM]))
END;

COMMENT "****** CASE 5 (^)*******";

BEGIN  POP(V2); POP(V1); PUSH(POWER(E(V1),E(V2))) END;

COMMENT "****** CASE 6 (_) ******";

ASSIGN:
BEGIN
      INTEGER B1;
      LABEL ERR,ASNEXIT;

      SAFE INTEGER ARRAY ITEMVAR M,W;
 
      IF OP[J]=STRINGTOKEN OR OP[J]=DRAWTOKEN THEN BEGIN
                                              ARROWSW_TRUE; RETURN 
                                                   END;
      IF NARGS NEQ 1 THEN SYNTAXERROR(14);

                POP(V2); POP(V1);

      V2_E(V2);

	IF FORSWITCH THEN BEGIN "FORCLAUSE"
		IF (LPLEVEL_LPLEVEL+1)>MAXNOLOOPS THEN ERROR("LOOPS NESTED TOO DEEP");;
		LPSTRING[LPLEVEL]_B;
		B_'01;
		IF TYPE[V1]=UNKNOWN THEN TYPE[V1]_SCALAR;
                IF TYPE[V1] NEQ SCALAR THEN TYPEFORMERROR(V1);
		LPV[LPLEVEL]_V1;
		LPLIST[LPLEVEL]_V2;
		LPPTR[LPLEVEL]_0;
		RETURN
	END "FORCLAUSE";

IF EQU(TEMPSTRING_NAME[V1],"DISPLAY") THEN BEGIN
                                RELDIS_FALSE;
                                GINIT(NAME[V2]);
                                DELETEENTRY(V2); DELETEENTRY(V1);
				RETURN
                                END;

IF EQU(TEMPSTRING,"DEQRELERR") THEN BEGIN
   COMMENT SET REL ERR FOR DEQ SOLVING;
   DEQRELERR_REL(VALUE[V2]);
   DELETEENTRY(V1);
   GOTO ASNEXIT                     END;


      IF TYPE[V1]=SUBSCR THEN

      BEGIN "SUBSCR" 

      IF TYPE[V2] = SCALAR OR TYPE[V2]=CONSTANT THEN B1_VALUE[V2] 
      ELSE IF TYPE[V2]=MATRIX THEN BEGIN R_CVI(VALUE[V2]); B1_DATUM(R)[1,1] END 
                              ELSE ERR:TYPEFORMERROR(-1);

      SHI_(VALUE[V1] ROT 18) LAND '777777; SLOW_VALUE[V1] LAND '777777;
      IF SHI LEQ 0 OR SLOW LEQ 0 THEN ERROR("ILLEGAL INDEX FOR MATRIX");

        IF TYPE[IDX[V1]] = UNKNOWN THEN
        BEGIN
           COMMENT SETUP ITEM WITH MATRIX;
        SAFE INTEGER ARRAY T[1:SHI,1:SLOW];
        R_NEW(T);
        TYPE[IDX[V1]]_MATRIX;
        VALUE[IDX[V1]]_CVN(R);
        END ELSE BEGIN
        R_CVI(VALUE[IDX[V1]]);
         EXPANDARRAY(R,SHI,SLOW);
               END;

      DATUM(R)[SHI,SLOW]_B1;
      FREET(V2); FREET(V1);
        RETURN
      END "SUBSCR";

IF TYPE[V1]=ROW OR TYPE[V1]=COL THEN
BEGIN "ROWCOL"

IF TYPE[IDX[V1]] NEQ MATRIX THEN GOTO ERR;

IF TYPE[VALUE[V1]]=UNKNOWN THEN BEGIN
   OWN SAFE INTEGER ARRAY T[1:1,1:1];
   TYPE[VALUE[V1]]_MATRIX;
   R_NEW(T);
   VALUE[VALUE[V1]]_CVN(R);     END
        ELSE IF TYPE[VALUE[V1]] NEQ MATRIX OR NAME[VALUE[V1]]=" " THEN GOTO ERR;


M_CVI(VALUE[VALUE[V1]]);


W_CVI(VALUE[IDX[V1]]);  R_CVI(VALUE[V2]);

IF TYPE[V2] = MATRIX THEN BEGIN D1_ROWSIZE("DATUM(R)");
			        D2_COLSIZE("DATUM(R)")  END
		     ELSE D1_D2_1;

IF TYPE[V1]=ROW THEN D1_SIZE("DATUM(W)");
IF TYPE[V1]=COL THEN D2_SIZE("DATUM(W)");


FOR I1_D1 STEP -1 UNTIL 1 DO 
FOR J1_D2 STEP -1 UNTIL 1 DO BEGIN
        SHI_IF TYPE[V1]=ROW THEN GETLINEAR(DATUM(W),I1) ELSE I1;
       SLOW_IF TYPE[V1]=COL THEN GETLINEAR(DATUM(W),J1) ELSE J1;
     EXPANDARRAY(M,SHI,SLOW);
      DATUM(M)[SHI,SLOW] _ IF TYPE[V2]=MATRIX THEN DATUM(R)[I1,J1] ELSE VALUE[V2];
                           END;

FREET(V2);
FREET(IDX[V1]); FREET(VALUE[V1]);  FREET(V1);
RETURN
  END "ROWCOL";
 
   SLOW_TYPE[V1];

IF (SHI_TYPE[V2]) = MATRIX THEN 
       IF SLOW = UNKNOWN THEN 
        BEGIN
          TYPE[V1]_MATRIX;
    ASGNM: R_CVI(VALUE[V2]);
           VALUE[V1]_CVN(NEW(DATUM(R)));
        END
        ELSE IF SLOW=MATRIX THEN
        BEGIN
          DELETE(CVI(VALUE[V1]));
          GOTO ASGNM
        END
        ELSE IF NUMBER(SLOW) OR SLOW=FUNCTION THEN
        BEGIN
          R_CVI(VALUE[V2]);
          VALUE[V1]_DATUM(R)[1,1];
        END
        ELSE GOTO ERR

ELSE IF NUMBER(SHI) THEN
        IF SLOW=UNKNOWN THEN 
        BEGIN
          TYPE[V1]_SCALAR;
          GOTO ASGNS
       END
        ELSE
        IF SLOW = MATRIX THEN 
        BEGIN
          R_CVI(VALUE[V1]);
          D1_ROWSIZE("DATUM(R)");
          D2_COLSIZE("DATUM(R)");
          FOR I1_1 STEP 1 UNTIL D1 DO FOR J1_1 STEP 1 UNTIL D2 DO
          DATUM(R)[I1,J1]_VALUE[V2];
        END
        ELSE IF NUMBER(SLOW) OR SLOW=FUNCTION OR SLOW=INITIAL THEN
ASGNS:    VALUE[V1]_VALUE[V2]
        ELSE GOTO ERR
ELSE IF SHI=WINDOW OR SHI=FUNCTION OR SHI=CURVE THEN
        IF SLOW=UNKNOWN THEN
        BEGIN
          TYPE[V1]_SHI;
          VALUE[V1]_VALUE[V2];
          IDX[V1]_IDX[V2];
          IF SHI NEQ FUNCTION THEN BEGIN "FIXCIRCLE"
                I1_V2;
                WHILE VALUE[I1] NEQ V2 DO I1_VALUE[I1];
                VALUE[IF I1=V2 THEN V1 ELSE I1]_V1;      END  "FIXCIRCLE";
          NAME[V2]_" ";  RETURN;
        END
        ELSE GOTO ERR
ELSE GOTO ERR;


ASNEXIT:
FREET(V2)
END;


COMMENT "****** CASE 7 (*) *******";

BEGIN  POP(V2); POP(V1); PUSH(TIMES(E(V1),E(V2))) END;

COMMENT "****** CASE 8 (/) *******";

BEGIN  POP(V2); POP(V1); PUSH(DIVIDE(E(V1),E(V2))) END;

COMMENT "****** CASE 9 (ROW COL *******";

BEGIN  POP(V2); POP(V1);
       BEGIN  INTEGER J;
              V1_E(V1);
              V2_E(V2);
              J_NEWTEMP;
              TYPE[J]_IF OPSYM=ROWOP THEN ROW ELSE COL;
              VALUE[J]_V1;
              IDX[J]_V2;
              PUSH(J)
       END
END;


COMMENT "****** CASE 10  (TRANSPOSE) *******";

         BEGIN  POP(V1); PUSH(TRANSPOSE(E(V1))) END;

COMMENT "****** CASE 11 (&) *******";

         BEGIN  POP(V2); POP(V1); PUSH(ROWCON(E(V1),E(V2))) END;

COMMENT "****** CASE 12 (&') *******";

         BEGIN  POP(V2); POP(V1); PUSH(COLCON(E(V1),E(V2))) END;

COMMENT "****** CASE 13 (F (FUNCTION APPLICATION)*) *******";

APPLYF:  BEGIN
         VALSW_FALSE;
         FOR V1_I-NARGS+1 STEP 1 UNTIL I DO P[V1]_E(P[V1]);
         DOFUNC;
        NARGS_1;
        END;

COMMENT "****** CASE 14 (:) *******";

         BEGIN  POP(V2); POP(V1); 
                PUSH(PCOLON(IF TYPE[V1]=COLON THEN V1 ELSE E(V1),E(V2))) END;

COMMENT "****** CASE 15 (FIT) *******";
         BEGIN SAFE INTEGER ARRAY PARM[1:I+1];
               WHILE I GEQ 0 DO BEGIN
                                IF NOT(TYPE[P[I]]=SCALAR) THEN TYPEFORMERROR(P[I]);
                                POP(PARM[I+1])
                                END;
               IF J=1 AND OP[1]=QUIET THEN BEGIN
                                        QUIETSW_TRUE; J_0;
                                          END;
               IF (FITN_FITN-1)=0 THEN SYNTAXERROR(15);
               FITDRIVER(PARM)
        END;
COMMENT "****** CASE 16 (HELP) *******";
         BEGIN POP(V1); V1_REL(VALUE[V1]);
               IF NARGS>1 THEN BEGIN POP(V2);
                               V2_REL(VALUE[V2]);
                               V1 SWAP V2   END
                          ELSE V2_1;
                HELPPAGE(V1,V2);END;
COMMENT "****** CASE 17 (TYPE) *******";

           TYPOUT;

COMMENT "****** CASE 18 (DELETE) *******";
         BEGIN DELL:POP(V1); DELETEENTRY(V1); 
                    IF I NEQ -1 THEN GOTO DELL
         END;
COMMENT "****** CASE 19 (INTENSITY) *******";
         BEGIN POP(V1); INTENSITY_REL(VALUE[V1]);  END;
COMMENT "****** CASE 20 (BLANK) *******";
         WHILE I GEQ 0 DO BEGIN POP(V1); CBLANK(V1) END;
COMMENT "****** CASE 21 (UNBLANK) *******";
         WHILE I GEQ 0 DO BEGIN POP(V1); CUNBLANK(V1) END;
COMMENT "****** CASE 22 (TO) *******";
         BEGIN 
               IF FITN > MAXFITDIM THEN ERROR("TOO MANY FUNCTIONS.");
               POP(V1); FITM[FITN]_E(V1); POP(FITF[FITN]);
               FITW[FITN_FITN+1]_0;
               NARGS_1;
         END;
COMMENT "****** CASE 23 (BY) *******";
         BEGIN 
      POP(V1); BYH_REL(VALUE[V1]); FREET(V1);
      POP(V1); BYW_REL(VALUE[V1]); FREET(V1);
        END;
COMMENT "****** CASE 24 (IN) *******";
         BEGIN  POP(WINDOWIDX)  END;

COMMENT "****** CASE 25 (AT) *******";
         BEGIN 
      POP(V1); ATY_REL(VALUE[V1]); FREET(V1);
      POP(V1); ATX_REL(VALUE[V1]); FREET(V1);
END;
COMMENT "****** CASE 26 (WT) *******";
         BEGIN POP(V1); FITW[FITN]_E(V1)  END;
COMMENT "****** CASE 27 (DRAW STRING) *******";
         BEGIN IF I GEQ 2 THEN SYNTAXERROR(9);
               IF J=1 AND OP[1]=VERTICAL THEN BEGIN XYFLOATINGVAL_1; J_0 END;
               POP(V2);
               IF NOT ARROWSW THEN IF TYPE[V2]=CURVE THEN BEGIN
                  V1_V2; V2_IF OPSYM=STRINGTOKEN THEN 0 ELSE -1; GOTO DRAWCURVE
                                                          END;
              
                V2_E(V2);
               IF I GEQ 0 THEN BEGIN POP(V1) END
                          ELSE BEGIN SETFORMAT(0,3); DO 
                               V1_SYMTABENTRY("TEMPC"&CVS(CURVENO_CURVENO+1)) UNTIL TYPE[V1]=UNKNOWN END;

               IF TYPE[V1] = CURVE THEN GO TO DRAWCURVE;

               IF TYPE[V2]=TEXT THEN IF WINDOWIDX=0 THEN   GOTO DEFGET ELSE GOTO DRAWCURVE;

               R1_CVI(VALUE[V2]);

               IF TYPE[V2] NEQ MATRIX OR COLSIZE("DATUM(R1)") NEQ 2 THEN TYPEFORMERROR(V2);

        IF WINDOWIDX=0 THEN 
        BEGIN
               XMIN_EXTREMEVAL(DATUM(R1),1,-1);
               YMIN_EXTREMEVAL(DATUM(R1),2,-1);
               XMAX_EXTREMEVAL(DATUM(R1),1,1);
               YMAX_EXTREMEVAL(DATUM(R1),2,1);
        DEFGET: IF TYPE[WINDOWIDX_SYMTABENTRY("DEFAULTWINDOW")]=UNKNOWN THEN 
              BEGIN
               COMMENT GET IN THE STANDARD DEFAULTWINDOW;
                PUSH(SYMTABENTRY("*"&MASTERDEVICE&":DEFAULTWINDOW"&MASTERPPN));
                DSKUSE ;
               GOTO GETSIZE
             END;

            COMMENT DIG UP DEFAULTWINDOW PARAMETERS;
            DWATX_REL(A[I1_IDX[WINDOWIDX]]);
            DWATY_REL(A[I1+2]);
            BYW_REL(A[I1+1]);
            BYH_REL(A[I1+3]);


            IF XMAX<BYW THEN XMAX_BYW;
            IF XMIN>DWATX THEN XMIN_DWATX;

            IF YMAX<BYH THEN YMAX_BYH;
            IF YMIN>DWATY THEN YMIN_DWATY;
    
GETSIZE:
                IF TYPE[V2]=TEXT THEN GOTO DRAWCURVE;
           WINDOWP(WINDOWIDX,XMAX-XMIN,YMAX-YMIN,XMIN,YMIN)
        END;
  DRAWCURVE:
		 DRAW(V1,V2,WINDOWIDX,LINETYPEVAL,
			PTTYPEVAL,XYFLOATINGVAL,SIZEVAL,PTLABELIDX,LABELSKIP,ATX,ATY,INTENSITY);
		 IF V2>0 THEN IF TYPE[V2]=TEXT THEN DELETEENTRY(V2) ELSE FREET(V2);
                   IF PTLABELIDX GEQ 0 THEN FREET(PTLABELIDX)
	  END;
COMMENT "****** CASE 28 (WINDOW) *******";
         BEGIN POP(V1); WINDOWP(V1,BYW,BYH,ATX,ATY) END;
COMMENT "****** CASE 29 (IMAGE) *******";
         BEGIN POP(V1); IMAGE(V1,BYW,BYH,ATX,ATY)  END;
COMMENT "****** CASE 30 (INSCRIBE) *******";
         WHILE I GEQ 0 DO BEGIN POP(V1); INSCRIBE(V1) END;
COMMENT "****** CASE 31 (UNSCRIBE) *******";
         WHILE I GEQ 0 DO BEGIN POP(V1); UNSCRIBE(V1) END;
COMMENT "****** CASE 32 (SIZE) *******";
         BEGIN 
      POP(V1); SIZEVAL_REL(VALUE[V1])
END;
COMMENT "****** CASE 33 (SAVE) *******";
         DSKSAV;
COMMENT "****** CASE 34 (USE) *******";
         DSKUSE;
COMMENT "****** CASE 35 (PTTYPE) *******";
         BEGIN  POP(V1);
                 IF NUMBER(TYPE[V1]) THEN PTTYPEVAL_REL(VALUE[V1])
                                     ELSE PTTYPEVAL_CVASC(NAME[V1]);
                 FREET(V1);
           END;
COMMENT "****** CASE 36 (LINETYPE) *******";
         BEGIN POP(V1); LINETYPEVAL_REL(VALUE[V1])   END;
COMMENT "****** CASE 37 (PTLABEL) *******";
         BEGIN END;
COMMENT "****** CASE 38 (WITH) *******";
         BEGIN IF NARGS=2 THEN BEGIN POP(V1);
                                     LABELSKIP_REL(VALUE[V1])  END ELSE LABELSKIP_1;
         POP(PTLABELIDX); PTLABELIDX_E(PTLABELIDX) END;
COMMENT "****** CASE 39 (XFLOATING) *******";
         BEGIN  XYFLOATINGVAL_1  END;
COMMENT "****** CASE 40 (YFLOATING) *******";
         BEGIN  XYFLOATINGVAL_-1  END;
COMMENT "****** CASE 41 (PLOT) *******";
         BEGIN SAFE REAL ARRAY BUF[1:128];
		POP(V1); BUF[2]_BUF[3]_REL("VALUE[E(V1)]"); 
                IF BUF[2]*DISINFO[6]>11 THEN BUF[7]_30;
		BUF[1]_314159; DPLOT (BUF[1],0);  "REST IS DEFAULTED"
	 END;
COMMENT "****** CASE 42 (LIST) *******";

         BEGIN  SAFE INTEGER ARRAY ARGS[1:NARGS];
                 INTEGER S;

                FOR S_NARGS STEP -1 UNTIL 1 DO BEGIN
                  IF TYPE[P[I]]=COLON 
                  THEN ARGS[S]_P[I]
                  ELSE 
                    ARGS[S]_E(P[I]); I_I-1  END;
                
                PUSH(LIST(ARGS));
                NARGS_1
         END;

COMMENT "*******CASE 43 (CR) *******";

BEGIN   END;

COMMENT "****** CASE 44 (-UNARY) *******";
BEGIN 
      POP(V1); PUSH(BINOPS(ZERO,E(V1),1))
END;
COMMENT "****** CASE 45 (NOT) *******";
BEGIN  POP(V1); PUSH(BINOPS(ZERO,E(V1),4))  END;
COMMENT "****** CASE 46 (PRINTERDRAW TTYDRAW) *******";
        BEGIN

            POP(V1); IF I GEQ 0 THEN BEGIN
                                         PLOTSYMBOLS_NAME[V1][2 TO INF];
                                        POP(V1)   END
                          ELSE PLOTSYMBOLS_"ABCDEFG";
           V1_E(V1);
           IF TYPE[V1] NEQ MATRIX THEN TYPEFORMERROR(V1);
           R1_CVI(VALUE[V1]);

           IF OPSYM=TTYDRAW THEN CHANNEL_6
                            ELSE BEGIN 
                                 OPEN(CHANNEL_1,"LPT",0,0,2,0,SHI,SHI_1);
                                 IF SHI THEN ERROR("CANNOT USE LPT");
                                 ENTER(CHANNEL,"FILEPLOT.TXT",0)
                                 END;

           XTIC_6;YTIC_4;
           XLABL_1;YLABL_1;
           XMIN_EXTREMEVAL(DATUM(R1),1,-1);
           XMAX_EXTREMEVAL(DATUM(R1),1,1);
           YMIN_EXTREMEVAL(DATUM(R1),2,-1);
           YMAX_EXTREMEVAL(DATUM(R1),2,1);
	FOR SHI_COLSIZE("DATUM(R1)") STEP -1 UNTIL 3 DO
	BEGIN
	   XT_EXTREMEVAL(DATUM(R1),SHI,-1);
	   IF XT<YMIN THEN YMIN_XT;
	   XT_EXTREMEVAL(DATUM(R1),SHI,1);
	   IF XT > YMAX THEN YMAX_XT;
	END;
           IF XMAX=XMIN THEN XMAX_XMAX+.01;
           IF YMAX=YMIN THEN YMAX_YMAX+.01;
           IF BYW=DEFAULTBY THEN BEGIN
           IF CHANNEL=1 THEN BEGIN XLINES_120;YLINES_56 END ELSE BEGIN XLINES_60; YLINES_20 END;
                                 END ELSE BEGIN XLINES_BYW; YLINES_BYH END;

           TYPLOT(DATUM(R1),YLINES,XLINES,XTIC,YTIC,XLABL,YLABL,CHANNEL,XMAX,XMIN,YMAX,YMIN,PLOTSYMBOLS);

           RELEASE(1);
           FREET(V1);
      END;

COMMENT "****** CASE 47 (ON) *******";

BEGIN POP(V2); POP(V1); V2_E(V2);
      IF NUMBER(TYPE[V2]) THEN BEGIN I_I+2; GOTO APPLYF END;
      IF TYPE[V2] NEQ MATRIX THEN TYPEFORMERROR(V2);
      R1_CVI(VALUE[V2]);
      BEGIN SAFE REAL ARRAY FV[1:ROWSIZE("DATUM(R1)"),1:1];
      BEGIN SAFE REAL ARRAY FVAL[1:ROWSIZE("DATUM(R1)")];
            DOVECTORF(V1,COLSIZE("DATUM(R1)"),0,DATUM(R1),FVAL);
            ARRTRAN(FV,FVAL);
      END;
            PUSH(BPUTANS(ONE,V2,CVN(NEW(FV)),MATRIX,0));
      END;
END;
COMMENT "****** CASE 48 (EXIT) *******";
        BEGIN COMMENT CALL RUNRTN (FOR BBN PROPHET PEOPLE), ELSE ENTER MONITOR.;
        COMMENT EXTERNAL PROCEDURE RUNRTN;  COMMENT FOR BBN/PROPHET ONLY;
        COMMENT REQUIRE "RUNRTN" LOAD!MODULE;   COMMENT FOR BBN/PROPHET ONLY;
        POP(V1);
        COMMENT RUNRTN;  COMMENT RUNRTN FOR BBN/PROPHET ONLY;
        START!CODE
        MOVEI 1,1;
        EXIT;		  COMMENT EXIT-SYSTEM OP BEING INVOKED.;
        END;
         END;
COMMENT "****** CASE 49 (CONSTRAINTS) *******";
BEGIN  POP(V1); CONPROC(V1) END;
COMMENT "****** CASE 50 (FOR) *******";
         BEGIN FORSWITCH_TRUE; MASTERFORSW_TRUE END;
COMMENT "****** CASE 51 (DIFF) *******";
       BEGIN POP(V2); POP(V1); PUSH(SYMTABENTRY(MAKEDIFFNAME(V1,V2)))  END;
COMMENT "****** CASE 52 (IF) *******";
        BEGIN 
        END;
COMMENT "****** CASE 53 (THEN) *******";
       BEGIN END;
COMMENT "****** CASE 54 (ELSE) *******";
       BEGIN I_I-2; IFSW_VALUE[E(P[I])]; FREET(P[I]);
             IFSW_IF IFSW THEN 1 ELSE 2;
             P[I]_P[I+IFSW]; FREET(P[I+3-IFSW]);
       END;
COMMENT "****** CASE 55 (GET) *******";
       BEGIN EXTERNAL INTEGER PROCEDURE DGET;
	     POP(V1);
                  RELDIS_FALSE;
	     GINIT(CURRENTDIS);      "NOW GINIT WILL TRY TO GET THE DISPLAY"
             IF TYPE[V1]=UNKNOWN THEN DELETEENTRY(V1);
       END;

COMMENT "****** CASE 56 (RELEASE) *******";
       BEGIN POP(V1); RELDIS_TRUE; IF DISINIT THEN DREL; 
             IF TYPE[V1]=UNKNOWN THEN DELETEENTRY(V1) END;

COMMENT "****** CASE 57 (DO) ******";
        BEGIN
	COMMENT THE DO COMMAND MUST GIVE A FILE NAME AS
	        "NAME.EXT[A,B]" OR NAME (WHICH IMPLIES NAME.DAT
	        ON THE USER'S AREA).;
	COMMENT A DO FILE MUST BE AN SOS FILE WHICH REPRESENTS A
	        SEQUENCE OF MLAB COMMANDS AND RESPONSES, THE
	        COMMANDS MUST ALL BE TERMINATED BY SEMICOLONS.
	        <CR>'S AND <LF>'S ARE IGNORED.;
        COMMENT NOTE DO "TTY:" IS OK! ;

STRING S,T;
         POP(V1);

        IF (TEMPSTRING_NAME[V1])="*" THEN EOF_LOP(TEMPSTRING) ELSE TEMPSTRING_TEMPSTRING&".DAT";
        T_SCAN(S_TEMPSTRING,2,BRCHAR);
        IF BRCHAR NEQ ":" THEN
        BEGIN
        COMMENT NO DEVICE SPECIFIED. ;
        S_TEMPSTRING;
        T_"DSK";
        END
        ELSE
        COMMENT STRIP OFF :;
        EOF_LOP(S);
COMMENT
        T = DEVICE
        S = FILNAM.EXT[PP]
;
              DELETEENTRY(V1);
              U_SEMICOLON;
IF NOT EQU(T,"TTY") THEN BEGIN 
              OPEN(3,"DSK",0,1,0,2000,BRCHAR,EOF);
               LOOKUP(3,S,EOF);
               IF EOF THEN ERROR("CANNOT FIND DO FILE");
                        END;
IF EQU(T,"TTY") THEN BEGIN
        TEMPSTRING_NULL;
	DO BEGIN	OUTSTR(CRLF&"*");

                        TEMPSTRING_INPUT(6,1)&TEMPSTRING;
	END UNTIL BRCHAR NEQ '33;
                     END ELSE BEGIN TEMPSTRING_INPUT(3,10); RELEASE(3) END;
              B_TEMPSTRING&";"&B&'01;
       S_T_TEMPSTRING_NULL;
       END;
COMMENT "****** CASE 58(PRINT) *******";
	BEGIN PRINTSW_TRUE; TYPOUT END;

END ;

END "PROCESS";
COMMENT
"******  BEGINNING OF MAIN PROGRAM CODE ******"
"THE FOLLOWING CODE DEFINES AND INITIALIZES VARIOUS DEVICES
AND VARIABLES.

   1.  THE USERS TTY IS OPENED ON CHANNEL 6.
   2.  VARIOUS BREAKTABLES FOR SCANNING ARE SET UP.

";


SETBREAK(1,'15&'175&'33,'14&'12&'13,"ISN");

COMMENT
"BREAKTABLE 1 OMITS FF, LF AND VTAB, AND BREAKS ON CR AND ALT."
THE CR OR ALT IS SKIPPED.
;

SETBREAK(2,"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",NULL,"XR");

COMMENT
"BREAKTABLE 2 BREAKS ON EVERY CHARACTER EXCEPT LETTERS OR DIGITS."
THE BREAKCHAR IS THE FIRST CHAR IN THE NEXT READ.
;

COMMENT BREAK-TABLES 10 AND 11 ARE USED IN THE PROCEDURE HELPPAGE WHICH TYPES FROM THE HELP FILE SYS:MLABD.TXT ;
              SETBREAK(10,NULL,CRLF&'11&'14&'177,"IN");
SETBREAK(11,'14&'12,NULL,"INA");


COMMENT "SETUP FREESPACE LIST OF 3 WD NODES IN NODE
         ,AND 15 WORD NODES IN A.";

J_0;
FOR I_1 STEP SIZENODEBLOCK UNTIL SIZENODEM1 DO BEGIN NODE[J]_I; J_I  END;
J_0;
FOR I_1 STEP SIZEABLOCK UNTIL SIZEAM1 DO BEGIN  A[J]_I; J_I  END;

COMMENT FREE LEAP HASH TABLE AREA - FOR OLDER SAIL COMPILERS ONLY!.;
START!CODE
COMMENT   MOVE  1,GOGTAB;
COMMENT   MOVE  2,HASTAB(1);
COMMENT   PUSHJ 15,CORREL;
END;


COMMENT "INITIALIZE VARIOUS VARIABLES.";

INITSYMTAB;
DISINIT_FALSE;
RELDIS_TRUE;
CURRENTDIS_"DEC340";
DEQRELERR_.001;

COMMENT SET UP PHONEY FUNCTIONS TEMPH,TEMPDH;

NEWNODE(I,A);
NEWNODE(J,NODE);
IDX[TEMPH]_J;
NODE[J+1]_I;

NEWNODE(U,NODE);
NODE[U]_UPLUS;
NODE[U+1]_ZERO;
NODE[J]_U;

NEWNODE(J,NODE);
IDX[TEMPDH]_J;
NODE[J+1]_I;

NEWNODE(U,NODE);
NODE[U]_UPLUS;
NODE[U+1]_ZERO;
NODE[J]_U;



COMMENT
"HERE WE GET AN INPUT COMMAND.  WHEN SUCH A COMMAND IS
RECEIVED IT IS DECOMPOSED AND PROCESSED, CAUSING
VARIOUS DATA STRUCTURES TO BE MODIFIED OR GENERATED.  WHEN THIS
IS COMPLETED, CONTROL RETURNS TO THIS POINT WHEREUPON
WE GET ANOTHER COMMAND."
;



HOME: REENTERFLAG_FALSE;
COMMENT THIS WILL CAUSE MLAB TO RUN AT THE PROCEDURE REENTER DEFINED ABOVE WHEN A "REENTER" IS TYPED TO THE MONITOR.  THE
PROCEDURE REENTER WILL, IN TURN, FORCE A PDL OVERFLOW WHICH WILL
LEAD TO A CLEAN-UP OF THE STACK (VIA A SPECIAL CLEAN-UP,FOLLOWED BY A NON-LOCAL GOTO) AND A BRANCH BACK TO LOCATION HOME (JUST BELOW)!
  ;
START!CODE
   MOVEI 1,REENTER;
   MOVEM 1,'124;
END;

COMMENT ALL ARITHEMETIC TROUBLES ARE REFERRED TO PDLOVHANDLER WHO WILL FIX UP RESULTS AND TYPE A MESSAGE AND CONTINUE - OR
DO NOTHING AND CONTINUE IF A JFCL OCCURS INDICATING THE TROUBLE
IS EXPECTED!;


IFC NOT TENEXSW THENC
INTMAP(29,APRFIX,0);
INTMAP(32,APRFIX,0);
INTMAP(19,PDLOVHANDLER,0);
ENABLE(29);
ENABLE(32);
ENABLE(19);

ELSEC
INTMAP(7,APRFXF,0);
INTMAP(6,APRFXO,0);
INTMAP(9,PDLOVHANDLER,0);
ENABLE(7);
ENABLE(6);
ENABLE(9);

ENDC


COMMENT SETTING !ERRP! WILL REPLACE THE NORMAL SAIL ERRMSG ROUTINE BY OUR ROUTINE, ERRHANDLER!  IT WILL NOW BE RECIEVING ALL USERERR CALLS.
IT WILL TYPE AN APPROPRIATE MESSAGE AND THEN LET THE SAIL ERRMSG HANDLER SILENTLY RETURN THE THE TROUBLE POINT (IF CONTINUABLE) OR
LET IT ENTER THE NON-LOCAL GOTO PROCEDURE GOHOME (IF FATAL), IN WHICH CASE, GOHOME WILL
GET THE STACKS CLEANED UP AS A SIDE-EFFECT!!!
;
!ERRP!_LOCATION(ERRHANDLER);

OPEN(6,"TTY",0,1,1,200,BRCHAR,EOF);
COMMENT SET "TTY NO LC" (LOWER TO UPPER CASE CONVERSION) FOR THE USERS TTY.  ;
START!CODE

IFC NOT TENEXSW THENC
  MOVNI 1,1;
  TTCALL 6,1;   COMMENT "GETLCH IN 1";
  TLZ 1,'000020;
  TTCALL 7,1;  COMMENT "SETLCH FROM 1";

ELSEC
  MOVEI	1,'100;
  RFMOD;
  TLZ  2,'177;
  TRO  2,'20;
  SFMOD;
  STPAR;

ENDC


END;
MASTERFORSW_FALSE;
CLEANUP;
HIFREE_SPANFREE_TEMPCHR_0;
LPLEVEL_0;
B_NULL;

START:

I_-1; J_-1;
OP[J_J+1]_STACKBOTTOM;

IF MASTERFORSW THEN BEGIN
FORSTART: LPPTR[LPLEVEL]_LPPTR[LPLEVEL]+1;
	ITM_CVI(VALUE[LPLIST[LPLEVEL]]);
	IF SIZE("DATUM(ITM)")<LPPTR[LPLEVEL] THEN
	BEGIN
		FREET(LPLIST[LPLEVEL]);
		LPLEVEL_LPLEVEL-1;
		IF LPLEVEL=0 THEN BEGIN
			MASTERFORSW_FALSE;
                        GOTO READST
            			END
		ELSE IF LENGTH(B)=0 THEN GOTO FORSTART ELSE GOTO SETUP
	END;
	
	B_LPSTRING[LPLEVEL];
	VALUE[LPV[LPLEVEL]]_INT("GETLINEAR(DATUM(ITM),LPPTR[LPLEVEL])");
	GO TO SETUP
                    END;

READST:   
SETUP:

IF DISINIT THEN BEGIN ;
	"IF RELDIS=-1 THEN USER HAS SAID 'RELEASE DIS';
	 IF RELDIS=-2 THEN WE RELEASED THE DISPLAY BECAUSE NOTHING WAS VISIBLE
	 IF RELDIS=0, THE DISPLAY IS RUNNING"

		IF RELDIS=0 AND POSTNUMBER=0 THEN BEGIN DREL;  RELDIS_-2 END ELSE
		IF RELDIS=-2 AND POSTNUMBER THEN BEGIN RELDIS_LNOT DGET;
			IF RELDIS THEN OUTSCR ("[DISPLAY NOT AVAILABLE]");
			END;
		DDONE;		"UPDATE DISPLAY"
        END;

IF LENGTH(B)=0 THEN BEGIN
	DO BEGIN	OUTSTR(CRLF&"*");

   			B_B&INPUT(6,1)

	END UNTIL BRCHAR NEQ '33;
	B_B&'01;
END;
 



NARGS_1;
FCTSW_ARROWSW_FALSE;
FITN_1; FITW[1]_0;


ATX_DEFAULTAT; ATY_DEFAULTAT;
BYW_DEFAULTBY; BYH_DEFAULTBY;
SIZEVAL_DEFAULTSIZE;
PTTYPEVAL_DEFAULTPTTYPE; LINETYPEVAL_DEFAULTLINETYPE;
WINDOWIDX_0;
PTLABELIDX_DEFAULTPTLABELIDX;
INTENSITY_DEFAULTINTENSITY;
XYFLOATINGVAL_DEFAULTXYFLOATING;
LABELSKIP_DEFAULTLABELSKIP;

FORSWITCH_FALSE;
QUIETSW_FALSE;
PRINTSW_FALSE;
COMMENT
"*******  TRANSLATE TO POLISH *******"
;



SETVSW:VSW_FALSE;
R:GETTOKEN(U,V);

IF U=ROWOP OR U=COLOP THEN B_"LIST "&B;
IF U=MINUS AND NOT VSW THEN U_UMINUS;
IF U=PLUS AND NOT VSW THEN GOTO R;
IF U=OPENBRACKET THEN BEGIN
                  NARGS_1;
                  IF VSW THEN U_FUNCTIONF;  END;

IF U=ID OR U=CONST THEN BEGIN
			   COMMENT WE COULD PUT THIS CHECK BACK
			   IN IF WE WISHED TO BE STRICT:
			   [IF VSW THEN SYNTAXERROR(99) ELSE];
                           COMMENT  AND WE DO, SO WE DID!;
                          IF VSW THEN IF OP[1] NEQ FITOP THEN SYNTAXERROR(11);
                          BEGIN PUSH(V);
                                VSW_TRUE;   
                                GOTO R      END;
		   END;
TV_COLTOKVAL[U];

IF TV=POLISHPREFIXOP THEN 
                    BEGIN PUSH(U);
                          PROCESS;
                          GOTO R      END;



IF NOT VSW THEN BEGIN 
                IF U=CR OR U=ENDOP OR U=SEMICOLON THEN 
                   COMMENT THE SPECIAL CASE FOR SEMICOLON CATERS TO THE USE: "END SEMICOLON" ;
                                        IF J=0 THEN IF U=SEMICOLON THEN GOTO SETVSW ELSE GOTO START
                                               ELSE IF OP[1]=HELP OR OP[1]=PLOT OR OP[1]=EXIT THEN
                                                    BEGIN PUSH(ONE); GOTO ACTION END
                                               ELSE IF OP[1]=PRINTTOKEN OR OP[1]=TYPETOKEN 
                                                    THEN GOTO ACTION 
                                                    ELSE SYNTAXERROR(6);
                      OP[J_J+1]_U;
                      GOTO R
                END;


ACTION:

IF (RTV_ROWTOKVAL[OP[J]]) LEQ 0 THEN SYNTAXERROR(17);

ACTNO _ (ACTM[(TV-1)*3+(RTV-1)%12]
                ROT
	((((RTV-1)MOD 12)+1)*3))  LAND '7;

IF ACTNO LEQ 0 THEN SYNTAXERROR(7);

CASE ACTNO OF
BEGIN
COMMENT  CASE ACTM(ROWTOKVAL(OP[J]),TV) OF BEGIN;

COMMENT "******* ACTION 0 ******";

BEGIN  END;


COMMENT "******* ACTION 1 ******";

BEGIN PUSH(OP[J]); J_J-1; PROCESS; GOTO ACTION  END;

COMMENT "******* ACTION 2 *******";

BEGIN OP[J_J+1]_U END;

COMMENT "******* ACTION 3 *******";

BEGIN PUSH(U); PROCESS END;

COMMENT "******* ACTION 4 ******";

BEGIN PUSH(OP[J]); J_J-1; PROCESS END;

COMMENT "******* ACTION 5 *******";

BEGIN J_J-1; COMMENT WHY DOES THIS NOT WORK - NARGS_1; END;

COMMENT "******* ACTION 6 *******";

BEGIN   END;

COMMENT "******* ACTION 7 *******";

BEGIN PUSH(OP[J]); OP[J]_U; PROCESS END;

END ;
 
IF U=CR THEN BEGIN IF I NEQ -1 THEN SYNTAXERROR(8);
                   GOTO START 
             END;
IF U=CLOSEBRACKET OR U=TRANSP THEN GOTO R;

IF U=SEMICOLON THEN GOTO SETUP;

GOTO SETVSW;



END "MAIN"
