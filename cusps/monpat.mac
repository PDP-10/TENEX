;<SYSCON>MONPAT.MAC;10    17-JUN-76 18:54:10    EDIT BY SYSCON
;<SYSCON>MONPAT.MAC;9    17-JUN-76 18:50:49    EDIT BY SYSCON
;<SYSCON>MONPAT.MAC;8    17-JUN-76 18:35:02    EDIT BY SYSCON
TITLE MONPAT - PATCH TO USE SA10 TO SIMULATE RP03
SUBTTL PARAMETERS
PATL==54000
;SYMBOLS FROM MONITOR
BASE==360
DSKCHN==4
FTKI10==-1
FT22BIT==-1
UNIBLK==52
KONCHN==57
CHNNUM==31
KONIOC==56
KONCUA==55
FILINT==500616
SAVE4==13436
UNYPUN==17052
DIE==535106
DPACB==17140
KONRED==36

;COMMOD PATCHES
	LOC	DPACB-1
	JSP	J,SPXIH0
	LOC	DPACB+KONRED
	DSKCHN_^D15,,SPXRED
	EXP	SPXWRT,SPXRDS,SPXWTS,SPXPOS,SPXLTM
	EXP	SPXWTF,SPXUPA,SPXCPY,SPXRCL,SPXSTP
	LOC	PATL

;MISC DEF'S
IODERR==200000
IODTER==100000
SPBKMX==^D36
DSKPIF==1000+1_<7-DSKCHN>
DSKPIN==2000+1<7-DSKCHN>
SA0==274
;AC'S
S=0
P=1
J=2
R=3
F=4
U=5
T1=6
T2=7
T3=10
T4=11
W=12
M=13
P1=14
P2=15
P3=16
P4=17

;PARAMETER DEFINITIONS FOR SPXKON

;SA10 CONI BITS
PARERR==200000	;MEMORY PARITY ERROR DETECTED
NXM==100000	;ATTEMPTED TO REFERENCE NONEXISTENT MEMORY

;STATUS BITS STORED BY SA10 IN LEFT HALF
SSEL==100000	;SELECT ERROR (NO CONTROLLER RESPONDS)
SBIP==40000	;BUS IN PARITY ERROR
SCTL==20000	;CONTROL SEQUENCE CHECK (SOFTWARE OR CONTROLLER SELECTIVE RESET)
SLEN==4000	;LENGTH ERROR - NOT DIRECTLY TESTED BUT SA10 STOPS IF NOT EXPECTED
SPCI==2000	;PROGRAM CONTROLLED INTERRUPT - NOT USED BY SPXKON

;STATUS BITS FROM CONTROLLER STORED BY SA10 IN LEFT HALF
SATN==1000	;ATTENTION - NOT USED BY 3830
SMOD==400	;STATUS MODIFIER
SCUE==200	;CONTROL UNIT END
SBSY==100	;BUSY
SCE==40		;CHANNEL END
SDE==20		;DEVICE END
SUC==10		;UNIT CHECK
SUX==4		;UNIT EXCEPTION - NEVER EXPECTED BY SPXKON
;BITS PLACED IN RIGHT HALF OF STATUS WORD BY SOFTWARE
SINV==10	;SENSE INVALID (IGNORE THE SENSE DATA AND SAY DEVICE ERROR)
SMER==4		;STATUS STORED BY SELECTIVE RESET CAUSED BY MEMORY ERROR

;BITS IN LEFT HALF OF FIRST SENSE WORD FROM CONTROLLER
NIRQ==200000	;INTERVENTION REQUIRED (DRIVE NOT READY OR NOT PRESENT)
NDAT==20000	;DATA CHECK (POSSIBLY CORRECTABLE)
NPRM==1000	;PERMANENT ERROR (WITH DATA CHECK MEANS HARD ERR)
NWRI==10	;WRITE INHIBITED (BY READ ONLY SWITCH ON DRIVE)
NCOR==1		;ECC CORRECTABLE (SOFTWARE MUST ALTER DATA)

;BITS IN RIGHT HALF OF FIRST SENSE WORD
NENV==200000	;ENVIRONMENTAL DATA PRESENT (USAGE OR ERROR STATISTICS)
;CHANNEL COMMAND WORD DEFINITIONS
NMT==400000	;NO MEMORY TRANSFER
TIC==200000	;TRANSFER IN CHANNEL
GO==100000	;COMMAND TO DEVICE
CHAIN==40000	;COMMAND CHAINING
BYTEM==20000	;BYTE MODE
SLI==4000	;SUPPRESS LENGTH INDICATION
SPCHO==3	;HIGH ORDER BITS OF CONTROLLER ADDRESS (HEX C0)

;COMMAND CODES TO CONTROLLER (SHIFTED TO CCW POSITION)
CNOP==3_2	;NO OPERATION
SENSE==4_2	;READ SENSE DATA
WRTD==5_2	;WRITE DATA
READD==6_2	;READ DATA
SEEK==7_2	;SEEK
RECAL==23_2	;RECALIBRATE
SSECT==43_2	;SET SECTOR
SIDE==61_2	;SEARCH IDENTIFIER EQUAL

;DISK CAPACITY PARAMETERS
NRPT==^D18	;# RECORDS PER TRACK
NTPC==^D19	;# TRACKS PER CYLINDER

;FUNCTIONS STORED IN BITS 33-35 OF SPXFNC
OPRED==0	;READ
OPWRT==1	;WRITE
OPPOS==4	;POSITION
OPCAL==7	;RECALIBRATE

;SOFTWARE FLAG BITS STORED IN LEFT HALF OF SPXFNC
FSOE==1		;STOP ON ERROR (OFF ON LAST RETRY)
FXFR==2		;XFER - ON WHEN UNIT NOT IDLE
FBSY==4		;BUSY - ON WHEN BUSY STATUS RECEIVED FROM CONTROLLER
FCUB==10	;CONTROL UNIT BUSY STATUS RECEIVED FOR THIS DRIVE
FOFL==20	;OFFLINE - INTERVENTION REQUIRED RECEIVED FOR THIS DRIVE
FSNS==40	;SENSING - ON WHEN SENSE COMMAND BEING PERFORMED

;EXTRA ERROR BITS PASSED TO FILINT IN T1
IOCDER==4000	;CORRECTABLE DATA ERROR (TELL DAEMON BUT NOT JOB)
IOENVR==2000	;ENVIRONMENTAL DATA PRESENT (FOR DAEMON TO LOG)
	SUBTTL ROUTINES TO START READS, WRITES, AND SEEKS
SPXRED:TDZA	T4,T4		;OP=0 (READ)
SPXWTF:			;WRITE FORMAT NOT IMPLEMENTED - JUST DO WRITE
SPXWRT:MOVEI	T4,OPWRT	;WRITE (NONSTOP)
	JRST	SPXGO		;GO TO COMMON CHANNEL STARTER

SPXRDS:TDZA	T4,T4		;READ, STOP ON ERR
SPXWTS:MOVEI	T4,OPWRT	;WRITE, STOP ON ERR
	HRLI	T4,FSOE		;FLAG TO STOP ON ERR
SPXGO:	TLO	T4,FXFR		;INDICATE ACTIVE TRANSFER
	PUSHJ	P,SAVE4	;SAVE P1-P4
	PUSH	P,F
	PUSH	P,W
	PUSH	P,M		;SAVE MOST ALL THE AC'S
	PUSH	P,T4		;SAVE FUNCTION ON PDL
	ANDI	T4,7		;LEAVE OP BITS
	LDB	T2,[POINT 4,DEVL,11]	;GET COMMAND CHAIN STATE
	CAIE	T2,17		;SKIP IF TERMINATED
	JRST	SPXGOE		;UNIT WAS ALREADY SEEKING OR TRANSFERRING
SPXGO1:	MOVE	T1,UNIBLK(U)	;GET STARTING LOG BLK #
	IDIVI	T1,^D18*^D19	;CYL TO T1
	HRLZ	F,T1		;START TO FORM CCHH WORD
	LSH	F,2		;PUT CYL IN 2 HIGH ORDER BYTES
	MOVEI	P2,SPXCLS	;SETUP PTR TO COMMAND LIST AREA
	MOVEI	P3,SPXDLS	;PTR TO DATA LIST AREA
	HRLI	P2,200000	;MAKE INTO TIC COMMAND
	TRNE	T4,4		;SKIP IF READING OR WRITING
	JRST	SPXGOS		;GO DO SEEK OR RECAL
	PUSHJ	P,STSEK		;STORE SEEK CMD IN CHAN PGM
	IDIVI	T2,^D18		;T2=HEAD, T3=REC # (0-17)
	DPB	T2,[POINT 8,F,31]	;F IS NOW CCHH
	MOVEI	W,1(T3)		;RECORD NUMBERS ON DRIVE START AT 1
	ROT	W,-10		;PUT IN HIGH BYTE SO F,W IS CCHHR
	HRLI	T4,	GO+CHAIN+BYTEM+SSECT+SPCHO	;SET SECTOR COMMAND
	MOVEM	T4,(P2)		;PUT IN AFTER SEEK
	MOVEI	T1,[0]	;POINTER TO BYTE CONTAINING POSITION OF FIRST REC
	HRLI	T1,-100		;FORM DCW
	MOVEM	T1,1(P2)	;STORE IN CMD LIST
	ADDI	P2,2		;NEXT COMMAND ADDRESS TO USE
	HRRZ	P1,KONCHN(J)	;PTR TO CHAN DATA BLOCK
	MOVE	M,CHNNUM(P1)	;GET # OF BLKS TO XFER
	TLNE	M,-1		;CALLED FOR ERROR RECOVERY?
	SKIPA	M,SPXNUM	;YES, USE # OF BLOCKS PREVIOUSLY SPECIFIED
	HRRZM	M,SPXNUM	;NO, SAVE # OF BLOCKS IN CASE OF ERROR
	CAILE	M,SPBKMX	;SEE IF CMD LIST WILL FIT
	JRST	SPXG2E		;NOPE, GIVE STOPCD
SPXGO2:	MOVEI	T3,0		;CLEAR # WDS LEFT IN CUR IOWD
	HRRZ	P4,@KONIOC(J)	;SETUP CONTROL WORD ADDRESS
;FALLS THRU
;FALLS IN
;HERE TO COMPILE CHAN PGM FOR EACH BLOCK
CCP0:	MOVEM	F,(P3)		;STORE CCHH FOR SEEK OR SEARCH
	MOVEM	W,1(P3)		;STORE REC # FOR SEARCH
	HRLI	T4,GO+CHAIN+BYTEM+SIDE+SPCHO	;FORM SEARCH CMD
	MOVEM	T4,(P2)		;PUT IN CHAN PGM
	HRLI	P3,-500		;SETUP 5 BYTE COUNT FOR SEARCH
	MOVEM	P3,1(P2)	;PUT SEARCH DCW IN CHAN PGM
	MOVEM	P2,2(P2)	;PUT TIC BACK TO SEARCH IN CHAN PGM
	ADDI	P3,2		;TO ADDRESS NEXT CCHHR
	HRLI	T4,GO+CHAIN+READD+SPCHO	;FORM READ COMMAND
	TRNE	T4,OPWRT	;IF WRITING
	HRLI	T4,GO+CHAIN+WRTD+SPCHO	;FORM WRITE COMMAND
	SOJLE	M,CCPL		;IF LAST BLOCK
	MOVEM	T4,3(P2)	;PUT READ OR WRITE IN CHAN PGM
	PUSHJ	P,STDCW		;STORE DCW(S) FOR DATA
	  JRST	CCPER		;DF10 LIST TOO SHORT
	ADDI	P2,5		;COMMAND ADDR FOR NEXT BLOCK
	ADD	W,[1B7]		;BUMP RECORD NUMBER
	CAMG	W,[NRPT*1B7]	;SKIP IF END OF TRACK
	JRST	CCP0		;GO DO NEXT
CCPET:	MOVSI	W,(1B7)		;BACK TO RECORD 1
	ADDI	F,1B31		;BUMP HEAD #
	MOVEI	T1,NTPC*1B31	;TO TEST FOR END OF CYLINDER
	CAIG	T1,(F)		;SKIP NOT END OF CYL
	JRST	CCPER		;CAN'T HANDLE CYL BOUNDARY
	PUSHJ	P,STSEK		;STORE A SEEK TO NEXT TRACK
	JRST	CCP0		;GO DO REC 1 ON NEXT TRACK

;HERE TO START POSITIONING
SPXPOS:MOVEI	T4,OPPOS
	JRST	SPXGO

;HERE TO RECALIBRATE
SPXRCL:MOVEI	T4,OPCAL
	JRST	SPXGO
CCPL:	MOVE	P3,P2		;SAVE POINTER TO LAST CMD TO SET SLI IF NEEDED
	TLZ	T4,CHAIN	;DON'T COMMAND CHAIN ON LAST CMD
	MOVEM	T4,3(P2)	;STORE LAST READ OR WRITE
	PUSHJ	P,STDCW		;TRY TO PUT IN FINAL DCW(S)
	  JRST	CCPL1		;SHORT COUNT ON LAST BLOCK
	JUMPN	T3,CCPER	;IF LONG COUNT IN DF10 LIST
CCPLX:	SKIPE	(P4)		;DF10 LIST SHOULD BE EXHAUSTED
	JRST	CCPER		;WASN'T
CCPLX1:	SETZM	5(P2)		;PUT A HALT A END OF CHAN PGM
	MOVEI	P2,6(P2)	;EXPECTED STATUS WORD 2
SPXGX:	MOVEM	P2,SPXES2	;SAVE TO COMPARE AT INTERRUPT
	SETZM	SPXPER	;NO PRIOR ERRORS
	SETZM	SPXST1	;NO ERROR (YET) FOR BLOCK COUNTER
	MOVEI	T3,SPXCLS	;COMMAND LIST ADDR
	MOVEM	T3,SPXRSA	;IF RESTART NEEDED
	MOVEM	T3,SPXRSB	;RESTART ON BUSY, ETC.
	HRRM	T3,DEVL	;PUT IN DEVICE LIST
	MOVEI	T3,15		;DEVICE LIST CODE FOR GO
	POP	P,SPXFNC	;SAVE FUNCTION FOR INTERRUPT
	DPB	T3,[POINT 4,DEVL,11]	;PUT GO CODE IN DEVL
	HRRZI	T3,DEVL	;GET DEVICE LIST BEGINNING
	TLO	T3,600000	;BLOCK MUX AND CONTINUE ON DUMMY STATUS FLAGS
	MOVEM	T3,@SPBASE	;MAKE SURE BASE WORD PROPERLY SET
	XCT	SPSETG	;TELL SA10 TO GO
	XCT	SPSETE	;MAKE SURE INT ENABLE SET
	POP	P,M		;RESTORE SOME AC'S
	POP	P,W
	POP	P,F
	JRST	CPOPJ1	;GIVE GOOD RETURN

CCPL1:	JUMPE	T2,CCPL2	;IF WE RAN OUT OF IOWDS
	SUBM	T1,T3		;GET BACK NEG COUNT OF LAST IOWD
	DPB	T3,[POINT 12,T2,11]	;FORM DCW
	TLZ	T2,400000	;INDICATE DATA CHAIN
	MOVEM	T2,4(P2)	;PUT IN CMD LIST
	SUB	T1,T3		;COMPUTE NEG # OF WORDS LEFT IN BLOCK
CCPL4:	TRNE	T4,OPWRT		;SKIP IF READING
	JRST	CCPL3
	LSH	T1,^D24		;FORM SKIP WORD
	MOVEM	T1,5(P2)	;PUT IN CMD LIST
	AOJA	P2,CCPLX	;FLAG 3 DCW'S IN LAST BLOCK

CCPL3:	MOVSI	T1,400000	;NOT DATA CHAIN BIT
	IORM	T1,4(P2)	;KILL DATA CHAIN FOR LAST DCW
	MOVSI	T1,SLI		;SUPPRESS LENGTH ERROR
	IORM	T1,3(P3)	;PUT IN LAST CMD WORD
	JRST	CCPLX		;FINISH LIST

CCPL2:	CAME	P3,P2		;SKIP IF WE RAN OUT OF IOWDS BEFORE STARTING BLOCK
	SOJA	P2,CCPL4	;NO, BUT FLAG ONLY 1 DCW THIS BLOCK
CCPER:	PUSHJ	P,DIE
	CAI	3,636054(1)	;SPL
	SETZM	4(P2)		;MAKE SURE CMD LIST HAS AN END
	JRST	CCPLX1		;EXECUTE BAD LIST ANYHOW
SPXGOS:	TRNE	T4,1		;SKIP IF SEEK
	JRST	SPXGOC		;RECAL
	PUSHJ	P,STSEK		;STORE SEEK COMMAND
	MOVEM	F,(P3)		;STORE ARGUMENT (CYL ONLY)
SPXGSC:	HRLI	T4,GO+NMT+CNOP+SPCHO	;PUT IN NOP SO INT AFTER POS DONE
	MOVEM	T4,(P2)		;STORE NOP IN CMD LIST
	SETZM	1(P2)		;PUT IN HALT
	MOVEI	P2,2(P2)	;INDICATE EEXPECTED END
	JRST	SPXGX		;GO DO IT

SPXGOC:	HRLI	T4,GO+CHAIN+NMT+RECAL+SPCHO	;FORM RECAL CMD
	MOVEM	T4,(P2)		;PUT IN CMD LIST
	AOJA	P2,SPXGSC	;FOLLOW WITH NOP AND DO IT

;ROUTINE TO STORE A SEEK AND ARGUMENT POINTERS
STSEK:	HRLI	T4,GO+CHAIN+BYTEM+SEEK+SPCHO	;FORM SEEK CMD
	MOVEM	T4,(P2)		;PUT IN CMD LIST
	MOVE	T1,[400000-200,,[0]]	;POINTER TO 2 BYTES OF ZEROS FOR BIN
	MOVEM	T1,1(P2)	;SALT IT AWAY
	HRLI	P3,-400		;TAKE 4 BYTES FOR CCHH
	MOVEM	P3,2(P2)	;SALT CCHH POINTER AWAY
	ADDI	P2,3		;P2 IS ADDR FOR NEXT CMD
	POPJ	P,

;STDCW: STORE 1 OR 2 DCW'S FOR NEXT BLOCK
;SKIPS UNLESS IOWD LIST EXHAUSTED OR COUNT SHORT
STDCW2:	PUSHJ	P,GIOW		;SETUP NEXT IOWD
	  POPJ	P,		;WAS NONE
STDCW:	CAIGE	T3,200		;SKIP IF REMAINING COUNT ENOUGH FOR ENTIRE BLOCK
	JRST	STDCW1		;NO, TAKE CARE OF HAIRY CASES
	SUBI	T3,200		;REDUCE COUNT BY BLOCK LENGTH
	MOVNI	T1,200		;COUNT FOR DCW
STDCWX:	DPB	T1,[POINT 12,T2,11]	;FORM DCW (NO DATA CHAIN)
	MOVEM	T2,4(P2)	;PUT IN CMD LIST
	SUB	T2,T1		;UPDATE STARTING ADDRESS OF DF10 WORD
CPOPJ1:	AOS	(P)		;GIVE SKIP RETURN
CPOPJ:	POPJ	P,

STDCW1:	JUMPE	T3,STDCW2	;IF IOWD COUNT WAS ZERO, GET NEXT IOWD
	MOVNS	T3		;FORM NEG COUNT LEFT IN THIS IOWD
	DPB	T3,[POINT 12,T2,11]	;FORM SHORT DCW
	TLZ	T2,400000	;INDICATE DATA CHAIN
	MOVEM	T2,4(P2)	;PUT IN CMD LIST
	ADDI	P2,1		;INDICATE 2 DCW'S TO BE STORED
	MOVNI	T1,200(T3)	;NEG COUNT REMAINING IN BLOCK
	PUSHJ	P,GIOW		;GET ANOTHER IOWD
	  POPJ	P,		;WAS NONE, TROUBLE UNLESS LAST BLOCK
	ADD	T3,T1		;GET COUNT LEFT IN NEW DCW AFTER FINISHING THIS BLOCK
	JUMPGE	T3,STDCWX	;JUMP IF COUNT ADEQUATE FOR REST OF BLOCK
	POPJ	P,		;GIVE FUNNY RETURN
;GIOW: GET NEXT IOWD FROM LIST, PUT COUNT IN T3 AND ADDR IN T2
;IF LIST EXHAUSTED, DON'T SKIP ON RETURN
GIOW1:	MOVE	P4,T2		;SIMULATE DF10 TIC
GIOW:	SKIPN	T2,(P4)		;PICK UP NEXT IOWD, CHECK FOR HALT
	  POPJ	P,		;IT WAS, GIVE END RETURN
	HLRO	T3,T2		;MINUS COUNT (UNLESS 22 BIT)
IFE FT22BIT,<
	TLZN	T2,-1		;SKIP UNLESS TIC, LEAVE ADDRESS CLEAN
	JRST	GIOW1		;GO DO TIC
>
IFN FT22BIT,<
	TLZN	T2,777760	;SKIP UNLESS TIC, LEAVE ADDRESS CLEAN
	JRST	GIOW1		;GO DO TIC
	ASH	T3,-4		;FORM CORRECT NEG COUNT
>
	MOVNS	T3		;MAKE COUNT POSITIVE
	ADDI	P4,1		;ADVANCE TO NEXT IOWD
	AOJA	T2,CPOPJ1	;CORRECT FOR DF10 ADDRESS OFFSET, GIVE GOOD RETURN

;HERE IF GO ATTEMPTED ON DRIVE STILL BUSY
SPXGOE:	PUSHJ	P,DIE
	CAIA	3,636047(17)	;SPG
	JRST	SPXGO1

;HERE IF MORE BLOCKS THAN FIT IN CMD LIST AREA
SPXG2E:	PUSHJ	P,DIE
	CAI	3,636042(1)	;SPB
	MOVEI	M,SPBKMX	;DO ONLY WHAT FITS
	JRST	SPXGO2

;DUMMY LATENCY ROUTINE
SPXLTM:MOVEI	T1,^D1000	;SAY RECORD STARTS IN ONE MILLISECOND
	JRST	CPOPJ1

;HERE TO "STOP" HUNG UNIT
SPXSTP:	MOVE	T1,SPXFNC	;GET STATE
	TLNE	T1,FXFR		;TRANSFERRING?
	JRST	SPXSP1		;OK, TRY TO ABORT
	PUSHJ	P,DIE
	CAI	3,636050(1)	;SPH
SPXSP1:	CONO	PI,DSKPIF	;LOCK OUT SA10 INTERRUPTS
	MOVEI	T1,340		;CODE FOR SELECTIVE RESET
	XCT	SPCONO	;ZAP CONTROLLER
	XCT	SPSETE	;MAKE SURE INTERRUPT ENABLED
	MOVE	T1,SPXRSA	;GET CHAN PGM ADDR TO RESTART
	TLO	T1,(15B11)	;ADD START CODE FOR DEVL
	PUSH	P,DEVL	;SAVE DEVL BEFORE CLOBBERING IT
	DPB	T1,[POINT 28,DEVL,35]	;ATTEMPT RESTART
	MOVSI	T1,FCUB+FBSY+FSNS
	ANDCAM	T1,SPXFNC	;CLEAR BUSIES AND SENSING
	HRROS	SPCUBF	;IN CASE WE LOSE A CONTROL UNIT END
	CONO	PI,DSKPIN	;SELECTIVE RESET INT CAN NOW OCCUR
	POP	P,T2		;SAVED DEVL ENTRY FOR ERROR STATISTICS
	JRST	CPOPJ1	;GIVE GOOD RETURN
;HERE TO SEE IF CONTROLLER (AND DRIVE) ARE UP.  ALSO USED BY SPXCPY
SPXUPA:
SPXUP1:	MOVEI	T1,400000	;SYSTEM RESET, ALL CHANNELS
	XCT	SPCONO	;ZAP THE SA10
	XCT	SPCONI	;GET CONI STATUS
	TLNN	T1,1		;SHOULD ALWAYS BE ON
	JRST	SPXUP3		;SA10 NOT ON BUS OR POWERED DOWN
	MOVEI	T1,4000
	SOJG	T1,.		;ALLOW SOME TIME FOR CONTROLLERS TO RESET
	MOVEI	T1,SPXTPG	;GET ADDRESS OF TEST PROG
	PUSHJ	P,SPXUPR	;RUN TEST PGM
	JUMPE	T3,SPXUP3	;IF TIMED OUT, TRY ANOTHER PATH
	TLNE	T1,SSEL		;SELECT ERR?
	JRST	SPXUP3		;YES, CONTROLLER OFF OR DISABLED, TRY ANOTHER PATH
	MOVEI	T3,0		;SENSE DATA IF NO ERROR
	TLNN	T1,SUC		;UNIT CHECK?
	JRST	SPXUP4		;NO, ALL IS WELL
	MOVEI	T1,SPXSPG
	PUSHJ	P,SPXUPR	;RUN SENSE PGM
	TLNN	T1,SCE		;CHECK CHANNEL END
	JRST	SPXUP3		;SENSE FAILED, TRY ANOTHER PATH
	MOVE	T3,SPXSN0	;GET FIRST WORD OF SENSE DATA
SPXUP4:	MOVEI	T1,1		;SET T1 SO WRITE HEADER LOCKOUT APPEARS OFF
	TLNN	T3,NIRQ		;CHECK INTERVENTION REQUIRED
	JRST	CPOPJ1	;NO, GIVE GOOD RETURN (PROBABLY WRITE INHIBITED)
SPXUP3:	POPJ	P,		;YES, ALL FAILED, GIVE OFFLINE RETURN

;ROUTINE TO RUN CHANNEL PROGRAM ADDRESSED BY T1 ON CHANNEL ADDRESSED BY T2
;WAITS FOR STATUS OR TIMEOUT
SPXUPR:	MOVEM	T1,@SPBASE	;PUT IN BASE FOR THIS ACCESS
	SETZM	@SPSTA0	;CLEAR FIRST STATUS WORD
	XCT	SPSETG	;TRY TO EXECUTE THE TEST PGM
	MOVEI	T3,^D40000	;GIVE ENOUGH TIME FOR SEEK, SEARCH, WRITE
SPXUP2:	SKIPN	T1,@SPSTA0	;ANY STATUS IN?
	SOJG	T3,SPXUP2	;NO, CHECK TIMEOUT
	XCT	SPCLRS	;TURN STATUS FLAG OFF (IF ON)
	POPJ	P,
SPXCPY:	MOVSI	T4,400000
	LDB	T1,UNYPUN
	JUMPN	T1,SPXCP1
	PUSHJ	P,SPXUPA
	JRST	SPXCP1
	XCT	SPSETE
	MOVE	T1,[600000,,DEVL]
	MOVEM	T1,@SPBASE
	MOVEI	T4,0
	TLNE	T3,10
	TLO	T4,100000
SPXCP1:	MOVNI	T1,1
	JFCL
	MOVEI	T2,^D19*^D18
	MOVEI	T3,^D18
	JUMPGE	T4,CPOPJ1
	POPJ	P,
	SUBTTL INTERRUPT PROCESSING ROUTINES
;COME HERE ON INTERRUPT FROM SA10
SPXIH0:	PUSHJ	P,SAVE4	;SAVE P1-P4
	XCT	SPCONI	;GET STATUS
	TRNE	T1,PARERR+NXM	;SKIP IF NO MEMORY TROUBLES
	JRST	SPXMER		;PAR ERR OR NXM
	TRNE	T1,100		;STATUS ON CHAN 0?
	JRST	SPXSTI		;YES, M IS ALREADY SET UP
	MOVEI	T1,610
	XCT	SPCONO
	MOVEI	T1,620		;SET UP TO CLEAR SPURIOUS INT ON CHAN 2
	XCT	SPCONO
	MOVEI	T1,630		;DO SAME FOR CHAN 3
SPXSPU:	AOS	SPSPER	;COUNT SPURIOUS INTS
SPXDS1:	XCT	SPCONO
	POPJ	P,		;RESTORE ACS AND DISMISS

;HERE IF PARERR OR NXM
SPXMER:	MOVEI	T1,20		;SETUP TO READ MEM USER BITS
	XCT	SPCONO	;SETUP DIAG BUS
	XCT	SPDATI	;READS MEM USER,,MB RIGHT TO T2
	TLNN	T2,3		;SKIP IF CHAN 2 OR 3
	JRST	SPXME1
	MOVEI	T1,200000	;CLEAR MEM ERR FLAG
	JRST	SPXSPU		;COUNT SPURIOUS, CLEAR FLAG, AND DISMISS

SPXME1:	HRLZM	T2,SPSMBR	;SAVE LH OF BAD DATA
	MOVEI	T1,30		;SET TO GET PAR BIT,,MB RIGHT
	XCT	SPCONO
	XCT	SPDATI
	HRRM	T2,SPSMBR	;SAVE RH OF DATA WORD
	XCT	SPCONI	;GET ERROR FLAGS TO T1
	ANDI	T1,700000	;KEEP INTERRUP, PARERR, NXM
	TLNE	T2,1		;PARITY BIT ON IN BAD DATA?
	TRO	T1,40000	;YES, ADD TO STATUS TO BE SAVED
	HRLZM	T1,SPSMAR	;PUT ERROR FLAGS IN STATUS BLOCK
	MOVEI	T1,10		;SETUP TO GET BAD ADDRESS
	XCT	SPCONO
	XCT	SPDATI
	DPB	T2,[POINT 20,SPSMAR,35]	;SAVE BAD ADDRESS
	MOVEI	T1,340		;DO A SELECTIVE RESET TO ABORT THE CURRENT
	SKIPGE	@SPBASE		;TRANSFER AND DETERMINE THE
	XCT	SPCONO	;DRIVE INVOLVED
	MOVEI	T1,200000	;THEN CLEAR THE MEM ERR FLAG AND DISMISS
	JRST	SPXDS1
;HERE WHEN VALID STATUS FLAG SET
SPXSTI:	SKIPL	@SPBASE	;RUNNING BLOCK MUX?
	JRST	SPXSEL		;NO, DISABLE INT AND DISMISS
	LDB	T2,[POINT 8,@SPSTA0,23]	;GET DEVICE ADDRESS
	SUBI	T2,SPCHO_6	;SUBTRACT CONTROLLER ADDRESS
	JUMPN	T2,SPXWDN	;IF <0, WRONG DRIVE #
	MOVE	U,KONCUA(J)	;GET UNIT DATA BLOCK POINTER
SPXSI0:	MOVE	S,SPXPER	;INIT S WITH PRIOR ERRORS
	MOVE	W,SPXFNC	;GET FUNCTION AND FLAGS
	MOVE	P2,@SPSTA0	;GET FIRST STATUS WORD
	TLC	P2,SCE+SDE	;CHANNEL END AND DEVICE END EXPECTED ON
	TLNE	P2,SSEL+SCTL+SBIP+SPCI+(377B15)	;SKIP IF GOOD STATUS
	JRST	SPXAS0		;GO TO STATUS ANALYSIS ROUTINE
SPXSI1:	TLNE	W,FSNS		;WERE WE SENSING?
	JRST	SPXAN0		;YES, GO TO SENSE ANALYSIS ROUTINE
	TLNN	W,FXFR		;WERE WE TRANSFERRING?
	JRST	SPXDSM		;NO, FLUSH THIS INTERRUPT
	LDB	T1,[POINT 24,DEVL,35]	;GET ADDRESS STORED BY CHAN IN DEVL
	CAMN	T1,SPXES2	;IF NOT EQUAL TO EXPECTED TERMINATION VALUE
	CAME	T1,@SPSTA1	;OR STORED ENDING STATUS
SPXDVE:	TRO	S,IODERR	;THEN CALL IT A DEVICE ERROR
SPXERR:	TRNE	W,OPPOS		;IF POSITIONING
SPXPDN:	TLO	S,400000	;THEN INDICATE A POSITION DONE
	MOVEI	T4,OPPOS	;MARK POSITIONING IN CASE OF EXTRA INTERRUPT
SPXER1:	MOVEM	T4,SPXFNC
	ANDI	W,7		;USE ONLY OPERATION CODE IN SPXFNC
	TRNE	W,OPPOS		;IF A POS OR RECAL INT
	TRZ	S,-1		;THEN DON'T REPORT ANY ERRORS
	IOR	S,W		;INCLUDE WITH POSITION FLAG AND ERRORS
	LDB	T2,[POINT 4,S,17]	;PUT DRIVE NUMBER IN COMM WORD
	MOVE	T1,S		;WHERE FILINT EXPECTS COMM WORD
	MOVE	T2,SPXST0	;USE STATUS ON LAST ERR FOR "CONI"
	MOVE	T3,SPXSN0	;AND FIRST 4 BYTES OF SENSE FOR "DATAI"
	PUSHJ	P,FILINT	;TELL THE SYSTEM ABOUT THE INTERRUPT
SPXDSM:	XCT 	SPSETG	;TURN ON GO FLAG
	XCT	SPCLRS	;CLEAR STATUS FLAG
	POPJ	P,		;RESTORE ACS AND DISMISS

;HERE IF STATUS WITH AN INVALID DEVICE ADDRESS RECEIVED
SPXWDN:	AOS	SPSPER	;COUNT A SPURIOUS ERROR
	JRST	SPXDSM		;AND DISMISS
;COME HERE WHEN SENSE SUCCESSFULLY COMPLETED TO ANALYZE THE RESULTS
SPXAN0:	TLC	P2,SCE+SDE	;RESTORE TO STATE AS STORED
	MOVEM	P2,SPXSS0	;SAVE FOR ERROR LOG
	MOVE	P2,SPXST0	;PICK UP STATUS BEFORE SENSE
	TRNE	P2,SINV		;DID WE FLAG THE SENSE AS INVALID?
	JRST	SPXDVE		;YES, JUST CALL IT A DEVICE ERROR
	MOVE	P2,SPXSN5	;GET LAST SENSE WORD, WHICH WAS SET TO ALL ONES
	TRNE	P2,17		;DID THE SENSE PROPERLY CLEAR THE LOW BITS?
	JRST	SPXDVE		;NO, CALL IT A DEVICE ERROR
	MOVE	P2,SPXSN0	;PICK UP FIRST 4 BYTES
	TLNE	P2,NIRQ		;IS INTERVENTION REQUIRED SET?
	JRST	SPXIRQ		;YES, GO MARK OFFLINE
	TRNE	P2,NENV		;ENVIRONMENTAL DATA?
	JRST	SPXENV		;YES, SET FLAG AND RETRY
	TLNN	P2,777777-NDAT-NCOR-NPRM	;OTHER THAN DATA ERROR BITS?
	TLNN	P2,NDAT		;DATA CHECK ON?
	JRST	SPXDVE		;NOT JUST A DATA CHECK, CALL IT A DEVICE ERROR
	TLNN	P2,NCOR		;CORRECTABLE?
	JRST	SPXAN3		;NO, SEE IF WE SHOULD STOP
	LDB	T1,[POINT 8,SPXSN1,31]	;GET SENSE BYTE 7 (FMT AND MSG)
	CAIN	T1,123		;IF IT DOESN'T SAY "DATA FIELD CORRECTABLE"
	PUSHJ	P,ERRCOR	;OR THE CORRECTION ROUTINE FAILS
	  JRST	SPXDVE		;THEN CALL IT A DEVICE ERROR
	HRRZ	T1,SPXST1	;WE GOT THE ERR CORRECTED, FROM WHERE TO PROCEED?
SPXAN1:	SKIPL	-1(T1)		;WAS DATA CHAINING USED?
	AOJA	T1,SPXAN1	;YES, SKIP TO NEXT DCW
SPXAN4:	SKIPN	(T1)		;ARE WE AT THE END OF THE COMMAND LIST?
	JRST	SPXERR		;YES, DON'T RESTART THE SA10
	MOVEM	T1,SPXRSA	;STORE RESTART ADDRESS
SPXAN2:	MOVEM	S,SPXPER	;SAVE AS "PRIOR" ERROR
	TLZ	W,FSNS		;WE'RE NO LONGER SENSING
	MOVEM	T1,SPXRSB	;STORE BUSY RESTART CMD ADDRESS
SPXANX:	TLZ	W,FBSY+FCUB	;WE HAVE NO DEVICE OR CONTROL BUSY
	TLO	T1,(15B11)	;DEVL CODE FOR "START"
	DPB	T1,[POINT 28,DEVL,35]	;PUT CODE AND CMD ADDR IN DEVL
SPXSFD:	MOVEM	W,SPXFNC	;STORE CURRENT FLAGS
	JRST	SPXDSM		;AND DISMISS

;HERE IF DATA CHECK NOT CORRECTABLE
SPXAN3:	TRO	S,IODTER	;INDICATE A DATA ERROR
	TLNE	W,FSOE		;ARE WE STOPPING ON ERROR
	JRST	SPXERR		;YES, GO TELL FILSER
	HRRZ	T1,SPXST1	;NO, CONTINUE FROM ADDR IN STATUS BLOCK
	JRST	SPXAN4		;STORE AS PRIOR ERROR AND CONTINUE

;COME HERE IF SELECT ERROR OR INTERVENTION REQUIRED
SPXIRQ:	MOVE	T4,[FOFL,,OPPOS]	;INDICATE OFFLINE AND POSITIONING
	TRO	S,IODERR	;FOR THIS TIME A DEVICE ERROR
	JRST	SPXER1		;GO TELL FILSER

;COME HERE WHEN ENVIRONMENTAL DATA PRESENT
SPXENV:	HRRZ	T1,SPXRSA	;GET RESTART CMD ADDRESS
	JRST	SPXAN2		;GO RETRY TRANSFER
;COME HERE TO ANALYZE UNUSUAL STATUS
SPXAS0:	TLC	P2,SCE+SDE	;PUT THESE 2 BITS INTO ORIGINAL STATE
	MOVEM	P2,SPXST0	;SAVE AS STATUS ON ERROR
	MOVE	P3,@SPSTA1	;GET 2ND STATUS WORD
	MOVEM	P3,SPXST1	;SAVE IT TOO
	MOVE	P3,DEVL	;PICK UP DEVICE LIST TERMINATION ENTRY
	MOVEM	P3,SPXDLE	;SAVE IT FOR ERROR LOG
	TLNE	P2,SSEL+SCTL	;SELECT OR CONTROL ERR?
	JRST	SPXSCT		;YES.  INCLUDES MEM AND HUNG ERRS
	TLNE	P2,SUC+SBIP	;UNIT CHECK OR BUS IN PARITY?
	JRST	SPXUCB		;YES, GO DO SENSE
	TLNE	P2,SBSY		;BUSY BIT IN STATUS?
	JRST	SPXBSY		;YES, ANALYZE FURTHER
	TLNE	P2,SCUE		;CONTROL UNIT END?
	JRST	SPXCUE		;YES, GO RESTART DRIVE
	TLNE	P2,SDE		;IF DEVICE END OFF
	TLNE	P2,SCE		;OR CHANNEL END ON
	JRST	SPXAST		;CALL IT ANOMALOUS STATUS
	TLZ	W,FOFL		;DRIVE IS NO LONGER OFFLINE
	TLNN	W,FBSY		;DID WE GET A PREVIOUS BUSY?
	JRST	SPXPDN		;NO GIVE FILSER A POSINT TO SAY A PACK WAS MOUNTED
SPXPSC:	HRRZ	T1,SPXRSB	;YES, RESTART THIS DRIVE
	JRST	SPXANX

;COME HERE ON UNIT CHECK OR BUS IN PARITY
SPXUCB:	HRRM	T2,SPCUBF	;A GOOD DRIVE TO RESTART ON CONTROL UNIT END
	TLNN	P2,SSEL+SCTL+SPCI+SBIP+SATN+SMOD+SCUE+SBSY+SUX	;ANY BAD BITS ON?
	JRST	SPXUC1		;NO, DON'T FLAG SENSE DATA TO BE INVALID
SPXAST:	MOVEI	T1,SINV		;FLAG THAT SENSE DATA MAY BE UNRELIABLE
	IORM	T1,SPXST0	;PUT INTO SAVED STATUS
SPXUC1:	TLO	W,FSNS		;FLAG THAT WE ARE SENSING
	SETOM	SPXSN5	;SET ALL BITS IN LAST SENSE DATA WORD
	MOVEI	T1,SPXSPG	;GET ADDRESS OF SENSE COMMAND
	JRST	SPXANX		;GO INITIATE THE SENSE

;COME HERE IF BUSY BIT IN STATUS
SPXBSY:	TLNE	P2,SCE+SDE+SCUE+SUX+SATN	;IF OTHER STATUS PRESENT
	JRST	SPXPSC		;THEN PENDING STATUS WAS JUST CLEARED
	TLNE	P2,SMOD		;WITH STATUS MODIFIER MEANS CONTROL UNIT BUSY
	TLOA	W,FCUB		;IF SO INDICATE CONTROL UNIT BUSY
	TLOA	W,FBSY		;IF NOT INDICATE DEVICE BUSY
	HRROS	SPCUBF	;ON CONTROL BUSY SET FLAG TO LATER SCAN ALL DRIVES
	JRST	SPXSFD		;SET THE FLAGS AND DISMISS
;COME HERE ON SELECT ERROR OR CONTROL SEQUENCE CHECK
SPXSCT:	TLNN	P2,SCTL		;CONTROL CHECK?
	JRST	SPXIRQ		;NO, SELECT ERROR.  MARK OFF  LINE
	MOVEI	T1,0		;SET TO CLEAR MEM ERR FLAG
	EXCH	T1,SPSMAR	;PICKUP MEM ERR FLAGS, ADDR AND CLEAR
	JUMPGE	T1,SPXAST	;WAS NOT MEM ERR, MIGHT HAVE BEEN CHK-1 OR HUNG
	MOVEM	T1,SPXMAR	;SAVE ADDR FOR THIS DRIVE
	TLNN	T1,PARERR	;PARERR OR NXM?
	TDZA	T1,T1		;NXM - IGNORE CPU'S DATA
	MOVE	T1,(T1)
	MOVEM	T1,SPXDAT	;SAVE DATA SEEN BY CPU AT BAD ADDRESS
	MOVE	T1,SPSMBR	;GET DATA SEEN BY CHANNEL
	MOVEM	T1,SPXMBR	;AND SAVE IT TOO
	MOVEI	T1,SMER		;MEM ERR BIT FOR SYSERR
	IORM	T1,SPXST0	;ADD IT TO STATUS
	JRST	SPXAST		;AND GO DO AN INVALID SENSE

;COME HERE ON CONTROL UNIT END
SPXCUE:	MOVE	W,SPXFNC	;GET FUNCTION AND FLAGS
	TLNE	W,FCUB		;CONTROL UNIT BUSY RECEIVED
	JRST	SPXPSC		;YES, TRY STARTING IT
	JRST	SPXDSM		;NO CUB FOUND, ASSUME INT SPURIOUS


;ERRCOR SUBROUTINE -- PERFORM ECC CORRECTION OF READ DATA
;
; EXPECTS SENSE DATA WITH CORRECTION INFO IN SPXSN0...5
; AND ADDR OF 1ST DATA CHAIN WD (+1) IN SPXST1(J)
;CALLED  PUSHJ P,ERRCOR
; CLOBBERS P2, P3, P4, T1, T2, T3, T4
; RETURNS TO CALL+1 IF FAILED (POSTS STOPCD "SPC" IF SOFTWARE AT FAULT)
; RETURNS TO CALL+2 IF SUCCESSFUL

ERRCOR:	LDB	T1,[POINT 8,SPXSN3,31]	;1ST BYTE OF RESTART DISPLACEMENT
	JUMPN	T1,CPOPJ	;BAD RETURN -- RESTART DISPLACEMENT WRONG
	LDB	P4,[POINT 16,SPXSN4,15]	;2ND, 3RD BYTES OF RESTART DISPL
	CAIE	P4,1100		;# OF BYTES IN 200-WD BLOCK
	POPJ	P,		;BAD RETURN -- RESTART DISPLACEMENT WRONG
	LDB	P3,[POINT 16,SPXSN4,31]	;ERROR DISPLACEMENT (# BYTES)
	LSHC	P3,1		;CONVERT P3, P4 TO # OF NIBBLES
	MOVEI	P2,6		;HOW MANY NIBBLES TO CORRECT
	CAMGE	P3,P2
	MOVE	P2,P3		;ONLY CORRECT THOSE IN DATA AREA
	SUBM	P4,P3		;FORWARD ERROR DISPLACEMENT (# NIBBLES)
	JUMPL	P3,CPOPJ	;BAD RETURN -- ERROR DISPLACEMENT TOO LARGE
	MOVE	P4,[POINT 4,SPXSN5]	;WILL GET NIBBLES OF SYNDROME
ERRCR1:	JUMPLE	P2,CPOPJ1	;IF NO MORE NIBBLES, GOOD RETURN
	ILDB	T4,P4		;GET NEXT NIBBLE OF SYNDROME
	JUMPE	T4,ERRCR5	;SAVE WORK IF NIBBLE SAYS NO CORRECTION
	MOVE	T2,P3		;FORWARD ERROR DISPLACEMENT (# NIBBLES)
	IDIVI	T2,^D9		;# OF NIBBLES PER WORD
	TRNN	T2,1		;SA-10 ODD, EVEN WORDS...
	ADDI	T3,1		;...HAVE NIBBLES ROTATED 1 POSITION
	IMULI	T3,-4		;ONLY USE R.H. OF RESULT
	ROT	T4,0(T3)	;PUT SYNDROME NIBBLE IN RIGHT POSITION
	MOVE	T1,SPXST1	;CHANNEL COMMAND POINTER
	TLZE	T1,77
	JRST	ERRCRE		;BAD NEWS IF NOT 18-BIT ADDRESS
ERRCR2:	MOVE	T3,-1(T1)	;GET DATA CHAIN WORD
	TLO	T3,400000	;FORCE SIGN BIT ON
	ASH	T3,-30		;- # WORDS
	ADD	T2,T3		;DIMINISH FORWARD DISPLACEMENT
	JUMPL	T2,ERRCR3	;TIME TO CORRECT
	SKIPL	-1(T1)		;SKIP IF THIS IS LAST DATA CHAIN WORD
	AOJA	T1,ERRCR2	;ELSE TO NEXT DATA CHAIN WORD
ERRCRE:	PUSHJ	P,DIE
	CAI	3,636043(2)	;SPC
ERRCR3:	HRRZ	T1,-1(T1)	;GET ADDRESS PART OF DATA CHAIN WORD
	TRNN	T1,-20
	JRST	ERRCR5		;IF DATA XFER IS SKIPPED
	SUB	T2,T3		;FWD DISPLACEMENT IN BLOCK (# WORDS)
	ADD	T1,T2		;WORD ADDRESS
IFN FTKI10,<
	DATAI	PAG,T3		;GET CURRENT EPT LOC
	TRO	T3,400000	;SET BIT TO LOAD ON DATAO
	LSH	T3,^D9		;GET WORD ADDR OF EPT
	LDB	T2,[POINT 13,T1,26]	;GET PAGE NUMBER OF WORD IN ERROR
	ADDI	T2,700000	;TURN ON ACCESS, WRITE, PUBLIC BITS
	HRRM	T2,377(T3)	;MAP ENTRY FOR EXEC PAGE 777
	LSH	T3,-^D9		;GET PAGE NUMBER OF EPT
	DATAO	PAG,T3		;CLEAR ASSOC MEMORY
	TRO	T1,777000	;FORM ADDRESS IN TOP PAGE
>
	XORM	T4,(T1)		;** CORRECT A NIBBLE **
ERRCR5:	ADDI	P3,1		;TO NEXT NIBBLE OF DATA
	SOJA	P2,ERRCR1	;COUNT A NIBBLE DONE, DO MORE

;HERE TO FLUSH UNWANTED SELECTOR CHANNEL INTERRUPTS
SPXSEL:	XCT	SPCLRE	;CLEAR INT ENABLE
	POPJ	P,		;DISMISS, LEAVING STATUS FLAG ON

;VARIABLES
SPSMAR:	0
SPSMBR:	0
SPSPER:	0
SPCUBF:	0
SPXNUM:	0
SPXES2:	0
SPXPER:	0
SPXST0:	0
SPXST1:	0
SPXRSA:	0
SPXRSB:	0
SPXFNC:	0
SPXSN0:	0
SPXSN1:	0
SPXSN2:	0
SPXSN3:	0
SPXSN4:	0
SPXSN5:	0
SPXSS0:	0
SPXDLE:	0
SPXMAR:	0
SPXMBR:	0
SPXDAT:	0
SPXCLS:	BLOCK	SPBKMX*6+^D12
SPXDLS:	BLOCK	SPBKMX*2
SPXSPG:	120020+SPCHO,,0
	-3000,,SPXSN0
	0
SPXTPG:	160034+SPCHO,,0
	-600,,SPXTPD
	160304+SPCHO,,0
	-500,,SPXTPD
	200000,,.-2
	120024+SPCHO,,0
	-1000,,SPXTPD
SPXTPD:	0
	0
DEVL:	BYTE	(8)SPCHO_6(4)17(24)0
	0
SPBASE:	BASE
SPSTA0:	BASE+1
SPSTA1:	BASE+2
SPCONO:	CONO	SA0,DSKCHN(T1)
SPSETG:	CONO	SA0,440+DSKCHN
SPSETE:	CONO	SA0,740+DSKCHN
SPCLRS:	CONO	SA0,600+DSKCHN
SPCLRE:	CONO	SA0,700+DSKCHN
SPCONI:	CONI	SA0,T1
SPDATI:	CONI	SA0,T2
	LIT
	RELOC	.
	END
