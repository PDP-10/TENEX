;<SOURCES>BCOM.MAC;4    15-OCT-74 15:06:28    EDIT BY LIEB
;[EDIT] ADD CODE TO CHANGE LOWER CASE SWITCHS TO UPPER CASE--LIEB
    TITLE  BCOM -- BASIC COMPILER FOR PDP10 TENEX
    SUBTTL ASSEMBLY CONTROL
;
SEARCH STENEX,BGBL
;
;
;
;
    OPDEF  ERR [EXP 001000000000]
;
;
;
;
;   LANGUAGE EXTENSIONS
;
;      THESE FLAGS CONTROL CONDITIONAL ASSEMBLY OPTIONS ALLOWING
;      FOR VARIOUS EXTENSIONS TO THE LANGUAGE WHICH MIGHT BE NEEDED
;      FOR COMPATIBILITY WITH DEC BASIC (AND OTHERS).  THEIR
;      DEFAULT VALUE IS 0 (OFF--FEATURE NOT IMPLEMENTED).
;
;
IFNDEF LEXN01,<LEXN01== 0>	;ALLOW DROPPING 'LET' IN ASSIGNMENT STATEMENTS
IFNDEF LEXN02,<LEXN02== 0>	;ALLOW MULTIPLE EQUALS [A(A=A+1)=1]
IFNDEF LEXN03,<LEXN03== 0>	;ALLOW QUOTE AS PRINT DELIMITER
;
;
  SUBTTL FILE STRUCTURE FOR BASIC ASSEMBLY
;
;
;
;   BAS01        HEADER, CONTROL INFO
;   BAS02        MACRO DEFINITIONS
;   BAS03        SYMBOL DEFINITIONS
;
;   BAS04        INTERRUPT PROCESSING
;   BAS05        ERROR MESSAGES
;
;   BAS06        INITIALIZATION
;
;   BAS07        STORAGE ALLOCATION SUBROUTINES
;
;   BAS10        BASIC LINE SCAN AND LINE NUMBER ROUTINES
;
;   BAS20        ARITHMETIC SCAN I
;   BAS21        ARITHMETIC SCAN II
;   BAS22        PERFORM NEXT OP (DONXT)
;   BAS23        ARITHMETIC SCAN SUBROUTINES
;
;   BAS50        STATEMENT ROUTINES I
;   BAS51        STATEMENT ROUTINES II
;   BAS52        STATEMENT SUBROUTINES--SCANNING
;   BAS53        STATEMENT SUBROUTINES
;   BAS54        SUB SUBROUTINES
;   BAS55	 LIBRARY ROUTINES
;   BAS56	 BINARY FILE INPUT ROUTINES
;   BAS57	 NAME SCAN ROUTINE
;
;
;   BAS90        SYMBOL DEFINITIONS FOR STORAGE
;   BAS91        SYMBOL TABLE
;
;   BAS99        END OF ASSEMBLY
;
;
;
;
;
  SUBTTL REGISTER ALLOCATION
;
;
;
    R0==   0           ;STANDARD REGISTERS ARE R0...R17
    R1==   1
    R2==   2
    R3==   3
    R4==   4
    R5==   5
    R6==   6
    R7==   7
    R10==  10
    R11==  11
    R12==  12
    R13==  13
    R14==  14
    R15==  15
    R16==  16
    R17==  17
;
;
;
    T0==   3           ;USED REGISTERS ARE T0...T9
    T1==   4
    T2==   5
    T3==   6
    T4==   7
    T5==   10
    T6==   11
    T7==   12
;
;
;
    FG==   0           ;0--COMPILER FLAGS
    CH=   13          ;13--CHARACTER FROM SOURCE FILE
    VS=   14          ;14--VARIABLE STACK
    OS=   15          ;15--OPERATIONS STACK
    T=    16          ;16--TRANSFERS
    P=    17          ;17--COMPILER PUSH DOWN LIST
;
;
;
;
;
    PRINTX *****START OF BAS02*****
;
;
SUBTTL BASIC MACROS--GENERAL
;
;
;
;   RFIX--DEFINE FIX INST FOR RUN TIME
;
DEFINE RFIX (LC)
<
    IFN R2-LC,<MOVE R2,LC>
    PUSHJ P,GRFIX
>
;
;
SUBTTL BASIC MACROS--CHARACTER HANDLING
;
;
;
;   GTCHR--GET NEXT CHARACTER FROM SOURCE
;
DEFINE GTCHR (RG)
<
    SOSG IFLCNT
    PUSHJ P,NXPAG
    ILDB RG,IFLTL
>
;
;
  SUBTTL BASIC MACROS--SAVING OBJECT/CONSTANTS/BINARY
;
;
;
;   SAVWD--SAVE ABSOLUE WORD
;
    DEFINE SAVWD
<
    MOVEI  R1,0        ;TYPE=ABS
    PUSHJ  P,.SVWD
>
;
;
;   SVWPR--SAVE WORD REFERENCING CODE
;
    DEFINE SVWPR
<
    MOVEI  R1,1        ;TYPE=PROG
    PUSHJ  P,.SVWD
>
;
;
;   SVWNM--SAVE WORD REFERING TO NUMERIC VAR
;
    DEFINE SVWNM
<
    MOVEI  R1,2        ;TYPE=NUM
    PUSHJ  P,.SVWD
>
;
;
;   SVWST--SAVE WORD REFERING T STRING VAR
;
    DEFINE SVWST
<
    MOVEI  R1,3        ;TYPE=STR
    PUSHJ  P,.SVWD
>
;
;
;   SVWCN--SAVE WORD REFERING TO CONSTANT AREA
;
    DEFINE SVWCN
<
    MOVEI  R1,4        ;TYPE=CN
    PUSHJ  P,.SVWD
>
;
;
;   SVWEX--SAVE WORD REFERING TO EXTERNAL
;
    DEFINE SVWEX
<
    PUSHJ  P,.SVEX
>
;
;
;   SVWFC--SAVE WORD REFERING TO INTERNAL FUNCTION
;
DEFINE SVWFC
<
    PUSHJ P,.SVFC
>
;
;
;   SVWMT--SAVE WORD REFERING TO MATRIX
;
DEFINE SVWMT
<
    MOVEI R1,7
    PUSHJ P,.SVWD
>
;
;
;   PUTWD--PUT A WORD INTO BINARY FILE
;
DEFINE PUTWD
<
    PUSHJ P,.PTWD
>
;
;
SUBTTL BASIC MACROS--SAVING CONSTANTS
;
;
;   SVCON--SAVE ABSOLUTE CONSTANT
;
DEFINE SVCON (TO)
<
    MOVEI R1,0
    XSVCON (TO)
>
;
;
;   XSVCON--SAVE CONSTANT OF RELOC TYPE (R1)
;
DEFINE XSVCON (TO)
<
    PUSHJ P,.SVCN
    AOS TO,CADDN
>
;
;
;   DSVCON--SAVE POSSIBLY DUPLICATE CONSTANT
;
DEFINE DSVCON (RG)
<
    PUSHJ P,FNCNST
    IFNB <RG>,<IFN RG-R2,<MOVEM R2,RG>>
>
;
;
  SUBTTL BASIC MACROS--ERROR MESSAGES
;
;
;
    DEFINE ERM (BTS,MES) ;ERROR MESSAGE
<
    ..TMP1== 0
    IRP    BTS,<
    ..TMP1== ..TMP1+ER.'BTS
>
    EXP    ..TMP1
    ASCIZ  \MES\
>
;
;
  SUBTTL BASIC MACROS--FUNCTION DEFINITIONS
;
;
;
    DEFINE DFN (NAME,FCTYP,NARG,A1,A2,A3,TYP)
<
    GTFTYP TYP,..TYP,0
    BYTE ( 6)NARG+1(1)FCTB.'FCTYP,FCTB.'A1,FCTB.'A2,FCTB.'A3
    RADIX50 ..TYP,NAME
    EXP    0
    EXP %'NAME
>
;
;
;
    FCTB.S== 1         ;STRING ARGUMENT
    FCTB.N== 0         ;NUMERIC ARGUMENT
    FCTB.== 0          ;VOID ARGUMENT
    FCTB.F== 0         ;FILE NUMBER ARGUMENT
;
;
;
;   GTFTYP--GET TYPE OF FCT FOR UPPER BITS
;
DEFINE GTFTYP (TYPE,OUT,DFLT)
<
    OUT== DFLT
    IFNB <TYPE>,<
      IRPC TYPE,<
        IFIDN <TYPE>,<F>,<OUT== 0
			  STOPI>
	IFIDN <TYPE>,<I>,<OUT== 40
			  STOPI>
	IFIDN <TYPE>,<P>,<OUT== 60
			  STOPI>
	IFIDN <TYPE>,<S>,<OUT== 20
			  STOPI> > >
>
;
;
SUBTTL BASIC MACROS--ASC TABLE DEFINITIONS
;
;
;
DEFINE ASCT (NAM,PT)
<
    BYTE (21)"NAM"(15)ASC'PT'NAM
>
;
;
  SUBTTL BASIC MACROS--STATEMENT ROUTINES
;
;
;
    DEFINE SPELL (X)
<
    IRP    X,<
    JSP    T,NXECH
    CAIE   CH,ASC..'X
    ERR    E.ILST
>>
;
;
;
;
SUBTTL BASIC MACROS -- ROUTINE CALLS
;
;
;
;   GNSUB--GENERATE SUBSCRIPT CALCS
;
  DEFINE GNSUB (LC)
<
	IFN T7-LC,<MOVE T7,LC>
	PUSHJ P,GNSUB$
>
;
;
;   FNCAL--GENERATE FUNCTION CALL
;
  DEFINE FNCAL (LC)
<
	IFN T7-LC,<MOVE T7,LC>
	PUSHJ P,FNCAL$
>
;
;
;   GTADD--GET ADDRESS AND RELOCATION TYPE
;
  DEFINE GTADD (LC)
<
	IFN R2-LC,<MOVE R2,LC>
	PUSHJ P,GTADD$
>
;
;
;   MKLOD--INSURE ITEM ON TOP OF STACK IS LOADABLE
;
  DEFINE MKLOD (LC)
<
	PUSHJ P,MKLOD$
	IFN T7-LC,<MOVEM T7,LC>
>
;
;
;   XMKLOD--DO MKLOD AND SAVE PTR TO WHERE ITEM IS
;
  DEFINE XMKLOD (LC)
<
	MOVEI T7,LC
	PUSHJ P,XMKLD$
	IFN T7-LC,<MOVEM T7,LC>
>
;
;
;   LOAD--GENERATE CODE TO LOAD AN ARGUEMNT
;
  DEFINE LOAD (LC)
<
	MOVE T3,LC
	PUSHJ P,LOAD$
	MOVEM T4,LC
>
;
;
;   GTREG--GET REGISTER TO USE
;
  DEFINE GTREG (LC)
<
	PUSHJ P,GTREG$
	IFN LC-R2,<MOVEM R2,LC>
>
;
;
;   RLREG--RELEASE ITEM, FREEING REGISTER USED, ETC.
;
  DEFINE RLREG (LC)
<
	IFN LC-T7,<MOVE T7,LC>
	PUSHJ P,RLREG$
>
;
;
  SUBTTL BASIC MACROS--RUN TIME ROUTINE DEFS
;
;
;
    DEFINE RTP (NAME,TYPE)
<
    GTFTYP TYPE,..TYP,0
    RADIX50 ..TYP,NAME
    XWD    0,0
    EXP %'NAME
>
;
;
;
;
    PRINTX *****START OF BAS03*****
;
;
  SUBTTL SYMBOL DEFINITIONS--STORAGE LAYOUT
;
;   THESE SYMBOLS ARE THE PARAMETERS USED IN LAYING OUT THE STORAGE
;      AT THE BEGINING OF A COMPILATION.
;
;
    NLINPG== 10         ;NUMBER OF PAGES FOR LINE NUMBERS
    NLINPX== 4         ;NUMBER OF EXTRA PAGES
;
    NCRLPG== 4 ;NUMBER OF PAGES FOR CONSTANT RELOC BYTES
;
    NCSTPG== 10         ;NUMBER OF PAGES FOR CONSTANTS
;
    NRLCPG== 4         ;NUMBER OF PAGES FOR RELOCATION BYTES
;
;
  SUBTTL SYMBOL DEFINITIONS--ERROR BITS
;
;   THESE BITS APPEAR IN THE LOWER HALF OF THE FIRST WORD OF AN ERROR MESSAGE
;      BLOCK.  THE SECOND WORD OF THE BLOCK ON FORWORD CONTAINS THE ACTUAL
;      MESSAGE IN STRING FORM, TERMINATED WITH A NULL (000).
;
;
    ER.T== 400000      ;TERMINAL ERROR--STOP IMMEDIATE
    ER.W== 200000      ;WARNING--CONTINUE COMPILING (STILL HALT RUN)
    ER.G== 100000       ;IGNORE REST OF SOURCE LINE
    ER.Q== 000100	;QUESTION--IGNORE ERROR
;
    ER.I== 040000      ;TYPE ' IN LLLLL'
    ER.A== 020000      ;TYPE ' AFTER LLLLL'
    ER.N== 010000      ;TYPE ' AND LLLLL'
    ER.L== 004000      ;TYPE ' LLLLL'
    ER.F== 001000      ;TYPE 'FOR M' (M====MATRIX NAME)
    ER.B== 000400     ;TYPE ERBUF CONTENTS
    ER.Y== 000200	;TYPE STR POINTED TO BY ERBUF
;
;
  SUBTTL SYMBOL DEFINITIONS--VARIABLE TYPES
;
;   THESE BITS ARE CONTAINED IN THE UPPER HALF OF ELEMENTS ON THE
;      VARIABLE STACK.  THEY IDENTIFY THE TYPE AND SOURCE OF THE
;      ITEM REPRESENTED.  THE LOWER HALF CONTAINS VARIOUS INFO--
;      REGISTER NUMBER FOR REGISTER ITEMS, SYMBOL NUMBER FOR SYMBOL
;      ENTRIES; ADDRESS (RELOCATABLE) FOR CONSTANTS, TEMPS; AND SO
;      ON.  FOR FURTHER INFO, READ ARITHMETIC SCAN.
;
;
    VTMAT== 100000     ;TYPE==MATRIX
    VTSTR== 200000     ;TYPE==STRING
    VTNUM== 400000     ;TYPE==NUMBER
;
    VTTMP== 040000	;LOC==TEMPORARY
    VTREG== 020000     ;LOC==REGISTER
    VTVAR== 010000     ;LOC==SYMBOL (VARIABLE)
    VTCON== 004000     ;LOC==CONSTANT
    VTFIL== 002000     ;LOC==FILE REF
;
    VTFC0== 001000     ;ITEM==FUNCTION CALL OF NO ARGS
    VTFCT== 000400     ;ITEM==FUNCTION CALL WITH ARGUMENTS
    VTSBC== 000200     ;ITEM==SUBSCRIPTING CALL
;
    VTMEL== 000100     ;ITEM==MATRIX NUMBER (SUBSCRIPT CALCULATED)
;
    VTCND== 000040     ;TYPE==CONDITIONSAL, ALL ITEMS USELESS
;
    VTXXX== 000037     ;PROHIBITED BITS
;
;
;
    VTNVR== VTNUM+VTVAR ;NUMERIC VARIABLE
    VTSVR== VTSTR+VTVAR ;STRING VARIABLE
    VTMSR== VTMAT+VTSTR+VTVAR ;STRING MATRIX VAR
    VTMNR== VTMAT+VTNUM+VTVAR ;NUMERIC MATRIX VAR
;
    VTNCN== VTCON+VTNUM ;NUMERIC CONSTANT
    VTSCN== VTCON+VTSTR	;STRING CONSTANT
;
    VTNDR== VTFC0+VTFCT+VTSBC ;NOT DIRECTLY LOADABLE
    VTTYP== VTMAT+VTSTR+VTNUM ;TYPE BITS
;
;
  SUBTTL SYMBOL DEFINITIONS--FLAG REGISTER BITS
;
;   THESE BITS APPEAR IN THE UPPER (AND IN SOME CASES LOWER) HALF OF REGISTER
;      FG.  MOST OF THEM HAVE TO DO WITH THE ARITHMETIC SCAN.  UPPER
;      HALF BITS ARE CONSIDERED PERMANENT WHILE LOWER HALF BITS ARE TO
;      BE TEMPORARY.
;
;
    NCHBT== 400000     ;NEXT CHARACTER ALREADY SCANNED
    OPBT== 200000      ;OPERATOR EXPECTED
    FCTBT== 100000     ;PROCESSING ARGUMENT LIST
;
    NUMBT== 040000     ;NUMERIC EXPRESSION
    STRBT== 020000     ;STRING EXPRESSION
    MATBT== 010000     ;MATRIX EXPRESSION
;
    OPPBT== 004000     ;OPERATOR HAS BEEN SCANNED
    CNPBT== 002000     ;CONSTANT HAS BEEN SCANNED
    ENDBT== 001000     ;PROCESSING END OF SCAN
;
    CNDBT== 000400     ;CONDITIONAL EXPRESSION
    EQUBT== 000200     ;EQUALS EXPRESSION
    XEQBT== 000100     ;EQUALS EXPRESSION AFTER ASSIGNMENT
;
    CALBT== 000040     ;SUB ARG ITEMS ALLOWED
    SBCBT== 000020     ;PROCESSING SUBSCRIPTS
    XVRBT== 000010	;HANDLING VAR-TERM (OR UDF) CURRENTLY
    PRIBT== 000001     ;PRINT EXRPRESSION
;
;
    SAVBTS== EQUBT+FCTBT+CNPBT+OPPBT+SBCBT ;BITS SAVED
    TYPBTS== STRBT+NUMBT+MATBT ;TYPE BITS
    FCSBBT== FCTBT+SBCBT ;FUNCTION/SUBSCRIPTING BIT
;
;
;
;   LOWER HALF BITS--CALL PARAMETERS
;
CLBPA== 400000 ;PUSH ARGS BEFORE CALL (VS ARG AFTER)
CLBPJ== 200000 ;PUSHJ ENTRY (VS JSA 16, ENTRY)
CLBPS== 040000 ;GET ARGS OFF P-STACK (VS VS-STACK)
;
CLBTY== 030000 ;TYPE OF CALL 0-PGM; 1-FCT; 2-EXT
    CLTPGM== 00000 ;CALL TO INSIDE PROGRAM
    CLTFCT== 10000 ;CALL TO USER FCT
    CLTEXT== 20000 ;CALL TO EXTERNAL
;
CLBNA== 000777 ;NUMBER OF ARGS
;
;
  SUBTTL SYMBOL DEFINITIONS--TERMINATORS
;
;   THESE ARE ARITHMETIC SCAN TERMINATORS.  IF THE SCAN IS TERMINATED BY
;      A SINGLE CHARACTER THEN THE CHARACTER IS SAVED.  ELSE , IF THE
;      SCAN IS TERMINATED BY A WORD THEN THE PROPER ONE OF THE FOLLOWING
;      IS USED.
;
;
    TRTHEN== 1001      ;THEN OR GOTO
    TRGOTO== TRTHEN    ;GOTO
    TRBIT== 1002       ;BIT
    TRWITH== 1004      ;WITH
    TRSYST== 1010      ;SYSTEM
    TRTO== 1020        ;TO
    TRSTEP== 1040      ;STEP
    TRGOSB== 1100      ;GOSUB
;
;
  SUBTTL SYMBOL DEFINITIONS--OPERATOR NUMBERS
;
;   THE WORDS ON THE OP STACK ARE TWO PART ITEMS.  IN THE LOWER HALF IS THE OPERATOR
;      NUMBER, USED BY 'DONXT' TO PERFORM THE OPERATOR.  THE UPPER HALF
;      CONTAINS PRIORITY BITS.  THE FOLLOWING DEFINE THE OPERATOR
;      NUMBERS:
;
;
    PN.PLU== 1         ;PLUS
    PN.MIN== 2         ;MINUS
    PN.MUL== 3         ;MULTIPLY
    PN.DIV== 4         ;DIVIDE
    PN.EXP== 5         ;EXPONENTIATE
    PN.AMP== 6         ;CONCATENATE
    PN.REQ== 7         ;RELATIONAL =
    PN.RNE== 10        ;RELATIONAL <>
    PN.RLT== 11        ;RELATIONAL <
    PN.RGT== 12        ;RELATIONAL >
    PN.RLE== 13        ;RELATIONAL <=
    PN.RGE== 14        ;RELATIONAL >=
    PN.UPL== 15        ;UNARY +
    PN.UMI== 16        ;UNARY -
    PN.EQU== 17        ;ASSIGNMENT =
    PN.EQN== 20        ;ASSIGNMENT =-
    PN.EQM== 21        ;MAT ASSIGNMENT
    PN.END== 22       ;IF END
    PN.MOR== 23        ;IF MORE
;
;
  SUBTTL SYMBOL DEFINITIONS--PRIORITY BITS
;
;   THESE BITS APPEAR IN THE UPPER HALF OF WORDS ON THE OPERATOR
;      STACK.  FOR LOWER HALF INFORMATION (OPERATOR NUMBERS) SEE
;      THE PREVIOUS SECTION.
;
;
    PR.PLU== 100       ;PLUS
    PR.MIN== 100       ;MINUS
    PR.MUL== 200       ;MULTIPLY
    PR.DIV== 200       ;DIVIDE
    PR.EXP== 400       ;EXPONENTIATE
    PR.AMP== 1000      ;CONCATENATE
    PR.UNI== 10000     ;UNARY OPERATORS
    PR.IMR== 20000	;IF END/IF MORE
;
    PR.REL== 4         ;RELATIONALS
    PR.LPR== 10        ;LEFT PARENTHESIS
    PR.FCL== 20        ;FUNCTION CALLS
;
    PR.EQU== 40        ;ASSIGNMENT
;
    PR.END== 1         ;END OF EXPRESSION
;
;
    RASOPS== PR.EXP+PR.EQU ;RIGHT ASSOCIATIVE OPERATORS
;
;
  SUBTTL SYMBOL DEFINITIONS--FUNCTION BLOCKS
;
;   FOR ALL INTERNAL AND EXTERNAL FUNCTONS, A SHORT TWO OR THREE
;      WORD BLOCK IS STORED.  THESE ARE CONTAINED IN FCTATB FOR
;      EXTERNAL FUNCTIONS AND UFCATB FOR USER FUNCTIONS.  IN ALL
;      CASES, THE FIRST WORD IS THE ID WORD, WITH THE NUMBER OF
;      ARGUMENTS + 1 IN BITS 0 TO 5; THE TYPE OF FUNCTION IN BIT 6;
;      AND THE ARGUMENT TYPES IN BITS 7 TO 35 (WITH THE TYPE BEING
;      0 FOR NUMERIC AND 1 FOR STRING).  THE LATER WORDS DIFFER
;      ACCORDING TO TYPE OF FUNCTION:
;
;
    FCIDWD== 0         ;WORD 0--ID WORD
;
;   EXTERNAL FUNCTIONS
;
    FCNAM== 1          ;NAME IN RADIX 50
    FCCNT== 2		;USAGE COUNT
    FCVAL== 3		;VALUE (LOC IN TRANSFER VECTOR)
;
;   INTERNAL FUNCTIONS
;
    FCIAD== 1          ;REL ADDRESS FOR USER FUNCTION
;
;
;
;   BIT DEFINITIONS FOR FCIAD
;
FCGBL== 400000 ;FUNCTION IS PASSED TO US
FCUSD== 200000 ;FUNCTION IS USED
;
;
  SUBTTL SYMBOL DEFINITIONS--RUN TIME ROUTINE BLOCKS
;
;   IN ADDITION TO FUNCTION BLOCKS, RUN TIME ROUTINES THAT ARE CALLED
;      WHICH ARE NOT FUNCTIONS ALSO GET BLOCKS FOR THEIR RADIX50
;      NAME AND THEIR RELOCATABLE ROUTNE ADDRESS.
;
;
    RTNAM== 0          ;WORD 0--NAME IN RADIX 50
    RTCNT== 1		;WORD 1--USAGE COUNT
    RTVAL== 2		;WORD 2--VALUE--LOC IN TRANSFER VECTOR
;
;
  SUBTTL SYMBOL DEFINITIONS--ASCII CHARACTERS
;
;
;
    ASCNUL== 0         ;NULL
    ASCSOH== 1         ;START OF HEADING
    ASCSTX== 2         ;START OF TEXT
    ASCETC== 3         ;END OF TEXT (^C)
    ASCETX== 3         ;END OF TEXT
    ASCEOT== 4         ;END OF TRANSMISSION
    ASCENQ== 5         ;ENQUIRY
    ASCACK== 6         ;ACKNOWLEDGE
    ASCBEL== 7         ;BELL
    ASC.BS== 10        ;BACKSPACE
    ASC.HT== 11        ;TAB
    ASC.LF== 12        ;LINE FEED
    ASC.VT== 13        ;VERTICAL TAB
    ASC.FF== 14        ;FORM FEED
    ASC.CR== 15        ;CARRIAGE RETURN
    ASC.SO== 16        ;SHIFT OUT
    ASC.SI== 17        ;SHIFT IN
    ASCDLE== 20        ;DATA LINK ESCAPE
    ASCDC1== 21        ;DEVICE CONTROL 1
    ASCDC2== 22        ;DEVICE CONTROL 2
    ASCDC3== 23        ;DEVICE CONTROL 3
    ASCDC4== 24        ;DEVICE CONTROL 4
    ASCNAK== 25        ;NEGATIVE ACKNOWLEDGE
    ASCSYN== 26        ;SYNCHRONOUS IDLE
    ASCETB== 27        ;END OF TRANSMISSION BLOCK
    ASCCAN== 30        ;CANCEL
    ASC.EM== 31        ;END OF MEDIUM
    ASCSUB== 32        ;SUBSTITUTE
    ASCESC== 33        ;ESCAPE
    ASC.FS== 34        ;FILE SEPARATOR
    ASC.GS== 35        ;GROUP SEPARATOR
    ASC.RS== 36        ;RECORD SEPARATOR
    ASC.US== 37        ;UNIT SEPARATOR
    ASCEOL== 37        ;(TENEX EOL)
;
;
    ASC.SP== 40        ;SPACE
    ASCEXC== 41        ; !
    ASCQTE== 42        ; "
    ASCNUM== 43        ; #
    ASCDOL== 44        ; $
    ASCPER== 45        ; %
    ASCAMP== 46        ; &
    ASCAPO== 47        ; '
    ASCLPR== 50        ; (
    ASCRPR== 51        ; )
    ASCMUL== 52        ; 0
    ASCPLU== 53        ; +
    ASCCMA== 54        ; ,
    ASCMIN== 55        ; -
    ASCDOT== 56        ; .
    ASCDIV== 57        ; /
    ASC..0== 60        ; 0
    ASC..1== 61        ; 1
    ASC..2== 62        ; 2
    ASC..3== 63        ; 3
    ASC..4== 64        ; 4
    ASC..5== 65        ; 5
    ASC..6== 66        ; 6
    ASC..7== 67        ; 7
    ASC..8== 70        ; 8
    ASC..9== 71        ; 9
    ASCCOL== 72        ; :
    ASCSEM== 73        ; ;
    ASC.LT== 74        ; <
    ASCEQU== 75        ; ==
    ASC.GT== 76        ; >
    ASCQST== 77        ; ?
    ASC.AT== 100       ; @
;
;
    ASC..A== 101       ;A
    ASC..B== 102       ;B
    ASC..C== 103       ;C
    ASC..D== 104       ;D
    ASC..E== 105       ;E
    ASC..F== 106       ;F
    ASC..G== 107       ;G
    ASC..H== 110       ;H
    ASC..I== 111       ;I
    ASC..J== 112       ;J
    ASC..K== 113       ;K
    ASC..L== 114       ; L
    ASC..M== 115       ;M
    ASC..N== 116       ;N
    ASC..O== 117       ; O
    ASC..P== 120       ;P
    ASC..Q== 121       ;Q
    ASC..R== 122       ;R
    ASC..S== 123       ;S
    ASC..T== 124       ;T
    ASC..U== 125       ;U
    ASC..V== 126       ;V
    ASC..W== 127       ;W
    ASC..X== 130       ;X
    ASC..Y== 131       ;Y
    ASC..Z== 132       ;Z
;
    ASCLBR== 133       ; [
    ASCBSL== 134       ; \
    ASCRBR== 135       ; ]
    ASCUPA== 136       ; ^
    ASCUND== 137       ; UNDERLINE OR BACKARROW (_)
    ASCBKR== 137
    ASCGRA== 140       ; GRAVE ACCENT
;
;
    ASCLCA== 141       ;LOWER CASE A
    ASCLCB== 142       ;LOWER CASE B
    ASCLCC== 143       ;LOWER CASE C
    ASCLCD== 144       ;LOWER CASE D
    ASCLCE== 145       ;LOWER CASE E
    ASCLCF== 146       ;LOWER CASE F
    ASCLCG== 147       ;LOWER CASE G
    ASCLCH== 150       ;LOWER CASE H
    ASCLCI== 151       ;LOWER CASE I
    ASCLCJ== 152       ;LOWER CASE J
    ASCLCK== 153       ;LOWER CASE K
    ASCLCL== 154       ;LOWER CASE L
    ASCLCM== 155       ;LOWER CASE M
    ASCLCN== 156       ;LOWER CASE N
    ASCLCO== 157       ;LOWER CASE O
    ASCLCP== 160       ;LOWER CASE P
    ASCLCQ== 161       ;LOWER CASE Q
    ASCLCR== 162       ;LOWER CASE R
    ASCLCS== 163       ;LOWER CASE S
    ASCLCT== 164       ;LOWER CASE T
    ASCLCU== 165       ;LOWER CASE U
    ASCLCV== 166       ;LOWER CASE V
    ASCLCW== 167       ;LOWER CASE W
    ASCLCX== 170       ;LOWER CASE X
    ASCLCY== 171       ;LOWER CASE Y
    ASCLCZ== 172       ;LOWER CASE Z
;
    ASCLBC== 173       ;LEFT BRACE
    ASCVLN== 174       ;VERTICAL LINE
    ASCRBC== 175       ;RIGHT BRACE
    ASCTIL== 176       ;TILDE
    ASCDEL== 177       ;RUB OUT (DELETE)
;
;
  SUBTTL SYMBOL DEFINITIONS--RADIX 50
;
;
;
    RDXSPA== 0         ;SPACE
    RDX..0== 1         ; 0
    RDX..1== 2         ; 1
    RDX..2== 3         ; 2
    RDX..3== 4         ; 3
    RDX..4== 5         ; 4
    RDX..5== 6         ; 5
    RDX..6== 7         ; 6
    RDX..7== 10        ; 7
    RDX..8== 11        ; 8
    RDX..9== 12        ; 9
;
    RDX..A== 13        ; A
    RDX..B== 14        ; B
    RDX..C== 15        ; C
    RDX..D== 16        ; D
    RDX..E== 17        ; E
    RDX..F== 20        ; F
    RDX..G== 21        ; G
    RDX..H== 22        ; H
    RDX..I== 23        ; I
    RDX..J== 24        ; J
    RDX..K== 25        ; K
    RDX..L== 26        ; L
    RDX..M== 27        ; M
    RDX..N== 30        ; N
    RDX..O== 31        ; O
    RDX..P== 32        ;P
    RDX..Q== 33        ; Q
    RDX..R== 34        ; R
    RDX..S== 35        ; S
    RDX..T== 36        ; T
    RDX..U== 37        ; U
    RDX..V== 40        ; V
    RDX..W== 41        ; W
    RDX..X== 42        ; X
    RDX..Y== 43        ; Y
    RDX..Z== 44        ; Z
;
    RDXDOT== 45        ; .
    RDXDOL== 46        ; $
    RDXPER== 47        ; %
;
;
  SUBTTL SYMBOL DEFINITIONS--SYSTEM CONSTANTS
;
;
;
    JOBUUO== 40        ;LOC WHERE USER UUO IS STORD
    JOB41== 41         ;LOC OF TRANSFER AFTER USER UUO
    JOBREL== 44       ;LOC OF ABS TOP OF CORE
    JOBDDT== 74        ;LOC OF DDT
    JOBSYM== 116       ;LOC OF SYMBOL TABLE
    JOBSA== 120       ;START ADDRESS
    JOBFF== 121       ;FIRST FREE ADDRESS
    JOBREN== 124      ;REENTER ADDRESS
;
;
;
 FDBBYV== 11 ;BYTE SIZE WORD IN FDB
;
;
;
;
;
    PRINTX *****START OF BAS04*****
;
;
SUBTTL START OF CODE
;
;
;
;
;
TWOSEG
RELOC 400000
;
;
CODHED:
;
;
  SUBTTL INTERRUPT ROUTINES--INTSET
;
;   INTSET--THIS ROUTINE IS USED TO SET UP FOR INTERRUPT PROCESSING.
;      IT IS CALLED ONCE BEGGORE ANY INTERRUPTS CAN  E ACCEPTED.
;
;
 INTSET:
    CIS			;CLEAR INTERRUPT SYSTEM
    MOVEI  R1,400000   ;SELECT CURRENT FORK
    EIR                ;ENABLE INTERRUPTS
    MOVE   R2,[XWD LEVTAB,CHNTAB] ;GET TANBLE POINTERS
    SIR                ;SET UP FOR INTERRUPTS
    MOVE   R2,[000507500000] ;SELECT CHANNELS TO USE
    AIC                ;ACTIVATE THEM
    POPJ P,
;
;
  SUBTTL INTERRUPT ROUTINES--TABLES (LEVTAB AND CHNTAB)
;
;
;   LEVTAB--POINTERS TO PC STORE WORDS
;
 LEVTAB:
    XWD    0,INTPC1    ;LEVEL 1
    XWD    0,INTPC2    ;LEVEL 2
    XWD    0,INTPC3    ;LEVEL 3
;
;   CHNTAB--TRNASFER VECTOR FOR INTERRUPT PROCESSING
;
 CHNTAB:
    XWD    0           ;CHARACTERS
    XWD    0
    XWD    0
    XWD    0
    XWD    0
    XWD    0
;
    XWD    0           ;APR OVERFLOW
    XWD    0           ;FLOATING APR OVERFLOW
;
    XWD    0
;
    XWD    1,FAULT     ;PDL OVERFLOW
    XWD    0           ;END OF FILE
    XWD    3,DATER     ;FILE DATA ERROR
;
    XWD    0           ;MISC FILE
    XWD    0
    XWD    0           ;TIME OF DAY
;
    XWD    1,ILIST     ;ILLEGAL INSTRUCTION
    XWD    1,FAULT     ;ILLEGAL MEMORY READ
    XWD    1,FAULT     ;ILLEEGAL MEMORY WRITE
    XWD    1,FAULT     ;ILLEGAL MEMORY EXEC
    XWD    0           ;FORK TERMINATION
    XWD    1,FAULT     ;MACHINE SIZE EXCEEDED
    XWD    0           ;TRAP TO USER
    XWD    0           ;NON-EXISTANT PAGE
;
    XWD    0
;
    XWD    0           ;CHARACTERS
    XWD    0
    XWD    0
    XWD    0
    XWD    0
    XWD    0
;
SUBTTL INTERRUPT ROUTINES--DATER
;
;   DATER--THIS ROUTINE HANDLES A FILE DATA ERROR
;
;
 DATER:
    MOVEI  R0,FILER    ;GET ERROR ENTRY
    HRRM   R0,INTPC3   ;SAVE FOR RETURN
    DEBRK              ;AND RETURN
;
;
 FILER:ERR E.FLER      ;FILE DATA ERROR
;
;
  SUBTTL INTERRUPT ROUTINES--ILIST
;
;   ILIST--HANDLE AN ILLEGAL INSTRUCTION.  THIS COULD BE AN ERROR
;      MESSAGE CALL OR IT COULD BE A FAULT CONDITION.
;
;
 ILIST:
    MOVEM  R17,ERREGS+17 ;SAVE REGS
    MOVEI  R17,ERREGS
    BLT    R17,ERREGS+16
    MOVE   T0,INTPC1  ;GET FLT ADD
    MOVE   R0,-1(T0)   ;GET OP
    LSH    R0,-33
    CAIE   R0,1        ;CHECK FOR ERROR MESSAE
    JRST FAULT 		;NO--SYSTEM ERROR
    JRST   ERPRC       ;YES--PROCESS
;
;
;
  SUBTTL INTERRUPT ROUTINES--FAULT
;
;   FAULT--THIS ROUTINE IS ENTERED WHEN WE GET A FATAL OR UNEXPECTED
;      INTERRUPT.  IT PRINTS THE ASSOCIATED ERROR MESSAGE (SYSTEM
;      MESSAGE) AND THEN TERMNATES.
;
;
 FAULT:
    MOVEM R0,FLTRGS	;SAVE R0
    MOVE R0,INTPC1	;GET PC OF INTERRUPT
    MOVEM R0,FLTLOC	;SAVE FOR ERROR DEBUGGING
    MOVEI  R0,FLERR    ;GET EXIT ADDRESS
    HRRM   R0,INTPC1   ;SAVE FOR RETURN
    MOVE R0,FLTRGS	;RESTORE R0
    DEBRK              ;AND RETURN
;
;
 FLERR:
    MOVEM  R0,FLTRGS   ;SAVE REGISTERS
    MOVE   R0,[XWD 1,FLTRGS+1]
    BLT    R0,FLTRGS+17
;
    MOVEI  R1,400000   ;CURRENT FORK
    GETER              ;GET LAST ERROR NUMBER
    MOVEI  R1,101      ;;PRIMARY OUTPUT DEVICE
    MOVEI  R3,0        ;DEFAULT MESSAGE
    ERSTR              ;ERROR # TO STRING ON USER TTY
    NOP		;IGNORE BAD RETURNS
    NOP		
    MOVEI  R1,37       ;CR
    PBOUT
    PBOUT
    ERR E.SYS		;PRINT ERROR MESSAGE
    HALTF              ;AND TERMINATE
;
;
    PRINTX *****START OF BAS05*****
;
;
  SUBTTL ERROR MESSAGE ROUTINES--ERPRC
;
;   ERPRC--THIS ROUTINE IS THE MAIN ERROR MESSAGE PRINTER.  IS IS CALLED
;      WITH THE UUO 'ERR' (=001).  THE ADDRESS OF THE UUO IS A POINTER
;      TO THE BLOCK FOR THE MESSAGE.  THE FIRST WORD OF THE BLOCK CONTAINS
;      BITS IN THE LOWER HALF.  THE SECOND AND FOLLOWING WORDS CONTAIN
;      THE ERROR MESSAGE AS AN ASCII STRING TERMINATED WITH A NULL (000).
;
;
 ERPRC:
;
  SKIPE R2,SRCJFN	;CHECK SOURCE FILE
  CAMN R2,ERJFN		;VERSUS PREVIOUS
    JRST ERPR6A		;SAME--NO LIBRARY HEADER NEEDED
  MOVEM R2,ERJFN	;SAVE FOR NEXT TIME
  MOVEI R1,ASCEOL		;EOL
  PBOUT		;PRINT
  HRROI R1,[ASCIZ /Library: /] ;PREFIX MESSAGE
  PSOUT ;PRINT
  MOVEI R1,101 ;TO TTY
  HRRZ R2,ERJFN ;FOR CURRNT SOURCE FILE
  MOVEI R3,0 ;FREE FORMAT
  JFNS ;PRINT FILE NAME
  MOVEI R1,ASCEOL ;EOL
  PBOUT ;PRINT
;
 ERPR6A:
  SKIPGE R2,PRGNM ;SUB NAME AS RELEVANT
  JRST ERPR6 ;IF MAIN PROGRAM, SKIP THIS CODE
  SKIPN IFLTYP	;IF .REL FILE, SKIP NAME
  CAMN R2,ERLNM ;CHECK FOR MATCH
  JRST ERPR6 ;HANDLE IF SAME
  MOVEI R1,ASCEOL ;NEW LINE
  PBOUT ;PRINT
  HRROI R1,[ASCIZ /Sub: /]
  PSOUT ;PRINT HEADER
  MOVEM R2,ERLNM ;SAVE SUB FOR NEXT TIME
  HRROI R1,SUBNAM(R2) ;GET PTR TO NAME
  SKIPN R2 ;USE IT IF NOT MAIN PROGRAM
  HRROI R1,[ASCIZ /MAIN PROGRAM/]
  PSOUT ;AND PRINT NAME
  MOVEI R1,ASCEOL ;GET EOL CHR
  PBOUT ;AND PRINT
;
 ERPR6:
  MOVE R2,PAGECT ;GET PAGE COUNT
  CAMN R2,ERLPG ;CHECK FOR SAME AS LAST MESSAGE
  JRST ERPR7 ;AND JUMP IF SO
    MOVEI R1,ASCEOL ;EOL
    PBOUT ;PRINT
  HRROI R1,[ASCIZ /Page /] ;Page HEADER
  PSOUT ;PRINT
  MOVEM R2,ERLPG ;SAVE PAGE NUMBER
  AOS R2 ;PLUS ONE TO GET ACTUAL PAGE
    MOVEI R1,101 ;TO TTY
    MOVEI R3,12 ;FREE FORMAT
    NOUT ;PRINT THE PAGE NUMBER
      BLOWUP ;MUST WORK
  MOVEI R1,ASCEOL ;NEW LINE
  PBOUT ;PRINT
;
 ERPR7:
    HRRZ   T0,JOBUUO   ;GET ADDRESS SPECIFIED
    HRROI  R1,1(T0)    ;GET STRING ADDRESS
    PSOUT              ;PRINT THE STRING
    MOVE   T7,0(T0)    ;GET BITS IN T7
;
;
    TRNN   T7,ER.L     ;PLAIN LINE NUMBER
    JRST   ERPR3A       ;NO
    MOVEI R1,ASC.SP ;SPACE BEFORE NUMBER
    PBOUT
    MOVE   R2,XLNNO ;YES--GET NUMBER
    PUSHJ P,ERLIN     ;AND PRINT IT
;
 ERPR3A:
  TRNN T7,ER.B ;CHECK IF ERBUF RELEVANT
    JRST ERPR3B ;NO--SKIP
  MOVEI R1,ASC.SP ;YES--SPACE
  PBOUT ;PRINT
  HRROI R1,ERBUF ;STRING PTR TO ERBUF
  PSOUT ;PRINT
  MOVEI R1,ASC.SP ;SAPCE
  PBOUT ;PRINT
;
 ERPR3B:
  TRNN T7,ER.Y ;CHECK IF ERBUF CONTAINS TALLY
    JRST ERPR3 ;NO--SKIP
  MOVEI R1,ASC.SP ;YES--SPACE FIRST
  PBOUT
  HRRO R1,ERBUF ;GET/CREATE TALLY
  PSOUT ;PRINT STRING POINTED TO
  MOVEI R1,ASC.SP ;END SPACE
  PBOUT
;
 ERPR3:
    SKIPL RPGFG		;IF ONE-LINE DON'T PRINT LINENUMBER
    TRNN   T7,ER.I     ;'IN LINE LLLLL'
    JRST   ERPR1
    HRROI  R1,[ASCIZ / in /]
    PSOUT
    MOVE   R2,LSTLN    ;LINE#
    PUSHJ P,ERLIN
;
 ERPR1:
    TRNN   T7,ER.A     ;' AFTER LINE LLLLL'
    JRST   ERPR2
    HRROI  R1,[ASCIZ / after /]
    PSOUT
    MOVE   R2,LSTLN    ;LINE NO
    PUSHJ P,ERLIN
;
 ERPR2:
    TRNN   T7,ER.N     ;'AND LINE LLLLL'
    JRST   ERPR4
    HRROI  R1,[ASCIZ / and /]
    PSOUT
    MOVE   R2,XLNNO ;LINE NO IN T7
    PUSHJ P,ERLIN
;
 ERPR4:
    TRNN   T7,ER.F     ; ' FOR XXXXX'
    JRST   ERPRX
    HRROI  R1,[ASCIZ / for /]
    PSOUT
    HRROI  R1,ERREGS+T7 ;STRING POINTER TO WORD
    PSOUT
;
;
;
 ERPRX:
    MOVEI R1,ASCEOL ;CRLF
    PBOUT ;PRINT
;
    TRNE   T7,ER.T     ;CHECK IF TERMINAL
    HALTF              ;HALT IF SO
    TRNE T7,ER.Q	;QUESTIONABLE ERROR ONLY
    JRST ERPR5		;YES--RETURN NOW
;
    AOS    T0,ERCNT    ;ELSE UPDATE NUMBER OF ERRORS
    CAIL   T0,5        ;CHECK IF TOO MANY
    JRST ERPR8 ;HANDEL TERMINAL
;
 ERPR9:
    TRNE   T7,ER.W     ;CHECK IF WARNING
    JRST   ERPR5       ;JUST RETURN
;
    HRRZI  T0,XEOL     ;ELSE GET ROUTINE FOR IGNORE LINE
    TRNN T7,ER.G ;CHECK FOR IGNORE REST OF LINN
    JRST .+4 ;HANDLE IF NOT--SKIP
    MOVEM  T0,INTPC1   ;SAVE IT
    MOVE P,OLDPDL ;GET ODL PDL VALUE
    MOVEM P,ERREGS+P ;AND SAVE IT AGAIN
;
  SKIPE R1,BINJFN ;GET BINARY JFN
  DELF ;DELETE IT IF IT EXISTS
    NOP ;IGNORE ERROR
  SETZM BINJFN ;NO BINARY FILE
;
 ERPR5:
    HRLZI  R17,ERREGS  ;RESTORE REGS
    BLT    R17,R17
    DEBRK
;
 ERPR8:
  MOVEI T0,1 ;REDUCE ERROR COUNT
  MOVEM ERCNT ;BUT DON'T MAKE IT ZERO
  HALTF ;NOW HALT
  JRST ERPR9 ;ALLOW THE USER TO CONTINUE WITH 4 MORE
;
;
;
SUBTTL ERROR MESSAGE ROUTINES--ERUDFC
;
;   ERUDFC--THIS ROUTINE IS CALLED WITH A FUNCTION NUMBER
;      IN T1 AND SHOULD PRINT THE MESSAGES RELATING TO THAT
;      FUNCTION BEING UNDEFINED.
;
;
ERUDFC:
;
  PUSH P,R1 ;SAVE R1
  PUSH P,R2 ;AND R2
  PUSH P,T0 ;AND T0
;
  MOVE T0,T1		;GET PTR ALSO IN T0
  LSH T0,-1		;BUT MAKE IT ACTUAL NUMBER
;
  MOVSI R1,432340 ;ASCIZ /FN/
  CAIL T0,32 ;CHECK IF STRING FCT
    JRST ERUFC1 ;HANDLE STRINT
  MOVEI R2,ASC..A(T0) ;GET NAME
  LSH R2,7		;MAKE ROOM FOR DUMMY CHR
  JRST ERUFC2 ;AND SKIP
;
 ERUFC1:
  MOVEI R2,ASC..A-32(T0) ;GET NAME FOR STRING FCT
  LSH R2,7		;MAKE ROOM FOR '$'
  ADDI R2,ASCDOL ;ADD DOLLAR SIGN
;
 ERUFC2:
  LSH R1,1+7 ;POSITION NAME CHR
  ADD R1,R2 ;ADD TO FULL NAME
  MOVEM R1,ERBUF ;SAVE IN BUFFER
;
  HRRZ R2,UFCLTB(T0) ;GET LIST OF UNDEF CALLS
  PUSHJ P,ERLST ;FOR EACH LINE IN LIST
  JRST .+3 ;SKIP WHEN DONE
    ERR E.UDFC ;PRINT ERROR FOR EACH LINE
    POPJ P, ;AND CONTINUE WITH NEXT
;
  POP P,T0 ;RESTORE T0
  POP P,R2 ;RESTORE R2
  POP P,R1 ;AND R1
  POPJ P, ;THEN RETURN
;
;
SUBTTL ERROR MESSAGE ROUTINES--ERUDLB
;
;   ERUDLB--THIS ROUTINE PRINTS THE UNDEFINED LINE
;      ERROR MESSAGE FOR EACH LINE WHERE THE LINE IS USED.  THE
;      UNDEFINED LINE NUMBER TABLE LINK IS IN T6 ON ENTRY.
;
;
ERUDLB:
;
  PUSH P,LSTLN ;SAVE LAST LINE
  PUSH P,R2 ;AND SAVE REGS R2,R1
  PUSH P,R1 
  MOVE R2,1(T6) ;GET LINE
  MOVEM R2,XLNNO ;SAVE FOR MESSAGE
  HLRZ R2,0(T6) ;GET UDF LIST
;
  PUSHJ P,ERLST ;FOR EACH REFERENCING LINE
  JRST .+3 ;SKIP WHEN DONE
    ERR E.UDLA ;PRINT MESSAGE FOR EACH LINE
    POPJ P, ;CONTINUE WITH NEXT MESSAGE
;
  POP P,R1 ;RESTORE REGS
  POP P,R2
  POP P,LSTLN ;RESTORE LST LINE
  POPJ P, ;AND RETURN
;
;
SUBTTL ERROR MESSAGE ROUTINES--ERLST
;
;   ERLST--THIS ROUTINE TAKES A LIST LINKED TO THE
;      OBJECT CODE IN R2 ON ENTRY AND PUSHJ TO 1(CALL)
;      FOR EACH LINE SPECIFIED IN THAT LIST.
;
;
ERLST:
;
  PUSHJ P,ERFLNN ;FIND LINE NUMBER
  MOVEM R1,LSTLN ;SAVE IT
  MOVE R1,0(P) ;GET CALLING ADDRESS
  PUSHJ P,1(R1) ;GENERATE ERROR MESSAGE
  ADD R2,OBJCOD ;RELOCATE NEXT LINK
  HRRZ R2,0(R2) ;AND PICK IT UP
  JUMPN R2,ERLST ;LOOP IF MORE IN LIST
  POPJ P, ;AND RETURN WHEN DONE
;
;
SUBTTL ERROR MESSAGE ROUTINES--ERFLNN
;
;   ERFLNN--THIS ROUINE TAKES A LOCATION IN R2 ON ENTRY (RELATIVE)
;      AND FINDS THE LINE NUMBER CORRESPONDING TO IT BY LOOKING
;      THRU THE LINETB.
;
;
ERFLNN:
;
  PUSH P,R2 ;SAVE INITIAL LINK
  SKIPA R1,LNNMS ;GET FIRST TABLE PTR
  ADDI R1,2 ;GET NEXT TABLE PTR
  HRRZ R2,1(R1) ;GET ITS VALUE
  CAMLE R2,0(P) ;CHECK IF THERE YET
  JRST .-3 ;AND LOOP
;
  POP P,R2 ;YES--RESTORE VALUE
  MOVE R1,0(R1) ;GET LINE NUMBER
  POPJ P, ;AND RETURN
;
;
  SUBTTL ERROR MESSAGE ROUTINES--ERLIN
;
;   ERLIN--THIS ROUTINE PRINTS THE NUMBER IN R2 ON ENTRY IN THE ERROR
;      MESSAGE CURRENTLY BEING PRINTED.
;
;
 ERLIN:
    HLRZ R4,R2 ;GET PAGE NUMBER IN R4
    ANDI R2,377777 ;GET ONLY ACTUAL LINE NUMBER
    MOVEI  R1,101      ;PRIMARY OUTPUT
    MOVEI  R3,12       ;RADIX DECIMAL
    NOUT               ;DO THE OUTPUT
    BLOWUP    ;SYSTEM ERROR IF BAD
;
  CAMN R4,PAGECT ;CHECK IF ON CURRENT PAGE
    JRST ERLIN1 ;SKIP IF SO
  HRROI R1,[ASCIZ / on page /] ;HEADER
  PSOUT ;PRINT HEADER
  MOVEI R1,101 ;TO TTY
  MOVEI R2,1(R4) ;GET PAGE NUMBER
  NOUT ;PRINT PAGE NUMBER
    BLOWUP ;MUST WORK
;
 ERLIN1:
    MOVEI  R1,40       ;FOLLOWING SPACE
    PBOUT
    POPJ P,      ;AND RETURN
;
;
  SUBTTL ERROR MESSAGE ROUTINES--ERROR TABLE
;
;
;
 E.INFT:ERM <I,G>,Incorrect format
 E.NCND:ERM <I,G>,No relational operator
 E.MTNM:ERM <I,G>,Matrix names may only be single letter
 E.MIX:ERM <I,G>,Mixed string and numeric operation
 E.VAR:ERM <I,G>,Illegal variable
 E.ASC:ERM <I,G>,Illegal ASC function argument
 E.ILCN:ERM <I,G>,Illegal constant
 E.NQT:ERM <I,G>,String constant must end with a quotation mark
 E.OPNA:ERM <I,G>,Operation not allowed
 E.NFN:ERM <I,G>,File number required
 E.UNMT:ERM <I,G>,Unmatched parenthesis
 E.CMP:ERM <I,G>,Expression too complicated
 E.TFAR:ERM <I,G>,Too few arguments
 E.TMAR:ERM <I,G>,Too many arguments
 E.ARTY:ERM <I,G>,Argument types do not match
 E.EOF:ERM <I,T>,No END or SUBEND statement
 E.NOLN:ERM <A,G>,No line number on line
 E.LNTL:ERM <A,G>,Line number too long
 E.ILST:ERM <I,G>,Illegal statement
 E.UDLA:ERM <L,I,W>,Undefined line number
 E.TOCN:ERM <T,I>,Too many constants
 E.LNOD:ERM <A>,Line number out of order
 E.ILCH:ERM <W,I>,illegal character
 E.FLER:ERM <T,L>,File error
 E.NSBC:ERM <I,G>,Wrong number of dimensions
 E.DATA:ERM <I,G>,Illegal constant in DATA statement
 E.DIM:ERM <I,G>,Illegal dimension specification
 E.FMDF:ERM <I,G>,Function multiply defined
 E.VREX:ERM <I,G>,Variable required
 E.FLNO:ERM <I,G>,File number required
 E.FWON:ERM <I,W>,FOR without NEXT
 E.LNNO:ERM <I,G>,Illegal line number
 E.TWMN:ERM <I>,Two main programs
 E.END:ERM <I,G>,END not at end of main program
 E.FCLN:ERM <I,G>,Attempt to transfer in or out of function
 E.PTBG:ERM <I,T>,Program too large
 E.ILMT:ERM <I,G>,Illegal MAT statement
 E.ILMF:ERM <I,G>,Illegal MAT function
 E.DMER:ERM <I,G>,Dimension error
 E.UIMP:ERM <I,W>,Feature not implemented at run time
 E.CLNM:ERM <I,G>,CALL name must be constant string
 E.SUB:ERM <I,G>,SUB must be first statement in program
 E.SBNM:ERM <I,G>,SUB name must be constant string
 E.TWSB:ERM <I,G>,Two SUBs with the same name
 E.SBAR:ERM <I,G>,SUB arguments must be variables
 E.SBND:ERM <I,W>,SUBEND not at end of SUB
 E.SBTY:ERM <I,G>,SUB arg types mismatched
 E.ISBN:ERM <I,G>,SUB name can't be null
 E.ISBL:ERM <I,G>,SUB name must be 8 chrs or less in length
 E.TMSA:ERM <I,G>,Too many arguments for SUB
 E.IRDX:ERM <I,G>,Name can't be converted to radix50
E.ISBF:ERM <I,G>,Illegal file number for SUB statement
 E.NFCT:ERM <I,G>,FNEND without DEF
 E.NFNE:ERM <I,W>,No FNEND for function
 E.NMNP:ERM <I>,No main program
 E.NSFC:ERM <I,G>,Nested function definitions
 E.NWOF:ERM <I,G>,NEXT without FOR
 E.SUDF:ERM <W,B>,Missing SUBprogram
 E.UDFC:ERM <I,W,B>,Undefined function
 E.IPQT:ERM <I,G>,Quotes may not be used as PRINT delimiters
 E.CDGM:ERM <I,G>,Can't dimension global matrices
E.SYS: ERM <T,I>,Compiler system error
E.LBNM: ERM <I,W>,Illegal LIBRARY name
E.LBNA: ERM <I,W,Y>,Couldn't open LIBRARY
E.TMFL: ERM <G,I>,Too many LIBRARY files
E.TIM: ERM <I,G>,Constant required for TIME statement
E.TMPG: ERM <I,G>,TIME statement must be in main program
 E.ALC: ERM <I,G>,No new variables allowed without recompiling
E.OLTL: ERM <I,G>,Statement too complex to execute
E.NNSB: ERM <I,G>,No new SUBs allowed without recompiling
E.VDTW: ERM <I,W>,Variable defined twice in SUB statement
E.FDTW: ERM <I,W>,Function defined twice in SUB statement
E.MDTW: ERM <I,W>,Matrix defined twice in SUB statement
E.TMFS: ERM <I,W>,Too many files defined in SUB statement
E.FLDT: ERM <I,W>,File defined twice in SUB statement
 E.UDFN:ERM <I,G>,Undefined funtion name
 E.RQN1:ERM <W>,Illegal directory for required LIBRARY
 E.RQN2:ERM <W>,Name too long for required LIBRARY
 E.RBKI:ERM <W>,Illegal .REL file
 E.RBKR:ERM <W>,Required file couldn't be found
;
;
  SUBTTL INITIALIZATION ROUTINES--START
;
;   START--THIS ROUTINE STARTS THE COMPILER OON THIS RUN.  IT FINDS AND
;      SAVES THE VARIOUS CORE LIMITS, READS THE FILE LIST, AND THEN
;      SETS UP CORE AND TABLES AND BEGINS COMPILING.
;
;
 START:
  JRST MONENT		;ENTRY VECTOR--MONITOR ENTRY
  JRST REENT		;REENTERY ADDRESS
  JRST LINENT		;ENTRY FOR ONE LINE COMPILATION
  JRST CHNENT		;ENTRY FROM CHAIN
;
;
 MONENT:
  SETZM RENTFG		;REENTRY NOT ALLOWED
;
 MNENT0:
  MOVNI R1,1		;FLAG TO GET PAGES OUT OF MAP
  HRLI R2,400000	;FROM CURRENT FORK
  HRRI R2,SRCPGN	;NO SOURCE FILE
  PMAP
  HRRI R2,GBLPGN	;NO GLOBAL INFO
  SKIPG RENTFG		;CHECK IF REENTRY
    PMAP
  HRRI R2,SYMPGN	;NO SYMBOL TABLE
  PMAP
  HRRI R2,CHNPGN	;NO CHAIN INFO
  PMAP
  MOVEI R0,0		;CLEAR R0 ON MONITOR ENTRY
  JRST MNENT1
;
 CHNENT:
  SETZM RENTFG		;NO REENTRY UNTIL SETTLED
  MOVEI R0,1		;SET R0 FOR BASIC EXEC ENTRY
;
 MNENT1:
  MOVEM R0,RPGFG ;SAVE ENTRY TYPE FLAG
  RESET ;RESET EVERY THING
  MOVEI R0,START	;GET START (EVEC) ADDRESS
  MOVEM R0,COMENT	;SAVE IN COMMON AREA
  SETZM CURSYM		;NO SYMBOL TABLE IN CORE
  JRST START0 ;AND DO START UP FOR FULL COMPILATION
;
 LINENT:
  SETOM RPGFG	;SET ENTRY FLAG FOR ONE LINE
  SETZM DEBFG		;NO DEBUG MODE
;
;
 START0:
  MOVE P,[IOWD 200,PDLBUF] ;SET UP PDL
  MOVEM P,SAVEP ;SAVE AS ORIG P
  PUSH P,[XWD -5,0] ;SAVE DUMMY 0 ON STACK
;
    SETZM  LSTLN       ;NO LAST LINE
    SETZM  MAINFG      ;NO MAIN PROGRAM
    PUSHJ P,INTSET    ;SET UP INTERRUPT SYSTEM
    SETZM  EOFFG       ;MARK EOF OF FILE
    SETZM ERLNM ;MAIN PROGRAM FOR ERROR MESSAGE NAME
    SETZM ERLPG ;PAGE 1 FOR ERROR MESSAGE PAGE
    SETZM ERCNT ;NO ERRORS 
    SETZM NUMLRQ	;NO FILES REQUIRED
    SKIPE RPGFG	;CHECK IF MONITOR ENTRY
    JRST START1 ;IF NOT, LEAVE SUB TABLE AS IS
;
  MOVNI R1,1		;FLAG TO GET PAGES OUT OF MAP
  HRLI R2,400000	;FROM CURRENT FORK
  HRRI R2,SUBPGN	;SUB TABLE
  PMAP
  AOS R2
  PMAP
    SETZM NSUBS		;NO SUBS THUS FAR
  SKIPLE RENTFG		;CHECK FOR REENTRY
    JRST START1		;HANDLE IF SO
  HRRI R2,LIBPGN	;LIBRARY TABLE
  PMAP
;
 START1:
    MOVEI T0,140 ;DEFAULT
    MOVEM  T0,STBASE   ;SAVE IT
    PUSHJ P,STINIT      ;INITIALIZE STORAGE
;
;
    SETOM  PRGNM       ;NO PROGRAM NOW
  SKIPGE R2,RPGFG	;CHECK IF ONE LINE COMPILATION
    JRST START2		;SKIP IF SO
  MOVEM R2,NRPGFG	;IF NOT, SAVE FLAG FOR NAME SCAN
  SKIPG RENTFG		;HAVE NAMES IF REENTRY
    PUSHJ P,NSCAN	;GET COMPILATION FILES/DIRECTIONS
  PUSHJ P,CLRLOW	;CLEAR LOW SEGMENT
  PUSHJ P,LIBSET	;AND SET UP FIRST FILE
  MOVEI R2,START	;ENTRY VECTOR PTR
  HRLI R2,4		;AND LENGTH
  MOVEI R1,400000	;CURRENT FORK
  SEVEC			;SET TO ALLOW REENTRY
  SETOM RENTFG		;SET FLAG FOR REENTRY ALLOWED
;
 START2:
  SETOM RENTFG		;INDICATE REENTRY ALLOWED
  MOVE R2,SRCJFN ;GET CURRENT SOURCE
  MOVEM R2,ERJFN ;SAVE FIRST FOR ERROR MESSAGE DEFAULT
    PUSHJ P,RINIT     ;SET UP TABLES AND CORE AREAS
;
    JRST   LINE        ;AND START PROCESSING
;
;
;
SUBTTL INITIALIZATION ROUTINES--REENT
;
;   REENT--THIS ROUTINE HANDLES REENTRY.  IT CHECKS IF WE HAVE A FILE
;      SPECIFICATION ALREADY AND IF SO, USES IT WITH NO OUTPUT FILES.
;      IF NONE IS GIVEN, THEN IT ACTS THE SAME AS START.
;
;
REENT:
;
  SKIPN RENTFG		;CHECK IF REENTRY OK
    JRST MONENT		;NO--DO START
;
  MOVMS RENTFG		;INDICATE REENTRY SET UP
  SETZM SAVJFN		;NO SAVE FILE
  SETZM BINJFN		;NO BINARY FILE
  SETZM LSTJFN		;NO LIST FILE
  SETZM SYMJFN		;NO SYMBOL TABLE
;
  MOVSI R2,LBBCM!LBBRQ	;NO GO THRU SOURCES IN LIBRARY PAGE
  MOVEI R3,LIBLST	;SETTING AS UNCOMPILED
;
 REENT2:
  HRRZ R3,0(R3)		;GET NEXT PTR
  JUMPE R3,REENT1	;DONE
  ANDCAM R2,LBBTS(R3)	;OFF THE BITS
  SETZM LBJFN(R3)	;INDICATE CLOSED
  MOVEI R1,LBNAM(R3)	;PTR TO NAME
  HRLI R1,440700	;TALLY TO NAME
  ILDB R0,R1		;GET NEXT CHR
  JUMPE R0,REENT2	;DONE--CONTINUE
  CAIE R0,ASCSEM	;CHECK FOR SEMICOLON (VERSION SPEC)
    JRST .-3		;TRY NEXT CHR IF NOT
  MOVEI R0,0		;IF SO, REPLACE WITH NULL
  DPB R0,R1		;TO END NAME WITHOUT VERSION
  JRST REENT2		;AND LOOP
;
 REENT1:
  MOVE R3,LIBLST	;GET PTR TO FIRST
  MOVEM R3,FSTLIB	;SAVE AS FIRST SOURCE FILE
  JRST MNENT0		;AND THEN START UP
;
;
  SUBTTL INITIALIZATION ROUTINES--STINIT
;
;   STINIT--THIS ROUTINE SETS UP THE INITIAL STORAGE FOR VARIOUS
;      ITEMS IN LOW CORE.  CODE IS COMPILED UP TO THE COMPILER
;      IN LOW CORE
;
 STINIT:
    SKIPGE RPGFG ;CHECK FOR ONE-LINE COMPILATION
    JRST STINI0 ;DIFFERENT STORAGE ALLOC FOR IT
    MOVE   T0,STBASE   ;GET BOTTOM ADDRESS
    MOVEM  T0,ULINTB   ;SAVE AS BASE OF UNDEFINED LINE NO TBL
    ADDI T0,777 ;GET TO PAGE BOUNDARY
    ANDI T0,-1000 ;NEXT ONE
    ADDI   T0,NLINPG*1000 ;PLUS LENGTH
    MOVEM  T0,LINETB   ;HEAD OF DEFINED LINE NUMBERS
;
    ADDI   T0,NLINPX*1000 ;SPACE TO LEAVE
    MOVEM T0,CRELOC ;SAVE AS CONST RELOC ADDRESS
    MOVEI T1,440300 ;TALLY FOR IT
    HRLM T1,CRELOC ;MAKE INTO TALLY
;
    ADDI T0,NCRLPG*1000 ;SPACE TO LEAVE
    MOVEM  T0,CONST    ;SAVE AS BASE OF CONSTANT AREA
;
    ADDI   T0,NCSTPG*1000 ;PLUS ROOM  OR THAT
    MOVEM  T0,RELOCS   ;SAVE AS RELOCATION AREA
    MOVEI  T1,440300   ;MAKE BYTE PTR
    HRLM   T1,RELOCS   ;FOR AREA
;
    ADDI   T0,NRLCPG*1000 ;PLUS SIZE
    MOVEM  T0,OBJCOD   ;SAVE AS OBJECT CODE BASE
;
    POPJ P, ;AND RETURN
;
 STINI0:
  MOVEI T0,450000 ;GET END OF COMPILER
  MOVEM T0,STBASE ;AND USE STORAGE AT END OF IT
  ADDI T0,777 ;GET PAGE BOUNDARY
  ANDI T0,-1000 ;AFTER END
  MOVEM T0,LINETB ;SAVE AS START OF LINE NUMBER TABLE
  MOVEM T0,CRELOC ;AND BASE OF CONSTANTS FOR RELOC
  MOVSI T1,440300 ;UPPER HALF OF RELOCATIONFOR CONSTS PTR
  HLLM T1,CRELOC ;SAVE
  ADDI T0,1000 ;NEXT PAGE
  MOVEM T0,CONST ;SAVE AS CONSTANT AREA BASE
  ADDI T0,1000 ;NEXT PAGE
  MOVEM T0,RELOCS ;SAVE AS BASE FOR PRGM RELOCS
  HLLM T1,RELOCS ;CREATE RELOC TYPE PTR
  ADDI T0,1000 ;NEXT PAGE
  MOVEM T0,OBJCOD ;SAVE AS OBJECT CODE BASE
  POPJ P, ;THEN DONE
  SUBTTL INITIALIZATION ROUTINES--RINIT
;
;   RINIT--THIS IS THE INITIALIZE-FOR-COMPILING ROUTINE WHICH SETS UP
;      CORE AND THE COMPILER ITSELF TO COMPILE THE NEXT PROGRAM.  IT MAY
;      BE CALLED EITHER INITIALLY OR BEFORE RESTARTING THE COMPILER FOR
;      A SUBPROGRAM OR WHATEVER.
;
;
 RINIT:
    SKIPGE RPGFG ;CHECK FOR ONE-LINE ENTRY
    JRST RINIT1 ;HANDLE SPECIAL IF SO
    SETZM SYMTAB ;CLEAR SYMBOL TABLE
    MOVE T1,[XWD SYMTAB,SYMTAB+1] ;USING BLT
    BLT T1,SYMTAB+1000-1	;CLEAR WHOLD PAGE
;
;
    MOVEI T1,32+32-1 ;CLEAR MATRIX TABLES
    SETZM MATPTB(T1) ;PTRS
    SETZM MATDTB(T1) ;DIMS
    SOJGE T1,.-2 
;
;
    MOVEI  T1,UFCATB   ;CLEAR INTERNAL (USER) FUNCTION TABLE
    SETZM  FCIAD(T1)
    SETZM  FCIDWD(T1)
    ADDI   T1,2
    CAIGE  T1,UFCAND
    JRST   .-4
;
;
 RINIT1:
  MOVEI T1,32+32-1	;CLEAR UNDEFINED USER FCT TABLE
  SETZM UFCLTB(T1)
  SOJGE T1,.-1
;
;
  MOVEI T1,44-1	;CLEAR TEMPROARY LOCATIONS TABLE
  SETZM TMPTB(T1)
  SOJGE T1,.-1
;
;
  MOVSI T0,SBBUSD ;CLEAR SUB TABLE OF USED BITS AND LISTS
  MOVEI T2,SUBTBL ;PTR
  SKIPN T1,NSUBS
    JRST .+5
  ANDCAM T0,SUBBTS(T2) ;BIT FOR USED
  SETZM SUBADD(T2) ;LINKED LIST TO OBJECT
  ADDI T2,SUBBLN
  SOJG T1,.-3 
;
;
    MOVE   T0,CONST    ;GET ADDRESS OF CONSTANTS
    HRLI   T0,444400   ;MAX # OR CONSTANTS
    MOVEM  T0,CNSTK    ;SAVE AS STACK POINTER
    MOVNI  T0,NCSTPG*1000 ;LENGTH OF CONSTANT AREA
    MOVEM  T0,CNSTCT      ;SAVE AS COUNT
;
;
    MOVE   T0,ULINTB   ;GET PTR TO UNDEF LINE NUMBER TBL
    SUBI   T0,2        ;MINUS TWO
    MOVEM  T0,ULNPT    ;SAVE AS PTR
    SETZM  ULNLS       ;CLEAR LINE # POINTER
    SETZM  ULNFR	;NOTHING FREE
;
;
    MOVE   T0,LINETB   ;GET PTR TO LINE NUMBERS
    MOVEM  T0,LNNMS    ;SAVE
    MOVE   T0,RELOCS   ;GET PTR TO RELOC BYTES
    MOVEM  T0,RLCPT    ;SAVE (THIS IS A BYTE PTR)
    MOVEI  T0,14*NRLCPG*1000 ;NUMBER OF THEM
    SKIPGE RPGFG ;CHECK FOR ONE-LINE
    MOVEI T0,14*1000 ;ONE PAGE IF SO
    MOVNM  T0,RLCNT    ;SAVE FOR TABLE MOVING/OVERFLOW CHECKS
;
    MOVE T0,CRELOC ;CONST RELOC TALLY
    MOVEM T0,CRLCPT ;SAVE IT
    MOVEI T0,14*NCRLPG*1000 ;SPACE FOR THIS MANY BYTES
    SKIPGE RPGFG ;CHECK FOR ONE-LINE
    MOVEI T0,14*1000 ;ONE PAGE IF SO
    MOVNM T0,CRLCNT ;SAVE
;
    MOVE   T0,OBJCOD   ;GET OBJECT CODE PTR
    HRLI   T0,444400   ;MAKE BYTE PTR FOR WHOLE WORD
    MOVEM  T0,OBJTL    ;SAVE
    SETZM  OBJPT       ;CLEAR OFFSET
    HRROI T0,400000(T0) ;GET ROOM FOR OBJECT
    SKIPGE RPGFG ;CHECK FOR ONE-LINE
    MOVNI T0,1000 ;ONE PAGE IF SO
    MOVEM  T0,OBJCNT   ;SAVE
;
;
;
    MOVSI R1,777774	;NO REGISTERS USED
    MOVEM R1,REGFGS
    SETZM  REGUSD      ;
    SETOM TMPFGS ;NO TEMPS ASSIGNED
    SETZM TIMEC  ;NO TIME STATEMENT
;
    MOVEI T0,HDRLN.-1 ;PREALLOCATED HEADER SIZE
    SKIPL RPGFG		;SET ONLY IF NOT ONE LINE
    MOVEM T0,VADDN ;SAVE AS BASE
    SETZM  SADDN       ;NO STRS
    SETZM  CADDN       ;NO CNSTS
;
  SETZM NUMNVR ;CLEAR COUNTERS
  SETZM NUMSVR
  SETZM NUMMAT
  SETZM NUMFCT
  SETZM NUMLIN
  SETZM NUMSUB ;NO SUBS FOR PROGRAM
;
  SETZM PGMOFF ;CLEAR PROGRAM OFFSET
  SETZM LNHDPT ;LINK FOR DEBUG MODE
  SETZM ENTADD ;NO ENTRY ADDRESS
    SETZM FILUSD ;NO FILES USED
;
  MOVSI R2,(NOP)	;GET A NOP
  MOVEI R1,0		;AND ABS TYPE
  SKIPE DEBFG		;CHECK IF DEBUG MODE
  PUSHJ P,.SVWD		;SAVE IF SO
;
;
;
    POPJ P,      ;AND RETURN
;
;
;
SUBTTL INITIALIZATION ROUTINES--CLRLOW
;
;   CLRLOW--THIS ROUTINE CLEARS THE LOWER PART OF CORE IN PREPARATION
;      FOR COMPILING.  IT VERY NICELY MAKES ALL PAGES EXCEPT PAGE
;      ZERO DISSAPPEAR, AND PAGE ZERO IS CLEARED FROM 140 TO 777.
;
;
CLRLOW:
;
  HRLI R2,400000	;CURRENT FORK
  HRRI R2,377		;FIRST PAGE OF LOW CORE
  MOVNI R1,1		;MARKER TO GET RID OF PAGE
;
 CLRLW1:
  PMAP			;BYE BYTE
  SOS R2		;NEXT PLEASE
  TRNE R2,777777	;DOWN TO PAGE 0 YET
    JRST CLRLW1		;NO--CONTINUE
  HRLI R1,140		;YES--JUST CLEAR LOCS 140-777
  HRRI R1,141
  SETZM 140
  BLT R1,777
;
  HRRI R2,500		;FIRST PAGE ABOVE COMPILER
;
 CLRLW2:
  MOVNI R1,1		;FLAG TO CLEAR PAGE
  PMAP			;BYE BYE
  AOS R2		;NEXT PLEASE
  HRRZ R1,R2		;NOW WHERE WERE WE
  CAIE R1,760		;NOW THATS THE END
    JRST CLRLW2	;NOT QUITE
  HRRI R2,RTVPGN	;DON'T WANT THIS ONE EITHER
  MOVNI R1,1
  PMAP			;TA TA RTV PAGE
  SETZM RTPOK		;NO RTP ANYMORE
;
  POPJ P,		;AND DONE
;
;
  SUBTTL INITIALIZATION ROUTINES--STMAIN
;
;   STMAIN--THIS ORUTINE IS USED TO SET UP FOR THE MAIN PROGRAM.  IT IS
;      CALLED WITH A PUSHJ P,WHEN THERE IS NO CURRENT PROGRAM (PRGNM=-1)
;      AND AND EXECUTABLE (NON-COMMENT) STATEMENT WAS FOUND
;      BEFORE A SUB STATEMENT.  THUS THE MAIN PROGRAM IS IMPLIED.  IT
;      SETS UP FOR SUCH.
;
;
 STMAIN:
    SETZM  PRGNM       ;NAME IS MAIN
    SKIPE  MAINFG      ;CHECK FOR TWO MAIN PROGRAMS
    ERR    E.TWMN      ;ERROR IF SO
    PUSHJ P,FNMAIN	;GET SUB TBL BLOCK FOR MAIN
    MOVSI R2,SBBDEF	;BIT FOR SUB DEFINED
    IORM R2,SUBBTS(T7)	;MARK FOR MAIN
    HRLZI R1,-4 ;MARKER ON STACK FOR MAIN PROGRAM
    EXCH R1,0(P) ;GET RETURN, SAVE FLAG ON STACK
    MOVEM P,OLDPDL	;SAVE PDL IN CASE OF FURTHER ERRORS
    JRST 0(R1) ;AND RETURN
;
;
;
  SUBTTL TERMINATION ROUTINES--END
;
;   END--THIS ROUTINE FINISHES THE COMPILATION OF THE CURRENT INPUT
;      SPECIFICATION.
;
;
 END:
    SKIPL  PRGNM       ;CHECK IF END OF PROGRAM
    ERR    E.EOF       ;ERROR IF NOT
  PUSHJ P,OTSBTB ;WRITE OUT THE SUB TABLE
  PUSHJ P,OTRQBK	;WRITE OUT REQUIRES BLOCKS
    SKIPE CGOFG ;CHECK IF WE WANT TO RUN
    JRST ENDGO ;AND HAINDLE IF SO
    HRROI R1,[ASCIZ /Done/] ;TERM MESSAGE
    PSOUT ;PRINT
    MOVEI R1,ASCEOL ;CRLF
    PBOUT ;PRINT
    MOVNI R1,1		;CLOSE ALL FILES
    CLOSF
      ERR E.FLER	;SHOULD BE ABLE TO
    RLJFN		;ALSO RELEASE JFNS
      ERR E.FLER	;SHOULDN'T FAIL
    HALTF              ;AND THEN STOP
;
;
 ENDGO:
  SKIPN MAINFG ;CHECK IF THERE WAS A MAIN PROGRAM
  ERR E.NMNP ;ERROR IF NOT
  PUSHJ P,CHKSUB ;MAKE SURE ALL SUBS ARE DEFINED
  PUSHJ P,SETRUN ;SET UP TO RUN
;
  SKIPGE CGOFG ;CHECK IF WE WANT TO ACTUALLY START
  SKIPE ERCNT ;AND THERE WERE NO ERRORS
  HALTF ;HANT IF NO RUN
  SETZM SYMJFN		;NO SYMBOL TABLE LEFT AROUND
;
  SKIPN R1,SAVJFN ;CHECK IF SAVE REQUESTED
    JRST RTPGO ;NO--START EXECUTION
  HRLI R1,400000 ;CURRENT FORK
  MOVE R2,STBASE ;TOP OF USED CORE
  ADDI R2,777 ;TO PAGE BOUNDARY
  LSH R2,-11
  MOVNS R2 ;NEGATE SIZE
  HRLZS R2 ;TO UPPER HALF
  HRRI R2,520000 ;BITS FOR FILE
  MOVEI R3,0 ;CLEAR R3 FLAGS
  SSAVE ;DO A SAVE
  HRROI R1,[ASCIZ /Core image saved/]
  PSOUT			;PRINT TERMINATION MESSAGE
  MOVEI R1,ASCEOL
  PBOUT
;
 RTPGO:
  MOVNI R1,1		;CLOSE ALL FILES
  CLOSF			;THAT WE USED
    ERR E.FLER
  RLJFN			;AND RELEASE THE JFNS
    ERR E.FLER
  MOVEI R1,400000	;CURRENT FORK
  DIR			;NO MORE INTERRUPTS!!
  SKIPE SAVJFN		;DO WE WANT TO RUN?
    HALTF		;NO--STOP HERE AND NOW
  JRST @MAIN. ;YES--ENTER MAIN PROGRAM
;
SUBTTL TERMINATION ROUTINES--SETRUN
;
;   SETRUN--THIS ROUTINE IS USED TO SET UP ALL PARAMETERS
;      NEEDED BY THE RUN TIME PACKAGE, MAINLY IN THE
;      COMMUNICATIONS AREA 0..140.  IT ALSO SETS
;      UP A TENEX ENTRY VECTOR FOR RUN TIME.
;
;
SETRUN:
;
  MOVE R2,MAIN. ;GET START ADDRESS
  HRRZM R2,JOBSA ;SAVE AS START ADDRESS FOR PA1050
  HRRZM R2,JOBREN ;SAVE AS 10/50 REENTER ADDRESS
  HRLI R2,1 ;LENGTH OF ENTRY VECTOR
  MOVEI R1,400000 ;SET VECTOR FOR THIS FORK
  SEVEC ;GO TO IT
;
  MOVE R2,STBASE ;NOW GET POINTER TO TOP
  ADDI R2,2+4 ;SAVE SPACE, MISS ENTRY VECTOR
  HRRZM R2,JOBFF ;SAVE AS FIRST FREE LOC
  HRLM R2,JOBSA ;FOR 10/50 COMPAT
;
  SETZM JOBDDT ;RID OF DDT ENTRY
  MOVEI R2,377777 ;ABS TOP ALLOWED
  MOVEM R2,JOBREL ;SAVE FOR RT
;
  MOVE R1,RTSYMS ;GET RT SYMBOL TABLE
  MOVEM R1,JOBSYM ;SAVE IT
;
  MOVNI R1,1 ;GET MINUS ONE
  HRLI R2,400000 ;CURRENT FORK
  HRRI R2,SRCPGN ;PAGE OF SOURCE FILE
  PMAP ;SHOULD BE GOTTEN RID OF
;
  POPJ P, ;NOW RETURN
;
;
  SUBTTL TERMINATION ROUTINE--ENBIN
;
;   ENBIN--THIS ROUTINE FINISHED THE BINARY FILE FOR THE CURRENT MAIN
;      PROGRAM.  IT STICKS INTO IT THE STARTUP BLOCK AND NAME DEFS FOR
;      ENTRY.
;
;
 ENBIN:
;
    SKIPE T0,NDATP ;CHECK IF ANY NUMERIC DATA
    PUSHJ P,ENDPTR ;IF SO, FIX UP END PTR
    SKIPE T0,SDATP ;CHECK IF ANY STRING DATA
    PUSHJ P,ENDPTR ;IF SO, FIX UP END PTR
    PUSHJ P,CLEAN ;HANDLE UNDEF LINES AND FCTS
;
  SKIPN BINJFN ;CHECK IF BINARY FILE
  SKIPE CGOFG ;AND COMPILE ONLY
  SKIPA ;IF WE WANT TO RUN, OR FILE EXISTS CONTINUE
    POPJ P, ;NONE--RETURN
;
  PUSHJ P,STBIN		;DO START OF BINARY FILE
    PUSHJ P,OFFSET ;COMPUTE OFFSETS FIRST
    PUSHJ  P,OTPRGM      ;WRITE PROGRAM TO .REL FILE
    PUSHJ  P,OTSYMS      ;WRITE SYMS TO .REL FILE
    PUSHJ  P,OTSTRT      ;WRITE START ADDRESS T .REL FILE
    PUSHJ  P,OTENDB      ;WRITE END BLOCK TO .REL FILE
;
    PUSHJ P,OTCORE ;SAVE PROGRAM IN CORE
;
    POPJ P, ;AND RETURN
;
;
;
  SUBTTL INITIALIZATION ROUTINES--STBIN
;
;   STBIN--THIS ROUTINE IS USED TO START THE MAIN OR A SUBROUTINE IN THE
;      BINARY FILE.  IT OUTPUTS THE VARIOUS INFO TO SPECIFY PROGRAM NAME
;      AND START THE CODE.  IN ADDITION, THE FIRST SYMBOL IS STARTED.
;
;
 STBIN:
    MOVE   R1,BINJFN   ;BINARY FILE???
    JUMPE  R1,STBIN1   ;NO--RETURN IMMED
;
    MOVE   R2,[XWD 6,2] ;NAME BLOCK
    PUTWD
    MOVEI  R2,0        ;ZERO
    PUTWD
    MOVE   R2,PRGNM    ;PROGRAM NAME
    JUMPE R2,.+4 ;SKIP IF MAIN
    MOVE T7,R2 ;GET SUB PTR IN T7
    PUSHJ P,GETRNM ;GET RDX NAME
    SKIPA ;AND SKIP
    MOVE   R2,[RADIX50 0,MAIN.] ;MAIN PROGRAM NAME
    PUTWD
    HRLZI R2,100 ;COMPILER ID
    PUTWD
;
 STBIN1:
    POPJ P, ;AND RETURN
;
;
;
SUBTTL TERMINATION ROUTINES--OFFSET
;
;   OFFSET--THIS RLOUTINE COMPUTES THE VARIOUS OFFSETS AND
;      FLAGS NEEDED TO WRITE OUT THE OBJECT CODE.  THESE
;      OFFSETS ARE USED FOR RELOCATING THE OBJECT CODE,
;      CONSTANTS AND SYMBOL DEFINITONS (IF NEEDED).
;
;
OFFSET:
;
  MOVE T0,STBASE ;GET BASE OF STORAGE
  SKIPE CGOFG ;CHECK IF WE ANT OBJECT THERE
  MOVEM T0,PGMOFF ;SAVE IF SO
;
  HRRZ T0,OBJPT ;LENGTH OF OBJECT
  MOVEM T0,CONOFF ;SAVE AS CONSTANT OFFSET
  SOS CONOFF ;MINUS ONE
  SKIPE PRGNM ;CHECK IF MAIN
  JRST OTPGM7 ;HANDLE IF NOT
  ADD T0,CADDN ;PLUS LENGTH OF CONSTANTS
  MOVEM T0,NVROFF ;SAVE AS NUM VAR OFFSET
  ADD T0,VADDN ;PLUS LENGTH OF NUM VARS
  MOVEM T0,SVROFF ;SAVE AS STR VAR OFFSET
  MOVEI T0,1 ;RELOCATE VARS
  MOVEM T0,TEMPB ;SAVE
  POPJ P,	;AND RETURN
;
 OTPGM7:
  HRLZI T0,15 ;REG 15
  MOVEM T0,NVROFF ;FOR NVR OFFSET
  ADD T0,VADDN ;OFFSET TO REG 15 FOR STRS
  MOVEM T0,SVROFF ;SAVE FOR STRING OFFSET
  SETZM TEMPB ;VARS NOT RELOCATABLE FOR SUB
  POPJ P, ;AND DONE
;
;
SUBTTL TERMINATION ROUTINES--ENDPTR
;
;   ENDPTR--THIS ROUTINE IS USED TO END THE POINTER LISTS
;      FOR NUMERIC OR STRING DATA.  IT MAKES THE ZERO AT
;      THE END OF THE LIST NOT RELOCATABLE.  IT PROBABLY
;      SHOULD BE REPLACED BY CODE TO RELOCATE THE LAST PTR
;      IN S.DAT (DATA STATEMENT RTN).
;
;
ENDPTR:
;
  MOVE T1,T0	;GET PTR TO LAST DATA PTR
  ADD T1,CONST	;RELOCATE
  HLLZS -1(T1)	;AND FIX UP LAST LINK
  SUBI T0,1 ;MINUS ONE FROM OFFSET
  IDIVI T0,14 ;DIVIDE OFFSET BY 12
  ADD T0,CRELOC ;TO QUOTIENT ADD BASE OF RELOC BYTES
  IMULI T1,3 ;REMAINDER TIMES 3
  LSH T1,44-6 ;TO POSITION FIELD
  SUB T0,T1 ;GET PROPER POINT (BYTE TALLY)
  MOVEI T1,0 ;NON-RELOCATABLE BYTE TYPE
  IDPB T1,T0 ;SAVE IT
  POPJ P, ;AND RETURN
;
;
SUBTTL TERMINATION ROUTINES--OTPRGM
;
;   OTPRGM--THIS ROUTINE TAKES THE OBJECT CODE AND THE CONSTANTS
;      WHICH HAVE BEEN COMPILED INTO CORE AND PUTS THEM INTO THE
;      .REL FILE (USING PUTWD) IN MACRO (LINK STANDARD) FORMAT.
;
;
OTPRGM:
;
  HRRZ T0,OBJPT ;LENGTH OF OBJECT
  ADD T0,CADDN ;PLUS LENGTH OF CONSTANTS
  HRRI R2,1(T0) ;PLUS ONE
  HRLI R2,1 ;TYPE BLOCK 1
  PUTWD ;SAVE
;
  MOVE T0,OBJCOD ;BASE OF OBJECT CODE
  HRLI T0,444400 ;CREATE TALLY
  MOVE T3,OBJTL ;END TALLY
  MOVEM T3,TEMPA ;SAVE
  MOVE T3,RELOCS ;TALLY TO RELOC BYTES
;
  MOVEI R2,0 ;FIRST WORD=BASE
  MOVEM R2,OTBUF+22 ;SAVE
  MOVEI T1,21 ;COUNT AFTER FIST WORD
  HRLZI T7,200000 ;RELOCATE THIS WORD
  MOVE T2,[POINT 2,T7,1] ;BYTE TALLY AFTER 1ST WORD
  JRST OTPRG1 ;AND SKIP
;
 OTPRG2:
  MOVEI T1,22 ;NEW BLOCK
  MOVE T2,[POINT 2,T7] ;START BYTE TALLY FOR RELOC
  SETZM T7 ;NO RELOCATION THUS FAR
;
 OTPRG1:
  ILDB T4,T0 ;GET OBJECT CODE WORD
  ILDB T5,T3 ;GET RELOC TYPE
  XCT OTPGTA(T5) ;RELOCATE ADDRESS
  XCT OTPGTB(T5) ;GET RELOCATION BIS FOR .REL
  IDPB T5,T2 ;SAVE RELOCATION BITS
  MOVEM T4,OTBUF(T1) ;SAVE WORD IN BUFFER
  SKIPE T5 ;SKIP IF NOT RELOCATABLE
  ADD T4,PGMOFF ;RELOCATE FOR OBJECT PLACEMENT IN CORE
    DPB T4,T0 ;RESAVE RELOCATED WORD
;
  CAMN T0,TEMPA ;CHECK IF DONE
  JRST OTPRG6 ;HANDLE IF SO
  SOJG T1,OTPRG1 ;IF MORE ROOM IN BLOCK LOOP
  PUSHJ P,OTBFR ;ELE WRITE OUT BUFFER
  JRST OTPRG2 ;AND CONTINUE
;
 OTPRG6:
  SOJG T1,.+3 ;CHECK IF DONE BLOCK AT SAME TIME AS DON OBJ
  PUSHJ P,OTBFR ;WRITE OUT BUFFER IF SO
  MOVEI T1,22 ;AN RESTORE COUNT
;
  MOVE T3,TEMPA ;GET END MARKER
  CAMN T3,CNSTK ;CHECK IF END OF CONSTS
  JRST OTPRG4 ;IF SO, THEN RETURN
;
  MOVE T0,CONST ;ELSE GET TALLY FOR CONSTS
  HRLI T0,444400 ;MAKE INTO FULL TALLY
  MOVE T3,CNSTK ;GET END TALLY
  MOVEM T3,TEMPA ;SAVE IT
  MOVE T3,CRELOC ;GET RELOC TALLY
  SKIPE CADDN ;CHECK IF ANY TO DO
  JRST OTPRG1 ;AND LOOP
;
 OTPRG4:
  CAIE T1,22 ;CHECK IF LEFTOVERS
  PUSHJ P,OTBFR ;WRITE OUT IF SO
  POPJ P, ;AND DONE
;
;
SUBTTL TERMINATION ROUTINES--OTPRGM--TABLES
;
;
;  OTPGTA--XCT'D TO RELOCATE T4 ADDRESS
;
OTPGTA:
  NOP ;ABS
  NOP ;PRGM
  ADD T4,NVROFF ;NUM VAR
  ADD T4,SVROFF ;STR VAR
  ADD T4,CONOFF ;CONSTANT
  PUSHJ P,OTPEXT ;HANDLE EXT
  BLOWUP		;NOT USED
  PUSHJ P,OTPMAT ;HANDLE MAT
;
;
;
;   OTPGTB--XCT'D TO GET PROPER RELOCATION BITS IN T5
;
OTPGTB:
  MOVEI T5,0 ;ABS
  MOVEI T5,1 ;PRGM
  MOVE T5,TEMPB ;NUM VAR
  MOVE T5,TEMPB ;STR VAR
  MOVEI T5,1 ;CONST
  MOVEI T5,1 ;EXT
  BLOWUP		;NOT USED
  MOVEI T5,1 ;MAT
;
;
SUBTTL TERMINATION ROUTNES--OTPRGM--OTBFR SUBROUTINE
;
;   OTBFR--THIS ROUTNE DUMPS THE CURRENT 18 WORD BUFFER FOR OTPRGM.
;      IT ASSMES T7 CONTAINS RELOCATION BITS AND T1 IS THE COUNT
;      N=18-(T1).
;
;
OTBFR:
;
  SKIPN BINJFN ;CHECK IF BINARY FILE
  POPJ P, ;IF NONE, JUST RETURN
;
  MOVE R2,T7 ;GET RELOC BITS
  PUTWD ;SAVE THEM
  SETZM T7 ;NO MORE RELOCATIN
;
  MOVEI T6,22-1 ;COUNTER
;
 OTBFR2:
  CAMGE T6,T1 ;CHECK IF DONE
  POPJ P, ;RETURN IF SO
  MOVE R2,OTBUF+1(T6) ;ELSE GET WORD
  PUTWD ;SAVE IN .REL FILE
  SOJA T6,OTBFR2 ;AND LOOP
;
;
SUBTTL TERMINATION ROUTINES--OTPRGM--OTPEXT SUBROUTINE
;
;   OTPEXT--THIS ROUTINE IS USED TO RELOACTE TE ADDRESS
;      IN T4 WHICH REFERS TO AN EXTERNAL SYMBOL.  IT CREATS A
;      LINKED GLOBAL LIST.
;
;
OTPEXT:
;
  TRNN T4,-1 ;CHECK IF END OF LINKED LIST
  MOVEI T5,0 ;DON'T RELOCATE IF SO
  POPJ P, ;AND DONE
;
;
SUBTTL TERMINATION ROUTINES--OTPRGM--OTPMAT SUBROUTINE
;
;   OTPMAT--THIS ROUTINE RELOCATES THE ADDRESS IN T4 WHICH IS
;     A REFERENCE TO A MATRIX/ARRAY.
;
;
OTPMAT:
;
  HRRZ R2,T4 ;GET ADDRESS
  ANDI R2,377777 ;MASK OUT STRING BIT
  MOVE R1,MATPTB(R2) ;GET CONST AREA LOC
  TLNE R1,MTGBL ;CHECK IF GLOBAL
    BLOWUP ;IT HAD BETTER NOT BE
  TRNE T4,400000 ;CHECK FOR STRING MAT
    JRST OTPMT1 ;HANDLE STRING
  MOVEI T5,2 ;NUMERIC--GET NUMERIC OFFSET TYPE
  HRR T4,MSYMTB(R2) ;GET OFFSET TO USE FROM SYMBOL TABLE
  ADD T4,NVROFF ;RELOCATE IT
  POPJ P, ;AND RETURN
;
 OTPMT1:
  MOVEI T5,3 ;STRING OFFSET TYPE
  HLR T4,MSYMTB-32(R2) ;GET ADDRESS FROM SYMBOL TABLE
  ADD T4,SVROFF ;RELOCATE IT
  POPJ P, ;AND RETURN
;
;
SUBTTL TERMINATION ROUTINES--OTSYMS
;
;   OTSYMS--THIS ROUTNE CAUSES ALL THE NECESSARY SYMBOL DEFINITINS
;      TO BE WRITTEN TO THE .REL FILE IN THE PROPER FORM.
;
;
OTSYMS:
;
  SKIPN BINJFN ;CHECK IF BINARY FILE
    POPJ P,		;NO--RETURN
;
  MOVE R2,NUMLIN ;NUMBER OF INE NUMBERS
  ADD R2,NUMFCT ;PLUS FUNCTION ENTRYS
  ADD R2,NUMSUB ;PLUS SUB REFS
  ADDI R2,2 ;PLUS GENERAL GLOBALS
  SKIPE PRGNM ;CHECK IF MAIN PROGRAM OR SUB
  JRST OTSYM2 ;JUMP IF SUB
  ADD R2,NUMNVR ;NUM VARS 
  ADD R2,NUMSVR ;STRING VRS
  ADD R2,NUMMAT ;MATRIX AREAS
  ADD R2,NUMMAT ;TWO SYMBOLS PER MAT
  ADDI R2,2 ;NVR/SVR LOCS
;
 OTSYM2:
  LSH R2,1 ;EACH SYM IS 2 WORDS
  HRLI R2,2 ;TYPE OF BLOCK IS 2
  PUTWD ;SAVE BLOCK HEAD
;
  MOVEI T0,11 ;COUNTER (9 SYMS/18 WD BLOCK)
  MOVE T1,[BYTE (2)0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1] ;REL BTS
;
  PUSHJ P,OTSNVR ;NUMERIC VARS
  PUSHJ P,OTSSVR ;STRING VARS
  PUSHJ P,OTSMAT ;MATRICES
  PUSHJ P,OTSFCT ;FCTS
  PUSHJ P,OTSSUB ;GLOBAL SUBROUTINE SYMBOLS
  PUSHJ P,OTSLIN ;LINE NUMBERS
  PUSHJ P,OTSSPL ;SPECIAL SYMBOLS
;
   POPJ P, ;AND DONE
;
;
SUBTTL TERMINATION ROUTINES--OTSYMS--OTSNVR SUBROUTINE
;
;   OTSNVR--THIS ROUTINE PRODUCES AND STORES ALL TE USED NUMERIC
;      VARIABLES
;
;
OTSNVR:
;
  SKIPE PRGNM ;CHECK IFMAIN PROGRAM
  POPJ P, ;IGNORE IF NOT
;
  MOVEI T2,32+414 ;TOP OF TABLE FOR US
;
 OTSNV2:
  SOJL T2,OTSNV1 ;NEXT VAR UNLESS DONE
  HRRZ T7,SYMTAB(T2) ;CHCK IF DEFINED
  TRZ T7,600000 ;GET RID OF INFO BITS
  JUMPE T7,OTSNV2 ;NO--LOOP
;
  ADD T7,NVROFF ;RELOCATE ADDRESS
  CAIL T2,32 ;CHECK IF SIMPLE NAME
  JRST .+3 ;JUMP IF NOT
  MOVEI T6,RDX..A(T2) ;GET NAME
  JRST OTSNV3 ;AND SKIP
;
  MOVEI T5,-32(T2) ;COMPLEX NAME--BREAK DOWN
  IDIVI T5,12 ;BY GETING QUOTIENT/REM
  ADDI T5,RDX..A ;FIRST LETTER
  IMULI T5,50 ;TIMES 50
  ADDI T6,RDX..0(T5) ;BOTH LETTERS
;
 OTSNV3:
  TLO T6,100000 ;SYMBOL TYPE LOCAL
  PUSHJ P,PUTSYM ;SAVE IT
  JRST OTSNV2 ;AND LOOP
;
 OTSNV1:
  POPJ P, ;AND RETURN
;
;
SUBTTL TERMINATION OUTNES--OTSYMS--OTSSVR SUBROUTINE
;
;   OTSSVR--THIS ROUTINE PRODUCES AND STORES ALL THE USED
;      STRING VARIABLES
;
;
OTSSVR:
;
  SKIPE PRGNM ;CHECK IF MAIN PROGRAM
  POPJ P, ;RETURN IF NOT
;
  MOVEI T2,32+414 ;TOP OF TABLE FOR US
;
 OTSSV2:
  SOJL T2,OTSSV1 ;NEXT VAR UNLESS DONE
  HLRZ T7,SYMTAB(T2) ;CHECK IF DEFINED
  JUMPE T7,OTSSV2 ;LOOP IF NOT
  TRZ T7,600000 ;GET RID OF INFO BITS
;
  ADD T7,SVROFF ;RELOCATE VALUE
  CAIL T2,32 ;CHCK IF SIMPLE NME
  JRST .+3 ;JUMP IF NOT
  MOVEI T6,RDX..A(T2) ;GET SINGLE LETTER NAME
  JRST OTSSV3 ;AND SKIP
;
  MOVEI T5,-32(T2) ;COMPLEX NAME--BREAK DOWN
  IDIVI T5,12 ;BY GETTING QUOTIENT/REM
  IMULI T5,50 ;FIRST LETTER TIMES 50
  ADDI T6,RDX..A*50+RDX..0(T5) ;GET NAME
;
 OTSSV3:
  IMULI T6,50 ;SAVE ROOM FOR $
  ADDI T6,RDXDOL ;ADD THE $
  TLO T6,100000 ;LOCAL SYMBOL
  PUSHJ P,PUTSYM ;SAVE IT
  JRST OTSSV2 ;AND LOOP
;
 OTSSV1:
  POPJ P, ;AND RETURN
;
;
SUBTTL TERMINATION ROUTINES--OTSYMS--OTSMAT SUBROUTINE
;
;   OTSMAT--THIS ROUTINE OUTPUTS TWO NAMES FOR EACH MATRIX USED,
;      THE DATA FOR IT AND THE ACTUAL LOC OF IT.
;
;
OTSMAT:
;
  SKIPE PRGNM ;CHECK IF MAIN PROGRAM
    POPJ P, ;RETURN IF NOT
  MOVEI T2,32+32 ;NUMBER OF ARRAYS TO LOOK AT
;
 OTSMT2:
  SOJL T2,OTSMT1 ;GET NXT UNLESS DONE
  SKIPN T7,MATPTB(T2) ;GET VALUE, CHECK IF DEFINED
  JRST OTSMT2 ;IF NOT DEFINED, GET NEXT
;
  HRRZS T7 ;ISOLATE VALUE
;
  CAIL T2,32 ;CHECK IF STRING/NUMERIC
  JRST OTSMT3 ;HANDLE STRING
;
  MOVEI T6,RDX..M*50*50+RDXDOT*50+RDX..A(T2) ;NAME
  HRRZ T5,MSYMTB(T2)	;GET VALUE FROM SYMBOL TABLE
  ADD T5,NVROFF ;NUMERIC OFFSET
  JRST OTSMT4 ;AND JUMP
;
 OTSMT3:
  MOVEI T6,RDX..A*50*50+RDXDOT*50+RDX..A-32(T2) ;NAME
  IMULI T6,50 ;TIMES 50 FOR EXTRA CHR
  ADDI T6,RDXDOL ;NAME>NAME$
  HLRZ T5,MSYMTB-32(T2)	;GET VALUE FROM SYMBOL TABLE
  ADD T5,SVROFF ;OFFSET VAL FOR TRING
;
 OTSMT4:
  ADD T7,NVROFF	;RELOCATE FOR NVR
  TLO T6,100000 ;LOCAL SMBOL
  PUSHJ P,PUTSYM ;SAVE IT
;
  MOVE T7,T5 ;GET VALUE
  TLZ T6,100000 ;TURN OFF LOCAL BIT
  IMULI T6,50 ;SAVE ROOM FOR ANOTHER CHR
  ADDI T6,RDXDOT ;ADD '.' TO NAME
  TLO T6,100000 ;MKE LOCAL SYMBOL
  PUSHJ P,PUTSYM ;SAVE SECOND SYMBOL
  JRST OTSMT2 ;AND LOOP
;
 OTSMT1:
  POPJ P, ;AND RETURN
;
;
SUBTTL TERMINATION ROUTINES--OTSYMS--OTSFCT SUBROUTINE
;
;   OTSFCT--THIS ROUTINE OUTPTS ONE OR TWO NAMES PRE USER FUNCTION
;      USED.  IF THE FUNCTION IS MULTI-LINE THE VARIABLE ADDRESS
;      IS ACCESSED AS <NAME>.
;
;
OTSFCT:
;
  MOVEI T2,64+64 ;LENGTH OF TABLES
;
 OTSFC2:
  SUBI T2,2 ;DEC COUNT TO GET NEXT ENTR
  JUMPL T2,OTSFC1 ;IF DONE, EXIT
  SKIPN UFCATB(T2) ;ELSE CHECK IF USED
  JRST OTSFC2 ;NOT USED--LOOP T NEXT
;
  MOVE T3,T2 ;GET NUMBER
  LSH T3,-1 ;DIVIDE BY TWO 
  CAIL T3,32 ;CHECK IF STRING
  JRST OTSFC3 ;HANDLE STRING
;
  MOVEI T6,RDX..F*50*50+RDX..N*50+RDX..A(T3) ;NAME
  JRST OTSFC4 ;AND JUMP
;
 OTSFC3:
  MOVEI T6,RDX..F*50*50+RDX..N*50+RDX..A-32(T3) ;NAME
  IMULI T6,50 ;SAVE ROOM FR ANOTHER CHR
  ADDI T6,RDXDOL ;ADD '$'
;
 OTSFC4:
  HRRZ T7,UFCATB+1(T2) ;GET RT ADDRESS
  TLO T6,100000 ;LOCAL SYMBOL
  PUSHJ P,PUTSYM ;SAVE IT
;
  JRST OTSFC2 ;JUMP IF NOT
;
 OTSFC1:
  POPJ P, ;AND RETURN WHEN DONE
;
;
SUBTTL TERMINATION ROUTINES--OTSSYM--OTSSUB SUBROUTINE
;
;   OTSSUB--OUTPUT ALL EXTERNAL SUBROUTINE REFERENECES
;
;
OTSSUB:
;
  SKIPN T2,NUMSUB ;CHECK IF THERE ARE ANY
  POPJ P, ;IF NOT, RETURN
;
  MOVEI T3,SUBTBL-SUBBLN ;INITIAL PTR
;
 OTSSB1:
  ADDI T3,SUBBLN ;GET TPR TO NEXT SUB BLK
  MOVE T7,SUBBTS(T3) ;CHECK IF USED
  TLNN T7,SBBUSD ;BY THIS PROGRAM
  JRST OTSSB1 ;NO--IGNORE
;
  HRRZ T7,SUBADD(T3) ;GET LINK ADDRESS
  EXCH T7,T3 ;GET SUB BLK PTR IN T7
  PUSHJ P,GETRNM ;GET NAME IN RDX 50
  MOVE T6,R2 ;GET NAME IN T6
  EXCH T7,T3 ;RESTORE BLK PTR TO T3
  TLZ T6,740000 ;DELETE EXCESS BITS
  TLO T6,600000 ;TYPE GLOBAL
  PUSHJ P,PUTSYM ;SAVE IT
  SOJG T2,OTSSB1 ;LOOP BACK IF MORE
;
  POPJ P, ;AND RETURN WHEN DONE
;
;
SUBTTL TERMINATION ROUTINES--OTSYMS--OTSLIN SUBROUTINE
;
;   OTSLIN--THIS ROUTINE OUTPUTS A SYMBOL 'LNNNNN' FOR EACH
;      LINE 'NNNNN' IN THE PROGRAM.
;
;
OTSLIN:
;
  HRRZ T2,LNNMS ;PTR TO LINE NUMBER TABLE
  SUBI T2,2 ;BELOW FIRST ENTRY
;
 OTSLN2:
  ADDI T2,2 ;NEXT LINE NUMBER
  CAML T2,LINETB ;CHECK I DONE
  POPJ P, ;RETURN IF SO
;
  MOVE T4,0(T2) ;GET NUMBER
  ANDI T4,377777 ;IGNORE FUNCTION BIT
  MOVEI T3,4 ;COUNTER
  MOVEI T6,RDX..L ;FIRST CHR
  MOVEI T7,4 ;ZERO-SURPRESS COUNTER
;
 OTSLN3:
  IDIV T4,[DEC 1,10,100,1000,10000](T3) ;NEXT DIGIT
  SKIPG T4 ;SKIP IF NON-ZERO DIGIT
  SOJG T7,OTSLN4 ;IF ZERO AND NOT LAST, SURPRESS
  MOVNI T7,1 ;NO MORE SURPRESSION
;
  IMULI T6,50 ;ROOM FOR ANOTHER CHR
  ADDI T6,RDX..0(T4) ;GET CHR
;
 OTSLN4:
  MOVE T4,T5 ;USE REMAINDER FOR NUMBER
  SOJGE T3,OTSLN3 ;AND LOOP UNTIL DONE
;
  HRRZ T7,1(T2) ;GET OBJ LOC
  TLO T6,100000 ;MAKE LOCAL SYMBOL
  PUSHJ P,PUTSYM ;SAVE IN .REL FILE
  JRST OTSLN2 ;AND LOOP
;
;
SUBTTL TERMINATION ROUTINES--OTSYMS--OTSSPL SUBROUTINE
;
;   OTSSPL--THIS ROUTINE OUTPUTS SYMBOLS THAT DEFINE CERTAIN
;      AREAS/LOCS IN PROGRAM (IE SPECIAL SYMBOLS)
;
;
OTSSPL:
;
  MOVE T7,CONOFF ;START OF CONSTANT AREA==CONST.
  ADDI T7,1		;PLUS ONE TO MAKE RIGHT
  MOVE T6,[RADIX50 10,CONST.]
  PUSHJ P,PUTSYM
;
  MOVE T6,[RADIX50 04,START.]	;DEFAULT START FOR MAIN PRGM
  SKIPN T7,PRGNM	;CHECK IF MAIN
    JRST .+3		;SKIP IF SO
  PUSHJ P,GETRNM	;IF NOT, THEN GET ACTUAL NAME
  TLO T6,040000		;MARK AS INTERNAL
  MOVE T7,ENTADD ;ENTRY OF MAIN==START.
  PUSHJ P,PUTSYM
;
  SKIPE PRGNM ;CHECK IF MAIN PROGRAM
  POPJ P, ;RETURN IF NOT
;
  MOVE T7,NVROFF ;START OF NUM VARS==NVRS.
  ADDI T7,1
  MOVE T6,[RADIX50 10,NVRS.]
  PUSHJ P,PUTSYM
;
  MOVE T7,SVROFF ;START OF STRING VARS==SVRS.
  ADDI T7,1
  MOVE T6,[RADIX50 10,SVRS.]
  PUSHJ P,PUTSYM
;
  POPJ P, ;AND RETURN
;
;
SUBTTL TERMINATION ROUTINES--OTSYMS--PUTSYM SUBROUTINE
;
;   PUTSYM--THIS ROUTINE STORES THE SYMBOL IN (T6,T7) IN THE
;      .REL FILE.  IT PUTS PROPER RELOCATION BITS ON AS NEEDED.
;
;
PUTSYM:
;
  SKIPN BINJFN ;CHECK IF THERE IS A BINARY FILE
  POPJ P, ;RETURN IF NOT
;
  CAIE T0,11 ;CHECK IF TIME FOR RELOC BITS
  JRST PTSYM1 ;NO--JUMP
  MOVE R2,T1 ;YES--GET BIS
  PUTWD ;AND SAVE
;
 PTSYM1:
  MOVE R2,T6 ;GET NAME
  PUTWD ;SAVE
  MOVE R2,T7 ;GET VAL
  PUTWD ;AND SAVE
  SOSG T0 ;DEC COUNT
  MOVEI T0,11 ;RESET WHEN BAD
;
  POPJ P, ;AND RTURN
;
;
SUBTTL TERMINATION ROUTINES--OTSTRT
;
;   OTSTRT--THIS ROUTINE GENERATES A START BLOCK IN THE .REL FILE
;      WITH THE PROPER ENTRY ADDRESS
;
;
OTSTRT:
;
  MOVE R2,ENTADD ;GET ENTRY ADDRESS
  ADD R2,PGMOFF ;RELOCATE
  SKIPN PRGNM ;CHECK IF MAIN PROGRAM
  MOVEM R2,MAIN. ;SAVE AS STARTING ADDRESS IF SO
;
  SKIPN BINJFN ;CHECK IF BINARY FILE EXISTS
  POPJ P, ;IF NOT, SKIP
;
  MOVE R2,[XWD 7,1] ;TYPE 7, LEN=1
  PUTWD ;SAVE
  HRLZI R2,200000 ;RELOCATE START ADD
  PUTWD ;SAVE
  MOVE R2,ENTADD ;GET ENTRY ADD REL
  PUTWD ;AND SAVE
;
  POPJ P, ;THEN RTUN
;
;
SUBTTL TERMINATION ROUTINES--OTENDB
;
;   OTENDB--THIS ROUTINE GENERATES AN END BOCK ON THE .REL FILE
;
;
OTENDB:
  SKIPN BINJFN ;IS THERE A BINARY FILE
  POPJ P, ;NO--RETURN
;
  MOVE R2,[XWD 5,2] ;TYPE = 5; LEN=2
  PUTWD ;SAVE
  HRLZI R2,200000 ;RELOATE FIST
  PUTWD ;SAVE
  MOVE R2,OBJPT ;LENGTH OF OBJECT
  ADD R2,CADDN ;PLUS CONSTANS
  ADDI R2,2 ;PLUS TWO
  SKIPE PRGNM	;CHECK IF MAIN PROGRAM
    JRST OTENB1		;JUMP IF NOT
  ADD R2,VADDN ;PLUS VARS NUM
  ADD R2,SADDN ;PLUS STRING VARS
  ADDI R2,1 ;PLUS ONE
;
 OTENB1:
  PUTWD ;AND SAVE
  MOVEI R2,0 ;NO ABS CODE
  PUTWD ;SAVE
;
  POPJ P, ;AND RETURN
;
;
;
SUBTTL TERMINATION ROUTINES--OTSBTB
;
;   OTSBTB--THIS ROUTINE WRITES OUT THE SUBROUTINE TABLES AS A PROGRAM
;      CALLED '.SUBTB'.  THIS CAN THEN BE USED BY THE COMPILER FOR
;      LOADING PRECOMPILED ROUTINES.
;
;
OTSBTB:
;
  MOVE R2,NSUBS		;CHECK IF THERE IS A SUB TABLE
  SKIPE NSUBS		;CHECK IF ANY SUBS
  SKIPN BINJFN		;AND BINARY FILE
    POPJ P,		;IF NOT, RETURN
;
  MOVE R2,[XWD 6,1]	;HEADER BLOCK
  PUTWD
  MOVEI R2,0
  PUTWD
  MOVE R2,[RADIX50 0,.SUBTB] ;NAME
  PUTWD
;
  MOVE R2,NSUBS		;NUMBER OF SUB BLOCKS
  IMULI R2,10		;LENGTH WRITTEN FOR EACH
  ADDI R2,1		;LOCATOR
  HRLI R2,1
  PUTWD
  MOVSI R2,200000	;RELOCATE ONLY ADDRESS
  PUTWD
  MOVEI R2,0
  PUTWD
  MOVEI T1,21		;COUNTER FOR RELOCATION
  MOVE T2,NSUBS		;COUNTER FOR SUBS
  MOVEI T3,SUBTBL	;PTR TO SUB TABLE
;
 OTSBT1:
  HLLZ R2,SUBBTS(T3)	;GET BITS WORD
  PUSHJ P,OTSBWD
  MOVEI T4,SUBNAM(T3)	;GET NAME/ARG TYPE PTR
  MOVEI T5,2+4		;COMBINED LENGTH
;
 OTSBT2:
  MOVE R2,0(T4)		;NEXT WORD OF NAME/ARG BITS
  PUSHJ P,OTSBWD	;SAVE
  AOS T4
  SOJG T5,OTSBT2	;WORK ON NEXT IF MORE
;
  MOVE R2,SUBPGD(T3)	;GET PRGM DATA AREA PTR
  SUB R2,SUBLOC(T3)	;GET RELATIVE
  HLL R2,SUBLEN(T3)	;ALONG WITH THE SUB LENGTH
  PUSHJ P,OTSBWD	;SAVE IT
;
  ADDI T3,SUBBLN	;NEXT SUB
  SOJG T2,OTSBT1	;LOOP IF MORE
;
  PUSHJ P,OTRQBK	;INSERT REQUIRES BLOCKS AS NEEDED
;
  MOVE R2,[XWD 5,2]	;END BLOCK
  PUTWD
  MOVSI R2,200000
  PUTWD
  MOVE R2,NSUBS
  IMULI R2,10
  PUTWD			;LAST LOC PTR
  MOVEI R2,0
  PUTWD
;
  POPJ P,		;AND RETURN
;
;
SUBTTL TERMINATION ROUTINES--OTRQBK
;
;   OTRQBK--THIS ROUTINE WRITES OUT REQUIRES BLOCKS FOR ALL LIBRARYS
;      THAT NEED THEM.  THE USER HAS THE OPTION OF SETTING THE
;      USER FLAG 'NLIBRARY' WHICH WILL CAUSE COMPILATION OF ONLY
;      THE PROGRAM.  THESE BLOCKS CAUSE THE LOADER TO GET THE
;      LIBRARYS.
;
;
OTRQBK:
;
  SKIPN T7,NUMLRQ	;CHECK IF THERE ARE ANY
    POPJ P,		;IF NOT, JUST RETURN
;
  MOVE R2,T7		;GET NUMBER
  IMULI R2,3		;AT THREE WORDS A SHOT
  HRLI R2,16		;LOCK TYPE 16
  PUTWD			;SAVE IT
  MOVEI T1,0		;COUNTER FOR PUTTING IN RELOC WORDS
  MOVE T6,LIBLST	;POINTER TO FIRST LIBRARY
;
 ORQBK4:
  MOVE R2,LBBTS(T6)	;GET BITS FOR THIS LIBRARY
  TLNN R2,LBBRQ		;CHECK IF REQUIRED
    JRST ORQBK1		;NO--SKIP IT
  MOVEI T5,LBNAM(T6)	;YES--GET NAME POINTER
  HRLI T5,440700	;AS TALLY
  MOVSI T4,'DSK'	;GET DEFAULT DEVICE
  ILDB R2,T5	;GET FIRST CHR
  CAIE R2,"<"		;CHECK IF DIRECTORY
    JRST ORQBK2		;NO--SKIP
  ILDB R2,T5		;YES--GET FIRST CHR
  PUSHJ P,ORQSIX	;CONVERT TO SIX BIT
  ILDB R2,T5		;GET FIRST CHAR OF NAME
;
  CAMN T0,['SUBSYS']	;CHECK FOR SYSTEM FILE
    JRST ORQBK3		;YES--USE SYS:
  ERR E.RQN1		;ELSE ERROR
  SKIPA			;USE USER DIRECTORY
;
 ORQBK3:
  MOVSI T4,'SYS'	;SYS: DEVICE
;
 ORQBK2:
  PUSHJ P,ORQSIX	;CONVERT NAME TO SIXBIT
  MOVE R2,T0		;NAME TO R2
  PUSHJ P,OTSBWD	;SAVE 
  MOVEI R2,0		;NO DIRECTORY
  PUSHJ P,OTSBWD	;SAVE
  MOVE R2,T4		;DEVICE
  PUSHJ P,OTSBWD	;SAVE
;
  SOSG T7		;DECREMENT COUNT OF REQUIRED LIBRARYS
    POPJ P,		;RETURN IF DONE
;
 ORQBK1:
  HRRZ T6,0(T6)		;ELSE GET PTR TO NEXT LIBRARY
  JUMPN T6,ORQBK4	;CHECK IT
  BLOWUP		;COUNT OFF??
;
;
SUBTTL TERMINATION SUBROUTINES--ORQSIX
;
;   ORQSIX--THIS ROUTINE IS USED SOLELY BY OTRQBK TO CONVERT ASCII
;      NAMES TO SIXBIT FOR OUTPUT TO THE LOADER.
;
;
ORQSIX:
  MOVEI T0,0		;CLEAR RESULTS WORD
  MOVE R1,[POINT 6,T0]	;GET POINTER TO IT
;
 ORSIX1:
  TRZ R2,40		;CONVERT CHR
  TRNE R2,100
  TRC R2,140
  IDPB R2,R1		;AND SAVE SIXBIT FORM
;
  ILDB R2,T5		;GET NEXT CHR
  CAIE R2,"."		;CHECK FOR END OF NAME
  CAIN R2,">"		;OR END OF DIRECTORY
    POPJ P,		;DONE IF SO
  TRNN T0,77		;CHECK IF MORE ROOM
    JRST ORSIX1		;IF SO, LOOP
  ERR E.RQN2		;ELSE ERROR
;
 ORSIX2:
  ILDB R2,T5		;AND IGNORE THE REST
  CAIE R2,"."
  CAIN R2,">"
    POPJ P,
  JRST ORSIX2
;
;
SUBTTL TERMINATION ROUTINES--OTSBTB--OTSBWD SUBROUTINE
;
;   OTSBWD--THIS ROUTINE WRITES OUT THE WORD IN R2 TO THE BINARY 
;      FILE, INSERTING NULL RELOCATION WORDS AS NEEDED.
;
;
OTSBWD:
;
  SOJGE T1,OTSBW1	;CHECK IF READY FOR RLC WORD
  PUSH P,R2		;IF SO, SAVE R2
  MOVEI R2,0
  PUTWD			;SAVE DUMMY WORD
  POP P,R2		;RESTORE R2
  MOVEI T1,21		;RESTORE COUNTER
;
 OTSBW1:
  PUTWD			;SAVE DATUM
  POPJ P,		;AND RETURN
;
;
SUBTTL TERMINATION ROUTINES--OTCORE
;
;   OTCORE--THIS ROUTINE IS USED TO POSITION THE RELOCATED
;      OBJECT CODE AND CONSTANTS IN CORE FOR A COMPILE 
;      AND GO TYPE OPERATION.  IT MOVES THEM DOWN AND THE
;      SAVES SPACE FOR VARIABLES (WHICH IS CLEARED).
;
;
OTCORE:
;
  PUSHJ P,SAVSUB	;SAVE INFO ABOUT THE SUB IN SUB TABLE
;
  SKIPN CGOFG ;CHECK IF COMPILE AND GO
  POPJ P, ;IF NOT, THEN JUST RETURN
;
  HRL T0,OBJCOD ;MOVE FROM OBJECT CODE AREA
  HRR T0,STBASE ;TO BOTTOM OF FREE STORAGE
  HRRZ T1,STBASE ;NEW BOTTOM
  ADD T1,OBJPT ;PLUS LENGTH==TOP OF NEW AREA
  BLT T0,0(T1) ;MOVE THE OBJECT CODE
;
  HRL T0,CONST ;WHERE CONSTS ARE
  HRRI T0,0(T1) ;WHERE WE WANT THEM TO BE
  ADD T1,CADDN ;NEW TOP OF USED CORE
  BLT T0,0(T1) ;MOVE CONSTS
;
  SKIPE PRGNM		;CHECK IF MAIN PROGRAM
    JRST OTCOR1		;IF NOT, SKIP ZEROING VARIABLES
  MOVE T2,VADDN ;SIZE OF VARIABLE AREA
  ADD T2,SADDN ;FOR VARS AND STRS
  JUMPE T2,OTCOR1 ;NONE--JUMP
  HRLI T0,0(T1) ;FROM START OF AREA
  HRRI T0,1(T1) ;INTO AREA
  ADD T1,T2 ;NEW END OF AREA
  BLT T0,0(T1) ;CLEAR THE VAR AREA
;
 OTCOR1:
  MOVE T0,STBASE ;GET NEW LOC OF OBJECT CODE
  MOVEM T0,OBJCOD ;SAVE AS OBJECT CODE BASE
  ADDI T1,1 ;REAL TOP OF CORE
  MOVEM T1,STBASE ;SAVE AS BASE
  PUSHJ P,LNKSUB ;LINK UP SUB CALLS
  SKIPL RPGFG		;CHECK FOR ONE-LINE COMPILATION--SKIP IF SO
  PUSHJ P,STINIT ;AND SET UP STORAGE AGAIN WITH WHAT'S LEFT
  POPJ P, ;THEN DONE
;
;
SUBTTL TERMINATION ROUTINES--.PTWD
;
;   .PTWD--THIS ROUTINE IS CALLD BY 'PUTWD' MACRO AND IS USED TO
;      PLACE (R2) INTO THE BNARY FILE.
;
;
.PTWD:
;
  MOVE R1,BINJFN ;GET JFN OF BINARY FILE
  BOUT ;PLACE IN FILE
  POPJ P, ;AND REURN
;
;
SUBTTL TERMINATION ROUTINES--EONELN
;
;   EONELN--THIS ROUTINE IS CALLED AT THE END OF COMPILING THE ONE
;      LINE ALLOWED FOR ONE LINE COMPILATIONS FROM THE DEBUFFER.
;      IT SETS UP THE COMPILED CODE IN THE SOURCE PAGE (677)
;      AND RETURNS TO THE DEBUGGER.
;
;
EONELN:
;
  PUSHJ P,CLEAN		;CHECK FOR UNDEF FCTS
  SKIPE ERCNT		;CHECK IF ANY ERRORS
    JRST ERONLN		;HANDLE IF SO
  MOVEI R2,R.DBLX	;GET RTP ROUTINE TO ENTER AT END OF EXEC
  HRLI R2,(JRST 0)	;GET JUMP TO DEBUGGER
  SVWEX			;SAVE AS EXTERNAL REF
;
  MOVEI R2,SRCBUF	;SOURCE BUFFER IS DESTINATION
  MOVEM R2,STBASE
  SETOM R2,PRGNM	;NO NAME AS FLAG
  PUSHJ P,OFFSET	;COMPUTE OFFSETS
  PUSHJ P,OTPRGM	;RELOCATE OBJECT AND CONSTS
  PUSHJ P,OTSYMS	;LINK SYMBOLS
  PUSHJ P,OTCORE	;MOVE CODE TO DESTINATION
  AOS ONELIN		;MARK AS SUCCESSFUL
;
 ERONLN:
  MOVEI R1,400000	;CURRENT FORK
  DIR			;DISABLE INTERRUPTS
  JRST @ONELIN		;AND EXIT TO CALLER
;
;
  SUBTTL STORAGE MANAGEMENT--MVLIN (MRULN,MRLIN)
;
;   MVLIN--THIS ROUTINE MOVES THE LINE NUMBER TABLE UP IN CORE BY
;      (MOVSIZ).  THIS ALLOWS MORE SPACE FOR BOTH LINE NUMBERS
;      ALREADY DEFINED (MRLIN) AND THOSE UNDEFINED (MRULN).
;
;
 MRULN:;               ;NEED MORE SPACE FOR UNDEFINED LINE NUMBERS
;
 MRLIN:;               ;NEED MORE SPACE FOR DEFINED LINE NUMBERS
;
 MVLIN:
;
    PUSH   P,T0        ;SAVE REGS T0,T1,T2
    PUSH   P,T1
    PUSH   P,T2
;
    MOVE   T0,LNNMS    ;GET BOTTOM OF AREA
    MOVE   T1,LINETB   ;GET TOP
    MOVE   T2,T1       ;SEE IF MOVED AREA WILL FIT
    ADD    T2,MOVSIZ   ;BELOW THE CONSTANTS
    CAML   T2,CRELOC    ;IN CORE
    PUSHJ  P,MVCRL     ;IF NOT, MOVE CONSTANTS AS WELL
;
    PUSHJ  P,MOVSTO    ;DO THE MOVE
;
  MOVE T0,MOVSIZ ;SIZE OF MOVE
  ADDM T0,LNNMS ;UPDATE PTRS
  ADDM T0,LINETB
;
;
    POP    P,T2        ;RESTORE REGS
    POP    P,T1
    POP    P,T0
;
    POPJ   P,          ;AND RETURN
;
;
;
SUBTTL STORAGE MANAGEMENT--MVCRL
;
;   MVCRL--THIS ROUTINE MOVE THE CONSTANT AREA RELOCATION BYTE
;      AREA UP IN CORE BY (MOVSIZ).  THIS ALLOWS MORE SPACE
;      FOR LINE NUMBERS.
;
;
MVCRL:
;
  PUSH P,T0 ;SAVE REGS T0,T1,T2
  PUSH P,T1
  PUSH P,T2
;
  MOVE T0,CRELOC ;GET BOTTOM OF AREA
  HRRZ T1,CRLCPT ;GET TOP
  ADDI T1,1 ;PLUS ONE
;
  MOVE T2,T1 ;GET TOP
  ADDI T2,MOVSIZ ;NEW TOP
  CAML T2,CONST ;WILL IT FIT
  PUSHJ P,MVCON ;NO--MOVE CONSTANT AREA
;
  PUSHJ P,MOVSTO ;DO THE MOVE
;
  MOVE T0,MOVSIZ ;SIZE O MOVE
  ADDM T0,CRELOC ;UPDATE PTRS
  ADDM T0,CRLCPT
  IMULI T0,14 ;TIME 12 FOR LENGTH
  ADDM T0,CRLCNT ;UPDATE LENGTH REMAINING
;
  POP P,T2 ;RESTOREREGS
  POP P,T1
  POP P,T0
;
  POPJ P, ;AND RETURN
;
;
  SUBTTL STORAGE MANAGEMENT--MVCON (MRCLR)
;
;   MVCON--THIS ROUTINE MOVES TE CONSTANTS UP IN CORE BY
;      (MOVSIZ).  THIS ALLOWS MORE ROOM FOR THE RELOCATION
;      BYTES OF THE CONSTANT AREA
;
;
MRCRL: ;NEED MORE SPACE FOR CONSTANT RELOC BYTES
;
 MVCON:
;
    PUSH   P,T0        ;SAVE REGS T0,T1,T2
    PUSH   P,T1
    PUSH   P,T2
;
    MOVE   T0,CONST    ;BOTTOM OF CONSTS
    HRRZ   T1,CNSTK    ;TOP OF CONSTANTS
    ADDI   T1,1        ;MINUS ONE THAT IS
;
    MOVE   T2,T1       ;SEE IF EXPANDED AREA WILL FIT IN CORE
    ADD    T2,MOVSIZ   ;AFTER IT IS MOVED
    CAML   T2,RELOCS   ;BELOW RELOCATION BYTES
    PUSHJ  P,MVRLC     ;IF NOT MAKE ROOM
;
    PUSHJ  P,MOVSTO    ;MOVE THE CONSTANTS
;
  MOVE T0,MOVSIZ ;SIZE OF MOVE
  ADDM T0,CONST ;UPDATE PTRS
  ADDM T0,CNSTK ;FOR CONSTS
  ADDM T0,CNSTCT ;AND LNGTH AVAIL
  MOVN T0,MOVSIZ ;MINUS SIZE OF MOE
  IMULI T0,14 ;TIME 12 FOR ENGT
  ADDM T0,CRLCNT ;MORE SPACE FOR RELOC BYTES
;
    POP    P,T2        ;RESTORE REGS
    POP    P,T1
    POP    P,T0
;
    POPJ   P,          ;AND RETURN
;
;
;
  SUBTTL STORAGE MANAGEMENT--MVRLC (MRCON)
;
;   MVRLC--THIS ROUTINE MOVES THE RELOCATION BYTES UP
;      IN CORE BY (MOVSIZ).  THIS ALLOWS MORE ROOM FOR CONSTANTS
;      (MRCON).
;
;
 MRCON:;               ;NEED MORE ROOM FOR CONSTANTS
;
 MVRLC:
;
    PUSH   P,T0        ;SAVE REGS T0,T1,T2
    PUSH   P,T1
    PUSH   P,T2
;
    MOVE   T0,RELOCS   ;BOTTOM OF AREA
    HRRZ   T1,RLCPT    ;TOP MINUS ONE
    ADDI   T1,1        ;REAL TOP
;
    MOVE   T2,T1       ;CHECK IF AREA
    ADD    T2,MOVSIZ   ;AFTER BEING MOVED
    CAML   T2,OBJCOD   ;WILL FIT BELOW OBJECT CODE
    PUSHJ  P,MVOBJ     ;AND IF NOT, MAKE ROOM FOR IT
;
    PUSHJ  P,MOVSTO    ;MOVE THE RELOC BYTES
;
  MOVE T0,MOVSIZ ;SIZE OF MOVE
  ADDM T0,RELOCS ;UPDATE PTRS
  ADDM T0,RLCPT ;FOR RELOCS
  IMULI T0,14 ;GET LENGTH DECREASE
  ADDM T0,RLCNT ;UPDATE LEN AVAIL
  MOVN T0,MOVSIZ ;NEG SIZE
  ADDM T0,CNSTCT ;MORE CONSTANT SPACE
;
    POP    P,T2        ;RESTORE REGS
    POP    P,T1
    POP    P,T0
;
    POPJ   P,          ;AND RETURN
;
;
;
  SUBTTL STORAGE MANAGEMENT--MVOBJ (MRRLC)
;
;   MVOBJ--THIS ROUTINE MOVES THE OBJECT CODE UP IN CORE BY
;      (MOVSIZ).  THIS ALLOWS MORE ROOM FOR RELOCATION BYTES
;      (MRRLC).
;
;
 MRRLC:;               ;MORE ROOM NEEDED FOR RELOCATION BYTES
;
 MVOBJ:
;
    PUSH   P,T0        ;SAVE REGS T0,T1,T2
    PUSH   P,T1
    PUSH   P,T2
;
    MOVE   T0,OBJCOD   ;BOTTOM OR AREA
    HRRZ   T1,OBJTL    ;TOP OF AREA
    ADDI   T1,1        ;PLUS ONE
;
    PUSHJ  P,MOVSTO    ;MOVE THE AREA
;
  MOVE T0,MOVSIZ ;SIZE OF MOVE
  ADDM T0,OBJCOD ;UPDATE PTRS
  ADDM T0,OBJTL ;TO OBJECT CODE
  ADDM T0,OBJCNT ;LESS ROOM AVAIL
  MOVN T0,MOVSIZ ;MINUS IZE OF MOVE
  IMULI T0,14 ;TIMES BYTES/WD
  ADDM T0,RLCNT ;MORE ROOM AVAIL FOR RELOC BITS
;
    POP    P,T2
    POP    P,T1        ;RESTORE THE REGS
    POP    P,T0
;
    POPJ   P,          ;AND RETURN
;
;
;
 MROBJ:
    ERR    E.PTBG      ;CAN'T GET MORE ROOM FOR OBJECT CODE
;
;
;
  SUBTTL STORAGE MANAGEMENT--MOVSTO
;
;   MOVSTO--THIS ROUTINE IS USED TO MOVE A BLOCK OF STORAGE
;      POINTED TO BY T0 (BOTTOM) AND T1 (TOP+1) UP IN CORE
;      BY (MOVSIZ).
;
;
 MOVSTO:
;
    PUSH   P,T3        ;SAVE REGS T3,T4
    PUSH   P,T4
    SKIPGE RPGFG	;CHECK IF ONE-LINE COMPILATION
    ERR E.OLTL		;ERROR IF WE GET HERE IN THAT CASE
;
    MOVE   T2,T1       ;GET LENGTH OF AREA
    SUB    T2,T0       ;TO BE MOVED
;
 MOVST2:
    CAMG   T2,MOVSIZ   ;CHECK IF >1 BLT NEEDED
    JRST   MVSTO1      ;NO--FINISH UP
    MOVE T3,T1 ;GET TOP OF AREA
    SUB T3,MOVSIZ ;START OF MOVE
    HRLS T3 ;SAVE AS SUCH
    HRR T3,T1 ;END OF MOVED BLOCK
    MOVE   T4,MOVSIZ   ;GET BLT WORD
    ADDI   T4,-1(T1)   ;TOP OF MOVE AREA
    SUB    T2,MOVSIZ   ;REMAINING SIZE
    SUB T1,MOVSIZ ;GET NEW END PTR
    BLT    T3,0(T4)    ;ISSUE BLT
    JRST   MOVST2      ;AND LOOP FOR NEXT BLOCK
;
 MVSTO1:
    HRLS   T0          ;FINAL MOE--GET BLT WORD
    ADD    T0,MOVSIZ   ;FROM AND TO
    HRRZ T1,T0 ;GET BASE OF AREA
    ADD T1,T2 ;GET END OF MOVING BLOCK
    BLT    T0,-1(T1)   ;AND MOVE THE FINAL BLOK
;
    POP    P,T4        ;RESTORE REGS
    POP    P,T3
;
    POPJ   P,          ;AND RETURN
;
;
;
  SUBTTL DATA SAVING ROUTINES--.SVWD
;
;   .SVWD--THIS ROUTINE IS INVOKED BY VARIOUS SAVE WORD
;      MACROS.  IT IS CALLED WITH THE RELOCATION TYPE IN R1
;      AND THE WORD TO BE PLACED IN THE OBJECT CODE IN R2.
;
;
 .SVWD:
;
    IDPB   R1,RLCPT    ;SAVE RELOCATION BYTE
    AOSL   RLCNT       ;BUMP COUNT OF SPACE FO RLC BYTES
    PUSHJ  P,MRRLC     ;MORE SPACE NEEDED
;
    IDPB   R2,OBJTL    ;SAVE THE WORD AS WELL
    AOS    R2,OBJPT    ;GET LOC AND BUMP PTR
    AOSL   OBJCNT      ;BUMP COUNT OF ROOM LEFT
    PUSHJ  P,MROBJ     ;MORE OBJECT CODE SPACE NEEDED
;
    POPJ   P,          ;AND RETURN
;
;
;
SUBTTL DATA SAVING ROUTINES--.SVCL
;
;   .SVCL--THIS ROUTINE SAVES A CLL TO A SUB/ UNDEF FCT AS
;      A LINKED LIST REFERENCE.
;
;
;
.SVCL:
;
  MOVE R1,OBJPT ;GET PTR TO OBJECT CODE
  SKIPE SUBADD(R2) ;CHECK IF SYMBOL USED YET
  JRST SVCL1 ;HANDLE IF SO
;
  HRLM R1,SUBADD(R2) ;SAVE LIST PTR
  JRST SVCL2 ;AND SKIP
;
 SVCL1:
  PUSH P,T0 ;SAVE T0
  MOVE T0,SUBADD(R2) ;GET LAST LINK
  ADD T0,OBJCOD ;RELOCATE
  HRRM R1,0(T0) ;SAVE NEW VALUE IN IT
  POP P,T0 ;RESTORE T0
;
 SVCL2:
  HRRM R1,SUBADD(R2) ;SAVE LOC OF CURRENT LINK
  HRRI R2,0 ;CLEAR ADDRESS
  MOVEI R1,5 ;TYPE OF EXTERNAL
  JRST .SVWD ;AND SAVE IT
;
;
SUBTTL DATA SAVING ROUTINES--.SVFC
;
;   .SVFC--THIS ROUTINE SAVES A REFERENCE TO A USER FUNCTION. 
;      IF THE FUNCTION HAS ALREADY BEEN DEFINED, THEN THE ADDRESS
;      OF ITS DEFINITION IS USED.  IF NOT, IT IS LINKED ON ITS
;      UNDEFINED LIST FOR FUTURE LINKING AND FOR ERROR MESSAGES.
;
;
.SVFC:
  HRRZ R1,1(R2)		;CHECK IF DEFINED YET
  JUMPN R1,SVFC1	;HANDLE IF SO
;
  HRRZI R1,-UFCATB(R2)	;GET NUMBER*2
  LSH R1,-1		;GET FUNCTION NUMBER
  HRRI R2,UFCLTB-1(R1)	;DUMMY EXTERNAL PTR
  JRST .SVCL		;TREAT LIKE LINKED EXTERNAL
;
 SVFC1:
  HRR R2,R1		;GET REAL ADDRESS
  MOVEI R1,1		;RELOC OF PRGM
  SKIPL RPGFG		;CHECK IF ONE LINE COMPILATION
  JRST .SVWD		;AND SAVE THE RESULT
  ADD R2,PRGBAS		;IF ONE, LINE RELOCATE TO ABSOLUTE NOW
  MOVEI R1,0		;TYPE OF ABSOLUTE
  JRST .SVWD		;AND THEN SAVE IT
;
;
SUBTTL DATA SAVING ROUTINES--.SVEX
;
;   .SVEX--THIS ROUTINE SAVES A WORD REFERING TO AN EXTERNAL
;      IN THE RTP.  IT IS MADE INTO AN INDIRECT REFERENCE VIA
;      THE TRASFER VECTOR ADDRESS OF THE ITEM.
;
;
.SVEX:
;
  AOS 1(R2)		;UPDATE USAGE COUNT
  HRR R2,2(R2)		;GET ACTUAL ADDRESS
  TLO R2,20		;SET ON INDIRECT BIT
  TRNN R2,-1		;CHECK IF DEFINED
    ERR E.UIMP		;ERROR IF NOT
  MOVEI R1,0		;ABSOLUTE ADDRESS
  JRST .SVWD		;AND SAVE IT
;
;
  SUBTTL DATA SAVING ROUTINES--SVCAL
;
;   SVCAL--THIS ROUTINE IS USED TO SAVE A RUN TIME ROUTINE CALL.  THE RTP
;      BLOCK POINTER (WD1=NAME, WD2=ADDRESS) IS IN R2 ON ENTRY.  THIS
;      ROUTINE ACTUALLY SAVES THE 'JSA 16,0' IN THE OBJECT CODE.
;
;
 SVCAL:
;
  MOVSI R1,CLBPJ ;CHECK IF WE SANT TO PUSHJ
  TDZE R1,0(R2) ;BY CHECKING BIT IN NAME
  TLO R2,(PUSHJ R.P,) ;CODE IF PUSHJ P,
  TLNE R1,CLBPJ ;CHECK AGAIN FOR JSA
  TLO R2,(JSA R.T,) ;CREATE CALL
  SVWEX ;SAVE AS EXTERNAL REF
  POPJ P, ;AND DONE
;
;
SUBTTL DATA SAVING ROUTINES--.SVCN
;
;   .SVCN--THIS ROUTINE IS CALLED TO SAVE A WORD IN THE CONSTANT
;      AREA.  THE WORD TO BE SAVED IS IN R2 ON ENTRY AND ITS
;      RELOCATION TYPE IS IN R1.  THIS ROUTINE DOES NOT UPDATE
;      'CADDN' WHICH MUST BE DONE BY CALLER.  SEE 'SVCON'
;      AD 'XSVCON' MACROS
;
;
.SVCN:
;
  IDPB R1,CRLCPT ;SAVE RELOC BYTE
  AOSL CRLCNT ;CHECK IF NEED MORE ROOM
  PUSHJ P,MRCRL ;GET IT IF SO
;
  IDPB R2,CNSTK ;SAVE CONSTANT
  AOSL CNSTCT ;CHECK IF IT FITS
  PUSHJ P,MRCON ;GET MORE ROOM IF NOT
;
  POPJ P, ;AND RETURN
;
;
SUBTTL DATA SAAVING ROUTINES--FNCNST
;
;   FNCNST--THIS ROUTINE SAVES THE CONSTANT IN R2 AS ABSOLUTE.
;      IF THERE ALREADY IS AN IDENTICAL CONSTANT, IT IS USED.
;
;
FNCNST:
;
  PUSH P,T0 ;SAVE T0
;
  MOVE T0,CADDN ;NUMBER OF CONSTANTS THUS FAR
  MOVE R1,CONST ;BASE OF AREA
;
 FNCNS3:
  SOJL T0,FNCNS1 ;NO MATCH--JUMP
  CAMN R2,0(R1) ;CHECK FOR MATCH
  JRST FNCNS2 ;YES--HANDLE
  AOJA R1,FNCNS3 ;ELSE TRY AGAIN
;
 FNCNS1:
  SVCON (R2) ;SAVE CONSTANT IF NO MATCH FOUND
  POP P,T0 ;AND RESTORE T0
  POPJ P, ;AND RETURN
;
 FNCNS2:
  SUB R1,CONST ;UNRELOCATE PTR TO CONST
  MOVEI R2,1(R1) ;AND GET GOOD ADDRESS FOR CONST
  POP P,T0 ;AND RESTORE T0
  POPJ P, ;RETURN USING OLD CONST
;
;
  SUBTTL STORAGE ALLOCATION ROUTINES--ALMAT
;
;
;   ALMAT--THIS ROUTINE ALLOCATES A VARIABLE FOR A MATRIX.  THIS
;      SHOULD INCLUDE A SYMBOL TABLE ENTRY AND A CONSTANT AREA BLOCK
;      FOR THE DIMENSIONS OF THE MATRIX.
;
;
 ALMAT:
    TLNE   T0,VTSTR    ;CHECK IF STRING
    ADDI   T0,32       ;CHANGE LOC IF SO
    HRRZ   R1,MATPTB(T0) ;NUMERIC--CHECK IF ALLOCATED
    JUMPN  R1,ALMT3    ;YES--HANDLE
    SKIPGE RPGFG ;CHECK FOR ONE LINE COMPILATION
    ERR E.ALC ;ILLEGAL TO BE HERE IF SO
    AOS    R1,VADDN    ;ELSE ALLOCATE 3 WDS IN NUM VAR AREA
    HRRM   R1,MATPTB(T0) ;SAVE PTR
    AOS    NUMMAT      ;ONE MORE MATRIX
;
    AOS VADDN ;SAVE SPACE FOR DIMS
    AOS VADDN
;
 ALMT3:
    MOVE   R1,XNSBCS   ;CHECK IF # DIMS SPECD
    JUMPE  R1,ALMT5   ;NO--RETURN
    SKIPGE RPGFG ;CHECK IF ONE LINE
    JRST ALMT4 ;SPECIAL CHECK NEEDED IF SO
    SKIPN  R2,MATDTB(T0) ;CHECK IF DIMS SPECD
    JRST   ALMT2       ;NO--FIRST TIME
    SKIPN SBCERF ;MUST WE FORCE SUBSCRIPT
    JRST ALMT5 ;NO--THEN RETURN WITHOUT CHECKING
    CAIE   R1,1        ;CHECK FOR 1D
    JRST   .+3         ;SKIP IF NOT
    JUMPL  R2,ALMT5   ;RETURN IF OK
    ERR    E.NSBC      ;ELSE ERROR
    JUMPGE R2,ALMT5   ;RETURN IF OK 2D
    ERR    E.NSBC      ;ELSE ERROR
;
 ALMT2:
    HRROI  R2,12       ;1000 INITIAL
    CAIE   R1,1        ;CHECK IF 2D
    HRLI   R2,12       ;IF SO, 10010
    MOVEM  R2,MATDTB(T0) ;SAVE DIMS
;
 ALMT5:
    POPJ P, ;AND RETURN
;
 ALMT4:
  SKIPN SBCERF		;CHECK IF SUBSCRIPTS FORCED
    JRST ALMT5		;IF NOT, THEN JUST RETURN
  MOVE R2,MATPTB(T0)	;GET MAT WORD W/ BITS
  CAIE R1,1		;CHECK IF 1D
    TLC R2,MTVCT	;FLIP BIT IF NOT
  TLNN R2,MTVCT	;NOW CHECK BIT
    ERR E.NSBC		;MUST BE CONSISTENT
  JRST ALMT5		;AND DONE
;
;
;
  SUBTTL STORAGE ALLOCATION ROUTINES--ALVAR
;
;   ALVAR--THIS ROUTINE ALLOCATES A VARIABLE.  THIS INVOLVES
;      SETTING UP A SYMBOL TABLE ADDRESS AND LINKING THE VARIABLE ON
;      THE LIST OF DEFINED VARIABLES IN THE SYMBOL TABLE.
;
;
 ALVAR:
    TLNE   T0,VTSTR    ;CHECK IF STRING
    JRST   ALSVR       ;HANDLE IF SO
;
 ALNVR:
    HRRZ   R1,SYMTAB(T0) ;GET NUMERIC SYM VAL
    JUMPN  R1,ALVR3    ;DEFINED--HANDLE
    SKIPGE RPGFG ;CHECK FOR ONE LINE COMPILATION
    ERR E.ALC ;CAN'T HAVE NEW VARIABLES IF SO
    AOS    R1,VADDN    ;ELSE GET NEW VALUE
    HRRM   R1,SYMTAB(T0) ;AND SAVE
    AOS    NUMNVR      ;ONE MORE NUM VAR
;
 ALVR3:
    JRST   0(T)        ;AND RETURN
;
;
 ALSVR:
    HLRZ   R1,SYMTAB(T0) ;STRING--GET SYM LOC
    JUMPN  R1,ALVR4    ;ALREADY DEFINED--USE OLD DEF
    SKIPGE RPGFG ;CHECK FOR ONE LINE COMPILATION
    ERR E.ALC ;CAN'T HAVE NEW VARIABLES IF SO
    AOS    R1,SADDN    ;ELE MAKE A NEW ONE
    HRLM   R1,SYMTAB(T0) ;AND SAVE IT
    AOS    NUMSVR      ;ONE MORE STR VAR
;
 ALVR4:
    JRST   0(T)        ;AND RETURN
;
;
    PRINTX *****START OF BAS10*****
;
;
SUBTTL LINE SCAN ROUTINES--STFIL
;
;   STFIL--THIS ROUTINE STARTS PROCESSING A SOURCE FILE.
;      IT BRINGS THE FIRST PAGE OF THE FILE INTO CORE
;      AND SETS UP ITS POINTERS.  ALSO, THE LENGTH OF THE
;      FILE, ETC. ARE RECORDED FOR LATER USE.
;
;
STFIL:
;
  PUSH P,R1 ;SAVE R1
  PUSH P,R2 ;AND R2
;
  HRLZ R1,SRCJFN ;GET PAGE HANDLE FOR FIRST PAGE
  SUBI R1,1 ;MINUS ONE FOR START
  MOVEM R1,IFLPG ;SAVE IT
;
  MOVE R1,SRCJFN ;GET JFN
  MOVNI R2,1 ;REQUEST END OF FILE
  SFPTR ;SET FILE PTR THERE
    BLOWUP ;MUST BE ABLE TO
  RFPTR ;NOW READ WHAT THAT POINTER IS
    BLOWUP ;MUST BE ABLE TO
  MOVEM R2,IFLLFT ;SAVE AS AMOUNT LEFT IN FILE
;
  SETZM IFLCNT ;NOTHING IN BUFFER PAGE
  SETZM IFLTL ;NO TALLY
  SETZM PAGECT ;PAGE NUMBER CLEARED
  SETZM LSTLN ;NO LAST LINE RELEVANT
;
  POP P,R2 ;RESTORE REGS
  POP P,R1
  POPJ P, ;AND RETURN
;
;
SUBTTL LINE SCAN ROUTINES--NXFIL
;
;   NXFIL--THIS ROUTINE IS CALLED AT THE END OF THE CURRENT
;      FILE.  ITS JOB IS EITHER TO STOP COMPILING OR TO
;      CONTINUE WITH THE NEXT FILE.
;
;
NXFIL:
;
  SKIPL PRGNM ;MUST BE INBETWEEN PROGRAMS
    ERR E.EOF ;ELSE ERROR
  SKIPGE RPGFG		;MAKE SURE ITS FROM BEXC
    BLOWUP		;BETTER NOT GET HERE ON ONE-LINE
  PUSHJ P,ENDSRC	;END OF SOURCE FILE
    JRST END		;NO--END OF COMPILATION
  JRST STFIL		;YES--NEXT FILE
;
;
SUBTTL LINE SCAN ROUTINES--NXPAG
;
;   NXPAG--THIS ROUTINE IS CALLED WHEN THE CURRENT BUFFER PAGE
;      RUNS OUT OF DATA. ITS JOB IS TO GET THE NEXT PAGE IN THE
;      CURRENT FILE OR THE FIRST PAGE IN THE NEXT FILE, ETC.
;
;
NXPAG:
;
  SKIPN IFLLFT ;CHECK IF NEW FILE NEEDED
  PUSHJ P,NXFIL ;GET IT IF SO
;
  PUSH P,R1 ;SAVE R1
  PUSH P,R2 ;AND R2
  PUSH P,R3 ;AND R3
;
  AOS R1,IFLPG ;NEXT PAGE
    SETZM CHNGFG	;NOT CHANGE
  HRRI R2,SRCPGN ;PAGE NUMBER IN OUR CORE USED FOR BUFFER
  HRLI R2,400000 ;OUR FORK
;
  HRLZI R3,100000 ;READ ACCESS WANTED
  CAME R1,R2 ;CHECK IF SAME AND DON'T MAP IF SO
  PMAP ;GET PAGE IN CORE
;
  TRNE R1,-1		;CHECK IF FIRST PAGE
    JRST NXPAG1		;IF NOT, SKIP
  SETZM IFLTYP		;ASSUME ASCII FILE
  HLRE R1,SRCBUF	;LOOK AT UPPER HALF
  JUMPLE R1,NXPAG1	;NOT LOADER
  CAILE R1,10		;CHECK FOR .REL TYPE
    JRST NXPAG1		;NO--ASCII
;
  SETOM IFLTYP		;.REL FILE--SET FLAG
  MOVE R1,IFLLFT	;GET LENGTH
  IDIVI R1,5		;IN WORDS NOT CHRS
  MOVEM R1,IFLLFT	;RESAVE
;
 NXPAG1:
  MOVEI R1,1000*5	;NUMBER OF CHRS IN PAGE
  SKIPE IFLTYP		;CHECK IF ASCII FILE
    MOVEI R1,1000	;NUMBER OF WORDS IN PAGE IF BINARY
  CAML R1,IFLLFT ;CHECK THAT
  MOVE R1,IFLLFT ;INCOMPLETE PAGE
  MOVEM R1,IFLCNT ;SAVE COUNT FOR PAGE
;
  MOVNS R1 ;NEGATE THE COUNT
  ADDM R1,IFLLFT ;AND UPDATE AMOUNT LEFT IN FILE
;
  MOVEI R1,SRCPGN*1000 ;ADDRESS OF PAGE IN CORE
  HRLI R1,440700 ;CREATE BYTE TALLY
  SKIPE IFLTYP		;CHECK IF ASCII SOURCE
    HRLI R1,444400	;IF NOT (BINARY) THEN WORD SOURCE
  MOVEM R1,IFLTL ;SAVE IT
;
  POP P,R3 ;RESTORE R3,R2,R1
  POP P,R2
  POP P,R1
  POPJ P, ;AND RETURN
;
;
  SUBTTL LINE SCAN ROUTINES--NXCH
;
;   NXCH--THIS ROUTINE GETS THE NEXT USABLE CHARACTER FROM THE SOURCE
;      FILE, IGNORING ONLY NULLS AND RUBOUTS.  NO EDITING IS DONE
;      ON THE CHARACTER.  IT IS CALLED WITH A JSP.
;
;
 NXCH:
    GTCHR CH ;GET CHAR
    JUMPE CH,NXCH     ;IGNORE NULLS
    CAIN CH,ASCDEL    ;CHECK FOR RUBOUT
    JRST   NXCH        ;IGNORE THEM
    JRST   0(T)        ;AND RETURN
;
;
  SUBTTL LINE SCAN ROUTINES--NXECH, CRECH
;
;   NXECH--THIS ROUTINE GETS THE NEXT EDITED CHARACTER IN THE FILE.  SPACES
;      AND MOST CONTROL CHARACTERS ARE IGNORED, LOWER CASE MAPPED TO UPPER, ETC.
;      THE CHARACTER IS RETURNED IN REGISTER 'CH'.
;
;   CRECH--THIS TAKES THE CURRENT CHARACTER IN 'CH' , PRESUMABLY GOTTEN
;      BY 'NXCH' ROUTINE, AND EDITS IT AS THE NXECH ROUTINE WOULD.
;
;
 NXECH:
    GTCHR CH ;GET NEXT SOURCE CHR
;
 CRECH:
    XCT    NXCHTB(CH)  ;EDIT CHAR VIA TABLE 'NXCHTB'
;
;
    JRST   0(T)        ;RETURN
;
;
 NXCH2:
    ERR    E.ILCH      ;ILLEGAL CHARACTERS--IGNORED
    JRST   NXECH       ;GET NEXT
;
;
 NXCH3:
    GTCHR CH ;COMMENT--IGNORE IT--GET CHR
    CAIN   CH,ASCEOL   ;CHECK FOR TENEX EOL
    MOVEI  CH,ASC.LF   ;CHANGE TO LF IF SO
    CAIE   CH,ASC.LF   ;CHECK FOR LF
    JRST   NXCH3       ;IF NOT, GET NEXT CHAR
    JRST   0(T)        ;AND THEN RETURN WITH LF
;
;
 NXCH4:
    AOS    PAGECT      ;NEW PAGE
    MOVEI  CH,ASC.LF   ;FUDGE LF
    JRST   0(T)        ;AND RETURN
;
;
;
SUBTTL LINE SCAN ROUTINES--CHAR TABLE FOR EDITING
;
;   NXCHTB--TABLE FOR CHARACTER EDITING
;
 NXCHTB:
    JRST   NXECH       ;000--NULL--IGNORE
    REPEAT 10,<JRST NXCH2> ;MISC CONTROL--ERROR, IGNORE
    JRST   NXECH ;TAB--IGNORE
    NOP                ;LINE FEED
    JRST NXCH2 ;VERTICAL TAB--ILLEGAL
    JRST   NXCH4       ;FF--END OF FILE
    JRST   NXECH       ;CR--IGNORE
    REPEAT 21,<JRST NXCH2> ;MISC CONTROL--ERORR, IGNORE
    MOVEI  CH,ASC.LF   ;EOL=LF
    JRST   NXECH       ;SPACE--IGNORE
    JRST   NXCH2       ;!--ERROR
    NOP                ;"
    NOP                ;#
    NOP                ;$
    JRST   NXCH2       ;%--ERROR
    NOP                ;&
    JRST   NXCH3       ;' -- COMMENT
    REPEAT 23,<NOP> ;MISC CHARS '(' ... ':'
    NOP                ;';'
    NOP                ;<
    NOP                ;=
    NOP                ;>
    JRST   NXCH2       ;?--ERROR
    JRST   NXCH2       ;@--ERROR
    REPEAT 32,<NOP> ;A...Z
    MOVEI  CH,ASCLPR   ;[-->(
    JRST   NXCH2       ;\--ERROR
    MOVEI  CH,ASCRPR   ;]-->)
    NOP                ;^
    JRST   NXCH2       ;_--ERROR
    JRST   NXCH2       ;GRAVE ACCENT--ERROR
    REPEAT 32,<HRRZI CH,-ASCLCA+ASC..A(CH)> ;LOWER TO UPPER CASE
    MOVEI  CH,ASCLPR   ;LEFT BRACE-->(
    JRST   NXCH2       ;VERTICAL LINE--ERROR
    MOVEI  CH,ASCRPR   ;RIGHT BRACE--)
    JRST   NXCH2       ;ESCAPE--ERROR
    JRST   NXECH       ;RUBOUT---IGNORE
;
;
  SUBTTL LINE SCAN ROUTINES--LINE
;
;   LINE--THIS IS THE MAIN COMPILER DRIVER.  ITS JOB IS TO SCAN A LINE.
;      FIRST IT PROCESSES THE LINE NUMBER.  THEN IT DETERMINES THE
;      STATEMENT TYPE AND JUMPS TO THE PROPER STATEMENT PROCESSING
;      ROUTINE.
;
;
 LINE:
    MOVEI  T1,0        ;CLEAR DIGIT COUTN
    MOVEI  T0,0        ;CLEAR LINE NUMBER
    HRLZI  R2,777774   ;FREE ALL REGS
    MOVEM  R2,REGFGS   ;SAVE FLAGS
    SETOM TMPFGS ;RELEASE ALL TEMPS
    MOVEM P,OLDPDL ;SAVE PDL FOR ERRORS
    SETZM ALWTRM ;NO SPECIAL TERMINATORS ALLOWED
    SETZM PRIFG ;NOT PRINT
    SKIPE  EOFFG       ;CHECK IF END OF FILE
    JRST   END         ;HANDLE IF SO
;
  JSP T,NXCH		;GET FIRST CHAR
  SKIPE IFLTYP		;CHECK FOR .REL FILE
    JRST INREL		;HANDLE IF SO
  SKIPA			;SKIP IF NOT
;
 LINE1:
    JSP    T,NXCH      ;GET CHAR
    CAIL   CH,ASC..0   ;CHECK FOR DIGIT
    CAILE  CH,ASC..9   ;SKIP IF DIGIT
    JRST   LIN1        ;HANDLE IF DONE LINE NUMBER
    ADDI   T1,1        ;DIGIT COUNT
    IMULI  T0,12       ;LINE NUMBER
    ADDI   T0,-ASC..0(CH)
    JRST   LINE1       ;HANDLE NEXT DIGIT
;
 LIN1:
    SKIPN  T1          ;SKIP IF SOMETHING THERE
    JRST   LIN3        ;HANDLE IF NO LINE NUM
    CAILE  T1,5        ;CHECK IF < 5 DIGITS
    ERR    E.LNTL      ;ERROR IF NOT
    PUSHJ P,LENTER      ;ENTER THE LINE NUMBER IN TABLE
    MOVE R2,PAGECT ;GET CURRENT PAGE NUMBER
    HRLM R2,LSTLN ;SAVE AS PART OF LINE NUMBER
    PUSHJ P,LINHDR ;LINE NUMBER INTO REG OP
    JSP    T,CRECH     ;EDIT TERMINAL CHARACTER
    CAIN   CH,ASC.LF   ;CHECK FOR COMMENT LINE
    JRST   XEOL         ;IGNORE IT IF SO
    MOVE   T2,[POINT 7,T3] ;GET TALLY FOR NOW
    SETZM  T3          ;CLEAR DESTINATION
    CAIL   CH,ASC..A   ;CHECK FOR LETTER
    CAILE  CH,ASC..Z
    ERR    E.ILST      ;ERROR IF NOOT
    IDPB   CH,T2       ;SAVE IN T3 IF SO
    JSP    T,NXECH     ;GET SECOND CHAR
    CAIL   CH,ASC..A   ;CHECK FOR LETTER
    CAILE  CH,ASC..Z
    JRST XLIN		;MIGHT BE ASSIGNMENT WITHOUT LET
    IDPB   CH,T2       ;IF LETTER, THEN SAVE IT
    CAMN   T3,[ASCII /IF/] ;CHECK FOR 'IF'
    JRST   S.IF        ;PROCESS IF SO
    CAMN   T3,[ASCII /ON/] ;CHECK FOR 'ON'
    JRST   S.ON        ;PROCESS IF SO
;
    JSP    T,NXECH     ;ELSE GET THIRD CHARACTER
    CAIL   CH,ASC..A   ;CHECK FOR LETTER
    CAILE  CH,ASC..Z
    ERR    E.ILST      ;MUST BE
    IDPB   CH,T2       ;SAVE IN T3
;
;   LOOK UP STATEMENT AS THREE CHARACTERS
;
    SKIPL  PRGNM       ;CHECK IF WE HAVE A PROGRAM
    JRST   LIN2        ;YES--SKIP
    CAMN   T3,CMRREM   ;CHECK FOR 'REM'
    JRST   S.REM       ;OK
    CAMN   T3,CMRSUB   ;CHECK FOR 'SUB'
    JRST   S.SUB       ;OK
    PUSHJ P,STMAIN      ;ELSE START MAIN PROGRAM
;
 LIN2:
    MOVEI  T4,CMTB3L   ;LENGTH OF TABLE
    CAMN   T3,CMNTB3-1(T4) ;CHECK FOR MATCH
    JRST   @CMRTB3-1(T4) ;HANDLE IF MATCH
    SOJG   T4,.-2      ;SKIP BACK IF MORE
    ERR    E.ILST      ;ERROR IF NO MATCH
;
 LIN3:
  JSP T,CRECH ;EDIT CURRENT CHR
  CAIE CH,ASC.LF ;CHECK FR EOL
  ERR E.NOLN ;NO--BAD
  JRST LINE ;YES--IGNORE
;
;   HANDLE POSSIBLE ASSIGNMENT WITHOUT LET
;
 XLIN:
  IFE LEXN01,<ERR E.ILST>	;NOT ALLOWED 
  IFN LEXN01,<
	MOVEM CH,MAT.CH	;SAVE CURENT CHR AS SECOND
   	LDB CH,T2	;RESTORE FIRST CHR
	SKIPGE PRGNM	;CHECK IF PROGRAM DEFINED
	PUSHJ P,STMAIN	;START MAIN PROGRAM IF NOT
	HRLZI FG,EQUBT+NCHBT	;BITS FOR LET
	JRST LET0	;AND ENTER LET ROTUINE
  >
;
;
              ;
;   THREE CHARACTER STATEMENT TABLE
;
;         NAMES
;
 CMNTB3:
    ASCII  /CAL/       ;CALL
    ASCII  /DEF/       ;DEF
    ASCII  /DIM/       ;DIM
    ASCII  /END/       ;END
    ASCII  /FIL/       ;FILE
    ASCII  /FNE/       ;FNEND
    ASCII  /LIB/       ;LIBRARY
    ASCII  /LIN/       ;LINPUT
    ASCII  /MAR/       ;MARGIN
    ASCII  /MAT/       ;MAT
    ASCII  /RAN/       ;RANDOMIZE
    ASCII  /RES/       ;RESET
    ASCII  /SCR/       ;SCRATCH
 CMRSUB:ASCII /SUB/    ;SUB
    ASCII  /TIM/       ;TIME
    ASCII  /WRI/       ;WRITE
    ASCII  /INP/       ;INPUT
    ASCII  /PRI/       ;PRINT
    ASCII  /RET/       ;RETURN
    ASCII  /DAT/       ;DATA
    ASCII  /STO/       ;STOP
    ASCII  /CHA/       ;CHANGE, CHAIN
    ASCII  /GOS/       ;GOSUB
    ASCII  /REA/       ;READ
 CMRREM:ASCII /REM/    ;REM
    ASCII  /GOT/       ;GOTO
    ASCII  /NEX/       ;NEXT
    ASCII  /FOR/       ;FOR
    ASCII  /LET/       ;LET
;
;         JUMP ADDRESSES
;
 CMRTB3:
    EXP    S.CAL       ;CALL
    EXP    S.DEF       ;DEF
    EXP    S.DIM       ;DIM
    EXP    S.END       ;END
    EXP    S.FIL       ;FILE
    EXP    S.FNE       ;FNEND
    EXP    S.LIB       ;LIBRARY
    EXP    S.LIN       ;LINPUT
    EXP    S.MAR       ;MARGIN
    EXP    S.MAT       ;MAT
    EXP    S.RAN       ;RANDOMIZE
    EXP    S.RES       ;RESET
    EXP    S.SCR       ;SCRATCH
    EXP    S.SUB       ;SUB
    EXP    S.TIM       ;TIME
    EXP    S.WRI       ;WRRTE
    EXP    S.INP       ;INPUT
    EXP    S.PRI       ;PRINT
    EXP    S.RET       ;RETURN
    EXP    S.DAT       ;DATA
    EXP    S.STO       ;STOP
    EXP    S.CHA       ;CHAIN, CHANGE
    EXP    S.GOS       ;GOSUB
    EXP    S.REA       ;READ
    EXP    S.REM       ;REM
    EXP    S.GOT       ;GO TO
    EXP    S.NEX       ;NEXT
    EXP    S.FOR       ;FOR
    EXP    S.LET       ;LET
;
    CMTB3L= 35         ;LENGTH
;
;
  SUBTTL LINE SCAN ROUTINES--EOL
;
;   EOL--THIS ROUTINE HANDLES THE END OF A LINE.  IT IGNORES
;      EVERYTHING UP TO THEH CARRAIGE RETURN AND THEN TRANSFERS TO
;     THE 'LLINE' ROUTINE TO PROCESS THE LINE.
;
;
 EOL:
    TLZN   FG,NCHBT    ;CHECK IF NEXT CHAR SCANNED
    JSP    T,NXECH     ;IF NOT, GET CHAR
    CAIN   CH,ASC.LF   ;CHECK FOR END OF LINE
    JRST   EOL1        ;HANDLE IF SO
    ERR    E.INFT      ;IF NOT THEN ERROR
;
;   ENTER HERE IF LINE TO BE IGNORED TILL END
;
 XEOL:
    CAIE CH,ASCEOL	;ACCEPT EOLS TOO
    CAIN   CH,ASC.LF   ;CHECK FOR END OF LINE
    JRST   EOL1        ;SKIP IF NOT
    JSP    T,NXCH      ;IF  NOT GET NEXT CHAR
    JRST   XEOL        ;AND TRY AGAIN
;
 EOL1:
    SKIPGE RPGFG	;CHECK FOR ONE LINE COMPILATION
    JRST EONELN		;HANDLE END OF IT IFSO
    PUSHJ P,LINTRL ;GET RID OF LINE NUMBER OP IF NO CODE
    JRST   LINE        ;WHEN FOUND EOL, THEN HANDLE NEXT LINE
;
;   ENTER HERE IF RT ROUTINE JUST COMPILED AND R2 SHOULD
;      BE MARKED AS USED
;
 RTEOL:
  MOVSI R2,100000 ;BIT FOR R2
  IORM R2,REGUSD ;MARK AS USED
  JRST EOL ;NOW EOL
;
;
SUBTTL LINE NUMBER ROUTINES--LINHDR
;
;   LINHDR--THIS ROUTINE GENERATES A HRROI R.L,<LN> FOR THE
;      CURRENT LINE (OR NOTHING OR A DEBUGGER CALL AS
;      REQUIRED).
;
;
LINHDR:
;
  SKIPE DEBFG ;CHECK IF DEBUG MODE
    JRST DLNHDR ;IF SO, GENERATE DEBUG TYPE HEADER
  MOVSI R2,(HRLI R.L,0) ;DUMMY OP
  HRR R2,LSTLN ;PLUS LINE NUMBER
  SAVWD ;SAVE IT
  POPJ P, ;THEN DONE
;
;
DLNHDR:
;
  MOVEI R2,R.DBGR ;GENERATE CALL TO DEBUGGER
  PUSHJ P,SVCAL ;SAVE THE CALL
  SKIPN R1,LNHDPT ;CHECK IF FIRST LINE, GET OLD LINK
    JRST DLNHD1 ;FIRST LINE--SKIP
  ADD R1,OBJCOD ;RELOCATE THE LINK
  HRRM R2,0(R1) ;SAVE NEW PTR IN OLD WORD
  MOVEI R1,1 ;GET RELOCATION TYPE OF PROGRAM
  IDPB R1,LNHDRP ;SAVE THERE
;
 DLNHD1:
  MOVE R2,OBJPT ;GET CURRENT OBJCET CODE PTR
  MOVEM R2,LNHDPT ;SAVE FOR TRAILER LINK
  MOVE R2,RLCPT ;GET RELOCATION PTR
  MOVEM R2,LNHDRP ;SAVE IT
  HRLZ R2,LSTLN ;GET LINE NUMBER
  SAVWD ;SAVE FOR LINK WORD
  POPJ P, ;AND RETURN
;
;
SUBTTL LINE NUMBER ROUTINES--LINTRL
;
;   LINTRL--THIS ROUTINE GETS RID OF THE CODE GENERATED BY 
;      LINHDR IF THAT CODE IS THE ONE INSTRUCTION HRROI R.L,X
;      AND IF NO OTHER CODE WAS GENERATED FOR THE LINE.
;
;
LINTRL:
;
  SKIPN OBJPT ;CHECK IF START OF PROGRAM
  POPJ P, ;JUST RETURN IF SO
  SKIPE DEBFG ;CHECK IF DEBUG MODE
    JRST DLNTRL ;IF SO,  GENERATE SPECIAL TRAILER
;
  HLLZ R2,@OBJTL ;GET LAST OP GEN
  CAME R2,[HRLI R.L,0] ;CHECK IF SAME
  POPJ P, ;CODE GENERATED--SKIP
;
  SOS OBJTL ;GET RID OF CODE
  SOS OBJPT ;DEC PTR
  SOS OBJCNT ;AND CNTR
  MOVS R2,RLCPT ;AND RELOC TALLY
  ADDI R2,030000 ;MUST BE BACKED UP
  MOVSM R2,RLCPT ;AND RESAVED
  SOS RLCNT ;AND ITS COUNTER
;
  POPJ P, ;THEN DONE
;
;
DLNTRL:
;
  POPJ P, ;THEN DONE
;
;
  SUBTTL LINE NUMBER ROUTINES--LENTER
;
;   LENTER--THIS ROUTINE HANDLES A LINE NUMBER JUST SCANNED.  IT ACCEPTS
;      THE LINE NUMBER IN T0 AND THE RADIX 50 LINE IN T2.
;
;
 LENTER:
    HRRZ R2,LSTLN ;GET LINE NUMBER ONLY
    CAMGE  T0,R2    ;CHECK IF LINE NUMBERS ARE IN ORDER
    ERR    E.LNOD      ;IF NOT, ERROR
    MOVEM  T0,LSTLN    ;SAVE NEW LINE
    SKIPGE PRGNM       ;CHECK IF WE HAVE A PROGRAM
    JRST   LENT2       ;HANDLE IF NOT
;
 LENT1:
    AOS    NUMLIN      ;ONE MORE LINE
    SOS    LNNMS       ;TWO WORD ENTRIES
    SOS    T3,LNNMS    ;GET NEXT AVAIL LOC IN LN TBL
    CAMG   T3,ULNPT    ;CHECK IF TABLE FULL
    PUSHJ  P,MRLIN     ;IF SO, MOVE UP TABLE
    MOVE   T3,LNNMS    ;GET PTR
    MOVE   R2,OBJPT    ;GET OBJ CODEADD
  HRRZM R2,1(T3) ;SAVE ADDRESS
  MOVE R2,T0 ;GET LINE NUM
  SKIPE CURFCT ;CHECK IF IN FCT
  TRO R2,400000 ;SET ON BIT I SO
  HRL R2,PAGECT ;ALSO SAVE WITH PAGE NUMBER
  MOVEM R2,0(T3) ;AND SAVE IN TABLE
    JSP    T,FNDLIN    ;CHECK I PREVIOUSLY UED
;
    POPJ P, ;AND RETURN
;
 LENT2:
    MOVE   T3,OBJPT    ;GET OBJECT CODE REL ADD
    MOVEM  T3,STADD       ;SAVE IT
    JRST   LENT1       ;AN SKIP
;
;
;
  SUBTTL LINE NUMBER ROUTINES--LNREF
;
;   LNREF--THIS ROUTINE TAKES A LINE NUMBER IN T7 ON ENTRY
;      AND RETURNS THE ADDRESS FOR THAT LINE NUMBER IN T7 ON EXIT.
;      ITS PURPOSE IS REFERENCES TO LINE NUMBERS (I.E. GO TO'S).
;
;
 LNREF:
    HRRZ T5,LSTLN ;GET LAST LINE NUMBER ONLY
    CAMLE  T7,T5    ;CHECK IF WE HAVE SCANNED THE LINE YET
    JRST   LNRF5       ;SKIP IF NOT
    SKIPN  CURFCT       ;CHECK IF IN FCT
    JRST   .+3         ;HANDLE IF NOT
    CAMG  T7,FCTLIN   ;IF SO, CHECK IF REF VALID
    ERR    E.FCLN      ;ERROR IF NOT
;
;IF PASSED ALREADY--DO BINARY LOOKUP IN TABLE
;
    HRRZ   T5,LNNMS    ;GET POINTER
    SUB    T5,LINETB   ;MINUS TOP
    MOVNI  T4,1        ;DIFFERENCE IN T4
    ASH    T4,1        ;COMPUTE LOG2 OF LENGTH
    CAMLE  T4,T5
    JRST   .-2
    ASH    T4,-1       ;ROUNDED DOWN
    MOVE   T3,T4       ;SAVE THE RESULT
    ADD    T3,LINETB   ;PLUS TOP OF CORE
    JRST   LNRF3       ;AND ENTER THE LOOKUP LOOP
;
;BINARY LOOKUP
;
 LNRF1:
    HRRZ   T6,0(T3)    ;GET LINE NUMBER
    TRZ T6,400000 ;ONLY
    CAMGE  T7,T6       ;SKIP IF <=
    JRST   LNRF2       ;HANDLE >
    CAMN   T7,T6       ;SKIP IF <
    JRST   LNRF8       ;HANDLE IF FOUND
    ASH    T4,-1       ;NEXT ITEM
    CAMN   T4,[-1]     ;CHECK IF DONE
    JRST   LNRF4       ;JUMP OUT ON FAIL
    ADD    T3,T4       ;NOT DONE--GET NEXT ITEM
 LNRF3:
    CAML   T3,LNNMS    ;CHECK IF OUT OF BOUNDS
    JRST   LNRF1       ;IF NOT, CONTINUE WITH LOOK UP
;
 LNRF2:
    ASH    T4,-1       ;>--GET NEXT ADDITIVE
    JUMPE  T4,LNRF4    ;EXIT IF FAIL
    SUB    T3,T4       ;CONSTRUCT NUXT NUMBER
    JRST   LNRF3       ;AND USE IT
;
;   FOUND
;
 LNRF8:
    MOVE R2,0(T3) ;GET NUMBER
    TRNN R2,400000 ;CHECK IF FUNCTION
    JRST   LNRF9       ;HANDLE IF SO
    SKIPN  CURFCT       ;IN FUNCTION
    ERR    E.FCLN      ;ERROR IF SO
;
 LNRF9:
    HRRZ   T7,1(T3)    ;GET ADDRESS IN T7
    POPJ P,      ;AND RETURN
;
;
;FAIL
;
 LNRF4:
    MOVEM T7,XLNNO ;SAVE REFERED TO LINE NUM FOR ERROR MES
    ERR    E.UDLA      ;ERROR MESSAGE
    POPJ P,      ;AND RETURN
;
;   HANDLE IF NOT OCCURED (FUTURE REF)
;
 LNRF5:
  MOVE T4,ULNLS ;GET FIRST ITEM IN LIST
  MOVEI T5,ULNLS ;AND PTR TO SOURCE OF LINK
  JUMPE T4,LNRFA3 ;NO UNDEFS--HANDLE
;
 LNRFA2:
  HRRZ T6,1(T4) ;GET LINE NUMBER
  CAMG T7,T6 ;CHECK IF OUR LINE IS ON LIST
  JRST LNRFA1 ;IF NOT, WE'VE PASSED IT--HANDLE
  MOVE T5,T4 ;NOT YET--GET NEXT LINK
  HRRZ T4,0(T5) ;AND LINK POINTER
  JUMPN T4,LNRFA2 ;JUMP BACK IF LINK EXISTS
  JRST LNRFA3 ;ELSE PROCESS
;
 LNRFA1:
  CAME T7,T6 ;CHECK IF LINE FOUND
  JRST LNRFA3 ;NO--NOT ON LIST--HANDLE
;
  HLRZ T7,0(T4) ;GET OLD LINK IF FOUND FOR ADDRESS TO USE
  MOVE T5,OBJPT ;GET CURRENT ADDRESS
  HRLM T5,0(T4) ;SAVE THAT FOR NEXT LINK
  POPJ P, ;AND RETURN
;
;
;
;   LNRFA--ENTER LINE NUMBER IN UNDEFINED LINKED LST
;
 LNRFA3:
    MOVE   T6,ULNFR    ;GET LIST POINTER
    JUMPN  T6,LNRFA5   ;LIST EMPTY
    MOVE   T6,ULNPT    ;PICK UPPOINTER
    ADDI   T6,2        ;SAVE ROOM FO BLOCK
    MOVEM  T6,ULNPT    ;SAVE POINTER
    CAMGE  T6,LNNMS    ;CHECK IF WE'LL FIL
    JRST   LNRFA6      ;WILL FIT--JUMP
    PUSHJ  P,MRULN     ;NO--GET MORE ROOM
    MOVE   T6,LNNMS    ;RESTORE PTR
    JRST   LNRFA6      ;AND JUMP
;
 LNRFA5:
    MOVE   T6,1(T6)    ;FREE BLOCK ON LIST--USE IT
    EXCH  T6,ULNFR    ;RESTORE FREE BLOCK POINTER
;
 LNRFA6:
  HRL T7,PAGECT ;PUT PAGENUMBER INTO LINE TO SAVE
  MOVEM T7,1(T6) ;SAVE LINE NUMBER IN NEW BLOCK
  HRRM T6,0(T5) ;SAVE LINK TO NEW BLOCK
  HRL T4,OBJPT ;GET CURRENT PTR
  MOVEM T4,0(T6) ;THAT AND NEXT BLOCK LINK TO NEW BLK
  MOVEI T7,0 ;RETURN ADDRESS OF ZERO
  POPJ P, ;AND RETURN
;
;
  SUBTTL LINE SCAN ROUTINES--FNDLIN
;
;   FNDLIN--THIS ROUTINE IS CALLED FROM LENTER WITH THE LINE NUMBER IN
;      T0 AND CHECKS TO SEE IF THAT LINE HAS BEEN DEFINED AS A
;      FUTURE REFERENCE.  IF NOT, IT RETURNS TO 1(T). IF SO, THEN IT
;      RETURNS THE ADDRESS IN R2 AND GETS RID OF THE UNDEFINED
;      BLOCK.
;
;
 FNDLIN:
    MOVE   T6,ULNLS    ;GET LIST OF UNDEFINED LINES
    JUMPE  T6,0(T)     ;IF EMPTY, THEN DONE
    HRRZ T7,1(T6) ;GET FIRST LINE ON LIST
    CAMGE  T0,T7    ;CHECK IF MORE ON  LIST (STILL POSSIBLE)
    JRST   0(T)        ;NOT THERE--RETURN
    CAME   T0,T7    ;CHECK IF DONE
    JRST   FNDLN1      ;ANOTHER LINE INBETWEEN--ERROR
;
;UNLINK BLOCK, LINK TO FREE LIST
;
    HRRZ   R2,0(T6)    ;GET ADDRESS
    MOVEM  R2,ULNLS    ;SAVE NEW LINK
    MOVE   T7,ULNFR    ;LINK BLOCK AS UNUSED
    MOVEM  T7,1(T6)    ;SET UP LINK
    MOVEM  T6,ULNFR
;
    HLRZ   R2,0(T6)    ;GET FIRST LINK
    MOVE   T7,OBJPT    ;GET REL ADDRESS OF WHERE TO LINK
;
 FNDLN2:
    ADD    R2,OBJCOD   ;PLUS BASE
    HRRZ   T6,0(R2)    ;GET OLD LINK
    HRRM   T7,0(R2)    ;SAVE PROPER ADDRESS
    SKIPE  R2,T6       ;SKIP IF DONE
    JRST   FNDLN2      ;ELE LINK UP ANOTHER
    JRST   0(T)        ;AND RETURN
;
;HANDLE UNDEFINED LINE NUMBER
;
 FNDLN1:
    PUSHJ P,ERUDLB ;PRINT ERROR MESSAGE(S) FOR UNDEF LINE
    HRRZ   T7,0(T6)    ;GET LINK TO USE
    MOVEM  T7,ULNLS    ;SAVE LINE NUMBER
    MOVE   T7,ULNFR    ;GIVE THE BLOCK TO THE FREE LIST
    MOVEM  T7,1(T6)    ;*****CHECK THIS CODE
    MOVEM  T6,ULNFR
    JRST   FNDLIN      ;AND TRY FINDING LINE AGAIN
;
;
    PRINTX *****START OF BAS20*****
;
;
  SUBTTL ARITHMETIC SCAN--ARSCN
;
;   ARSCN--THIS IS THE MAIN ROUTINE OF THE ARITHMETCI SCAN.  IT
;      SERVES AS THE ENTRY.  THE ARITHMETIC SCAN IS THE HEART OF
;      THIS COMPILER,  IT IS USED FOR SCANNING ANY EXPRESSION,
;      CONSTANT, VARIABLE, ETC.  IT SETS UP FUNCTION CALLS,
;      SUBROUTINE CALL LISTS, MAT STATMENTES, ETC.
;
;
 ARSCN:
;
;
;
;   INITIALIZATION
;
    MOVE   VS,[IOWD 100,ARVST] ;SET UP VAR STACK
;
 ARSCN1:
    MOVE   T0,[POINT 36,CONBF] ;CONSTANT POINTER
    MOVEM  T0,CONPT    ;SAVE IT
;
 ARSCN2:
    MOVE   OS,[IOWD 100,AROST] ;SET UP OP STACK
    PUSH   OS,[XWD PR.END,0] ;PUSH FLAG ON OP STACK
;
;
;
    SETZM XNSBCS ;NO DEFAULT SUBSCRIPTS
    JRST   ARNX1       ;AND ENTER LOOP
;
;
;   XARSCN--ENTRY TO ARSCN WHEN YOU WANT THE WORD IN R2
;      TO BE PLACED ON THE VS STACK INIT (USEFUL FOR DUMMY
;      FCT CALLS).  CALLED WITH A PUSHJ P,XARSCN.
;
;
XARSCN:
;
  MOVE VS,[IOWD 100,ARVST] ;INITIAL VS
  PUSH VS,R2 ;SAVE ITEM ON IT
  JRST ARSCN1 ;AND ENTER SCAN
;
;
;   CARSCN--ENTRY TO ARSCN WHICH IS NORMAL EXCEPT THAT PREVIOUS
;      CONSTANTS STILL IN BUFFER (CONBF) SHOULD NOT BE PURGED.
;
;
CARSCN:
;
  MOVE VS,[IOWD 100,ARVST]	;SET UP VS STACK
  JRST ARSCN2			;AND SKIP
;
;
  SUBTTL ARITHMETIC SCAN--ARNXT
;
;   ARNXT--THIS ROUTINE PROCESSES THE NEXT ELEMENT IN THE CURRENT
;      SCAN. IT LOOKS AT THE ITME AND BRANCHES TO THE PROPER
;      PLACE IN THE ARITHMETIC SCAN TO PROCESS IT.
;
;
 ARNXT:
    TLZ    FG,PRIBT    ;IGNORE PRINT EXPRESSIONS AFTER FIRST TIME
;
 ARNX1:
    TLZN   FG,NCHBT    ;CHECK IF CHARACTER ALREADY SCANNED
    JSP    T,NXECH     ;IF NOT, THEN GET NEXT CHAR
    JRST    ARCHTB(CH)  ;BRANCH, ETC. BY TABLE
;
;
              ;
;   ARCHTB--TABLE OF ARITHMETIC SCAN CHARACTER HANDLING
;
 ARCHTB:
    REPEAT 40,<JRST AREXI> ;CONTROL CHRS--END
    JRST   ARNXT       ;SPACE
    ERR    E.INFT      ;!
    JRST   ARSTR       ;"
    ERR    E.INFT      ;#
    ERR    E.INFT      ;$
    ERR    E.INFT      ;%
    JUMPA   6,ARSBOP    ; &
    JRST   AREXI       ; '
    JRST   ARLPR       ; (
    JRST   ARRPR       ; )
    JUMPA   3,ARBOP     ; 0
    JRST   1,AROP      ; +
    JRST   ARCMA       ; ,
    JUMPA   2,AROP      ; -
    JRST   ARNUM       ; .
    JUMPA  4,ARBOP     ; /
    REPEAT 12,<JRST ARNUM> ; 0...9
    JRST   AREXI       ; :
    JRST   AREXI       ; ;
    JRST   ARCOP       ; <
    JRST   AREQU       ; =
    JRST   ARCOP       ; >
    ERR    E.INFT      ; ?
    ERR    E.INFT      ; @
    REPEAT 32,<JRST ARWRD> ;A ... Z
    JRST   ARLPR       ; [
    ERR    E.INFT      ; \
    JRST   ARRPR       ; ]
    JUMPA  5,ARBOP     ; ^
    ERR    E.INFT      ; GRAVE ACCENT
;
  SUBTTL ARITHMETIC SCAN--AREXI
;
;   AREXI--THIS ROUTINE IS USED TO FINISH UP AN ARITHEMTIC SCAN.  IT
;      CLEANS OFF THE STACK AND RETURNS WITH HOPEFULLY ON  IEM ON THE
;       VARIABLE STACK AND NONE ON THE OP STACK.
;
;
 AREXI:
    MOVEM  CH,ARTERM   ;SAVE TERMINATOR
    TLO    FG,NCHBT    ;CHARACTER ENTRY--SCANNED TOO MANY
    TLNN   FG,OPBT     ;CHECK IF END OKAY TO HAVE
    ERR    E.INFT      ;ERROR IF NOT
;
 AREXX:
    TLO    FG,ENDBT    ;MARK AS END OF SCAN
    TLNE   FG,CNDBT    ;CHECK IF CONDITIONAL WANTED/NOT FOUND
    ERR    E.NCND      ;ERROR IF SO
    TLNE   FG,EQUBT    ;CHECK IF '=' REQUIRED
    ERR    E.INFT      ;ERROR IF SO
    HRLZI  T0,PR.END   ;CHECK FOR ALL OPS OFF STACK
;
 AREXX2:
    TDNE   T0,0(OS)    ;CHECK FOR OP STACK EMPTY
    JRST   AREX1       ;IF SO, JUMP
    PUSHJ P,DONXT     ;ELSE PERFORM TOP OPERATION
    JRST   AREXX2      ;AND TRY AGAIN
;
 AREX1:
    POPJ P, ;AND RETURN
;
;
  SUBTTL ARITHMETIC SCAN--ARWRD
;
;   ARWRD--THIS ROUTINE SCANS THE NEXT SYNTACTIC UNIT STARTING WITH
;      A LETTER.  THIS MAY BE A VAIRABLE, A TERMINATOR (TO, THEN, ETC.)
;      , A FUNCTION CALL OR REFERENCE, ETC.  IT THEN PERFORMS THE
;      PROPER STACKING, ETC. BASED ON WHAT IT FINDS.
;
;
 ARWRD:
    TLNE   FG,OPBT     ;CHECK IF OPERATOR EXPECTED
    JRST   ARTRM       ;TERMINATOR IF SO
    SETZM  T7          ;CLERR OUTPUT WORD
    MOVE   T2,[POINT 7,T7] ;TALLY
    IDPB   CH,T2       ;SAVE FIRST CHARACTER IN WORD
    SKIPN CH,MAT.CH ;USE MAT CHR IF GIVEN
    JSP    T,NXECH     ;GET NEXT CHARACTER
    CAIGE  CH,ASC..0   ;CHECK FOR SUBSEQUENT DIGIT
    JRST   ARVR1       ;NO--HANDLE NON-DIGIT, NON-LETTER
    CAIG   CH,ASC..9   ;CHECK FOR DIGIT
    JRST   ARVR2       ;HANDLE 00DIGIT00
    CAIGE  CH,ASC..A   ;CHECK FOR LETTER
    JRST   ARVR1       ;HANDLE IF NOT
    CAIGE  CH,ASC..Z
    JRST   ARFCT       ;DOUBLE LETTER--ASSUME FUNCTION
;
;ONE CHAR VARIABLE
;
 ARVR1:
    SETZM MAT.CH ;MAT CHR NOT GIVEN
    LDB    T0,T2       ;GET FIRST CHAR
    SUBI   T0,ASC..A   ;TO NUMBER 0...25
    JRST   ARVAR       ;HANDLE 00ONE00 CHAR VARRABLE
;
;TWO CHAR VARRALBE
;
 ARVR2:
    SETZM MAT.CH	;EXTRA CHR NOT GIVEN ANY MORE
    LDB    T0,T2       ;GET CHARACTER
    IMULI  T0,12       ;TIMES 10
    ADDI   T0,32-ASC..0-12*ASC..A(CH) ;TO VARIABLE NUMBER IN T0
    JSP    T,NXECH     ;GET NEXT CHARACTER
    JRST   ARVAR       ;AND CHECK FOR STRING, MAT, ETC.
;
;
  SUBTTL ARITHMETIC SCAN ROUTINES--ARVAR
;
;   ARVAR--CHECK TYPE OF VARIABLE, AND RROCESS IF NUMERIC
;
;
 ARVAR:
    TLNE   FG,MATBT    ;MATRIX PROCESSING
    TLNE   FG,EQUBT    ;ASSIGNMENT
    SKIPA              ;SKIP
    JRST   ARMVR       ;HANDLE IF SO
;
 ARVR6:
    CAIN   CH,ASCDOL   ;'$' FOLLOWS
    JRST   ARSVR       ;YES--PROCESS AS STRING VARIABLE
    HRLI   T0,VTNVR    ;GET BITS FOR VVAR STACK
    CAIN CH,ASCLPR ;CHECK FOR '('--SUBSCRIPTING
    JRST ARVR7 ;HANDLE IF SO
    JSP    T,ALVAR     ;ALLOCATE SPACE FOR NUMERIC VARIABLE
;
 ARVR3:
    TLNE   FG,STRBT    ;CHECK IF STRING EXPECTED
    ERR    E.MIX       ;ERROR IF SO
    TLO    FG,NUMBT    ;MARK AS NUMERIC
    TLO    FG,NCHBT    ;CURRENT CHARACTER TOO MUCH
;
 ARVR4:
    PUSH   VS,T0       ;SAVE THE ENTRY ON STACK
    TLO    FG,OPBT     ;MARK AS OPERATOR EXPECTED
    JRST   ARNXT       ;AND GO ON
;
 ARVR7:
    TLO T0,VTMAT ;MAKE INTO MAT FOR SBSCNG
    JRST ARVR3 ;AND DON'T ALLOC--JUST PROCESS
;
;
  SUBTTL ARITHMETIC SCAN ROUTINES--ARSVR
;
;   ARSVR--PROCESS A STRING VARIABLE
;
;
 ARSVR:
    HRLI   T0,VTSVR    ;GET STRING VARIABLE BITS IN T0 U
    JSP T,NXECH ;GET NEXT CHR
    CAIN CH,ASCLPR ;CHECK FOR '('
    JRST ARVR8 ;IF SO, PROCESS SUBSCRIPTING
    JSP    T,ALVAR     ;ALLOCATE SPACE FOR VARIALBE
;
 ARVR5:
    TLNE   FG,NUMBT    ;CHECK IF NUMERIC
    JRST   E.MIX       ;ERROR IF SO
    TLO    FG,STRBT+NCHBT    ;MARK AS STRING EXPRESSION
    JRST   ARVR4       ;AND SAVE THE VS ELEMENT
;
 ARVR8:
  TLO T0,VTMAT ;MARK AS MATRIX FOR SBSC
  JRST ARVR5 ;AND SKIP
;
;
  SUBTTL ARITHMETIC SCAN ROUTINES--ARMVR
;
;   ARMVR--PROCESS A MATRIX VARIABLE
;
;
 ARMVR:
    TLNE   FG,EQUBT    ;CHECK IF ASSIGNMENT
    JRST   ARMV2       ;HANDLE IF SO
    CAIL   T0,32       ;CHECK IF TWO LETTER VARRALBE
    ERR    E.MTNM      ;ERROR IF SO
    SETZM SBCERF	;DON'T FORCE DIMS
    MOVEI R2,2		;AND TWO DIMENSIONAL DEFAULT
    SKIPE PRIFG		;CHECK FOR MATPRINT
      MOVEI R2,1	;IMPLIES VECTOR
    SKIPE CHNGFG	;UNLESS CHANGE
      AOS R2,SBCERF	;THEN FORCE 1D DIMS
    MOVEM R2,XNSBCS	;LSAVE DIMS
    CAIN   CH,ASCDOL   ;CHECK FOR STRING MATRIX
    JRST   ARMV1       ;HANDLE IF SO
;
    HRLI   T0,VTMNR    ;GET BITS FOR NUMERIC
    PUSHJ P,ALMAT     ;ALLOCATE SPACE FOR MATRIX
    SETZM XNSBCS ;CLEAR NUM SBCS
    JRST   ARVR3       ;AND THE PROCESS AS NUMERIC
;
 ARMV1:
    HRLI   T0,VTMSR    ;GET VS BITS
    PUSHJ P,ALMAT     ;ALLOCATE SPACE FOR MATRIX
    SETZM XNSBCS ;CLEAR NUM SBCS
    JSP T,NXECH		;SCAN NEXT CHR (AFTER $)
    JRST   ARVR5       ;AND PROCESS AS STRING VARIABLE
;
 ARMV2:
    JRST   ARVR6       ;HANDLE MATRIX
;
;
  SUBTTL ARITHMETIC SCAN ROUTINES--ARXVR
;
;   ARXVR--HANDLE ONE LETTER VARIABLE IN FRONT OF TERMINATOR.
;
;
 ARXVR:
    SKIPN ALWTRM	;IS A TERM ALLOWED
    ERR E.UDFN		;NO--MUST BE UNDEFINED FUNCTION THEN
    LDB    T0,[POINT 7,T7,6] ;GET FIRST CHAR
    SUBI   T0,ASC..A   ;GET SYMBOL TABLE PTR
    TLNE   FG,STRBT ;CHECK FOR BAD TYPES
    ERR    E.MIX       ;ERROR IF FOUND
    TLO    FG,NUMBT    ;MARK AS NUMERIC
    TLNE FG,MATBT	;CHECK FOR MAT EXTRESSION
    JRST ARXV1		;HANDLE IF SO
    HRLI   T0,VTNVR    ;GET VS BITS
    JSP    T,ALVAR     ;ALLOCATE SPACE FO IT
;
 ARXV2:
    PUSH   VS,T0       ;SAVE ON VS STACK
    TLO FG,XVRBT	;MARK AS POSSIBLE UNDEFINED FUNCTION
    JRST   ARXTR       ;AND HANDLE SUBSEQUENT TERMINATOR
;
 ARXV1:
  HRLI T0,VTMNR		;MATRIX--NUMERIC TYPE
  PUSHJ P,ALMAT		;MAKE INTO MATRIX REALLY
  SETZM XNSBCS		;CLEAR REQUIRED NUMBER DIMS
  JRST ARXV2		;AND CONTINUE
;
;
  SUBTTL ARITHMETIC SCAN--ARTRM
;
;   ARTRM--THIS ROUTINE HANDLES A TERMINATOR STRING SUCH AS 'THEN'
;      OR 'STEP' OR 'TO' OR 'GOTO'.  IT SAVES THE TERMINATOR NUMBER
;      AS THE TERMINATOR FROM SCAN AND TRANSFERS TO AREXI TO EXIT THE
;      ARITHMETIC SCAN IF ONE IS FOUND.
;
;
 ARTRM:
    SKIPN ALWTRM ;SPECIAL TERMS ALLOWED
    JRST ARTR5A ;HANDLE IF NOT--ERROR
    MOVE   T2,[POINT 7,T7,6] ;GET TALLY IN T2
    MOVEI  T7,0        ;CLEAR ACCUMULATION WORD
    IDPB   CH,T2       ;AVE FIRST CHARACTER
    JSP    T,NXECH     ;GET SECOND CHAR
    CAIL   CH,ASC..A   ;CHECK FOR ALPHABETIC
    CAILE  CH,ASC..Z
    ERR    E.INFT      ;ERROR IF NOT
    IDPB   CH,T2       ;SAVE THE CHARACTER
    JSP    T,NXECH     ;GET THIRD CHARACTER
;
;LOOOK UP TERMINATOR
;
 ARXTR:
    LSH    T7,7        ;GET FIRST TWO CHARACTERS
    MOVEI  T1,NTRMS-2  ;NUMBER IN TABLE
    CAMN   T7,TRMNTB(T1) ;CHECK FOR MATCH
    JRST   ARTR1       ;HANDLE MATCH
    SOJGE  T1,.-2      ;SKIP BACK IF MORE
    ERR    E.INFT      ;ERROR IF NOT IN TABLE
;
 ARTR1:
    SETZM  T3          ;CLEAR COUNT
    MOVEI  T0,TRMSTB(T1) ;GET SPELLING INFO
    ADD    T0,[POINT 7,0,6] ;CREATE TALLY TO IT
    LDB    T2,T0       ;CHECK FIRST SPELLING CHAR
    JUMPE  T2,ARTR3    ;DONE SPELLING
;
 ARTR2:
    CAME   CH,T2       ;CHECK FOR CHARACTER MATCH
    JRST   ARTR4       ;HANDLEIF NOT MATCH
    AOS    T3          ;BUMP CHR COUNT
    ILDB   T2,T0       ;GET NEXT CHARACTER
    JSP    T,NXECH     ;AND NEXT CHAR FROM SOURCE
    JUMPN  T2,ARTR2    ;SKIP BACK IF MORE TO CHECK
;
;   TERMINATOR FOUND AND SPELLED
;
 ARTR3:
    TLO    FG,NCHBT    ;EXTRA CHARACTER SCANNED
    MOVE   T0,TRMOTB(T1) ;PICK UP TERMINATOR NUMBER
    MOVEM  T0,ARTERM   ;AND SAVE FOR EXIT
    ANDI T0,777 ;MASK TO GET TYPE OF TERM BIT
    TDNE T0,ALWTRM ;CHECK IF ALLOWED
    JRST   AREXX       ;AND EXIT ARITHMETIC SCAN
  TLNN FG,XVRBT		;CHECK IF POSSIBLE UNDEFINED FCT
    ERR E.INFT		;IF NOT, GIVE GENERAL MESSAGE
    ERR E.UDFN		;IF SO, TEL USER
;
;
 ARTR4:
    SKIPN  T3          ;CHECK IF FIRST CHR
    CAIE   T1,TRMGO    ;CHECK FOR 'GO'
    ERR    E.INFT      ;ERROR IF NO
    MOVEI  T1,TRMGSB   ;TRY GOSUB
    JRST   ARTR1       ;AND LOOP
;
 ARTR5A:
  MOVE R1,0(VS)		;GET TOP OF VS
  TLNE R1,VTSTR		;CHECK FOR CONSTANT
  TLNN R1,VTCON	;STRING THERE
    ERR E.INFT		;IF NOT, PLAIN OLD ERROR
 ARTR5:
  SKIPN PRIFG ;CHECK IF PRINT EXPRESSION OR NOT
    ERR E.INFT ;IF NOT, THEN JUST INCORRECT FORMAT
;
  IFE LEXN03,<ERR E.IPQT>	;QUOTE NOT ALLOWED AS PRINT DELIM
  IFN LEXN03,<
	MOVEM CH,PRIFG	;SAVE CHR FOR PRINT
 	MOVEI CH,ASCSEM	;FAKE A SEMICOLON
	JRST AREXI	;AND EXIT
  >
;
;
SUBTTL ARITHMETIC SCAN--TERMINATOR TABLE
;
;   TRMNTB--TABLE OF TERMINATOR NAMES
;
 TRMNTB:
    ASCII  /TO/
    ASCII  /TH/
    ASCII  /ST/
 TRMNGO:
    ASCII  /GO/
    ASCII  /BI/
    ASCII  /WI/
    ASCII  /SY/
 TRMNGS:
    ASCIZ  /GO/
;
;   TRMSTB--TABLE OF TERMIAATOR CONTINUED SPELLINGS
;
 TRMSTB:
    ASCII  //          ;TO
    ASCII  /EN/        ;THEN
    ASCII  /EP/        ;STEP
    ASCII  /TO/        ;GO TO
    ASCII  /T/         ;BIT
    ASCII  /TH/        ;WITH
    ASCII  /STEM/      ;SYSTEM
    ASCIZ /SUB/    ;GOSUB
;
;   TRMOTB--TABLE OF TERMINATOR OUTPUT CODES
;
 TRMOTB:
    XWD    0,TRTO      ;TO
    XWD    0,TRTHEN    ;THEN
    XWD    0,TRSTEP    ;STEP
    XWD    0,TRTHEN    ;GO TO
    XWD    0,TRBIT     ;BIT
    XWD    0,TRWITH    ;WITH
    XWD    0,TRSYST    ;SYSTEM
    XWD    0,TRGOSB    ;GOSUB
;
    NTRMS== .-TRMOTB   ;NUMBER OF TERMINATORS
;
    TRMGO== TRMNGO-TRMNTB ;GOTO
    TRMGSB== TRMNGS-TRMNTB ;GOSUB
;
;
  SUBTTL ARITHMETIC SCAN--ARFCT
;
;   ARFCT--THIS ORUTINE IS ENTERED WHEN A TWO LETTER VARIABLE IS FOUND
;      AND THEREFORE A FUNCTION NAME OR CALL IS EXPECTED.  THIS
;      ROUTINE CHECKS FOR USER OR MACHINE FUNCTION AND PROCESSES
;      IT ACCORDINGLY
;
;
 ARFCT:
    IDPB   CH,T2       ;SAVE SECOND CHARACTER
    CAMN   T7,[ASCII /FN/] ;CHECK FOR USER FCT
    JRST   ARUFC       ;HANDLE USER FUNCTIONS
    JSP    T,NXECH     ;GET THIRD CHAR
;
 ARFC3:
    CAIL   CH,ASC..A   ;CHECK FOR ALPHABETIC
    CAILE  CH,ASC..Z
    ERR    E.VAR       ;ILLEGAL VARIALBE IF THIRD NOT ALPHABETIC
    IDPB   CH,T2       ;SAVE HIRD CHARACTER
    JSP    T,NXECH     ;GET NEXT CHARACTER
    CAIN   CH,ASCDOL    ;CHECK FOR STRING FUNCTION
    JRST   ARFC1       ;HANDLE IF SO
    TLO    FG,NCHBT    ;IF NOT, WE SCANNED PAST WHAT WE WANTED
    CAMN T7,[ASCII /TRN/]	;CHECK FOR TRN FCT
    JRST ARFC2		;MAY BE EITHER STRING/NUMERIC
    TLNE   FG,STRBT    ;CHECK EXPRESSION TYPE
    ERR    E.MIX       ;ERROR IF BAD
    TLO    FG,NUMBT    ;SET EXPRESSION TYPE NUMERIC
;
 ARFC2:
    TLNE   FG,MATBT    ;CHECK IF MAT
    JRST   ARMFC       ;HANDLE MAT FCTS
    CAMN   T7,[ASCIZ /ASC/] ;CHECK FOR 'ASC'
    JRST   ARASC       ;PROCESS IF SO
    MOVEI  T1,FCTLN-1  ;***LOOK UP FUNCTION IN TABLE
    CAMN   T7,FCTNTB(T1)
    JRST   ARIFC       ;IF FOUND--PROCESS
    SOJGE  T1,.-2      ;LOOK FOR MORE IF NOT
    TLNN   FG,PRIBT+CNDBT    ;SKIP IF PRINT EXPRESSION
    JRST   ARXVR       ;HANDLE POSSIBLE VARIABLE-TERMINATOR SEQUEENCE
  TLNN FG,PRIBT ;CHECK IF PRINT
  JRST ARCFA ;HANDLE CONDITIONAL
;
 ARFC4:
    CAMN   T7,[ASCII /USI/] ;CHECK FOR PRINT TERMINATORS--USING
    JRST   ARPFB       ;HANDLE USING
    MOVEI T1,NPFCT-1 ;CHECK FOR PRINT FCTS
    CAMN T7,PFCNTB(T1) ;IN TABLE
    JRST ARPFA ;HANDLE IF FOUND
    SOJGE T1,.-2 ;LOOP IF NOT
    JRST   ARXVR       ;ELSE TRY SOMETHING ELSE
;
 ARFC1:
    IDPB   CH,T2       ;SAVE '$' FOR STRING FUNCTINS
    TLNE   FG,NUMBT    ;CHECK EXPRESSION TYPE
    ERR    E.MIX       ;ERROR IF NOT STRING
    TLO    FG,STRBT    ;SET TO STRING
    JRST   ARFC2       ;AND PROCESS FUNCTIN
;
;   HANDLE TAB FUNCTION
;
 ARPFA:
    AOS    0(P)       ;BUMP RETURN FOR TAB
    ADDI T1,FCTLN+NMFCT ;MAKE INTO REAL FCT NUMBER
    JRST   ARIFC       ;PROCESS FUNCTION
;
;   HANDLE 'USING' IN PRINT
;
 ARPFB:
    CAIE   CH,ASC..N   ;USI'NG
    ERR    E.ILST
    JSP    T,NXECH
    CAIE   CH,ASC..G   ;G
    ERR    E.ILST
    POP P,T1 ;GET RETURN IN T1
    JRST   2(T1)       ;AND RETURN SPECIAL FOR PRINT USING
;
;
;   HANDLE MAT FUNCTIONS
;
 ARMFC:
    SKIPE PRIFG		;CHECK FOR MAT PRINT
    JRST ARFC4		;ONLY PRINT FCTS ALLOWED
    TLNE   FG,EQUBT    ;CHECK EXP TYPE
    ERR    E.ILMT      ;CAN'T BE ON LEFT OF EQUALS SIGN
    MOVEI  T1,NMFCT-1  ;NUM OF MAT FCTS
    CAMN   T7,MFCNTB(T1) ;CHECK FOR MATCH
    JRST   ARMF1       ;FOUND
    SOJGE  T1,.-2      ;KEEP LOOKING
    SKIPN ALWTRM	;DELIMITER ALLOWED?
    ERR E.ILMFC		;NO--ERROR
    JRST ARXVR		;YES--TRY MATCHING IT
;
 ARMF1:
    POP    OS,T0       ;GET LAST OP
    TLNN   T0,PR.EQU   ;CHECK FOR =
    ERR    E.ILMT      ;ELSE ERROR
    ADDI   T1,FCTLN    ;GET DUMMY FUNCTION NUMBER
    JRST   ARIFC       ;AND PROCESS
;
;
;   HANDLE CONDITIONAL UNDEFS (IF END, IF MORE
;
ARCFA:
  CAMN T7,[ASCII /END/] ;CHECK FOR IF END
  JRST ARCNFC ;HANDLE
  CAME T7,[ASCII /MOR/] ;CHECK FOR IF MORE
  JRST ARXVR ;NO--CHECK FOR SPECIAL VAR-TERM
;
  CAIE CH,ASC..E ;IFMOR'E
  ERR E.ILST ;ERROR IF NOT
  JSP T,NXECH ;GET NEXT CHR
  SKIPA T1,MOROP ;GET OF FOR IFEND
;
 ARCNFC:
  MOVE T1,ENDOP ;GET OP FOR IF MORE
;
  CAIE CH,ASCNUM ;CHECK FOR #
  ERR E.INFT ;ERROR IF NOT
  TLNE FG,OPPBT+CNPBT+STRBT ;MAKE SURE LEGAL
  ERR E.INFT ;ERROR IF NOT
  TLZ FG,NCHBT+OPBT+CNDBT ;IGNORE #, MISC
  TLO FG,OPPBT+NUMBT ;SCAN NUMERIC EXP
  PUSH OS,T1 ;SAVE OP ON STACK
  JRST ARNXT ;AND DONE
;
;
  SUBTTL ARITHMETIC SCAN--ARASC
;
;   ARASC--THIS HANDLES THE ASCII FUNCTION, WHICH IS HANDLED VERY SPECIAL
;      BY THE COMPILER.  IF THE ARGUMENT IS A SINGLE CHARACTER, IT IS USED
;      DIRECTLY, ELSE A NAME MATCH IS PERFORMED..
;
;
 ARASC:
    CAIE   CH,ASCLPR   ;CHECK FOR '('
    ERR    E.INFT      ;WHICH MUST BE PRESENT
    JSP    T,NXCH      ;GET NEXT REAL CHARACTER
;
 ARASC9:
    MOVE   T1,CH       ;SAVE THE CHAR
    CAIGE  CH,ASC..A   ;CHECK FOR ALHPABETIC
    JRST   ARASC1      ;NO--HANDLE AS SPECIAL
    CAILE  CH,ASC..Z
    JRST   ARASC5      ;>ALPHABETIC--CHECK FOR LOWER CASE
;
 ARASC7:
    MOVE T4,T1 ;CLEAR T4 (ACCUMULATION)
    MOVEI  T3,0        ;SAVE FLAG FOR >1 CHAR
;
 ARASC3:
    JSP    T,NXECH     ;GET NEXT CHARACTER
    CAIN   CH,ASCRPR   ;CHECK FOR ')'
    JRST   ARASC2      ;IF SO, HANDLE DONE WORD SCAN
    ADDI  T3,1        ;ELSE MARK AS >1 CHAR
    LSH T4,7 ;MAKE ROOM FOR NEXT CHR
    ADD T4,CH ;PUT IT IN WORD
    JRST   ARASC3      ;AND GO BACK FOR MORE
;
 ARASC2:
    JUMPE  T3,ARAS2A   ;IF ZERO CHARACTER, HANDLE AS SPECIAL
  LSH T4,17 ;ELSE POSITION WORD
    MOVEI  T1,ASCTBL   ;ELSE GET POINTER TO ASCI TABLE
    MOVE T2,ASCTB-1(T1) ;GET TABLE ENTRY
    AND T2,[777777700000] ;LOOK AT NAME IN THERE
    CAMN T4,T2 ;CHECK IF NAMES MATCH
    JRST   ARASC4      ;HANDLE MATCH
    SOJG   T1,.-4      ;LOOK FOR MORE
    ERR    E.ASC       ;ERROR IF NO MATCH FOUND
;
 ARAS2A:
  MOVE T1,T4 ;GET SINGLE CHR VALUE
  JRST ARASC6 ;AND USE IT
;
 ARASC4:
  MOVE T1,ASCTB-1(T1) ;GET VALUE
  ANDI T1,77777 ;MASK TO GET IT ONLY
    JRST   ARASC6
;
;   HANDLE SPECIAL VARIALBE
;
 ARASC5:
    CAILE  CH,ASCLCA   ;CHECK FOR LOWER CASE
    JRST   ARASC1      ;HANDLE IF NOT
    CAIGE  CH,ASCLCZ
    JRST   ARASC1
    SUBI   CH,ASCLCA-ASC..A ;TREAT AS UPPER CASE IF SO
    JRST   ARASC7      ;AND PROCESS
;
 ARASC1:
    JSP    T,NXECH     ;LOOK AT NEXT CHARACTER
    CAIE   CH,ASCRPR   ;FOR ')'
    JRST   ARASC8      ;BETTER BE EXCESS SPACE IF NOT
;
 ARASC6:
    FSC    T1,233       ;FLOAT THE RESULTANT NUMBER
    TLZ    FG,NCHBT    ;EXTRA CHARACTER NOT SCANNED
    TLO FG,OPBT ;OP EXPECTED NEXT
    MOVE   R2,T1       ;GET NUMBER FOR PROCESSING
    JRST   ARNASC       ;AND TREAT LIKE CONSTANT
;
 ARASC8:
    CAIE   T1,ASC.SP   ;SINGLE SPECIAL CHAR BETTER BE SPACE
    ERR    E.ASC       ;ERROR IF NOT
    JRST   ARASC9      ;IGNORE IF SO
;
;
SUBTTL ARITHMETIC SCAN--ASCT (TABLE
;
;   ASCTB--TALBE OF SPECIAL 'ASC' NAMES
;
 ASCTB:
    ASCT (NUL)
    ASCT (SOH)
    ASCT (STX)
    ASCT (ETX)
    ASCT (EOT)
    ASCT (ENQ)
    ASCT (ACK)
    ASCT (BEL)
    ASCT (BS,.)
    ASCT (HT,.)
    ASCT (LF,.)
    ASCT (VT,.)
    ASCT (FF,.)
    ASCT (CR,.)
    ASCT (SO,.)
    ASCT (SI,.)
    ASCT (DLE)
    ASCT (DC1)
    ASCT (DC2)
    ASCT (DC3)
    ASCT (DC4)
    ASCT (NAK)
    ASCT (SYN)
    ASCT (ETB)
    ASCT (CAN)
    ASCT (EM,.)
    ASCT (SUB)
    ASCT (ESC)
    ASCT (FS,.)
    ASCT (GS,.)
    ASCT (RS,.)
    ASCT (US,.)
    ASCT (SP,.)
;
    ASCT (UND)
    ASCT (BKR)
    ASCT (GRA)
    ASCT (LCA)
    ASCT (LCB)
    ASCT (LCC)
    ASCT (LCD)
    ASCT (LCE)
    ASCT (LCF)
    ASCT (LCG)
    ASCT (LCH)
    ASCT (LCI)
    ASCT (LCJ)
    ASCT (LCK)
    ASCT (LCL)
    ASCT (LCM)
    ASCT (LCN)
    ASCT (LCO)
    ASCT (LCP)
    ASCT (LCQ)
    ASCT (LCR)
    ASCT (LCS)
    ASCT (LCT)
    ASCT (LCU)
    ASCT (LCV)
    ASCT (LCW)
    ASCT (LCX)
    ASCT (LCY)
    ASCT (LCZ)
    ASCT (LBR)
    ASCT (VLN)
    ASCT (RBR)
    ASCT (TIL)
    ASCT (DEL)
;
    ASCTBL== .-ASCTB
;
;
;
;
    PRINTX *****START OF BAS21*****
;
;
;
  SUBTTL ARITHMETIC SCAN--ARNUM
;
;   ARNUM--THIS ROUTINE IS USED FOR CONSTRUCTING ARITHMETIC CONSTANTS
;      AT COMPILE TIME.  IT IS CALLED WHEN A DIGIT OR A DECIMAL POINT
;      IS FOUND AS THE NEXT CHARACTER.
;
;   IT CONSTRUCTS THE PROPER FLOATING POINT CONSTANT AND THEN STORES IT
;      IN THE CONSTANT BUFFER.  LATER, WHEN THE CONSTANT IS TO BE USED,
;      A DECISION IS MADE AS TO WHETHER TO USE IT HALF WORD OR FULL
;      WORD.  MOREOVER, PUTTING IT IN A BUFFER, ALLOWS MULTIPLE CON-
;      STANTS TO BE MERGED (1+2==3) WITHOUT COMPILING ANY EXTRA CODE
;      OR CONSTANTS.
;
;   THIS ROUTINE ASSIGNS SPECIAL NAMES TO THE REGISTERS FOR DESCRIPTIVE
;      PURPOSES.  THEY ARE:
;
 ARNUM:
    TLOE FG,OPBT ;CHECK FOR OP NOT EXPECTED
    JRST ARTR5A ;WAS--ERROR
    TLNE   FG,STRBT    ;CHECK FOR STRING EXP
    ERR    E.MIX       ;CAN'T BE
    TLO    FG,NUMBT    ;MAKE SURE NUMERIC
;
    SETOM  T4          ;EXPONENT FLAG
    SKIPA  T2,NUMTL    ;TALLY TO NUMBER AREA
;
;   COPY SOURCE TO STRING
;
 ARNMD:
    JSP    T,NXECH     ;GET NEXT CHAR
;
 ARNME:
    CAIGE  CH,ASC..0   ;CHECK FOR DIGIT
    JRST   .+3         ;SKIP IF NOT
    CAIG   CH,ASC..9   ;CHECK AGAIN
    JRST   ARNMA       ;HANDLE DIGITS
    CAIN   CH,ASCDOT   ;CHECK FOR DECIMAL POINT
    JRST   ARNMA       ;OK IF SO
    CAIN   CH,ASC..E   ;CHECK FOR 'E'
    JRST   ARNMB       ;HANDLE IF SO
    JRST   ARNMC       ;ELSE END OF NUMBER
;
 ARNMA:
    IDPB   CH,T2       ;SAVE THE NEW CHAR
    JRST   ARNMD       ;AND CONTINUE
;
 ARNMB:
    AOJN   T4,ARNMC    ;SET FLAG INDIC EXP ON CHECK
    IDPB   CH,T2       ;SAVE THE EXPONENT CHAR
    JSP    T,NXECH     ;GET NEXT CHAR
    CAIE   CH,ASCPLU   ;CHECK FOR '+'
    CAIN   CH,ASCMIN   ;OR '-'
    JRST   ARNMA       ;OK IF SO
    JRST   ARNME       ;ELSE CHECK IT
;
 ARNMC:
    MOVEI  T0,0        ;END OF STRING
    IDPB   T0,T2       ;SAVE
    MOVE   R1,NUMTL    ;INIT TALLY
    FLIN               ;GET NUMBER
    ERR    E.ILCN      ;ERROR IF BAD
;
;
;   SAVE CONSTANT
;
    TLO    FG,CNPBT+NCHBT ;MARK AS CONSTANT PRESENT
    TLZ FG,XEQBT	;CAN'T HAVE EQUALS OP  NOW
;
 ARNASC:
    HRLZI  T4,PR.UNI   ;CHECK FOR UNARY OPERATOR ON STACK
    TDNN   T4,0(OS)
    JRST   ARNM4       ;NOT THERE
    POP    OS,T4       ;GET THE UNARY OP OFF STACK
    CAME   T4,UOPTB    ;CHECK FOR UNARY MINUS
    MOVNS  R2          ;NEGATE THE NUMBER IF SO
;
 ARNM4:
    IDPB   R2,CONPT    ;SAVE THE CONSTANT IN THE SPECIAL BUFFER
    HRRZ   T1,CONPT    ;GET ADDRESS IN BUFFER
    CAIL T1,CONBND ;CHECK IF BUFFER OVERFLOW
    ERR E.TOCN ;ERROR IF SO
    HRLI   T1,VTNUM+VTCON ;GET BITS FOR VAR STACK
    PUSH   VS,T1       ;SAVE ON VARIABLE STACK
    JRST   ARNXT       ;AND DONE
;
;
;
;
  SUBTTL ARITHMETIC SCAN--ARSTR
;
;   ARSTR--THIS ROUTINE HANDLES A STRING CONSTANT.  IT IS CALLED WHEN
;     A QUOTE IS FOUND.  IT THEN SCANS THE REST OF THE STRING CONSTANT
;      AND STICKS IT IN THE CONSTANT AREA FOR OUTPUT.
;
;
 ARSTR:
    TLOE FG,OPBT ;CHECK IF OP EXPECTED AND SET TO EXPECT ONE
    JRST ARTR5 ;MUST NOT BE EXPECTED--ELSE ERROR
    TLNE   FG,NUMBT+MATBT ;CHECK FOR STRING EXPRESSION
    ERR    E.MIX       ;ERROR  IF NOT
    TLO    FG,STRBT    ;MARK AS SUCH
    TLZ    FG,NCHBT+XEQBT    ;HAVEN'T SCANNED CHAR YET
    PUSHJ P,DMSTR       ;SCAN THE STRING
    EXP    ASCQTE      ;TERM ON QUOTE
;
    HRLI   T5,VTSCN ;STRING CONSTANT
    PUSH   VS,T5       ;SAVE IT
    CAIE   CH,ASCQTE   ;CHECK FOR " TERMINATOR
    ERR    E.NQT       ;ERROR IF NOT
    TLZ    FG,NCHBT    ;IGNORE QUOTE
    JRST   ARNXT       ;AND CONTINUE
;
;
;
  SUBTTL ARITHMETIC SCAN--AROP
;
;   AROP--THIS ROUTINE HANDLES + AND - BY DECIDING WHETHER THEY ARE
;      UNARY OR BINARY OPERATORS.  IF BINARY, CONTROL IS PASSED TO
;      'ARBOP'.  IF UNARY, THIS ROUTINE, ENTYR ARUOP,
;      PROCESSES THEM.
;
;
 AROP:
    TLNE   FG,OPBT     ;CHECK IF OPERATOR EXPECTED
    JRST   ARBOP       ;HANDLE IF SO--BINARY
;
 ARUOP:
    TLNE   FG,STRBT+MATBT ;CHECK IF NUMERIC EXPRESSION
    ERR    E.OPNA      ;ERROR IF NOT
    TLO    FG,NUMBT    ;MARK AS NUMERIC
    HLRZ   T0,ARCHTB(CH) ;GET OP NUMBER
    LSH    T0,-4-1     ;ALONE
    ANDI   T0,17
    MOVE R1,0(OS) ;GET OP
    TLNE R1,PR.UNI ;CHECK FOR UNARY
    ERR E.INFT ;ERROR IF SO
    MOVE   T1,UOPTB-1(T0) ;GET UNARY OPERATOR WORD
    TLO    FG,OPPBT    ;MARK OP AS PRESENT
    JRST   ARXPOP      ;AND PROCESS OPERATOR
;
;
  SUBTTL ARITHMETIC SCAN--ARBOP
;
;   ARBOP--THIS ROUTINE PROCESSES A BINARY OPERATOR.  'ABSBOP' IS THE ENTRY
;     FOOR STRING BINARY OPERATORS, 'ARBOP' IS THAT FOR NUMERIC ONES.
;
;
 ARBOP:
    TLNN   FG,NUMBT    ;CHECK FOR NUMERIC EXPRESSION
    ERR    E.MIX       ;ERROR IF NOT
;
 ARBP1:
    TLZN   FG,OPBT     ;CHECK IF OPERATOR EXPECTED
    ERR    E.INFT      ;ERROR IF NOT
    TLO    FG,OPPBT    ;OPERATRO PRESENT
    HLRZ   T0,ARCHTB(CH) ;GET OP # FROM REG FIELD
    LSH    T0,-4-1     ;TO L
    ANDI   T0,17       ;ALONE
    MOVE   T1,BOPTB-1(T0) ;GET OPERATOR WORD
    JRST   ARXPOP      ;AND PROCESS
;
;
 ARSBOP:
    TLNN   FG,STRBT    ;CHECK FOR STRING EXPRESSION
    ERR    E.OPNA      ;ERROR IF NOT
    JRST   ARBP1       ;PROCESS IF SO
;
;
  SUBTTL ARITHMETIC SCAN--ARCOP
;
;   ARCOP--THIS ROUTINE HANDLES A CONDITIONAL OPERATOR.  A CONDITIONAL
;      CONSISTS ON ONE OR TWO OF (=,<,>).  FROM THE SET OF THOSE GIVEN,
;      A OP STACK WORD IS FOUND AND USED.
;
;
 ARCOP:
    TLZE   FG,OPBT     ;CHECK IF OPERATOR EXPECTED
    TLZN   FG,CNDBT    ;AND CONDITIONAL ALLOWED
    ERR    E.OPNA      ;ERROR ON EITHER COUNT
    TLO    FG,OPPBT    ;OPERATOR PRESENT
;
    MOVE   T1,CH       ;GET FIRST CHAR
    SUBI   T1,ASC.LT-1 ;TO 1,2, OR 3 (< = >)
    CAIN   T1,3        ;CHECK BOUNDS
    MOVEI  T1,4        ;CHANGE > TO 4
    JSP    T,NXECH     ;GET NEXT CHAR
    MOVEI  T2,-ASC.LT+1(CH) ;GET 1,2 OR 3 IN T2
    JUMPLE T2,ARCP1    ;HANDLE IF NOT <>=
    CAILE  T2,3
    JRST   ARCP1
    CAIN   T2,3        ;CHECK FOR >
    MOVEI  T2,4        ;MAKE 3 TO 4 (FOR BITS)
    TDNE   T1,T2       ;CHECK FOR DUPLICATE == << >> ETC
    ERR    E.INFT      ;ERROR IF SO
    IOR    T2,T1       ;ELSE SAAE COMBINATION
    MOVE   T1,COPTB(T2) ;GET OPER WORD
    JRST   ARPOP       ;AND PROCESS
;
 ARCP1:
    TLO    NCHBT       ;EXTRA CHAR SCANNED
    MOVE   T1,COPTB(T1) ;GET PROPER OP WORD
    JRST   ARPOP       ;AND PROCESS
;
;
  SUBTTL ARITHMETIC SCAN--OPERATOR TABLES
;
;
;   UOPTB--UNARY OPERATORS
;
 UOPTB:
    XWD    PR.UNI,PN.UPL ; +
    XWD    PR.UNI,PN.UMI ; -
;
;
;   BOPTB--BINARY OPERATORS
;
 BOPTB:
    XWD    PR.PLU,PN.PLU ; +
    XWD    PR.MIN,PN.MIN ; -
    XWD    PR.MUL,PN.MUL ; 0
    XWD    PR.DIV,PN.DIV ; /
    XWD    PR.EXP,PN.EXP ; ^
    XWD    PR.AMP,PN.AMP ; &
;
;
;   COPTB--CONDITIONAL OPERATORS
;
 COPTB:
    XWD    0,0
    XWD    PR.REL,PN.RLT ;1=.LT. <
    XWD    PR.REL,PN.REQ ;2=.EQ. =
    XWD    PR.REL,PN.RLE ;3=.LE. <=
    XWD    PR.REL,PN.RGT ;4=.GT. >
    XWD    PR.REL,PN.RNE ;5=.NE. <>
    XWD    PR.REL,PN.RGE ;6=.GE. >=
    XWD    0,0
;
;
;   OPEQU--ASSIGNMENT
;
 OPEQU:XWD PR.EQU,PN.EQU ; =
;
;
;   FILE OPS
;
 ENDOP:
  XWD PR.IMR,PN.END ;IF END
MOROP:
  XWD PR.IMR,PN.MOR ;IF MORE
;
;
  SUBTTL ARITHMETIC SCAN--AREQU
;
;   AREQU--THIS ROUTINE HANDLES '=' .  IF ASSIGNMENT IS IMPLIED, THEN
;      THIS OPERATOR IS STACKED, ELSE THE '=' IS ASSUMED TO BE COND-
;      ITIONAL.
;
;
 AREQU:
    TLZE   FG,EQUBT    ;CHECK IF '=' EXPECTED
    TLO    FG,XEQBT    ;IF FIRST TIME UNMARK AS SUCH
    TLNN   FG,XEQBT    ;CHECK IF ASSIGNMENT ALLOWED
    JRST   ARCOP       ;NO--PPOCESS AS CONDITIONAL
;
    TLZN   FG,OPBT     ;MAKE SURE OPERATOR EXPECTED
    ERR    E.INFT      ;ERROR IF NOT
    MOVE   T1,OPEQU    ;GET OP STACK WORD
    JRST   ARPOP       ;AND PROCESS
;
;
  SUBTTL ARITHMETIC SCAN--ARPOP
;
;   ARPOP--THIS ROUTINE IS CALLED WITH AN OP STACK WORD IN T1.  IT DECIDES
;      WHETHER TO POP THE TOP ELEMENT OF THE STACK IN ITS FAVOR OR NOT.
;      IN ANY CASE, IT PERFORMS ALL STACKED OPERATIONS TO BE POPPED AND
;      ENDS UP BY PLACING THE NEW OPERATOR ON THE STACK.
;
;
 ARPOP:
    TLZ FG,CALBT ;NO LONGER ACCEPT CALL TYPE ARGS
    HLLZ   T0,T1       ;GET PRIORITY BIT
    SOS    T0          ;GET ALL LOWER BITS TURNED ON
    HLLZS  T0          ;GET RID OF BOTTOM BITS
;
 ARPP2:
    TDNE   T0,0(OS)    ;CHECK TO POP
    JRST   ARPP1       ;NO--PUSH AND EXIT
    TLNN   T1,RASOPS   ;CHECK IF RIGHT ASSOCIATIVE
    JRST   .+3         ;SKIP IF NOT
    CAMN   T1,0(OS)    ;IF SO, CHECK IF SAME
    JRST   ARPP1       ;IF SO, THEN DON'T POP
    PUSHJ P,DONXT     ;DO NEXT OPERATION
    JRST   ARPP2       ;AND CHECK AGAIN
;
 ARPP1:
    PUSH   OS,T1       ;SAVE NEW OP ON STACK
    JRST   ARNXT       ;AND DONE
;
;   ENTER HERE FOR NON-CONDITIONAL OPERATOR
;
 ARXPOP:
    TLNE   FG,EQUBT    ;CHECK IF EQUALITY
    ERR    E.INFT      ;ERROR IF ASSIGNMENT DESIRED
    TLZ    FG,XEQBT    ;ASSIGNMENT NOT LEGAL
    JRST   ARPOP       ;AND CONTINUE
;
;
;
  SUBTTL ARITHMETIC SCAN--ARLPR
;
;   ARLPR--THIS ROUTINE PROCESSES A LEFT PARENTHESIS EITHER AS A DUMMY
;     OPERATOR OR AS A FUNCTION/SUBSCRIPTING CALL LIST
;
;
 ARLPR:
    TLNE   FG,OPBT     ;CHECK IF OPERATOR EXPECTED
    JRST   ARLP1       ;YES--FUNCTION/SBSC LIST
    TLNE   FG,EQUBT    ;CHECK IF ASSIGNMENT
    ERR    E.INFT      ;ERROR IF SO
    TLZ    FG,XEQBT    ;ASSIGNMENT ILLEGAL
    PUSH   OS,FG       ;YES--PUSH FLOAG BITS
    HRLI   T1,PR.LPR   ;GET PRIORITY
    PUSH   OS,T1       ;SAVE DUMMY WORD
    TLZ    FG,SAVBTS   ;RESET BITS FOR INSIDE PARENS
    IFN LEXN02,<TLO FG,XEQBT>	;ALLOW EQUALS IF MULTIPLE ALLOWED
    JRST   ARNXT       ;AND GO ON TO NEXT CHARACTER
;
 ARLP1:
    HLLZ   T1,0(VS)    ;FCT/SBSC--CHECK ITEM ON VS
    TLNE   T1,VTFC0+VTFCT ;CHECK FOR FUNCTION
    JRST   ARFCL       ;PROCESS IF FUNCTION CALL
    TLNN T1,VTMAT ;CHECK IF SBSC ING
    ERR E.INFT ;INCORRECT FORMAT IF NOT
    JRST ARPMT ;HANDLE IF SO
;
;
  SUBTTL ARITHMETIC SCAN--ARRPR
;
;   ARRPR--THIS ROUTINE PROCESSES A RIGHT PARENTHESIS.  IT CHECKS
;      IF THE PAREN IS FOR FCT/SBSC LIST AND PROCESSES
;      IT IF SO.  OTHERWISE, IT POPS UNTIL THE LAST LEFT PAREN.
;
;
 ARRPR:
    TLNE   FG,FCSBBT   ;CHECK IF FCT/SBSC
    JRST   ARCMA       ;PROCESS IF SO
;
    HRLZI  T0,PR.LPR   ;ELSE POP TO LEFT PAREN
;
 ARRPR2:
    TDNE   T0,0(OS)    ;CHECK IF '('
    JRST   ARRPR1      ;YES--DONE
    PUSHJ P,DONXT     ;YES--POP NEXT OFF STACK
    JRST   ARRPR2      ;AND TRY AGAIN
;
 ARRPR1:
    PUSHJ P,GTLOD     ;GET ITEM LOADABLE
    POP    OS,T1       ;POP THE LEFT AREN
    POP    OS,T1       ;POP THE FLAGS
    TLZ    T1,-1-SAVBTS ;MASK SAVED ONES
    OR     FG,T1       ;RSTORE BITS
    JRST   ARNXT       ;AND DONE
;
;
  SUBTTL ARITHMETIC SCAN--ARIFC
;
;   ARIFC--HANDLE AN INTERNAL (PREDEFINED) FUNCTION CALL.  THIS ROUTINE
;      SETS UP THE VARIABLE STACK FOR A PREDEFINED FUNCTION OF NO ARGS
;      AND OF THE PROPER TYPES.
;
;
 ARIFC:
    LSH T1,2        ;GET POINTER TO 4 WD TABLE
    MOVEI  T1,FCTATB(T1) ;GET TABLE POINTER
    MOVE   T2,FCIDWD(T1) ;GET ARG RTP ENTRY POINTER
    TLNE   T2,004000   ;CHECK FOR STRING FCT
    JRST   ARFCB       ;PROCESS AS SUCH
;
 ARFCA:
    HRLI   T1,VTFC0+VTNUM ;FUNCTION TYPE FOR NUMERIC FCT
    PUSH   VS,T1       ;PUSH IT
    TLO    FG,OPBT     ;OPERATOR EXPECTED
    IFN LEXN02,<TLO FG,XEQBT>	;ALOW EQUALS IF MULTIPLE ALLOWED
    JRST   ARNXT       ;AND DONE
;
 ARFCB:
    HRLI   T1,VTFC0+VTSTR ;FUNCTION TYPE FOR STRING FUNCTION
    JRST   ARFCA+1     ;HANDLE LIKE NUMERIC
;
;
  SUBTTL ARITHMETIC SCAN--ARUFC
;
;   ARUFC--HANDLE A USER FUNCTION NAME.  DECIDE IF IT IS A NAME OR A CALL
;      AND EITHER PROCESS AS VARIABLE OR AS FUNCTION CALL.
;
;
 ARUFC:
    JSP    T,NXECH     ;GET THIRD CHAR OF NAME (HAVE 'FN')
    CAIL   CH,ASC..A   ;CHECK FOR LETTER
    CAILE  CH,ASC..Z
    JRST   ARFC3       ;JUMP BACK INTO 'ARFCT' IF NOT
;
    IDPB   CH,T2       ;SAVE THIRD CHAR
    MOVEI  T0,-ASC..A(CH) ;GET NUMBER IN T0
    MOVE   T1,T0       ;GET NUMBER IN T1
    ADDI   T1,UFCATB(T0) ;GET ENTRY IN UFCATB (2 WD ENTRYS)
    HRLI   T0,VTNVR    ;GUESS NUMERIC VAR
    JSP    T,NXECH     ;GET FOURTH CHAR
    CAIE   CH,ASCDOL   ;CHECK FOR '$'
    JRST   ARUF1       ;HANDLE IF NOT
    IDPB   CH,T2       ;SAVE '$' AS PART OF NAME
    TLNE   FG,NUMBT+MATBT ;CHECK TYPE FOR STRING
    ERR    E.MIX       ;BAD
    TLO    FG,STRBT    ;MARK AS STRING EXPRESSION
;
    TLZ FG,NCHBT ;NOT SCANNED NEXT CHR
    HRLI   T0,VTSVR    ;STRING VAR
    ADDI   T1,64       ;RELOCATE TABLE POINTER
    CAMN   T0,CURFCT    ;CHECK IF SAME AS CURRENT FCT
    JRST   ARUFN       ;HANDLE IF NAME
    JRST   ARFCB       ;HANDLE IF STRING FUNCTION CALL
;
 ARUF1:
    TLO    FG,NCHBT    ;EXTRA CHAR SCANNED
    TLNE   FG,STRBT+MATBT ;LEGAL EXPRESSION???
    ERR    E.MIX       ;NO
    TLO    FG,NUMBT    ;MARK AS NUMERIC EXPRESISION
    CAMN   T0,CURFCT    ;CHECK IF SAME AS CURRENT
    JRST   ARUFN       ;HANDLE NAME
    JRST   ARFCA       ;PROCESS AS FUNCTION IF NOT SAME
;
;
  SUBTTL ARITHMETIC SCAN--ARUFN
;
;   ARUFN--HANDLE USER FUNCTION NAME.  WE HAVE WHAT WE THINK IS A
;     FUNCTION NAME ARGUMENT AND WANT TO TREAT AS A VARIABLE.
;
;
 ARUFN:
    TLON   FG,NCHBT    ;EXTRA CHARACTER SCANNED
    JSP    T,NXECH     ;MAKE SURE
    CAIN   CH,ASCLPR   ;CHECK FOR '('
    JRST ARUFN1 ;THEN IT MUST BE A CALL
    ADDI   T0,414+32      ;GET SYMBOL NUMBER
    TLNN   T0,VTSTR    ;CHECK IF STRING
    JRST   ARVR3       ;HNDLE NUMERIC
    JRST   ARVR5       ;HANDL STRING
;
 ARUFN1:
  TLNN T0,VTSTR ;CHECK IF STRING FCT
  JRST ARFCA ;HANDLE NUMERIC
  JRST ARFCB ;HANDLE STRING
  SUBTTL ARITHMETIC SCAN--ARFCL
;
;   ARFCL--ROUTINE TO HANDLE FUNCTION CALL.  THIS ROUTINE IS ENTERED WITH
;      A LEFT PARENTHESIS WHICH REPRESENTS A FUNCTION ARGUMENT LIST.  IT
;      PREPARES THE SCAN FOR SCANNING THE LIST AND FIDDLES WITH THE
;      STACKS ACCORDINGLY.
;
;
 ARFCL:
    HRLZI  T2,FCTBT    ;GET BIT FOR FUNCTION
;
 ARFL1:
    PUSH   OS,FG       ;SAVE THE FLAG BITS
    PUSH   OS,0(VS)    ;PUSH THE VARIABLE STACK ENTRY
    PUSH   OS,[0]      ;ARG COUNT
    PUSH   OS,[0]      ;ARG BITS
    HRRZ   T1,0(VS)    ;GET VARIABLE STACK NUMBER IN T1
    CAIL   T1,FCTAFL   ;CHECK FOR FILE FUNCTION
    CAIL  T1,FCTAND   ;BY POSITION
    JRST   ARFCL1      ;PROCESS IF NOT
;
    JSP    T,NXECH     ;GET NEXT CHARACTER IF SO
    CAIE   CH,ASCNUM   ;CHECK FOR '#'
    ERR    E.NFN       ;ERROR IF NOOT
;
 ARFCL1:
    HRLI   T1,PR.FCL   ;GET FUNCTION CALL PRIORITY
    PUSH   OS,T1       ;SAVE OFFICIAL OP STACK WORD
    TLZ    FG,SAVBTS+OPBT+TYPBTS ;RESET EXPRESSION FOR ARGS
    TDO    FG,T2       ;NEW BITS
    TLNE   FG,SBCBT    ;CHECK IF SUBSCRIPT
    TLO    FG,NUMBT    ;IF SO, FORCE NUMERIC ARGS
    JRST   ARNXT       ;AND THEN CONTINUE
;
;
SUBTTL ARITHMETIC SCAN==ARPMT
;
;   ARPMT--THIS ROUTINE CHECKS AN APPARENT SUBSCRIPT REF
;      FOR BEING A SUB CALL ARGUMENT OF A MATRIX.  IT IS USED
;      ONLY IF 'CALBT' IS ON, AND EXITS EITHER TO ARSCN ON NOT
;      OR TO AREXI IF ONE IS FOUND.
;
;
ARPMT:
;
  TLNN FG,CALBT ;CHECK IF CALL ARGS EXPECTED
    JRST ARSBC ;IF NOT, THEN SUBSCRIPTING
  JSP T,NXECH ;GET NEXT CHR IF SO
  TLO FG,NCHBT ;MARK AS SCANNED
  CAIN CH,ASCCMA ;CHECK FOR COMMA 
  JRST ARPMT1 ;HANDLE IF COMMA
  CAIE CH,ASCRPR ;CHECK FOR RPR
  JRST ARSBC ;NO--THEN SUBSCRIPTING
;
  MOVEI R2,1 ;() FOUND
  JRST ARPMT2 ;HANDLE 1D PASSED
;
 ARPMT1:
  JSP T,NXECH ;(, FOUND--LOOK FOR (,)
  CAIE CH,ASCRPR ;CHECK FOR THAT CASE
  ERR E.INFT ;ERROR IF NOT
  MOVEI R2,2 ;IF SO, 2D ARG PASSED
;
 ARPMT2:
  MOVEM R2,XNSBCS ;SAVE NUM DIMS
  SETOM SBCERF ;MUST BE THAT NUMBER OF DIMS
  POP VS,T0 ;GET MAT VAR
  PUSHJ P,ALMAT ;MAKE INTO MATRIX
  PUSH VS,T0 ;AND RESAVE
  JSP T,NXECH ;SCAN ANOTHER CHR
  JRST AREXI ;AND THEN DONE
;
;
  SUBTTL ARITHMETIC SCAN--ARSBC
;
;   ARSBC--HANDLE START OF SUBSCRIPTING. A MATRIX VARIABLE FOLLOWED BY A
;      '(' HAS BEEN FOUND.  HIS ROUTINE SETS UP FOR IT, USING THE ARFCL
;      ROUTINE TO DO MOST OF THE WORK.
;
;
 ARSBC:
    POP    VS,T1       ;GET MAT VAR
    TLC    T1,VTSBC+VTVAR ;RESET BITS FOR SUBSCRIPTED
    PUSH   VS,T1       ;AND RESAVE ON VS
    HRLZI  T2,SBCBT    ;MARK AS SUBSCRIPTING
    JRST ARFL1		;AND PROCESS USING ARFCL
;
;
  SUBTTL ARITHMETIC SCAN--ARCMA
;
;   ARCMA--HANDLE A COMMA.  IF INSIDE A FUNCTION OR SUBSCRIPT CALL, THEN
;      PROCESSES AS AN ARG LIST.  ELSE, TERMINATES ARITHMETIC SCAN.  THIS
;      ROUTINE DOES BOOKKEEPING ON ARG NUMBERS AND TYPES AS WELL AS
;      RESETS THINGS FOR THE NEXT ARGUMENT.
;
;
 ARCMA:
    TLNN   FG,FCSBBT   ;CHECK IF FUNCTION/SBSC PROCESSING
    JRST   AREXI       ;IF NOT, THEN EXIT
    HRLZI  T0,PR.FCL   ;GET PRIORITY OF FUNCTION
;
 ARCM1:
    TDNE   T0,0(OS)    ;CHECK IF BACK TO FCT ON OS
    JRST   ARCM2       ;PROCESS WHEN SO
    PUSHJ P,DONXT     ;IF NOT, POP NEXT
    JRST   ARCM1       ;;AND THEN TRY AGAIN
;
 ARCM2:
    MKLOD (T7)		;MAKE THE ARGUMENT LOADABLE
    PUSH   VS,T7       ;AND RESAVE IT
    SOS    -2(OS)      ;DECREMENT ARG COUNT
    TLNN   FG,STRBT    ;CHECK IF STRING
    JRST   ARCM3       ;SKIP IF NOT
    HRLZI  T0,004000   ;IF SO, SET ON ARG TYPE BITS
    MOVE R1,-2(OS)	;GET SHIFT COUNT
    LSH T0,0(R1)	;GET PROPER BIT BY SHIFTING
    ORM    T0,-1(OS)   ;AND SAVE IN WORD
;
 ARCM3:
    TLZ    FG,TYPBTS+OPBT   ;UNSET TYPE FOR NEXT ARG
    TLNE   FG,SBCBT    ;CHECK IF SUBSCRIPTING
    TLO    FG,NUMBT    ;IF SO, FORCE ARG TO NUMERIC
    CAIE   CH,ASCRPR   ;CHECK FOR ')'
    JRST   ARNXT       ;NO--','--PROCESS NEXT ITEM
    JRST   ARCFC       ;YES--CLOSE FUNCTION CALL
;
;
  SUBTTL ARITHMETIC SCAN--ARCFC
;
;   ARCFC--THIS ROUTINE CLOSES (ENDS) A FUNCTION CALL.  IT CLEANS OFF THE
;      OPERATOR STACK AND SAVES THE PROPER NEW CONTROL WORD ON THE VARIABLE
;      STACK AS WELL AS OTHER VARIABLE STACK ITEMS NEEDED BY FCTS SUCH AS
;      TYPE BITS AND ARG COUNT.
;
;
 ARCFC:
    POP    OS,T0       ;BIT FOR FCT AND PTR TO FCT
    POP    OS,T1       ;TYPE BITS
    POP    OS,T2       ;ARG COUNT
    POP    OS,T3       ;ID WORD
;
    TLNE   FG,SBCBT    ;CHECK IF SUBSCRIPT
    JRST   ARCSB       ;HANDLE IS SO
;
    PUSH   VS,T1       ;SAVE TYPE BITS ON VS
    PUSH   VS,T2       ;SAVE ARG COUNT ON VS
    HRLI   T3,VTFCT    ;TYPE OF FUNCTION WITH ARGS
    PUSH   VS,T3       ;SAVE IT
    POP    OS,FG       ;GET THE OLD FLAG BITS
    JRST   ARNXT       ;AND THEN CONTINUE
;
;
  SUBTTL ARITHMETIC SCAN--ARCSB
;
;   ARCSB--THIS ROUTINE CLOSES A SUBSCRIPTING CALL.  IT IS ENTERED FROM
;      ARCFC AND ONLY HAS TO SET UP THE VARIABLE STACK FOR SUBSSCRIPT
;      CALL AND RESTORE THE FLAGS.  IN ADDITION IT DOES NUMBER
;      OF SUBSCRIPT CHECKING.
;
;
 ARCSB:
    MOVNM  T2,XNSBCS   ;SAVE # OF SUBSCRIPTS
    SETOM SBCERF ;JUST HAVE NUMBER OF DIMS SPECED
    PUSH   VS,T2       ;PUSH NUMBER OF ARGS
    MOVE   T0,T3       ;GET NUMBER OF SYMTAB ENTRY FOR ARRAY
    PUSHJ P,ALMAT     ;CHECK AND ALLOCATE
    PUSH VS,T0 ;AND SAVE RESULTANT MATRIX ON VS
    POP    OS,FG       ;RESTORE FLAG BITS
    TLZ FG,NCHBT ;NEXT CHAR NOT SCANNED
    JRST   ARNXT       ;AND CONTINUE PROCESSING
;
;
    PRINTX *****START OF BAS22*****
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DONXT--DONXT
;
;   DONXT--THIS ROUTINE IS CALLED TO POP THE TOP ITEM OFF THE OPERATOR
;      STACK AND TO PERFORM THE INDICATED OPERATION.  IT BRANCHES ON
;      THE TYPE OF OPERATOR AND DOES WHATEVER IS NECESSARY.
;
;
 DONXT:
    MOVEM  T0,SAVT0    ;SAVE T0
    MOVEM  T1,SAVT1    ;AND T1
    SETZM FSTARG ;FIRST ARG TO CHECK IF SECOND NEEDS R0,R1
;
    POP    OS,T2       ;GET OPERATOR WE ARE POPPING
;
    TLNE   T2,PR.LPR+PR.FCL ;CHECK IF OK
    ERR    E.UNMT      ;ILLEGAL--UNMATCHED PARENTHESIS
    JRST   DOTAB(T2)   ;HANDLE THROUGH TABLE
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOEXI
;
;   DOEXI--EXIT FROM DONXT ROUTINES.
;
;
 DOEXI:
    MOVE   T0,SAVT0    ;GET BACK T0,T1
    MOVE   T1,SAVT1
    POPJ P,      ;AND RETURN
    SUBTTL ARITHEMTIC SUBROUTINE--DONXT--DOTAB
;
;   TABLE OF OPERATORS AND ROUTINES TO HANDLE THEM
;
;
 DOTAB:
    ERR    E.UNMT      ;0--ILLEGAL
    JRST   DOPLU       ;1--+
    JRST   DOMIN       ;2-- -
    JRST   DOMUL       ;3-- *
    JRST   DODIV       ;4-- /
    JRST   DOEXP       ;5-- ^
    JRST   DOCCT       ;6-- &
    JRST   DOREL       ;7-- = (RELATIONAL)
    JRST   DOREL       ;10-- <>
    JRST   DOREL       ;11-- <
    JRST   DOREL       ;12-- >
    JRST   DOREL       ;13-- <=
    JRST   DOREL       ;14-- >=
    JRST   DOEXI       ;15-- + (UNARY)
    JRST   DOUMI       ;16-- - (UNARY)
    JRST   DOEQU       ;17-- = (ASSIGNMENT)
    JRST DOEQN ;20--NEGATIVE ASSIGNMENT
    JRST DOMEQ ;21--MAT ASSIGNMENT 
    JRST DOEND ;22--IF END
    JRST DOMOR ;23--IF MORE
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOPLU,DOMIN,DOMUL,DODIV
;
;   DOPLU,DOMIN,DOMUL,DODIV--THESE ARE ENTRIES TO 'DOOP' WHICH SERVES TO
;      GENERATE CODE FOR A NORMAL ARITHMETIC OPERATION, TAKING WHATEVER
;      SHORTCUTS ARE POSSIBLE
;
;
 DOPLU:
    MOVSI   T2,(FADR 0) ;PLUS
    JRST   DOOP
;
;
 DOMIN:
    MOVSI   T2,(FSBR 0) ;MINUS
    JRST   DOOP
;
;
 DOMUL:
    MOVSI   T2,(FMPR 0) ;TIMES
    JRST   DOOP
;
;
 DODIV:
    MOVSI   T2,(FDVR 0) ;DIVIDE
    JRST   DOOP
;
;
SUBTTL ARITHEMTIC SUBROUTINES--DONXT--DOOP
;
;
;
 DOOP:
    TLNE   FG,MATBT    ;CHECK FOR MAT OPERATOR
    JRST   DOMOP       ;PROCESS IF SO
    XMKLOD (T1)		;GET THE FIRST ARG
    MKLOD (T0)		;AND THE SECOND
    TLNN   FG,ENDBT    ;CHECK IF END OF EXPRESSION
    JRST   DOOP1       ;NO--SKIP
    MOVE   T5,0(OS)    ;YES--CHECK OPERATOR NEXT
    CAME   T5,OPEQU    ;FOR '=' (ASSIGNMENT)
    JRST   DOOP1       ;JUMP IF NOT
    CAMN   T1,0(VS)    ;TO SAME ITEM AS ON STACK???
    JRST   DOOPB       ;YES--SAVE AS SECOND
    CAMN   T0,0(VS)
    JRST   DOOPA       ;YES--SAME AS FIRST
;
;   GENERATE CODE FOR NORMAL OPERATION
;
 DOOP1:
    TLNE   T0,VTREG    ;CHECK IF FIRST IN REG
    JRST   DOOP2       ;HANDLE IF SO
    TLNE   T1,VTREG    ;CHECK IF SECOND IN REG
    JRST   DOOP3       ;HANDLE IF SO
;
 DOOP4:
    LOAD (T0)		;LOAD THE FIRST WHEN NECESSARY
;
 DOOP2:
    PUSHJ P,DAROP     ;AND GENERATE CODE
    EXP    T2          ;OPERATOR
    EXP    T0          ;REGISTER USED
    EXP    T1          ;ARGUMENT TO BE OPED ON
    RLREG (T1)		;RELEASE FREED REGS
    PUSH   VS,T0       ;SAVE NEW LOC OF RESULT
    JRST   DOEXI       ;AND DONE
;
 DOOP3:
    TLNE   T2,10000    ;CHECK IF OPERATION INVERTIBLE
    JRST   DOOP4       ;IF NOT, PROCESS AS IF BOTH NOT LOADABLE
    EXCH   T0,T1       ;ELSE SWITCH COMERS
    JRST   DOOP2       ;AND THEN PROCESS
;
;
SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOOPA (SPEICAL CASES)
;
;HANDLE <OP>M IF POSSIBLE
;
;
 DOOPA:
    TLNE   T2,10000    ;MUST INVERT IF POSSIBLE
    JRST   DOOP1       ;CAN'T DO
    EXCH   T0,T1       ;FLIP TO INVERT
;
 DOOPB:
    POP    OS,T3       ;GET RID OF '=' OPERATION
    POP    VS,T3	;GET RID OF DUMPLICATE VARIABLE
    TLO    T2,3000	;INDICATE TOMEMORY
    LOAD (T0)		;INSURE THE NUMBER IS LOADED
    PUSHJ P,DAROP	;AND THEN PEROFORM OPERATION
    EXP    T2          ;MODIFIED OPERATOR
    EXP    T0          ;REGISTER
    EXP    T1          ;OPERAND
;
    RLREG (T1)		;RELEASE USED ITEM
    PUSH   VS,T0       ;SAVE RESULT
    JRST   DOEXI	;AND RETURN
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOEXI,DOCCT
;
;   DOEXP,DOCCT--THESE TWO OPERATORS BOTH GENERATE RUN TIME ROUTINE
;      CALLLS OF TWO ARGUMENTS.  THE FIRST IS FOR EXPONENTIATION AND
;      THE SECOND IS FOR CONCATENATION.  THE ROUTINE DORSB2 IS USED
;      TO GENERATE THE ACCTUAL CODE.
;
;
 DOEXP:
    MOVEI  T2,R.EXPN   ;GET RUN TIME ENTRY FOR EXPONENTIATION
    PUSHJ P,DORSB2    ;GENERATE CODE
    HRLZI  R2,VTREG+VTNUM ;VS BITS AND TYPE
    PUSH   VS,R2       ;PUSH THE ITEM
    HRLZI R1,400000 ;RETURNED IN R0
    ANDCAM R1,REGFGS ;INDICATE THEN THAT R0 USED
    JRST   DOEXI       ;AND THEN DONE
;
;
;
 DOCCT:
    MOVEI  T2,R.CCT    ;GET RUN TIME ENTRY FOR CONCATENATION
    PUSHJ P,DORSB2    ;GENERATE CODE
    HRLZI  R2,VTREG+VTSTR ;MARK RESULT AS STRING IN REG
    HRRI   R2,1        ;IN REGISTER ONE
    PUSH   VS,R2       ;AND SAVE
    HRLZI R1,200000 ;INDICATE THAT R1 IS USED
    ANDCAM R1,REGFGS ;FOR THIS PURPOSE
    JRST   DOEXI       ;AND DONE
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOREL
;
;   DOREL--THIS ROUTINE HANDLES RELATIONAL OPERATORS.  IT GENERATES EITHER
;      DIRECT COMPARISON TESTS OR STRING TESTS.  IT ENDS UP WITH NOTHING
;      REALLY IN A REGISTER (VTCND ON STACK VS);  CODE GENERATED IS TO
;      SKIP IF CONDITION IS NOT SATISFIED THE NEXT INSTRUCTION.
;
;
 DOREL:
    TLNE   FG,STRBT    ;CHECK FOR STRING RELATIONS
    JRST   DOSRL       ;HANDLE IF SO
;
    XMKLOD (T1)		;GET BOTH ARGS LOADABLE
    MKLOD (T0)
;
    TLNE   T0,VTREG    ;CHECK IF FIRST IN REG
    JRST   DORL2       ;HANDLE IF SO
    TLNE   T1,VTREG    ;ELSE CHECK IF SECOND IN REG
    JRST   DORL3       ;HANDLE IF SO
;
    LOAD (T0)		;LOAD FIRST WHEN NECESSARY
;
 DORL2:
  MOVE T3,DORLTB-PN.REQ(T2) ;GET OPERAND
;
 DORL5:
    PUSHJ  P,DAROP     ;GENERATE COMPARE
    EXP    T3          ;OP
    EXP    T0          ;REGISTER
    EXP    T1          ;OPERAND
;
    RLREG (T1)		;RELEASE USED ITEM
    PUSH   VS,[XWD VTCND,0] ;SAVE MARKER ON STACK
    JRST   DOEXI       ;AND DONE
;
 DORL3:
    MOVE T3,IDRLTB-PN.REQ(T2) ;GET INVERTED OPERAND
    EXCH   T0,T1       ;AND OPERANDS
    JRST   DORL5       ;AND THEN PROCESS
;
;
SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOSRL
;
;   DOSRL--DO STRING RELATIONS--GENERATES CODE TO CALL 'R.SCP' TO GET
;      STRING COMPARISON AND GET SIGN OF COMPARE IN R0.  THEN GENERATES
;      PROPER TRANSFER BASED ON THAT.
;
;
 DOSRL:
    MOVE T3,DORLTB-PN.REQ(T2) ;GET OPERAND
    MOVEM  T3,TEMP     ;SAVE OPERATOR
    MOVEI  T2,R.SCP    ;GET ROUTINE NAME TO CALL
    PUSHJ P,DORSB2    ;PERFORM SUBROUTINE CALL
;
    PUSH VS,[XWD VTCND,0] ;PUT RESULT WORD ON STACK
    MOVE   R2,TEMP     ;RESTORE OPERATOR
    ADD    R2,[XWD 020000,1] ;CAM==>SKIP
    SAVWD              ;SAVE IN MEMORY
    JRST   DOEXI       ;AND THEN DONE
;
;
SUBTTL ARITHMETIC SUBROUTINES--DONXT--DORLTB
;
;   DORLTB--TABLE OF OPERATORS FOR VARIOUS RELATIONS
;
 DORLTB:
    CAMN               ;=
    CAME               ;<>
    CAMGE              ;<
    CAMLE              ;>
    CAMG               ;<=
    CAML               ;>=
;
;
;   IDRLTB--INVERTED TABLE OF OPERATORS FOR RELATIONS
;
 IDRLTB:
  CAMN		;=
  CAME		;<>
  CAMLE		;<
  CAMGE		;>
  CAML		;<=
  CAMG		;>=
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOUMI
;
;   DOUMI--DO UNARY MINUS--THIS ROUTINE GENERATES THE CODE TO NEGATE
;      THE ARGUMENT AT THE TOP OF THE VS.  A CHECK IS MADE FOR A=-A;
;      ALSO, NEGATIVE LOADS ARE USED WHENEVER ARG ISN'T IN REGISTER
;      ALREADY.
;
;
 DOUMI:
    TLNN   FG,ENDBT    ;CHECK IF END OF EXPRESSION
    JRST   DONG3       ;NO--JUMP
    MOVE   T2,0(OS)    ;CHECK TOP OF OS
    CAME   T2,OPEQU    ;FOR = ASSIGNMENT
    JRST   DONG3       ;HANDLE IF NOT
    ADDI   T2,1        ;IF SO, MAKE INTO =- ASSIGNMENT
    MOVEM  T2,0(OS)    ;RESAVE ON OS
    JRST   DOEXI       ;AND DONE
;
 DONG3:
    MKLOD (T0)		;INSURE FIRST ARG LOADABLE
    TLNE T0,VTREG ;CHECK IF IN REG
    JRST DONG4 ;HANDLE IF SO
    GTREG (T1)		;ELSE GET A REGISTER TO USE
    PUSHJ  P,DAROP     ;AND PERFORM THE LOAD
    EXP    [MOVN 0]    ;USING NEGATED MOVE
    EXP    T1          ;NEW REGISTER
    EXP    T0          ;OLD OPEAND
    RLREG (T0)		;RELEASE USED ITEM
    PUSH   VS,T1       ;SAVE THE NEW VALUE
    JRST   DOEXI       ;AND DONE
;
 DONG4:
    PUSH VS,T0 ;SAVE IT AGAIN
    MOVSI   R2,(MOVNS) ;GET A NEGATED MOVE TO SELF
    HRR    R2,T0       ;WITH THE REGISTER NUMBER
    SAVWD              ;AND SAVE IT
    JRST   DOEXI       ;AND THEN WE ARE DONE
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOEQU,DOEQN
;
;   DOEQU,DOEQN--THESE TWO OPERATORS DO ARITHMETIC AND STRING ASSIGNMENT
;      FUNCTIONS.  DOEQN IS ARITHMETIC ONLY AND IMPLIES =-.  THE CODE
;      GENERATED IS THE OBVIOUS ONE EXCEPT THAT, FOR STRING ASSIGNMENT,
;      THE OLD STRING IS DEALLOCATED AND THE NEW ONE'S COUNT IS
;      UPDATED IN LINE.
;
;
 DOEQU:
    MOVSI  T2,(MOVEM) ;GET OPERATOR
    JRST   DOEQA       ;AND RPOCESS
;
;
 DOEQN:
    MOVSI  T2,(MOVNM) ;GET OVERATOR
    JRST   DOEQA       ;AND PROCESS
;
;
SUBTTL ARITHEMTIC SUBROUTINES--DOEQA
;
;DOEQA--COMMON ROUTINE FOR ASSIGNMENT
;
;
 DOEQA:
    TLNE FG,MATBT ;CHECK FOR MAT ASSIGNMENT
    JRST DOMEQ ;HANDLE SPECIAL IF SO
    PUSHJ P,GTLOD     ;LOAD THE RHS
    POP    VS,T0       ;GET POINTER TO IT
    MKLOD (T1)		;GET ADDRESS FOR MEMORY SAVE
;
    TLNN   FG,STRBT    ;CHECK FOR STRING ASSIGNMENT
    JRST   DOEQ1       ;SKIP IF NOT
    MOVEI  R2,R.DLC    ;GET DEALLOCATION ROUTINE ADDRESS
    PUSHJ P,SVCAL     ;GENERATE CALL TO IT
    GTADD (T1)		;GET ADDRESS OF ARG
    PUSHJ P,SVADD     ;AND SAVE IT
    MOVSI R2,(SKIPE) ;GENERATE SKIP FOR NULL STRING
    HRR R2,T0 ;GET PTR TO STRING TO CHECK
    SAVWD ;SAVE IT
    HRLZ   R2,T0       ;GET POINTER TO STRING
    ADD    R2,[AOS -1] ;WE WANT TO INCREMENT COUNT
    SAVWD              ;SAVE THE INSTRUCTION
;
 DOEQ1:
    PUSHJ P,DAROP     ;GENERATE ASSIGNMENT
    EXP    T2          ;OPERATOR
    EXP    T0          ;REG
    EXP    T1          ;OPERAND
;
    RLREG (T1)		;RELEASE REGS OF LHS
    PUSH   VS,T0       ;SAVE RESULT ON STACK
    JRST   DOEXI       ;AND THEN DONE
;
;
SUBTTL ARITHMETIC SUBROUTINES--DONXT--DOEND, DOMOR
;
;   DOEND--THIS ROUTINE HANDLES IF END#, WHILE
;   DOMOR--THIS ROUTINE HANDLES IF MORE#
;
;
DOEND:
;
  MOVEI T2,R.IFEN ;GET RTP ROUTINE TO PROCESS
  JRST DOENMR ;AND SKIP
;
;
;
DOMOR:
;
  MOVEI T2,R.IFMR ;GET RTP ROUTINE TO PROCESS
;
 DOENMR:
  PUSHJ P,DORSB1 ;GENERATE CALL TO ROUTINE
  PUSH VS,[XWD VTCND,0] ;SAVE COND RESULT ON STACK
  AOS FILUSD ;WE HAVE USED FILES
  MOVSI R2,000100 ;R.FL REG USED
  IORM R2,REGUSD ;INDICATE THAT
  JRST DOEXI ;AND DONE
;
;
SUBTTL ARITHMETIC SUBROUTINES--DOMEQ
;
;   DOMEQ--THIS ROUTINE HANDLES MAT ASSIGNMENT.  IT IS
;      ENTERED ONLY ON THE STATEMENT MAT A=B AS ALL
;      OTHER MAT ASSIGNMENTS ARE HANDLED BY MATOP OR
;      MFCAL.
;
;
DOMEQ:
;
  MOVE T0,0(VS) ;GET RHS MAT
  MOVEI R2,1 ;GUESS 1-D
  SKIPL MATDTB(T0) ;CHECK THAT
  MOVEI R2,2 ;ELSE 2-D
;
  MOVEM R2,XNSBCS ;SAVE NUMBER OF DIMS FOR NEW LHS
  SETOM SBCERF ;MUST HAVE THAT MANY
  MOVE T0,-1(VS) ;PICK UP LHS
  PUSHJ P,MAKMAT ;MAKE INTO MATRIX
  MOVEM T0,-1(VS)	;SAVE NEW MAT PTR BACK ON STACK
;
  MOVEI T2,R.MASS ;GET ENTRY FOR RUN TIME
  TLNE FG,STRBT		;CHECK IF STRING ASSIGNMENT
    MOVEI R2,R.SMSS	;MARK AS SUCH
  HRRI FG,CLTEXT+2 ;EXTERNAL CALL OR 2 ARGS
  PUSHJ P,GCALL ;TO DO THE ASSIGNMENT
;
  JRST DOEXI ;THEN DONE
;
;
SUBTTL ARITHMETIC SUBROUTINES--DOMOP
;
;   DOMPOP--THIS ROUTINE IS CALLED TO DO A MAT OPERATION
;      SUCH AS MAT +, MAT - OR MAT *.  IT GENERATES THE 
;      APPROPRIATE CALLS TO PERFORM THE FUNCTIONS AS WELL
;      AS DETERMINES THE DIMENSION TYPE OF THE RESULTANT
;      MATRIX OR VARIABLE.
;
;
DOMOP:
;
  SKIPE PRIFG		;CHECK FOR MAT PRINT
    ERR E.INFT		;MAT EXPRESSIONS NOT ALLOWED THERE
  MOVE T7,1(OS) ;GET OP CASUING MOP
  POP OS,T0 ;GET NEXT OP
  TLNN T0,PR.EQU ;MUST BE '='
  ERR E.ILMT ;ILLEGAL IF NOT
;
  MOVNI T6,44-3 ;INITIAL BYTE POSITION
  MOVE T0,-1(VS) ;FIRST MAT
  TLNN T0,VTMAT ;CHECK FOR MATRIX
  JRST DOMOP2 ;HANDLE IFNOT [SCLR * MAT]
  SKIPL MATDTB(T0) ;CHECK IF 1/2 D
  ADDI T6,1*3 ;MOVE BYTE PTR IF 1D
;
 DOMOP3:
  MOVE T0,0(VS) ;LOOK AT SECOND ARG
  SKIPL MATDTB(T0) ;CHECK IF IT IS 1/2 D
  ADDI T6,2*3 ;ADJUST FOR 1D
  MOVE T0,MOPDTB-1(T7) ;GET OP WORD
  LSH T0,0(T6) ;ADJUST FOR PROPER BYTE
  ANDI T0,7 ;MASK THE BYTE
  CAIN T0,3 ;CHECK IF ILLEGAL TYPE (3)
  ERR E.DMER ;ERROR IF SO
  MOVEM T0,XNSBCS ;SAVE IF NOT AS # DIMS
  SETOM SBCERF ;MUST HAVE THAT MANY SBCS
;
  SKIPN T2,MOPTB-1(T7) ;GET RTN TO CALL
  ERR E.ILMT ;MAT DIVIDE ILLEGAL
;
  SKIPN T1,XNSBCS ;CHECK IF VAR/MAT
  JRST DOMOP1 ;IF VAR, JUMP
  MOVE T0,-2(VS) ;GET MAT FROM STACK
  PUSHJ P,MAKMAT ;IF MAT, MAKE INTO REAL MAT
  MOVEM T0,-2(VS) ;AND RESAVE ON STACK
;
 DOMOP1:
  HRRI FG,CLTEXT+3 ;EXTERNAL CALL WITH 3 ARGS
  PUSHJ P,GCALL ;GENERATE CALL
;
  JRST DOEXI ;AND THEN DONE
;
;
 DOMOP2:
  MOVEI T7,5 ;NEW OP--MAT SCL MULTIPLY
  JRST DOMOP3 ;AND HANDLE
;
;
SUBTTL ARITHMETIC SUBORUTINES--DOMOP--TABLES
;
;
;   MOPTB--ROUTINE NAME FOR OPERATION
;
MOPTB:
  EXP R.MADD ;ADD
  EXP R.MSUB ;MINUS
  EXP R.MMUL ;TIMES
  EXP 0 ;DIVIDE IS ILLEGAL
  EXP R.MSCL ;SCALE
;
;
;   MOPDTB--REULTANT TYPE/DIM TABLE
;
MOPDTB:
  BYTE (3)1,3,3,2
  BYTE (3)1,3,3,2
  BYTE (3)0,1,1,2
  BYTE (3)3,3,3,3
  BYTE (3)1,1,2,2
;
;
;
    PRINTX *****START OF BAS23*****
;
;
  SUBTTL ARITHMETCI SUBROUTINES--GNSUB
;
;   GNSUB--THIS ROUTINE GENERATES CODE FOR SUBSCRIPTING CALLS.  IT
;      ACTUALLY (FOR NOW AT LEAST) GENERATES THE ACTUAL CALCULATING
;      CODE IN LINE.
;
;
 GNSUB$:
    PUSH   P,T0        ;SAVE T0,T1,T2
    PUSH   P,T1
    PUSH   P,T2
    MOVE   T0,T7       ;PICK UP STACK WORD FOR SBSC CALL
    POP    VS,T6       ;POP THE ARGUMENT
    TRNN   T6,1        ;CHECK IF ONE  OR TWO ARGS
    JRST   GNSBB       ;HANDLE TWO
;
;   ONE DIMENSIONAL
;
    PUSHJ P,GSBLF     ;GENERATE LOAD OF ARG
    CAML  1           ;CHECK INSTRUCTIN
;
 GNSB1:
  PUSHJ P,CKRG ;CHECK TO NOT USE REG 0
    LSH T1,22+4+1 ;POSITION NEW REG
  MOVE R2,RPGFG		;GET ONE LINE ENTRY FLAG
  SKIPN PRGNM		;CHECK IF MAIN PROGRAM
    JUMPGE R2,GNSB2	;AND NOT ONE LINE ENTRY
;
  MOVE R2,MATPTB(T0) ;GET MAT PTR
  TLNN R2,MTGBL ;CHECK IF GLOBAL
    JRST GNSB4 ;NO--HANDLE BETTER CODE GENERATOR
  HRLI R2,(ADD 0,@0) ;GET OP TO ADD IN OFFSET
  ADD R2,T1 ;PLUS REG
  SVWNM ;SAVE AS REFERENCE TO NUM VAR AREA (MATPTR)
  JRST GNSB2 ;AND SKIP
;
 GNSB4:
  HRRZ R2,T0 ;GETMAT WORD
  TLNE T0,VTSTR ;CHECK IF STRING
  TRO R2,400000 ;MARK AS SUCH
  ADD R2,T1 ;PLUS REG OF OFFSET
  TLO R2,(ADDI) ;TLO MAT OFFSET TO ARRAY OFFSET
  SVWMT ;SAVE AS MAT REF
;
 GNSB2:
    LSH    T1,-5       ;REGISTER OUT
    MOVE   T7,T0    ;GET POINTER TO MATRIX
    HLL    T7,T0       ;AND BITS
    TLZ    T7,-1-VTNUM-VTSTR ;TURN OFF TYPE BITS
    ADD    T7,T1       ;PLUS NEW TYPE BITS
    TLO    T7,VTMEL    ;PLUS MATRIX ELEMENT==>VS WORD FOR EL
;
    POP    VS,T0       ;GET RID OF LAST ITEM ON VS
    POP    P,T2        ;RESTORE T2,T1,T0
    POP    P,T1
    POP    P,T0
    POPJ   P,		;AND RETURN
;
;   GNSBB--TWO DIMENSIONS
;
 GNSBB:
    PUSHJ P,GSBLF     ;LOAD FIRST ARG
    CAML  2           ;SECOND ARG
    MOVEM  T1,TEMP     ;SAVE RESULTANT REG
    PUSHJ P,GSBLF     ;LOAD SECOND ARG
    CAML 1
    GTADD (T0)	;GET ADDRESS FOR MATRIX
    ADD    R2,[IMUL 2] ;CONSTRUCT MULTIPLY
    ADD R2,T1 ;GET PROPER ADD
    SVWNM              ;AND SAVE IT
    MOVE   R2,T2       ;GET REG OF NEW ANSWER
    ADD    R2,TEMP     ;PLUS REG OF FIRST
    TLO    R2,(ADD)  ;CONSTRUCT ADD OF THE TWO
    SAVWD              ;AND SAVE IT
    HRLZI  T7,400000   ;SIGN BIT
    MOVN R1,T2 ;GET SHIFT COUNT FROM REG NUMBER
    LSH    T7,0(R1)    ;INDICATE REGISTER USED
    ORM    T7,REGFGS   ;FREE REGISTER
    MOVE   T1,TEMP     ;SAVE RESULTANT REG
    JRST   GNSB1       ;AND DONE
;
;
SUBTTL ARITHMETIC SUBROUTINE--GNSUB--GSBLF
;
;   GSBLF--THIS ROUTINE LOADS ONE ARGUMENT FROM THE STACK FOR SUBSCRIPT
;      CHECKING.  IT FIXES THE ARGUMENT AND USES 0(T) TO CHECK FOR BOUNDS
;      OF THE ARG.
;
;
 GSBLF:
    POP    VS,T1       ;GET ITEM FROM STACK
    TLNN T1,VTCON ;CHECK FOR CONSTANT
    JRST GSBLF1 ;NO--HANDLE
    MOVE R2,0(T1) ;YES--GET VALUE
    XFIX R2 ;FIX IT
    TLNE R2,-1 ;CHECK IF TOO BIG
    JRST GSBLF1 ;ALLOW--BUT AT RUN TIME GIVE ERROR
    MOVE T4,R2 ;SAVE NUMBER
    GTREG (T1) ;GET A REG FOR US
    HRRZ T2,T1 ;SAVE IN T2
    LSH T1,22+4+1 ;MAKE T1 INTO REG POS
    MOVE R2,T4 ;RESTORE NUMBER TO R2
    TLO R2,(MOVEI) ;USE FIXED POINT LOAD
    ADD R2,T1 ;TO REG WE GOT
    SAVWD ;AND SAVE ABS
    SKIPE SBCHK ;CHECK IF CHECKING DIMS
    JRST GSBLF4 ;NO--JUST RETURN
    JRST GSBLF3 ;YES--GO AHEAD AND CHECK
;
 GSBLF1:
    RFIX T1 ;GENERATE CODE TO FIX
    HRRZ T2,R2 ;ISOLATE REG NUMBER
    MOVE T1,T2 ;GET REG NUMBER IN T1
    LSH T1,22+4+1 ;TO REG FIELD
    SKIPE  SBCHK       ;CHECK IF SUBSCRIPT CHECKING
    JRST GSBLF4 ;RETURN IF NOT
;
    MOVSI  R2,(SKIPL)  ;CHECK FOR <=0
    ADD    R2,T2       ;GET REGISTER
    SAVWD              ;AND SAVE
;
 GSBLF3:
    MOVE   R2,T1       ;RESTORE REGISTER
    GTADD (T0) ;GET ADDRESS
    ADD R2,T1 ;PLUS REGISTER BEING USED
    ADD R2,@0(P) ;PLUS COMPARE INST
    PUSHJ P,SVREL ;SAVE THIS
    HRRZ   R2,T0       ;GET MATRIX LOC IN R2
    TLO    R2,(R.SBER)  ;CODE TO GENERATE RUN TIME SUBSCRIPT ERROR
    ADD R2,T1 ;REG NUMBER FOR VALUE PRINT OUT
    SAVWD              ;SAVE IT
;
 GSBLF4:
  AOS 0(P) ;BUMP RETURN
  POPJ P, ;AND RETURN
;
;
  SUBTTL ARITHMETIC SUBROUTINES--FNCAL
;
;   FNCAL--THIS ROUTINE IS USED TO GENERATE A FUNCTION CALL WHICH
;      IS ON THE STACK EXCEPT FOR THE HEADER WORD WHICH IS AT O(T)@.
;      THE NECCESSARY CODE IS GENREATED FOR CALLING THE FUNCTION AND
;      POINTING TO THE ARGUMENTS.
;
;
 FNCAL$:
;
    PUSHJ P,RTCRG ;RELEASE REGS 0,1
;
    PUSH   P,T0        ;SAVE T0,T1,T2
    PUSH   P,T1
    PUSH   P,T2
;
    MOVE   T0,T7       ;GET ID WORD FOR CAAL
    MOVEM T0,FNCTM# ;SAVE THE ID WORD
    HRRZ   T1,T0       ;GET POINTER TO FCT BLOCK IN T1
    CAIL   T1,UFCATB   ;CHECK IF USER/INTERNAL
    JRST   UFCAL       ;HANDLE USER
    CAIL T1,MFCTS ;CHECK IF MAT FUNCTION
    CAIL T1,MFCTND ;IN BOUNDS
    SKIPA ;NOT MAT FCT--SKIP
    JRST MFCAL ;HANDLE MAT FUNCTIONS
;
    MOVEI  T2,FCNAM(T1) ;GET NAME PTR IF EXTERNAL
    HRRI FG,CLTEXT ;EXTERNAL CALL
    JRST   FNCL1       ;AND THEN SKIP
;
 UFCAL:
  HRRZ T2,T1 ;GET ADDRESS
  MOVSI R1,FCUSD ;GET BIT TO MARK AS USED
  IORB R1,FCIAD(T1) ;AND SAVE IN FCT
  TLNN R1,FCGBL ;CHECK IF GLOBAL
  JRST UFCAL1 ;HANDLE IF H'OT
  MOVE R2,[PUSH R.P,R.V] ;SAVE VAR REG IS SO
  SAVWD ;DO IT AT RUN TIME
  MOVE R2,[PUSH R.P,R.RBGS] ;PUT MARKER ON STACK AS WELL
  SVWEX ;SAVE AS EXTERNAL REF
;
 UFCAL1:
  HRRI FG,CLTFCT+CLBPA+CLBPJ ;INTERNAL FCT CALL
;
;   HANDLE ARGUMENTS
;
 FNCL1:
    POP    VS,T1       ;GET COUNT
  SUB FG,T1 ;PUT NUMBER OF ARGS INTO TYPE WORD FOR CALL
  POP VS,T3 ;GET TYPE WORD
    TLNE   FG,STRBT    ;CHECK IF STRING
    TLO    T3,004000   ;SET ON PROPER BIT IF SO
    MOVM   T7,T1       ;GET ABS VAL OF COUNT
    AOS    T7          ;PLUS ONE
    LSH    T7,36       ;TO UPPER SIX BITS
    ADD    T3,T7       ;CREATE FULL TYPE WORD
;
    MOVE   T7,FCIDWD(T0) ;CHECK OLD WORD TO SEE IF DEFINED
    JUMPE  T7,FNCL2    ;HANDLE UNDEFINED
    TLNN   T7,-1       ;CHECK IF SPECIAL
    JRST   FNCL3       ;HANDLE IF SO
    CAME   T3,FCIDWD(T0) ;CHECK FOR MATCH
    JRST   FNCL6       ;NO MATCH--ERROR
    JRST   FNCL3       ;MATCH--CONTINUE
;
 FNCL2:
    MOVEM  T3,FCIDWD(T0)    ;SAVE BITS IF IT WAS UNDEFINED
;
 FNCL3:
    PUSHJ P,GCALL ;AND GENERATE CALL TO FCT
    POP VS,T0 ;GET FCT OFF STACK
;
    TLC    T0,VTFC0+VTREG ;MARK ITEM AS IN REGISTER
    HLLZ   T7,T0       ;GET BITS FOR REGISTER 0
    TLNE   T7,VTSTR    ;CHECK FOR STRING FCT
    HRRI   T7,1        ;IF SO, RETURN IS IN REG 1
;
  HRRZ R2,FNCTM ;GET ITEM OF CALL
  CAIL R2,UFCATB ;CHECK IF USER FCT
  MOVE R1,FCIAD(R2) ;CHECK IF GLOBAL
  TLNN R1,FCGBL ;IN BITS
  JRST FNCL7 ;IF NOT, SKIP
  MOVEI R2,R.STEX ;CALL STACK CLEAN UP RTN
  PUSHJ P,SVCAL ;TO GET RID OF MARKER AND V REG
;
 FNCL7:
    POP    P,T2        ;RESTORE T2,T1,T0
    POP    P,T1
    POP    P,T0
    HRLZI  R1,400000   ;GUESS NUMERIC
    TLNE   T7,VTSTR    ;CHECK FOR STRING
    HRLZI  R1,200000   ;REG 1 FOR STRING
    ANDCAM R1,REGFGS   ;MARK REG AS USED
    POPJ   P,		;AND DONE
;
 FNCL6:
    AND    T7,[770000000000] ;MASK ARG COUNT
    MOVE   T1,FCIDWD(T0) ;GET EXPECTED TYPE WORD
    AND    T1,[770000000000] ;MASK COUNT
    CAMGE  T2,T1       ;CHECK FOR MATCH
    ERR    E.TFAR      ;ERROR IF TOO FEW
    CAME   T2,T1
    ERR    E.TMAR      ;ERROR IF TOO MANY ARGS
    ERR    E.ARTY      ;ELSE ARG TYPE ERROR
;
;
SUBTTL MFCAL--MAT FUNCTION CALL
;
;   MFCAL--THIS ROUTINE HANDLES MAT FUNCTIONS. THESE ARE 
;      THOSE THAT OCCUR AS MAT STATEMENTS MAT X=FCT(Y).
;      THERE ARE SEVERAL TYPES OF MAT FCTS--BASICALLY
;      THOSE THAT CREATE A NEW MATRIX (IDN,CON,ZER,NUL$)
;      AND THOSE THAT OPERATOE ON A MATRIX (TRN,INV).
;
;
MFCAL:
;
  MOVEI R2,2 ;ASSUME 2 D IF NOT OTHERWISE TOLD
  MOVEM R2,XNSBCS ;SAVE AS DEFAULT
  SETZM SBCERF ;THIS DEFAULT IS NOT ENFORCED ON PREDEFINED
;
  MOVE T7,FCIDWD(T0) ;CHECK ID WORD
  TLNE T7,760000 ;MAT CREATION FCT HAS NO ARGS
  JRST MFCL4 ;IF ARGS--MAT FCT OF MAT
;
  POP VS,T1 ;MAT CREATION--GET FCT
  POP VS,T2 ;GET ID WORD AND NUM OF ARGS OFF STACK
  TLNE T2,003777 ;MAKE SURE NO STRING ARGS
  ERR E.ILMF ;ERROR IF THERE ARE ANY
  MOVNS T1 ;GET POSITIVE NUMBER OF ARGS
;
  HRRZ R2,T0 ;ISOLATE LOWER HALF
  CAIN R2,MTFIDN ;CHECK FOR 'IDN'
  CAIE T1,1 ;AND ONE ARG
  JRST MFCL1 ;IF NOT BOTH OF THESE, JUMP
  PUSH VS,0(VS) ;IF THIS IS THE CASE, DUPLICATE ARG
  AOS T1 ;AND BUMP ARG COUNT
;
 MFCL1:
  MOVE T0,VS ;GET STACK PTR
  SUB T0,T1 ;BEHIND ARGS
  MOVE T0,-1(T0) ;PICK UP MATRIX
  PUSHJ P,XDMMAT ;DIMENSION IT
  POP VS,T1 ;GET FCT CALL WORD OFF THE STACK
  MOVEM T0,0(VS) ;SAVEARG FOR CALL
;
  MOVE R2,FNCTM ;GETFCT TABLE PTR
  MOVEI T2,FCNAM(R2) ;GET PTR TO RTP ADD
  HRRI FG,CLTEXT+1 ;EXTERNAL CALL
  PUSHJ P,GCALL ;GENERATE IT
;
 MFCL2:
  HRLZI T7,VTREG+VTNUM ;FAKE RETURN
  JRST FNCL7 ;AND DONE
;
;
;   HANDLE MAT FCT OF MAT VAR
;
 MFCL4:
  POP VS,T1 ;GET NUMBER OF ARGS
  MOVNS T1 ;POSITIVE
  CAIE T1,1 ;MUST BE ONE
  ERR E.ILMF ;ERROR IF NOT
  POP VS,R2 ;GET FCIDWD
  POP VS,T0 ;AND THE ARG
  MOVE R2,FNCTM		;GET FUNCTION WORD
  CAIN R2,MTFTRM	;CHECK FOR MAT TRANSPOSE
  TLNN T0,VTSTR		;WITH A STRING MAT
    SKIPA		;IF NOT, SKIP
  HRRI R2,MTFTRS	;IF SO, MAKE IT STRING MAT TRANSPOSE
  MOVEM R2,FNCTM	;AND RESAVE THE RESULT
  PUSHJ P,MAKMAT ;MAKE THE ARG INTO A MATRIX
  MOVEM T0,0(VS) ;SAVE OVER FCT CALL WORD ON STACK
  MOVEM R1,XNSBCS ;SAVE NUMBER OF DIMS FOR RESULT
  SETOM SBCERF ;MAT MUST HAVE THESE DIMS
  MOVE T0,-1(VS) ;GET RESULTANT MAT
  PUSHJ P,MAKMAT ;FORCE TO BE A MATRIX
  MOVEM T0,-1(VS) ;AND RESAVE
;
  MOVE R2,FNCTM ;GET FCT ENTRY PTR
  MOVEI T2,FCNAM(R2) ;GET PTR TO TABLE FOR RTP ENTRY
  HRRI FG,CLTEXT+2 ;EXTERNAL CALL OF TWO ARGS
  PUSHJ P,GCALL ;GENERATE IT
  JRST MFCL2 ;AND DONE
;
;
SUBTTL ARITHMETIC SUBROUTINES--GCALL
;
;   GCALL-THIS ROUTINE GENERATES A CALL.  THE TYPE BITS
;      OF THE CALL ARE GIVEN IN FG LOWER ON ENTRY AND THE
;      ADDRESS TO CALL IS GIVEN IN T2.  IF THE TYPE OF CALL IS
;      EXTERNAL, THEN THE TYPE BITS ARE TAKEN FROM THE HIGH
;      ORDER BITS OF THE EXTERNAL RADIX50 NAME.
;
;
GCALL:
;
  MOVEM P,DUMMYP# ;SAVE INIT PDL
  PUSHJ P,RTCRG ;FREE REGS 0,1
  LDB T0,[POINT 2,FG,23] ;GET TYPE OF CALL
  CAIE T0,2 ;CHECK FOR EXTERNAL
  JRST GCALL1 ;NO--HANDLE
  HLRZ R2,0(T2) ;YES--GET HIGH ORDER BITS
  LSH R2,-22+3 ;ONLY THESE MAY CHANGE
  DPB R2,[POINT 3,FG,20] ;SAVE AS ACTIVE
;
 GCALL1:
  MOVE T1,FG ;GET NUMBER OF ARGS
  ANDI T1,777 ;AND ONLY THAT
  JUMPE T1,GCALL2 ;NO ARGS--SKIP
  MOVEI T3,1(VS) ;GET INIT PTR FOR VS
  TRNE FG,CLBPS ;CHECK IF VS OR P STACK HAS ARGS
  MOVEI T3,0(P) ;PSTACK--GET INIT PTR
  SUB T3,T1 ;GET PTR TO FIRST ARG
;
  TRNN FG,CLBPA ;CHECK IF WE SHOULD PUSH ARGS BEFORE CALL
  JRST GCALL2 ;NO--JUMP
  PUSHJ P,GARGS ;YES--PUSH ARGS
;
 GCALL2:
  MOVSI R2,(JSA 16,) ;USE JSA 16,
  TRNE FG,CLBPJ ;UNLESS TOLD NOT TO
  MOVSI R2,(PUSHJ R.P,) ;IN WHICH CASE USE PUSHJ P,
  ADD R2,T2	;PLUS ADDRESS OF CALL
;
  MOVEI R1,1		;DEFAULT SAVE TYPE IS PRGM
  PUSHJ P,GCLXTB(T0)	;SAVE CALL PROPERLY
;
  JUMPE T1,GCALL3 ;JUMPE IF NO ARGS
  TRNE FG,CLBPA ;CHECK IF PLACE ARGS AFTER CALL
  JRST GCALL3 ;NO--JUMP
  PUSHJ P,GARGS ;YES--SAVE ARGS NOW
;
 GCALL3:
  PUSHJ P,RARGS ;RELEASE ARGS
  TRNN FG,CLBPS ;CHECK IF PDL ARGS
    POPJ P, ;IF NOT, JUST RETURN
  POP P,R2 ;IF SO ,GET RETURN
  MOVE P,DUMMYP ;RESTORE P TO BEFORE ARGS
  JRST 0(R2) ;AND THEN RETURN
;
;
;   TABLE FOR SAVING CALL OP BASED ON CODED TYPE
;
 GCLXTB:
  JRST .SVWD		;0--PROGRAM REF
  JRST .SVFC		;1--FUNCTION REF (USER)
  JRST GCLEXT		;2--EXTERNAL REF
;
;
;
;   GCLEXT--SAVE EXTERNAL--CHECK FOR SUB/FCT/RTP
;
 GCLEXT:
  HRRZ R1,R2		;GET ADDRESS
  CAIL R1,SUBTBL	;CHECK IF SUB
  CAILE R1,SUBTBL+1777
    JRST .SVEX		;HANDLE FCT/RTP ENTRY
  JRST .SVCL		;HANDLE CALL OF SUB
;
;
SUBTTL ARITHMETIC SUBROUTINES--GARGS
;
;   GARGS--THIS ROUTINE IS CALLED ONLY FROM GCALL AND IT
;      SAVES THE ARGS AS EITHER PUSH P,<ARG> OR AS 
;      ARG N,<ARG> DEPENDING ON THE FLAG BITS.
;
;
GARGS:
;
  MOVEM T3,ARGSPT ;SAVE INITAL ARG PTR
  MOVE T4,VS ;GET OLD STACK
  TRNN FG,CLBPS ;CHECK IF THAT'S THE STACK USED
    JRST GARG4 ;SKIP IF VS
  MOVE T4,DUMMYP ;IF P, REG INIT P
  POP T4,R2 ;BUMP 1 PAST CALL RETURN ADDRESS
;
 GARG4:
  SOJL T1,GARG1 ;NEXT ARG--DONE?
  POP T4,R2 ;NO--BUMP STACK DUMMY
  MOVE R2,0(T3) ;GET ARG
  GTADD (R2) ;GET ADDRESS OF ARG
  TRNE FG,CLBPA ;CHECK FOR PUSH/ARG
  JRST GARG2 ;HANDLE PUSH
  PUSHJ P,SVADD ;SAVE AS ARG WITH TYPE INFO
  JRST GARG3 ;AND SKIP
;
 GARG2:
  TLO R2,(PUSH R.P,) ;CREATE PUSH
  PUSHJ P,SVREL ;AND SAVE IT
;
 GARG3:
  AOJA T3,GARG4 ;AND GO ON TO NEXT ITEM
;
 GARG1:
  TRNN FG,CLBPS ;CHECK IF VS STACK USED
  MOVEM T4,VS ;SAVE END VS IF SO
  TRNE FG,CLBPS ;CHECK IF P STACK USED
  MOVEM T4,DUMMYP# ;SAVE END P IF SO
;
  POPJ P, ;AND RETURN
;
;
SUBTTL ARITHMETIC SUBROUTINES--RARGS
;
;   RARGS--THIS ROUTINE IS CALLED ONLY FROM GCALL AND
;      ONLY AFTER A CALL TO GARGS.  IT RELEASES THE
;      REGISTERS, ETC. USED BY THE CALLING SEQUENCE.
;
;
RARGS:
;
  MOVE T1,FG ;GET ARG COUNT
  ANDI T1,777 ;WHICH IS IN THE FLAGS REG
  MOVE T2,ARGSPT ;GET ORIG ARGS PTR (FROM GARGS)
;
 RARG1:
  SOJL T1,RARG2 ;CHECK IF DONE
  MOVE T7,0(T2) ;GET ARG
  RLREG (T7) ;AND RELEASE IT
  AOJA T2,RARG1 ;AND BUMP PTR AND LOOP
;
 RARG2:
  POPJ P, ;AND DONE
;
;
SUBTTL ARITHMETIC SUBROUTINES--MKIMD
;
;   MKIMD--THIS ROUTINE TAKES AN OP WITH AN IMMEDIATE
;      ADDRESS AND MAKES WHATEVER MODIFICATIONS ARE NEEDED 
;      FOR THAT OP TO WORK.
;
;
MKIMD:
;
  MOVS R1,R2 ;GET DUP OF WORD TO SAVE
  ANDI R1,770000 ;OP ALONE IN R1
  CAIN R1,(CAM) ;CHECK FOR COMPARE
  JRST MKIMD1 ;HANDLE
  CAIN R1,(260000000000) ;CHECK FOR 'PUSH'
    JRST MKIMD1 ;WHICH CAN'T BE IMMEDIATIZED
;
  CAIN R1,(MOVE) ;CHECK FOR MOVE
  TLC R2,004000 ;MAKE MOVSI
;
  ADD R2,[001000000000] ;ADD IMMED BIT TO OP
  MOVEI R1,0 ;TYPE OF ABSOLUTE
  POPJ P, ;TO INDICATE IMMEDIATE
;
;
 MKIMD1:
  PUSH P,R2 ;CAN'T BE IMMED--SAVE OP
  HRLZS R2 ;GET FULL WORD CONST
  DSVCON (R2) ;SAVE SHARABLE
  POP P,R1 ;RESTORE OLD OP
  HLL R2,R1 ;PRESERVE OP AND REGS
  MOVEI R1,4 ;CONSTANT TYPE
  POPJ P, ;AND RETURN CONST
;
;
  SUBTTL STATEMENT SUBROUTINES--SVREL
;
;   SVREL--THIS ROUTINE SAVES THE ITEM IN R2 ACCORDING TO THE RELBT
;      IN FG.
;
;   IT IS CALLED WITH A JSA T,SVREL.
;
;
 SVREL:
;
  JRST @.+1(R1) ;BRANCH BY TYPE OF ADD
;
    JRST .SVWD ;ABS
    JRST SVRL2 ;IMMED
    JRST .SVWD ;NVR
    JRST .SVWD ;SVR
    JRST .SVWD ;CON
    JRST .SVEX ;EXT
    JRST .SVFC ;USR FCT
    JRST .SVWD ;MAT
;
;
 SVRL2:
  PUSHJ P,MKIMD ;MAKE INTO IMMED ADDRESSING
    JRST .SVWD ;AND SAVE RESULT
;
;
  SUBTTL ARITHMETIC SUBROUTINES--DAROP
;
;   DAROP--THIS IS THE ROUTINE WHICH DOES AND ARITHMETIC OPEATION.  IT IS
;      CALLED WITH A POINTER TO A WORD CONTAINING THE OPERATOR IN 0(T),
;      A POINTER TO THE REGISTER WORD IN 1(T) AND A POINTER TO THE ITEM
;      TO BE OPED TO THE REGISTER ITEM IN 2(T).  IT RETURNS TO 3(T)
;      WHEN DONE.
;
;
 DAROP:
    MOVE T,0(P) ;PTR TO ARGS
    MOVE R2,@2(T) ;GET FIRST
    GTADD (R2) ;GET ADDRESS OF ARG
    MOVE T7,@1(T) ;GET REG
    LSH T7,22+4+1 ;POSITION IT
    IOR R2,T7 ;INTO OP
    IOR R2,@0(T) ;PLUS OPERATOR
    MOVEI T7,3 ;RETURN ADDRESS
    ADDM T7,0(P) ;NEEDS UPDATING
    JRST SVREL ;RETURN THRU SVREL
;
;
  SUBTTL ARITHMETIC SUBROUTINES--GTADD
;
;   GTADD-THIS ROUTINE GETS THE WORKING ADDRESS OF THE ITEM
;      AT 0(T) ANND PLACES IT IN R2.  IN ADDITION 'RELBT' IS SET ON IN
;      THE LOWER PART OF 'FG' IF THE ADDRESS RETURNED IS RELOCATABLE.
;
;
 GTADD$:
    MOVEM  R2,LSTADD#  ;SAVE AS LAST ADDRESS
    TLNE   R2,VTREG    ;CHECK IF REGISTER
    JRST   GTAD1       ;HANDLE IF SO
    TLNE   R2,VTMAT    ;CHECK FOR MATRIX
    JRST   GTAD7       ;HANDLE IF SO
    TLNE   R2,VTVAR    ;CHECK IF VARIABLE
    JRST   GTAD2       ;HANDLE IF SO
    TLNE   R2,VTCON    ;CHECK FOR FULL CONSTANT
    JRST   GTAD4       ;HANDLE IF SO
    TLNE   R2,VTMEL    ;CHECK FOR MATRIX ELEMENT
    JRST   GTAD5       ;HANDLE IF SO
    TLNE R2,VTTMP 	;CHECK FOR TEMPORARY
    JRST GTAD9		;HANDLE IF SO
    TLNE R2,VTFC0 ;CHECK FOR FUNCTION
    JRST GTAD8 ;HANDLE FUNCTION
    TLNE R2,VTFCT	;CHECK FOR FAKED RTP FUNCTION
    JRST GTAD8D		;HANDLE IF SO
    BLOWUP    ;ELSE ERROR
;
;   REGISTER
;
 GTAD1:
    HRRZS  R2          ;GET REGISTER NUMBER ALONE IN R2
    MOVEI  R1,0        ;TYPE ADDRESS 0--ABSOLUTE (REG)
    POPJ P,      ;THAT'S ALL FOLKS
;
;   VARIABLE
;
 GTAD2:
    TLNE R2,VTSTR ;CHECK IF STRING
    JRST GTAD2S ;HANDLE IF SO
    MOVEI R1,2 ;OFFSET FOR NUMERIC
    HRRZ R2,SYMTAB(R2) ;LOC IN NVRS
    TRZE R2,VRGBL ;CHECK FOR GLOBAL VAR
    JRST GTAD2G ;HANDLE IF SO
    TRZN R2,VRFCT ;CHECK IF FCT LOCAL
    POPJ P, ;AND RETURN
;
 GTAD2F:
  HRLI R2,R.F ;AND REG
  MOVEI R1,0 ;ABSOLUTE
  POPJ P, ;THEN RETURN
;
 GTAD2G:
  TLO R2,20 ;GLOBAL VARIABLE
  MOVEI R1,2 ;INDIRECT AND NVR OFFSET
  POPJ P, ;THEN RETURN
;
 GTAD2S:
    MOVEI R1,3 ;IN SVRS--OFFSET
    HLRZ R2,SYMTAB(R2) ;GET LOC THERE
    TRZE R2,VRGBL ;CHECK FOR GLOBAL VAR
    JRST GTAD2G ;HANDLE IF SO
    TRZN R2,VRFCT ;CHECK IF IN NVRS (VRFCT BIT ON)
    POPJ P,      ;AND RETURN
    JRST GTAD2F ;AND HANDLE FUCNTION
;
;   MATRIX ELEMENT
;
 GTAD5:
  SKIPL RPGFG		;CHECK FOR ONE LINE ENTRY
  SKIPE PRGNM ;CHECK IF MAIN PROGRAM
  JRST GTAD5S ;HANDLE IF NOT
  TLNE R2,VTSTR ;CHECK IF STRIN
  TRO R2,400000 ;SET ON FLAG IF SO
  TLZ R2,777760 ;TURN OFF EXTRANEOUS BITS
  MOVEI R1,7 ;TYPE MAT
    POPJ P,      ;AND RETURN
;
 GTAD5S:
  TLZ R2,777760  ;ISOLATE REG OF OFFSET
  HRRI R2,0 ;NO ADDRESS
  MOVEI R1,0 ;AND MAKE THAT ABSOLUTE
  POPJ P, ;HANDLE
;
;   CONSTANT
;
 GTAD4:
    TLNE R2,VTSTR ;CHECK IF STRING CONST
    JRST GTAD4S ;HANDLE IF SO
    MOVE   R2,0(R2)    ;GET ACTUAL CONSTANT
    TRNE   R2,-1       ;CHECK IF HALF WORD OK
    JRST   GTAD6       ;NO
    HLRZS  R2          ;YES--GET AS ADDRESS
    MOVEI  R1,1        ;TYPE ADDRESS IMMED
    POPJ P,      ;AND RETURR
;
 GTAD4S:
  HRRZS R2 ;GET ADDRESS OF STRING CONST
  MOVEI R1,4 ;TYPE RELOC OF CONST
  POPJ P, ;AND RETURN
;
 GTAD6:
    DSVCON (R2)      ;SAVE THE CONSTANT ADDRESS==>R2
    MOVEI  R1,4        ;TYPE ADDRESS CONSTANT
    POPJ P,      ;AND RETURN
;
;   MATRIX
;
 GTAD7:
    MOVE   R2,MATPTB(R2) ;GET PTR TO MAT BLOCK
    TLNE R2,MTGBL ;CHECK IF GLOBAL
    TLO R2,20 ;INDIRECT REF IF SO
    TLZ R2,777740 ;TURN OFF EXTRANEOUS BITS
    MOVEI  R1,2        ;TYPE ADDRESS NUM VAR
    POPJ P,      ;AND RETURN
;
;   FUNCTION
;
 GTAD8:
  HRRZS R2 ;ISOLATE ADDRESS
  CAIL R2,UFCATB ;CHECK IF USER/INTERNAL
  JRST GTAD8U ;JUMP FOR USER
  MOVEI R2,FCNAM(R2) ;IF INTERNAL--HANDLE
  TLO R2,20		;MAKE INDIRECT
  MOVEI R1,5 ;TYPE OFEXT
  POPJ P, ;AND RETURN
;
 GTAD8U:
  MOVEI R1,6 ;IF USER--TYPE OF USER FCT
  POPJ P, ;AND RETURN
;
 GTAD8D:
  HRRZS R2		;ISOLATE ADDRESS IN PRGM
  MOVEI R1,10		;RELOCATE FOR PROGRAM
  POPJ P,		;AND DONE
;
;
;   TEMPORARIES
;
 GTAD9:
  MOVEI R1,2 ;RELOC TYPE OF NVR
  TLNE R2,VTSTR ;CHECK IF STRING
  MOVEI R1,3 ;THEN TYPE OF SVR
  SKIPGE RPGFG		;CHECK FOR ONE-LINE COMPIJ&ATION
    MOVEI R1,4		;IF SO, MAKE CONSTANTS
  HRR R2,TMPTB(R2) ;GET PROPER VALUE
  TLZ R2,777740		;GET RID OF EXCESS BITS
  POPJ P, ;AND RETURN
;
;
  SUBTTL ARITHMETIC SUBROUTINES--SVADD
;
;   SVADD--THIS ROUTINE TAKES AN ADDRESS IN R2 AND SAVES IT FOR A SUBROUTINE
;     OR FUNCTION CALL.  IT SHOULD TURN ON WHATEVER BITS SYSTEM ROUTINES
;      REALLY WANTED ON AND SHOULD  CONVERT HALF WORD CONSTANTS TO FULL WORD
;      ONES.
;
;
 SVADD:
    TLO R2,320000 ;MAKE INTO JUMP
;
    JRST   @.+1(R1)    ;BRANCH ON ADDRESS TYPE
;
    JRST   .SVWD       ;ABSOLUTE
    JRST   SVAD2       ;IMMED
    JRST   .SVWD       ;VAR (NUMERIC)
    JRST   .SVWD       ;STRING VAR
    JRST   .SVWD       ;CONSTANT
    JRST   .SVEX       ;EXTERNAL
    JRST   .SVFC       ;INTERNAL FCT
    JRST   .SVWD       ;MAT
    JRST   SVAD3	;PROGRAM RELOC
;
;
 SVAD2:
    MOVEM  R2,LSTADD#  ;SAVE RESULT
    HRLZS  R2          ;GET CONSTANT OUT OF IT
    DSVCON (R2)      ;SAVE CONSTANT
    HLL    R2,LSTADD   ;RESTORE TYPE BITS
    MOVEI R1,4 		;TYPE OF CONSTANT
    JRST .SVWD		;HANDLE AS SUCH
;
;
 SVAD3:
    MOVEI R1,1		;PROGRAM RELOC
    JRST .SVWD		;SAVE IT
;
;
  SUBTTL ARITHMETIC SUBROUTINES--GTLOD
;
;   GTLOD--THIS ROUTINE CAUSES THE TOP ITEM ON THE VARIABLE STACK
;     TO BE LOADED INTO A REGISTER.
;
;
 GTLOD:
    MKLOD (T7)		;MAKE THE ITEM LOADABLE
    LOAD (T7)		;AND INSURE THAT IT IS LOADED
    PUSH   VS,T7	;RESTORE ITEM BACK ON STACK
    POPJ P,      ;AND RETURN
;
;
  SUBTTL ARITHMETIC SUBROUTINES--MKLOD
;
;   MKLOD--THIS ROUTINE TAKES THE TOP ITEM FROM THE VARIABLE STACK AND
;      MAKES SURE IT CAN BE LOADED DIRECTLY.  IF IT CAN'T IN ITS
;      PRESENT FORM, IT IS FORCED INTO A MORE COMPATIBLE FORM, GENERALLY
;      IN A REGISTER.
;
;
 MKLOD$:
    POP    VS,T7       ;GET TOP ITEM FROM STACK
    TLNE   T7,VTNDR    ;CHECK IF DIRECTLY LOADABLE
    JRST   MKLD1       ;NO--HANDLE
;
 MKLD2:
    SKIPGE RPGFG	;CHECK FOR ONE-LINE COMPILATION
    JRST MKLD8	;HANDLE SPECIAL IF SO
    POPJ   P,	;AND RETURN
;
 MKLD1:
    TLNE   T7,VTFC0    ;CHECK FOR FCT OF 0 ARGS
    JRST   MKLD4       ;HANDLE IF SO
    TLNE   T7,VTSBC    ;CHECK IF SUBSCRIPTED
    JRST   MKLD3       ;HANDLE IF SO
;
 MKLD5:
    FNCAL (T7)		;ELSE HANDLE FUNCTION CALL
    JRST   MKLD2       ;AND THEN DONE
;
 MKLD3:
    GNSUB (T7)		;HANDLE SUBSCRIPTED
    JRST   MKLD2       ;AND THEN DONE
;
 MKLD4:
  PUSH VS,T7 ;SAVE RESULT BACK ON STACK
  MOVSI R2,000000 ;ZERO ARG FCT FCIDWD
  TLNE T7,VTSTR ;CHECK IF STRING FCT
  TLO R2,004000 ;MARK IS SO
  PUSH VS,R2 ;SAVE ON STACK
  PUSH VS,[0] ;SAVE NUM ARGS
  JRST MKLD5 ;AND PROCESS FUNCTION
;
;
 MKLD8:
  TLNE T7,VTCON		;CHECK FOR CONSTANT STRING
  TLNN T7,VTSTR
    POPJ P,		;RETURN NOW IF NOT (LOADABLE NOW)
;
  MOVEI R2,R.DSTR	;CALL DEBUGGER STRING ROUTINE
  PUSHJ P,SVCAL		;SAVE CALL
  GTADD (T7)		;GET THE ADDRESS OF STRING CONST
  PUSHJ P,SVADD		;AND SAVE IT
  HRLZI R1,200000	;GET 1
  ANDCAM R1,REGFGS	;NOW IN USE
  HRLZI T7,VTREG+VTSTR	;BITS FOR NEW STRING
  HRRI T7,1		;IN REG 1
  POPJ P,		;AND RETURN IT
;
;
SUBTTL ARITHMETIC SUBROUTINES--XMKLOD
;
;   XMKLOD--THIS ROUTINE USES MKLOD AND FUNCTIONS SIMILARLY.  THE
;      ONLY DIFFERENCE IS THAT THE ARG IS SAVED IN 'FSTARG' AS
;      THE FIRST ARGUMENT FOR LATER CHECKS (IE IF SECOND CAUSES
;      0 AND 1 TO BE SAVED AND FIRST IS THRE).
;
;
XMKLD$:
;
  MOVEM T7,FSTARG ;SAVE ITS LOC
  JRST MKLOD$ ;AND USE MKLOD$
;
;
  SUBTTL ARITHMETIC SUBROUTINES--LOAD
;
;   LOAD--THIS TROUTINE FORCES THE ITEM SPECIFIED BY 0(T) TO BE LOADED
;      INTO A REGISTER.  THE ITEM MUST BE LOADABLE (MKLOD) FIRST.
;
;
 LOAD$:
    TLNE   T3,VTREG    ;CHECK IF ALREADY IN REG
    JRST LOAD1 ;JUST RETURN IF SO
    TLNE   T3,VTNDR    ;CHECK IF DIRECTLY LOADABLE
    BLOWUP    ;IF NOT, SYSTEM ERROR
;
    GTREG (T4) ;GET A REGISTER INTIO
    TLNE T3,VTSTR	;CHECK FOR STRING
    JRST LOAD2		;HANDLE SPECIAL IF SO
    PUSHJ  P,DAROP     ;GENERATE LOAD
    EXP    [MOVE 0]    ;USING 'MOVE'
    EXP    T4          ;REG
    EXP    T3          ;ITEM
    POPJ P, ;AND RETURN WITH NEW VALUE
;
 LOAD1:
  AOS 0(P) ;NO NEW VALUE--BUMP RET8URN
  POPJ P, ;AND EXIT
;
 LOAD2:
  PUSHJ P,DAROP		;GENERATE SKIPE LOAD OF STRING
    EXP [SKIPE 0]
    EXP T4
    EXP T3		;INTO NEW REGISTER
  HRLZ R2,T4		;GET REG NUMBER IN INDEX FIELD
  ADD R2,[AOS -1]	;GENERATE $$$AOS -1(REG)$$$
  SAVWD			;AND SAVE IT
  POPJ P,		;THEN RETURN
;
;
SUBTTL  ARITHMETIC SUBROUTINES--DORSB1
;
;   DORSB1--THIS ROUTINE GENERATES A CALL TO A RTP FCT
;      WITH ONE ARGUMENT WHERE THE ARGUMENT IS CURRENTLY
;      ON THE VARIABLE STACK.
;
;
DORSB1:
;
  MKLOD (T7) ;LOAD THE ARG
  SETZM FSTARG ;NO FIRST ARGUMENT
;
  PUSH VS,T7 ;SAVE THE VALUE BACK ON STACK
  HRRI FG,CLTEXT+1 ;EXTERNAL CALL FROM VS
  PUSHJ P,GCALL ;GENERATE CALL
  POPJ P, ;AND RETURN
;
;
SUBTTL ARITHMETIC SUBROUTINS--DORSB2
;
;   DORSB2--SUBROUTINE OF ABOVE TO GENERATE CODE FOR A RTP CALL OF TWO
;      ARGUMENTS, THE TOP TWO ITEMS ON THE STACK.
;
;
 DORSB2:
  XMKLOD (T0) ;LOAD THE FIRST ARGUMENT IF NEEDED
  MKLOD (T7) ;LOAD THE SECOND ARG IF NEEDED
  PUSH VS,T7 ;SAVE FIRST BACK ON STACK
  PUSH VS,T0 ;AND SECOND AS WELL
  HRRI FG,CLTEXT+2 ;EXTERNAL CALL FROM VS FOR 2 ARGS
  PUSHJ P,GCALL ;GENERATE CALL
;
    POPJ P,      ;AND THEN RETURN
;
;
SUBTTL ARITHMETIC SUBROUTINES--TMPRG
;
;   TMPRG--THIS ROUTINE TAKES A REGISTER NUMBER IN R2 ON ENTRY
;      AND SAVES IT IN A TEMPORARY CELL, RETURNING THE DATA
;      WORD FOR THE TEMPORARY IN R2 ON EXIT.
;
;
TMPRG:
;
  PUSH P,T0 ;SAVE T0 THROUGHOUT
  MOVN T0,R2 ;GET REG NUMBER IN T0 NEGATED
  HRLZI R1,400000 ;GET BIT FOR REG 0
  LSH R1,0(T0) ;ADJUST FOR GIVEN REG
  IORM R1,REGFGS ;RELEASE THE REGISTER
;
  MOVEI R1,GTNTMP ;GUESS WE WANT A NUMERIC TEMP
  TLNE R2,VTSTR ;CHECK THAT
  MOVEI R1,GTSTMP ;ELSE STRING TEMP
  HRRZ T0,R2 ;GET REGISTER NUMBER ALONE IN T0
  PUSHJ P,0(R1) ;GET OUR TEMP
  PUSH P,R2 ;SAVE PTR TO TEMP
  GTADD (R2) ;GET ADDRESS/RELOC TO USE FOR IT
  LSH T0,4+1 ;MOVE REG TO REG FIELD
  HRLI R2,202000(T0) ;GET SAVE INST (MOVEM)
  PUSHJ P,SVREL ;SAVE IT
;
  POP P,R2 ;RESTORE TEMP VAR WORD
  POP P,T0 ;RESTORE T0
  POPJ P, ;AND RETUR
;
;
SUBTTL ARITHEMETIC SUBROUTINE TMPMEL
;
;   TMPMEL--THIS ROUTINE SAVES THE MATRIX ELEMENT IN R2 ON ENTRY
;      IN A TEMP AND RETURNS THE APPROPRIATE DATA WORD FOR IT ON
;      R2 EXIT
;
;
TMPMEL:
;
  HLRZ R1,R2 ;GET REG USED
  ANDI R1,17 ;AND ONLY IT
  HLL R1,R2 ;GET DATA WORD FOR REG
  SKIPE PRGNM ;CHECK IF MAIN PROGRAM
    JRST TMPML1 ;HANDLE SUBROUTINE
;
  PUSH P,R1 ;SAVE R1 FOR NOW IF MAIN PRGM
  GTADD (R2) ;GET ADDRESS/RELOC FOR MEL
  HRLI R2,(ADDI) ;WE WANT TO GET REAL ADDRESS
  MOVE R1,0(P) ;PICK UP REG USED
  LSH R1,22+4+1 ;ADJUST TO REG FIELD
  ADD R2,R1 ;USE THAT REG IN OP
  MOVEI R1,7 ;RELOC OF MATRIX
  PUSHJ P,SVREL ;SAVE THE ADD
  POP P,R1 ;NOW RESTORE REG WORD
;
 TMPML1:
  MOVE R2,R1		;GET RESULT IN R2
  PUSHJ P,TMPRG ;SAVE REG IN TEMP
  MOVSI R1,750000	;CHANGE MOVEM TO HRRZM
  XORM R1,@OBJTL	;IN CREATED STORE INST
  TLO R2,20 ;AND GO INDIRECT FOR MATRIX ELEMENT
  POPJ P, ;THEN DONE
;
;
SUBTTL ARITHMETIC SUBROUTINES--FREFG
;
;   FRERG--THIS ROUTINE FREES A REG USED ON THE VARIABLE STACK
;      BY SAVING IT IN A TEMPORARY.  IT WILL LOOK FOR EITHER
;      TEMPORARY VALUES IN REGS OR MATRIX ELEMENTS IN REGS.
;
;
FRERG:
;
  PUSH P,T0 ;SAVE T0
  MOVEI T0,ARVST ;PTR TO STACK
;
 FRERG1:
  CAILE T0,0(VS) ;CHECK IF DONE
    ERR E.CMP ;COULDN'T FIND ANYTHING TO RELEASE
  MOVE R2,0(T0) ;CHECK NEXT ITEM
  TLNE R2,VTMEL ;CHECK FOR MATRIX ELEMENT
    JRST FRERG2 ;HANDLE IF SO
  TLNN R2,VTREG ;CHECK FOR REGISTER
    AOJA T0,FRERG1 ;NO--TRY AGAIN
;
  PUSHJ P,TMPRG ;REGISTER VALUE--EXCHANGE WITH TEMP
;
 FRERG3:
  EXCH R2,0(T0) ;SAVE NEW ITEM  BACK ON STACK
  POP P,T0 ;RESTORE T0
  POPJ P, ;AND RETURN
;
 FRERG2:
  PUSHJ P,TMPMEL ;SAVE MAT ELEMENT
  JRST FRERG3 ;SAVE AND EXIT
;
;
SUBTTL ARITHEMTIC SUBROUTINES--GTSTMP,GTNTMP
;
;   GTXTMP--THESE ROUTINES GET A TEMPORARY OF THE SPECIFIED TYPE
;      AND RETURN THE DATA WORD FOR IT IN R2.  IF NO MORE TEMPS
;      ARE AVAILABLE AN ERROR MESSAGE IS PRINTED.
;
;
GTSTMP:
;
  PUSH P,T0 ;SAVE T0
  HRRZ R1,TMPFGS ;LOOK ONLY AT STR TEMPS
  MOVEI T0,SADDN ;USE STRING AREA
  JRST GTTMP1 ;AND SKIP
;
;
GTNTMP:
;
  PUSH P,T0 ;SAVE T0
  HLLZ R1,TMPFGS ;USE ONLY NUMERIC TMPS
  MOVEI T0,VADDN ;USE NUMERIC AREA
;
 GTTMP1:
  JFFO R1,.+2 ;FIND TEMP TO USE
    ERR E.CMP ;MUST FIND ONE
  MOVNS R2		;GET NEG THE TEMP NUMBER
  HRLZI R1,400000	;GET BIT FOR IT
  LSH R1,0(R2)		;ADJUST BIT FOR NUMBER
  ANDCAM R1,TMPFGS	;SET BIT OFF TO INDICATE IN USE
  MOVNS R2		;THEN RESTORE TEMPNUMBER
  HRLI R2,VTTMP+VTNUM ;GUESS NUMERIC
  CAIE T0,VADDN ;CHECK THAT
    TLC R2,VTNUM+VTSTR ;MAKE STRING
  SKIPE TMPTB(R2) ;CHECK IF ALLOCATED YET
    JRST GTTMP2 ;YES--SKIP
  SKIPGE RPGFG		;CHECK IF ONE LINE
    JRST GTTMP3		;HANDLE SPECIAL IF SO
  AOS R1,0(T0) ;NO--ALLOCATE A NEW TEMP IN PROPER AREA
  MOVEM R1,TMPTB(R2) ;SAVE IN TABLE
;
 GTTMP2:
  POP P,T0 ;RETURN ORIG T0
  POPJ P, ;AND RETURN
;
 GTTMP3:
  PUSH P,R2		;SAVE R2
  MOVEI R2,1		;GET DUMMY WORD
  SVCON (R1)		;SAVE CONSTANT FOR TEMP
  POP P,R2		;RESTORE TEMP NUMBER
  MOVEM R1,TMPTB(R2)	;SAVE LOC OF TEMP
  JRST GTTMP2		;AND CONTINUE NORMALLY
;
;
  SUBTTL ARITHMETIC SUBROUTINES--GTREG
;
;   GTREG--THIS ROUTINE PICKS A REGISTER WHICH IS CURRENTLY NOT
;     BEING USED BY THE OBJECT CODE AND PASSES IT BACK IN 'R7' AS
;      A VS-STACK TYPE WORD FOR THE REGISTER.  IT IS ALSO PLACED
;      IN 0(T) @ FOR THE CALLING ROUTINE.
;
;
 GTREG$:
    MOVE   R1,REGFGS   ;CHECK REGISTER USAGE
    TLZ    R1,600177   ;MARK REGS 0,1,14,15,16,17 AS USED
    JFFO   R1,.+2      ;CHECK FOR FREE REG
    JRST GTRGA ;HANDLE IF NO MORE--MUST RELEASE ONE
    TLNE FG,STRBT ;CHECK IF STRING
    TLO R2,VTSTR ;MARK AS SUCH
    TLNE FG,NUMBT ;CHECK IF NUMERIC
    TLO R2,VTNUM ;MARK AS SUCH
    TLO    R2,VTREG    ;TYPE OF REGISTER
    HRLZI   R1,400000   ;GET 0 BIT
    MOVNS  R2          ;GET NEGATIVE SHIFT COUNT
    LSH    R1,0(R2)    ;POSITION FOR REG USED
    MOVNS  R2          ;RESTORE POSITIVE REG NUMBER
    XORM   R1,REGFGS   ;MARK AS REG USED
    ORM    R1,REGUSD   ;AND PERMANENT USAGE
    POPJ P, ;AND RETURN
;
 GTRGA:
  PUSHJ P,FRERG ;GET A FREE REGISTER
  JRST GTREG ;AND TRY GETTING A REG AGAIN
;
;
  SUBTTL ARITHMETIC SUBROUTINES--RLREG
;
;   RLREG--THIS ROUTINE RELEASES REGISTERS WHICH WE ARE DONE WITH
;      IN THE OBJECT CODE.  IN THIS WAY THE REGISTER CAN BE USED AGAIN
;      AS A TEMPORARY IN THE SAME LINE.
;
;
 RLREG$:
    TLNN   T7,VTREG+VTMEL+VTTMP    ;CHECK FOR REGISTER
    POPJ   P,		;RETURN IF NOT--NO RELEASING NEEDED
    TLNE T7,VTMEL ;CHECK FOR MAT
    JRST RLREG1 ;HANDLE IF SO
    TLNE T7,VTTMP ;CHECK IF TEMP
    JRST RLTMP ;RELEASE IF SO
;
    HRLZI  R1,400000   ;GET 0 BIT
    MOVN   R2,T7       ;GET NEGATIVE SHIFT COUNT
    LSH    R1,0(R2)    ;POSITION FOR REGISTER TO RELEASE
    XORM   R1,REGFGS   ;AND MARK REG AS FREE
    TLNN   T7,VTSTR    ;CHECK FOR STRING IN REGISTER
    POPJ P,		;AND THEN RETURN
;
    MOVEI  R2,R.DLC    ;GET DEALLOCATION ROUTINE
    PUSHJ P,SVCAL     ;SAVE THE CALL FOR STRING
    HRRZ   R2,T7       ;GET ADDRESS (REGISTER)
    TLO R2,(JUMP) ;MAKE INTO NOP
    SAVWD              ;SAVE IT
    POPJ   P,		;AND THEN RETURN
;
 RLREG1:
  MOVS R2,T7 ;GET REG NUMBER IN R2
  ANDI R2,17 ;AND ONLY IT
  MOVNS R2 ;NEGATE IT
  HRLZI R1,400000 ;BIT FOR REG
  LSH R1,0(R2) ;ADJUST FOR PROPER REG
  XORM R1,REGFGS ;MARK REG AS FREE
  POPJ P, ;AND RETURN
;
 RLTMP:
  MOVN R2,T7 ;GET NEGATIVE TEMP NUMBER
  HRLZI R1,400000 ;GET BIT
  LSH R1,0(R2) ;ADJUST FOR TEMP
  IORM R2,TMPFGS ;RELEASE TEMP
  TLNE T7,VTNUM+20	;CHECK FOR NUMERIC/INDIRECT
    POPJ P,		;DONE IF SO
    POPJ P, ;DONE IF NOT
  MOVEI R2,R.DLC ;IF SO, MUST DEALLOCATE IT
  PUSHJ P,SVCAL ;SAVE CALL THE DLOC RTN
  GTADD (T7)		;GET ADDRESS TO USE
  TLO R2,(JUMP) ;OP OF JUMP (NOP)
  PUSHJ P,SVREL		;AND SAVE
  POPJ P, ;NOW DONE
;
;
  SUBTTL ARITHMETIC SUBROUTINES--RTCRG
;
;   RTCRG--THIS ROUTINE FREES REGISTER 0.  THIS IS THE REGISTER IN WHICH
;      VALUES ARE RETRNED FROM FUNCTIONS/SUBROUTINES AND VARIOUS RUN-
;     TIME CALLS. IT IS NOT PRESERVED OVER SUCH CALLS, AND THUS, BEFORE
;      IT CAN BE USED FOR ONE, IT MUST BE FREED.
;
;
 RTCRG:
    PUSH   P,T7        ;SAVE T7
    MOVE   T7,REGFGS   ;GET REGS USED
    TLOE   T7,400000   ;CHECK IF R0 USED
    JRST   RTRC2       ;SKIP IF NOT
    MOVEI  T7,0        ;REG ZERO
    PUSHJ P,REPRG     ;REPLACE REG
;
 RTRC2:
    MOVE   T7,REGFGS   ;CHECK REGS USED
    TLOE   T7,200000   ;FOR REG 1
    JRST   RTRC1       ;SKIP IF REG 1 FREE
    MOVEI  T7,1        ;ELSE SAVE AND RELEASE REG 1
    PUSHJ P,REPRG     ;WITH THE ROUTINE
;
 RTRC1:
    MOVSI T7,600000 ;BITS FOR REGS 0,1
    IORM T7,REGFGS ;MARK AS FREE
    POP    P,T7        ;RESTORE T7
    POPJ P,      ;AND RETURN
;
;
;
  SUBTTL ARITHMETIC SUBROUTINES--REPRG
;
;   REPRG--THIS ROUTINE WILL RELEASE AND REPLACE A REGISTER WITH
;      ANOTHER.  IT IS USED MAINLY TO RELEASE R0,R1 BEFORE FCT CALLS
;      DURING ARITHMETIC SCAN.  THE REGISTER IN QUESTION IS IN T7 ON
;      ENTRY.
;
;
 REPRG:
    GTREG (R2)		;GET ANOTHER REG
    MOVEM  R2,XTEMP    ;SAVE THE REG WE GOT
    LSH    R2,22+4+1   ;TO REG FIELD
    TLO    R2,(MOVE) ;GENERATE INSTRUCTIONS TO MOVE ITEM
    ADD    R2,T7       ;FROM REG
    SAVWD              ;SAVE IT
;
  SKIPN R2,FSTARG ;CHECK IF FIRST ARG SAVED
  JRST REPRG1 ;NO--SKIP
  MOVE R1,0(R2) ;GET IT IF SO
  TLNN R1,VTREG ;CHECK FOR IN REG
  JRST REPRG1 ;NO--SKIP
  HRRZS R1 ;IF SO,ISOLATE NUMBER
  CAMN T7,R1 ;CHECK IF ONE WE ARE SAVING
  JRST REPRG2 ;YES--U@SAVE
;
 REPRG1:
    HRRZ   R2,VS       ;GET STACK TOP
    HRLZI  R1,VTREG    ;CHECKING FOR ITEM
    TDNN   R1,0(R2)    ;LOOK FOR REG ON STACK
    SOJA   R2,.-1      ;MUST BE THERE
    HRRZ   T6,0(R2)    ;FOUND REG--CHECK IF RIGHT ONE
    CAME   T6,T7       ;FROM START
    SOJA   R2,.-4      ;NO--KEEP TRYING
    CAIGE R2,ARVST ;CHECK IF IN BOUNDS
    BLOWUP ;IF NOT, THEN WE LOST WHERE R0/R1 IS
;
 REPRG2:
    HRRZ   R1,XTEMP    ;RESTORE NEW REG
    HRRM   R1,0(R2)    ;AND CHANGE ITEM ON STACK
    POPJ P,      ;AND THEN RETURN
;
;
;
    PRINTX *****START OF BAS50*****
;
;
SUBTTL STATEMENT ROUTINES--CALL
;
;   S.CAL--THIS ROUTINE PROCESSES THE CALL STATEMENT.  IT 
;      GENERATES A JSA T,<RTN> FOR THE EXTERNAL RTN
;      FOLLOWED BY ITS ARGS.
;
;
S.CAL:
;
  SPELL L ;CAL'L
;
  SETOM CALFG ;MARK AS CALL RATHER THAN SUB
  HRLZI FG,STRBT ;SCAN STRING
  PUSHJ P,ARSCN ;EXPRESSION
  POP VS,T0 ;GET RESULT
  TLNN T0,VTCON ;MUST BE SCNSTANT FOR NOW
    ERR E.CLNM ;ERROR IF NOT
  PUSHJ P,FNDSUB ;FIND THE SUB FOR THIS STRING
;
  PUSHJ P,STSBAR ;SET UP FOR SUB ARGS
  MOVEM P,TEMPA ;SAVE INITIAL PDL
  CAIE CH,ASCCOL ;CHECK FOR ':'
    JRST CALL1 ;NO--NO ARGS--SKIP
;
;   HANDLE ARGS
;
 CALL2:
  TLZ FG,NCHBT ;IGNORE CURRENT CHR
  PUSHJ P,SBARG ;GET NEXT ARG
    NOP ;SKIP IF NOT VAR
  MOVE R2,T0 ;GET ARG
  TLNE R2,VTCON		;CHECK FOR CONSTANT
    PUSHJ P,CALCON	;HANDLE--MOVE TO TEMP
  TLNE R2,VTFC0		;CHECK FOR FUNCTION
    PUSHJ P,CALFCT	;CHECK--EXTERNAL FCTS MUST BE KLUDGED
  TLNE R2,VTMEL ;CHECK FOR MATRIX ELEMENT
    PUSHJ P,TMPMEL ;SAVE AS TEMP IF SO
  TLNE R2,VTREG ;CHECK FOR REG VALUE
    PUSHJ P,TMPRG ;SAVE AS TEMP IF SO
  PUSH P,R2 ;SAVE ITEM ON STACK
  CAIN CH,ASCCMA ;CHECK FOR ',' TERM
  JRST CALL2 ;HANDLE IF SO
;
 CALL1:
  PUSHJ P,CKSBTY ;CHECK ARG TYPES
  HRRZ T2,CRSUB ;GET PTR TO CURRENT SUB
  MOVSI R1,SBBUSD ;GET BIT FOR DEFINED
  TDNN R1,SUBBTS(T2) ;CHECK IF PREVIOUSLY DEFINED
  AOS NUMSUB ;NO PREVIOUS  USE--UPDATE SUB COUNT
  IORM R1,SUBBTS(T2) ;MARK AS USED
;
  HRRI FG,CLTEXT+CLBPS+CLBPJ ;EXTERNAL CALL ARGS FROM PS
  ADD FG,NSBARG ;NUMBER OF ARGS FOR CALL
  PUSHJ P,GCALL ;GENERATE CALL
;
  SKIPN DEBFG ;CHECK IF DEBUG MODE
    JRST RTEOL ;NO--DONE
  MOVEI R2,R.DBSX ;YES--TELL DEBUGGER WE RETURNED
  PUSHJ P,SVCAL ;SAVE CALL TO DEBUGGER
  JRST RTEOL ;AND DONE
;
;
  SUBTTL STATEMENT ROUTINES--CHA (CHAIN AND CHANGE)
;
;   S.CHA--'CHA' SCANNED--CHECK FOR CHAIN OR CHA'NGE.
;
;
 S.CHA:
    JSP    T,NXECH     ;CHECK FOURTH CHARACTER
    CAIN   CH,ASC..N   ;FOR 'N'
    JRST   S.CHNG      ;HANDLE CHANGE
    CAIN   CH,ASC..I   ;CHECK FOR 'I'
    JRST   S.CHAN      ;HANDLE CHAIN
    ERR    E.ILST      ;ELSE ERROR
;
;
;
SUBTTL STATEMENT ROUTINES--CHAN (CHAIN)
;
;   S.CHAN--THIS ROUTINE HANDLES THE CAHIN STATMENT.  IT GENERATES
;      A CALL TO THE RUN TIME PACKAGE PASSING THE NUMBER OF FILES
;      TO BE PASSED IN R1 AND FOLLOWED BY THE FILE TO CHAIN TO,
;      THE SYSTEM (NULL FOR NONE GIVEN), AND THE FILES.
;
;
S.CHAN:
;
  SPELL N		;CHAI'N
;
  MOVEI R2,TRSYST!TRWITH	;ALLOW 'SYSTEM' OR 'WITH' AS TERMS
  MOVEM R2,ALWTRM
  JSP T,NXECH		;GET NEXT CHR
  CAIN CH,ASCNUM	;CHECK FOR # (CHAIN#N)
    JRST CHANN		;HANDLE IF SO
  MOVEI R2,R.CHAN	;ELSE NORMAL CHAIN
  MOVEM R2,TEMPB	;SAVE RTP NAME
  HRLZI FG,STRBT!NCHBT	;WANT A STRING
;
 CHAN4:
  PUSHJ P,ARSCN 	;GET IT
  SETZM ALWTRM		;CLEAR TERM
;
  MKLOD (T7)		;GET RUESULT
  PUSH VS,T7		;SAVE ITEM BACK ON STACK
  PUSHJ P,RTCRG		;FREE REGS 0,1
  POP VS,T7		;RESTORE ITEM
  PUSH P,T7		;SAVE ON STACK
  MOVE R2,ARTERM	;GET TERMINATOR
  CAIE R2,TRSYST	;CHECK FOR 'SYSTEM'
    JRST CHAN1		;SKIP IF NOT
;
  MOVEI R2,TRWITH	;ALLOW 'WITH' TO TERM SYSTEM NAME
  MOVEM R2,ALWTRM
  HRLZI FG,STRBT+NCHBT	;WANT A STRING
  PUSHJ P,ARSCN		;SO GET ONE
  SETZM ALWTRM		;NO MORE TERMS ALLOWED
  MKLOD (T7)		;GET RESULTANT STRING
  PUSH VS,T7		;PUT ITEM BACK ON V STACK
  PUSHJ P,RTCRG		;RELEASE REGS 0,1
  POP VS,T7		;RESTORE ITEM IN T7
  PUSH P,T7		;SAVE IT
  JRST CHAN2		;AND SKIP
;
 CHAN1:
  MOVEI R2,0		;ZERO FOR CONSTANT STRING
  DSVCON (R2)		;OF A NULL STRING FOR NO SYSTEM
  HRLI R2,VTSCN		;GET WORD FOR IT
  PUSH P,R2		;SAVE ON STACK
;
 CHAN2:
  SETZM TEMPA		;CLEAR COUNTER OF NUMBER OF FILES
  MOVE R2,ARTERM	;GET TERMINATOR
  CAIE R2,TRWITH	;CHECK FOR 'WITH'
    JRST CHAN5		;NO--NO FILES--SKIP
  SKIPA			;ALREADY HAVE NEXT CHR
;
 CHAN3:
  JSP T,NXECH		;GET CHR
  CAIE CH,ASCNUM	;MUST BE '#'
    ERR E.INFT		;OR ELSE ERROR
  HRLZI FG,NUMBT	;SCAN A NUMBER
  PUSHJ P,CARSCN
  MKLOD (T7)		;AND PICK IT UP
  PUSH P,T7		;SAVE ON STACK
  AOS TEMPA		;BUMP FILE COUNTER
  MOVE R2,ARTERM	;CHECK TERM
  CAIN R2,ASCCMA	;FOR COMMA
    JRST CHAN3		;LOOP IF MORE
;
 CHAN5:
  MOVE R2,TEMPA		;GET NUMBER FILES
  HRLI R2,(MOVEI 1,)	;INST TO LOAD THAT AT RUN TIME
  SAVWD			;SAVE IT
  MOVE R2,TEMPA		;GET NUMBER FILES AGAIN
  HRRI FG,CLBPS+CLTEXT+2(R2)	;CALL BITS
  MOVE T2,TEMPB	;CHAIN ROUTINE
  PUSHJ P,GCALL		;GENERATE CALL TO CHAIN ROUTINE
  JRST EOL		;AND DONE
;
 CHANN:
  MOVEI R2,R.CHNN	;ROUTINE FOR CHAIN #1
  MOVEM R2,TEMPB	;SAVE
  HRLZI FG,NUMBT	;GET BIT FOR NUMERIC EXPRESSION
  JRST CHAN4		;HANDLE RESTO OF CHAIN
;
;
  SUBTTL STATEMENT ROUTINES--CHANGE
;
;   S.CHNG--THIS ROUTINE HANDLES THE CHANGE STATEMENT.  IT GENERATES A
;      CALL TO ONE OF FOUR ROUTINES IN THE OBJECT CODE.
;
;
 S.CHNG:
    SPELL <G,E>        ;CHAN'GE
    SETZM  TEMPB       ;TYPE OF CHANGE FLAG
    SETOM CHNGFG	;INDICATE CHANGE STATEMENT
    MOVEI T1,TRTO ;'TO' ALLOWED AS TERM
    MOVEM T1,ALWTRM ;AND INDICATE THAT
    MOVEI T1,1		;NUMBER OF IMPLIED DIMS
    MOVEM  T1,XNSBCS   ;SAVE FOR MAT ALOCATION
    SETOM SBCERF ;MUST BE VECTOR
    HRLZI  FG,         ;ARITHMETIC SCAN
    PUSHJ P,ARSCN       ;FOR FIRST ITEEM
;
    CAMN CH,ARTERM ;MAKE SURE WE DIDN'T GET CHR TERM
    ERR    E.INFT      ;ERROR IF NOT
    TLNE   FG,STRBT    ;CHECK IF STRING
    JRST   CHNG1       ;HANDLE STRING-TO-MATRIX
;
    POP    VS,T7       ;MATRIX -TO-STRING
    TLNN   T7,VTVAR    ;CHECK FOR NUMERIC EXPRESSION OK FOR MATRIX
    ERR    E.INFT      ;ELSE ERROR
    HRRZS  T7          ;GET VARIABLE NUMBER
    CAILE  T7,32       ;A...Z???
    ERR    E.INFT      ;NO--ERROR
    HRLI   T7,VTMAT+VTNVR ;MARK AS NUMERIC MATRIX
    AOS    TEMPB       ;TYPE OF CHANGE IS M-S
    PUSHJ P,ALMAT     ;INSURE MATRIX APPEARS
    TLZ    FG,-1-NCHBT ;GET RID OF OLD BITS NO LONGER NEEDED
    TLO    FG,STRBT    ;SCAN STRING NEXT
    JRST   CHNG2       ;AND PROCESS
;
 CHNG1:
    MKLOD (T7)		;INSURE STRING IS LOADABLE
    TLZ    FG,-1-NCHBT ;GET RID OF OLD BITS
    TLO    FG,MATBT+NUMBT ;S-M  --  SCAN MATRIX NEXT
;
 CHNG2:
  PUSH P,T7 ;SAVE ARG ON STACK
  MOVEI R2,TRBIT ;ALLOW 'BIT' TO TERMINATE
  MOVEM R2,ALWTRM ;SAVE
    PUSHJ P,ARSCN       ;SCAN SECOND FIELD
    TLNN   FG,MATBT    ;CHECK FOR MAT(S-M)
    JRST   CHNG3       ;HANDLE NOT
    POP    VS,T7       ;YES MAT--CHECK FOR VAR
    TLNN   FG,VTVAR    ;AND NOT EXPRESSION
    ERR    E.INFT      ;ELSE ERROR
    JRST   CHNG4       ;PROCESS CALL
;
 CHNG3:
    MKLOD (T7)		;INSURE STRING LOADABLE
;
 CHNG4:
    PUSH P,T7 ;SAVE SECOND ARG
    HRRI FG,CLTEXT+CLBPS+2 ;EXT CALL WITH 2 ARGS ON P-STACK
    CAME   CH,ARTERM   ;CHECK FOR CHARACTER TERMINATOR
    JRST   CHNGBT      ;ELSE TRY CHANGE BIT
    MOVE   R2,TEMPB    ;CHECK TYPE OF CHANGE
    MOVE   T2,CHNGTB(R2) ;GET PROPER ROUTINE
    PUSHJ P,GCALL ;AND GENERATE CALL
    JRST   RTEOL         ;AND DONE
;
;
 CHNGTB:
    EXP    R.CHSM      ;CHANGE STRING TO MATRIX
    EXP    R.CHMS      ;CHANGE MATRIX TO STRING
;
;
;
SUBTTL STATEMENT ROUTINES--CHNGBT
;
;   CHNGBT--THIS ROUTINE PROCESS THE END OF A CHANGE BIT STARTING WITH
;     THE TERMINATOR 'BIT'.  IT IS A SHOOT OFF FROM THE CHANGE ROUTINE
;      IMMEDIATELY PRECEDING.
;
;
 CHNGBT:
    TLZ FG,-1-NCHBT	;CLEAR BITS EXCEPT NEXT CHR
    TLO FG,NUMBT	;WANT NUMERIC EXPRESSION
    PUSHJ P,ARSCN
    MKLOD (T7)		;INSURE ITS LOADABILITY
;
    PUSH P,0(P) ;MOVE DOWN ARGS TO MAKE ROOM FOR BIT SIZ5E
    EXCH T7,-2(P) ;SAVE BIT SIZE ARG
    MOVEM T7,-1(P) ;FINISH REARRANGING STACK
    MOVE R2,TEMPB ;GET TYPE OF CHANGE
    MOVE T2,CHBTTB(R2) ;GET PROPER ROUTINE TO CALL
    HRRI FG,CLTEXT+CLBPS+3 ;EXT CALL OF 3 ARGS ON P-STACK
    PUSHJ P,GCALL ;AND GENERATE CALL
    JRST RTEOL ;THEN DONE
;
;
 CHBTTB:
    EXP    R.CBSM      ;CHANGEEBIT STRING TO MATRIX
    EXP    R.CBMS      ;CHANGE BIT MATRIX TO STRING
;
;
;
  SUBTTL STATEMENT ROUTINES--DATA
;
;   S.DAT--THIS ROUTINE HANDLES A DATA STATEMENT. IT GENERATES
;      A LINKED LIST (WITH RELATIVE LINKS) IN THE CONSTANT AREA.
;      THERE ARE TWO LISTS, ONE FOR NUMBERS AND ONE FOR STRINGS.  THE
;     LINK ALWAYS OCCUPIES THE LOWER HALF OF THE WORD.  IN THE CASE OF
;      STRINGS AND HALF WORD CONSTANTS, THE DATA OCCUPEIES THE
;      UPPER HALF.  IN THE CASE OF FULL WORD CONSTANTS, THE DATA IS
;      CONTAINED IN THE SUBSEQUENT WORD AND 0 IS IN THE UPPER HALF.
;
;
 S.DAT:
    SPELL <A>          ;DAT'A
;
 DATA0:
    JSP    T,NXECH     ;CHECK NEXT CHAR--START OF DATUM
    CAIL   CH,ASC..0   ;CHECK FOR DIGIT
    CAILE  CH,ASC..9
    JRST   .+2         ;SKIP IF NOT
    JRST   DATA1       ;HANDLE AS NUMBER IF SO
    CAIN   CH,ASCQTE   ;QUOTE--STIRNG
    JRST   DATA5
    CAIN   CH,ASCDOT   ;PERIOD--NUMBER
    JRST   DATA1
    CAIN   CH,ASCPLU   ;'+'
    JRST   DATA1       ;NUMBER
    CAIN   CH,ASCMIN   ;'-'
    JRST   DATA1       ;NUMBER
    JRST   DATA4       ;ELSE UNQUOTED STRING
;
;   HANDLE NUMBER
;
 DATA1:
    HRLZI  FG,NCHBT+NUMBT ;SCAN NUMBER
    PUSHJ P,ARSCN
    POP    VS,T1       ;MAKE SURE THAT'S ALL WE GOT
    TLNN   T1,VTCON    ;A CONSTANT
    ERR    E.DATA      ;ERROR IF NOT
    MOVE   T2,0(T1)    ;GET ACTUAL CONSTANT IN T2
    MOVEI  T3,NDATP    ;DATA LIST
;
;   SAVE NEXT DATUM (T2) ON LIST (T3)
;
 DATA7:
    MOVEI R1,4 ;CONST RELOC
    MOVEI R2,1 ;NOTHING FOR NOW
    XSVCON (R2) ;SAVE IN CONST AREA
    SKIPE  0(T3)       ;CHECK IF FIRST LINK
    JRST   .+3         ;SKIP IF THERE
    MOVEM  R2,1(T3)    ;SAVE
    JRST   DATA3         ;AND SKIP AFTER HANDLING FIRST LINK
;
    MOVE R1,0(T3)	;GET LINK WORD
    ADD R1,CONST	;AND RELOCATE IT
    HRRM   R2,-1(R1)   ;SAVE FOR LAST LINK
;
 DATA3:
    MOVEM  R2,0(T3)    ;SAVE
    TRNN   T2,-1       ;CHECK IF HALF/FULL WORD
    JRST   DATA2       ;HANDLE HALF WORD
    HRLI   R1,1        ;GET MARKER FOR FULL WWRD *****
    HLLM   R1,@CNSTK    ;SAVE IT
    MOVE R2,T2 ;GET CONSTANT TO BE SAVED
    SVCON () ;AND SAVE
    JRST   DATA9       ;CONTINUE
;
 DATA2:
    HLLM   T2,@CNSTK    ;SAVE HALF WORD DATAM IN UPPER HALF
;
;   HANDLE NEXT DATUM OR END OF LINE
;
 DATA9:
    TLZN   FG,NCHBT    ;GET NEXT CHAR
    JSP    T,NXECH     ;CALLING FOR IT AS NEEDED
    CAIN   CH,ASCCMA   ;CHEC FOR ','
    JRST   DATA0       ;FOUND--ANOTHER ITEM ON LINE
    TLO    FG,NCHBT    ;WE HAVE SCANNED EOL
    JRST   EOL         ;NO--END OF LINE
;
;   HANDLE IMPLICIT STRING
;
 DATA4:
    TLO    FG,NCHBT    ;SCANNED TOO FAR
    PUSHJ P,DMSTR     ;SCAN THE STRING
    EXP    ASCCMA      ;LOOKING FOR A COMMA
    TLO    FG,NCHBT    ;SET SAYING SCANNED EXTRA CHAR
    JRST   DATA6       ;SKIP WHEN DONE
;
;   HANDLE QUOTED STRING
;
 DATA5:
    HRLZI  FG,NCHBT+STRBT ;SCAN A STRING
    PUSHJ P,ARSCN
    POP    VS,T1       ;MAKE SURE THAT'S ALL WE GOT
    TLNN   T1,VTCON    ;BY CHECKING FOR CONSTANT
    ERR    E.DATA      ;ERROR IF MORE
;
 DATA6:
    HRLZI T2,-1 ;STRING VAL
    MOVEI  T3,SDATP    ;USE STRING DATA POINTER
    JRST   DATA7       ;AND SAVE DATUM
;
;
;
  SUBTTL STATEMENT ROUTINES--DEF
;
;   S..DEF--THIS ROUTINE HANDLES THE START OF A FUNCTION DEFINITION.  IT
;      SCANS THE FUNCTION NAME AND THEN THE ARGUMENT LIST. IT SETS UP
;     THE COMPILERS PDL FOR THE FUNCTION AND GENERATES A JUMP AROUND
;      THE FUNCTIONS CODE.  IN ADDITION, A SYMBOL IS SET UP FOR ENTERING IT.
;
;   THE STACK SHOULD LOOK LIKE THIS AFTER A DEF IS SCANNED:
;
;         <OBJAD> OF TRANSFER
;      XP: -1     FLAG
;         <SYM VAAUE> SAVED FROM OLD
;         <SYM NUMBER> OF ARG
;         ...          REPEAT FOR EACH ARG
;         <# ARGS>
;         <REGUSD>
;         XP
;         <VADDN> OF FUNCTION NAME IF MULTIPLE LINE DEF
;        <ULNLS>
;        <LINE NUMBER>
;
;   IN ADDITION, THIS ROUTNE GENERATES THE COMPUTING CODE FOR SINGLE
;      LINE DEFS AND THEN TRANSFERS TO THE 'FNEND' ROUTINE TO FINISH
;      THEM UP.
;
;
 S.DEF:
    SKIPE CURFCT ;CHECK IF CURRENTLY INSIDE FCT
    ERR E.NSFC ;ERROR IF SO
    SPELL <F,N>        ;GET 'FN' FROM FUNCTION NAME
    AOS    NUMFCT      ;ONE MORE FCT
    JSP    T,NXECH     ;CHECK THIR CHAR
    CAIL   CH,ASC..A   ;FOR ALPHABETIC
    CAILE  CH,ASC..Z
    ERR    E.INFT      ;ERROR IF NOT
    HRRZI  T7,-ASC..A(CH) ;GET FUNCTION NUMBER IN T7
    JSP    T,NXECH     ;CHECK NEXT CHARCTER
    MOVEI  T6,0        ;T6 IS THE BITS WORD
    HRLI   T7,VTNVR    ;TYP OF NUMBERI VAR
    CAIE   CH,ASCDOL   ;CHECK FOR '$'
    JRST   DEF1        ;NOO
    TLO    T6,004000   ;IS--MARK AS STRING FCT
    HRLI   T7,VTSVR     ;TYPE OF STRING VAR
    JSP    T,NXECH     ;IGNORE '$'
;
 DEF1:
  MOVEM T7,CURFCT ;SAVE ITEM AS CUR FCT
  MOVE T5,LSTLN ;GET CURRENT LINE
  MOVEM T5,FCTLIN ;SAVE THAT AS HEAD OF FCT LINE
    MOVEI  T5,0        ;NUMBER OF ARGS
  PUSH P,OBJPT ;SAVE CURRENT LOC ON STACK
  MOVSI R2,(JRST) ;GET DUMMY JUMP
  SVWPR ;SAVE IN OBJECT
  SETOM TEMPC ;OFFSET NUMBER CLEAR
    PUSH   P,[-1]      ;SAVE FLAG
    MOVE   T3,P        ;GET SAVED PDL POINTER IN T3
    CAIE   CH,ASCLPR   ;CHECK IF ARGUMENT LIST
    JRST   DEF3        ;NO--JUMP
;
;   SCAN ARGUMENTS
;
 DEF2:
    TLZ FG,NCHBT ;NEXT CHR NOT SCANNED
    PUSHJ P,SVRNM       ;GET STRING/NUMERIC VARIABLE NAME
    PUSH   P,SYMTAB(T0) ;SAVE OL SYMBOL TABLE LOC
    PUSH   P,T0        ;SAVE NEW VARIALB ENUMBER
  AOS T1,TEMPC ;GET OFFSET ADDRESS
  TRO T1,VRFCT ;IF SO, THEN MARK AS NVR OFFSET
  TLNE T0,VTSTR ;CHECK IF STRING
  HRLM T1,SYMTAB(T0) ;SAVE AS STRING
  TLNE T0,VTNUM ;CHCK IF NUMERIC
  HRRM T1,SYMTAB(T0) ;SAVE FR NUMERIC
    SOS    T5          ;ARG COUNT
    TLNN   T0,VTSTR    ;CHECK FOR STRING
    JRST   DEF4        ;HANDLE IF NOT
    HRLZI  T4,004000   ;ELSE ADD BIT FOR STRING
    LSH    T4,0(T5)    ;SHIFT FOR POSITION
    IOR    T6,T4       ;AND SAVE
;
 DEF4:
    CAIN   CH,ASCCMA   ;CHECK FOR MORE ARGS
    JRST   DEF2        ;HANDLE IF SO
    CAIE   CH,ASCRPR   ;CHECK FOR END OF EXPRESSION
    ERR    E.INFT      ;ERROOR IF NOT
    JSP    T,NXECH     ;GET NEXT CHARACTER
;
;   FINISH DEF
;
 DEF3:
    PUSH   P,T5        ;SAVE ARG COUNT
    MOVNI  R2,-1(T5)   ;GET POSITIVE COUNT PLUS ONE
    LSH    R2,44-6     ;TO UPPER 6 BITS
    ADD    T6,R2       ;;TO BITS WORD
  MOVE R2,T7 ;GET PTR
  LSH R2,1 ;TIMES 2
  TLNE T7,VTSTR ;CHECK IF STRING
  ADDI R2,2*32 ;GET BETTER NUMBER IF SO
    SKIPN  UFCATB(R2)  ;CHECK IF FUNCTION USED
    JRST   DEF5        ;HANDLE UNDEFINED
    CAME   T6,UFCATB(R2) ;CHECK FOR SAME DEFINITION
    JRST   DEF6        ;DIFFERENT--ERROR
    JRST   DEF7        ;SAME--OKAY
;
 DEF5:
    MOVEM  T6,UFCATB(R2) ;NEW --SAVE DEFINITION
;
 DEF7:
    PUSH   P,REGUSD    ;SAVE REGUSD UP TO NOW
    SETZM  REGUSD      ;CLLEAR NEW ONE
    PUSH   P,T3        ;SAVE OLD PDL POINTER(START OF ARGS)
    CAIN   CH,ASCEQU   ;CHECK FOR '='
    JRST   DEF10       ;AHDNEL SINGLE LINE DEF
  MOVE T0,T7 ;GET FCT NUMBER IN T0
  ADDI T0,414+32 ;GET SYMTAB NUMBER
  MOVEI R2,400001 ;GET BIT AND OFFSET FOR FCT VAR
  SUB R2,T5 ;MINUS NUMBER OF ARGS
  TLNE T7,VTSTR ;CHECK IF STRING
  HRLM R2,SYMTAB(T0) ;SAVE IF SO
  TLNN T7,VTSTR ;CHECK AGAIN
  HRRM R2,SYMTAB(T0) ;SAVE IF NOT STRING
;
  PUSH P,T7 ;SAVE THE FCT NUMBER
  PUSH P,ULNLS ;SAVE LIST OF UNDEF LINE NUMBERS
  SETZM ULNLS ;AND LCEAR THE LIST FOR US
  PUSH P,LSTLN ;SAVE LAST LINE
  HRLZI R2,-2 ;MARKER WORD
  PUSH P,R2 ;SAVE ON STACK
    TLO    FG,NCHBT    ;EXTRA CHAR SCANNED
    JRST   EOL         ;AND DONE
;
 DEF6:
    MOVEI  T0,UFCATB(R2) ;GET FUNCTION NUMBER
    MOVE   T2,T6       ;AND BAD FCT ID WORD
    JRST   FNCL6       ;AND GENERATE PROPER ERROR
;
;
;
SUBTTL STATEMENT ROUTINES--DEF10--SINGLE LINE DEF
;
;   HANDLE SINGLE LINE DEF--SCAN EXPRESSION
;
;
 DEF10:
    MOVE R2,LSTLN ;GET LAST LINE NUMBER
    HRLI R2,(HRLI R.L,) ;LOAD FOR ERROR MESSAGES
    SAVWD ;SAVE LOAD
;
    HRLZI  FG,NUMBT    ;GUESS NUMERIC
    TLNN   T7,VTNUM    ;CHECK IF RIGHT
    HRLZI  FG,STRBT    ;ELSE USE STRING
    PUSH   P,T7        ;SAVE FCT NUMBER
    PUSHJ P,ARSCN       ;SCAN EXPPRESSION
    MKLOD (R2)		;INSURE ITS LOADABILITY
    GTADD (R2)		;GET ADDRESS
    POP    P,T7        ;RESTORE FUNCTION NUMBER
    SETZM TEMPB ;MARK AS ONE LINE DEF
    TRNN   T1,-2       ;CHECK IF RETURN IN REG CORRECT
    JRST   FNENDA      ;JUMP IF SO
    TLO R2,(MOVE 0,) ;ELSE MOVE TO R0
    TLNN   T7,VTNUM    ;CHECK FOR STRING FCT
    TLO    R2,40       ;USE R1 IF SO
    PUSHJ P,SVREL     ;SAVE THE RESULT
    JRST   FNENDA      ;AND HANDLE END OF FUNCTION PROCESSING
;
;
;
  SUBTTL STATEMENT ROUTINES--DIM
;
;   S.DIM--THIS ROUTINE HANDLES THE DIM STATEMENT.  IT IS USED FOR
;      DIMENSIONING VARIABLES.  IT GENERATES NO CODE, BUT WILL MODIFY THE
;      VARIABLES CONSTANT AREA DIMENSIONS.
;
;
 S.DIM:
    TLZ FG,NCHBT ;NEXT CHR NOT SCANNED
    PUSHJ P,SVRNM ;SCAN SVRIABLE NAME
    CAIE   CH,ASCLPR   ;CHECK FOR '('
    ERR    E.INFT      ;ERROR IF NOT
    SETZM  T1          ;NUMBER DIMS
;
;   HANDLE NEXT DIMENSION
;
 DIM2:
    TLZ    FG,NCHBT    ;NEXT CHAR SCANNED
    PUSHJ P,GTNM        ;NUMBER TO T7, LENGTH IN T6
    JUMPLE T7,DIMER    ;MUST BE >0
    AOS    T1          ;UPDATE COUNT
    CAIN T1,1 ;CHECK IF FIRST TIME/SECOND TIME
    MOVE   T5,T7       ;SAVE DIM
    CAIN   CH,ASCCMA   ;CHECK FOR ','
    JRST   DIM2        ;HANDLE SECOND DIMENSION
    CAIE   CH,ASCRPR   ;CHECK FOR ')'
    ERR    E.INFT      ;ERRO IF NOT
    MOVEM  T1,XNSBCS   ;SAVE # DIMS
    SETOM SBCERF ;MAT MUST HAVE THOSE DIMS
    PUSHJ P,MAKMAT ;MAKE A MATRIX
    HRROM  T5,MATDTB(T0) ;SAVE DIM
    TRNN   T1,1        ;CHECK NUMBER OF DIMS
    HRLM   T7,MATDTB(T0) ;SAVE SECOND DIM
    MOVE R2,MATPTB(T0) ;GET PTR
    TLNE R2,MTGBL ;CHECK IF GLOBAL
    ERR E.CDGM ;ERROR IF SO
;
    JSP    T,NXECH     ;CHECK NEXT CHARACTER
    TLO    FG,NCHBT    ;MARK AS SCAANED
    CAIN   CH,ASCCMA   ;CHECK FOR ','
    JRST   S.DIM       ;HANDLE ANOTHER VARIABLE IF SO
    JRST   EOL         ;ELSE DONE
;
 DIMER:
    ERR    E.DIM       ;ERROR CONDITION
;
;
;
  SUBTTL STATEMENT ROUTINES--END
;
;   S.END--THIS ROUTINE HANDLES THE END STATEMENT.  IT PROCESSES THE
;      END OF THE MAIN PROGRAM.  IF FINISHES UP THE MAIN PROGRAM AND
;      THEN CONTINUES SCANNING IN CASE THERE ARE SUBPROGRAMS.
;
;
 S.END:
    SKIPE  PRGNM       ;CHECK FOR MAIN PROGRAM
    ERR    E.END       ;NO--ERROR
;
 END0:
  HRLZI T7,-4 ;MARKER FOR MAIN
  PUSHJ P,CLRP ;LOOK FOR IT ON STACK
    BLOWUP ;MUST BE FOUND
;
    MOVEI  R2,R.STOP   ;STO IF WE GET TO HERE
    PUSHJ P,SVCAL     ;SAVE
    MOVE R2,OBJPT	;GET .
    SUBI R2,1		;GET .-1
    HRLI R2,(JRST)	;GET JRST .-1 (TO PREVENT RESTART)
    SVWPR		;SAVE IT
;
    PUSHJ  P,ALCARS    ;ALLOCATE ARRAYS
    PUSHJ P,GTPGDT ;GET PROGRAM DAT TO CNST AREA
;
  MOVE R2,OBJPT ;GET LOBJ PTR
  MOVEM R2,ENTADD ;SAVE AS ENTRY ADDRESS
  PUSHJ P,SVRTGT	;SAVE CODE TO GET RTP
  MOVSI R2,(MOVEI 1,) ;GET CODE TO PT TO PGDATA AREA
  ADD R2,PGDATA ;LOC
  SVWCN ;SAVE --LOADS PTR IN R1
  MOVEI R2,R.INIT ;GET INITIALIZATION ROUTINE
  PUSHJ P,SVCAL ;SAVE CALL TO IT
;
  SKIPN R2,TIMEC ;SEE IF TIME SPECIFIED
    JRST END1 ;NO--SKIP
  HRLI R2,(MOVE 1,) ;LOAD IT IF SO
  SVWCN ;ITS IN CONSTANT AREA
  MOVEI R2,R.TIME ;CALL RTP RTN TO HANDLE
  PUSHJ P,SVCAL ;SAVE CALL TO RTP RTN
;
 END1:
  PUSHJ P,PRPMAT ;SET UP CODE FOR MATRICES
;
  MOVEI R2,R.DBST	;DEBUGGER START UP
  SKIPE DEBFG		;CHECK IF DEBUG MODE
    PUSHJ P,SVCAL	;SAVE CALL TO START DEBUGGER
;
  MOVE R2,STADD ;GET PROGRAM STARTING ADDRESS
  TLO R2,(JRST 0) ;CREATE JUMP TO IT
  SVWPR ;AND SAVE THAT
;
    PUSHJ P,ENBIN       ;END OF BINARY
;
    SETOM  PRGNM       ;NO PROGRAM
    AOS    MAINFG      ;HAVE HAD MAIN PROGRAM
    PUSHJ P,RINIT     ;REINITIALIZE CORE
;
    JRST   EOL         ;AND PROCESS NEXT LINE
;
;
;
  SUBTTL STATEMENT ROUTINES--FILE
;
;   S.FIL--THIS ROUTINE HANDLES THE FILE STATEMENT.  IT CALLS 'IODRV'
;      TO SCAN A FILE NUMBER AND THEN A STRING EXPRESSION, PASSING
;      THE FILE NUMBER TO 'FSET' AND THE STRING TO 'R.FILE'.
;
;
 S.FIL:
    SPELL <E>          ;FIL'E
    JSP    T,IODRV     ;CALL IODRV
    EXP    0           ;MUST HAVE FILE NUMBER
    XWD    STRBT       ;ARG TYPE
    EXP    R.FILE      ;ROUTINE
;
;
;
  SUBTTL STATEMENT ROUTINES--FNEND
;
;   S.FNE--THIS ROUTINE HANDLES THE END OF A DEF (INTERNAL) FUNCTION.
;      IT IS ENTERED DIRECTLY ON 'FNEND' STATEMENT IN SOURCE, OR FROM
;      THE DEF ROUTINE IN THE CASE OF A SINGLE LINE FUNCTION.  IT
;      MOVES THE VALUE TO R0 IF NECESSARY, AND THEN GENERATES:
;
;        <LOAD VALUE>
;        PUSHJ P,STKEX
;       <DLOC STR ARGS>
;        ,RESTORE USED REGS>
;        SUB P,[XWD N,N]
;        JRST @N(P)
;         <FUNCTION ID WORD>
;         FNX:
;        PUSH P,[0]
;        <SAVE REGS USED>
;        MOVEI 14,-N(P)
;        <ALOC STR ARGS>
;         JRST S.1 ;JUMP INTO DEF CODE
;         S.2: ;EXIT FROM JUMP AROUND DEF
;
;
 S.FNE:
    SPELL <N,D>        ;FNE'ND
;
  HRLZI T7,-2 ;GET MARKER FROM DEF
  PUSHJ P,CLRP ;LOOK FOR IT ON STACK
    ERR E.NFCT ;ERROR IF NOT FOUND
  PUSHJ P,CLNULN ;HANDLE UNDEF LINE NUMBERS
;
    POP P,R1 ;MARKER
    POP    P,T1        ;GET LINE NUM
    POP P,ULNLS ;RESTORE OLD UNDEF LINE NUMBS
    POP    P,T7        ;GET FCT NUMBER
;
  SETOM TEMPB ;SET FLAG
  MOVE R2,[MOVE 0,1(14)] ;LOAD VALUE OF FCT
  SUB R2,-2(P) ;PLUS NUMBER OF ARGS
  TLNE T7,VTSTR ;CHECK FOR STRING FCT
  TLO R2,40 ;IF SO, USE R1
  SAVWD ;SAVE THE VALUE PICK UP
  TLNN T7,VTSTR ;CHECK IF STRING
  JRST FNENDA ;SKIP IF NOT
  MOVE R2,[AOS -1(1)] ;IF SO, UPDATE ALLOC COUNT**********
  SAVWD ;SAVE THAT
;
;   ENTER HERE FOR SINGLE  LINE DEF
;
 FNENDA:
    HRRZ T6,T7 ;GET FCT NUM
    LSH T6,1 ;TIMES BY 2
    TLNE T7,VTSTR ;CHECK IF STR FCT
    ADDI T6,32*2 ;IF SO, GET BETTER PTR
;
  PUSHJ P,DFCSTR ;FOR EACH STRING ARG
    JRST FNDA2 ;PROCESS WHEN DONE
;
    MOVEI R2,R.DLC ;GET DLC ROUTINE
    PUSHJ P,SVCAL ;SAVE CALL TO DEALLOCATE STRING
    MOVE R2,T4 ;GET ARG OFFSET
  TLO R2,(JUMP 1,0(14)) ;PTR TO THIS STR JUMP
    SAVWD ;SAVE PTR
    POPJ P, ;AND GO TO NEXT STRING
;
;
 FNDA2:
  MOVEI R2,R.STEX ;ROUTINE TO GET RID OF RTP STACK GARBAGE
  PUSHJ P,SVCAL ;SAVE CALL TO IT
;
  MOVSI R2,000040 ;R14 USED
  IORM R2,REGUSD ;SO INDICATE THAT
  PUSHJ P,SVRGS ;SAVE REGS
    XWD 4,17 ;REALLY LOAD IN REVERSE ORDER
    POP R.P, ;USING A POP
    LSH T1,1 ;DIRECTION OF REG LOOK AT
    SOS T2 ;COUNT OF REG NUM
;
    MOVE   T0,FCIDWD+UFCATB(T6) ;GET FCT ID WORD
    LSH    T0,-44+6    ;GET ARG COUNT
    MOVE R2,T0 ;GET COUNT
    SUB R2,TEMPB ;+1 IF MULTI-LINE
    HRLS R2 ;IN BOTH HALVES
    DSVCON (R2) ;SAVE AS CONST--GET ADD
    TLO R2,(SUB R.P,) ;CODE TO BUMP P OVER ARGS
    SVWCN ;SAVE AS CONST REFS
    MOVE R2,T0 ;GET ARG COUNT AGAIN
    TLO R2,(JRST @0(P)) ;CREATE JUMP THROUGH RETURN ADD
    SAVWD ;AND SAVE ABS
;
    MOVE   R2,FCIDWD+UFCATB(T6) ;GET ID WORD
    SAVWD              ;AND SAVE IT
;
    HRRZ R2,UFCATB+FCIAD(T6) ;CHECK IF ROUTINE DEFINED
    SKIPE R2 ;BY CHECKING IF PREVIOUS ADDRESS
    ERR E.FMDF ;ERROR IF SO
    MOVE R2,OBJPT ;GET CUREN ADDRESS
    HRRM  R2,UFCATB+FCIAD(T6) ;ELSE SAVE ENTRY SYMBOL
;
  MOVE R1,T6		;GET FUNCTION NUMBER*2
  LSH R1,-1		;GET FUNCTION NUMBER
  MOVS T1,UFCLTB(R1)	;PREPARE TO LINK UNDEF REFS
  JUMPE T1,FNDA6	;NONE--SKIP
;
 FNDA7:
  ADD T1,OBJCOD		;RELOCATE THIS LINK
  HRRZ T2,0(T1)		;GET NEXT LINK
  HRRM R2,0(T1)		;SAVE PROPER ADDRESS
  SKIPE T1,T2		;GET NEXT LINK, CHECK IF DONE
    JRST FNDA7		;LOOP IF MORE
  SETZM UFCLTB(R1)	;CLEAR LINK WORD AFTER DONE
;
;
 FNDA6:
  SKIPN TEMPB ;CHECK IF ONE LINER
  JRST FNDA4 ;IF SO, THEN JUMP
  MOVEI R2,0 ;ELSE GET WORD OF ZERO
  DSVCON (R2) ;GET CONST FOR IT
  TLO R2,(PUSH R.P,) ;PUSH INITIAL VALUE FOR FCT
  SVWCN ;SAVE WORD TO DO SO
;
 FNDA4:
  PUSHJ P,SVRGS ;NOW SAVE THE REGS USED
    XWD 100000,2 ;STARTING WITH R2
    PUSH R.P, ;PUSHING THEM
    LSH T1,-1 ;SHIFT FOR NEXT
    AOS T2 ;COUNT FOR NEXT
;
  MOVN R2,TEMPA ;NUMBER OF REGS SAVED
  ADD R2,-2(P) ;NUMBER OF VARS
  ADD R2,TEMPB ;PLUS ONE IF MLDEF
  HRLI R2,(MOVEI 14,0(P)) ;CREATE WORD TO SET UP R14
  SAVWD ;AND SAVE IT
;
  PUSHJ P,DFCSTR ;FOR ALL STRING ARGS
    JRST FNDA3 ;SKIP WHEN DONE
;
    MOVE R2,T4 ;GET ARG NUMBER OF STR
    TLO R2,(SKIPE 1,0(14)) ;LOAD VALUE IN R1 AT RT
    SAVWD ;SAVE THIS
    MOVE R2,[AOS -1(1)] ;UPDATE USAGE COUNT FOR STROE
    SAVWD ;SAVE THIS TOO
    POPJ P, ;AND GO ON TO NEXT STR
;
 FNDA3:
    POP    P,T6        ;GET PDL FOR START OF ARGS
    MOVEM T6,TEMPA ;SAVE THAT
    POP    P,REGUSD        ;GET OLD REGUSD WORD
    MOVEI  T4,0        ;COUNT
    POP    P,T5        ;NEGATIVE COUNT
    MOVE R2,[PUSH R.P,R.L] ;CODE TO SAVE LINE NUM
    SAVWD ;SAVE IT
;
  JUMPE T5,FNDA5 ;JUMP IF NOT ARGS
  POP P,R1 ;RESTORE ARG
  POP P,SYMTAB(R1) ;AND PUT OLD SYMTAB WORD BACK
  AOJL T5,.-2 ;LOOP UNTIL DONE
;
 FNDA5:
;
  MOVE R2,[PUSH P,R.RBGS] ;PUSH TO AVOID GOSUBS RETURNING
  SVWEX ;SAVE AS EXT REF
;
;   HANDLE END OF FNEND
;
    MOVE   P,TEMPA     ;RESTORE PDL
    POP    P,T0        ;-1 FLAG
    HRRZ   R2,0(P)     ;SADDN
    MOVE R2,0(P) ;START ADD
    ADD    R2,[JRST 1] ;$$$JRST S,1$$$ START EXECUTING
    SVWPR              ;SAVE
    POP    P,R2        ;RETSTORE SADDN FROM STACK
    ADD R2,OBJCOD ;GET ABS ADDRESS
    MOVE T0,OBJPT ;GET CUREN ADD
    HRRM T0,0(R2) ;FILL INTO TRANSFER AROUND
    SETZM FCTLIN ;NO HEAD LINE
    SETZM  CURFCT       ;END OF FCT
    JRST   EOL         ;AND THEN DONE
;
  SUBTTL STATEMENT ROUTINES--FOR
;
;   S.FOR--THIS ROUTINE HANDLES THE FOR STATEMENT..  ONE OF THREE ITEMS
;      IS GENERATED, WITH THE GENERAL CASE BEING ONE, AND THE OTHER TWO
;      BEING A CONSTANT POSITIVE AND A CONSTANT NEGATIVE STEP.  THE
;      CODE FIRST COMPUTES THE INITIAL VALUE AND LEAVES IT IN A
;      REGISTER.  THEN THE FINAL VALUE AND STEP ARE SCANNED AND MADE
;      LOADABLE BUT NOT IN A REGISTER (TEMPS ALOCATED IN CONSTANT AREA).
;      IN THE GENERAL CASE, CODE IS GENERATED TO CHANGE THE COMPARE IN
;      THE LOOP DEPENDING ON THE SIGN OF THE STEP.
;
;   THE LOOP ITSELF CONSISTS OF LOADING THE OLD VALUE, ADDING THE INCREMENT
;      ,CHECKING IF THE TEST SUCCEEDS OR FAILS, AND THEN, ON SUCCESS,
;      SAVING THE NEW VALUE AND ENTERING THE CODE SUBSEQUENT.
;
;   THE STACK (COMPILER) CONSTAINS THE SADDN AT START (FOR SYMBOL ID)
;      AND -1,VAR# FOR MATCHING VERSUS A FOR.
;
;
 S.FOR:
    PUSH P,LSTLN ;PUSH THE LINE NUMBER
    TLZ FG,NCHBT ;NEXT CHR NOT SCANNED
    PUSHJ P,VARNM     ;SCAN A VARIABLE
    JSP    T,ALVAR     ;MAKE SURE ITS THERE
    MOVEM  T0,TEMPA    ;SAVE ITS VLAUE
    CAIE   CH,ASCEQU   ;CHECK FOR '='
    ERR    E.INFT      ;ERROR IF NOT
    MOVEI R2,TRTO ;ALLOW 'TO' AS TERMINATOR
    MOVEM R2,ALWTRM ;SAVE
    HRLZI  FG,NUMBT    ;SCAN A NUMERIC EXPRESSION
    PUSHJ P,ARSCN       ;FOR INITIAL VALUE
    PUSHJ P,GTLOD     ;GET VALUE LOADED
    POP    VS,TEMPB    ;GET REGISTER ITS IN
    HRRZ T1,TEMPB ;GET PTR TO REG
    PUSHJ P,CKRG ;MAKE SURE IT ISN'T REG 0
    MOVEM T1,TEMPB ;IF IT WAS, SAVE NEW REG
;
    SETZM LOCA ;CLEAR SAVE OF OP TO FILL IN
    CAMN CH,ARTERM ;MAKE SURE 'TO' TERMINATED
    ERR    E.INFT      ;MUST BE
    MOVEI R2,TRSTEP ;ALLOW 'STEP' TO TERMINATE
    MOVEM R2,ALWTRM ;SAVE
    HRLZI  FG,NUMBT+NCHBT ;SCAN LIMIT VALUE
    PUSHJ P,ARSCAD      ;RETURNING ADDRESS
    MOVEM  R2,TEMPC    ;SAVE AS TO VALUE
    SETZM  TEMPD       ;SAVE DUMMY STEP
    SETZM  TEMPE       ;AND FLAG
    MOVE   T1,ARTERM   ;CHECK TERMINATOR
    CAIE   T1,TRSTEP   ;FOR 'STEP'
    JRST   FOR1        ;NOT--PROCESS
    SETZM ALWTRM ;ONLY CHR TERMINATORS
    HRLZI  FG,NUMBT+NCHBT ;NUMERIC STEP
    PUSHJ P,ARSCAD      ;GET STEP AS ADDRESS
    MOVEM  R2,TEMPD    ;AND SAVE IT
;
;   CHECK FOR AND HANDLE GENERAL CASE
;
    TLNE   T1,VTCON    ;CHECCK IF CONSTANT STEP
    JRST   FOR3        ;HANDLE IF SO
    GTREG (T2)		;ELSE GET A FREE REG
    LSH    T2,22+4+1   ;MOVE VALUE TO REG FILED
    HRRZ   R2,TEMPB    ;GET REG FOR COMPARE
    LSH R2,4+1 ;INTO REG FIELD IN LOWER HALF
    ADD    R2,[HRLZI 313000] ;GENERATE $$$HRLZI [CAMLE R2,]$$$
    ADD    R2,T2       ;GET REGISTER WE'RE USING
    SAVWD              ;AND SAVE
;
    PUSHJ  P,OPGEN     ;SKIPGE <STEP>
    SKIPGE
    ARG    [0]         ;REG
    ARG    TEMPD       ;STEP LOC
;
    MOVE   R2,[TLC 006000] ;CHANGE CAILE TO CAIGE
    ADD    R2,T2       ;PLUS REG USED
    SAVWD              ;SAVE
;
    MOVE R2,OBJPT ;GET CURRENT ADD
    MOVEM R2,LOCA ;SAVE FOR FILL IN
    MOVSI R2,(HLLM)  ;GET INST TO SAVE OP
    ADD R2,T2 ;PLUS REG FROM
    SVWPR ;AND SAVE
    JRST   FOR1        ;AND PROCESS
;
 FOR3:
    MOVE   T2,0(T1)    ;GET CONSTANT
    MOVEM  T2,TEMPE    ;AND SAVE IT
;
;   GENERATE LOOP CODE
;
 FOR1:
  MOVE R2,TEMPA ;GET LOC OF ADDRESS
  GTADD (R2) ;GET ADDRESS
  DPB R1,[POINT 6,R2,5] ;SAVE RELOCATION TYPE IN ADD
  MOVE T7,R2 ;PUT INTO T7
    MOVE   T6,TEMPC    ;TO IN T6
    MOVE   T5,TEMPD    ;STEP IN T5
    MOVE T4,OBJPT ;GET CURRENT ADD
    MOVEM T4,LOCB ;AND SAVE
    HRRZ   T3,TEMPB    ;REG
    LSH    T3,22+4+1   ;REG IN T3 IN REG FLD
    MOVSI R2,(JRST) ;GENERATE JUMP INTO LOOK
    SVWPR              ;SAVE IT
;
    PUSH P,OBJPT ;SAVE CURRENT LOC
;
    PUSHJ P,OPGEN ;OP GENERATE $$$MOVE RX,VAR$$$
    MOVE
    EXP T3
    EXP T7
    JUMPE  T5,FOR2     ;HANDLE NIL STEP
;
    PUSHJ P,OPGEN     ;OP GENERATE $$$FADR RX,STEP$$$
    FADR               ;OP
    EXP    T3          ;REG
    EXP    T5          ;ADDRESS
    JRST   FOR4        ;AND JUMP
;
 FOR2:
    MOVE   R2,[FADRI 201400] ;DEFAULT STEP
    ADD    R2,T3       ;REG
    SAVWD              ;SAVE IT
;
 FOR4:
    MOVE R2,OBJPT ;CURRENT ADD
    MOVE T0,LOCB ;BACK FILL IN
    ADD T0,OBJCOD ;MAKE ABS
    HRRM R2,0(T0) ;FILL IN LINK
;
    SKIPN T0,LOCA ;CHECK FOR TWO LINKS
    JRST .+3 ;JUMP IF NOT
    ADD T0,OBJCOD ;GET REAL ADDRESS
    HRRM R2,0(T0) ;AND FILL IN SECOND INK
;
    SKIPGE TEMPE       ;CHECK FOR CAMLE OR GE
    JRST   FOR20       ;HANDLE GE
;
    PUSHJ P,OPGEN     ;GENERATE COMPARE
    CAMLE              ;FOR DEFAULT STEP/PLUS CONST
    EXP    T3
    EXP    T6
;
 FOR11:
    PUSH P,OBJPT ;SAVE CURRENT ADD
    MOVSI R2,(JRST)
    SVWPR              ;AND SAVE IT
;
  PUSHJ P,OPGEN ;GENERATE $$$MOVEM RX,VAR$$$
    MOVEM
    EXP T3
    EXP T7
;
    HRLI   T7,-1       ;CREAT FOR FLAG
    HRR T7,TEMPA ;RESTORE VAL
    PUSH   P,T7        ;AND SAVE IT ON STACK
    JRST   EOL         ;AND DONE
;
 FOR20:
    PUSHJ P,OPGEN     ;GENERATE CONST FOR NEGATIVE STEP
    CAMGE
    EXP    T3
    EXP    T6
    JRST   FOR11       ;AND THEN CONTINUE
;
;
;
  SUBTTL STATEMENT ROUTINES--GOSUB
;
;   S.GOS--THIS ROUTINE HANDLES THE GOSUB STATEMENT.  GOSUBS ARE HANDLED
;      BY A PDL OFF REGISTER 15 DURING RUN TIME. (R.P=15).  THUS A GOSUB
;      IS A PUSHJ 15,<LINE>.
;
;
 S.GOS:
    SPELL <U,B>        ;GOS'UB
    TLZ    FG,NCHBT    ;MUST SCAN CHAR AGAIN
    PUSHJ P,GTLNNO      ;GET LIN NUMBER ADDRESS
    TLO    T7,(PUSHJ R.P,) ;CONSTRUCT TRANSFER
    MOVE   R2,T7       ;GET TRANSFER IN R2 FOR SAVING
    SVWPR              ;SAVE IT
    JRST   EOL         ;AND DONE
;
;
;
  SUBTTL STATEMENT ROUTINES--GOTO
;
;   S.GOT--THIS ROUTINE HANDLES A GOTO STATEMENT.  IT GENREATES A JRST
;      TO THE SPECIFIED LINK.
;
;
 S.GOT:
    SPELL <O>
    TLZ    FG,NCHBT    ;EXTRA CHAR SCANNED
;
 GOTO1:
    PUSHJ P,GTLNNO      ;GET LINE NUMBER ADDRESS
    TLO    T7,(JRST)   ;CONSTRUCT JUMP
    MOVE   R2,T7       ;GET WORD IN R2 TO SAVE
    SVWPR              ;SAVE IT
    JRST   EOL         ;AND DONE
;
;
;
  SUBTTL STATEMENT ROUTINES--IF
;
;   S.IF--THIS ROUTINE HANDLES THE IF STATEMENT.  IT SCANS AN ARITHEMTIC
;      CONDITIONAL OF SORTS WHICH SOHULD END WITH A SKIP ON FAIL.  IT
;     THEN GENERATES THE TRANSFER TO THE SPECIFIED LINE USING THE GOTO
;      ROUTINE.
;
;
 S.IF:
    SKIPGE PRGNM       ;CHECK FOR MAIN PROGRAM
    PUSHJ P,STMAIN      ;IF NO PROGRAM--MAKE MAIN
    MOVEI R2,TRTHEN ;ALLOW 'THEN' TO TERMINATE
    MOVEM R2,ALWTRM ;SAE
    HRLZI  FG,CNDBT    ;SCAN CONDITIONAL
    PUSHJ P,ARSCN
    CAMN CH,ARTERM ;MAKE SURE 'THEN' TERMINATED SCAN
    ERR    E.INFT      ;ERROR IF NOT
    JRST   GOTO1       ;HANDLE TRANSFER
;
;
;
  SUBTTL STATEMENT ROUTINES--INPUT
;
;   S.INP--THIS ROUTIE HANDLES THE INPUT (READ FROM ASCII DEVICE)
;      STATEMENT.  IT USES THE IOSCN ROUTINE TO GERNEATE I/O CODE WITH
;      THE GIVEN PARAEMENTERS.
;
;   INPUT IS STARTED WITH A CALL TO R.FSET AND THEN A CALL TO R.INST FOR
;      SETTING UP.  STRING INU IS DONE WITH R.ISTR AND NUMERIC WITH
;      R.INUM.  FINALLY, THE END OF THE LINE IS HANDLED WITH EITHER
;      R.IDON OR R.IDNC DEPENDING ON WHETHER THERE IS A FINAL COMMA OR
;      NOT.
;
;
 S.INP:
    SPELL <U,T>        ;INP'UT
    JSP    T,IOSCN     ;CALL IOSCN
    EXP    R.TSET      ;DEFAULT TO FILE IS TERMINAL
    EXP    R.INUM      ;NUMERIC INPUT CALL
    EXP    R.ISTR      ;STRING INPUT CALL
    EXP    R.IDON      ;NORMAL TERMINATION
    EXP    R.IDNC      ;COMMA TERMINATION
    EXP    INPVAR      ;ROUTINE TO SCAN FIELDS
    XWD    R.ISET,R.ISET      ;SET UP ROUTINE
;
;
;
  SUBTTL STATEMENT ROUTINES--LET
;
;   S.LET--THIS ROUTINE HANDLES THE LET STATEEENT.  THIS DOES AN ARITH-
;      METIC SCAN WITH THE 'EQUBT' OPTION--REQUIRING AN ASSIGNMENT TO
;      BE PREFORMED.
;
;
 S.LET:
    HRLZI  FG,EQUBT    ;TYPE OF SCAN
;
 LET0:
    PUSHJ P,ARSCN       ;DO SCAN
    POP VS,T7		;GET RESULT OFF STACK
    RLREG (T7)		;AND RELEASE IT
    JRST   EOL         ;AND THEN DONE
;
;
;
SUBTTL STATEMENT ROUTINES--LIBRARY
;
;   S.LIB--THIS ROUTINEHANDLES THE LIBRARY STATEMENT.  IT USES THE
;      'NEWLIB' ROUTINE TO DO MOST OF THE NON-SCANNING WORK.  THIS
;      ROUTINE IS EXTERNAL (PART OF BEXC), SO SOME SORT OF LINKAGE
;      MUST BE DEVISED.
;
;
S.LIB:
  SPELL <R,A,R,Y>	;LIB'RARY
;
 LIB1:
  HRLZI FG,STRBT ;SCAN A STRING EXP
  PUSHJ P,ARSCN
  POP VS,T0 ;GET RESULT
  TLNN T0,VTCON ;BETTER BE STRING CONSTANT
    JRST LIB6 ;ERROR IF NOT
  HRRZI T7,-1(T0) ;PTR REL TO TALLY
  ADD T7,CONST ;GET TALLY
  SKIPN R2,0(T7) ;IF NOT NULL
    JRST LIB6 ;NULL STRINGS AREN'T ALLOWED
  ADD R2,CONST ;RELOCATE THE TALLY
  SUBI R2,1 ;CORRECTLY
  MOVEM R2,ERBUF ;SAVE IT
  MOVE R1,[ASCIZ /BAS/]	;EXTENSION
  MOVEM R1,GTFEXT
  MOVSI R1,100000	;GETJFN BITS
  MOVEM R1,GTFLGS
  SETZM GTFNAM		;NO DEFAULT NAME
  MOVEI R1,GTFBF	;PTR TO BUFFER
  GTJFN ;ATTEMP TO OPEN IT
    JRST LIB5 ;HANDLE FAIL
  PUSH P,R1 ;SAVE THE JFN
  MOVE R2,[XWD 070000,200000] ;BITS FOR OPEN
  OPENF ;TRY TO OPEN IT
    JRST LIB2 ;HANDLE ERROR THERE
  POP P,R1 ;RESTORE JFN
  PUSHJ P,NEWLIB ;YES--TELL SOMEONE ABOUT THE LIBRARY
  SKIPN LIBFG		;CHECK IF USER WANT'S TO IGNORE LIBRARYS
    JRST LIB4		;NO--SKIP
  AOS NUMLRQ		;YES--THEN REQUIRE RATHER THAN COMPILE
  MOVE R3,LIBLST	;GET PTR TO LIB BLOCK
  MOVSI R2,LBBRQ	;GET REQUIRE BIT
  IORM R2,LBBTS(R3)	;AND SAVE ON
;
 LIB4:
  CAIN CH,ASCCMA ;CHECK TERMINATOR
    JRST LIB1 ;IF COMMA, TRY SOME MORE
  JRST EOL ;ELSE DONE
;
 LIB2:
  EXCH R1,0(P) ;OPEN FAILED--RELEASE JFN
  CLOSF ;SO WE AVOID PROBLEMS
    TRN
  POP P,R1 ;RESTORE ERROR NUMBER
;
 LIB5:
  ERR E.LBNA ;GIVE ERROR MESSAGE ON NOT OPENING IT
  JRST LIB4 ;THEN TRY SOME MORE
;
 LIB6:
  ERR E.LBNM ;ILLEGAL NAME
  JRST LIB4 ;TRY AGAIN
;
;
  SUBTTL STATEMENT ROUTINES--LINPUT
;
;   S.LIN--THIS ROUTINE HANDLES THE LINPUT STATEMENT.  AGAIN, THE IOSCN
;      ROUTINE IS USED TO DO HE WORK AND THE PARAMENTERS ARE SPECIFIED
;      BELOW.   THE CODE GENERATED IS SIMILAR TO INPUT EXCEPT THAT R.LSTR
;      IS THE CALLED ROUTINE.
;
;
 S.LIN:
    SPELL <P,U,T>      ;LIN'PUT
    JSP    T,IOSCN     ;CALL IOSCN
    EXP    R.TSET      ;DEFAULT FROM FILE IS TERMINAL
    EXP    0           ;NO NUMERIC LINPUT
    EXP    R.LSTR      ;STRING LINPUT
    EXP    R.IDON      ;DONE
    EXP    R.IDNC      ;DONE WITH COMMA
    EXP    INPVAR      ;ROUTINE TO SCAN A FIELD
    XWD    R.ISET,R.ISET      ;SET UP ROUTINE
;
;
;
  SUBTTL STATEMENT ROUTINES--MARGIN
;
;   S.MAR--THIS ROUTINE HANDLES THE MARGIN STATEMENT. IT IS SCANNED
;      USING THE IODRV ROUTINE TO SCAN A NUMERIC FIELD AND GENERATE A
;      CALL USING THAT ARGUMENT TO THE R.MRGN ROUTINE. PREVIOUS TO THIS
;      CALL A CALL TO R.FSET OR R.TSET IS SET UP.
;
;
 S.MAR:
    SPELL <G,I,N>      ;MAR'GIN
    JSP    T,IODRV     ;CALL IODRV
    EXP    R.TSET      ;DEFAULT FROM FILE IS TTY
    XWD    NUMBT       ;ARGUMENT TYPE--NUMERIC
    EXP    R.MRGN      ;ROUTINE TO BE CALLED
;
;
;
  SUBTTL STATEMENT ROUTINES--MAT
;
;   S.MAT--THIS ROUTINE HANDLES THE MAT STATEMENT.  IT CHECKS FOR
;      A MAT I/O STATEMENT AND HANDLES THAN VIA BRANCHING.  IF
;      IT IS NOT, THEN IT PROCESSES A MT ARITHMETIC VIA ARSCN.
;
;
 S.MAT:
    JSP    T,NXECH     ;GET NEXT CHAR
    CAIL   CH,ASC..A   ;CHECK FOR ARITHMETIC
    CAILE  CH,ASC..Z
    ERR    E.ILMT      ;WHICH IT MUST BE
    MOVEM  CH,T0       ;SAVE IT
;
    JSP    T,NXECH     ;GET NEXT CHAR
    CAIL   CH,ASC..A   ;CHECK FOR ARITH
    CAILE  CH,ASC..Z
    JRST   MAT1        ;IF NOT, THEN MAT ARITHMETIC STATEMENT
;
    DPB    CH,[POINT 7,T0,6] ;SAVE SECOND CHAR WITH FIRST
    ROT    T0,-7    ;ADJUST THE TWO
    MOVEI  T1,NMTST-1  ;CHECK FOR MAT I/O
    CAMN   T0,MTSTA(T1) ;VERSUS TABLE
    JRST   @MTSTB(T1)  ;BRANCH WHEN FOUND
    SOJGE  T1,.-2      ;LOOP UNTIL DONE
    ERR    E.ILMT      ;MUST MATCH
;
 MAT1:
    MOVEM  CH,MAT.CH   ;ARITHMETIC--SAVE CHAR
    MOVE   CH,T0       ;GET FIRST CHAR
    HRLZI  FG,NCHBT+MATBT+EQUBT ;ARITH SCAN TYPES FOR MAT
    PUSHJ P,ARSCN       ;CALL THE SCAN
    MKLOD (T7)		;IF FCT, MUST ISSUE CALL
;
    JRST   RTEOL         ;AND DONE
;
;
;
;
;
;   MAT I/O TYPE TABLES
;
;
;      MTSTA--ASCII NAMES
;
 MTSTA:
    ASCIZ  /PR/        ;MATPRINT
    ASCIZ  /IN/        ;MATINPUT
    ASCIZ  /LI/        ;MATLINPUT
    ASCIZ  /RE/        ;MATREAD
    ASCIZ  /WR/        ;MATWRITE
;
    NMTST== .-MTSTA    ;NUMBER OF ENTRIES
;
;
;      MTSTB--ROUTINES TO HANDLE
;
 MTSTB:
    JRST   S.MPR       ;MATPRINT
    JRST   S.MIN       ;MATINPUT
    JRST   S.MLI       ;MATLINPUT
    JRST   S.MRE       ;MATREAD
    JRST   S.MWR       ;MATWRITE
;
;
;
;
SUBTTL STATEMENT ROUTINES--MATINPUT
;
;   S.MIN--HANDLE MATINPUT STATEMENT
;
;
S.MIN:
;
  SPELL <P,U,T> ;MATIN'PUT
  HRROI T0,1 ;ALLOW NEW DIMS/ASSUME 1D
  JSP T,MIOSCN ;HANDLE AS I/O STMT
    EXP R.TSET ;DEFAULT IS TTY
    XWD R.MVIN,R.MINN ;MAT INP NUM
    XWD R.MVIS,R.MINS ;MAT INP STR
    EXP R.IDON ;DONE
    EXP R.IDNC ;DONE/CONTINUE
    EXP MATSCN ;SCAN MAT NAMES
    XWD R.ISET,R.ISET ;SET UP ROUTINE
;
;
SUBTTL STATEMENT ROUTINES--MATLINPUT
;
;   S.MLI--HANDLE MATLINPUT STATEMENT
;
;
S.MLI:
;
  SPELL <N,P,U,T> ;MATLI'NPUT
  HRROI T0,1 ;ALLOW NEW DIMS--ASSUME 1-D
  JSP T,MIOSCN ;HANDLE AS I/O STMT
    EXP R.TSET ;DFLT IS TTY
    EXP 0 ;NO NUM MAT LINPUT
    XWD R.MLNS,R.MLNS ;STRING ENTRY
    EXP R.IDON ;DPNE ENTRY
    EXP R.IDNC ;DONE/CONTINUE ENTRY
    EXP MATSCN ;SCAN MAT NAMES
    XWD R.ISET,R.ISET ;SET UP
;
;
SUBTTL STATEMENT ROUTINES--MATPRINT
;
;   S.MPR--HANDLE MATPRINT STATEMENT
;
;
S.MPR:
;
  SPELL <I,N,T> ;MATPR'INT
  SETOM MATFG# ;MARK AS MAT PRINT
  JRST PRNT0 ;AND EXNTER PRINT ROUTINE
;
;
SUBTTL STATEMENT ROUTINES--MATREAD
;
;   S.MRE--HANDLE MATREAD STATEMENT
;
;
S.MRE:
;
  SPELL <A,D> ;MATRE'AD
  HRROI T0,1 ;ALLOW NEW DIMS//ASSUME 1-D
  JSP T,MIOSCN ;HANDLE AS I/O STMT
    XWD -1,MREAD1 ;DATA DEFAULT
    XWD R.MRDN,R.MRDN ;MAT READ NUM
    XWD R.MRDS,R.MRDS ;MAT READ STR
    EXP -1 ;NO END
    EXP -1 ;NO END/CON
    EXP MATSCN ;SCAN MAT NAMES
    XWD R.RNST,R.RSST ;SET FOR RANDOM FILE
;
;
 MREAD1:
    EXP 0 ;NO SET UP NEEDED
    XWD R.MRIN,R.MRIN ;MAT READ INTERNAL NUM
    XWD R.MRIS,R.MRIS ;MAT READ INTERNAL STR
    EXP -1 ;NO DONE
    EXP -1 ;NO DONE/CON
    EXP MATSCN ;SCN MAT NAMES
    EXP 0 ;NO SET UP
;
;
SUBTTL STATEMENT ROUTINES--MATWRITE
;
;   S.MWR--HANDLE MATWRITE STATEMENT
;
;
S.MWR:
;
  SPELL <I,T,E> ;MATWR'ITE
  HRRZI T0,1 ;NO NEW DIMS//ASSUME 1-D
  JSP T,MIOSCN ;TREAT AS I/O STATEMENT
    EXP 0 ;NO DEFAULT FOR FILE
    XWD R.MWRN,R.MWRN ;MAT WRITE NUM
    XWD R.MWRS,R.MWRS ;MAT WRITE STR
    EXP -1 ;NO DONE
    EXP -1 ;NO DONE/CON
    EXP MATSCN ;USE MAT NAMES
    XWD R.RNST,R.RSST ;RANDOM FILE SET UP
;
;
  SUBTTL STATEMENT ROUTINES--NEXT
;
;   S.NEX--THIS ROUTINE HANDLES THE 'NEXT' STATEMENT.  A MATCHING
;      FOR STATEMENT MUST HAVE BEEN FOUND AND MUST BE ON THE TOP
;      OF THE STACK (COMPILERS). CODE IS GENERATED FOR A
;      TRANSFER BACK FOR THE NEXT LOOP ITEM AS WELL AS FOR THE EXIT
;      SYMBOL FROM THE LOOP.  THE SYMBOL NUMBERS FOR THESE ARE TAKEN
;      OFF THE STACK.
;
;
 S.NEX:
    SPELL <T>          ;NEX'T
    TLZ FG,NCHBT ;NEXT CHR NOT SCANNED
    PUSHJ P,VARNM     ;GET VARIABLE NAME
    HRRO   T7,T0       ;NEXT STACK WORD
  CAME T7,0(P) ;FOR SHOULD BE ON TOP OF STACK
      ERR E.NWOF ;ERROR IF NOT FOUND
;
    POP    P,T1        ;POP OFF THE VAIRBLE NUMBER
    POP    P,T6        ;AND THEN THE SYMBOL NUMBER FROM STACK
    POP P,R2 ;RESTORE LINK
    TLO R2,(JRST) ;FORM JUMP BACK
    SVWPR ;SAVE
    MOVE R2,OBJPT ;GET CURENT LOC
    ADD T6,OBJCOD ;ABS ADDRESS OF INK T FILL IN
    HRRM R2,0(T6) ;FILL IN EXIT TRANSFER
    POP P,R1 ;LINE NUMBER
    TLO    FG,NCHBT    ;NEXT CHR ALREADY SCANNED
    JRST   EOL         ;AND THEN DONE
;
;
    PRINTX *****START OF BAS51*****
;
;
  SUBTTL STATEMENT ROUTINES--ON
;
;   S.ON--THIS ROUTINE GENERATES CODE FOR THE ON STATEMENT.  IT  FIRST
;      LOADS AND THEN FIXES THE ON VALUE.  NEXT IT CHECKS IF IT IS IN
;      BOUNDS, AND FINALLY IT JUMPS TO THE PROPER PLACE.  IT THEN
;      GENERATES TRANSFERS TO THE VARIOUS LINES FOLLOWED BY A WORD
;      CONTAINING THE UMBER OF LINES SPECIFIED.
;
;
 S.ON:
    SKIPGE PRGNM       ;CHECK IF MAIN PROGRAM
    PUSHJ P,STMAIN      ;SET UP FOR IT IF SO
;
    MOVEI R2,TRGOTO!TRGOSB ;ALLOW GOTO OR GOSUB
    MOVEM R2,ALWTRM ;TO TERMINATE SCAN
    HRLZI  FG,NUMBT    ;NUMERIC AEXPRESSION
    PUSHJ P,ARSCN       ;SCAN IT
    PUSHJ P,GTLOD ;LOAD INTO REG
    HRRZ T1,0(VS) ;GET ITEM OF STACK
    PUSHJ P,CKRG ;MAKE SURE NOT REG 0
    MOVEM T1,0(VS) ;RESAVE NEW ITEM IF IT WAS
    POP VS,R2 ;GET ITEM OFF STACK
    LSH    T7,22+4+1   ;GET REG IN REG FIELD IN T7
    RFIX R2 ;FIX AT RUN TIME
    HRRZ T6,R2 ;GET NEW REG IN T6
    MOVE T7,T6 ;AND T7
    LSH T7,22+4+1 ;AND IN T7 IN REG FIELD
;
    MOVSI R2,(SKIPLE) ;CHECK FOR <=0
    ADD    R2,T6       ;PLUS REG
    SAVWD              ;SAVE
;
    PUSH P,OBJPT ;SAVE CURRENT ADD
    MOVSI R2,(CAILE) ;GENERATE COMPARE
    ADD    R2,T7       ;PLUS REG
    SAVWD              ;SAVE CHECK FOR UPPER BOUND
;
    MOVSI R2,(R.ONER)    ;GET ROUTINE FOR ON ERROR
    SAVWD ;SAVE UUO FOR IT
;
    MOVE R2,OBJPT ;GET CURRENT ADDRESS
    TLO    R2,(JRST) ;GENERATE JUMP TO OURSELF
    LSH    T6,22       ;GET REG AS INDEX
    ADD    R2,T6       ;TO INSTRUCTION
    SVWPR              ;AND SAVE IT
;
    MOVEI R2,0 ;NEITHER GOSUB NOR GOTO
    MOVE   T1,ARTERM   ;CHECK TERMINATRO FROM SCAN
    CAIN T1,TRGOTO ;CHECK FOR GOTO
    MOVSI R2,(JRST) ;IF SO, DO JRST
    CAIN T1,TRGOSB ;CHECK FOR GOSUB
    MOVSI R2,(PUSHJ R.P,) ;IF SO, USE PUSHJ
    SKIPN R2 ;MUST BE ONE OR OTHER
    ERR E.INFT ;ELSE ERROR
    MOVEM R2,TEMPA ;SAVE OP TO USE
;
    MOVEI  T2,1        ;COUNT TO ONE
    SKIPA              ;AND SKIP
;
 ON1:
    TLZ    FG,NCHBT    ;NEXT CHAR ALREADY SCANNED
    PUSHJ P,GTLNNO      ;SCAN A LINE NUMBER
    MOVE   R2,T7       ;GET LINE NUMBER REFERNCE
    ADD    R2,TEMPA ;CREAT JUMP
    SVWPR              ;SAVE
    CAIN   CH,ASCCMA   ;CHECK FOR COMMA TERM
    AOJA   T2,ON1      ;YES--TRY AGAIN
    POP P,T0 ;GET REF TO MAX
    ADD T0,OBJCOD ;GET REAL ADD
    HRRM T2,0(T0) ;SAVE MAX FOR COMPARE
    JRST   EOL         ;THEN DONE
;
;
;
  SUBTTL STATEMENT ROUTINES--PRINT
;
;   S.PRI--THIS ROUTINE HANDLES THE PRINT STATEENT.  THIS DIFFERS FROM
;     ALL OTHER I/O ROUTINES WHICH ARE HANDLED BY IOSCN OR IODRV IN
;      THAT SEVERAL SPECIAL CASES MUST BE HANDLED.  THESE INCLUDE THE
;      DIFFERENCE BETWEEN COMMA AND SEMICOLON, THE USE OF THESE TWO
;      CHARACTERS AT THE END OF THE LINE; MULTIPLE COMMAS; THE TAB
;      FUNCTION; AND FINALLY, THE USING CLAUSE.
;
;   THE ROUTINE R.FSET OR R.TSET IS USED TO SELECT THE FILE.  THEN
;      R.PNUM PRINTS NUMBERS, R.PSTR PRINTS STRINGS; R.PEOL PRINTS A
;      CARRIAGE RETURN=LINE FEED; R.PCMA TABS FOR A COMMA;
;      R.TAB PERFORMS THE TAB FUNCTION.
;
;
 S.PRI:
    SPELL <N,T>        ;PRI'NT
    SETZM MATFG# ;NOT MAT PRINT
;
 PRNT0:
    MOVEI  R2,R.TSET   ;TERMINAL DEFAULT
    PUSHJ P,FILNO       ;SCAN FILE NUMBER
    NOP                ;IGNORE NONE
    MOVEI  R2,R.PRST   ;CALL TO PRINT SET UP
    PUSHJ P,SVCAL     ;SAVE IT
    TLON FG,NCHBT ;SCAN NEXT CH
    JSP T,NXECH ;IF NECESSARY
    SKIPE MATFG# ;CHECK FOR MATPRINT
    JRST PRNT0A ;CAN'T HAVE EMPTY FIELD IF SO
    CAIN CH,ASC.LF ;CHECK FOR EMPTY LINE
    JRST PRNT5 ;HANDLE IF SO
    CAIN CH,ASCCMA	;CHECK FOR COMMA START
    JRST PRNT7
    CAIN CH,ASCSEM	;CHECK FOR SEMICOLON START
    JRST PRNT6		;HANDLE
;
 PRNT0A:
    HRLZI FG,NCHBT+PRIBT ;BITS FOR ARITHMETIC SCAN
    SKIPE MATFG		;CHECK FOR MAT PRINT
    TLO FG,MATBT	;WANT MAT IF SO
    SETOM PRIFG ;MARK AS PRINT SCAN
    PUSHJ P,ARSCN       ;SCAN FIRST ITEM
    JRST   PRNT1       ;NORMAL EXPRESSION
    JRST   PRTAB       ;TAB FUNCTION
    JRST   S.PUSG      ;'USING'
;
;   PROCESS AN EXPRESSION
;
 PRNT1:
    SKIPE MATFG ;CHECK FOR MAT PRINT
    JRST MPR1 ;HANDLE IF SO
    TLNN   FG,NUMBT    ;CHECK EXPRESSION TYPE
    JRST   PRNT2       ;HANDLE STRING
    MOVEI  T2,R.PNUM   ;ROUTINE TO PRINT NUMERIC
    JRST   PRNT3       ;SKIP
;
 PRNT2:
    TLNN   FG,STRBT    ;CHECK FOR STRING
    ERR    E.INFT      ;ERROR IF NOT
    MOVEI  T2,R.PSTR   ;ROUTINE TO PRINT A STRING
;
 PRNT3:
    PUSHJ P,DORSB1 ;GENERATE CALL
;
;   HANDLE INTER-EXPRESSION TERMINATORS
;
 PRNT4:
    CAIN   CH,ASC.LF   ;CHECK FOR EOL
    JRST   PRNT5       ;HANDLE IF SO
    CAIN   CH,ASCSEM   ;CHECK FOR SEMI-COLON
    JRST   PRNT6       ;HANDLE
    CAIN   CH,ASCCMA   ;CHECK FOR COMMA
    JRST   PRNT7       ;PROCESS
    ERR    E.INFT      ;ELSE ERROR
;
 PRNT5:
    MOVEI  R2,R.PEOL   ;END OF LINE
    PUSHJ P,SVCAL     ;SAVE CALL FOR CRLF PARIN
;
 PRNT9:
    SETZM MATFG# ;CLEAR MAT FLAG ON EXIT
    JRST   RTEOL         ;AND THEN DONE
;
 PRNT6:
  SKIPG CH,PRIFG	;IF EXTRA CHR ALREADY SCANNED, USE IT
    JSP    T,NXECH     ;CHECK NEXT CHARACTER
  SETOM PRIFG		;RESET PRINT FLAG
    TLO    FG,NCHBT    ;MARKED AS SCANNED
    CAIN   CH,ASC.LF   ;CHECK FOR EOL
    JRST   PRNT9       ;DONE IF SO
    JRST   PRNT8       ;ELSE CONTINUE WITH NEXT EXPRESSION
;
 PRNT7:
    MOVEI  R2,R.PCMA   ;COMMA--TAB MULTIPLE 15
    PUSHJ P,SVCAL     ;SAVE THE CALL
    JSP    T,NXECH     ;GET NEXT CHARACTER
    TLO    FG,NCHBT    ;MARK AS SCANNED
    CAIN   CH,ASC.LF   ;CHECK FOR EOL
    JRST   PRNT9       ;HANDLE IF SO
    SKIPE MATFG ;CHECK IF MAT
    JRST PRNT8 ;MULTIPLE COMMA'S NOT ALLOWED IF SO
    CAIN   CH,ASCCMA   ;CHECK FOR MULTIPL COMMAS
    JRST   PRNT7       ;HANDLE IF SO
;
;   HANDLE ANOTHER FIELD
;
 PRNT8:
    TLZ    FG,-1-NCHBT ;PRESERVE ONLY NCHBT
    TLO    FG,PRIBT    ;PPINT EXPRESSION
    SKIPE MATFG		;CHECK FOR MAT PRINT
    TLO FG,MATBT	;WANT A MATRIX IF SO
    PUSHJ P,ARSCN       ;SCAN IT
    JRST   PRNT1       ;EXPRESSION FOUND
    JRST   PRTAB       ;TAB FOUND
    ERR    E.INFT      ;'USING' FOUND--NOT FIRST--EERROR
;
;   HANDLE TAB/PAG/LIN FUNCTION
;
 PRTAB:
    SKIPE MATFG ;CHECK IF MAT PRINT
    ERR E.INFT ;CAN'T TAB IF SO
    MKLOD (T0) ;LOAD THE ARGUEMNT
    HRLZI  T0,400000   ;REGISTER 0 FREE
    IORM   T0,REGFGS   ;OR SHOULD BE
    JRST   PRNT4       ;NOTE--LOADIN CAUSES FUNCTION CALL TO 'TAB'
;
;
;
SUBTTL STATEMENT ROUTINE--PRINT--MAT PRINT VERSION
;
;      MPR1--THIS GENERATES PRINT-TYPE CODE FOR A MATRIX
;   WHICH WE ARE MAT PRINTING.
;
;
 MPR1:
  MOVEI T2,R.MPRN ;ROUTINE TO CALL
  TLNN FG,NUMBT ;FOR NUMERIC
    MOVEI T2,R.MPRS ;ROUTINE FOR STRING IF NOT NUMERIC
  PUSHJ P,DORSB1 ;GENERATE CALL
  MOVE T0,1(VS) ;RESTORE MAT PTR
;
  CAIN CH,ASCSEM ;CHECK FOR ';' TERMINATOR
    JRST MPR2 ;HANDLE IF SO
  MOVEI R2,R.PCMA ;ELSE ASSUME COMMA SPACE BETWEEN ELEMENTS
  PUSHJ P,SVCAL ;SAVE IT
;
  MOVEI R2,R.PEOL ;GUESS NEW LINE WITH EACH ROW
  CAIN CH,ASC.LF ;CHECK IF THAT'S THE CASE
    MOVEI R2,R.PCMA ;NO--IF VECTOR, WANT COMMA SPACING
  JRST MPR3 ;AND SKIP
;
 MPR2:
  MOVSI R2,(TRN) ;HANDLE SEMI-COLON SPACING
  SAVWD ;BY DOING NOTHING BETWEEN ELEMENTS
  MOVEI R2,0 ;AND NOTHING BETWEEN VECTOR ELEMENTS
;
 MPR3:
  SKIPL MATDTB(T0) ;CHECK IF VECTOR
    MOVEI R2,R.PEOL ;IF NOT, ALWAYS NEW LINE BETWEEN ROWS
  JUMPE R2,MPR4 ;HANDLE NOTHING BETWEEN ROWS
  PUSHJ P,SVCAL ;SAVE CALL TO ACTION BETWEEN ROWS
  JRST MPR5 ;AND CONTINUE WITH PRINT SCAN
;
 MPR4:
  MOVSI R2,(TRN) ;GET OP TO DO NOTHING
  SAVWD ;ABOUT SPACING BETWEEN ITEMS
;
 MPR5:
  CAIE CH,ASC.LF ;CHECK FOR EOL
    JRST PRNT6 ;HANDLE
  JRST PRNT9 ;HANDLE OTHER DELIM
;
;
  SUBTTL STATEMENT ROUTINES--PRINT USING
;
;   S.PUSG--THIS ROUTINE IS ENTERED FROM THE PRINT ROUTINE WHEN USING
;      IS THE FIRST ITEM IN THE LINE.  IT IS USED TO PERFORM FORMATTED
;      PRINTS.
;
;   IT GENERATES AN INITIAL CALL TO R.USNG PASSING THE FORMAT STRING.
;      THEN TO PRINT A NUMBER, R.PUNM IS CALLED; FOR A STRING, R.PUST
;      IS CALLED.  AT THE END OF THE USING, R.PUND IS CALLED.  ALSO,
;      WHERE INDICATED, CALLS WILL BE INSERTED TO R.PEOL FOR A NEW
;      LINE.
;
;
 S.PUSG:
    HRLZI  FG,STRBT    ;SCAN THE USING STRING
    PUSHJ P,ARSCN       ;AS AN EXPRESSIN
    MOVEI  T2,R.USNG   ;ROUTINE TO CALL FOR IT
    JRST   PUSG3       ;AND ENTER LOOP
;
;   HANDLE NEXT EXPRESSION
;
 PUSG8:
    TLZ    FG,-1-NCHBT ;SAVE ONLY NCHBT
    SKIPE MATFG ;CHECK FOR MATPRINT USING
    JRST MPU1 ;GENERATE CODE FOR IT IF SO
    PUSHJ P,ARSCN       ;SCAN AN EXPRESSION
    TLNN   FG,NUMBT    ;CHECK IF NUMERIC
    JRST   PUSG2       ;HANDLE IF NOT
    MOVEI  T2,R.PUNM   ;PROINT FOR NUMERIC
    JRST   PUSG3       ;PROCESS
;
 PUSG2:
    TLNN   FG,STRBT    ;CHECK FOR STIRNG
    ERR    E.INFT      ;ERROR IF NOT
    MOVEI  T2,R.PUST   ;ROUTINE FOR STRING
;
 PUSG3:
    PUSHJ P,DORSB1 ;GENERATE CALL
;
;   HANDLE TERMINATORS
;
 PUSG4:
    CAIN   CH,ASC.LF   ;CHECK FOR END OF LINE
    JRST   PUSG5       ;HANDLE IF SO
    CAIN   CH,ASCSEM   ;CHECK FOR SEMICOLON
    JRST   PUSG6       ;HANDLE
    CAIN   CH,ASCCMA   ;CHECK FOR COMMA
    JRST   PUSG6       ;HANDLE
    ERR    E.INFT      ;ELSE ERROR
;
 PUSG5:
    MOVEI  R2,R.PUND   ;END OF LINE
    PUSHJ P,SVCAL     ;SAVE CALL FOR END OF PRINT USING
    JRST   PRNT5       ;AND DONE--EXIT EIXT WITHH CRLF
;
 PUSG6:
  SKIPG CH,PRIFG	;IF EXTRA CHR ALREADY SCANNED, USE IT
  JSP  T,NXECH   ;COMMA OR SEMICOLON
  SETOM PRIFG		;RESET PRINT FLAG
  TLO  FG,NCHBT  ;SCAN AND FLAG FOR NEXT CHAR
    CAIE   CH,ASC.LF   ;CHECK FOR EOL
    JRST   PUSG8       ;HANDLE IF NOT--NEXXT EXPRESSION
    MOVEI  R2,R.PUND   ;ELSE END OF PRINT USING
    PUSHJ P,SVCAL     ;SAVE CALL FOR THAT
    JRST   PRNT9       ;AND THEN DONE
;
;
SUBTTL STATEMENT ROUTINES--PRINT USING--MAT PRINT USING CODE
;
;   MPU1--THIS ROUTINE GENERATES THE CALLING SEQUENCE FOR 
;      MAT PRINT USING.
;
;
 MPU1:
  HRRZI T0,1 ;1D MATRIX, NO REDIM ALLOWED
  PUSHJ P,MATSCN ;SCAN MATRIX NAME
;
  MOVEI T2,R.MPUN ;ASSUME NUMERIC
  TLNN FG,NUMBT ;CHECK THAT
  MOVEI T2,R.MPUS ;ENTRY FOR STRING
  PUSHJ P,DORSB1 ;GENERATE CALL WITH MAT ARG
;
  MOVE T0,1(VS) ;GET MAT PTR
  MOVSI R2,(TRN) ;DO NOTHING BETWEEN ELEMENTS
  SAVWD ;SAVE THAT
  SKIPGE MATDTB(T0) ;CHECK FOR 1D
    JRST MPU2 ;HANDLE 1D
  MOVEI R2,R.UEOL ;2D--NEW LINE FOR EACH ROW
  PUSHJ P,SVCAL ;SAVE THE CALL
  JRST PUSG4 ;AND CONTINUE IN PRINT USING CODE
;
 MPU2:
  MOVSI R2,(TRN) ;DO NOTHING BETWEEN VECTOR ELS
  SAVWD ;SAVE
  JRST PUSG4 ;CONTINUE
;
;
  SUBTTL STATEMENT ROUTINES--RANDOMIZE
;
;   S.RAN--THIS ROUTINE HANDLES THE 'RANDOMIZE STATEMENT.  IT
;      GENERATES A CALL TO THE R.RNDM ROUTINE TO GET A RANDOM SERIES OF
;      RANDOM NUMBERS.
;
;
 S.RAN:
    SPELL <D,O,M,I,Z,E>
    MOVEI  R2,R.RNDM   ;GET ROUTINE
    PUSHJ P,SVCAL     ;SAVE THE CALL
    JRST   EOL         ;AND THEN DONE
;
;
;
  SUBTTL STATEMENT ROUTTNES--READ
;
;   S.REA--THIS ROUTINE HANDLES THE READ ROUTINE.  IT USES IOSCN TO
;      GENERATE CODE FOR I/O AND USES THE RNUM AND RSTR FOR NUMBERS
;      AND STRING RESPECTIVELY.  IN ADDITION, NO FILE IMPLIES
;      THAT DATA IS TO BE USED.
;
;
 S.REA:
    SPELL <D>
    JSP    T,IOSCN     ;CALL IOSCN
    XWD    -1,READ1          ;DEFAULT TO FILE IS DATA (INTERNAL)
    EXP    R.RNUM      ;READ NUMERIC
    EXP    R.RDST      ;READ STRING
    EXP    -1          ;NO DONE ROUTINE
    EXP    -1          ;NO DONE-CONTINUE ROUTINE
    EXP    INPVAR      ;ROUTINE TO SCAN FIELD
    XWD    R.RNST,R.RSST  ;SETUP
;
 READ1:
    EXP    0           ;INTERNAL READ BLOCK--NO FILE
    EXP    R.RDTN      ;NUMERIC DATA READ
    EXP    R.RDTS      ;STRING DATA READ
    EXP    -1          ;NO DONE
    EXP    -1          ;NO DONE-CONTINUE
    EXP    INPVAR      ;INPUT TYPE VARIABLES
    EXP    0           ;NO SETUP NEEDED
;
;
;
  SUBTTL STATEMENT ROUTINES--REM
;
;   S.REM--THIS ROUTINE HANDLE THE REMARK (COMMENT) STATEMENT.  BASICALLY,
;      IT DOES NOTHING.
;
;
 S.REM:
    JRST   XEOL        ;IGNORE REST OF LINE
;
;
;
  SUBTTL STATEMENT ROUTINE--RESET
;
;
;   S.RES--THIS STATMENT HANDLES THE RESET STATEMENT.  IT EITHER GENERATES
;      A FILE SETUP AND THEN A CALL TO R.RRST (RANDOM FILE RESET) OR
;      R.RST (ASCII FILE RESET); OR IT GENERATES A CALL TO R.RSTR FOR
;      DATA RESTORE.
;
;
 S.RES:
    SPELL <E,T>        ;RES'ET
    MOVEI  R2,R.RSTR   ;NO FILE--RESTORE DATA
    PUSHJ P,FILNO       ;SCAN FILE NUMBER
    JRST   EOL         ;IF RESTORE DATA, THEN DONE
;
    TLON   FG,NCHBT    ;ELSE CHECK NEXT CHARACTER
    JSP    T,NXECH     ;ON LINE
    CAIN   CH,ASC.LF   ;FOR LINE FEED
    JRST   RESET1      ;END OF LINE--HANDLE ASCII FILE RESET
    HRLZI  FG,NUMBT+NCHBT ;RANDOM--GET ARGUMENT
    PUSHJ P,ARSCN       ;SCAN IT
    MOVEI T2,R.RRST ;ROUTINE TO CALL
    PUSHJ P,DORSB1 ;GENERATE CALL
    JRST   RTEOL         ;AND THEN DONE
;
 RESET1:
    MOVEI  R2,R.RST    ;ASCII FILE RESET
    PUSHJ P,SVCAL     ;SAVE THE CALL
    JRST   RTEOL         ;AND THEN DONE
;
;
;
  SUBTTL STATEMENT ROUTINES--RETURN
;
;   S.RET--THIS ROUTINE HANDLES THE RETURN (FROM GOSUB).  IT GENERATES
;      A POPJ R.P, WHERE R.P=15 (SEE GOSUB).
;
;
 S.RET:
    SPELL <U,R,N>      ;RET'URN
    MOVSI R2,(POPJ R.P,) ;GENERATE RETURN JUMP
    SAVWD              ;SAVE IT
    JRST   EOL         ;AND THEN DONE
;
;
;
  SUBTTL STATEMENT ROUTINES--SCRATCH
;
;   S.SCR--THIS ROUTINE HANDLE S THE SCRATCH STATEMENT. IT CALLS THE
;      IODRV ROUTINE TO SCAN THE FILE NUMBER (IF PRESENT< TTY DEFAULT)
;      AND THEN A NUMERIC FIELD, PASSING THE ARGUMENT TO R.SCR.
;
;
 S.SCR:
    SPELL <A,T,C,H>    ;SCR'ATCH
    MOVEI  R2,R.TSET   ;DEFAULT OF TTY
    PUSHJ P,FILNO       ;GET FILENUMBER
    ERR    E.FLNO      ;NONE--BAD--ERROR
    MOVEI  R2,R.SCR    ;RT ROUTINE NAME
    PUSHJ P,SVCAL     ;SAVE CALL TO IT
    JRST   RTEOL         ;AND DONE
;
;
;
  SUBTTL STATEMENT ROUTINES--STOP
;
;   S.STO--THIS ROUTINE HANDLES THE STOX STATEMENT.  IT GENERATES
;      A CALL TO R.STOP.
;
;
 S.STO:
    SPELL <P>          ;STO'P
    MOVEI  R2,R.STOP   ;GET ROUTINE TO CALL
    PUSHJ P,SVCAL     ;GENERATE CALL
    JRST   EOL         ;AND THEN DONE
;
;
;
SUBTTL STATEMENT ROUTINES--SUB
;
;   S.SUB--THIS ROUTINE HANDLES THE SUB STATEMENT.  IT PUTS THE
;      SUB ARGUMENTS ON THE GENERAL STACK AND ALLOCATES SPACE FOR
;      THEM.  IT ALSO BEGINS PROGRAM COMPILATION.
;
;
S.SUB:
;
  JSP T,NXECH ;CHECK NEXT CHR
  CAIN CH,ASC..E ;FOR 'E'---SUB'E'ND
  JRST S.SUBE ;HANDLE IF SO
;
  MOVEI R2,1 ;GET POSITIVE FLAG
  MOVEM R2,CALFG ;SAVE IT
  SKIPL PRGNM ;MAKE SURE WE DON'T HAVE A PROGRAM
    ERR E.SUB ;MUST BE FIRST STMT IN PROGRAM
  PUSHJ P,RINIT		;REINITIALIZE STORAGE FO PREVENT ERRORS
  SETZM R.DBGR+1	;UNDO LINKS OF COMMENT LINES
  SETZM STADD		;AND STARTING ADDRESS OF COMMENTS
;
  HRLZI FG,STRBT+NCHBT ;BITS TO SCAN SUB NAME
  PUSHJ P,ARSCN ;AS STRING CONSTANT
  POP VS,T0 ;GET OFF STACK
  TLNN T0,VTCON ;MAKE SURE IT IS A STRING CONST
    ERR E.SBNM ;ERROR IF NOT
  PUSHJ P,FNDSUB ;FIND SUB ENTRY IN TABLE
  MOVE T0,SUBBTS(T7) ;GET BITS FOR SUB
  TLNE T0,SBBDEF ;CHECK IF DEFINED--MARK AS SUCH
    ERR E.TWSB ;ERROR IF ALREADY DEFINED
  MOVE T0,CRSUB ;GET CURRENT SUB
  MOVEM T0,PRGNM ;SAVE AS PROGRAM NAME
  MOVE T1,LSTLN		;GET LAST LINE NUMBER
  HRLM T1,SUBFLN(T0)	;SAVE FOR EDITING?
  MOVE T1,CURLIB	;GET CURRENT LIBRARY PTR
  HRRM T1,SUBLIB(T0)	;SAVE IN SUB BLOCK
  MOVEM T0,CURSUB	;AND SAVE THIS SUB BLOCK AS CURRENT
;
  PUSHJ P,STSBAR ;PREPARE TO SCAN ARGS
  MOVEM P,TEMPA ;SAVE INITIAL PDL
  CAIE CH,ASCCOL ;CHECK FOR ':'--INDICATES ARGS
  JRST SUB1 ;NO ARGS--JUMP
;
 SUB2:
  TLZ FG,NCHBT ;IGNORE CURRENT CHR
  PUSHJ P,SBARG ;SCAN AN ARG
    ERR E.SBAR ;MUST BE A VARIABLE
  PUSHJ P,ALSBVR ;ANDFINISH ALLOCATING SPACE FOR IT
;
  PUSH P,T0 ;SAVE THE ARG ON STACK
  CAIN CH,ASCCMA ;CHECK FOR ANOTHER ARG
  JRST SUB2 ;HANDLE IF SO
;
 SUB1:
  PUSHJ P,CKSBTY ;CHECK SUB TYPE
;
  PUSHJ P,ASBMTS ;DO MATRIX ALLOCATIONS
  PUSH P,NSBARG ;SAVE NUMBER OF ARGS
  PUSH P,TEMPA ;SAVE INITAL STACK PTR TO ARGS
  PUSH P,CRSUB ;SAVE SUB BLK PTR
  HRLZI R2,-3 ;GET MARKER
  PUSH P,R2 ;AND SAVE IT
;
  MOVEI R2,R.DBSB ;IF DEBUG MODE, TELL DBGR WE ENTERED SUB
  SKIPE DEBFG ;CHECK IF DEBUG MODE
  PUSHJ P,SVCAL ;SAVE THE CALL
;
  JRST EOL ;AND DONE
;
;
SUBTTL STATEMENT ROUTINES--SUBEND
;
;   S.SUBE--THIS ROUTINE HANDLES THE SUBEND STATEMNT BY GENERATING
;      AN END OF SUB BLOCK TO RETURN TO THE CALLING ROUTINE AND
;      AN ENTRY BLOCK TO SET UP THE SUB ON ENTRY.
;
;
S.SUBE:
;
  SPELL <N,D> ;SUBE'ND
;
  SKIPG PRGNM ;MAKE SURE WE WERE IN A SUB
    JRST SBND4 ;NO--ERROR AND TREAT LIKE END
;
  PUSHJ P,ALCARS ;ALLOCATE ARRAYS IN VARIABLE AREAS
  PUSHJ P,GTPGDT ;GET PRGM DATA
;
  HRLZI T7,-3 ;MARKER FOR STACK FROM SUB
  PUSHJ P,CLRP ;FIND IT
    BLOWUP ;MUST BE FOUND
;
  POP P,T0 ;GET MARKER OFF STACK
  POP P,T7 ;CURRENIT SUB BLK PTR
  POP P,T6 ;STACK PTR FOR ARGS
  POP P,T5 ;NUMBER OF ARGS
;
  MOVE R2,[POP R.P,16] ;POP RETURN OFF THE STACK
  SAVWD ;SAVE THAT
;
  MOVEI R2,R.SBEX ;EXIT ROUTINE
  PUSHJ P,SVCAL ;SAVE CALL TO IT
;
  MOVSI T0,20 ;MARK REG15 AS USED
  IORM T0,REGUSD ;AND SAVE THAT ON STACK
  PUSHJ P,SVRGS ;RESTORE REGS
    XWD 4,17 ;START WITH R17
    POP R.P, ;USING POP
    LSH T1,1 ;NEXT REG BIT
    SOS T2 ;NEXT REG NUM
;
  MOVSI R2,(JRST 0(16)) ;GET RETURN INST
  SAVWD ;AND SAVE RETURN
;
  MOVE R2,OBJPT ;GET CURRENT PTR
  MOVEM R2,ENTADD ;SAVE AS ENTRY ADDRESS
;
  MOVE R2,[POP R.P,16] ;RESTORE CALL ADDRESS FOR ENTRY CODE
  SAVWD ;SAVE RESTORE CODE
;
  PUSHJ P,SVRGS ;SAVE REGS
    XWD 100000,2 ;START WITH R2
    PUSH R.P, ;USING PUSH
    LSH T1,-1 ;NEXT REG BIT
    AOS T2 ;NEXT REG NUMBER
;
  MOVE R2,PGDATA ;PROGRAM DATA AREA PTR
  TLO R2,(MOVEI 1,) ;GET PTR TO IT IN 1 AT RT
  SVWCN ;SAVE CODE
;
  MOVEI R2,R.SBEN ;ENTRY ROUTINE 
  PUSHJ P,SVCAL ;SAVE CALL TO IT
;
  PUSHJ P,FCTCHK	;CHECK PASSED FUNCTIONS
  PUSHJ P,PRPMAT ;PREPARE MATRICES
  MOVE R2,[PUSH R.P,16] ;SAVE THE RETURN ADDRESS
  SAVWD ;AT RUN TIME
  MOVE R2,STADD ;GET PROGRAM START ADDRESS
  TLO R2,(JRST) ;FORM JUMP TO IT
  SVWPR ;AND SAVE TO ENTER FIRST LINE OF CODE
;
  PUSH P,T7 ;PRESERVE T7
  PUSHJ P,ENBIN ;END OF BINARY FILE
  POP P,T7 ;RESTORE T7
  MOVE R2,LSTLN		;GET LAST LINE
  HRRM R2,SUBTLN(T7)	;SAVE AS TO LINE IN SUB BLOCK
  MOVE R2,ENTADD ;GET ENTRY ADDRESS
  ADD R2,PGMOFF ;RELOCATE REALLY
  PUSHJ P,DEFSUB ;DEFINE SUB IF RELEVANT
  SETOM PRGNM ;NO PROGRAM
  PUSHJ P,RINIT ;REINITIALIZE FOR NEXT PROGRAM
  MOVE P,SAVEP		;GET A FRESH P STACK
  PUSH P,[XWD -5,0]	;SAVE INITIAL MARKER
;
  JRST EOL ;AND DONE
;
SBND4:
  ERR E.SBND ;ERROR IF OCCURS IN MAIN PROGRAM
  JRST END0 ;AND FAKE AS END STATEMENT
;
;
SUBTTL STATEMENT ROUTINES--TIME
;
;   HANDLES THE TIME STATEMENT--ALLOWED ONLY IN MAIN PROGRAM--NOT
;      IMPLEMENTED AT RUN TIME YET DO TO TENEX DEFICIENCIES.
;
;
S.TIM:
;
  SPELL <E>		;TIM'E
;
  HRLZI FG,NUMBT ;SCAN A NUMERIC EXPRESSION
  PUSHJ P,ARSCN 
  POP VS,T0 ;GET RESULT
  TLNN T0,VTCON ;BETTER BE CONSTANT
    ERR E.TIM ;ERROR IF NOT
  MOVE R2,0(T0) ;YES--PICK UP CONST
  DSVCON (R2) ;SAVE DUPLICATABLE
  MOVEM R2,TIMEC ;SAVE PTR TO IT FOR START UP
  SKIPE PRGNM ;CHECK FOR MAIN PROGRAM
    ERR E.TMPG ;BETTER BE THAT AS WELL
  ERR E.UIMP		;WARN USER TIME DON'T WORK
  JRST EOL ;AND DONE
;
;
  SUBTTL STATEMENT ROUTINES--WRITE
;
;   S.WRI--THIS ROUTINE HANDLES THE WRITE STATEMENT. IIT USES THE IOSCN
;      ROUTINE TO SCAN THE INPUT LINE FOR FILE NUMBER AND EXPRESSIONS.
;      NO SET UP CALL OR DONE CALL IS NEEDED, AND INTERMEDIATE CALLS ARE
;      DONE WITH R.WNUM AND R.WSTR FOR NUMBERS AND STRINGS.
;
;
 S.WRI:
    SPELL <T,E>        ;WRI'TE
    JSP    T,IOSCN     ;CALL IOSCN
    EXP    0           ;FILE REQUIRED
    EXP    R.WNUM      ;NUMERIC WRITE
    EXP    R.WSTR      ;STRING WRITE
    EXP    -1          ;NO DONE ROUTINE
    EXP    -1          ;NO DONE--CONTINUE ROUTINE
    EXP    ARSCN       ;USE ARSCN FOR EXPRESSIONS
    XWD    R.RNST,R.RSST      ;SET UP FOR WRITE
;
;
;
    PRINTX *****START OF BAS52*****
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--ARSCAD
;
;   ARSCAD--THIS ROUTINE SCANS AN EXPRESSION AND INSURES THAT THE OUTCOME
;      IS DIRECTLY LOADABLE BUT NOT IN A REGISTER.  IT IS USED PRIMARILY
;      BY THE 'FOR' STATEMENT.  IT RETURNS THE ADDRESS IN R2.  MOREOVER
;      THE SIGN BIT OF R2 IS SET ON IF THE ADDRESS IS RELOCATABLE. ELSE
;     IT ISN'T.
;
;   IT IS CALLED WIITH A PUSHJ P,ARSCAD.
;
;
 ARSCAD:
    PUSHJ P,ARSCN       ;SCAN AN EXPRESSION
    MKLOD (T1)		;INSURE ITS LOADABLE
    TLNE   T1,VTREG    ;CHECK FOR IN REGISTER
    JRST   ARCAD1      ;HANDLE
    TLNE T1,VTVAR+VTMEL+VTTMP ;CHECK IF VARIABLE
    JRST ARCAD2 ;MUST LOAD AND SAVE IF SO
    GTADD (T1)		;ELSE JUST GET ADDRESS
    DPB R1,[POINT 6,R2,5] ;SAVE TYPE OF ADDRESS
    POPJ P, ;AND RETURN
;
 ARCAD2:
    LOAD (T1)		;VARIABLE--LOAD INTO REG
;
 ARCAD1:
    HRRZ   R2,T1       ;GET VALUE IN R2
    PUSHJ P,SVTMP     ;SAVE IT IN TEMP
    HRLI R2,020000 ;TYPE OF ADDRESS==CONSTANT
    POPJ P, ;AND RETURN
;
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--ARSCVR
;
;   ARSCVR--THIS ROUTINE SCANS AN EXPRESSION AND GUARANTEES THAT IT
;      IS A VARIABLE DESIGNATOR OF SOME SORT.  IT IS USED FOR SCANS
;      OF INPUT LISTS, ETC.
;
;   IT IS CALLED WITH PUSHJ P,ARSCVR.  IT RETURNS TO 0(CALL) WITH A MATRIX
;      ELEMENT AND TO 1(CALL) WITH NORMAL VARIABLE
;
;
 ARSCVR:
    PUSHJ P,ARSCN       ;SCAN THE EXPRESSION
    MOVE   T1,0(VS)    ;CHECK TOP OF STACK
    TLNE   T1,VTVAR    ;FOR VARIABLE
    JRST   ARSVR1      ;HANDLE IF SO
    TLNE   T1,VTMEL    ;CHECK FOR MAT ELEMENT
    JRST   ARSVR2      ;AHDNEL IF SO
    TLNE   T1,VTSBC    ;HANDLE IF SUBSCRIPTING
    JRST   ARSVR3      ;;PROCESS IF SO
    ERR    E.VREX      ;ELSE VARAABLE REQUIRED ERROR
;
 ARSVR1:
    POP P,T1 ;GET RETURN IN T1
    JRST   1(T1)       ;VARIABLE ON STACK, DONE
;
 ARSVR2:
    POPJ P, ;AND RETURN
;
 ARSVR3:
    MKLOD (T7)		;LOAD THE SUBSCRIPTED VAR
    PUSH   VS,T7       ;AND RESTACK
    JRST   ARSVR2      ;THEN HANDLE LIKE MAT ELEMENT
;
;
;
SUBTTL STATEMENT SUBROUTINES--SCANNING--DMMAT
;
;   DMMAT--THIS ROUTINE IS CALLED TO SCAN NEW DIMS FOR A MAT
;      FOR A MAT I/O OPERATION.  THUS 0,1 OR 2 DIMS ARE ALLOWED
;      INITIALLY THE MATRIX IS IN T0.  THE MATRIX IS SET UP
;      WITH A CALL TO 'ALMAT' WITH THE PROPER DIMS.  ALSO, IF
;      ARGS ARE PRESENT, A REDIMMING ROUTINE IS CALLED AT RUN TIME.
;
;
DMMAT:
;
  TLON FG,NCHBT ;CHECK IF XTRA CHR SCANNED
  JSP T,NXECH ;SCAN NEXT
;
  CAIE CH,ASCLPR ;CHECK FOR '('
  JRST MAKMAT ;IF NOT, THEN JUST DIM THE MAT (T0)
;
  MOVE R2,T0 ;IF THERE, THEN GET MAT IN R2
  TLO R2,VTMAT ;MAKE INTO MAT
  HRLZI FG,OPBT+NCHBT+NUMBT ;PREPARE TO CALL ARITHMETIC SCAN
  TLNE T0,VTSTR ;CHECK IF STRING MAT
  TLC FG,NUMBT+STRBT ;HANDLE WHATEVER CASE
;
  PUSHJ P,XARSCN ;FAKE SBSC CALL FOR ARITHEMTIC SCAN
  POP VS,T0 ;GET SBSC HEADER OFF STACK
  TLC T0,VTVAR+VTSBC ;BACK TO VARIABLE
  POP VS,T1 ;NUMBER OF DIMS (MINUS)
;
  MOVNS T1 ;MAKE NUMBER OF DIMS POS
  JRST YDMMAT ;AND GENERATE CALL FOR REDIMMING
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--DMSTR
;
;   DMSTR--THIS ROUTINE SCANS A STRING AND PUTS IT INTO THE CONSTANT
;      AREA.  THE TERMINATOR IS TAKEN IN 0(T) OR A LINE FEED.  ON
;      EXIT IT GIVES THE NUMBER OF CHARS IN T5 AND  A POINTER TO THE
;      START OF THE STRING IN THE CONSTATN AREA IN T4.
;
;   IT IS CALLED WITH PUSHJ P,DMSTR/EXP TERM
;
;
 DMSTR:
    MOVE   R2,[XWD 0,200001] ;GET DUMMY STRING HEADER
    SVCON (T5)      ;SAVE IT--GET ADDRESS
    HRRZ   T6,CNSTK    ;GET ADDRESS OF STRING
    MOVEI  T4,0        ;COUNTER
    MOVE   T7,@0(P)   ;GET TERMINATOR
;
 DSTR3:
    MOVEI  T3,5        ;HANDLE NEXT WORD BOUNDARY
    MOVE   T1,[POINT 7,T2] ;CHARS TO T2
    SETZ   T2,         ;CLEAR OUTPUT WORD
;
 DSTR2:
    TLZN   FG,NCHBT    ;CHECK FOR NEXT CHARACTER
    JSP    T,NXCH      ;PICK UP IF NEEDED
    CAIN   CH,ASC.LF   ;CHECK FOR END OF LINE
    JRST   DSTR1       ;END OF LINE--EXIT
    CAIN   CH,ASCEOL   ;CHECK FOR MISC END OF LINE
    JRST   DSTR5       ;HANDLE
    CAIN   CH,ASCAPO   ;CHECK AGAIN
    JRST   DSTR7       ;HANDLE
    CAIN   CH,ASC.CR   ;CHECK FOR CR
    JRST   DSTR2       ;IGNORE IF SO
    CAMN   CH,T7       ;CHECK FOR TERMINATOR MATCH
    JRST   DSTR1       ;YES
;
 DSTR8:
    IDPB   CH,T1       ;ELSE SAVE CHAR
    AOS    T4          ;UPDATE CHAR COUNT
    SOJG   T3,DSTR2    ;BACK IF MORE ROOM IN T2
    MOVE R2,T2 ;GET WORD TO SAVE
    SVCON () ;AND SAVE IT
    JRST   DSTR3       ;AND NEW WORD
;
 DSTR7:
  CAIN T7,ASCQTE ;CHECK FOR QUOTE
  JRST DSTR8 ;QUOTED STRING--IGNORE IF SO
;
 DSTR5:
    JSP    T,CRECH     ;EDIT TO FAKE NXECH
;
 DSTR1:
    JUMPE  T4,DSTR4    ;NULL STRING--HANDLE
    TLNN   T1,770000   ;CHECK FOR LAST WORD NOT SAVED
    JRST   DSTR6         ;SAVED
    MOVE R2,T2 ;GET LAST WORD
    SVCON () ;SAVE IT
;
 DSTR6:
    HRLM   T4,0(T6)    ;SAVE CHARACTER COUNT
    AOS    R2,T5          ;UPDATE COUNT
    HRLI R2,440700 ;MAKE INTO TALLY
    MOVEI R1,4 ;RELOCATE AS CONSTANT
    XSVCON (T5) ;AND SAVE TALLY
    POP P,T7 ;GET RETURN
    JRST   1(T7)       ;AND RETURN
;
 DSTR4:
    SETZM R2 ;CLEAR CONSTANT TO SAVE
    SVCON (T5) ;SAVE,R ETURN ADD IN T5
    POP P,T7 ;GET RETURN
    JRST   1(T7)       ;AND RETURN
;
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--FILNO
;
;   FILNO--THIS ROUTINE SCANS A FILE NUMBER EXPRESSION STARTING WITH A
;      '#' AND ENDING WITH A ':'.  IT ACCEPTS IN R2 ON ENTRY THE RTP
;      ROUTINE TO CALL IF NO FILE EXPRESSION IS THERE.  IF ONE IS
;      PRESENT, R.FSET IS CALLED.  A R2 OF 0 YIELDS AN ERROR IF NO
;      FILE NUMBER IS PRESENT.  MOREOVER, CONTROL IS RETURNED TO
;      . ON NONE PRESENT AND TO .+1 ON ONE PRESENT.
;
;   IT IS CALLED WITH A MOVEI R2,<RTN>/PUSHJ P,FILNO
;
;
 FILNO:
    PUSH   P,R2        ;SAVE ENTRY R2 (ALT RTN)
    MOVSI R1,000100 ;FILE REG WILL BE USED
    IORM R1,REGUSD ;SAVE IN USED REGS WORD
    PUSH P,T ;SAVE T ON CALL
    JSP    T,NXECH     ;CHECK NEXT CHARACTER
    POP P,T ;RESTORE T OF CALL
    CAIE   CH,ASCNUM   ;CHECK FOR '#'
    JRST   FILNO1      ;HANDLE IF NOT
;
    POP P,R2 ;RESTORE R2 OFF STACK
    AOS FILUSD ;WE HAVE FILES IN THIS PROG
    HRLZI  FG,NUMBT    ;IF SO, SCAN NUMERIC FILE NUMBER
    PUSHJ P,ARSCN      ;AND GENERATE CALL
    MOVEI  T2,R.FSET   ;TO R.FSET
    HRRI FG,CLTEXT+1 ;EXTERNAL CALL OF ONE ARG
    PUSHJ P,GCALL ;GENERAL CALL
    CAIN   CH,ASC.LF   ;CHECK FOR EOL TERMINATOR
    JRST   FILNO2      ;HANDLE IF SO
    CAIE   CH,ASCCOL   ;CHECK FOR ':' TERMINATOR
    ERR    E.INFT      ;ERROR IF NOT
    TLZ    FG,NCHBT    ;IGNORE ':'
;
 FILNO3:
    POP P,R2 ;GET RETURN ADDRESS
    JRST   1(R2)       ;AND RETURN FILE PRESENT
;
 FILNO2:
    TLO    FG,NCHBT    ;MARK CHARACTER AS SCANNED ON EOL
    JRST   FILNO3      ;AND ERTEURN
;
;   HANDLE NO FILE NUMBER
;
 FILNO1:
    POP    P,R2        ;RESTORE ENTRY R2 (ALT RTN)
    SKIPN  R2          ;CHECK IF WE HAVE A DEFAULT
    ERR    E.FLNO      ;NO--ERROR
    SKIPL  R2          ;CHECK IF RTN OK
    PUSHJ P,SVCAL     ;YES--SAVE CALL TO DEFAULT
    TLO    FG,NCHBT    ;SCANNED TOO MANY CHARS
    POPJ P, ;AND RETURN
;
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--GTLNNO
;
;   GTLNNO--THIS ROUTINE SCANS A LINE NUMBER AND RETURNS THE RELOCATABLE
;      ADDRESS OF THE CORRESPONDING LINE IN T7 ON EXIT.
;
;   IT IS CALLED WITH A PUSHJ P,GTLNNO.
;
;
 GTLNNO:
    PUSHJ P,GTNM        ;GET A NUMBER
    SKIPLE T6          ;CHECK NUMBER OF CHARS <=0
    CAILE  T6,5        ;<=5
    ERR    E.LNNO      ;ILLEGAL LINE NUMBER
    PUSHJ P,LNREF     ;LEGAL--REFERENCE TO GET ADDRESS
    POPJ P, ;AND RETURN
;
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--GTNM
;
;   GTNM--THIS ROUTINE SCANS A NUMBER AND RETURNS THE NUMBER OF DIGITS IN
;     T6 AND THE NUMBER SCANNED IN T7.
;
;   IT IS CALLED WITH A PUSHJ P,GTNM.
;
;
 GTNM:
    MOVEI  T7,0        ;CLEAR NUMBER
    MOVEI  T6,0        ;AND CHAR COUNT
    TLON   FG,NCHBT    ;WE WILL SCAN TOO MANY CHARS
;
 GTNM2:
    JSP    T,NXECH     ;CHECK NEXT CHARACTER
    CAIL   CH,ASC..0   ;CHECK FOR DIGIT
    CAILE  CH,ASC..9   ;
    POPJ P, ;NO--RETURN DONE
    IMULI  T7,12       ;YES--GET NEW NUMBER
    ADDI   T7,-ASC..0(CH) ;FROM NEW DIGIT AND OLD NUM
    AOJA   T6,GTNM2    ;BUMP CHR COUNT AND CONTINUE
;
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--IODRV
;
;   IODRV--THIS ROUTINE HANDLES A STATEMENT OF THE FORM #N:X WHERE IT
;      IS DESIRED TO DO AN FSET FOR #N AND THEN CALL A CERTAIN ROUTINE
;      WITH X AS AN ARGUMENT.
;
;   IT IS CALLED WITH:
;         JSP T,IODRV
;         EXP <DEFAULT FILE ROUTINE> FOR NO FILE NUMBER
;         EXP <ARSCN BITS FOR ARG>
;         EXP <ROUTINE TO BE CALLED WITH ARG>
;      AND RETURNS TO EOL WHEN DONE.
;
;
 IODRV:
    MOVEM  T,TEMPA     ;SAVE RETURN
    MOVE   R2,0(T)     ;PICK UP THE DEFAULT ROUTINE
    PUSHJ P,FILNO       ;AND SCAN THE FILE NUMBER
      NOP ;IGNORE F OT THERE (WE HD DEFAULT
;
    TLZ    FG,-1-NCHBT ;IGNORE ALL BUT NEXT CHARACTER FLAG
    MOVE   T,TEMPA     ;RESTORE T PTR
    TDO    FG,1(T)     ;NEW BITS FROM CALL
    PUSHJ P,ARSCN       ;SCAN THE ARGUMENT
    MOVE   T,TEMPA     ;RESTORE CALL
    MOVE   T2,2(T)     ;GET ROUTINE TO CALL
    PUSHJ P,DORSB1 ;AND GENERATE CALL
    JRST   RTEOL         ;THEN DONE SCANNING LINE
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--IOSCN
;
;   IOSCN--THIS ROUTINE HANDLES A STANDARD I/O REQUEST STATEMENT SUCH
;      AS READ, INPUT, LINPUT, OR WRITE (PRINT IS NON-STANDARD).  IT
;      IS CCALLED WITH SEVERAL PARAMETERS AS FOLLOWS:
;
;         JSP T,IOSCN
;         EXP <DEFAULT RTN FOR NO FILE NUMBER>
;         EXP <CALL FOR NUMERIC I/O> (0 ILLEGAL)
;         EXP <CALL FOR STRING I/O>
;         EXP <CALL WHEN DONE NORMALLY>
;         EXP <CALL WHEN COMMA TERMINATES LINE>
;         EXP <ROUTINE TO SCAN FIELD>
;         EXP <INITIAL SET UP CALL>
;
;   IT RETURNS TO EOL, SO CALLING RTN NEVER REGAINS CONTROL.
;
;
MIOSCN:			;ENTRY FROM MAT I/O
  HLRZM T0,MTRDMF ;SAVE REDIM ALLOWED FLAG
  HRRZM T0,XNSBCS ;AND DEFAULT NUMBER OF SBSCS
;
;
 IOSCN:
  SETOM TEMPC ;SET FLAG
    MOVEM  T,TEMPA     ;SAVE CALLING ADDRESS
    MOVE   R2,0(T)     ;GETT DEFAULT RTN
    PUSHJ P,FILNO       ;SCAN IT
    JRST IOSCN8 ;HANDL IF NONE
    MOVE   T,TEMPA     ;RESTORE CALL POINTER
;
 ISCN9A:
    TLZ    FG,-1-NCHBT ;KEEP ONLY NCHBT
;
 IOSCN4:
    SETZM TEMPB ;CLEAR MAT DIM FLAG
    MOVE   T,TEMPA     ;RESTORE CALLING ADD
    PUSHJ P,@5(T)       ;CALL ROUTINE TO PICK UP NEXT FIELD
    MOVE   T,TEMPA     ;GET CALL ADDRESS
    AOSE TEMPC ;BUMP COUNT TO SEE IF FIRST TIME
    JRST ISCN4A ;NO--SKIP
;
  HLRZ R2,6(T) ;GET SET UP ROUTINE FOR NUMERIC
  TLNE FG,STRBT ;CHECK IF STRING
  HRRZ R2,6(T) ;IF SO, GET STRING SET UP
  SKIPE R2 ;SKIP IF WE HAVE TO SET UP
  PUSHJ P,SVCAL ;IF SO, SAVE CALL TO SET UP
;
 ISCN4A:
    TLNE   FG,NUMBT    ;CHECK IF NUMERIC
    JRST   IOSCN1      ;YES--HANDLE
    TLNE   FG,STRBT    ;CHEECK FOR STRING
    JRST   IOSCN2      ;YES--HANDLE
    ERR    E.INFT      ;NO AGAIN--ERROR
;
 IOSCN1:
    MOVE   T2,1(T)     ;NUMERIC--GET ROUTINE
    SKIPE TEMPB ;CHECK IF SPECIAL MAT ROUTINE NEEDED
    MOVSS T2 ;IF SO, GET ITS ENTRY (MATINPUT W/O DIMS)
    ANDI T2,-1 ;KEEP ONLY PROPER ROUTINE
    SKIPN  T2          ;SKIP IF LEGAL
    ERR    E.INFT      ;ELSE ERROR
;
 IOSCN3:
    PUSHJ P,DORSB1 ;GENERATE CALL
;
    CAIN   CH,ASC.LF   ;CHECK FOR LF TERM
    JRST   IOSCN5      ;HANDLE
    CAIE   CH,ASCCMA   ;CHECK FOR COMMA
    ERR    E.INFT      ;MUST BE
    JSP    T,NXECH     ;SKIP COMMA
    CAIN   CH,ASC.LF   ;CHECK FOR COMMA AT END OF LINE
    JRST   IOSCN6      ;HANDLE IF SO
    HRLZI  FG,NCHBT    ;ELSE USE CHAR
    JRST   IOSCN4      ;AND HANDLE NEXT FILED
;
 IOSCN2:
    MOVE   T2,2(T)     ;AHNDLE STRING ARGUMENT
    SKIPE TEMPB ;CHECK IF SPECIAL MAT RTN NEEDED
    MOVSS T2 ;IF SO, GET RTP ENTRY FOR IT
    ANDI T2,-1 ;MASK THE RESULT TO GET ONLY RTN
    JRST   IOSCN3      ;PROCESS
;
 IOSCN5:
    MOVE   T,TEMPA     ;RESTORE CALL ADD
    MOVE   R2,3(T)     ;GET END ROUTINE
;
 IOSCN7:
    SKIPL  R2          ;IF NONE, THEN IGNORE
    PUSHJ P,SVCAL     ;ELSE SAVE CALL TO END ROUTINE
    JRST   RTEOL         ;AND DONE
;
 IOSCN6:
    MOVE   T,TEMPA     ;GET CALL ADD
    MOVE   R2,4(T)     ;COMMA END--GET DONE, CONTINUE RTN
    JUMPN  R2,IOSCN7      ;IF VALID, HANDLE
    ERR    E.INFT      ;ELSE ERROR
;
 IOSCN8:
    SKIPGE 0(T)        ;CHECK FIRST ARG (DFT RTN)
    HRRZ T,0(T) ;DATA READ--GET PTR
    MOVEM T,TEMPA ;SAVE NEW PTR
    JRST   ISCN9A      ;AND CONTINUE
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--INPVAR
;
;   INPVAR--THIS ROUTINE IS THE FIELD SCANNING ROUTINE DESIGNATED TO
;      IOSCN FOR INPUT ITEMS.  BASICALLY IT IS A CALL TO ARSCVR, BUT
;      THE DIFFERENT RETURNS ARE MASKED.
;
;
 INPVAR:
    PUSHJ P,ARSCVR      ;SCAN A VARIABLE EXPRESSION
    NOP                ;IGNORE MAT ELEMENT RETURN
    POPJ P, ;AND RETURN
;
;
;
SUBTTL STATEMENT SUBROUTINES--SCANNING--MATSCN
;
;   MATSCN--THIS ROUTINE IS THE FIELD SCANNING ROUTINE USED
;      TO SCAN FIELDS FOR MAT I/O STATEMENTS.  THESE FIELDS
;      CONSIST OF A VARIABLE (MATRIX) NAME AND POSSIBLY A
;      SUBSCRIPT LIST FOR REDIMENSIONING.
;
;
MATSCN:
;
  MOVE VS,[IOWD 100,ARVST]	;SET UP VAR STACK
  SETZM SBCERF ;DON'T REALLY ENFORCE DIMS
;
  PUSHJ P,SVRNM ;SCAN A VARIABLE NAME
;
  HRRZ R2,T0 ;TO R2
  CAIL R2,32 ;CHECK IF SIMPLE NAME
  ERR E.INFT ;ERROR IF NOT
  TLO T0,VTMAT ;MAKE INTO MATRIX
;
  CAIE CH,ASCLPR ;CHECK FOR '('
  AOSA TEMPB ;SET FLAG AND SKIP
  SKIPE MTRDMF ;IS REDIM ALLOWED
  SKIPA ;WE'RE OKAY--SKIP
  ERR E.INFT ;INCORRECT FORMAT IF NOT OKAY
;
  PUSHJ P,DMMAT ;HANDLE OPTIONAL DIMENSIONS
  TLNE T0,VTNUM ;CHECK IF NUMERIC
    TLO FG,NUMBT ;MARK AS SUCH
  TLNE T0,VTSTR ;CHECK IF STRING
    TLO FG,STRBT ;MARK AS SUCH
  PUSH VS,T0 ;SAVE ITEM SCANNED ON STACK
  POPJ P, ;AND RETURN
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--SVRNM
;
;   SVRNM--THIS ROUTINE IS USED TO SCAN A VARIABLE, EITHER NUMERIC OR
;      STRING FROM THE INPT STREAM.  IT RETURNS THE VS STACK WORD
;      CONTAINING THE VARIABLE NUMBER IN T0 ON EXIT.
;
;   IT IS CALLED WITH A PUSHJ P,SVRNM.
;
;
 SVRNM:
    PUSHJ P,VARNM       ;SCAN VARIABLE NUMERIC
    CAIE   CH,ASCDOL   ;CHECK FOR '$' AT END
    POPJ P, ;NO--THEN DONE
    TLC    T0,VTSTR+VTNUM ;AND TYPE
    JSP    T,NXECH     ;IGNORE '$'
    POPJ P, ;AND THEN RETURN
;
;
;
  SUBTTL STATEMENT SUBROUTINES--SCANNING--VARNM
;
;   VARNM--THIS ROUTINE IS USED TO SCAN A NUMERIC VARIABLE.  IT RETURNS
;      THE VS STACK WORD FOR THE VARIABLE IN T0 ON EXIT.
;
;   IT IS CALLED WITH A PUSHJ P,VARNM.
;
;
 VARNM:
    TLON FG,NCHBT ;CHECK FOR EXTRA CHR SCANNED, MARK AS SO
    JSP    T,NXECH     ;CHECK NEXT CHARACTER
    CAIL CH,ASC..A ;FOR ALPHABETIC
    CAILE  CH,ASC..Z
    ERR    E.INFT      ;NOT FOUND--ERROR
    MOVEI  T0,-ASC..A(CH) ;GET NUMBER IN T0
    JSP    T,NXECH     ;CHECK NEXT CHARACTER
    CAIL   CH,ASC..0   ;CHECK FOR NUMBER
    CAILE  CH,ASC..9
    JRST   VARNM1      ;NO--THEN VARIABLE NAME SCANNED
    IMULI  T0,12       ;ELSE COMPUTE NEW NUMBER
    ADDI   T0,32-ASC..0(CH) ;FOR VARIALBE
    JSP    T,NXECH     ;GET NEXT CHARACTER
;
 VARNM1:
    CAIN CH,ASC..N ;CHECK FOR XN
    CAIE T0,5 ;CHECK FOR 'FN'
    SKIPA ;NO--SKIP
    JRST VARNM2 ;YES--HANDLE FUNCTION NAME
;
 VARNM3:
    HRLI   T0,VTNVR    ;VT BITS
    POPJ P, ;AND RETURN
;
 VARNM2:
  JSP T,NXECH ;'FN' FOUND--GET VAR NAME
  CAIL CH,ASC..A ;'A'
  CAILE CH,ASC..Z ;CHECK FOR LETTER
    ERR E.INFT ;NOT LETTER--ERROR
  MOVEI T0,-ASC..A+32+414(CH) ;--LETTER--GET FCT NUM
  JSP T,NXECH ;MUST SCAN EXTRA CHAR
  JRST VARNM3 ;AND DONE ALMOST
;
;
;
;
    PRINTX *****START OF BAS53*****
;
;
SUBTTL STATEMENT SUBROUTINES--ALCARS
;
;   ALCARS--THIS ROUTINE ALLOCATES SPACE FOR ARRAYS IN THE VARIABL
;      AREAS AND SETS UP THE DIM WORDS IN THE CONSTANT AREA.
;
;
ALCARS:
;
  MOVEI T0,1 ;FLAG TO SHOW NUMERIC/STRING
  MOVE T1,SADDN ;START WITH STRING
  MOVEI T3,63 ;INITIAL NUMBER
;
 ALCAR5:
  MOVEI T2,31 ;NUMBER OF ARRAYS
;
 ALCAR3:
  SKIPN T4,MATDTB(T3) ;CHECK IF MAT USED
  JRST ALCAR2 ;NO--LOOP
  MOVE T6,MATPTB(T3) ;YES--GET VADDN
  SKIPGE MATDTB(T3)	;CHECK IF MAT/VECTOR
  TLO T6,MTVCT		;SET ON BIT ACCORDINGLY
  MOVEM T6,MATPTB(T3)	;AND SAVE NEW BITS
  TLNE T6,MTGBL ;CHECK IF GLOBAL ARRAY
  JRST ALCAR2 ;IGNORE IT IF SO
  AOBJP T4,.+1 ;INCREMENT BOTH DIMS
  TLNN T4,-1 ;CHECK FOR 1-D
  JRST ALCAR6 ;HANDLE 1 D
;
  HLRZ T5,T4 ;GET LENGTH FROM 1ST DIM
  HRRZS T4 ;ISOLATE SECOND DIM
  IMUL T4,T5 ;MULTIPLY
;
 ALCAR6:
  MOVEI T6,1(T1) ;GET ADDRESS OF MAT
  XCT ALCROP(T0) ;SAVE IN SYMBOL TABLE
  ADD T1,T4 ;NEXT FREE SPACE IN AREA
;
 ALCAR2:
  SOS T3 ;NEXT MAT
  SOJGE T2,ALCAR3 ;JUMP BACK UNTIL DONE TYPE
  SOJL T0,ALCAR4 ;ELSE, CHECK IF DONE BTH STR AND NUM
  HRRZM T1,SADDN ;NO--SAVE STR PTR
  MOVE T1,VADDN ;GET NUM PTR
  JRST ALCAR5 ;AND REENTER LOOP
;
 ALCAR4:
  HRRZM T1,VADDN ;YES--DONE BOTH--SAVE NUM ADD
  POPJ P, ;AND RETURN
;
;
 ALCROP:
  HRRM T6,MSYMTB(T2) ;SAVE NUMERIC VALUE
  HRLM T6,MSYMTB(T2) ;SAVE STRING VALUE
SUBTTL STATEMENT SUBROUTINES--CLEAN
;
;   CLEAN--THIS ROUTINE IS CALLED AT THE END OF A PROGRAM
;      TO PRINT ERROR MESSAGES FOR ALL UNDEFINED LINE
;      NUMBERS AND USER FUNCTIONS.
;
;
CLEAN:
;
  PUSHJ P,CLNULN ;HJANDLE UNDEF LINE NUMS
;
  MOVEI T1,0 ;FUNCTION NUMBER
;
 CLEAN3:
  MOVE T2,FCIAD+UFCATB(T1) ;GET THIS FCT WORD
  TLNE T2,FCUSD ;CHECK IF USED
  TRNE T2,-1 ;AND UNDEFINED
  SKIPA ;IF OK, THEN SKIP
  PUSHJ P,ERUDFC ;ELSE UNDEFINED FUNCTION ERROR
  ADDI T1,2 ;NEXT FCT
  CAIGE T1,64+64 ;CHECK IF DONE
  JRST CLEAN3 ;LOOP IF NOT
;
  POPJ P, ;AND RETURN WHEN DONE
;
;
SUBTTL STATEMENT SUBROUTINES--CLNULN
;
;   CLNULN--THIS ROUTINE GOES THROUGH THE LIST OF UNDEFINED
;      LINE NUMBERS AND PRINTS THE ERROR MESSAGES FOR
;      EACH REF OF EACH LINE.
;
;
CLNULN:
;
  MOVE T6,ULNLS ;CHECK FOR UNDEFINED LINE NUMBERS
  JUMPE T6,CLNUL2 ;NONE--SKIP
;
 CLNUL1:
  PUSHJ P,ERUDLB ;ERROR FOR EACH UNDEFINED LINE NUMBER
  HRRZ T6,0(T6) ;GET NEXT LINK
  MOVEM T6,ULNLS ;SAVE AS CURRENT
  JUMPN T6,CLNUL1 ;AND LOOP IF MORE
;
;
 CLNUL2:
  POPJ P, ;AND RETURN
;
;
SUBTTL STATEMENT SUBROUTINES--CLRP
;
;   CLRP--THIS ROUTINE IS USED TO CLEAR THE P STACK LOOPING
;      FOR A CERTAIN FLAG
;
;
CLRP:
;
  POP P,T ;GET RETURN
;
 CLRP1:
  CAMN T7,0(P) ;CHECK FOR MATCH OF FLAG
  JRST 1(T) ;RETURN SUCCESS IF SO
;
  HLRE R2,0(P) ;ELSE GET TYPE OF MARKER ON STACK
  JUMPG R2,CLRP2 ;MISC--IGNORE
  MOVNS R2 ;MAKE POSITIVE
  CAIG R2,4 ;MUST BE 0,1,2,3,4
  CAIG R2,0
    JRST CLRP2 ;IGNORE IF NOT
  JRST .+1-1(R2) ;BRANCH BY TYPE
;
    JRST CLFOR ;1--FOR LOOP WITHOUT NEXT
    JRST CLFCT ;2--DEF WITHOUT FNEND
    JRST 0(T) ;3--SUB--DONE FAIL
    JRST 0(T) ;4--MAIN--DONE FAIL
    BLOWUP   ;5--END OF PDL--BAD ERROR
;
;
 CLRP2:
  POP P,R2 ;IGNORE POSITIVE NUMBERS ON STACK
  JRST CLRP1 ;AND TRY AGAIN
;
;
;   CLFOR--FOR WITHOUT NEXT--POP AND PRINT ERROR
;
 CLFOR:
  POP P,R2 ;HEADER
  POP P,R2 ;SYMBOL NUMBER
  POP P,R2 ;LINK
  POP P,R2 ;GET LINE NUMBER FOR ERROR
  PUSH P,LSTLN ;SAVE LAST LINE
  MOVEM R2,LSTLN ;SAVE ERROR LINE AS CURRENT
  ERR E.FWON ;PRINT MESSAGE
  POP P,LSTLN ;RESTORE CURRENT LINE
  JRST CLRP1 ;AND DONE
;
;
;   CLFCT--DEF WITHOUT FNEND--POP AND PRINT ERROR
;
 CLFCT:
  POP P,XLNNO ;LINE NUMBER
  POP P,ULNLS ;UNDEF LINE NUM LIST
  POP P,R2 ;NAME
  POP  P,R2 ;OLD STACK PTR
  MOVE P,R2 ;SKIP ARGS
  POP P,R2 ;-1 MARKER
  POP P,R2 ;<OBJAD>
  ERR E.NFNE ;PRINT ERROR MESSAGE
  JRST CLRP1 ;AND CONTINUE
;
;
SUBTTL STATMENT SUBROUTINES--CKRG
;
;   CKRG--THIS ROUTINE IS CALLED WHEN A REGISTER IS
;      TO BE USED FOR AN EXTENDED PERIOD AND REGISTER
;      0 IS NOT ALLOWED (IE SBSC, FOR).  IT MOVES REG 0
;      TO ANOTHER REG IS NECESSARY AND, IN THAT CASE RETURNS
;      T0O CALL+1.  IF ALL IS OK, IT RETURNS TO CALL+2.
;
;
CKRG:
  JUMPN T1,CKRG1 ;CHECK IF REG 0 BEING USED
  GTREG (T1) ;YES--GET ANOTHER REG
  MOVSI R2,(MOVEM R0,) ;CODE TO SWAP REGS
  HRR R2,T1 ;INTO NEW REG
  SAVWD ;SAVE CODE
  MOVSI R1,400000 ;BIT FOR REG 0
  IORM R1,REGFGS ;RELEASE IT
  POPJ P, ;AND RETIURN
;
 CKRG1:
  AOS 0(P) ;REGISTER OK AS IS
  POPJ P, ;RETURN +1
;
;
SUBTTL STATEMENT SUBROUTINES--DFCSTR
;
;   DFCSTR--THIS ROUTINE DOES SOMETHING FOR EACH STRING
;      ARGUMENT OF A USER FUNCTION..  IT RETURNS TO CALL
;      BUT EAC|H TIME A STR ARG IS FOUND PUSHJ'S TO CALL+1.
;
;
DFCSTR:
;
  MOVE T5,FCIDWD+UFCATB(T6) ;GET FC IDWD
  HRRZI T4,-1 ;OFFSET IN T4
;
 DFSTR4:
  TLZ T5,774000 ;IGNORE COUNT
  JUMPE T5,DFSTR2 ;DONE--NO MORE STR ARGS
  TLNN T5,002000 ;THIS ARG IS STRING?
  JRST DFSTR3 ;NO--SKIP
  MOVE R2,0(P) ;GET CALLING ADDRESS
  PUSHJ P,1(R2) ;YES--HANDLE
;
 DFSTR3:
  LSH T5,1 ;POSITION FOR NEXT ARG
  SOJA T4,DFSTR4 ;AND LOOP FOR IT
;
 DFSTR2:
  POPJ P, ;RETURN WHENI DONE
;
;
SUBTTL STATEMENT SUBROUTINE--GRFIX
;
;   GRFIX--THIS ROUTINE GENERATES CODE TO FIX THE QUANTITY
;      WHOSE REG IS IN R2 LOWER ON ENTRY AT RUN TIME.
;
;
GRFIX:
;
  IFN KI10,<
    PUSH VS,R2 ;DUMMY ITEM TO STACK
    MKLOD (T7) ;MAKE SURE ITS LOADABLE
    MOVE T6,T7		;DUPLICATE WORD
    TLNE T6,VTREG	;CHECK IF REG
    TRNN T6,777776	;AND NOT 0 OR 1
    SKIPA		;SKIP IF WE NEED NEW REG
      JRST GRFIX1	;CAN USE SAME REG
    GTREG (T6) ;GET A REGISTER FOR IT
;
   GRFIX1:
    GTADD (T7) ;GET ITS ADDRESS
    PUSH P,T6 ;DUPLICATE ADDRESS
    LSH T6,4+1 ;SHIFT TO REG FIELD
    TLO R2,122000(T6) ;CONSTRUCT FIX W/ LOAD
    PUSHJ P,SVREL ;SAVE IT
    CAMN T7,0(P)	;CHECK IF USING SAME REG
    JRST GRFIX2		;SKIP IF SO
    RLREG (T7)		;ELSE RELEASE THE OLD ITEM
;
   GRFIX2:
    POP P,R2		;GET RESULT IN R2
    POPJ P, ;AND DONE
  >
;
;
  IFE KI10,<
    PUSH VS,R2 ;SAVE THE ITEM
    PUSHJ P,GTLOD ;LOAD TO REG
    MOVE T7,0(VS) ;PICK IT UP
    LSH T7,22+4+1 ;GET REG FIELD VALUE
    MOVE R2,T7 ;TO R2
    ADD R2,[FADRI 0,233400] ;CONSTRUCT FIRST WORD
    SAVWD ;SAVE IT
    MOVE R2,T7 ;GET REG
    ADD R2,[SUB 0,R.FIX] ;CONSTRUCT SECOND WORD
    SVWEX ;SAVE IT
    POP VS,R2 ;AND RESTORE THE ITEM
  >
;
;
SUBTTL STATEMENT SUBROUTINES--GTPGDT
;
;   GTPGDT--THIS ROUTINE SETS UP THE PROGRAM DATA AREA AND
;      PUTS THE CONST AREA LOC OF IT IN PGDATA.
;
;
GTPGDT:
;
  MOVEI T0,0 ;ASSUME NO FILES USED
  SKIPE FILUSD ;CHECK THAT
  MOVEI T0,R.NFLS ;FILES USED--SAVE SPACE FOR THEM
;
  AOS T1,VADDN ;START PTR TO FILE AREA
  ADDM T0,VADDN ;SAVE SPACE FOR MORE FILES
;
  HRLZ R2,VADDN ;GET VAR AREA PTR
  MOVEI R1,2 ;TYPE OFFSET OF NVR
  SKIPE PRGNM ;UNLESS SUB
  MOVEI R1,0 ;THEN ABS ZERO IN LOWER
  XSVCON (R2) ;SAVE THAT WORD AS FIRST OF PGDATA AREA
  MOVEM R2,PGDATA ;SAVE ITS LOC
;
  HRLZ R2,SADDN ;GET LEN OF SVR AREA
  MOVEI R1,3 ;ALSO PTR TO START OF AREA IF MAIN
  SKIPE PRGNM ;CHECK TAHT
  MOVEI R1,0 ;ABS ZERO IF SUB
  XSVCON (R2) ;SAVE LENGTH/VAL
;
  HRL R2,T0 ;GET LENGTH OF FILE ARE
  HRRI R2,0(T1) ;AND PTR TO IT
  SVCON ;SAVE IN CONSTANT AREA
;
  MOVEI R1,4 ;OFFSET OF CONST
  SKIPN R2,NDATP+1 ;FOR NUM DATA PTR
  MOVEI R1,0 ;UNLESS ZERO--THEN ABS
  XSVCON ;SAVE
;
  MOVEI R1,4 ;OFFSET OF CONST
  SKIPN R2,SDATP+1 ;FOR STRING DATA
  MOVEI R1,0 ;UNLESS NONE--THEN ABS
  XSVCON ;SAVE
;
  SETZB R2,T0 ;CLEAR REGS FOR SUB NAME
  SKIPN R1,PRGNM ;CHECK IF MAIN PROGRAM
  JRST .+3 ;IF SO, SKIP
  MOVE R2,SUBNAM(R1) ;IF SUB, GET NAME
  MOVE T0,SUBNAM+1(R1) ;IN TWO REGS
  SVCON ;SAVE FIRST WORD OF NAME
  MOVE R2,T0 ;GET SECOND WORD
  SVCON ;AND SAVE IT TOO
;
  SKIPE R2,PRGNM ;CHECK IF MAIN PROGRAM
    LDB R2,[POINT 8,SUBARG(R2),7] ;IF NOT, GET # ARGS
  SKIPE R2		;CHECK IF THERE ARE ANY ARGS
    SOS R2		;IF SO, DECREMENT COUNT FIRST
  MOVN R1,R2 ;GET MINUS NUMBER ARGS
  HRL R2,R1 ;TO UPPER HALF
  SVCON ;SAVE THIS NUMBER ARGS WORD
;
  MOVEI R2,1 ;PLEN
  SVCON ;SAVE
  MOVEI R2,1 ;CLEN
  SVCON ;SAVE
  MOVEI R2,1 ;LINK
  SVCON ;SAVE
  MOVSI R2,1		;PROGRAM BASE
  MOVEI R1,1		;RELOCATE FOR PRGORAM
  XSVCON		;SAVE
;
;
  POPJ P, ;AND RETURN
;
;
SUBTTL STATEMENT SUBROTUINES--MAKMAT
;
;   MAKMAT--THIS ROUTINE IS USED TO MAKE A VARIABLE INTO A MAT
;      AND TO CALL ALMAT TO PREALLOCATE SPACE (PSEUDO SPACE) 
;      FOR IT.
;
;
MAKMAT:
;
  HRRZ R2,T0 ;GET VAR NUMBER FROM PTR IN T0
  CAIL R2,32 ;CHECK IF LEGAL FOR MAT
  ERR E.ILMT ;IF NOT, THEN ERROR
  TLO T0,VTMAT ;MARK AS MATRIX
  PUSHJ P,ALMAT ;ALLOCATE IT
;
  MOVEI R1,1 ;ASSUME 1-D
  SKIPL MATDTB(T0) ;CHECK THAT
  MOVEI R1,2 ;ELSE RETURN 2-D
;
  POPJ P, ;RETURN, NEW MAT PTR IN T0, DIM IN R1
;
;
  SUBTTL STATEMENT SUBROUTINES--OPGEN
;
;   OPGEN--THIS ROUTINE IS USED TO GENERATE A WORD OF CODE.  THE OPERATOR
;      TO BE USED IS LOCATED AT 0(T).  THE REGISTER WORD (FOR USE) IS
;      IN 1(T) AND THE ADDRESS WORD, WHICH IS THE ACTUAL ADDRESS TO BE
;      USED (WITH THE SIGN BIT AS THE RELOCATABLE FLAG), IS IN 2(T).
;
;   IT IS CALLED WITH:
;         JSA T,OPGEN
;         <OP>
;         EXP <REGISTER WORD ADDRESS>
;         EXP <ADDRESS WORD ADDRESS>
;
;
 OPGEN:
    POP P,T ;GET RETURN
    MOVE   R2,@2(T)    ;GET ADDRESS
    LDB R1,[POINT 6,R2,5] ;GET ADD TYPE
    TLZ R2,777740 ;CLEAR EXCESS BITS
    ADD    R2,0(T)     ;ANYWAY, NOT RELOC--ADD OP
    ADD    R2,@1(T)    ;AND REGISTER WORD
;
    PUSHJ P,SVREL ;AND SAVE THE RESULT
    JRST 3(T) ;AND RETURN
;
;
;
SUBTTL STATEMENT SUBROUTINES--PRPMAT
;
;   PRPMAT--THIS ROTUINE GENERATES CODE FOR THE END OF START
;      UP TO PUT ABSOLUTE ADDRESSES INTO THE MAT PTR WORDS IN
;      THE CONSTANT AREA.
;
;
PRPMAT:
;
  MOVEI T0,0 ;COUNT AND REL PTR
;
 PRPMT1:
  SKIPN MATDTB(T0) ;CHECK IF THIS MAT USED
    JRST PRPMT5 ;NO--GO ON TO NEXT
  MOVE R2,MATPTB(T0) ;YES--GET PTR
  TLNE R2,MTGBL ;CHECK IF GLOBAL
    JRST PRPMT5 ;IGNORE IF SO
;
  HRR R2,MATDTB(T0) ;GET FIRST DIM
  ADDI R2,1		;PLUS ONE
  HRLI R2,(MOVEI 0,) ;CODE TO LOAD IT
  SAVWD ;SAVE
  HRRZ R2,MATPTB(T0) ;MAT LOC
  ADD R2,[MOVEM 0,1] ;SAVE IT AS WELL
  SVWNM ;IN MAT HDR
;
  HLRE R2,MATDTB(T0) ;GET SECOND DIM
  SKIPL R2		;CHECK FOR VECTOR
    ADDI R2,1		;IF MAT, ADD ONE
  HRLI R2,(MOVEI 0,) ;CODE TO LOAD IT
  SAVWD ;SAVE
  HRRZ R2,MATPTB(T0) ;MAT LOC
  ADD R2,[HRREM 0,2] ;CODE TO SAVE IN MAT HDR
  SVWNM ;SAVE
;
  HRRZ R2,T0 ;GET MAT NUMBER
  CAILE T0,31 ;CHECK FOR NUM/STR
    TRO R2,400000 ;MARK AS STRING
  HRLI R2,(MOVEI 0,) ;CODE TO PNT TO MAT
  SVWMT ;SAVE IT
  HRRZ R2,MATDTB(T0) ;GET SECOND DIM
  ADDI R2,1 ;PLUS ONE
  HLRE R1,MATDTB(T0) ;GET FIRST DIM
  AOSE R1 ;PLUS ONE, CHECK FOR VECTOR
    IMUL R2,R1 ;MAT--GET TOTAL SIZE
  HRLI R2,(HRLI 0,) ;CODE TO LOAD SIZE
  SAVWD ;SAVE
  HRRZ R2,MATPTB(T0) ;GET MAT PTR
  HRLI R2,(MOVEM 0,) ;CODE TO SAVE HDR WORD
  SVWNM ;SAVE IT
;
 PRPMT5:
  AOS T0 ;ENEXT MAT
  CAIG T0,63 ;DONE?
    JRST PRPMT1 ;NO--TRY SOME MORE
  POPJ P, ;YES--RETURN
;
;
SUBTTL STATEMENT SUBROUTINES--SVRGS
;
;   SVRGS--THIS ROUTINE IS USED TO SAVE/RESTORE THE USED
;      REGISTERS AS INDICATED BY REGUSD BITS.  IT IS CALLED
;      WITH:
;
;        JSA T,SVRGS
;          XWD REG-BIT,REG-NUMER
;          PUSH P,   OR   POP P,
;          LSH +/- 1
;          SOS/AOS T2
;
;
SVRGS:
;
  POP P,T ;RESTORE RETURN
  MOVE T0,REGUSD ;GET REGS USED
  TLZ T0,600003 ;DON'T SAVE 0,1 OR 17
  TLO T0,000000 ;ALWAYS SAVE 13,14
;
  SETZM TEMPA ;NUMBER SAVED
  HLLZ T1,0(T) ;GET FIRST REG BIT
  HRRZ T2,0(T) ;AND NUMBER
;
 SVRG2:
  TDZN T0,T1 ;CLEAR USED, CHECK IF USED
  JRST SVRG1 ;NOT USED--LOOK AT NEXT
;
  MOVE R2,1(T) ;GET OP TO SAVE/LOAD
  ADD R2,T2 ;PLUS REG NUMBER
  SAVWD ;SAVE THE INST
  AOS TEMPA ;BUMP SAVED COUNT
;
 SVRG1:
  XCT 2(T) ;LSH T1+/-1
  XCT 3(T) ;SOS/AOS T2
  JUMPN T0,SVRG2 ;JUMP BACK IF MORE TO SAVE
;
  JRST 4(T) ;ELSE RETURN
;
;
SUBTTL STATEMENT SUBROUTINS--SVRTGT
;
;   SVRTGT--THIS ROUTINE GENERATES CODE TO OPEN AND GET THE
;      RUN TIME PACKAGE.  IT IS PART OF MAIN PROGRAM INITIALIZATION.
;
;
SVRTGT:
;
  MOVE T0,[POINT 36,RTGTCD]	;POINT TO CODE
  MOVE T1,[POINT 1,RTGTRL]	;POINT TO RELOCATION VALUES FOR CODE
  MOVEI T2,RTGTLN		;LENGTH OF AREA
;
 SVRT3:
  ILDB R2,T0		;GET NEXT WORD
  ILDB R1,T1		;AND RELOC
  JUMPE R1,SVRT1	;HANDLE ABS
  HRRE R1,R2		;GET ADDRESS GIVEN
  ADD R1,OBJPT		;GET REAL ADDRESS
  HRR R2,R1		;AND MOVE BACK
  SVWPR			;AND SAVE AS PROGRAM REF
  JRST SVRT2		;AND THEN SKIP
;
 SVRT1:
  SAVWD			;SAVE ABSOLUTE WORD
;
 SVRT2:
  SOJG T2,SVRT3		;LOOP IF MORE
  POPJ P,		;AND RETURN WHEN DONE
;
;
;  THIS IS THE CODE WE ARE INSERTING
;
RTGTCD:
  SKIPE RTPOK		;CHECK IF RTP THERE
  JRST 21		;YES--SKIP
  HRLZI R1,100001	;BITS FOR GET
  HRROI R2,13		;PTR TO FILE
  GTJFN			;GET THE FILE
    BLOWUP
  HRLI R1,400000	;TO CURRENT FORK
  GET			;GET RTP
  MOVEI R1,400000	;CURRENT FORK
  MOVEI R2,-11		;STARTING LOC
  HRLI R2,1		;LENGTH OF ENTRY VECTOR
  SEVEC			;RESET ENTRY VECTOR
  SETOM RTPOK		;INDICATE THERE
  JRST 5		;AND SKIP
  ASCII /<SYSSUP>BRTP.SAV/ ;FILE
;
RTGTLN== .-RTGTCD
;
;
;   THIS IS THE RELOCATION BITS FOR THE CODE
;
RTGTRL:
  BYTE (1)0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0
;
;
  SUBTTL STATEMENT SUBROUTINES--SVTMP
;
;   SVTMP--THIS ROUTINE IS USED TO SAVE A NUMBER IN REGISTER IN A WORD
;      OF CORE.  THE CORE WORD USED IS A PERMANENT TEMPORARY, IE IS NOT
;      RELEASEABLE.  IT IS USED PRIMARILY BY FOR-LOOPS FOR LIMIT AND
;      STEP VALUES.
;
;   IT IS CALLED WITH PUSHJ P,SVTMP WITH THE REG VALUE IN R2 AND RETURNS
;      THE NEW ADDRESS IN R2
;
;
 SVTMP:
    AOS T7,VADDN ;GET ADDRESS OF WHERE TO SAVE
    LSH    R2,22+4+1   ;GET REG IN REG FIELD
    TLO R2,(MOVEM) ;CONSTRUCT MOVEM RG,<TEMP>
    ADD    R2,T7       ;ADDRESS
    SVWNM              ;SVE IT
  PUSH P,T7 ;SAVE T7
  RLREG (T1) ;RELEASE THE REG
  POP P,T7 ;RESTORE T7
    HRRZ   R2,T7       ;GET ADDRESS OF RESULT
    POPJ P,      ;AND RETURN
;
;
SUBTTL STATEMENT SUBROUTINES--XDMMAT
;
;   XDMMAT--THIS ROUTINE IS CALLED WITH A MATRIX PTR IN T0 AND
;      THE NUMBER OF ARGS FOR REDIMMING IN T1.  THE ARGS
;      THEMSELVES ARE ON THE VS STACK.  THIS ROTUINE
;      GENERATES THE APPROPRIATE RTP CALLS FOR REDIMMING.
;
;
XDMMAT:
;
  JUMPE T1,MAKMAT ;IF NOT DIMS, JUST MAKE MAT
  MOVEM T1,XNSBCS ;ELSE SAVE NUMBER OF DIMS
  SETOM SBCERF ;ENFORCE THIS H'UMBER OF DIMS
  PUSHJ P,MAKMAT ;MAKE MAT PTR INTO MAT
;
;
 YDMMAT:
  PUSH P,T0 ;SAVE MAT PTR
  PUSH VS,T0 ;ON STACK AND ON VS
;
  HRRI FG,CLTEXT+1(T1) ;EXTERNAL CALL OF N+1 ARGS
  CAIE T1,1 ;CHECK IF 1-D
  JRST XDMMT2 ;HANDLE 2-D
  MOVEI T2,R.RDM1 ;RTN FOR 1-D REDIM
  PUSHJ P,GCALL ;GENERATE CALL
  JRST XDMMT3 ;AND SKIP
;
 XDMMT2:
  MOVEI T2,R.RDM2 ;RTN FOR 2-D REDIM
  PUSHJ P,GCALL ;GEN CALL FOR 2-D REDIM
;
 XDMMT3:
  POP P,T0 ;RESTORE MAT PTR
;
  POPJ P, ;AND RETURN
;
;
;
;
;
    PRINTX *****START OF BAS54*****
;
;
SUBTTL SUB SUBROUTINES--ALSBVR
;
;   ALSBVR--THIS ROUTINE ALLOCATES SPACE FOR A SUB VARIABLE
;      AFTER IT IS RETURNED FROM THE ARITHMETIC SCAN.  THE
;      VARIABLE WORD IS IN T0.
;
;
ALSBVR:
;
  TLNE T0,VTMAT ;CHECK IF MATRIX
    JRST ALSBV1 ;HANDLE MATRIX
  TLNE T0,VTFC0 ;CHECK IF FCT
    JRST ALSBV2 ;HANDLE FCT
  TLNE T0,VTFIL ;CHECK IF FILE
    JRST ALSBV4 ;HANDLE FILES
  TLNE T0,VTSTR ;ELSE VARIABLE--CHECK FOR STRING
    JRST ALSBV3 ;HANDLE STRING
;
;   NUMERIC VARIABLE
;
  MOVEI R2,VRGBL ;BIT TO MAKE GLOBAL
  XORB R2,SYMTAB(T0) ;SET OP
  TRNN R2,VRGBL		;CHECK IF WE MADE IT GLOBAL
    ERR E.VDTW		;IF NOT, THEN WAS--ERROR
  POPJ P, ;AND RETURN
;
;   STRING VARIABLE
;
 ALSBV3:
  SOSE SADDN ;DEALLOCATE IT
    ERR E.VDTW		;A CONVENIENT WAY TO SEE IF DEFINED TWICE
  AOS R2,VADDN ;ALLOCATE AS NUMERIC SPACE
  TRO R2,VRGBL ;MAKE GLOBAL TOO
  HRLM R2,SYMTAB(T0) ;SAVE IN SYMBOL TABLE
  POPJ P, ;AND RETURN
;
;   FUNCTION
;
 ALSBV2:
  AOS NUMFCT ;ONE MORE FUNCTION
  MOVE R2,OBJPT ;GET CURRENT PTR
  ADD R2,[JRST 5] ;GENERATE JUMP OVER NEW CODE
  SVWPR ;SAVEIT
  MOVEI R2,0		;SAVE SPACE FOR ID WORD
  SAVWD			;SAVE SAVED SPACE
  AOS R2,VADDN		;ALLOCATE VARIABLE SPACE FOR NAME
  HRLI R2,(MOVE 1,)	;GENERATE CODE TO LOAD PTR TO FCT
  SVWNM			;AND SAVE IT
  MOVE R2,[HRRO R.V,CALLV.(R.V)] ;CODE TO RELOAD V
  SAVWD ;SAVE IT
  MOVSI R2,(JRST 0(1)) ;USE IT FOR JUMPING THRU
  SAVWD ;SAVE JUMP
  MOVE R2,OBJPT ;GET CURRENT PTR
  SUBI R2,3 ;GET PTR TO CODE WE GENERATED
  TLO R2,FCGBL ;MARK AS GLOBAL
  EXCH R2,FCIAD(T0) ;SAVE FOR FUNCTION DEF
  TLNE R2,FCGBL		;CHECK IF PREVIOUSLY GLOBAL
    ERR E.FDTW		;IF SO, THEN ERROR
  POPJ P, ;AND DONE
;
;   MATRIX
;
 ALSBV1:
  MOVSI R2,MTGBL ;MARK AS GLOBAL
  XORB R2,MATPTB(T0) ;SAVE BIT
  TLNN R2,MTGBL		;CHECK IF GLOBAL BEFORE
    ERR E.MDTW		;ERROR IF SO
  MOVNI R2,2 ;ONLY ONE LOC USED, NOT 3
  ADDM R2,VADDN ;SO DEALLOCATE SOME SPACE
  POPJ P, ;AND RETURN
;
;   FILES
;
 ALSBV4:
  AOS R2,VADDN ;GET SPACE ALLOCATED TO FILE
  HRLI R2,(MOVE 0,@0) ;CODE TO LOAD FCT VAL
  SVWNM ;SAVE IT
  HRRZ R2,T0 ;GET FILE NUMBER
  HRLI R2,(HRLI 0,) ;CODE TO LOAD IT TOO
  SAVWD ;SAVE
  MOVEI R2,R.PCFL ;RTN TO HANDLE SET UP
  PUSHJ P,SVCAL ;SAVE CALL TO IT
  HRRZ R2,T0	;GET NUMBER OF FILE
  MOVEI R1,20-1		;PTR TO TABLE OF FILE NUMBERS USED
  SKIPE SBFLTB(T1)	;CHECK FOR EMPTY ENTRY
  CAMN R2,SBFLTB(R1)	;OR MATCHING ONE
    JRST .+4		;HANDLE FOUND
  SOJGE R1,.-3		;LOOP IF MORE
  MOVEI R1,0		;GET GOOD PTR
  ERR E.TMFS		;AND GIVE ERROR MESSAGE IF TOO MANY
;
  EXCH R2,SBFLTB(R1)	;SAVE NEW NUMBER
  SKIPE R2		;MAKE SURE WE DIDN'T FIND DUPLICATE
    ERR E.FLDT		;ERROR IF DUPLICATE
;
  POPJ P, ;THEN DONE
;
;
SUBTTL SUB SUBROUTINES--ASBMTS
;
;   ASBMTS--ALLOCATE MATRICES FOR SUB STATEMENT.  THIS RTN GENERATES
;      CODE TO SET UP FOR GLOBAL MATRICES.
;
;
ASBMTS:
;
  MOVEI T0,63 ;NUMBER OF MATS
;
 ASBMT3:
  MOVE R2,MATPTB(T0) ;GET NEXT MAT
  TLNN R2,MTGBL ;CHECK IF GLOBAL
    JRST ASBMT1 ;NO--SKIP IT
;
  HRLI R2,(MOVE 0,) ;CODE TO LOAD PTR FROM PASS LOC
  SVWNM ;SAVE
  AOS R2,VADDN ;ALLOCATE SPACE FOR NEW MAT BLOCK
  HRRM R2,MATPTB(T0) ;SAVE PTR TO SPACE
  MOVEI T1,2 ;COUNTER
;
 ASBMT2:
  HRLI R2,(MOVEM 0,) ;CODE TO SAVE NEXT PTR
  SVWNM ;SAVE
  JUMPE T1,ASBMT1 ;CHECK IF DONE, SKIP IF SO
  MOVSI R2,(AOS 0) ;ELSE GEN CODE TO BUMP PTR
  SAVWD ;SAVE
  AOS R2,VADDN ;GET NEW ADDRESS
  SOJA T1,ASBMT2 ;AND LOOP
;
 ASBMT1:
  SOJGE T0,ASBMT3 ;JUMP BACK IF MORE MATS TO LOOK AT
  POPJ P, ;RETURN IF NOT
;
;
SUBTTL SUB SUBROUTINES--CALCON
;
;   CALCON--THIS ROUTINE HANDELS CONSTANTS IN A CALL STATEMENT.  IT
;      CAUSES THEM TO BE LOADED AND SAVED IN A TEMP.  THE INITAL
;      POINTER IS IN R2 ON ENTRY AND THE NEW POINTER IS LEFT IN R2
;      ON EXIT.
;
;
CALCON:
;
  PUSH P,R2		;STACK THE PTR
  LOAD (R2)		;GET THE ITEM INTO A REG
  POP P,R1		;RESTORE CONST PTR
  TLZ R2,VTSTR+VTNUM	;DELETE TYPE OF NEW ITEM
  TLO R2,VTNUM		;GUESS NUMBER
  TLNE R1,VTSTR		;CHECK IF STRING
    TLO R2,VTSTR	;MARK AS STRING
  POPJ P,		;AND RETURN IT
;
;
SUBTTL SUB SUBROUTINES--CALFCT
;
;   CALFCT--THIS ROUTINE IS ENETERED WITH A FUNCTION REFERENCE IN R2 FOR
;      PASSING ON A CALL.  IT SHOULD CHECK TO SEE IF ANY SPECIAL CODE IS
;      NECESSARY TO MATCH UP THE FUNCTION'S CALLING SEQUEENCE WITH THAT
;      OF A STANDARD INTERNAL FUNCTION.
;
;
CALFCT:
;
  HRRZ R1,R2		;GET LOC OF FCT TABLE
  CAIL R1,UFCATB	;CHECK IF USER FCT
    POPJ P,		;IT IS--RETURN OK
  MOVE R1,FCNAM(R2)	;ELSE CHECK NAME
  TLNE R1,CLBPJ		;FOR PUSHJ ENTRY
    POPJ P,		;IT IS--RETURN OK
;
  MOVE R1,FCIDWD(R2)	;ELSE GET ID WORD
  LSH R1,-44+6		;TO GET NUMBER OF ARGS
  PUSH P,OBJPT		;SAVE CURRENT OBJECT PTR
  SOS R1		;MINUS ONE FROM NUMBER TO GET ACTUAL #ARGS
  PUSH P,R1		;SAVE NUMBER ARGS
  MOVE T0,R2		;DUPLICATE OLD FCT WORD
  MOVSI R2,(JRST)	;GENERATE JUMP AROUND US
  HRRI R2,5(R1)		;ADDRESS
  ADD R2,OBJPT		;PLUS CURRENT LOC
  SVWPR			;SAVE AS PROGRAM REF
;
  MOVE R2,FCIDWD(T0)	;GET ID WORD
  SAVWD			;SAVE IT
  MOVEI R2,FCNAM(T0)	;GET NAME
  PUSHJ P,SVCAL		;SAVE CALL TO IT
  MOVN R2,0(P)		;GET NEG NUMBER ARGS
  JUMPE R2,CLFCT1	;SKIP IF NONE
  HRLI R2,(JUMP 0(P))	;GET IN R2 A FULL PTR TO FIRST ARG
  PUSH P,R2		;AND SAVE
;
 CLFCT2:
  SAVWD			;SAVE PTR TO NEXT ARG
  AOS R2,0(P)		;NEXT PTR
  TRNE R2,-1		;CHECK IF DONE
    JRST CLFCT2		;IF NOT, LOOP FOR MORE
;
  POP P,R2		;GET ARG PTR OFF STACK
;
 CLFCT1:
  AOS R2,0(P)		;NUMBER ARGS PLUS ONE
  HRLS R2		;IN BOTH HALVES
  DSVCON (R2)		;SAVE AS CONSTANT
  HRLI R2,(SUB P,)	;CREATE INST TO RESTORE PDL
  SVWCN			;SAVE IT
  POP P,R2		;GET NUMBER ARGS + 1
  HRLI R2,(JRST @0(P))	;GENERATE RETURNING CODE
  SAVWD			;AND SAVE
  POP P,R2		;GET OBJPT
  ADDI R2,2		;PLUS TWO
  HLL R2,T0		;TYPE BITS FOR FCT
  TLC R2,VTFC0+VTFCT	;MARK AS KLUDGED
  POPJ P,		;AND RETURN
;
;
SUBTTL SUB SUBROUTINES--CHKSUB
;
;   CHKSUB--THIS ROUTINE IS CALLED AT THE VERY END TO MAKE
;      SURE THAT ALL SUBS THAT ARE NEEDED ARE LOADED.  IT
;      PRINTS ERROR MESSAGES FOR ALL MISSING SUBS.
;
;
CHKSUB:
;
  SKIPN T0,NSUBS ;GET NUMBER OF SUBS
  POPJ P, ;NONE--RETURN
;
  MOVEI T1,SUBTBL ;GET PTR TO SUB TABLE
;
 CKSB2:
  MOVE R2,SUBBTS(T1) ;GET BITS FOR NEXT SUB
  TLNE R2,SBBDEF ;CHECK IF DEFINED
    JRST CKSB1 ;SKIPF IF SO
  MOVE R1,SUBNAM(T1) ;ELSE GET NAME
  MOVEM R1,ERBUF ;SAVE FOR ERROR MESSAGE
  MOVE R1,SUBNAM+1(T1) ;FULL NAME
  MOVEM R1,ERBUF+1
  ERR E.SUDF ;GIVE MESSAGE
;
 CKSB1:
  ADDI T1,SUBBLN ;ON TO NEXT SUB
  SOJG T0,CKSB2 ;IF THERE ARE MORE
  POPJ P, ;RETURN IF NOT
;
;
SUBTTL SUB SUBROUTINES--CKSBTY
;
;   CKSBTY--THIS ROUTINE CHECKS THE TYPE OF THE SUBROUTINE IN
;      TERMS OF ITS ARGUMENTS.  IT ASSUMES THAT THE ARGS GIVEN
;      CURRENTLY ARE CODED INTO 'CSBARG' AND COMPARES THEM
;      TO THE CURRENT SUB.  IF THIS IS THE FIRST SET OF ARGS
;      FOR THAT SUB, THEN THE SUB ARGS ARE SET.
;
;
CKSBTY:
;
  MOVE T7,CRSUB ;GET CURRENT SUB
  MOVE R2,NSBARG ;GET NUMBER ARGS PLUS ONE
  ADDI R2,1 ;PLUS ONE
  LSH R2,44-10 ;POSITION FOR CSBARG WORD
  ORM R2,CSBARG ;AND SAVE
;
 XCSBTY:		;CHECK TYPE WITH COMPLETED ARG WDS ENTRY
;
  SKIPN R2,SUBARG(T7) ;CHECK IF SUB ARGS DEFINED
  JRST CKSTY1 ;HANDLE IF NOT
;
  MOVEI R1,0 ;IF SO, GET WORD COUNTER
;
 CKSTY3:
  SKIPN T6,CSBARG(R1) ;MORE TO DO
  JRST CKSTY2 ;NO--DONE OK
  CAME T6,SUBARG(T7) ;YES--COMPARE WORDS
    ERR E.SBTY ;MUST MATCH
  AOS T7 ;NEXT WORD FOR SUB
  AOS R1 ;NEXT WORD IN CURRENT ARGS BUF
  CAIGE R1,NSARWD ;DONE
  JRST CKSTY3 ;NO--LOOP
;
 CKSTY2:
  POPJ P, ;AND RETURN
;
 CKSTY1:
  MOVEI R2,SUBARG(T7) ;GET POINTER TO SUB ARG AREA
  HRLI R2,CSBARG ;AND FROM AREA--CURRENT ARGS
  BLT R2,SUBARG+NSARWD-1(T7) ;MOVE IN NEW ARG CODES
  POPJ P, ;AND THEN DONE
;
;
SUBTTL SUB SUBROUTINES--DEFSUB
;
;   DEFSUB--THIS ROUTINE IS CALLED FROM SUBEND WHEN WE ARE
;      READY TO DECLARE THE FINAL ADDRESS OF THE SUB IN
;      QUESTION FOR RT LINKABE.
;
;
DEFSUB:
;
  MOVE T0,SUBGBL(T7) ;GET BITS/VALUE
  TLO T0,SBBDEF		;MARK AS DEFINED
  MOVEM T0,SUBBTS(T7)	;AND SAVE
  HRRM R2,SUBGBL(T7) ;AND SAVE R2 AS NEW LOC
  SKIPN CGOFG ;CHECK IF WE WANT TO RUN LATER
    POPJ P, ;IF NOT, RETURN NOW
  HRRZS T0 ;ISOLATE OLD LINKED LIST OF SUB REFS
  JUMPE T0,DFSB1 ;IF NOEN, THEN SKIP
  HRRZ R1,0(T0) ;GET NEXT
  HRRM R2,0(T0) ;SAVE RESULT
  SKIPE T0,R1 ;CHECK IF DONE FILLING IN LIST
  JRST .-3 ;LOOP UNTIL DONE
;
 DFSB1:
  POPJ P, ;AND THEN RETURN
;
;
SUBTTL SUB SUBROUTINES--FCTCHK
;
;   FCTCHK--THIS ROUTINE GENERATES CODE TO CHECK THE TYPE OF ALL
;      PASSED FUNCTIONS BY CHECKING THE ID WORDS OF THE ONE PASSED
;      AGAINST WHAT IS EXPECTED.
;
;
FCTCHK:
;
  SKIPN T1,T5		;GET NUMBER ARGS IN T1
    POPJ P,		;RETURN NOW IF NONE
  MOVEI T4,HDRLN.-1	;INITIAL PTR TO WHERE FCT WORD WILL BE
  MOVE T2,T6		;POINTER TO ARGS
;
 FCCHK2:
  AOS T2		;NEXT ARG
  AOS T4		;LOC FOR IT
  MOVE T0,0(T2)		;PICK UP ARG
  TLNN T0,VTFCT!VTFC0	;CHECK FOR FUNCTION
    JRST FCCHK1		;IGNORE IF NOT
  MOVSI R2,(MOVE R1,)	;LOAD THE ACTUAL ADDRESS OF FCT
  HRR R2,T4
  SVWNM
  MOVE R2,[MOVE R0,-1(R1)] ;LOAD THE ID WORD AS WELL
  SAVWD
  HRRZ R2,FCIAD(T0)	;SAVE ID WORD IN BLOCK
  SUBI R2,1
  HRLI R2,(MOVEM R0,)
  SVWPR
  SKIPN R2,FCIDWD(T0)	;CHECK IF WE HAVE OUR OWN ID WORD
    JRST FCCHK1		;IF NOT, SKIP
  DSVCON (R2)		;IF SO, SAVE IT AS CONSTANT
  HRLI R2,(CAME R0,)	;AND COMPARE GIVEN ONE WITH IT
  SVWCN
  MOVEI R2,-UFCATB(T0)	;GET FUNCTION NUMBER
  LSH R2,-1		;GET REAL NUMBER
  HRLI R2,(R.FCER)	;ERROR CAUSING INST
  SAVWD			;SAVE
;
 FCCHK1:
  SOJG T1,FCCHK2	;LOOP IF MORE TO LOOK AT
  POPJ P,		;AND RETURN
;
;
SUBTTL SUB SUBROUTINES--FNDSUB
;
;   FNDSUB--THIS ROUTINE TAKES A STRING CONST PTR IN T0 AND
;      FINDS THE SUB IN THE SUB TABLE CORRESPONDING TO IT.  IF
;      NO SUCH SUB EXISTS, ONE IS ADDED TO THE TABLE.
;
;
FNDSUB:
;
  HRRZ T7,T0 ;GET PTR TO CONST
  ADD T7,CONST ;GET REAL PTR
  SKIPN T7,-1(T7) ;CHECK IF NULL
    ERR E.ISBN ;CAN'T BE NULL
  ADD T7,CONST ;RELOCATE THE PTR
  SUBI T7,1 ;CORRECTLY
  HLRZ R2,-1(T7) ;NUMBER OF CHRS IN NAME
  MOVE T5,0(T7) ;FIRST WORD
  MOVEI T6,0 ;SECOND WORD OF SHORT NAMES
  CAILE R2,5 ;SKIP IF SHORT NAME
  MOVE T6,1(T7) ;ELSE GET SECOND WORD OF IT
  CAILE R2,8 ;CHECK MAX LENGTH OF NAME
    ERR E.ISBL ;ERROR IF TOO LONG
;
 XFNSUB:		;FIND SUB WITH T5,T6 SET UP ENTRY
;
  MOVEI T7,SUBTBL ;GET SUB TABLE PTR
  SKIPN R2,NSUBS ;NUMBER OF SUBS
    JRST FNSUB4 ;NONE--CAN'T FIND ANYTHING
;
 FNSUB5:
  CAME T5,SUBNAM(T7) ;CHECK 1ST WORD FOR MATCH
    JRST .+3 ;SKIP IF NOT
  CAMN T6,SUBNAM+1(T7) ;CHECK FOR MATCH
    JRST FNSUB6 ;HANDLE MATCH
  ADDI T7,SUBBLN ;NEXT ENTRY
  SOJG R2,FNSUB5 ;SKIP BACK IF MORE TO LOOK AT
;
 FNSUB4:
  MOVEM T7,CRSUB ;SAVE PTR AS CURRENT SUB
  SKIPGE RPGFG		;CHECK FOR ONE LINE
    ERR E.NNSB		;CAN'T HAVE NEW SUBS IN THAT CASE
  AOS NSUBS ;ONE MORE SUB
  MOVEM T5,SUBNAM(T7) ;SAVE NAME OF SUB
  MOVEM T6,SUBNAM+1(T7) ;SAVE SECOND HALF OF NAME
  MOVSI R2,SBBCPJ ;BIT TO CALL WITH PUSHJ
  MOVEM R2,SUBBTS(T7) ;SAVE THAT ON IN BLOCK
  POPJ P, ;AND RETURN
;
 FNSUB6:
  MOVEM T7,CRSUB ;SAVE PTR TO CURRENT SUB
  POPJ P, ;AND RETURN
;
;
SUBTTL SUB SUBROUTINES--GETRNM
;
;   GETRNM--THIS ROUTINE TAKES A SUB BLK PTR IN T7 ON ENTRY AND
;      RETURNS THE SUB NAME IN RADIX 50 IN R2 ON EXIT, PRINTING
;      AND ERROR MESSAGE IF THE CONVERSION WASN'T PERFECT.
;
;
GETRNM:
;
  MOVEI T5,6 ;CHR COUNT
  MOVEI T6,0 ;RDX50 ACCUM WORD
  MOVE T4,[POINT 7,SUBNAM(T7)] ;NAME TALLY
;
 GTRNM3:
  ILDB R2,T4 ;GET NEXT CHR
  JUMPE R2,GTRNM1 ;IF DONE, THEN EXIT
  SOJL T5,GTRNM2 ;IF TOO LONG, THEN ERROR
  PUSHJ P,RDX50 ;CONVERT CHR TO RDX50
  IMULI T6,50 ;TIMES 50
  ADD T6,R2 ;PLUS NEW VALUE TO ACCUM NAME
  JRST GTRNM3 ;AND CONTINUE
;
 GTRNM2:
  ERR E.IRDX ;ERROR IF TOO LONG
;
 GTRNM1:
  MOVE R2,T6 ;GET RESULT IN R2
  POPJ P, ;AND RETURN
;
;
SUBTTL SUB SUBROUTINES--GTARTY
;
;   GTARTY--THIS ROUTINE DECODES THE ARG WHOSE STACK WORD IS INT
;      T0 ON ENTRY AND RETURNS THE CODE IN R1 ON EXIT.
;
;
GTARTY:
;
  MOVEI R1,0 ;DEFAULT OF 0
  TLNE T0,VTSTR ;CHECK IF STRING
    ADDI R1,1 ;IF SO, MODIFY DEFAULT
;
  TLNE T0,VTFC0 ;CHECK FOR FUNCTION
    ADDI R1,6 ;HANDLE
  TLNE T0,VTMAT ;CHECK FOR MAT
    JRST GTART1 ;PROCESS
  TLNE T0,VTFIL ;CHECK FOR FILE
    MOVEI R1,17 ;HANDLE
  POPJ P, ;AND RETURN
;
 GTART1:
  ADDI R1,2 ;HANDLE MAT--GUESS VECTOR
  SKIPL MATDTB(T0) ;CHECK THAT
  ADDI R1,2 ;NO--MATRIX
  POPJ P, ;AND RETURN
;
;
SUBTTL SUB SUBROUTINES--LNKSUB
;
;   LNKSUB--THIS ROUTINE IS CALLED TO LINK THE SUB CALLS IN
;     THE CURRENT PROGRAM, EITHER WITH THE REAL ADDRESS OF
;      THE SUB OR WITH THE UNDEFINED LIST FOR THE SUB.
;
;
LNKSUB:
;
  SKIPN CGOFG ;CHECK IF WE WANT TO RUN
    POPJ P, ;IF NOT, THEN RETURN
;
  MOVEI T2,SUBTBL ;GET PTR TO SUB TABLE
  SKIPN T1,NSUBS ;GET COUNT OF NUMBER OF SUBS
    POPJ P, ;IF NONE, THEN RETURN
;
 LNKSB1:
  MOVE R2,SUBBTS(T2) ;CHECK THIS SUB
  TLNN R2,SBBUSD ;IF WE USED IT
    JRST LNKSB2 ;IF NOT, IGNORE
  TLNN R2,SBBDEF ;CHECK IF DEFINED
    JRST LNKSB3 ;HANDLE UNDEFINED
;
  MOVS T3,SUBADD(T2) ;DEFINED--GET INTERNAL LIST
  ADD T3,OBJCOD ;RELOCATE PTR
;
 LNKSB4:
  HRRZ R1,0(T3) ;PICK UP NEXT LINK
  HRRM R2,0(T3) ;SAVE ABS SUB VALUE
  SKIPE T3,R1 ;CHECK IF DONE
  JRST LNKSB4 ;NO--LOOP
  JRST LNKSB2 ;YES--NEXT SUB
;
 LNKSB3:
  MOVS T3,SUBADD(T2) ;UNDEFINED--GET LISTS
  ADD T3,OBJCOD ;RELOCATE FIRST PTR IN INTERNAL LIST
  HRRM T3,SUBGBL(T2) ;SAVE AS START OF UNDEF GBL LIST
;
 LNKSB6:
  HRRZ R1,0(T3) ;PICK UP NEXT LINK
  JUMPE R1,LNKSB5 ;ZERO--DONE
  HRRM R1,0(T3) ;AND RESAVE
  MOVE T3,R1 ;GET NEXT LINK
  JRST LNKSB6 ;AND LOOP
;
 LNKSB5:
  HRRM R2,0(T3) ;SAVE LINK TO~ PREVIOUS LIST TO LINK THEM UP
;
 LNKSB2:
  ADDI T2,SUBBLN ;NEXT SUB BLOCK
  SOJG T1,LNKSB1 ;DEC SUB COUNT
  POPJ P, ;AND RETURN IF DONE
;
SUBTTL SUB SUBROUTINES--RDX50
;
;   RDX50--THIS ROUTINE CONVERTS THE ASCII CHR IN R2 TO A
;      RADIX50 CHR IN R2.
;
;
RDX50:
;
  CAIL R2,ASC..A ;CHECK FOR LETTER A...Z
  CAILE R2,ASC..Z
  JRST .+3 ;NO--SKIP
    MOVEI R2,RDX..A-ASC..A(R2) ;YES--GET RESULT
    POPJ P, ;AND RETURN
;
  CAIL R2,ASCLCA ;CHECK FOR LOWER CASE LETTER
  CAILE R2,ASCLCZ
  JRST .+3 ;NO--SKIP
    MOVEI R2,RDX..A-ASCLCA(R2) ;CONVERT
    POPJ P, ;AND RETURN
;
  CAIL R2,ASC..0 ;CHECK FOR DIGIT
  CAILE R2,ASC..9
  JRST .+3 ;NO--SKIP
    MOVEI R2,RDX..0-ASC..0(R2) ;CONVERT DIGIT
    POPJ P, ;AND RETURN
;
  CAIE R2,ASCDOL ;CHECK FOR '$'
  JRST .+3 ;NO--SKIP
    MOVEI R2,RDXDOL ;YES--CONVERT
    POPJ P, ;AND RETURN
;
  CAIE R2,ASCDOT ;CHECK FOR '.'
  JRST .+3 ;NO--SKIP
    MOVEI R2,RDXDOT ;YES--CONVERT
    POPJ P, ;AND RETURN
;
  CAIE R2,ASCPER ;CHECK FOR '%'
  ERR E.IRDX ;IF NOT, THEN ERROR
    MOVEI R2,RDXPER ;CONVERT
    POPJ P, ;AND RETURN
;
;
SUBTTL SUB SUBROUTINES--STSBAR
;
;   STSBAR--THIS ROUTINE IS CALLED TO START SETTING  UP A SUBROUTINE
;      ARG LIST SCAN.  IT INITIALIZES THE NUMBER AND CODES FO
;      THE SCANNED ARGS.
;
;
STSBAR:
;
  SETZM NSBARG ;COUNT
  SETZM CSBARG ;CODES
  MOVE R2,[XWD CSBARG,CSBARG+1] ;CLEAR ALL CODES
  BLT R2,CSBARG+6-1 ;FOR AREA
;
  MOVE R2,[POINT 4,CSBARG,7] ;INITIAL PTR
  MOVEM R2,CSBART ;AND SAVE IT
;
  MOVEI R2,20-1		;LENGTH OF SBFLTB-1
  SETZM SBFLTB(R2)	;CLEAR SBFLTB FOR CHECK FOR DUPLICATES
  SOJGE R2,.-1		;LOOP UNTIL DONE
;
  POPJ P, ;THEN RETURN
;
;
SUBTTL SUB SUBROUTINES--SBARG
;
;   SBARG--THIS ROUTINE SCANS A SUB/CALL ARGUMENT.  IT CALLS
;      THE ARITHMETIC SCAN, BUT ALLOWS SINGULAR FCTS AND
;      MAT SBSC CALLS WITH NO ARGS.
;
;
SBARG:
;
  TLZ FG,-1-NCHBT ;GET RID OF ALL BLAGS BUT CHR  USAGE
  TLO FG,CALBT ;MARK AS CAL ARG SCAN
  TLON FG,NCHBT ;CHECK IF WE WANT NEXT CHR
  JSP T,NXECH ;GET NEXT CHR IF NEEDED
  CAIN CH,ASCNUM ;CHECK FOR '#'--FILE
  JRST SBARG1 ;HANDLE FILE NUMBER
;
  PUSHJ P,ARSCN ;SCAN ARG OTHERWISE
  MOVE T0,0(VS) ;CHECK RESULT
  TLNE T0,VTFC0 ;CHECK FOR FCT CALL WITH NO ARGS
  JRST SBARG3 ;HANDLE IF SO
  XMKLOD (T0) ;ELSE MAKE RESULT LOADABLE
;
 SBARG9:
  PUSHJ P,RTCRG ;SAVE REGS 0 AND 1
  PUSHJ P,GTARTY ;GET ARG TYPE
  IDPB R1,CSBART ;SAVE IN CODE WORDS
  AOS R2,NSBARG ;ARG COUNT
  CAILE R2,MXSBAR ;MAKE SURE NOT TOO MANY
    ERR E.TMSA ;ERROR IF TOO MANY
;
  TLNE T0,VTVAR+VTFC0+VTFIL ;CHECK FOR VAR/FCT
    AOS 0(P) ;IF SO, THEN RETURN +1
;
  POPJ P, ;THEN RETURN
;
;
;   SBARG1--HANDLE FILE NUMBERS
;
 SBARG1:
  TLC FG,NCHBT+NUMBT ;IGNORE CHR, GET NUMBER
  PUSHJ P,ARSCN ;FROM SCAN
  AOS FILUSD ;WE HAVE NOW USED FILES
  SKIPL CALFG ;CHECK IF CAL/SUB
  JRST SBARG2 ;HANDLE IF SUB
  MOVEI R2,R.PSFL ;ROUTINE TO GET FILE ADDRESS FOR PASSING
  JSA T,DORSB1 ;GENERATE CALL OF 1 ARG
  HRLZI T0,VTREG+VTFIL ;RESULT IS IN REG  0
  HRLZI R2,400000 ;BIT FOR REG 0
  ANDCAM R2,REGFGS ;MAKR AS SUED
  MOVEI R2,T0 ;LOC OF ARG WHICH USES IT
  MOVEM R2,FSTARG ;SAVE THAT
  JRST SBARG9 ;AND DONE
;
 SBARG2:
  POP VS,T0 ;GET ITEM OFF VS
  TLNN T0,VTCON ;MUST BE CONSTANT
    ERR E.ISBF ;ERROR IF NOT
  MOVE T0,0(T0) ;GET CONSTNAT
  XFIX T0 ;FIX IT
  CAIL T0,1 ;CHECK FOR IN BOUNDS
  CAILE T0,7777 ;FOR FILE NUMBER
    ERR E.ISBF ;ERROR IF NOT
  HRLI T0,VTFIL ;TYPE OF FILE W/ NUMBER
  JRST SBARG9 ;AND RETURN THAT
;
;
;   SBARG3--HANDLE FUNCTIONS OF NO ARGS
;
 SBARG3:
  SETZM FSTARG ;NO ARG LOC
  JRST SBARG9 ;IF FUNCTION, JUST DON'T CALL IT
;
;
;
;
;
    PRINTX *****START OF BAS55*****
;
;
SUBTTL LIBRARY SUBROUTINES--DONFIL
;
;   DONFIL--THIS ROUTINE IS CALLED WHEN THE COMPILER IS DONE WITH A SOURCE
;      FILE.  IT IS ENTERED WITH THE LIBRARY BLOCK PTR IN R3 AND SHOULD
;      CLOSE THE FILE AND CLEAR 'SRCJFN'.
;
;
DONFIL:
;
  SETZM SRCJFN		;CLEAR OLD SOURCE JFN
  SETZM CURLIB		;AND CURRENT LIBRARY
  MOVE R1,LBBTS(R3)	;CHECK CURRENT BITS
  TLNE R1,LBBTM		;CHECK FOR TEMP FILE
    POPJ P,		;IF SO, DON'T CLOSE IT
  MOVE R1,LBJFN(R3)	;ELSE GET JFN
  CLOSF			;CLOSE THE FILE 
    BLOWUP		;AND RELEASE JFN
  SETZM LBJFN(R3)	;CLEAR JFN
  POPJ P,		;AND RETURN
;
;
SUBTTL LIBRARY SUBROUTINES--ENDSRC
;
;   ENDSRC--THIS ROUTINE IS CALLED AT THE END OF THE CURRENT LIBRARY FILE TO
;      FIND THE NEXT RELEVANT LIBRARY FILE AND TO GET IT READY TO COMPILE
;      FROM.
;
;
ENDSRC:
;
  PUSH P,R1		;SSPVE R1,R2,R3
  PUSH P,R2
  PUSH P,R3
  MOVE R3,CURLIB	;GET CURRENT LIBRARY PTR
  MOVSI R1,LBBCM	;GET COMPILED BIT
  IORM R1,LBBTS(R3)	;TURN ON
  PUSHJ P,DONFIL	;CLOSE FILE IF NEEDED
  MOVEI R1,LIBLST	;GET PTR TO ALL LIBRARYS
;
 ENSRC1:
  HRRZ R1,0(R1)		;GET NEXT LIBRARY
  JUMPE R1,ENSRC2	;IF DONE, THEN EXIT
  MOVE R3,LBBTS(R1)	;ELSE CHECK THE BITS
  TLNE R3,LBBCM+LBBRQ		;FOR COMPILED
    JRST ENSRC1		;IF SO, IGNORE IT
  MOVE R3,R1		;ELSE GET SUB BLOCK IN R3
  PUSHJ P,GETFIL	;GET THE FILE AS THE SOURCE
  AOS -3(P)		;BUMP THE RETURN
;
 ENSRC2:
  POP P,R3		;RESTORE R3,R2,R1
  POP P,R2
  POP P,R1
  POPJ P,		;AND RETURN
;
;
SUBTTL LIBRARY SUBROUTINES--FNMAIN
;
;   FNMAIN--THIS ROUTINE FINDS/CREATES THE SUB TABLE BLOCK FOR THE
;      MAIN PROGRAM.
;
;
FNMAIN:
;
  MOVEI T7,SUBTBL	;PTR TO SUB TABLE
  SKIPN R2,NSUBS	;CHECK NUMBER OF SUBS
    JRST FMAIN1		;SKIP IF NONE
;
 FMAIN3:
  SKIPN SUBNAM(T7)	;CHECK FOR MAIN HERE
  SKIPE SUBNAM+1(T7)	;WOULD HAVE ZERO NAME
    SKIPA
  JRST FMAIN2		;HANDLE WHEN FOUND
  ADDI T7,SUBBLN	;ELSE GO TO NEXT SUB
  SOJG R2,FMAIN3	;LOOPING
;
 FMAIN1:
  AOS NSUBS		;ADD ANOTHER SUB
  SETZM SUBNAM(T7)	;SAVE NAME
  SETZM SUBNAM+1(T7)
  SETZM SUBBTS(T7)	;CLEAR BITS
;
 FMAIN2:
  MOVEM T7,CURSUB	;SAVE PTR AS CURRENT SUB BLOCK
  POPJ P,		;AND RETURN
;
;
SUBTTL LIBRARY SUBROUTINES--GETFIL
;
;   GETFIL--THIS ROUTINE SETS UP THE CURRENT SOURCE JFN FROM THE LIBRARY FILE
;      POINTED TO BY R3.  IT OPENS THE FILE IF NECESSARY.
;
;
GETFIL:
;
  SKIPN R1,LBJFN(R3)	;CHECK IF WE HAVE JFN
    PUSHJ P,GTOPFL	;IF NOT, GET ONE
  MOVEM R1,SRCJFN	;SAVE JFN
  MOVEM R3,CURLIB	;SAVE LIB PTR AS CURRENT
  POPJ P,		;AND RETURN
;
;
SUBTTL LIBRARY SUBROUTINES--GTOPFL
;
;   GTOPFL--THIS ROUTINE OPENS THE FILE WHOSE LIBRARY IS IN R3 AND RETURNS THE
;      JFN OF THE OPEN FILE IN R1.
;
;
GTOPFL:
;
  MOVSI R1,100001	;BITS FOR OPEN
  HRROI R2,LBNAM(R3)	;NAME PTR
  GTJFN			;GET A JFN
    BLOWUP		;WE KNOW THE FILE IS THERE
  MOVE R2,[XWD 070000,200000]	;BITS FOR OPEN
  OPENF			;OPEN THE FILE
    BLOWUP		;AND READABLE
  MOVEM R1,LBJFN(R3)	;SAVE JFN
  POPJ P,		;AND RETURN
;
;
SUBTTL LIBRARY SUBROUTINES--GSYMFL
;
;   GSYMFL--THIS ROUTINE OPENS A TEMPORARY FILE FOR SAVING THE SYMBOL TABLES
;      IN.
;
;
GSYMFL:
;
  PUSH P,R3		;SAVE R3,R4
  PUSH P,R4
  GJINF			;GET JOB INFO
  MOVE R1,R3		;JOB NUMBER TO R1 (FOR VERSION)
  POP P,R4		;RESTORE R4
  POP P,R3		;AND R3
;
  HRLI R1,410001	;OTHER BITWS FOR TEMP FILE
  HRROI R2,[ASCIZ /BASIC.SYMTABS/]	;NAME
  GTJFN			;GET A JFN TO USE
    BLOWUP		;BETTER BE ABLE TO
  HRLZM R1,SYMJFN	;SAVE JFN
  MOVE R2,[XWD 440000,300000]
  OPENF			;OPEN FOR PMAPPING
    BLOWUP		;BETTER WORK
  POPJ P,		;AND RETURN
;
;
SUBTTL LIBRARY SUBROUTINES--LIBSET
;
;   LIBSET--THIS ROUTINE IS CALLED TO SET UP THE FIRST FILE UPON THE START
;      OF A FULL COMPILATION FROM THE LIB TABLE.
;
;
LIBSET:
;
  SKIPN R3,FSTLIB	;CHECK TO MAKE SURE FIRST LIB IS GIVEN
    BLOWUP		;IT BETTER BE
  PUSHJ P,GETFIL	;GET THE FILE FOR READING
  PUSHJ P,STFIL		;START THE FIRST FILE
  POPJ P,		;AND DONE
;
;
SUBTTL LIBRARY SUBROUTINES--NEWLIB
;
;   NEWLIB--THIS ROUTINE IS CALLED TO OPEN A NEW LIBRARY FILE AND TO PLACE
;      IT IN THE LIBRARY PAGE/TABLE.  IT ALSO CHECKS FOR DUPLICATE NAMES
;      IN THE TABLE AND IGNORES THEM.  THE FILE IS LEFT CLOSED TO BE OPENED
;      WHEN NEEDED.  THE JFN FOR THE NEW FILE IS IN R1 ON ENTRY.
;
;
NEWLIB:
;
  PUSH P,R2		;SAVE R2
  PUSH P,R3		;SAVE R3,R4,R5,R6
  PUSH P,R4
  PUSH P,R5
  PUSH P,R6
  MOVEM R1,XLBJFN#	;SAPVE INITIAL JFN
  MOVE R3,[XWD TMPBF,TMPBF+1]	
  SETZM TMPBF
  BLT R3,TMPBF+14-1	;CLEAR NAME BUFFER
  MOVE R2,R1		;DUPLICATE IT
  MOVE R1,TMPTL		;TALLY TO TEMP AREA
  MOVEI R3,0		;FREE FORMAT
  JFNS			;GET STRING NAME IN SPTD FORM
;
  HRRZS R1		;ISOLATE LAST ADDRESS
  SUBI R1,TMPBF-1	;GET LENGTH OF NAME
  HRRZ R2,LIBLST	;AND PTR TO LIBS
  JUMPE R2,NWLIB1	;FIRST LIB--HANDLE SPECIAL
;
 NWLIB4:
  MOVE R3,R1		;LENGTH TO R3
  MOVEI R4,TMPBF	;PTR TO NEW STRING IN R4
  MOVEI R5,LBNAM(R2)	;TO OLD IN R5
;
 NWLIB6:
  MOVE R6,0(R4)	;GET NEXT WORD
  CAME R6,0(R5)		;CHECK FOR MATCH
    JRST NWLIB2		;NO MATCH--TRY NEXT LIBRARY
  AOS R4		;MATCH--TRY NEXT WORD
  AOS R5
  SOJG R3,NWLIB6	;UNTIL DONE
  JRST NWLIB3		;HANDLE DUPLICATE
;
 NWLIB2:
  HRRZ R2,LBLNK(R2)	;NEXT LIBRARY PTR
  JUMPN R2,NWLIB4	;IF ANOTHER, CHECK IT
;
 NWLIB1:
  MOVE R3,LIBPTR	;GETLIB PTR
  MOVE R2,LIBLST	;AND LIST HEADER
  HRRZM R2,LBLNK(R3)	;LINK NEW ITEM TO START OF LIST
  MOVEM R3,LIBLST
  SETZM LBSBS(R3)	;NO SUBS YET
  SETZM LBJFN(R3)	;NO JFN
  MOVEI R5,LBNAM(R3)	;NAME PTR
  ADDI R5,-1(R1)	;END OF NAME AREA
  CAIL R5,LIBBUF+1000	;CHECK IF IT FITS
    ERR E.TMFL		;ERROR IF NOT
  MOVEI R4,LBNAM(R3)	;NAME PTR
  HRLI R4,TMPBF		;POINTER TO WHERE NAME IS NOW
  BLT R4,0(R5)		;MOVE THE NAME
  ADDI R1,LBNAM		;END OF NAME PTR
  ADDM R1,LIBPTR	;SAVE ROOM FOR LIBRARY BLOCK WE'VE CREATED
  SKIPE FSTJFN		;CHECK IF FIRST FILE
    JRST NWLIB3		;NOT--JUMP
  MOVE R1,XLBJFN	;IF SO, DON'T CLOSE
  MOVEM R1,FSTJFN	;BUT RATHER SAVE GIVEN JFN
  MOVEM R1,LBJFN(R3)	;SAVE FIRST JFN IN LIB BLOCK
  MOVEM R3,FSTLIB	;FOR US
  JRST NWLIB5		;AS FIRST LIBRARY
;
 NWLIB3:
  MOVE R1,XLBJFN	;NOT FIRST--GET JFN
  CLOSF			;CLOSE IT
    BLOWUP
  MOVEI R1,0		;INDICATE NO JFN AT END IF CLOSED
;
 NWLIB5:
  POP P,R6		;RESTORE REGS
  POP P,R5		
  POP P,R4
  POP P,R3
  POP P,R2
  POPJ P,		;AND RETURN
;
;
SUBTTL LIBRARY SUBROUTINES--SAVSUB
;
;   SAVSUB--THIS ROUTINE IS CALLED AT THE END OF COMPILING A SUBROUTINE
;      TO SAVE WHATEVER FINAL INFORMATION IS NEEDED.  THIS INCLUDES SETTING
;      UP THE SUB BLOCK AND THE SYMBOL TABLE FOR DEBUGGING PURPOSES.
;
;
SAVSUB:
;
  MOVE T7,CURSUB	;GET CURRENT SUB BLOCK PTR
  MOVE R2,STBASE	;GET STORAGE BASE
  HRRM R2,SUBLOC(T7)	;SAVE BASE IN SUB BLOCK
;
  MOVE R2,OBJPT		;GET LENGTH OF OBJECT
  ADD R2,CADDN		;PLUS LENGTH OF CONSTS
  ADDI R2,2		;PLUS TWO
  SKIPE PRGNM		;CHECK FOR MAIN PROGRAM
    JRST SVSUB1		;SKIP IF NOT
  ADD R2,VADDN		;IF SO, ROOM FOR VARS ALSO NEEDED
  ADD R2,SADDN
  ADDI R2,1
;
 SVSUB1:
  HRLM R2,SUBLEN(T7)	;SAVE LENGTH OF SUB
  MOVE R2,PGDATA	;GET PGM DATA
  ADD R2,STBASE		;RELOCATE
  ADD R2,CONOFF		;TO GET ACTUAL FINAL LOC
  HRRM R2,SUBPGD(T7)	;SAVE IN SUB BLOCK
  MOVE R2,PGDATA	;GET PGM DATA AREA PTR
  ADD R2,CONST		;GET REAL PTR NOW
  MOVEM T7,PGLNK-1(R2)	;SAVE PTR TO SUB BLOCK IN IT
;
  SKIPN DEBFG		;CHECK IF DEBUGGING
    POPJ P,		;IF NOT, THEN RETURN NOW
;
  SKIPN SYMJFN		;CHECK IF WE HAVE A SYMBOL TABLE
    PUSHJ P,GSYMFL	;GET ONE IF NOT
  MOVE R2,SYMJFN	;GET SYMBOL TABLE JFN/PAGE
  HLR R2,SUBSYM(T7)	;CHECK IF WE HAVE A PAGE ALLOCATED ALREADY
  TRNN R2,-1		;IT WOULD BE IN SUB TABLE
    AOS R2,SYMJFN	;IF NOT, ALLOCATE ONE
  HRLM R2,SUBSYM(T7)	;AND SAVE IN SUB BLOCK
  HRLI R1,400000	;CURRENT FORK
  HRRI R1,SYMPGN	;PAGE NUMBER THERE
  MOVSI R3,140000	;READ/WRITE
  PMAP			;MAP INTO FILE
  MOVE R2,R1		;GET CORE PAGE IN R1
  MOVNI R1,1		;AND DELTE IT
  PMAP			;SO WE DON'T CLOBBER FILE AND CAN CLEAR IT
;
  POPJ P,		;AND RETURN
;
;
;
;
;
    PRINTX *****START OF BAS56*****
;
;
SUBTTL BINARY INPUT ROUTINES--INREL
;
;   INREL--THIS ROUTINE IS THE DRIVER TO READ A BINARY (.REL)
;      FILE.  IT WILL EITHER IGNORE THE FILE IF WE ARE ONLY
;      COMPILING, OR IF WE ARE LOADING, IT WILL READ THE FILE
;      IN AND RELOCATE IT CORRECTLY AS WELL AS LINK UP THE
;      GLOBAL REFERENCES IN IT.
;
;
INREL:
;
  MOVE T7,CURLIB	;GET CURRENT LIBRARY PTR
  MOVSI R2,LBBRQ	;AND REQUIRES BIT
  IORM R2,LBBTS(T7)	;INDICATE TO REQUIRE IF WRITING BINARY FILE
  SKIPN CGOFG		;ARE WE LOADING?
    JRST DONREL		;IF NOT, THEN IGNORE THIS FILE
  MOVE T7,STBASE	;GET PTR TO OBJECT AREA
  HRLI T7,444400	;MAKE WORD TALLY
  MOVEM T7,RSTTAL		;SAVE TALLY FOR STORING
;
 INREL1:
  PUSHJ P,NXRBLK	;START THE NEXT RELOCATABLE BLOCK
  MOVE R1,RBLKTY	;GET THE BLOCK TYPE
  CAILE R1,20		;CHECK IF OK
    JRST RBKILL		;HANDLE ILLEGAL BLOCKS
  JRST .+1(R1)		;ELSE BRANCH ON BLOCK TYPE
;
    JRST RBKT0	;TYPE 0
    JRST RBKT1		;TYPE 1
    JRST RBKT2		;TYPE 2
    JRST RBKT3		;TYPE 3
    JRST RBKT4		;TYPE 4
    JRST RBKT5		;TYPE 5
    JRST RBKT6		;TYPE 6
    JRST RBKT7		;TYPE 7
    JRST RBKT10		;TYPE 10
    JRST RBKT11		;TYPE 11
    JRST RBKT12		;TYPE 12
    JRST RBKT13		;TYPE 13
    JRST RBKT14		;TYPE 14
    JRST RBKT15		;TYPE 15
    JRST RBKT16		;TYPE 16
    JRST RBKT17		;TYPE 17
;
;
 INXREL:
  MOVE R1,IFLCNT	;ENTER HERE ON END OF BLOCK
  CAIG R1,1		;CHECK FOR POTENTIAL EOF
  SKIPE IFLLFT		;BY CHECKING READ FLAGS
  SKIPA			;SKIP IF NOT
    JRST DONREL		;HANDLE EOF
  GTCHR CH		;ELSE GET FIRST WORD OF NEXT BLOCK
  JRST INREL1		;AND PROCESS
;
;
 DONREL:
  SKIPL PRGNM		;DONE WITH .REL FILE
    ERR E.RBKI		;BETTER BE DONE WITH CURRENT PROGRAM
  SETZM IFLTYP		;CLEAR FLAGS
  SETZM IFLLFT		;MARK AS EOF
  SETZM IFLCNT
  JRST LINE		;PREPARE FOR NEXT FILE
;
;
SUBTTL BINARY INPUT ROUTINES--IGNORED/ILLEGAL BLOCKS
;
;   THESE REPRESENT BLOCK TYPES THAT ARE EITHER DEFINED
;      AS IGNORED (0), THAT ARE NOT IMPLEMENTED YET NON
;      FATAL FOR THIS LOADER (3,4,11,12,13,14,15), AND
;      THAT ARE FATAL.
;
;
RBKT0:
RBKT3:
RBKT4:
RBKT11:
RBKT12:
RBKT13:
RBKT14:
RBKT15:
;
RBKIGN:
;
  PUSHJ P,NXRWD		;GET NEXT WORD FROM FILE
    JRST INXREL		;HANDLE DONE BLOCK
  JRST RBKIGN		;LOOP IF MORE TO IGNORE
;
;
RBKILL:
  ERR E.RBKI		;ERROR IF ILLEGAL
  JRST RBKIGN		;THEN IGNORE IT
;
;
SUBTTL BINARY INPUT ROUTINES--TYPE 1--PROGRAM
;
;   RBKT1--THIS ROUTINE READS TYPE 1 (PROGRAM/DATA) BLOCKS
;      FROM THE REL FILE AND RELOCATES THEM INTO CORE.
;
;
RBKT1:
;
  PUSHJ P,NXRWD		;GET FIRST WORD (LOC)
    JRST INXREL		;NONE--IGNORE BLOCK
  HRLI CH,444400	;GET WORD TALLY FROM IT
  MOVEM CH,RSTTAL	;SAVE IT FOR LOADING
  SKIPLE RBASFG		;CHECK FOR BASIC AND .SUBTB
    JRST RBKSUB		;PROCESS THAT AS SPECIAL
;
 RBKPRG:
  PUSHJ P,NXRWD		;GET THE NEXT WORD IN BLOCK
    JRST INXREL		;HANDLE DONE
  IDPB CH,RSTTAL	;SAVE IN CORE
  JRST RBKPRG		;AND LOOP
;
;
RBKSUB:
  PUSHJ P,NXRWD		;ENTER HERE FOR SUB TABLE ENTRY
    JRST INXREL		;DONE--EXIT TO NEXT BLOCK
  PUSHJ P,NXRWD		;GET SECOND WORD
    JRST RBKILL		;MUST BE THERE
  MOVE T5,CH		;TO T5
  PUSHJ P,NXRWD		;GET THIRD WORD
    JRST RBKILL
  MOVE T6,CH		;TO T6 (NAME IN T5,T6 NOW)
  PUSHJ P,XFNSUB	;FIND SUB TABLE ENTRY
;
  MOVEI T0,4		;LENGTH OF ARG WORDS
  MOVEI T1,CSBARG	;BUFFER PTR
  HRLI T1,444400	;BYTE TALLY FOR IT
;
 RBKSB1:
  PUSHJ P,NXRWD		;GET NEXT WORD
    JRST RBKILL		;MUST BE THERE
  IDPB CH,T1		;SAVE IN BUFFER
  SOJG T0,RBKSB1	;LOOP IF MORE
  PUSHJ P,XCSBTY	;THEN CHECK SUB TYPE VS THESE
;
  PUSHJ P,NXRWD		;FINALLY GET LAST WORD
    JRST RBKILL
  JRST RBKSUB		;AND LOOP FOR MORE SUBS
;
;
SUBTTL BINARY INPUT ROUTINES--TYPE 2--SYMBOLS
;
;   RBKT2--THIS ROUTINE READS TYPE 2 (SYMBOLS) BLOCKS.  IT WILL
;      HANDLE LINKING OF INTERNAL/EXTERNALS VIA THE SUBROUTINE
;      TABLE.
;
;
RBKT2:
;
  PUSHJ P,NXRWD		;GET FIRST WORD (NAME)
    JRST INXREL		;HANDLE END OF BLOCK
  LDB R1,[POINT 4,CH,3]	;GET RADIX50 CODE
  CAIN R1,1		;CHECK FOR INTERNAL
    JRST RSYINT		;HANDLE IF SO
  CAIN R1,14		;CHECK FOR EXTERNAL
    JRST RSYEXT		;HANDLE IF SO
  PUSHJ P,NXRWD		;ELSE JUST GET ITS VALUE
    JRST INXREL		;IGNORE RANDOM END OF BLOCK
  JRST RBKT2		;AND LOOP
;
;
RSYINT:
  SKIPE RBASFG		;ENTER HERE FOR INTERNAL SYMBOL
  CAME CH,[RADIX50 04,START.]	;CHECK FOR MAIN PROGRAM START ADD
    SKIPA		;SKIP IF NOT
    MOVEI CH,0		;KLUDGE IT IF SO
;
  PUSHJ P,R50ASC	;CONVERT SYMBOL TO ASCII
  PUSHJ P,XFNSUB	;FIND ENTRY IN SUB TABLE FOR IT
;
  MOVE T0,SUBBTS(T7)	;GET BITS FOR THIS ITEM
  TLNE T0,SBBDEF	;MAKE SURE NOT ALREADY DEFINED
    ERR E.TWSB		;ERROR IF SO
  TLO T0,SBBREL		;MARK AS .REL SUB
  MOVEM T0,SUBBTS(T7)	;AND RESAVE THE BITS
;
  PUSHJ P,NXRWD		;GET THE SYMBOL VALUE
    JRST RBKILL		;MUST BE PRESENT
  HRRZ R2,CH		;ISOLATE IN R2
  PUSHJ P,DEFSUB	;LINK PREVIOUS OCCURENECES AND DEFINE
;
  JRST RBKT2		;THEN DONE THIS SYMBOL
;
;
RSYEXT:
  MOVEM CH,TEMPA	;ENTER HERE ON EXTERNAL REFERENCE
  PUSHJ P,NXRWD		;GET THE VALUE
    JRST RBKILL		;MUST BE THERE
  JUMPL CH,RSYADD	;HANDLE SPECIAL RELOCATION
  EXCH CH,TEMPA		;RESTORE NAME, SAVE VALUE
  PUSHJ P,R50ASC	;CONVERT NAME TO ASCII
  PUSHJ P,XFNSUB	;THEN FIND IN SUB TABLE
  HRRZ T0,TEMPA		;GET VALUE LOWER (LINK)
  JUMPE T0,INXREL	;IF NO LIST GIVEN, THEN DONE
  MOVE R2,SUBBTS(T7)	;CHECK SUB BITS
  TLNN R2,SBBDEF	;TO SEE IF DEFINED
    JRST RSYEX1		;HANDLE NOT DEFINED YET
;
 RSYEX2:
  HRRZ T1,0(T0)		;GET NEXT LINK
  HRRM R2,0(T0)		;SAVE PROPER VALUE
  SKIPE T0,T1		;CHECK IF DONE
    JRST RSYEX2		;LOOP IF MORE
  JRST RBKT2		;NEXT SYMBOL IF DONE
;
 RSYEX1:
  HRRZ T1,0(T0)		;GET FIRST LINK
  JUMPE T1,RSYEX3	;HANDLE DONE LOOKING THRU LIST
  MOVE T0,T1		;ELSE GET NEXT LINK PTR
  JRST RSYEX1		;AND LOOP
;
 RSYEX3:
  HRRM R2,0(T0)		;LINK OLD LIST TO END OF NEW
  HRRZ R0,TEMPA		;GET NEW LIST HEAD
  HRRM R0,SUBGBL(T7)	;SAVE THAT IN SUB BLOCK
  JRST RBKT2		;AND GO ON TO NEXT SYMBOL
;
;
RSYADD:
  TLNN CH,100000	;ENTER HERE FOR SPECIAL RELOCATION RQSTS
    JRST RBKILL		;DON'T HANDLE MODIFIED SYMBOLS**********
  EXCH CH,TEMPC		;RESTORE SYMBOL
  PUSHJ P,R50ASC	;TO ASCII
  PUSHJ P,XFNSUB	;FIND SUB ENTRY
  MOVE R2,SUBBTS(T7)	;CHECK BITS
  TLNN R2,SBBDEF	;FOR DEFINED
    JRST RBKILL		;DON'T HANDLE FUTURE RELOCS**********
;
  HRRZ R2,SUBGBL(T7)	;GET OLD VALUE
  MOVE R1,TEMPC		;RESTORE 2ND WORD
  TLNE R1,200000	;CHECK IF UPPER HALF RELOC
    MOVSS R2		;RET UPPER HALF VALUE
  ADD R2,0(R1)		;GET CHANGED ADDRESS
  HRRM R2,0(R1)		;SAVE RIGHT HALF BACK
  TLNE R1,200000	;CHECK IF LEFT HALF AFFECTED
    HLLM R2,0(R1)	;IF SO, SAVE IT AS WELL
;
  JRST RBKT2		;THEN DONE WITH SYMBOL
;
;
SUBTTL BINARY INPUT ROUTINES--TYPE 5--END BLOCK
;
;   RBKT5--HANDLES A TYPE 5 (END) BLOCK BY SETTING UP FOR
;      THE NEXT PROGRAM.
;
;
RBKT5:
;
  PUSHJ P,NXRWD		;GET FIRST DATA WORD
    JRST RBKILL		;MUST BE ONE
  HRRZI R2,4(CH)	;GET END+4 TO R2
  MOVEM R2,STBASE	;SAVE AS NEW BASE
  PUSHJ P,STINIT	;RESET STORAGE PTRS, ETC.
  PUSHJ P,RINIT		;AND TALLYS AND TABLES AS WELL
  SETOM PRGNM		;NO PROGRAM
  JRST RBKIGN		;IGNORE EVERYTHING ELSE IN BLOCK
;
;
SUBTTL BINARY INPUT ROUTINES--TYPE 6--NAME BLOCK
;
;   RBKT6--THIS ROUTINE HANDLES A TYPE 6 (NAME) BLOCK BY SETING
;      FLAGS FOR THE COMPILER (BASIC/NOT) AND CHECKING FOR
;      THE SPECIAL PROGRAM '.SUBTB' IN A BASIC COMPILATION.
;
;
RBKT6:
;
  SKIPL PRGNM		;CHECK IF WE HAVE A PROGRAM
    JRST RBKILL		;BETTER NOT
  SETZM RBASFG		;CLEAR COMPILER FLAG
  PUSHJ P,NXRWD		;GET FIRST DATA WORD
    JRST INXREL		;IGNORE BLOCK IF NO NAME GIVEN
  MOVEM CH,PRGNM	;SAVE NAME IF GIVEN
  PUSHJ P,NXRWD		;GET SECOND WORD
    JRST INXREL		;DONE IF NONE
  HLRZS CH		;DHECK COMPILER IF THERE
  CAIE CH,100		;FOR TBASIC
    JRST RBKIGN		;IGNORE RESET OF BLOCK IF NOT
  SETOM RBASFG		;MARK AS BASIC
  MOVE R1,PRGNM		;CHECK NAME AGAIN
  CAME R1,[RADIX50 0,.SUBTB]	;CHECK FOR SUB TABLE
    JRST RBKIGN		;IF NOT, THEN DONE
  MOVNS RBASFG		;IF SO, SET FLAG FOR IT
  JRST RBKIGN		;AND IGNORE THE REST OF THE BLOCK
;
;
SUBTTL BINARY INPUT ROUTINES--TYPE 7--START
;
;   RBKT7--THIS ROUTINE HANDLES A TYPE 7 BLOCK (START).  IT
;      USES THE ADDRESS GIVEN FOR THE ENTRY ADDRESS.  IF THE PROGRAM
;      IS NAMED MAIN. THEN THE ADDRES BECOMES THE STARTING ADDRESS
;      OF EEVERYTHING.
;
;
RBKT7:
;
  PUSHJ P,NXRWD		;GET THE WORD
    JRST INXREL		;HANDLE NONE--IGNORE
  MOVE R1,PRGNM		;CHECK THE PROGRAM NAME
  CAMN R1,[RADIX50 0,MAIN.]	;CHECK FOR MAIN PROGRAM
    PUSHJ P,RBMAIN	;HANDLE MAIN PROGRAM
  MOVEM CH,ENTADD	;ELSE JUST SAVE FOR ANYONE WHO WANTS IT
  JRST RBKIGN		;AND IGNORE THE REST OF THE BLOCK
;
;
 RBMAIN:
  HRRZM CH,MAIN.	;SAVE STARTING ADDRESS
  SKIPE MAINFG		;CHECK IF FIRST MAIN PROGRAM
    ERR E.TWMN		;ERROR IF TWO OF THEM
  SETOM MAINFG		;FLAG MAIN PROGRAM FOUND
  POPJ P,		;AND DONE
;
;
SUBTTL BINARY INPUT ROUTINE--TYPE 10--INTERNAL REQUEST
;
;   RBKT10--THIS ROUTINE HANDLES INTERNAL REQUEST TYPE BLOCKS
;      THAT CONTAIN A LINKED LIST IN THE UPPER HALF AND THE
;      DATA VALUE IN THE LOWER.
;
;
RBKT10:
;
  MOVEI T1,0		;ASSUME LOWER HALF VALUE
  PUSHJ P,NXRWD		;GET NEXT WORD
    JRST INXREL		;DONE--EXIT
  CAME CH,[-1]		;CHECK FOR UPPER HALF FLAG
    JRST RBKIR1		;NO--SKIP
  PUSHJ P,NXRWD		;YES--GET ACATUAL WORD
    JRST INXREL		;DONE--EXIT
  MOVEI R1,1		;SET FLAG
;
 RBKIR1:
  HLRZ R1,CH		;GET FIRST LINK
  JUMPE R1,RBKT10	;NULL LIST--IGNORE
;
 RBKIR2:
  XCT RBIRTA(T1)	;GET NEXT LINK
  XCT RBIRTB(T1)	;SAVE VALUE
  SKIPE R1,R2		;CHECK IF DONE
    JRST RBKIR2		;LOOP IF MORE
  JRST RBKT10		;HANDLE NEXT REQUEST IF DONE
;
;
 RBIRTA:
  HRRZ R2,0(R1)		;LOWER
  HLRZ R2,0(R1)		;UPPER
;
;
 RBIRTB:
  HRRM CH,0(R1)		;LOWER
  HRLM CH,0(R1)		;UPPER
;
;
SUBTTL BINARY INPUT ROUTINES--TYPE 16--REQUIRE
;
;   RBKT16--THIS ROUTINE WILL CAUSE A FILE TO BE ADDRED AS IF
;      A LIBRARY STATEMENT APPEARED FOR IT.  RBKT17 (LIBRARY)
;      ALSO GOES HERE AS IS TREATED EXACTLY THE SAME.
;
;
RBKT16:
RBKT17:
;
  PUSHJ P,NXRWD		;GET FIRST WORD
    JRST INXREL		;IF DONE, THEN DONE
  PUSHJ P,SIXASC	;CONVERT TO ASCII
  PUSHJ P,NXRWD		;GET SECOND WORD
    JRST RBKILL		;WORDS COME IN TRIPLES
  PUSHJ P,NXRWD		;IGNORE 2ND, GET THIRD
    JRST RBKILL		;SHOULD BE THERE
;
  MOVE R2,TMPTL		;GET TALLY TO NAME
  MOVEM R2,GTFNAM	;SAVE FOR OPEN
  HRROI R2,[ASCIZ /REL/]	;DEFAULT EXTENSION
  MOVEM R2,GTFEXT	;TRY IT FIRST
  MOVEI R2,0		;GUESS HIS DIRECTORY
  CAMN CH,[SIXBIT 'SYS']	;CHECK FOR SYS:
    HRROI R2,[ASCIZ /SUBSYS/]	;SPECIAL IF SO
  MOVEM R2,GTFDIR	;SAVE DIRECTORY
  HRLZI R2,100000	;OLD FILE ONLY
  MOVEM R2,GTFLGS	;SAVE
  HRRZI R1,GTFBF	;PTR TO GTJFN BUFFER
  MOVEI R2,0		;NO STRING
  GTJFN			;TRY OPEINING FILE
    SKIPA		;FAIL
    JRST RBKRQ1		;SUCCESS--HANDLE
;
  HRROI R2,[ASCIZ /BAS/]	;ELSE TRY NON-COMPILED FORM
  MOVEM R2,GTFEXT	;SAVE EXTENSION DFLT
  HRRZI R1,GTFBF	;BUFFER PTR AGAIN
  MOVEI R2,0		;NO STRING
  GTJFN			;TRY TO GET THIS FILE
    JRST RBKRQ2		;STILL FAIL
;
 RBKRQ1:
  MOVE R2,[XWD 070000,200000]	;OPEN FOR READING ASCII
  OPENF			;GET OPEN
    JRST RBKRQ2		;FAIL IS BAD
  SETZM GTFDIR		;CLEAR DIRECTORY AGAIN
  PUSHJ P,NEWLIB	;HANDLE NEW LIBRARY
  JRST RBKT16		;AND THEN LOOP FOR ANOTHER FILE
;
 RBKRQ2:
  ERR E.RBKR		;ERROR IF CAN'T GET THE FILE
  JRST RBKT16		;AND CONTINUE WITH NEXT FILE
;
;
SUBTTL BINARY INPUT ROUTINES--NXRWD
;
;   NXRWD--THIS ROUTINE GETS THE NEXT RELOCATABLE WORD
;      FROM THE INPUT FILE, RELOCATAING IT AS APPROPRIATE.  IT
;      RETURNS TO 0(P) IF END OF BLOCK/END OF FILE OCCURS
;      AND TO 1(P) WITH THE WORD IN CH IF MORE DATA IS PRESENT.
;
;
NXRWD:
;
  SOSGE RBLKCT		;CHECK IF DONE BLOCK
    POPJ P,		;YES--JUST RETURN
  MOVE R1,IFLCNT	;CHECK IF DONE FILE
  SKIPN IFLLFT		;BY CHECKING FLAGS
  CAILE R1,1		;DEALING WITH INPUT
    SKIPA		;NOT END
    POPJ P,		;END--JUST RETURN
  SOSGE RRLCCT		;CHECK IF DONE THIS RELOC BLOCK
    JRST NXRWD2		;YES--GET RELOCATION WORD
;
 NXRWD3:
  AOS 0(P)		;DATA RETURN
  GTCHR CH		;GET BASIC WORD
  ILDB R1,RRLCTL	;GET NEXT RELOCATION ITEM
  TRNE R1,1		;CHECK FOR LOWER HALF RELOC
    ADD CH,STBASE	;RELOC IF SO
  TRNN R1,2		;CHECK FOR UPPER HALF RELOC
    POPJ P,		;DONE IF NOT
  HRLZ R1,STBASE	;IF SO, GET RELOC CONST
  ADD CH,R1		;DO RELOC
  POPJ P,		;AND DONE
;
 NXRWD2:
  GTCHR CH		;GET RELOCATION WORD
  MOVEM CH,RRLCWD	;SAVE IT
  MOVE R1,[POINT 2,RRLCWD]	;TALLY TO IT
  MOVEM R1,RRLCTL	;SAVE THAT
  MOVEI R1,22-1		;INITIAL COUNT
  MOVEM R1,RRLCCT	;SAVE THAT
  JRST NXRWD3		;AND THEN GET DATA WORD
;
;
SUBTTL BINARY INPUT ROUTINES--NXRBLK
;
;   NXRBLK--THIS ROUTINE IS CALLED WITH THE FIRST DATA
;      WORD FOR A BLOCK IN CH.  IT SETS UP THE BLOCK TYPE
;      AND COUNT IN PREPARATION FOR SCANNING THAT BLOCK.
;
;
NXRBLK:
;
  HRRZM CH,RBLKCT	;SAVE INITIAL COUNT
  SETZM RRLCCT		;NO RELOCATION NOW
  HLRZM CH,RBLKTY	;SAVE TYPE
  POPJ P,		;AND DONE
;
;
SUBTTL BINARY INPUT ROUTINES--CONVERSION
;
;   R50ASC--CONVERTS (CH) TO ASCII IN T5,T6 FROM RADIX50
;
;   R5ASCC--CONVERTS RADIX50 CHR (R2) TO ASCII CHR (R2)
;
;   SIXASC--CONVERTS SIXBIT (CH) TO ASCII IN TMPBF
;
;
R50ASC:
;
  MOVE R1,CH		;GET RADIX 50 WORD
  TLZ R1,740000		;MINUS EXTRA BITS
  MOVE T0,[POINT 7,T5]	;TALLY FOR ASCII
  SETZB T5,T6		;CLEAR ASCII RESULT
  PUSH P,[-1]		;PUT MARKER ON STACK
;
 R5ASC2:
  JUMPE R1,R5ASC1	;HANDLE DONE
  IDIVI R1,50		;ELSE GET NEXT CHR
  PUSHJ P,R5ASCC	;CONVERT ONE CHR
  PUSH P,R2		;SAVE IT
  JRST R5ASC2		;AND LOOP
;
 R5ASC1:
  POP P,R2		;RESTORE LAST CHR
  JUMPL R2,R5ASC3	;HANDLE DONE
  IDPB R2,T0		;SAVE CHR IN ASCII STRING
  JRST R5ASC1		;AND LOOP
;
 R5ASC3:
  POPJ P,		;THEN RETURN
;
;
;
;
R5ASCC:
;
  CAIE R2,RDXSPA	;CHECK FOR SPACE
  JRST .+3		;NO
    MOVEI R2,ASC.SP	;YES--GET IT
    POPJ P,		;AND RETURN IT
;
  CAILE R2,RDX..9	;CHECK FOR DIGIT
  JRST .+3		;NO
    MOVEI R2,ASC..0-RDX..0(R2)	;GET IT
    POPJ P,		;AND RETURN IT
;
  CAILE R2,RDX..Z	;CHECK FOR LETTER
  JRST .+3		;NO
    MOVEI R2,ASC..A-RDX..A(R2)	;GET IT
    POPJ P,		;AND RETURN IT
;
  MOVE R2,[EXP ASCDOT,ASCDOL,ASCPER]-RDXDOT(R2)	;ELSE GET PROPER VALUE
  POPJ P,		;AND RETURN IT
;
;
;
;
SIXASC:
;
  SETZM TMPBF		;CLEAR BUFFER
  SETZM TMPBF+1
  MOVE R1,CH		;GET COPY OF STRING
  MOVE T1,TMPTL		;OUTPUT TALLY
;
 SXASC2:
  LDB R2,[POINT 6,R1,5]	;GET NEXT CHR
    JUMPE R2,SXASC1	;HANDLE DONE
  ADDI R2,40		;TO ASCII
  IDPB R2,T1		;SAVE IN STRING
  LSH R1,6		;POSITION FOR NEXT CHR
  JRST SXASC2		;AND LOOP
;
 SXASC1:
  POPJ P,		;AND RETURN
;
;
;
;
;
    PRINTX *****START OF BAS57*****
;
;
SUBTTL INITIALIZATION ROUTINES--NSCAN
;
;   NSCAN--THIS ROUTINE IS THE USER FILE NAME SCAN.  IT GETS THE
;      VARIOUS FILES AND FILE NAMES AND SWITCHES FROM A LINE OF
;      USER INPUT.  THE FORMAT IS AS FOLLOWS:
;
;      <LINE>::=<FIELD>[,<FIELD>]*
;      <FIELD>::=<FILENAME>!<FILENAME>/BINARY!<FILENAME>/SAVE!
;                <FILENAME>/LIST!<FLAG>!<FILENAME>/CREF
;      <FLAG>::=DEBUG!TEST!XTEST!COMPILE!NCHECK!LOAD!GO!
;               NLIBRARYS!INIT!NDEBUG
;
;
;
RNSCAN:
	MOVNI R1,1	;MINUS ONE MEANS ALL FILES
 	CLOSF		;CLOSE AND RELEASE THEM
 	SETZM NRPGFG	;NOW ASK THE USER
	SKIPA P,NSCNP	;REEENTER ON ERROR/'INIT' FLAG
;
NSCAN:
	MOVEM P,NSCNP	;SAVE PDL AT START
	SETZM GTFNAM	;CLEAR FLAGS
	SETZM SRCJFN	;AND JFNS
	SETZM LSTJFN
	SETZM BINJFN
	SETZM DEBFG
	SETZM TESFG
	SETOM CGOFG
	SETZM SBCHK
	SETZM CRFFG
	SETZM LIBFG
	SETZM NMTAL
	SETZM ECHOFG	;CLEAR ECHO MODE
	MOVEI R2,SRCBUF+500	;PTR TO PLACE FOR ERROR STRINGS
	MOVEM R2,SERBFP	;SAVE PTR
;
	MOVEI R1,LIBBUF	;CLEAR LIBRARY BUFFER
	MOVEM R1,LIBPTR
	SETZM LIBLST
	SETZM LIBBUF
	MOVE R1,[XWD LIBBUF,LIBBUF+1]
	BLT R1,LIBBUF+777
	SETZM FSTLIB
	SETZM FSTJFN
;
	JRST NSCN0	;AND ENTER SCAN
;
;
;
;   NSCN0--MAIN LOOP OF NSCAN ROUTINE
;
;
NSCN0:
	MOVE R2,[POINT 7,SRCBUF]	;TALLY TO AREA FOR SOURCE STRING
  	MOVEM R2,INTAL	;SAVE INPUT TALLY
	SKIPE NRPGFG	;CHECK IF NAME PUT THERE ALREADY
	JRST NSCN4	;IF SO, SKIP READING IT
	HRROI R1,[BYTE (7)37,52]	;PROMPT
	PUSHJ P,INTTY		;GET USER INPUT
NSCN4:	MOVEI R2,0	;NO TERM INITIALLY
	SETZM NRPGFG	;READ CONTINUATION, ETC. FROM USER
NSCN1:	MOVEM R2,INTRM	;SAVE TERMINATOR
	CAIN R2,"/"	;CHECK FOR SWITCH
	JRST NSCSW	;HANDLE
	CAIE R2,"_"	;CHECK FOR '_'
	CAIN R2,"="	;CGECK FOR '='
	JRST NSCEQ	;HANDLE
	PUSHJ P,NSCSRC	;OLD FILE BECOMES SOURCE NOW
	CAIN R2,37	;EOL?
	JRST NSCEOL	;YES
	PUSHJ P,NSCNM	;ELSE SCAN A NAME
	JRST NSCN2	;HANDLE NO NAME HERE (DOUBLE TERMS)

NSCN3:	CAIN R2,"/"	;CHECK FOR SWITCH FOLLOWING NAME
	JRST NSCN1	;SWITCH FOLLOWS--SCAN IT
	PUSHJ P,NSCSRC	;ELSE SOURCE FILE
	JRST NSCN1	;AND SCAN NEXT ITEM

NSCN2:	MOVE R1,INTRM	;GET TERMINATOR
	CAIN R2,37	;CHECK FOR EOL FOUND
	CAIE R1,","	;AND COMMA BEFORE
	SKIPA
	JRST NSCN0	;YES--ALLOW NEW LINE (CONTINUATION)
	JRST NSCN1	;ELSE JUST IGNORE
;
;
;
;   NSCEQ--HANDLE EQUALS SIGN (BREAK OUTPUT FROM INPUT)
;
NSCEQ:
	SKIPE FSTJFN	;CHECK FOR PREVIOUS SOURCE FILE
	JRST NSCER1	;THEN USER SHOULDN'T HAVE '='
	PUSHJ P,NXTRM	;GET NEXT TERMINATOR
	JRST NSCN1	;AND CONTINUE
;
;
;
;   NSCEOL--HNALDE END OF SCAN
;
NSCEOL:
	SKIPN R1,FSTJFN	;CHECK FOR SOURCE FILE
	JRST NSCERD	;AT LEAST ONE
	MOVEM R1,SRCJFN	;SAVE
	JSP R5,GTOFIL	;GET OUTPUT FILE
	  EXP SAVJFN
	  ASCIZ /SAV/
	  XWD 440000,120000
	SKIPE R1,SAVJFN	;CHECK IF SAVE FILE PRESENT
	TLOA R1,400000	;IF SO, MARK FOR CLOSE W/O RELEASE
	SKIPA		;IF NOT, SKIP
	CLOSF		;IF SO, CLOSE IT W/O RELEASE
	TRN		;IGNORE BAD CLOSE/IF NOT, CONTINUE
	SKIPE CRFFG	;CHECK IF CREF
	  JRST NSEOL3	;HANDLE IF SO
	JSP R5,GTOFIL	;GET OUTPUT LIST FILE
 	  EXP LSTJFN
	  ASCIZ /LST/
	  XWD 070000,120000
	JRST NSEOL4	;AND SKIP
;
 NSEOL3:
  JSP R5,GTOFIL		;OPEN FOR CROSS REF
    EXP LSTJFN
    ASCIZ /CRF/
    XWD 070000,120000
;
 NSEOL4:
	JSP R5,GTOFIL	;GET OUTPUT BINARY FILE
	  EXP BINJFN
	  ASCIZ /REL/
	  XWD 440000,120000
;
;   CONSISTENCY CHECKS
;
  SKIPE DEBFG		;CHECK IF DEBUG MODE
  SKIPN SAVJFN		;AND SAVE FILE
    SKIPA		;NO
    JRST NSCER7		;YES--INCOMPATIBLE
;
 NSEOL1:
  SKIPE LIBFG		;CHECK IF LIBRARYS TO BE REQUIRED
  SETZM CGOFG		;DON'T EXECUTE IN THAT CASE
;
  SKIPE LSTJFN		;CHECK IF LISTING CALLED FOR
    JRST NSCERA		;WE WON'T PRODUCE ONE!!!
;
  SKIPE SAVJFN		;CHECK IF SAVING
    SETOM CGOFG		;IF SO, FORCE CODE GENERATION
;
 NSEOL2:

	MOVEI R1,37	;EOL
	SKIPE ECHOFG	;CHECK IF REDIRECT (NO ECHO)
	PBOUT		;SIGNIFY DONE TO USER
	POPJ P,		;AND RETURN
;
;
;
;   NSCWD--SCAN A WORD (SWITCH) AND PLACE TALLY IN WDTAL
;   NSCNM--SCAN A WORD (FILENAME) AND PLACE TALLY IN NMTAL
;
;
NSCWD:
  MOVE R2,INTAL	;GET TALLY
  MOVEM R2,WDTAL ;SAVE
  JRST NSCWD0 ;AND SKIP
;
;
NSCNM:
  MOVE R2,INTAL ;GET TALLY
  MOVEM R2,NMTAL ;SAVE
;
;
 NSCWD0:
  SETZM R3 ;CLEAR COUNTER
;
 NSCWD1:
  ILDB R2,INTAL	;GET NEXT CSOURCE CHR
  CAIE R2," "	;CHECK FOR SPACE/COMMA
  CAIN R2,","
    JRST NSCWD2	;HANDLE IF SO
  CAIE R2,"_"	;CHECK FOR BACKARROW
  CAIN R2,"/"	;CHECK FOR SLASH
    JRST NSCWD3
  CAIE R2,"="	;CHECK FOR = OR EOL
  CAIN R2,ASCEOL
    JRST NSCWD3
  AOJA R3,NSCWD1	;BUMP CHR COUNT NAD LOOP
;
 NSCWD2:
  MOVEI R1,0		;INDICATE END OF STRING
  DPB R1,INTAL
  PUSHJ P,NXTRM		;SKIP SERIES OF TERMS
  JRST NSCWD4		;AND SKIP
;
 NSCWD3:
  MOVEI R1,0		;INDICATE END OF STRING
  DPB R1,INTAL
;
 NSCWD4:
  MOVEM R2,NWTRM	;SAVE TERM
  SKIPE R3		;CHECK FOR ANY NAME SCANNED
    AOS 0(P)		;IF SO, BUMP RETURN
  POPJ P,		;THEN RETURN
;
;
;
;   NXTRM--SKIP SEQUENCES OF TERMINATORS
;
;
NXTRM:
  ILDB R2,INTAL		;GET NEXT CHR
  CAIE R2,"_"		;CHECK FOR _
  CAIN R2,"="		;CHECK FOR =
    POPJ P,		;RETURN IF SO
  CAIE R2,","		;CHECK FOR COMMA OR SPACE
  CAIN R2," "
    JRST NXTRM		;LOOP IF SO
  MOVSI R1,070000
  ADDM R1,INTAL		;BACK UP TALLY IF NOT TERM
  MOVEI R2,","		;FAKE COMMA TERMINATOR
  POPJ P,		;AND RETURN
;
;
;
;   NSCSW--SCAN A SWITCH AND ACT ON IT
;
NSCSW:
  PUSHJ P,NSCWD		;SCAN WORD
    JRST NSCER3		;BETTER BE ONE
;
 NSCSW0:
  MOVE R3,[IOWD NSWTBL+1,NSWTB]
  PUSHJ P,TBLOK		;TABLE LOOK UP SWITCH
  MOVEI R1,1		;PTR TO IT IN R5, GET A ONE
  XCT NSWACT-1(R5)	;TAKE ACTION ON SWITCH
  JRST NSCN1		;AND DONE
;
;
 TBLOK:
  SETZM FLGNM		;CLEAR NAME STORE
  PUSH P,R2		;SAVE R2 (LAST CHR)
  MOVEI R5,0		;INITIAL COUNTER
;
 TBLOK5:
  AOBJP R3,TBLOK1	;CHECK IF NDONE--GET NEXT PTR
  AOS R5		;AND COUNT TO GO WITH IT
  MOVE R4,0(R3)		;AND GET ITEM TALLY
  MOVE R2,WDTAL		;GET FLAG TALLY
;
 TBLOK4:
  ILDB R0,R4		;GET NEXT ITEM CHR
  JUMPE R0,TBLOK2	;HANDLE DONE ITEM
  ILDB R1,R2		;GET NEXT USER CHR
  JUMPE R1,TBLOK3	;HANDLE DONE USER
;[EDIT]ADD CHECK FOR LOWER CASE AND RAISE  BY LIEB
  CAIL R1,141		;IS IT LOWER CASE?
  SUBI R1,40		;YES, MAKE IT UPPER  END [EDIT]
  CAMN R1,R0		;CHECK FOR MATCH
    JRST TBLOK4		;MATCH--HANDLE NEXT CHR
  JRST TBLOK5		;NO MATCH--TRY NEXT
;
 TBLOK2:
  ILDB R1,R2		;END OF GIVEN--CHECK USER
  JUMPN R1,TBLOK5	;NOT END--NO MATCH
;
 TBLOK3:
  SKIPE FLGNM		;MATCH--CHECK FOR AMBIGUOUS
    JRST NSCER5		;HANDLE THAT ERROR
  MOVEM R5,FLGNM	;SAVE MATCH NUMBER
  JRST TBLOK5		;AND MAKE SURE ITS THE ONLY ONE
;
 TBLOK1:
  POP P,R2		;RESTORE CHR
  SKIPN R5,FLGNM	;CHECK FOR MATCH AT ALL
    JRST NSCER4		;OR ELSE ERROR
  POPJ P,		;AND DONE
;
;
;   SWITCH TABLES
;
;
;      NAMES
;
DEFINE SWCMD (NAM)
<
	POINT 7,[ASCIZ /NAM/]
>
;
;
NSWTB:
  SWCMD DEBUG
  SWCMD TEST
  SWCMD XTEST
  SWCMD COMPILE
  SWCMD SAVE
  SWCMD BINARY
  SWCMD RELOCATABLE
  SWCMD NCHECK
  SWCMD CREF
  SWCMD LIST
  SWCMD LOAD
  SWCMD GO
  SWCMD NLIBRARYS
  SWCMD INIT
  SWCMD NDEBUG
  SWCMD HELP
NSWTBL== .-NSWTB
;
;
;      ACTIONS
;
NSWACT:
  SETOM DEBFG		;DEBUG
  SETOM TESFG		;TEST
  MOVEM R1,TESFG	;XTEST
  SETZM CGOFG		;COMPILE
  PUSHJ P,NSCSAV	;SAVE
  PUSHJ P,NSCBIN	;BINARY
  PUSHJ P,NSCBIN	;REL
  SETOM SBCHK		;NCHECK
  PUSHJ P,NSCCRF	;CREF
  PUSHJ P,NSCLST	;LIST
  MOVEM R1,CGOFG	;LOAD
  SETOM CGOFG		;GO
  SETOM LIBFG		;NLIBRARYS
  JRST RNSCAN		;INIT
  SETZM DEBFG		;NDEBUG
  JRST NHELP		;HELP
;
;
;
;   NHELP--PRINT HELPFUL INFO AND RESTART
;
NHELP:
;
  HRROI R2,[ASCIZ /<DOC>TBASIC.HELP/]	;HELP FILE
  MOVSI R1,100001	;BITS FOR OPEN
  GTJFN
    JRST NHELPA
  MOVE R3,R1
  MOVE R2,[XWD 070000,200000]
  OPENF
    JRST NHELPB
  MOVEI R3,101		;JFN FOR FILE--R1; TTY--R3
;
 NHELP2:
  BIN			;GET CHR
  MOVE R4,R2
  GTSTS			;CHECK FOR EOF
  TLNE R2,001000
    JRST NHELP1		;HANDLE DONE
  MOVE R2,R4
  EXCH R1,R3		;PRINT CHR TO TTY
  BOUT
  EXCH R1,R3
  JRST NHELP2		;AND LOOP
;
 NHELP1:
  CLOSF			;CLOSE FILE WHEN DONE
    TRN
;
 NHELP3:
  HRROI R1,[BYTE (7)37,37,37]
  PSOUT			;FEW LINE FEEDS
  JRST RNSCAN		;AND RESTART
;
 NHELPB:
  MOVE R3,R1		;RESTORE JFN
;
 NHELPA:
  CLOSF			;CLOSE FILE ON ERROR
    TRN
  MOVEI R1,37		;EOL
  PBOUT		;PRINT IT
  PBOUT
  HRROI R1,[ASCIZ /I CAN'T HELP YOU/]
  PSOUT			;DEFAULT MESSAGE
  JRST NHELP3		;RESTART ANYWAY
;
;
;
;   NSCSRC--MAKE FILE JUST SCANNED A SOURCE FILE
;
;
NSCSRC:
  SKIPN R1,NMTAL	;WAS THERE A FILE?
    POPJ P,		;NO--IGNORE REQUEST
  ILDB R1,R1		;CHECK FIRST CHR
  SKIPN R1		;FOR A NULL
    POPJ P,		;WHICH CASE SHOULD ALSO BE IGNORED
;
  PUSH P,R2		;SAVE R2
  HRROI R1,[ASCIZ /BAS/]
  MOVEM R1,GTFEXT
  HRROI R1,[ASCIZ /REL/]	;DEFAULT NAME (2ND) IS .REL
  MOVEM R1,GTFXXT	;SAVE AS EXTRA EXTENSION
  MOVSI R1,100000
  MOVEM R1,GTFLGS
  MOVE R1,[XWD 070000,200000]
  MOVEM R1,GTFOBT
  PUSHJ P,GTFILE	;GET AND OPEN THE FILE
;
  PUSHJ P,NEWLIB	;ENTER IT AS LIBRARY
  JUMPE R1,NSCRC1	;CHECK IF FIRST (STILL HAVE JFN)
  MOVE R2,FSTLIB	;IF SO, GET LIB PTR
  HRROI R2,LBNAM(R2)	;GET NAME PTR
  MOVEM R2,GTFNAM	;SAVE AS DEFAULT
;
 NSCRC1:
  SETZM NMTAL		;CLEAR TALLY TO NAME
  POP P,R2		;RESTORE R2
  POPJ P,		;AND DONE
;
;
;
;   NSCBIN--MAKE CURRENT FILE GIVEN A BINARY FILE
;
;
NSCBIN:
  SKIPN R1,NMTAL	;GET TALLY
    MOVEI R1,1		;DUMMY TALLY
  SETZM NMTAL		;CLEAR TALLY TO INDICATED USED
  EXCH R1,BINJFN	;SAVE AS BINARY FILE
  JUMPN R1,NSCER9	;BETTER BE FIRST ONE
  POPJ P,		;AND DONE
;
;
;   NSCSAV--MAKE CURRENT FILE GIVEN THE SAVE FILE
;
NSCSAV:
  SKIPN R1,NMTAL	;GET TALLY
    MOVEI R1,1		;DUMMY TALLY
  SETZM NMTAL		;CLEAR TALLY TO INDICATED USED
  EXCH R1,SAVJFN	;SAVE AS SAVE JFN
  JUMPN R1,NSCER8	;BETTER BE FIRST ONE
  POPJ P,		;AND DONE
;
;
;   NSCCRF--MAKE CURRNET FILE GIVEN THE CREF FILE
;   NSCLST--MAKE CURRENT FILE GIVEN THE LIST FILE
;
NSCCRF:
  SETOM CRFFG		;INDICATE CREF
;
NSCLST:
  SKIPN R1,NMTAL	;GET TALLY TO FILE NAME
    MOVEI R1,1		;DUMMY TALLY
  SETZM NMTAL		;CLEAR TO INDICATE USED
  EXCH R1,LSTJFN	;SAVE AS LIST FILE
  JUMPN R1,NSCERB	;BETTER BE FIRST
  POPJ P,		;AND DONE
;
;
;
;   GTOFIL--GET AND OUTPUT FILE JFN AND OPEN AND SAVE
;
;
GTOFIL:
;
  SKIPN R1,@0(R5)	;CHECK IF NAME GIVEN
    JRST 3(R5)		;NO--RETURN
  CAIN R1,1		;CHECK IF DUMMY FOR NULL
    MOVEI R1,0		;MAKE NULL
  MOVEM R1,NMTAL	;SAVE FOR OPEN
  HRROI R1,1(R5)		;GET EXTENSION
  MOVEM R1,GTFEXT
  SETZM GTFXXT		;NO SECOND EXTENSION TO TRY
  MOVSI R1,400000	;BITS FOR GTJFN
  MOVEM R1,GTFLGS
  MOVE R1,2(R5)		;GET BITS FOR OPEN
  MOVEM R1,GTFOBT
  PUSHJ P,GTFILE	;GET JFN AND OPEN FILE
  MOVEM R1,@0(R5)	;SAVE THE JFN WE GOT
  SETZM NMTAL		;NO FILE AGAIN
  JRST 3(R5)		;AND RETURN
;
;
;
;   GTFILE--GET JFN AND OPEN CURRENT FILE
;
;
GTFILE:
  PUSH P,R2		;SAVE R2
  MOVEI R1,GTFBF	;BUFFER FO DEFAULTS
  MOVE R2,NMTAL		;TALLY TO NAME
  GTJFN			;GET THE JFN
    JRST GTFIL1		;ERROR
;
  PUSH P,R1		;SAVE JFN ON STACK FOR ERROR
  MOVE R2,GTFOBT	;GET BITS FOR OEPN
  OPENF			;OPEN FILE
    JRST GTFIL2		;HANDLE ERROR
  POP P,R1		;RESTORE JFN
  POP P,R2		;RESTORE R2
  POPJ P,		;AND RETURN
;
 GTFIL2:
  EXCH R1,0(P)		;SAVE ERROR, GET JFN
  CLOSF			;CLOSE THE FILE AGAIN
    TRN
  POP P,R1		;RESTORE ERROR
  JRST NSCERC		;HANDLE ERROR
;
 GTFIL1:
  SKIPN R2,GTFXXT	;CHECK FOR EXTRA EXTENSION
    JRST NSCERC		;NO--ERROR THEN
  SETZM GTFXXT		;YES--DON'T REPEAT LOOP
  MOVEM R2,GTFEXT	;SAVE EXTENSION
  POP P,R2		;RESTORE R2 ON ENTRY
  JRST GTFILE		;AND REENTER
;
;
;
;  NSCER#--THE ERROR ROUTINE ERNTRIES
;
;
NSCER1:
NSCER3:
  HRROI R1,[ASCIZ /Illegal syntax in file specification--restart/]
  MOVEI R2,0
  MOVEI R0,RNSCAN	;RESTART ADDRESS
  JRST NSCERR
;
;
NSCERD:
  HRROI R1,[ASCIZ /No source file given--restart/]
  MOVEI R2,0
  MOVEI R0,RNSCAN
  JRST NSCERR
;
;
NSCER4:
  HRROI R1,[ASCIZ /Switch not recognized--/]
;
 NSCR4A:
  MOVE R2,WDTAL
  HRROI R3,[ASCIZ /--Reenter switch/]
  MOVEI R4,0
  MOVEI R0,NSCESW
  JRST NSCERR
;
;
NSCER5:
  HRROI R1,[ASCIZ /Switch name ambiguous--/]
  JRST NSCR4A
;
;
NSCER6:
  HRROI R1,[ASCIZ /File scan aborted--restart/]
  MOVEI R2,0
  MOVEI R0,RNSCAN
  JRST NSCERR
;
;
NSCER8:
  HRROI R1,[ASCIZ /save/]
  SKIPA
;
NSCER9:
  HRROI R1,[ASCIZ /binary/]
  SKIPA
;
NSCERB:
  HRROI R1,[ASCIZ /list/]
  MOVEM R2,INTRM
  MOVE R2,R1
  HRROI R1,[ASCIZ /Two /]
  HRROI R3,[ASCIZ / files given--second used/]
  MOVEI R4,0
  MOVEI R0,NSCN4
  JRST NSCERR
;
;
NSCERC:
  HRROI R1,[ASCIZ /Couldn't open file /]
  MOVE R2,NMTAL
  HRROI R3,[ASCIZ /--reenter file name/]
  MOVEI R4,0
  MOVEI R0,NSCEFL
  JRST NSCERR
;
;
NSCER7:
  HRROI R1,[ASCIZ /Can't save DEBUG version--NDEBUG assumed/]
  MOVEI R2,0
  SETZM DEBFG
  MOVEI R0,NSEOL1
  JRST NSCERR
;
;
NSCERA:
  HRROI R1,[ASCIZ /No listing will be produced/]
  MOVEI R2,0
  MOVEI R0,NSEOL2
  JRST NSCERR
;
;
;
;   NSCERR--ERROR MESSAGE ROUTINES
;
;
NSCERR:
  PUSH P,R1		;SAVE R1
  HRROI R1,[BYTE (7)37,37]
  PSOUT			;PREFIX MESSAGE
  MOVEI R1,101		;TTY JFN
  DOBE			;WAIT FOR OUTPUT TO FINISH
  MOVEI R1,100		;TTY INPUT JFN
  CFIBF			;AND THEN IGNORE REST OF USER INPUT
  POP P,R1
;
 NSCRR1:
  PSOUT			;PRINT FIRST PART OF MESSAGE
  MOVE R5,[XWD R2,R1]
  BLT R5,R3		;GET NEXT PART OF MESSAGE
  JUMPN R1,NSCRR1	;HANDLE IF PRESENT
  JRST @R0		;ELSE GO TO PROPER PLACE
;
;
;   NSCESW--REENTER SWITCH NAME
;
NSCESW:
  PUSHJ P,NSCEWD	;GET WORD
    JRST NSCER6		;HANDLE ABORT SCAN
  MOVEM R1,WDTAL	;SAVE TALLY
  ILDB R2,R1		;CHECK FIRST CHR
  CAIN R2,"/"		;FOR '/' (USER TYPED IN /
    MOVEM R1,WDTAL	;IF SO, THEN IGNORE IT
  MOVE R2,NWTRM		;RESTORE R2
  MOVE P,NSCNP		;RESTORE PDL
  JRST NSCSW0		;AND CONTINUE MAIN SCAN
;
;
;   NSCEFL--REENTER FILE NAME
;
NSCEFL:
  PUSHJ P,NSCEWD	;GET WORD
    JRST NSCER6		;ABORT IF REQUESTED
  MOVEM R1,NMTAL	;SAVE TLALY
  MOVE R2,NWTRM		;AND RESTORE R2
  MOVE P,NSCNP		;RESTORE PDL
  JRST NSCN3		;FINALLY CONTINUE
;
;
;
;   NSCEWD--READ WORD FOR ERROR MESSAGE RESPONSE
;
;
NSCEWD:
  HRROI R1,[BYTE (7)37,52,52]
  MOVE R2,SERBFP	;GET TALLY TO READ IN AREA AND PROMPT
  HRLI R2,440700	;COMPELTE TALLY
  PUSH P,R2		;SAVE TALLY
  PUSH P,INTAL		;SAVE CURRENT TALLY
  PUSHJ P,INTTY		;READ STRING FROM USER
  POP P,INTAL		;RESTORE CURRENT TALLY
  MOVE R2,0(P)		;RESTORE TALLY
  MOVEI R3,0		;CLEAR CHR COUNTER
;
 NSCEW2:
  ILDB R1,R2	;GET NEXT CHR
  CAIE R1,37		;CHECK FOR EOL
  AOJA R3,NSCEW2	;IF NOT, LOOP
  MOVEI R1,0		;IF SO, GET END MARKER
  DPB R1,R2		;SAVE
  ADDI R2,2		;SEPARATION SPACE
  HRRZM R2,SERBFP	;SAVE FOR NEXT ERROR
  POP P,R1		;RESTORE TALLY
  SKIPE R3		;CHECK IF ANY CHRS GIVEN
  AOS 0(P)		;IF SO, ALLOW USING IT FRO RETRY
  POPJ P,		;AND RETURN
;
;
SUBTTL NAME SCAN ROUTINES--INTTY
;
;   INTTY.--THIS ROUTINE READS A FILE FROM THE TTY INTO
;      THE BUFFER FOR THE FILE.  IT DOES LINE EDITING
;      ALA TENEX, SOS, ETC.
;
;
INTTY:
;
  PUSH P,R1 ;SAVE PROPMT
  PUSH P,R2	;AND TALLY
;
 INTY7:
  MOVEI R1,101 ;GET JFN
  MOVEI R2,170120	;BITS FOR INPUTTING FROM TTY
  SFMOD
  MOVE R2,-1(P) ;PROMPT STRING
  MOVEI R3,0 ;UNTIL NUL
  SOUT ;PRINT THE STRING
  SETOM ECHOFG		;ASSUME WE'RE ECHOING
  MOVEI R1,100		;INPUT JFN
  DVCHR			;CHECK FOR TTY
  TLNE R1,600000	;BY LOOKING AT DEVICE
    SETZM ECHOFG	;FLAG IF NOT TTY (NO ECHO)
;
  MOVE R2,0(P)		;GET TALLY
  MOVEM R2,INTAL ;SAVE TALLY FOR INPUTTING
  MOVEI R3,0 ;CLEAR CHR COUNT
;
 INTY6:
  MOVEI R1,100 ;GET INPUT JFN
  BIN ;READ NEXT CHR
  CAIN R2,177 ;CHECK FOR RUN OUT (DELETE)
    JRST INTY2 ;DELETE CHR
  CAIL R2,40 ;CHECK FOR CONTROL
    JRST INTY1 ;NON-CONTROL--USE
  CAIN R2,ASCEOL ;CHECK FOR EOL
    JRST INTY5 ;HANDLE
  CAIN R2,1 ;CHECK FOR ^A
    JRST INTY2 ;DELETE CHR
  CAIN R2,30 ;CHECK FOR ^X
    JRST INTY3 ;DELETE LINE
  CAIN R2,25	;CHECK FOR ^U
    JRST INTY3	;DELETE LINE
  CAIN R2,21 ;CHECK FOR ^Q
    JRST INTY3 ;DELETE LINE
  CAIN R2,22 ;CHECK FOR ^R
    JRST INTY4 ;RETYPE LINE
  CAIN R2,ASC.CR	;CHECK FOR CR
    JRST INTY6		;IGNORE IF SO
  CAIN R2,ASC.LF ;CHECK FOR LINE FEED
    JRST INTY5 ;HANDLE SPECIAL IF SO
  JRST INTY1 ;ELSE USE AS INPUT
;
;   USE THIS CHR
;
 INTY1:
  IDPB R2,INTAL ;SAVE CHR
  CAIN R2,33 ;CHECK FOR ESCAPE
    MOVEI R2,"$" ;ECHO DOLLAR SIGN FOR IT
  MOVEI R1,101 ;GET OUTPUT JFN
  SKIPE ECHOFG		;MAKE SURE WE'RE ECHOING
    BOUT ;ECHO CHR
  AOS R3 ;UPDATE COUNT
  JRST INTY6 ;AND TRY AGAIN
;
;   DELETE LAST CHR
;
 INTY2:
  SOJL R3,INTY3 ;CHECK FOR NEW LINE NEEDED
  MOVEI R1,101 ;GET OUTPU JFN
  MOVEI R2,"\" ;CHR TO INDICATE DELETE
  BOUT ;PRINT
  LDB R2,INTAL ;GET LAST CHR
  BOUT ;PRINT
  MOVS R2,INTAL ;GET TALLY
  ADDI R2,070000 ;BACK UP ONE
  TRNE R2,400000 ;CHECL FOR WORD BOUNDARY
  SUB R2,[XWD 1,430000] ;GET IN PREVIOUS WORD
  MOVSM R2,INTAL ;RESAVE TALLY
  JRST INTY6 ;AND HANDLE NEXT CHR
;
;   DELETE LINE
;
 INTY3:
  MOVEI R1,101 ;GET JFN FOR OUTPUT
  MOVEI R2,"_" ;CHR
  BOUT ;PRINT
  BOUT ;IT
  BOUT ;THREE TIMES
  MOVEI R2,ASCEOL ;NEW LINE
  BOUT ;PRINT
  JRST INTY7 ;AND READ NEW LINE
;
;   RETYPE LINE
;
 INTY4:
  MOVE R0,R3 ;GET COUNT THUS FAR
  MOVEI R1,101 ;GET OUTPUT JFN
  MOVEI R2,ASCEOL ;NEW LINE
  BOUT ;FORCEIOUT
  HRRO R2,0(P) ;GET TALLY
  SOUT ;PRINT THE STRING WE HAVE
  MOVE R3,R0 ;RESTORE COUNT
  JRST INTY6 ;AND NEXT
;
;   END OF INPUT
;
 INTY5:
  MOVEI R2,ASCEOL	;FAKE EOL NO MATTER WHAT TERM CHR WAS
  IDPB R2,INTAL ;SAVE LAST CHR
  POP P,INTAL ;SET UP TALLY
  POP P,R1 ;GET RID OF PROMPT
  POPJ P,	;AND RETURN
;
;
;
;
    PRINTX *****START OF BAS90*****
;
;
  SUBTTL COMPILER STORAGE--INTERRUPT ROUTINES
;
;
;
 FLTRGS:BLOCK 20       ;REGISTERS ON FAULT
 ERREGS:BLOCK 20       ;REGISTERS ON ERROR
 FLTLOC:BLOCK 1		;PC ON LAST FAULT
;
;
;
;   ERROR MESSAGE PROCESSING
;
ERLNM: BLOCK 1 ;LAST SUB NAME USED
ERLPG: BLOCK 1 ;LAST PAGE NUMBER USED
ERJFN: BLOCK 1 ;LAST JFN USED
ERBUF: BLOCK 2 ;TEMP BUFFER
XLNNO: BLOCK 1 ;EXTRA LINE NUMBER
;
;
  SUBTTL COMPILER STORAGE--GENERAL INFORMATION
;
;
;
 MAINFG:EXP 0          ;FLAG FOR MAIN PROGRAM PRESENT
 EOFFG:BLOCK 1         ;END OF FILE FLAG
;
;
 MOVSIZ:EXP 1*1000     ;LENGTH OF MOVES
;
 TIMEC: BLOCK 1 ;TIME CONST PTR FOR TIME STATEMENT
;
;
;
;   OPEN FILE ROUTINE STORAGE
;
GTFBF:
;
  GTFLGS: XWD 400000,0	;FLAGS
	  XWD 377777,377777	;JFNS
	  EXP 0		;DEVICE
  GTFDIR: EXP 0		;DIRECTORY
  GTFNAM: BLOCK 1	;DEFAULT NAME
  GTFEXT: BLOCK 1	;DEFAULT EXT
 	  EXP 0,0,0	;PROTECTION, ACCOUNT, JFN DESIRED
;
 GTFOBT: BLOCK 1	;OPEN BITS
  INTAL: BLOCK 1	;INPUT TALLY
 INTRM: BLOCK 1		;TERMINATOR
 WDTAL: BLOCK 1		;WORD TALLY
 NMTAL: BLOCK 1		;NAME TALLY
 NSCNP: BLOCK 1		;SAVE PDL
 FLGNM: BLOCK 1		;FLAG FOUND (NUMBER)
 SERBFP: BLOCK 1	;ERROR POINTER LOC
 NRPGFG: BLOCK 1	;DATA ALREADY READ FLAG (CHAIN)
 NWTRM:	BLOCK 1		;TERM AFTER LAST WORD
 GTFXXT: BLOCK 1	;EXTRA EXTENSION TO TRY
 ECHOFG: BLOCK 1	;FLAG TO INDICATE ECHO OR NOT
;
;
;
  SUBTTL COMPILER STORAGE--STORAGE LAYOUT
;
;
;
;
 ULINTB:BLOCK 1        ;START OF UNDEFINED LINE NUMBER TABLE
 ULNPT:BLOCK 1         ;CURRENT PTR (END) OF IT
;
 LINETB:BLOCK 1        ;TOP OF LINE NUMBER TABLE
 LNNMS:BLOCK 1         ;BOTTOM (GROWS DOWN) OF IT
;
  CRELOC: BLOCK 1 ;BOTTOM OF CONST RELOCS
  CRLCPT: BLOCK 1 ;TALLY FOR CONST RELOCS
  CRLCNT:BLOCK 1 ;COUNT FOR CONST RELOCS
;
 CONST:BLOCK 1         ;BOTTOM OF CONTANT AREA
 CNSTK:BLOCK 1         ;TOP OF AREA
 CNSTCT:BLOCK 1        ;NEG COUNT OF WORDS REMAINING
;
 RELOCS:BLOCK 1        ;BASE OF RELOCS
 RLCNT:BLOCK 1         ;NEG COUNT O SPACE REMAINING
 RLCPT:BLOCK 1         ;TOP (ACTIVE PTR) OF AREA
;
 OBJCOD:BLOCK 1        ;BASE OF OBJECT CODE
 OBJTL:BLOCK 1         ;TOP OF AREA (ACTIVE)
 OBJPT:BLOCK 1         ;RELATIVE ADDRESS INTO AREA
 OBJCNT:BLOCK 1        ;NEG NUMBER OF WORDS REMAINING TO BE FILLED
;
 SAVEP: BLOCK 1 ;INITIAL PDL
;
;
;
  SUBTTL COMPILER STORAGE--CODE GENERATION
;
;
;
NUMNVR: BLOCK 1 ;NUMBER OF NUM VARS
NUMSVR: BLOCK 1 ;NUMBER OF STR VARS
NUMMAT: BLOCK 1 ;NUMBER OF MATS
NUMFCT: BLOCK 1 ;NUMBER OF FCTS
NUMLIN: BLOCK 1 ;NUMBER OF LINES
NUMSUB: BLOCK 1 ;NUMBER OF SUB CALL REFS
NUMLRQ: BLOCK 1 ;NUMBER OF REQUIRED LIBRARYS
;
;
OTBUF: BLOCK 22+2 ;BUFFER FO HOLDING 18 WORD SUBBLOCKS
;
;
ENTADD: BLOCK 1 ;ENTRY ADDRESS
;
;
  SUBTTL COMPILER STORAGE--LINE SCAN ROUTINES
;
;
;
 ULNLS:BLOCK 1         ;LIST OF UNDEFINED LINE NUMBERS
 ULNFR:BLOCK 1         ;LIST OF FREE UNDF LINE NO BLOCKS
;
 STADD:BLOCK 1         ;ADDRESS OF CURRENT STATEMENT
;
 FCTLIN:BLOCK 1        ;LINE NUMBER OF HEAD OF FUNCTION
;
 LNHDPT: BLOCK 1 ;LINE HEADER PTR
 LNHDRP: BLOCK 1 ;LINE HEADER RELOC PTR
;
 OLDPDL: BLOCK 1 ;OLD PDL FOR ERROR RECOVERY
;
;
  SUBTTL COMPILER STORAGE--ARITHMETIC SCAN
;
;
;
;
 REGFGS:BLOCK 1        ;USED REGISTERS
 REGUSD:BLOCK 1        ;USED REGISTERS OVER WHOLE ROUTINE
 ARTERM:BLOCK 1        ;TERMINATOR
 ALWTRM: BLOCK 1 ;ALLOWED TERMINATORS
;
  FSTARG: BLOCK 1 ;FIRST ARG SAVE
;
 XNSBCS:BLOCK 1        ;NUMBER SUBSCRIPTS ASSUMED
  SBCERF: BLOCK 1 ;FLAG TO ENFORCE XNSBCS
;
 CONPT:POINT 36,CONBF  ;POINTER TO CONSTANT BUFFER
 CONBF:BLOCK 100       ;CONSTANT BUFFER
 CONBND:
;
 ARVST:BLOCK 100       ;VARIABLE STACK (VS)
;
 AROST:BLOCK 100       ;OPERATIONS STACK (OS)
;
 NUMBF:BLOCK 20        ;BUFFER FOR ACCUMULATING NUMBERS
 NUMTL:POINT 7,NUMBF   ;TALLY FOR IT
;
 TEMP:BLOCK 1          ;TEMPORARY
 XTEMP:BLOCK 1         ;TEMP
 SAVT0:BLOCK 1         ;LOC FOR SAVING T0
 SAVT1:BLOCK 1         ;LOC FOR SAVING T1
;
 PRIFG: BLOCK 1 ;FLAG TO INDICATE PRINT EXPRESSION
 CHNGFG: BLOCK 1 ;FLAG TO INDICATE CHANGE EXPRESSION
;
 ARGSPT: BLOCK 1 ;GCALL PTR TO LAST ARGS
;
 TMPFGS: BLOCK 1 ;TEMPROARY AVAILABLE FLAGS
 TMPTB: BLOCK 44 ;TEMPORARY LOCATION TABLE
;
;
  SUBTTL COMPILER STORAGE--STATEMENT ROUTINES
;
;
;
 TEMPA:BLOCK 1         ;TEMPORARIES
 TEMPB:BLOCK 1
 TEMPC:BLOCK 1
 TEMPD:BLOCK 1
 TEMPE:BLOCK 1
;
 LOCA: BLOCK 1 ;LOCATION TEMPS
 LOCB: BLOCK 1
;
FILUSD: BLOCK 1 ;FILES USED FLAG
MTRDMF: BLOCK 1 ;MAT I/O--REDIM ALLOWED FLAG
;
 MAT.CH: EXP 0 ;EXTRA CHR SCANNED BY MAT RTNS
;
;
;
 NDATP:EXP 0           ;NUMERIC DATA POINTER
    EXP    0
 SDATP:EXP 0           ;STRING DATA POINTER
    EXP    0
;
;
 MATDTB:
  BLOCK 32	;A()...Z() DIMENSIONS
  BLOCK 32	;A$()...Z$() DIMENSIONS
;
;
 UFCLTB:
  BLOCK 32	;FNA...FNZ  UNDEFINED LINKED LISTS
  BLOCK 32	;FNA$...FNZ$ UNDEFINED LINKED LISTS
;
;
SUBTTL COMPILER STORAGE--SUBS
;
;
;
 NSUBS: BLOCK 1 ;NUMBER OF SUBS
 CRSUB: BLOCK 1 ;CURRENT SUB BLOCK PTR
 NSBARG: BLOCK 1 ;NUMBER OF ARGS SCANNED
 CSBARG: BLOCK 5 ;BLOCK FOR CURRENT ARG TYPES
 CSBART: BLOCK 1 ;TALLY TO CURRENT ARGS
 CALFG: BLOCK 1 ;CAL/SUB FLAG
 SBFLTB: BLOCK 20 ;FILE NUMBER TABLE
;
;
SUBTTL COMPILER STORAGE--BINARY FILE INPUT
;
;
;
 IFLTYP: BLOCK 1	;TYPE OF FILE (0-ASCII,<>0-BINARY)
 RBLKCT: BLOCK 1	;COUNT OF WORDS LEFT IN BLOCK
 RRLCCT: BLOCK 1	;COUNT OF WORDS IN RLC BLOCK
 RRLCTL: BLOCK 1	;TALLY TO RELOCATION BYTES
 RRLCWD: BLOCK 1	;CURRENT RELOCATION WORD
 RBLKTY: BLOCK 1	;BLOCK TYPE
 RBASFG: BLOCK 1	;BASIC PRGM/NON BASIC
 RSTTAL: BLOCK 1	;STORING TALLY
;
;
SUBTTL COMPILER STORAGE--LIBRARY ROUTINES
;
;
;
 XLBJFN: BLOCK 1	;JFN ON NEWLIB ENTRY
 TMPTL: POINT 7,TMPBF	;TALLY TO TEMP BUFFER
 TMPBF: BLOCK 14	;TEMP AREA FOR NAMES FOR NEWLIB
;
;
;
    PRINTX *****START OF BAS91*****
;
;
SUBTTL ARITHMETIC SCAN--FUNCTION NAME TABLE
;
;   FCTNTB--TABLE OF INTERNAL FUNCTION NAMES
;
 FCTNTB:
    ASCII  /ABS/
    ASCII  /ATN/
    ASCII  /CHR$/
    ASCII  /CLK$/
    ASCII  /COS/
    ASCII  /COT/
    ASCII  /DAT$/
    ASCII  /DET/
    ASCII  /EXP/
    ASCII  /INT/
    ASCII  /LEN/
    ASCII  /LOG/
    ASCII  /MOD/
    ASCII  /NUM/
    ASCII  /POS/
    ASCII  /RND/
    ASCII  /SEG$/
    ASCII  /SGN/
    ASCII  /SIN/
    ASCII  /SQR/
    ASCII  /STR$/
    ASCII  /TAN/
    ASCII  /TIM/
    ASCII  /USR$/
    ASCII  /VAL/
;
;   FILE FUNCTIONS
;
 FCTNFL:
    ASCII  /LOC/       ;THESE TAKE FILE NUMBER AS FIRST ARG
    ASCII  /LOF/
    ASCII  /MAR/
    ASCII  /PER/
    ASCII  /TYP/
;
;
    FCTLN== .-FCTNTB   ;LENGTH
;
;
;
;
;   MATRIX FUNCTIONS
;
 MFCNTB:
    ASCII  /CON/
    ASCII  /IDN/
    ASCII  /INV/
    ASCII  /NUL$/
    ASCII /TRN/		;STRING TANSPOSE (CAN'T MATCH)
    ASCII  /TRN/
    ASCII  /ZER/
;
    NMFCT== .-MFCNTB
;
;
;   PRINT FCTS
;
PFCNTB:
  ASCII /TAB/
  ASCII /LIN/
  ASCII /PAG/
;
NPFCT== .-PFCNTB ;NUMBER
SUBTTL ARITHMETIC SCAN--FUNCTION VALUE TABLE
;
;   FCTATB--TABLE OF INTERNAL FUNCTION DEFINITIONS
;
 FCTATB:
    DFN ABS.,N,1,N,, ;ABS
    DFN ATN.,N,1,N,, ;ATN(N)
    DFN CHR.,S,1,N,, ;CHR$(N)
    DFN CLK.,S,0,,,  ;CLK$
    DFN COS.,N,1,N,, ;COS(N)
    DFN COT.,N,1,N,, ;COT(N)
    DFN DAT.,S,0,,,  ;DAT$
    DFN DET.,N,0,,,  ;DET
    DFN EXP.,N,1,N,, ;EXP(N)
    DFN INT.,N,1,N,, ;INT(N)
    DFN LEN.,N,1,S,, ;LEN(S$)
    DFN LOG.,N,1,N,, ;LOG(N)
    DFN MOD.,N,2,N,N, ;MOD(N,M)
    DFN NUM.,N,0,,,  ;NUM
    DFN POS.,N,3,S,S,N ;POS(S1$,S2$,N)
    DFN RND.,N,0,,,  ;RND
    DFN SEG.,S,3,S,N,N ;SEG$(S$,N1,N2)
    DFN SGN.,N,1,N,, ;SGN(N)
    DFN SIN.,N,1,N,, ;SIN(N)
    DFN SQR.,N,1,N,, ;SQR(N)
    DFN STR.,S,1,N,, ;STR$(N)
    DFN TAN.,N,1,N,, ;TAN(N)
    DFN TIM.,N,0,,,  ;TIM
    DFN USR.,S,0,,,  ;USR$
    DFN VAL.,N,1,S,, ; VAL(S$)
;
 FCTAFL:
    DFN LOC.,N,1,F,, ;LOC(#F)
    DFN LOF.,N,1,F,, ;LOF(#F)
    DFN MAR.,N,1,F,, ;MAR(#F)
    DFN PER.,N,2,F,S, ;PER(#F,S$)
    DFN TYP.,N,2,F,S, ;TYP(#F,S$)
;
 FCTAND:
;
    NFCTS== FCTAND-FCTATB ;NUMBER OF FUNCTIONS
;
;
;   MATRIX FCTS
;
 MFCTS:
    DFN CON.,N,0
   MTFIDN: DFN IDN.,N,0
    DFN MINV.,N,1,N
    DFN NUL.,S,0
 MTFTRS: DFN TRNS.,N,1,S
 MTFTRM: DFN TRN.,N,1,N
    DFN ZER.,N,0
 MFCTND:
;
 PFCTS:
    DFN TAB.,N,1,N,,
    DFN LIN.,N,1,N,,
    DFN PAG.,N,0,,,
 PFCTND:
;
;
 FCTND:
;
;
;
SUBTTL COMPILER TABLES--RUN TIME SYMBOL DEFS
;
;
;
;   REGISTERS
;
R.FL== 13 ;FILE PTR
R.F== 14 ;FCT VARS
R.V== 15 ;VARIABLE AREA
R.L== R.V ;LINE NUMBERS (UPPER HALF)
R.T== 16 ;TRANSFERS
R.P== 17 ;PDL
;
;
;   PARAMETERS
;
R.NFLS== 24 ;MAX NUMBER OF FILES
;
;
;   ERROR CALLS
;
R.ONER== 002000000000 ;ON ERROR
R.SBER== 003000000000 ;SUBSCRIPT ERROR
R.FCER== 004000000000 ;PASSED FCT ERROR
;
;
  SUBTTL COMPILER TABLES--RUN TIME BLOCKS
;
;   RUN TIME BLOCKS ARE TWO WORD BLOCKS DESCRIPED IN SYMBOL DEFINITIONS.
;      THERE IS ONE BLOCK FOR EACH RUN TIM EROUTINE WHICH MIGHT HAVE TO
;      BE LOADED.  IT CONTAINS THE NAME IN RADIX50 AND THE RELATIVE
;      ADDRESS FOR COMPILING USAGE
;
;
 RTPBKS:
 R.CBMS:RTP CBMS.      ;CHANGE BIT MAT TO STRING
 R.CBSM:RTP CBSM.      ;CHANGE BIT STRING TO MAT
 R.CCT:RTP CCT.        ;CONCATENATE
 R.CHAN:RTP CHAIN.	;CHAIN
 R.CHMS:RTP CHMS.      ;CHANGE MATRIX TO STRING
 R.CHNN:RTP CHANN.	;CHAIN #
 R.CHSM:RTP CHSM.      ;CHANGE STRING TO MATRIX
 R.DBGR:RTP DBGR.	;DEBUGGER LINE ENTRY
 R.DBLX:RTP DBLX.	;DEBUGGER END OF ONE LINE REENTRY
 R.DBSB:RTP DBSB.	;DEBUGGER NEW SUB ENTRY
 R.DBST:RTP DBST.	;DEBUGGER INITIAL ENTRY
 R.DBSX:RTP DBSX.	;DEBUGGER SUB EXIT ENTRY
 R.DLC:RTP SDLOC.      ;DEALLOCATE STRING
 R.DSTR:RTP DBSTR.	;DEBUGGER STRING COPY (CONST STRS)
 R.EXPN:RTP EXPON.     ;EXPONENTIATE
 R.FILE:RTP FILE.      ;FILE STATEENT
 R.FSET:RTP FSET.      ;FILE SET
 R.IDNC:RTP INDNC.     ;INPUT DONE/CONTINUE
 R.IDON:RTP INDON.     ;INPUT DONE
 R.IFEN:RTP IFEND. ;IF END TEST
 R.IFMR:RTP IFMOR. ;IF MORE TEST
 R.INIT:RTP INIT.      ;INITIALIZATION (RUN TIME)
 R.INUM:RTP INNUM.     ;INPUT NUMERIC
 R.ISET:RTP INSET.     ;INPUT SETUP
 R.ISTR:RTP INSTR.     ;INPUT STRING
 R.LSTR:RTP LNSTR.     ;LINPUT STRING
 R.MADD:RTP MADD. ;MATRIX ADDITION
 R.MASS:RTP MASS. ;MAT ASSIGNMENT
 R.MINN:RTP MINN.	;MAT INPUT NUMERIC
 R.MINS:RTP MINS.	;MAT INPUT STRING
 R.MLNS:RTP MLNS.	;MAT LINPUT (STRING)
R.MMUL:RTP MMUL. ;MATRIX MULTIPLICATION
 R.MPRN:RTP MPRN.	;MAT PRINT NUMERIC
 R.MPRS:RTP MPRS.	;MAT PRINT STRING
 R.MPUN:RTP MPUN. ;MAT PRINT USING NUMERIC
 R.MPUS:RTP MPUS. ;MAT PRINT USING STRING
 R.MRDN:RTP MRDN.	;MAT READ NUMERIC
 R.MRDS:RTP MRDS.	;MAT READ STRING
 R.MRIN:RTP MRIN.	;MAT READ INTERNAL NUMERIC
 R.MRIS:RTP MRIS.	;MAT READ INTERNAL STRING
 R.MSCL:RTP MSCL. ;MATRIX SCALAR MULTIPLICATION
 R.MSUB:RTP MSUB. ;MATRIX SUBTRACT
 R.MVIN:RTP MVIN. ;MAT VARIABLE LENGTH INPUT NUMERIC
 R.MVIS:RTP MVIS. ;MAT VARIABLE LENGTH INPUT STRING
 R.MWRN:RTP MWRN.	;MAT WRITE NUMERIC
 R.MWRS:RTP MWRS.	;MAT WRITE STRING
 R.MRGN:RTP MRGN.    ;MRGN
 R.PCFL:RTP PCFL. ;RECIEVE A FILE
 R.PCMA:RTP TBCMA.      ;PRINT COMMA
 R.PEOL:RTP PEOL.     ;PRINT CRLF
 R.PNUM:RTP PNUM.      ;PRINT NUMBER
R.PRST:RTP PRSET. ;PRINT SET
 R.PSFL:RTP PSFL. ;PASS A FILE
 R.PSTR:RTP PSTR.      ;PRINT STRING
 R.PUND:RTP PUEND.     ;PRINT USING END
 R.PUNM:RTP PUNUM.     ;PRINT USING NUMBER
 R.PUST:RTP PUSTR.     ;PRINT USING STRING
R.RBGS: RTP RBGSP. ;RETURN BEFORE GOSUB
 R.RDM1: RTP RDM1. ;1-D REDIM
 R.RDM2: RTP RDM2. ;2-D REDIM
R.RDST: RTP RDSTR. ;READ STRING
R.RDTN: RTP RDATN. ;READ DATA NUMERIC
R.RDTS: RTP RDATS. ;READ DATA STRING
 R.RNDM:RTP RNDMZ.    ;RANDOMIZE
 R.RNUM:RTP RDNUM.     ;READ NUMBER
 R.RNST:RTP RNSET. ;RANDUM NUMERIC SET
 R.RRST:RTP RRST.    ;RANDOM RESET
 R.RSST:RTP RSSET. ;RANDOM STRING SET
 R.RST:RTP RESET.      ;RESET (ASCII)
 R.RSTR:RTP RESTR.     ;RESTORE (RESET DATA)
 R.SBEN:RTP SBENT. ;SUB ENTER
 R.SBEX:RTP SBEXT. ;SUB EXIT
 R.SCP:RTP SCMPR.      ;STRING COMPARE
 R.SCR:RTP SCRCH.     ;SCRATCH
 R.SMSS:RTP SMASS.	;MAT STRING ASSIGNMENT
 R.STEX:RTP STKEX. ;STACK CLEAN ON FCT/SUB EXIT
 R.STOP:RTP STOP.      ;STOP
 R.TIME:RTP TIME.	;TIME STATEMENT SET UP
 R.TSET:RTP TSET.      ;SET UP FOR TERMINAL
 R.UEOL:RTP USEOL. ;USING END OF LINE
 R.USNG:RTP USING.     ;USING
 R.WNUM:RTP WRNUM.     ;WRITE NUMERIC
 R.WSTR:RTP WRSTR.     ;WRITE STRING
;
 RTBKND:
;
;
;
  SUBTTL END OF COMPILER USED CORE
;
;
;
;
 VARS:VAR              ;SPECIFIED VARS
;
 PATCH:BLOCK 300       ;PATCH AREA
;
;
 PDLBUF: BLOCK 200	;PDL BUFFER
;
;
 LITS:LIT              ;LITERALS
 CODEND: 
;
;
    PRINTX *****START OF BAS99*****
;
;
;
  SUBTTL END OF ASSEMBLY
;
;
;
    END    START
