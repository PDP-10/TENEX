00100	
00200	IFNDEF SALONE,<
00300		TITLE DISF10 -- FORTRAN-10 DRIVER FOR DISPLAY ROUTINES
00400	>
00500	
00600	
00700	
00800	COMMENT $
00900	
01000	THIS IS A DRIVER FOR THE DISPLAY ROUTINES FOR USE WITH FORTRAN-10
01100	PROGRAMS.  IT INCLUDES CODE FOR READING IN THE APPROPRIATE
01200	DEVICE-DEPENDENT SEGMENT OF CODE, AND SUBSEQUENTLY DISPATCHING
01300	ALL CALLS TO THAT SEGMENT.
01400	
01500	
01600	THIS PROGRAM IS TO BE ASSEMBLED WITH DISDEF.FAI, THE GLOBAL
01700	DEFINITIONS OF CALLS, ETC. FOR THE DISPLAY ROUTINES.
01800	
01900	$
02000	
02100	BEGIN FORTRAN-10
02200	
02300	
02400	IFNDEF SALONE,<
02500	INTERNAL PPNRJF,DEVRJF;
02600	>
02700	
02800	EXTERNAL ALCOR.,DECOR.		;USE FOROTS CORE ALLOCATION ROUTINES
02900	
03000	;EVERY SUBROUTINE CALL COMES TO THIS DISPATCHER.
03100	;A SAMPLE ENTRY POINT LOOKS LIKE:
03200	;
03300	;	SIXBIT /DOT3/
03400	;DDOT3:	JSP 0,DISP	;CALL DISPATCHER
03500	;	JRST @23(S)	;DISPATCH TABLE ENTRY TO DISPLAY-DEPENDENT CODE
03600	;	BYTE-WORD	;ARGUMENT TYPES.
03700	;
03800	
03900	DISP:	MOVEI	1,ACSAV		;SAVE ALL AC'S
04000		BLT	1,ACSAV+17	;LIKE SO.
04100		MOVEM	0,LASTDIS	;LAST ROUTINE CALLED.
04200		HRLI	0,(<POINT 4,0,35>) ;POINTER TO ARGUMENT TYPES.
04300		JRST	NEXT		;AND EXAMINE THEM.
04400	PGO:	PUSH	P,1		;SAVE THIS ARGUMENT.
04500		ADDI	16,1		;GET NEXT ARGUMENT.
04600	NEXT:	ILDB	2,0		;GET NEXT 4-BIT CODE.
04700		JRST	@DOTAB(2)	;...
04800	
04900	DOTAB:	DISPA			;DONE -- GO TO ROUTINE.
05000		WINT			;INTEGER VALUE
05100		WREL			;REAL VALUE
05200		WPTR			;POINTER VALUE.
05300	
05400	LASTDIS:	0		;DISPATCH LAST ROUTINE.
05500	ACSAV:	BLOCK	20		;AC SAVE AREA.
05600	RETLOC_ACSAV+16
05700	
05800	DISPA:	MOVEM	16,ACSAV+16		;SAVE FORTRAN AC.
05900		MOVEI	S,T			;POINTER TO DISPATCH
06000		MOVE	R,.DBASE(S)		;GET POINTER TO DATA AREA
06100		MOVE	0,.0SAV(S)		;AND RESTORE AC0
06200		XCT	@LASTDIS		;CALL ROUTINE WITH JRST
06300	
06400	FRET:	TDZA	A,A			;RETURN 0
06500	TRET:	MOVNI	A,1			;RETURN TRUE
06600		MOVEM	A,ACSAV			;RETURN IN AC 0
06700	RET:	MOVEM	0,.0SAV(S)		;SAVE THE AC
06800		MOVSI	17,ACSAV		;RESTORE AC'S
06900		BLT	17,17			;LIKE SO.
07000		POPJ	P,			;RETURN TO CALLER.
07100	
07200	WINT:	MOVE	1,@(16)			;PICK UP ARG.
07300		LDB	3,[POINT 4,(16),12]	;GET TYPE BITS.
07400		CAIE	3,2			;INTEGER?
07500		SKIPN	3			;NO-UNSPECIFIED?
07600		JRST	PGO			;YES-ASSUME OK
07700		CAIE	3,4			;FLOATING?
07800		 JRST	 ERR1			;NO -- ERROR.
07900		PUSHJ	P,WFIXW			;FIX IT.
08000		JRST	PGO			;OK
08100	
08200	WREL:	MOVE	1,@(16)			;ARG.
08300		LDB	3,[POINT 4,(16),12]
08400		CAIE	3,4			;REAL?
08500		SKIPN	3			;NO-UNSPECIFIED?
08600		 JRST	 PGO			;YES-ASSUME OK
08700		CAIE	3,2			;INTEGER?
08800		JRST	ERR1			;NO - ERROR
08900		PUSHJ	P,WFLOAT		;FLOAT THE INTEGER.
09000		JRST	PGO
09100	
09200	WPTR:	MOVE	1,(16)			;GET ADDRESS.
09300		JRST	PGO			;AND STACK IT.
09400	
09500	
09600	ERR1:	PUSHJ	P,@[XWD =2*40,WERROR]	;CALL ERROR PRINTER.
09700						;ERROR 8
09800		JRST	PGO			;AND GO WITH IT ANYWAY.
09900	
10000	
10100	INT__1
10200	REL__2
10300	PTR__3
10400	III__CLBASE
10500	
10600	DEFINE CL & (NAM,ARGS,ROUT) <
10700		INTERNAL D&NAM
10800		SIXBIT /NAM/			;DISPLAY NAME
10900	D&NAM:	JSP	0,DISP			;CALL DISPATCHER.
11000		IFDIF <ROUT><>,<JRST ROUT>
11100		IFIDN <ROUT><>,<JRST @III(S)
11200			III__III+1
11300		>
11400		BBYTE_0
11500		BBPOS_=32
11600		IFDIF <ARGS><>,<
11700		FOR I IN (ARGS) {
11800		BBYTE_I  BBPOS ! BBYTE
11900		BBPOS_BBPOS-4
12000		}
12100		>
12200		BBYTE
12300	>
12400	
12500	DEFINE CI & (NAM) <
12600		.&NAM __ III
12700		III__III+1
12800	>
12900	
13000	CALLS					;PUT IN ALL THE SUBROUTINES
     
00100	;MISCELLANEOUS ROUTINES.
00200	
00300	
00400	WFIXW:	PUSH	P,2			;FIX VAL IN 1
00500		MULI	1,400
00600		TSC	1,1
00700		ASH	2,-243(1)
00800		MOVE	1,2
00900		POP	P,2
01000		POPJ	P,
01100	
01200	WFLOAT:	PUSH	P,2		;FLOAT VAL IN 1
01300		IDIVI	1,400000
01400		SKIPE	1
01500		TLC	1,254000
01600		TLC	2,233000
01700		FAD	1,2
01800		POP	P,2
01900		POPJ	P,
02000	
02100	
02200	;ERROR PRINTER
02300	INTERNAL DERRHL
02400	WERROR:	PUSH	P,A		;SAVE AN AC
02500		PUSH	P,B
02600		PUSH	P,C
02700		TTCALL	3,[ASCIZ /?DISPLAY ERROR #/]
02800		MOVE	A,-3(P)		;ADDRESS
02900		MOVE	A,-1(A)		;LITERAL LOCN.
03000		TLZ	A,777760	;ONLY SAVE INDEX FIELD.
03100		MOVEM	A,ERRLOC#	;SAVE IT. (IT WILL HAVE INDEX AC, MAYBE)
03200		LDB	A,[POINT 12,@ERRLOC,12] ;GET ERROR NUMBER
03300		PUSHJ	P,DECPNT
03400		TTCALL	3,[ASCIZ /; ROUTINE D/]
03500		MOVE	B,LASTDIS
03600		MOVE	B,-3(B)		;SIXBIT NAME.
03700	W0:	SETZM	A
03800		LSHC	A,6
03900		JUMPE	A,W1
04000		ADDI	A,40
04100		TTCALL	1,A		;TYPE CHAR
04200		JRST	W0
04300	W1:	SKIPG	@ERRLOC		;ONLY PRINT IF FATAL
04400		TTCALL	3,[ASCIZ /
04500	 CALLED FROM /]
04600		HRRZ	A,RETLOC
04700		SUBI	A,1
04800		SKIPG	@ERRLOC		;ONLY PRINT IF FATAL
04900		PUSHJ	P,OCTPNT	;PRINT IT.
05000		TTCALL	3,[ASCIZ /
05100	/]
05200		POP	P,C
05300		POP	P,B
05400		POP	P,A
05500	DERRHL:	SKIPL	@ERRLOC		;FATAL?
05600		 POPJ	 P,		;NO -- IT WILL HANDLE IT.
05700		CALLI	12		;EXIT.
05800	
05900	DECPNT:	MOVEI	C,=10
06000		SKIPA
06100	OCTPNT:	MOVEI	C,10
06200	RECUR:	IDIVI	A,(C)		;LEAVES REMAINDER IN B.
06300		ADDI	B,"0"
06400		HRLM	B,(P)
06500		SKIPE	A
06600		 PUSHJ	 P,RECUR
06700		HLRZ	B,(P)
06800		TTCALL	1,B		;TYPE THE CHARACTER.
06900		POPJ	P,
     
00100	;LANGUAGE-DEPENDENT ROUTINES
00200	
00300	;ROUTINE TO TRANSFER MATRIX POINTED TO BY B INTO
00400	;THE WORK MATRIX.  THE WORK MATRIX IS STORED WITH
00500	;COLUMN NUMBER THE MOST RAPIDLY-VARYING.  WE
00600	;MUST CHANGE THAT FOR FORTRAN.
00700	
00800	PUTMAT:	MOVEI	C,WORKM-1(R)	;FIRST ELEMENT IN MATRIX
00900		MOVEI	D,4		;FOUR ROWS TO FILL.
01000	PUT0:	PUSH	C,(B)		;ROW 1, COLUMN 1
01100		PUSH	C,4(B)
01200		PUSH	C,=8(B)
01300		PUSH	C,=12(B)
01400		ADDI	B,1
01500		SOJG	D,PUT0		;LOOP FOR 4 ROWS.
01600		POPJ	P,
01700	
01800	STRING:	MOVE	A,(16)		;==> ENCODED ARRAY
01900		HRLI	A,(<POINT 7,0>)
02000		MOVEM	A,BYTEP#
02100		MOVEI	A,2
02200		ADDB	A,ACSAV+16		;BUMP RETURN ADDRESS
02300		MOVE	16,@-1(A)		;COUNT.
02400		MOVNI	A,1
02500		PUSHJ	P,@.TEXT(S)		;START STRING.
02600	SLOP:	SOJL	16,STRD			;ANY MORE?
02700		ILDB	A,BYTEP
02800		PUSHJ	P,@.TEXT(S)
02900		JRST	SLOP
03000	STRD:	MOVNI	A,2
03100		PUSHJ	P,@.TEXT(S)
03200		JRST	RET
03300	
03400	
03500	;INITIALIZATION ROUTINES (PHASE 1)
03600	
03700	INIGO:
03756		MOVE	A,(P)		;IF USER WANTS HISEG DISPLAY
03758		CAIN	A,1		;FILE, ERROR
03760	REPEAT 0,<
03762		TTCALL	3,[ASCIZ /FORTRAN-10 REQUIRES LOW SEGMENT CORE ALLOCATION.
03774	HIGH SEGMENT SPECIFICATION IGNORED.
03786	/]
03818	>
03826	
03828	REPEAT 0,<
03834		TTCALL 3,[ASCIZ /ERROR *** FORTRAN-10 REQUIRES LOW SEGMENT DISPLAY FILE.
03836	HIGH SEGMENT REQUEST IGNORED.  YOU SHOULD EXPLICITLY REQUEST LOW
03838	SEGMENT DISPLAY FILE BY CHANGING THE 4TH ARG OF THE DINI CALL 
03840	TO A 0.   CALL 496-4823 FOR AN EXPLANATION.
03844	/]
03846	>
03850		SETZM	(P)		;FORCE LOW SEG
03875		SETZM	.LANG(S)		;SAY THIS IS FORTRAN
03900	;PATCH IN ADDRESSES OF FORTRAN CORE ALLOCATION ROUTINES
04000		MOVEI	A,ALCOR.
04100		MOVEM	A,.GET(S)
04200		MOVEI	A,DECOR.
04300		MOVEM	A,.REL(S)
04400		
04410		MOVEI	A,PATADR	;FIXUP ADDRESS FOR PATCHING
04415		MOVEM	A,.PADR(S)
04420	
04425	
04430	IFDEF SALONE,<
04435		MOVEI	A,DISNUM
04440		SKIPN	A		;IF STAND-ALONE FOR 340
04445		PUSHJ	P,PATADR	;THEN PATCH
04450		JRST	INIG1
04455	>
04460	
04465		MOVE	A,-3(P)		;GET DISPLAY # OR NAME
04470		CAMN	A,[SIXBIT /DEC340/]	;IS THIS THE 340
04475		MOVEI	A,0		;YES
04480		SKIPN	A		;IS THIS THE 340?
04485		PUSHJ	P,PATADR	;YES - PATCH
04500	
05000	INIG1:
05100	IFNDEF SALONE,<    ; CODE TO READ-IN THE APPROPRIATE SEGMENT
05200	
05300		MOVE	B,-3(P)		;GET DISPLAY NUMBER
05400		OPEN	OBLK		;TRY TO GET CHANNEL OPEN
05700		 JRST	 NODIS		;NO DISK == NO DISPLAY
05800		MOVE	A,PPNRJF
05900		MOVEM	A,INAM+3		;PPN
06000		LOOKUP	INAM
06300		 JRST	 NODIS		;NO SEGMENT FILE == NO DISPLAY
06400	AG:	INPUT [IOWD ROUTSIZE,<TT+PCHBRK>
06500					0]
06800		STATZ	20000		;LOOK FOR END OF FILE.
07100		 JRST	 NODIS
07200		CAME	B,.DISN(S)	;CORRECT DISPLAY NUMBER
07300		CAMN	B,.DISNM(S)	;OR CORRECT SIXBIT NAME?
07400		 JRST	 GOTIT		;YES
07500		JRST	AG		;NO -- LOOK FARTHER
07600	
07700	INAM:	SEGNAM			;SIXBIT NAME OF SEGMENT.
07800		SIXBIT /SEG/
07900		BLOCK 2
08000	PPNRJF:	SEGPPN
08100	
08200	OBLK:	17
08300	DEVRJF:	SEGDEV
08400		0
08500	
08600	
08700	NODIS:	PUSHJ	P,@[XWD S+(=14*40),.ERRGO]
08800		SUB	P,[XWD 4,4]	;GET RID OF ALL ARGS.
08900		JRST	FRET		;RETURN FALSE, FALSE, FALSE
09000	
09100	GOTIT:	RELEASE
09400	
09500	>
09600	IFDEF SALONE,<     ; CODE TO MOVE LOW PART OF DISPATCH TABLE
09700			   ; BACK WHERE IT BELONGS.
09800	^T_CBEG			;BEGINNING OF CODE AREA
09900	
10000		MOVE	A,[XWD TT+.FIX,CBEG+.FIX]
10100		BLT	A,CBEG+PCHBRK-1
10200	>
10300	
10400		JRST @.INI(S)		;GO TO DISPLAY-DEPENDENT PART
10500	
10600	
10700	
10800	;ROUTINE CALLED BY FOROTS WHEN IT MUST EXPAND CORE AND THE
10900	;340 IS INIT'D. THIS ALLOWS OMNIGRAPH TO TAKE CARE OF
11000	;STOPPING THE 340 AND UNLOCKING BEFORE CORE IS EXPANDED
11100	
11150	?OMN.PT__20
11175	
11250	FORTB:	PUSH	P,R		;SAVE AC'S AND SETUP NEW VALUES
11257		PUSH	P,0
11264		PUSH	P,A
11278		MOVEI	S,T		;SETUP AC'S
11285		MOVE	R,.DBASE(S)
11292		MOVE	0,.0SAV(S)
11300		SKIPN	.RUN(S)		;IS THE DISPLAY GOING?
11400		JRST	OMN1		;NO
11500		MOVE	A,OXSTAT(R)	;SAVE STATUS
11600		MOVEM	A,SAVSTAT
11700		MOVE	A,[XWD 4,400007]	;STOP 340 AND UNLOCK
11800		DISCAL	A
11900	OMN1:	MOVE	S,.JBOPS	;SETUP AC 15
12000		MOVEI	A,FORTA		;CHANGE OMNIGRAPH ENTRY POINT
12100		MOVEM	A,OMN.PT(S)
12300	RST1:	POP	P,A	;RESTORE AC'S
12400		POP	P,0
12500		POP	P,R
12600		POPJ	P,
12700	
12800	
12900	;ROUTINE CALLED BY FOROTS AFTER IT HAS EXPANDED CORE TO
13000	;START 340 UP AGAIN
13100	
13250	FORTA:	PUSH	P,R		;SAVE AC'S AND SETUP AC'S
13257		PUSH	P,0
13264		PUSH	P,A
13278		MOVEI	S,T		;SETUP AC'S
13285		MOVE	R,.DBASE(S)
13292		MOVE	0,.0SAV(S)
13300		SKIPN	.RUN(S)		;SHOULD WE TRY TO GET STARTED AGAIN
13400		JRST	OMN2		;NO
13500		MOVEI	A,OXSTAT(R)	
13600		HRLI	A,1		;TRY TO RE-SEIZE DISPLAY
13700		DISCAL	A
13800		JRST	OMN3		;CANNOT
13900		MOVE	A,SAVSTAT	;RESTORE DEVICE RUN BITS
14000		HRLI	A,3
14100		DISCAL	A		;RESTART DEVICES
14200	OMN2:	PUSHJ	P,PATADR
14250		MOVE	S,.JBOPS
14300		JRST	RST1
14400	OMN3:	TTCALL	3,[ASCIZ /CANNOT RE-SEIZE DISPLAY
14500	/]
14600		TLZ	DISRUN		;SAY NO LONGER RUNNING
14700		MOVEM	.0SAV(S)
14800		SETZM	.RUN(S)
14900		JRST	OMN2
15000	
15100	
15200	PATADR:	PUSH	P,S		;SAVE AC S
15210		MOVE	S,.JBOPS	;SETUP S TO POINT TO BASE OF FOROTS
15220					;LOW SEG STATIC DATA AREA
15300		MOVEI	A,FORTB
15400		MOVEM	A,OMN.PT(S)
15500		POP	P,S
15600		POPJ	P,
15700	
16600	
16700	SAVSTAT:	0	;FOR SAVING DEVICE RUN BITS
16750	
16790	
16800	
     
00100	
00200	IFNDEF SALONE,<
00300	^T:
00400	>
00500	TT:			;HERE BEGINS THE DISPATCH TABLE.
00600		0		;SAVE REGISTER 0
00700		0		;POINTER TO DATA AREA
00900		WFIXW		;FIX ROUTINE
01000		WFLOAT		;FLOAT ROUTINE
01100		PUTMAT		;MATRIX TRANSFER ROUTINE
01200		TRET		;RETURN TRUE
01300		FRET		;RETURN FALSE
01400		RET		;RETURN INTEGER
01500		RET		;RETURN
01600		JRST 	WERROR	;.ERRGO
01650		0		;DEFINES WHICH CORE ALLOCATION METHOD
01675				;0 IF LOW SEG, -1 IF HISEG
01681	
01687	;THE FOLLOWING ENTRIES ARE USED ONLY BY THE LOW SEGMENT
01693	;CORE ALLOCATION METHOD
01696	
01700		ALCOR.		;FOR ADDRESS OF ALCOR.
01800		DECOR.		;FOR ADDRESS OF DECOR.
01900		PATADR		;FOR ADDRESS OF PATCH ROUTINE
02000		0		;FLAG IF DISPLAY IS RUNNING
02100		0		;FLAG WHICH LANGUAGE
02200		BLOCK 20		;FOR AC SAVE AREA
02300	
02400	
02500	IFNDEF SALONE, <
02600	
02700	;IF THESE ARE NOT STAND-ALONE ROUTINES, HERE IS WHERE WE LEAVE
02800	;A BLOCK OF STORAGE FOR THE ROUTINES TO BE READ INTO.
02900	
03000	BLOCK	ROUTSIZE
03100	
03200	>
03300	BEND
03400	END
03500	
