
IFNDEF IMSSS,<IMSSS==1>			;IMSSS -- RLS DEC-6-72
IFNDEF EDDT,<EDDT==1>			;IMSSS -- MAKE DDT10X
;18 FEB 71, 1416:

; RST NEW LOOKUP
; MODS FOR MULTIPLE WORD TEXT INPUT AND STRING CONTROLLED TIN
; ADDITIONS FOR BIT PRINTOUTS ON TRXX TLXX CONO CONSZ ETC. RST
;ADDITIONS FOR TENEX MONITOR DDT - DLM 26 FEB 70
; ADDITIONS FOR FAIL BLOCK STRUCTURE RST

	MLON

;ALL OTHER REFERENCES TO VERSION # ARE TAKEN CARE OF BY THIS DEFINITION

DDTVER==22

SUBTTL	2 JUN 69
REPEAT 0,<


DDT ASSEMBLY INSTRUCTIONS

THE SOURCE FILE OF DDT.13 WILL ASSEMBLE INTO SEVERAL DIFFERENT
VERSIONS; THE ASSEMBLY IS CONTROLLED BY THE VALUE ASSIGNED
TO THE SYMBOL "EDDT". THE SYMBOL "EDDT" IS DECODED AS FOLLOWS:

BIT 35	=0;	ASSEMBLE A RELOCATABLE DDT
	=1;	ASSEMBLE DDT PHASE'D TO 770000

(IF THE SYMBOL "EDDT" IS NOT DEFINED AT ALL, DDT WILL BE ASSEMBLED
	WITH EDDT=0.)
>	;END OF REPEAT 0

IFNDEF EDDT,<EDDT=0>


OPDEF TYI [PBIN]
OPDEF TYO [PBOUT]
OPDEF MRPAC [JSYS 772]
IFN EDDT&1,<
	TITLE DDT10X
	ZLOW==40

	INTERN PHDDT
	INTERN MDDT
	INTERN JOBSYM
	INTERN EMDDT
PHDDT:	PHASE 770000
MDDT:
>

IFE EDDT&1,<
	TITLE UDDT
	ZLOW=20
	INTERN UDDT,JOBSYM
UDDT:
>


;DEFINE ACCUMULATORS

F=0		;FLAGS
P=17		;PUSH DOWN
R=<A=2>		;POINTERS TO TABLES, CORE, ETC.
S=<B=3>
W=<C=4>		;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
T=5		;TRANSFER DATA
W1=6
W2=7
SCH=10		;MODE CONTROL SWITCH FOR OUTPUT
AR=11		;MODE CONTROL SWITCH FOR OUTPUT
ODF=12		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT=13		;TEMPORARY
TT1=14	;TEMPORARY

;DEFINE I/O DEVICE MNEMONICS FOR DDT USE
PRS==4
TTYY==120
PTRR==104
PTPP==100

;DEFINE PUSH DOWN LENGTH
LPDL=50		;MAX LENGTH PUSH DOWN LIST

;DEFINE BITS FOR USE IN LEFT HALF OF ACCUMULATOR F
COMF==200000		;COMMA TYPED FLAG
TIF==100000		;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
PTF==100		; +, -, OR * HAS BEEN TYPED
CTF==400
SF==4		;SYLLABLE FLAG
QF==1		;QUANTITY TYPED IN TO WORD ASSEMBLER

CF==40		; $  TYPED
CCF==10000	; $$  TYPED
MF==2		;MINUS SIGN TYPED IN
LTF==20		;LETTER TYPED IN TO CURRENT SYLLABLE
ROF==10		;REGISTER OPEN FLAG
STF==4000
FAF==1000		; < TYPED
SAF==2000		; > TYPED

FPF==20000		; . TYPED IN
FEF==400000		; E FLAG

MLF==200		;*FLAG
DVF==40000		;DIVIDE FLAG

;PID IS 20 IF SYM TAB POINTER IS INDIRECT JOBSYM
PID==0		;=0 IF SYMBOL TABLE POINTER IS IN JOBSYM


;DEFINE BITS FOR USE IN RIGHT HALF OF ACCUMULATOR F

ITF==2	;INSTRUCTION TYPED IF ITF=1
OUTF==4	;OUTPUT IF OUTF=1
CF1==400		;OUTPUT 1 REGISTER AS CONSTANT
LF1==2000		;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
Q2F==1		;NUMBER TYPED AFTER ALT MODE 
R20F==10	;TEMP FLAG USED IN SETUP
SBF==20
NAF==200		;NEGATIVE ADDRESSES PERMISSABLE
POWF==4000		;ARGUMENT FOR EXPONENT COMING

;DEFINE SYMBOL TABLE SYMBOL TYPES
GLOBAL==040000		;GLOBAL SYMBOL
LOCAL==100000
PNAME==740000		;PROGRAM NAME
DELI==200000		;DELETE INPUT
DELO==400000		;DELETE OUTPUT
OPDEF DDTINT [Z 0,]	;ADR INTERNAL TO DDT (NOT CURRENTLY USED)

NBP==20			;NUMBER OF BREAKPOINTS


DDT:	JRST .+2
	XWD 0,JOBSYM		;SO OTHER PROGRAMS CAN FIND SYMTAB
	SETZM STRING
	JSR SAVE
	PUSHJ P,REMOVB
	PUSHJ P,CHKSYM
DD1:	PUSHJ P,CRF
DD1.5:	TLZ F,ROF		;CLOSE ANY OPEN REGISTER
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF		;LOAD ACS
	HRLS MMODF		;SET MEMORY MODE BACK TO PERMANENT
DD2:	CLEARM PRNC		;PARENTHESES COUNT
	SETZM	EXU0		;NO SINGLE STEP
	SETZM	EXU1		;NOR SINGLE-CCALLING
	MOVE P,PS
LIS:	MOVE T,ESTU
	MOVEM T,ESTUT		;INIT UNDEFINED SYM ASSEM
	TDZ F,[XWD 777777-ROF-STF,LF1+CF1+SBF+2+Q2F]
LIS0:	TDZ F,[XWD 777777-ROF-STF-FAF-SAF,NAF]
	CLEARM,WRD
LIS1:	CLEARM,FRASE
LIS2:	MOVEI T,1
	MOVEM T,FRASE1
	TLZ F,MLF+DVF
L1:	TLZ F,CF+CCF+SF+FPF		;TURN OFF CONTROL, SYL, PERIOD FLAG
	CLEARM,SYL
L1RPR:	CLEARM,SYM
	MOVEI T,6
	MOVEM T,TEM		;INIT SYMBOL COUNTER
	MOVE T,[POINT 7,TXT]
	MOVEM T,CHP		;SETUP FOR OPEVAL SYMBOL
	CLEARM,DEN
	CLEARM,WRD2

L2:	PUSHJ P,TIN		;PICK UP CHARACTER
	CAIL T,"A"+40		;LOWER CASE A
	CAILE T,"Z"+40		;LOWER CASE Z
	JRST .+2
	TRC T,40		;CHANGE LOWER CASE TO UPPER CASE
	TLNE F,CF		;CONTROL FLAG
	JRST L21
	CAIG T,"Z"		;Z
	CAIGE T,"A"		;A
	JRST .+2
	JRST LET
L21:	MOVE R,T
	CAILE T,137	;DISPATCH TABLE HAS ENTRIES ONLY .LE. 137
	JRST ERR
	IDIVI R,3		;REMAINDER GIVES COLUMN, QUOTIENT GIVES ROW
	LDB W,BDISP(R+1)	;GET 12 BIT ADDRESS FROM DISPATCH TABLE
	CAIGE W,MULT-DDT	;FIRST EVAL ROUTINE
	JRST DDT(W)


	MOVE T,SYL
	TLZN F,LTF
	JRST POWER
	MOVE T,[XWD OPEVAL,EVAL]	;GET ADDRESSES OF LOOKUP ROUTINES
	SKIPN WRD		;IF C(WRD)=0, CALL OPEVAL FIRST, OTHERWISE EVAL FIRST
	MOVSS T
	MOVEM T,SAVE
	JRST L213

L212:	HLRZS T,SAVE		;GET ADDRESS OF THE OTHER LOOKUP ROUTINE
	JUMPE T,UND1		;IF ADR=0, THEN SYMBOL UNDEFINED
L213:	PUSHJ P,(T)	;CALL OPEVAL OR EVAL
	JRST L212		;SYMBOL NOT FOUND
L4:	TLZE F,MF
	MOVN T,T
	TLNN F,SF
	CAIE W,LPRN-DDT
	JRST .+2
	JRST LPRN

	EXCH T,FRASE1
	TLNN F,DVF
	IMULB T,FRASE1
	TLZE F,DVF
	IDIVB T,FRASE1
	CAIGE W,ASSEM-DDT
	JRST DDT(W)		;MULTIPLY OR DIVIDE
	ADDB T,FRASE
	CAIGE W,SPACE-DDT
	JRST DDT(W)		; + - @ ,

	ADD T,WRD
	TLNE F,TIF		;TRUNCATE INDICATOR FLAG
	HLL T,WRD		;TRUNCATE
	MOVEM T,WRD
	TLNN F,QF
	MOVE T,LWT
	CLEARM,R
	MOVE W1,ESTUT
	CAMN W1,ESTU
	JRST L5
	CAILE W,CARR-DDT
	JRST ERR
L5:	CAIG W,RPRN-DDT
	JRST DDT(W)
	PUSH P,KILRET
	SKIPN PRNC
	JRST DDT(W)


ERR:	SETZM STRING
	MOVEI W1,"?"
	JRST WRONG1
UNDEF:	MOVEI W1,"U"
	JRST WRONG1
WRONG:	MOVE W1,[ASCII /XXX/]
WRONG1:	MOVE P,PS
	PUSHJ P,TEXT
	TLNN F,ROF		;REG OPEN?
	JRST DD1		;NO, CR AND RESET
RET:	MOVE P,PS
	PUSHJ P,LCT		;COMMON RETURN FOR TAB;,JRST LIS
	SKIPN	EXU0		;SINGLE STEPPING?
	  JRST DD2		;NO
	CLEARM	EXU0
	SETZM	EXU1		;
	SETZM	NBP*4+B1ADR-4	;CLEAR TEMPORARY BREAKPOINT
	JRST DD2


UND1:	MOVE R,ESTUT		;UNDEFINED SYM ASSEMBLER
	HLRE S,ESTUT
	ASH S,-1		;SETUP EVAL END TEST
	HRLOI W1,37777+DELI+LOCAL
	PUSHJ P,EVAL2
	CAIN W,ASSEM-DDT
	TLNN F,ROF
	JRST UNDEF
	SKIPE PRNC
	JRST UNDEF
	MOVEI T,"#"
	CAIE W,ASSEM-DDT
	PUSHJ P,TOUT

	MOVN R,[XWD 2,2]
	ADDB R,ESTUT
	MOVE T,SYM
	TLO T,GLOBAL
	MOVEM T,(R)
	HRRZ T,LLOCO
	TLNE F,MF
	TLO T,400000
	MOVEM T,1(R)
	MOVEI T,0
	JRST L4

QUESTN:	PUSHJ P,CRF		;LIST UNDEFINED SYMBOLS
	MOVE R,ESTU
QUEST1:	JUMPGE R,DD1
	MOVE T, (R)
	SKIPA W1,ESTU

QUEST2:	ADD W1,[XWD 2,2]
	CAME T,(W1)
	JRST QUEST2
	CAME R,W1
	JRST QUEST4
	PUSHJ P,SPT
	PUSHJ P,CRF
QUEST4:	ADD R,[XWD 2,2]
	JRST QUEST1


NUM:	ANDI T,17		;T HOLDS CHARACTER
	TLNE F,CF+FPF
	JRST NM1
	MOVE W,SYL
	LSH W,3
	ADD W,T
	MOVEM W,SYL
	MOVE W,DEN
	IMULI W,12		;CONVERT TO DECIMAL
	ADD W,T
	MOVEM W,DEN
	AOJA T,LE1A

DOLLAR:	SKIPA T,[46+101-13]	;RADIX 50 $ TO BE
PERC:	MOVEI T,47+101-13	;PERCENT SIGN
LET:	TLC F,SF+FPF		;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
	TLZN F,LTF+FEF+SF+FPF
	CAIE T,105		; E
	TLOA F,LTF
	TLOA F,FEF
	JRST LET1
	TLZN F,MF
	SKIPA W1,SYL
	MOVN W1,SYL
	MOVEM W1,FSV
	CLEARM DEN
LET1:	SUBI T,101-13		;FORM RADIX 50 SYMBOL
LE1A:	TLO F,SF+QF
LE2:	MOVE W,SYM
	MOVEI R,101-13(T)
	IMULI W,50		;CONVERT TO RADIX 50
	ADD W,T
	SOSGE TEM		;IGNORE CHARACS AFTER 6
	JRST L2
	MOVEM W,SYM
	IDPB R,CHP
	MOVEM W,SYM
	JRST L2


NUM1:	EXCH T,WRD2		;FORM NUMBER AFTER $
	IMULI T,12
	ADDM T,WRD2
	TRO F,Q2F
	JRST L2

NM1:	TLNE F,CF
	JRST NUM1
	MOVEI W1,6		;FORM FLOATING POINT NUMBER
	AOS NM1A
NM1A:	MOVEI W2,0
	MOVSI R,201400
NM1A1:	TRZE W2,1
	FMPR R,FT(W1)
	JUMPE W2,NM1B
	LSH W2,-1
	SOJG W1,NM1A1
NM1B:	MOVSI W1,211000(T)
	FMPR	R,W1		;COMPUTE VALUE OF NEW DIGIT
	FADRB	R,FH		;ADD VALUE INTO FLOATING NO.
	MOVEM R,SYL
	AOJA T,LE1A


CHKSYM:	HLRZ T,ESTU		;THIS SEQUENCE INITS SYM TABLE LOGIC
	SUB T,ESTU
	MOVE W,@SYMP
	ADD T,W		;IF THE TOP OF THE UNDEFINED SYM TAB DOES
	TRNE T,-1		; NOT POINT TO BOTTOM OF REGULAR SYM TAB,THEN
	HRRZM W,ESTU		; RE-INIT UNDEFINED SYM TABLE POINTER, ESTU.
	MOVE T,PRGM
	SUB T,W		;IF THE SYM TABLE PNTR AND THE PROGRAM
	TSC T,T		; NAME (PRGM) PNTR DO NOT END UP IN THE
	MOVE W1,PRGM		; SAME PLACE, OR THEY DO NOT BOTH START ON
	XOR W1,W		; AN EVEN (OR BOTH ON ODD) LOCATION, OR
	TRNN W1,1		; PRGM .GE. 0, THEN RE-INIT PRGM.
	JUMPE T,CPOPJ
	SETZM PRGM
	SETZM BLOCK		;RESET WORLD
	POPJ P,


POWER:	TLNN F,FEF
	JRST L4		;NO EXPONENT
	CAIE W,PLUS
	CAIN W,MINUS
	TROE F,POWF
	TRZA F,POWF
	JRST (W)		; E+-

	MOVE W2,DEN
	CLEARM FRASE
	MOVEI W1,FT-1
	TLZE F,MF
	MOVEI W1,FT01
	SKIPA T,FSV
POW2:	LSH W2,-1
	TRZE W2,1
	FMPR T,(W1)
	JUMPE W2,L4
	SOJA W1,POW2


PERIOD:	MOVE T,LLOC
	TLNE F,SF		;SYLLABLE STARTED
	MOVE T,DEN
	MOVEM T,SYL
	TLNE	F,FPF		;HAS A PERIOD BEEN SEEN BEFORE?
	TLO	F,LTF		;YES, TWO PERIODS MAKES A SYMBOL
	TLON F,FPF+SF+QF
	MOVEI T,0
	IDIVI T,400
	SKIPE T
	TLC T,243000
	TLC W1,233000
	FAD	T,[0]		;NORMALIZE T AND W1
	FAD	W1,[0]
	FADR	T,W1
	MOVEM T,FH
	HLLZS NM1A
	MOVEI T,45		;RADIX 50 PERIOD
	JRST LE2

PILOC:	MOVEI T,SAVPI		;ADR SETUP FOR $I
QUANIN:	TLOA T,(DDTINT)		;MARK FOR ADR INTERNAL TO DDT
QUAN:	MOVE T,LWT		;PICK UP LAST QUANTITY TYPED
QUAN1:	MOVEM T,SYL
QUAN2:	TLO F,SF+QF		;WRD,SYL STARTED
	TLZ F,CF+CCF
	JRST L2

CONTRO:	TLOE F,CF
	TLO F,CCF
	JRST L2


;BIT 40 - DELETE OUTPUT
; 20 - DELETE INPUT
; 10 - LOCAL
; 04 -GLOBAL
; NO BITS - PROGRAM NAME

EVAL0:	HRLOI W1,37777+DELI
	HLRE S,@SYMP
	ASH S,-1	;SETUP END TEST
	JRST EVAL3

EVAL1:	ADD R,[XWD 2,2]
EVAL2:	SKIPL R
	MOVE R,@SYMP
	AOJG S,CPOPJ		;NOTHING FOUND
EVAL3:	MOVE T,(R)
	XOR T,SYM
	TLNN T,PNAME
	TLOA W1,LOCAL
	TDNE T,W1
	JRST EVAL1
	TLNN T,340000
	JRST EVAL1
	MOVE T,1(R)
CPOPJ1:	AOS (P)		;FOUND SYMBOL, SKIP
CPOPJ:	POPJ P,

IFN IMSSS,<
JEVAL:	
COMMENT ! CHECK FOR A UUO OR JSYS NAME !
	MOVE	R,[XWD -JTBLSZ,JTBL]
UAGAIN:	MOVE	T,(R)		;GET A SYMBOL
	TLZ	T,PNAME		;IGNORE BITS
	CAMN	T,SYM		;A MATCH?
	  JRST	UFOUND		;YES
	ADD	R,[XWD 2,2]	;INCREMENT POINTER
	JUMPL	R,UAGAIN	;ANY MORE THERE?
;CANNOT FIND IT
	JRST	CPOPJ		;CANNOT FIND
;FOUND IT IN UUO-JSYS TABLE
UFOUND:	MOVE	T,1(R)		;GET THE VALUE
	JRST	CPOPJ1
>;IFN IMSSS


;HERE IS THE WFW BLOCK STRUCTURE PATCH 
EVAL:	PUSHJ P,EVALA
	JRST EV9
	JRST CPOPJ1

EVALA:	MOVSI W1,DELI
	HLRE S,@SYMP
	ASH S,-1
	SKIPL R,TBLK
	JRST EVL1
	SETZM TBLK
	JRST EVL2
EVL1:	SKIPL R,BLOCK
	JRST EV5
EVL2:	MOVE T,1(R)
	MOVEM T,BLVL
	JRST EV1


EV3:	CAMN R,@SYMP
	JRST EV4
IFE IMSSS,<
	AOJGE S,CPOPJ
>;IFE IMSSS
IFN IMSSS,<
	AOJGE S,JEVAL
>;IFN IMSSS
EV1:	SUB R,[XWD 2,2]
	MOVE T,(R)
	TDNE T,W1
	JRST EV3
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST EV2
	SKIPN T
	TLOA W1,LOCAL
	SKIPA T,(R)
	JRST EV3
	XOR T,SYM
	TLZ T,740000
	JUMPN T,EV3
	MOVE T,1(R)
	JRST CPOPJ1

EV4:	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	AOJL S,EV1
	POPJ P,

EV2:	MOVE T,1(R)
	CAMGE T,BLVL
	JRST EV2A
EV2B:	SUB R,[XWD 2,2]
	ADDI S,1
	LDB T,[POINT 4,(R),3]
	CAIE T,3
	JRST EV2B
	JRST EV2
EV2A:	MOVEM T,BLVL
	JRST EV3


EV5:	MOVEI T,1
	MOVEM T,BLVL
	SKIPGE R,PRGM
	JRST EV1
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	JRST EV1
EV9:	SETZM SVTB
	SETZM SVFB
	SETOM SVF
	HLRE T,@SYMP
	JUMPGE T,CPOPJ		; EMPTY SYMBOL TABLE
	MOVNS T
	ADD T,@SYMP
	HRRZ R,T
EV9A:	SUB R,[XWD 2,2]
	CAMN R,@SYMP
	JRST EV9B
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST EV9C
	CAIN T,0
	JRST EV9D
	TRNE T,4
	JRST EV9A
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000
	JUMPN T,EV9A
	AOSE SVF
	JRST [	MOVE T,1(R)
		CAME T,SVBTS
		POPJ P,
		SETZM SVF
		JRST EV9A]
	MOVEM R,BLVL
	MOVE T,1(R)
	MOVEM T,SVBTS
	JRST EV9A

EV9C:	SKIPN SVF
	JRST EV9A
	MOVEM R,SVFB
	JRST EV9A


EV9D:	SKIPN SVF
	JRST EV9A
	MOVEM R,SVTB
	SETZM SVFB
	JRST EV9A

EV9B:	SKIPE SVF
	POPJ P,
	AOS (P)
	MOVSI T+1,(ASCIZ /[_/)
	PUSHJ P,TEXT2
	SKIPE R,SVTB
	CAMN R,PRGM
	JRST EV9B1
	MOVE T,(R)
	PUSHJ P,SPT1
	MOVSI T+1,(ASCIZ /$:/)
	PUSHJ P,TEXT2
EV9B1:	MOVE W1,BLVL
	PUSHJ P,SPT0
	MOVEI T,"]"
	PUSHJ P,TOUT
	MOVE R,BLVL
	MOVE T,1(R)
	POPJ P,


TEXI:	PUSHJ P,TEXIN		;INPUT TEXT
	MOVEM T,SYL
	MOVEI W1,5
	MOVEI T-1,0
	PUSHJ P,TEXIN
	CAIN T,33		;NEW ALT MODE, ESCAPE
	JRST QUAN2
	TLNN F,CCF
	TLNN F,CF
	JRST TEXI2+1
	AOJA W1,SIXBIN
TEXI2:	PUSHJ P,TEXIN
	CAMN T,SYL
	JRST TEXI3
	ROT T,-7
	LSHC T-1,7
	SOJG W1,TEXI2
	PUSHJ P,TEXDEP		; DEPOSIT THIS WORD OF TEXT
	JRST TEXI2+1		; AND CONTINUE

TEXI3:	LSHC T-1,-43
	JUMPLE W1,QUAN1
	LSH T,7
	SOJA W1,.-2

TEXDEP:	TLNN F,ROF		; IS A REGISTER OPEN?
	JRST [	MOVE T,SYL	; NO, TYPE TERMINATOR FOR THE GUY
		PUSHJ P,TOUT
		JRST CPOPJ1]	; AND SKIP RETURN
	PUSHJ P,TEXIN
	CAMN T,SYL
	TLNE F,CCF
	JRST .+2
	POPJ P,
	PUSH P,T
	MOVE T,-1(P)
	XCT 1(T)
	MOVE R,LLOCO
	PUSHJ P,DEP
	JRST ERR
	POP P,T
	AOS LLOCO
	MOVEI W1,5
	MOVEI T-1,0
	POPJ P,


SIXBI1:	PUSHJ P,TEXIN    ; INPUT TEXT (SIXBIT)
SIXBIN:	CAMN T,SYL
	JRST SIXBI2
	CAIL T,"A"+40		;IS CHAR BETWEEN LOWER CASE "A" AND
	CAILE T,"Z"+40		; LOWER CASE "Z"?
	SKIPA			;NO
	TRC T,40		;YES, CONVERT TO UPPER CASE
	CAIL T," "		;IS CHAR IN SIXBIT SET?
	CAILE T,"_"
	JRST ERR		;NO
	ANDI T,77		;YES, MASK TO 6 BITS
	TRC T,40		;CONVERT TO SIXBIT FORM
	ROT T,-6
	LSHC T-1,6
	SOJG W1,SIXBI1
	PUSHJ P,TEXDEP		; DEPOSIT THIS WORD OF TEXT
	JRST SIXBIN
SIXBI2:	MOVE T,T-1
	JUMPLE W1,QUAN1
	LSH T,6
	SOJA W1,.-2

; CONTROL-A  TAKE SYM AS RADIX50

RDX50:	MOVE T,SYM
	MOVEM T,SYL
	TLZ F,FPF!FEF!LTF!SF
	MOVSI T+1,(<ASCIZ /^A/>)
	PUSHJ P,TEXT2
	JRST L1RPR

KILL:	TLNN F,LTF		;DELETE SYMBOLS
	JRST ERR
	PUSHJ P,EVAL
	JRST KILL1
	MOVEI T,DELO/200000		;DELETE OUTPUT
	TLNE F,CCF
	MOVEI T,DELI/200000		;NO INPUT OR OUTPUT
	DPB T,[POINT 2,(R),1]	;LEFT 2 BITS IN SYMBOL
KILRET:	JRST RET		;USED AS A CONSTANT


KILL1:	MOVE R,ESTU		;REMOVE UNDEFINED SYMS
	JUMPGE R,UNDEF
KILL2:	PUSHJ P,EVAL0
	JRST RET
	PUSHJ P,REMUN
	JRST KILL2

REMUN:	MOVE S,[XWD 2,2]	;REMOVE ONE UNDEFINED SYMBOL
	ADDB S,ESTU
	MOVE W,-2(S)
	MOVEM W,(R)
	MOVE W,-1(S)
	MOVEM W,1(R)
	POPJ P,


TAG:	TLNN F,LTF   ; NO LETTERS IS ERROR
	JRST ERR   ; GO SAY ERROR
	TLNE F,FAF   ; DEFINE SYMBOLS
	JRST DEFIN		;A<B:
	TLNE F,CF		;DEFINE SYMBOL AS OPEN REGISTER
	JRST SETNAM
	MOVE W,LLOCO
	HRRZM W,DEFV

DEFIN:	PUSHJ P,EVALA		;DEFINED SYMBOL?
	JRST DEF1		;NO - DEFINE
	JRST DEF2		;YES, REDEFINE
DEF1:	MOVN R,[XWD 2,2]
	ADDB R,@SYMP	;MOVE UNDEFINED TABLE 2 REGISTERS
	HRRZ T,ESTU
	SUBI T,2
	HRL T,ESTU
	HRRM T,ESTU
	SKIPGE ESTU
	BLT T,-1(R)
DEF2:	MOVE T,DEFV
	MOVEM T,1(R)		;PUT IN NEW VALUE
	MOVSI T,GLOBAL
	IORB T,SYM
	MOVEM T,(R)		;PUT IN NEW SYM AS GLOBAL
	MOVE R,ESTU

DEF3:	JUMPGE R,RET		;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE T,SYM
	CAME T,(R)
	JRST DEF4
	MOVE S,DEFV
	SKIPGE, 1(R)
	MOVN S,S
	PUSH P,R
	MOVE R,1(R)
	PUSHJ P,FETCH
	JRST ERR
	ADD S,T
	HRRM S,T
	PUSHJ P,DEP
	 JFCL
	POP P,R
	PUSHJ P,REMUN
DEF4:	ADD R,[XWD 2,2]		;REMOVE THE NOW DEFINED SYMBOL
	JRST DEF3


SETNAM:	MOVE R,@SYMP		;SET PROGRAM NAME - DOLLAR COLON
SET1:	JUMPGE R,UNDEF
	MOVE T,(R)
	CAMN T,SYM
	JRST SET2
	ADD R,[XWD 2,2]
	JRST SET1
SET2:	MOVEM R,PRGM
	SETZM BLOCK
	PUSHJ P,SB1
	JRST RET
SBPRM:	MOVEM R,BLOCK
	JRST RET

SB1:	CAMN R,@SYMP
	POPJ P,
	SUB R,[XWD 2,2]
	LDB T,[POINT 4,(R),3]
	JUMPE T,CPOPJ
	CAIE T,3
	JRST SB1
	MOVE T,(R)
	XOR T,SYM
	TLZ T,740000
	JUMPN T,SB1
	JRST CPOPJ1

SETBLK:	TLNE F,LTF
	SKIPL R,PRGM
	JRST ERR
	PUSHJ P,SB1
	JRST UNDEF
	TLNE F,CF
	JRST SBPRM
	MOVEM R,TBLK
	JRST L1RPR


;***ROUTINES BEYOND HERE EVALUATE THEIR ARGUMENT***
MULT:	TLOA F,PTF+MLF		;*
DIVD:	TLO F,DVF+PTF		;SINGLE QUOTE
	JRST L1

ASSEM:	JRST PLUS		;#
MINUS:	TLO F,MF
PLUS:	TLO F,PTF
	JRST LIS2

LPRN:	CAML P,[XWD LPDL-4,0]	;LEFT PARENTHESIS
	JRST ERR
	PUSH P,F		;RECURSE FOR OPEN PAREN
	PUSH P,WRD
	PUSH P,FRASE
	PUSH P,FRASE1
	AOS,PRNC
	JRST LIS

INDIRE:	HRLZI W,20		;@
	IORB W,WRD
	TLO F,QF
	JRST LIS2

ACCF:	MOVE R,T		;COMMA PROCESSOR
ACCCF:	MOVSI T,.-.		;LEFT HALF OF A,,B
	TLOE F,COMF		;COMMA TYPED BEFORE?
	JRST ACCF1		;YES
	HRRM R,ACCCF		;NO, SAVE LEFT HALF OF A,,B
	HLLZ T,R
	LDB W1,[POINT 3,WRD,2]	;CHECK FOR IO INSTRUCTION
	IDIVI W1,7
	LSH R,27(W1)
	ADD T,R
	ADDB T,WRD
	JRST SPACE+1


ACCF1:	MOVEM T,WRD		;SET LEFT HALF OF A,,B
	JRST SPACE+1

SPACE:	TLNE F,QF
	TLO F,TIF
	TLZ F,MF+PTF
	JRST LIS1

RPRN:	TLNN F,QF		;)
	MOVEI T,0
	MOVS T,T
	SOSGE,PRNC
	JRST ERR
	POP P,FRASE1
	POP P,FRASE
	POP P,WRD
	POP P,F
	TLNE F,PTF
	TLNE F,SF
	JRST RPRN1
	MOVEM T,SYL
	TLO F,QF+SF
	JRST L1RPR
RPRN1:	ADDB T,WRD
	TLO F,QF
	JRST L1RPR-1


;REGISTER EXAMINATION LOGIC

LINEF:	PUSHJ P,DEPRA	;NEXT REGISTER
	PUSHJ P,CRNRB
	JRST .+2
LI0:	PUSHJ P,CRF
	AOS T,LLOC
LI1:	HRRZM T,LLOC
	HRRZM T,LLOCO
      	PUSHJ P,PAD
	MOVEI T,"/"
	CAME SCH,SCHM		; TEMP MODE SAME AS PERM MODE?
	JRST [	CAIN SCH,FTOC	; NO, IF CONSTANT MODE
		MOVEI T,"["	; USE [
		CAIN SCH,PIN	; IF SYMBOLIC MODE
		MOVEI T,"]"	; USE ]
		JRST .+1]
	TLNE F,STF
	MOVEI T,"!"
	PUSHJ P,TOUT
LI2:	TLZ F,ROF
	PUSHJ P,LCT
	MOVE R,LLOCO
	PUSHJ P,FETCH
	JRST LINCR
	TLO F,ROF
	TLNE F,STF
	JRST DD2
	JRST CONSYM		;RETURN IS A POPJ

LINCR:	TLO F,ROF		;PAGE NOT ASSIGNED, PRETEND WAS OPENED
	MOVEI W1,"?"		;BUT TYPE OUT ?
	JRST TEXT

VARRW:	PUSHJ P,DEPRA		;^
	PUSHJ P,CRF
	SOS T,LLOC
	JRST LI1

CARR:	PUSHJ P,DEPRA		;CLOSE REG
	JRST DD1.5


OCON:	TLNE F,QF		; QUANTITY TYPED?
	MOVEI SCH,FTOC		; YES SET TEMPORARY MODE
	TRO F,LF1+CF1		;OPEN AS CONSTANT
	JRST SLASH

OSYM:	TLNE F,QF
	MOVEI SCH,PIN
	TRZ F,CF1		;OPEN SYMBOLICALLY
	TROA F,LF1
SUPTYO:	TLOA F,STF		;SUPPRESS TYPEOUT
SLASH:	TLZ F,STF		;TYPE OUT REGISTER
	TLNN F,QF		;WAS ANY QUANTITY TYPED?
	JRST SLAS1		;NO. DO NOT CHANGE MAIN SEQUENCE
	MOVE R,LLOC		;YES. SAVE OLD SEQUENCE AND
	MOVEM R,SAVLOC
	HRRZM T,LLOC
SLAS1:	HRRZM T,LLOCO
	JRST LI2

ICON:	TLNN F,ROF	;REGISTER OPENED OR ERR
	JRST SUPTYO
	PUSHJ P,DEPRS
	JRST SLAS1


TAB:	PUSHJ P,DEPRS	;OPEN REGISTER OF Q
	MOVEI T,-1(T)
	EXCH T,LLOC		;SET UP NEW SEQUENCE AND
	MOVEM T,SAVLOC		;SAVE OLD SEQUENCE
	JRST LI0

DEPRA:	MOVE R,SAVLOC
	TLNE F,CF		;RESTORE OLD SEQUENCE IF $CR,$CF, OR
	EXCH R,LLOC		;IF $^ OR $BS WAS TYPED
	MOVEM R,SAVLOC		;SETUP "NEW" OLD SEQUENCE
	TLNE F,ROF		;IF REGISTER IS BEING CHANGED
	TLNN F,QF		;REMOVE ALL PREVIOUS UNDEFINED
	JRST DEPRS		;SYMBOL REFERENCES TO IT
	MOVE R,ESTU
	MOVEM W1,ESTU
DEPRA2:	JUMPGE R,DEPRS
	HRRZ W,1(R)
	CAMN W,LLOCO
	PUSHJ P,REMUN
	ADD R,[XWD 2,2]
	JRST DEPRA2

EQUAL:	TROA F,LF1+CF1		;=
PSYM:	TRZ F,CF1		;@
	TRO F,LF1
	PUSHJ P,CONSYM
	JRST RET

R50PNT:	LSH T,-36	;RADIX 50 SYMBOL PRINTER
	TRZ T,3
	PUSHJ P,TOC
	PUSHJ P,TSPC
	SETZM SVFB
	MOVEI W1,LWT	;SETUP FOR SPT
	JRST SPT

SIXBP:	MOVNI W2,6		;SIXBIT PRINTER
	MOVE W1,LWT
SIXBP1:	MOVEI T,0
	ROTC T,6
	ADDI T,40
	PUSHJ P,TOUT
	AOJL W2,SIXBP1
	POPJ P,


;MODE CONTROL SWITCHES

TEXO:	MOVEI R,TEXTT-HLFW	;$T ASSUME 7 BIT ASCII
	MOVE T,WRD2
	CAIN T,6		;CHECK FOR $6T
	MOVEI R,SIXBP-HLFW	;SET MODE SWITCH FOR SIXBIT
	CAIN T,5		;CHECK FOR $5T
	MOVEI R,R50PNT-HLFW	;SET MODE SWITCH FOR RADIX 50
HWRDS:	ADDI R,HLFW-TFLOT		;H
SFLOT:	ADDI R,TFLOT-PIN		;F
SYMBOL:	ADDI R,PIN-FTOC		;S
CON:	ADDI R,FTOC		;C
	HRRZM R,SCH
	JRST BASE1

RELA:	TRZE F,Q2F		;CHANGE ADDRESS MODE TO RELATIE
	JRST BASECH
	MOVEI R,PADSO-TOC
ABSA:	ADDI R,TOC		;A
	HRRZM R,AR
	JRST BASE1

BASECH:	MOVE T,WRD2		;$NR  CHANGE OUTPUT RADIX TO N, N>1
	CAIGE T,2
	JRST ERR
	HRRZM T,ODF
BASE1:	MOVS S,[XWD SCHM,SCH]
	TLNN F,CCF
	JRST LIS1
	BLT S,ODFM	;WITH $$, MAKE MODES PERMANENT
	HLRS MMODF		;MAKE MEMRY MODE PERMANENT
	JRST RET

SEMIC:	MOVEM T,LWT		;SEMICOLON TYPES IN CURRENT MODE
	JRST @SCH

;SET MEMORY MODE, $1U ON, $0U IS OFF
;ON MEANS FETCH AND STORE DONE WITH UMOVE, UMOVEM

UMOD:	HRRZS MMODF		;LEFT HALF IS TEMP, RIGHT IS PERM
	MOVE T,WRD2
	CAIN T,1		;ON?
	HRROS MMODF		;YES
	SETOM LASTPG
	JRST BASE1


;GO AND EXECUTE LOGIC
;ROUTINE TO GET THE STARTING ADDRESS IN RH OF T
UJOBSA==120			;LOC OF DEC STARTING ADDRESS

GETST:	PUSH	P,1		;SAVE ACS
	PUSH	P,2
	MOVEI	1,400000	;THIS FORK
	GEVEC			;GET ENTRY VECTOR
	HRR	T,2		;ASSUME TENEX
	CAMN	2,[JRST 400010]	;IS IT REALLY TENEX?
	  HRR	T,UJOBSA	;NO, DEC STYLE

	POP	P,2		;RESTORE ACS
	POP	P,1
	POPJ	P,		;RETURN


GO:	HRLI	T,(JRST)	;$G
	TLOE	F,QF		;DID USER GIVE ADDRESS?
	   JRST	XEC0		;USE IT
	PUSHJ	P,GETST		;GET ADDRESS IN RH OF T
	TRNE	T,-1		;IF NO ADDR THEN ERROR

XEC:	TLNN F,QF		;X
	JRST ,ERR
XEC0:	MOVEM T,TEM
	PUSHJ P,CRF
	PUSHJ P,TTYLEV
	PUSHJ P,INSRTB
	SETZM SKPCT
	JSP T,RESTORE
	XCT TEM
	AOS SKPCT
	AOS SKPCT
	JSR SAVE		;HANDLES UP TO +3 SKIP
	PUSHJ P,REMOVB
	MOVEI TT,3
	SUB TT,SKPCT		;CALCULATE SKIP AMOUNT
	MOVEI W1,"$"
	PUSHJ P,TEXT		;TYPE N $'S FOR RETURN +N
	SOJG TT,.-2
	JRST DD1

XEC1:	JRST DDT		;USED  AT PROC0

;WRITE-PROTECT LOGIC
;ADDR TO BE WRITE-PROTECTED IS IN T

WPROT:	
	MOVEM	T,PRTADR	;SAVE ADDRESS
	HRLM	T,NBP*4+B1ADR-4	;MARK FOR PRINTOUT
	JUMPE	T,UNPROT	;NO WRITE-PROTECT LOCATION?

	MOVE	R,T		;
	PUSHJ	P,FETCH		;GET CONTENTS OF ADDRESS
	  JRST	ERR		;CANNOT FETCH

	MOVEM	T,PRTCON	;SAVE CONTENTS
	SKIPA	T,[JSR	PRTCHK]
UNPROT:	SETZ	T,
PRTSET:	MOVEM	T,NBP*4+B1ADR-3	;SET CONDITIONAL BP
	POPJ	P,	



PRTADR:	0
PRTCON:	0
SAVE1:	0

;THIS ROUTINE SHOULD BE WRITTEN TO USE THE FETCH
;PROCEDURE -- BUT THAT REQUIRES MORE EXPENSE THAN
;PERHAPS DESIRABLE, SINCE WE WOULD HAVE TO DO A SAVE
;EACH TIME IN.		RLS

PRTCHK:	0			;JSR TO HERE
	MOVEM	1,SAVE1		;SAVE AC 1
	MOVE	1,@PRTADR	;GET ADDRESS
	CAME	1,PRTCON	;IS IT THE SAME?
	   JRST	FNDWRT		;WRITTEN
PRTRET:	MOVE	1,SAVE1		;GET BACK 1
	JRST	@PRTCHK		;RETURN

FNDWRT:	
	MOVEM	1,PRTCON	;SAVE NEW CONTENTS

	HRROI	1,[ASCIZ/(WP)/]
	PSOUT
	AOS	PRTCHK
	JRST 	PRTRET


;CODE TO HANDLE ANY DISPLAY FEATURES AVAILABLE IN DDT
;ARRIVE HERE ON ALL BREAK POINTS
DSPSIZ==5

DISPLY:

;;;	HRRZ	T,BREAK2	;GET BP NO.
;;;	CAIE	T,NBP		;IS IT THE SINGLE-STEPPER?
;;;	  JRST	DSPRET		;NO
;PRINT OUT THE INSTRUCTION
	MOVEI	T,"/"	
	PUSHJ	P,TOUT		;PRINT A SLASH
	PUSHJ	P,LCT		;PRINT SOME SPACES
	HRRZ	R,LLOC		;GET CURRENT ADDRESS
	PUSHJ	P,FETCH		;NOW GET CONTENTS IN T
	  JRST	BPLUP		;ERROR
	MOVEM	T,LWT		;ARG FOR PIN
	PUSHJ	P,PIN		;PRINT INSTRUCTION (IGNORE CURRENT MODE)
	PUSHJ	P,CRF		;PRINT A CRLF

DSPRET:	MOVEI	R,DSPLST
DSPRE1:	SKIPN	(R)		;SHOW THIS?
	   JRST	NODSP		;NOPE
	PUSH	P,R		;SAVE
	MOVE	T,(R)		;ADDR
	PUSHJ	P,LI1		;DISPLAY LINE, CURRENT MODE
	PUSHJ	P,CRF		;CRLF
	POP	P,R		;RESTORE
NODSP:	AOJ	R,
	CAIGE	R,DSPLST+DSPSIZ	;MORE?
	  JRST	DSPRE1		;YES
	POPJ	P,		;NO


	
DSPLST:	BLOCK DSPSIZ


MKLIST:	MOVEI	T,DSPLST	;L
	MOVEI	W,1	
	MOVEM	W,FRASE1	
	JRST	QUANIN		;THE QUANTITY








;BREAK POINT LOGIC

BP1:	REPEAT NBP,<	0		;JSR TO HERE FOR BREAKPOINT
	JSA T, BCOM
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT IS IN PLACE
	0
>

B1INS==BP1+2
BPN==.-4

BCOM:	0
	POP T,LEAV		;MOVE INSTRUCTION TO LEAV
	MOVEI T,B1SKP-B1INS+1(T)
	HRRM T,BCOM3		;CONDITIONAL BREAK SETUP
	MOVEI T,B1CNT-B1SKP(T)
	HRRM T,BCOM2		;PROCEDE COUNTER SETUP
	MOVE T,BP1-B1CNT(T)
	HLLM T,LEAV1		;SAVE FLAGS FOR NO-BREAK RESTORE
	MOVEM T,SAVPI		;STANDARD PLACE OF BREAK PC
	MOVE T,BCOM

BCOM3:	SKIPE B1SKP		;ADDR MOD TO LOOK AT COND. INST.
	XCT @.-1		;XCT CONT INST, BREAK IF SKIPS
BCOM2:	SOSG B1CNT		;ADDR MOD TO LOOK AT PROCEED COUNTER
	JRST BREAK

	MOVEM T,AC0+T
	SKIPE	EXU0		;ARE WE SINGLE-STEPPING?
	   JRST	PROC1		;YES
	LDB T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIL T,264	;JSR
	CAILE T,266	;JSA,JSP
	TRNN T,700	;UUO
	JRST PROC1		;MUST BE INTERPRETED
	CAIE T,260	;PUSHJ
	CAIN T,256	;XCT
	JRST PROC1		;MUST BE INTERPRETED
	MOVE T,AC0+T
	JRST 2,@LEAV1
LEAV1:	XWD 0,LEAV

RETB:	HRRZ T,BCOM2	;SET UP TEXT STRING
	SKIPE T,1(T)
	HRLI T,(<POINT 7,0>)
	MOVEM T,STRING
	JRST RET


BREAK:	SETZM SARS		;BE SURE TO SAVE AC'S ON BREAK
	JSR SAVE		;SAVE THE WORLD
	PUSHJ P,REMOVB		;REMOVE BREAKPOINTS
	PUSHJ P,CHKSYM	;RESET PRGM AND BLOCK IF SYMBOLS MOVED
	SOS T,BCOM3
	HRRZS T			;GET ADDR OF BREAKPOINT JUST HIT
	SUBI T,B1ADR-4
	IDIVI T,4
	HRRM T,BREAK2	;WE WANT IT LATER
	MOVE W1,BRKNAM-1(T)	;GET THE RIGHT JUNK
	PUSHJ P,TEXT2		;AND PRINT
		;<<<<<<< THESE BALANCE THE >'S IN THE NEXT FEW LINES
	MOVSI W1,(<ASCIZ />/>)		;TYPE > FOR COND BREAK
	SKIPG @BCOM2		;TEST PROCEED COUNTER
	MOVSI W1,(<ASCIZ />>/>)	;TYPE >> FOR PROCEED COUNTER BREAK
	PUSHJ P,TEXT2
	MOVE T,SAVPI		;BREAK PC
	MOVEI T,-1(T)
	MOVE W1,LLOC		;SAVE CURRENT SEQUENCE
	MOVEM W1,SAVLOC
	HRRZM T,LLOC		;SET CURRENT SEQ TO BREAK ADR
	PUSHJ P,PAD		;TYPE PC AT BREAK
	PUSHJ	P,DISPLY	;DO ANY DISPLAY STUFF
	HRRZ T,@BCOM3
	HRRM T,PROC0		;SETUP ADDRESS OF BREAK
	HLRZ T,@BCOM3
	JUMPE T,BREAK1		;TEST FOR REGISTER TO EXAMINE
	PUSHJ P,LCT		;PRINT TAB
	HLRZ T,@BCOM3
	PUSHJ P,LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:	MOVSI S,400000
BREAK2:	ROT S,0	;WILL BE MODIFIED WITH BREAK NUM
	PUSHJ P,LISTEN		;DONT PROCEED IF TTY KEY HIT
	TDNN S,AUTOPI		;DONT PROCEED IF NOT AUTOMATIC
	JRST RETB		;DONT PROCEED
	MOVEI T,2	;COMPENSATE FOR SOS
	ADDB T,@BCOM2
	JUMPL T,PROCD1	;GO IF STILL LESS THAN
	ANDCAM S,AUTOPI	;TURN OFF AUTOPI
	JRST RETB	;AND BREAK

RADIX ^D10
BRLNAM:
I==1
DEFINE	QQ(N)<
	ASCII /$'N'B/
>
BRKNAM:	REPEAT	NBP,<
QQ \I
I==I+1
>
RADIX 8

;CODE FOR $V COMMAND -- SINGLE-STEPPING
;SYNTAX -- P(W)$V
;P IS THE PROCEED COUNT, W THE WRITE-PROTECT LOCATATION
;IF P IS 0 OR NON-EXISTENT, THEN 1 ASSUMED.  IF W IS
;0 OR NON-EXISTENT, THEN NO WRITE-PROTECTION.
;SIMILAR SYNTAX FOR $Y -- SINGLE-CALLING
;$V COMES TO PROCDN   $Y COMES TO PROCDC

PROCDC:	SETOM	EXU1		;INDICATE SINGLE-CALLING
	SKIPA			
PROCDN:
	SETZM	EXU1		;INDICATE NO SINGLE-CALLING
	SETOM	EXU0		;SET UP FOR SINGLE INSTRUCTION
	TLZN	F,QF		;ANY ARGUMENTS?
	  MOVEI	T,1		;SET UP FOR XWD 0,1

	PUSH	P,T		;SAVE T
	HLRZ	T,T		;GET WRITE-PROTECT ADDRESS
	PUSHJ	P,WPROT		;PROTECT OR UNPROTECT
	POP	P,T		;GET BACK T

	HRRZ	T,T		;RIGHT HALF ONLY
	SKIPN	T		;SKIP IF NON-ZERO

        MOVEI	T,1
	MOVEM	T,NBP*4+B1ADR-2	;PUT IN REPEAT COLUMN OF TABLE

;IF NOT AT A BP, THEN START AT JOB STARTING ADDRESS

	HRRZI	R,XEC1		;MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ	P,FETCH		;GET ADDR
	  JRST 	BPLUP1		;ERROR	
	HRRZ	T,T		;LOOK AT ADDR ONLY
	CAIE	T,DDT		;ISN'T DDT HOPEFULLY
	  JRST 	PROCE1		;NO, ISN'T
	PUSHJ	P,GETST		;GET STARTING ADDRESS (IN RH OF T)
	HRRM	T,XEC1		;PROCEED FROM THE STARTING ADDRESS
	JRST	PROCE1		;NOW PROCEED


PROCEDE: TLNE F,QF		;N$P	;PROCEED AT A BREAKPOINT
	JRST PROC3
	MOVEI T,1
	TLNE F,CCF	;IF $$P
	MOVSI T,200000	;THEN VERY LARGE COUNT
PROC3:	TLNE F,CCF	;IF AUTOPROC
	MOVNS T		;NEGATE
	MOVEM T,@BCOM2

PROCE1:	HRRZ R,BCOM3
	PUSHJ P,AUTOP
PROCD1:	PUSHJ P,CRF
	PUSHJ P,TTYLEV
PROC0:	HRRZI R,XEC1		;MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ P,FETCH
	JRST BPLUP1		;ONLY GET HERE IF MEMORY SHRANK
	MOVEM T,LEAV
	PUSHJ P,INSRTB
	JRST PROC2

PROC1:	MOVE T,AC0+T
	JSR SAVE
	JFCL
PROC2:	MOVEI W,100
	MOVEM W,TEM1		;SETUP MAX LOOP COUNT
	JRST IXCT5


IXCT4:	JUMPE T,IXCT6		;SYSTEM UUO? (0, 40-77)
	CAIL T,40
	JRST IXCT6		;YES, DON'T INTERPRET
	MOVEM R,40		;INTERPRET FOR NON-SYSTEM UUOS
	MOVEI R,41
IXCT:	SOSL TEM1
	PUSHJ P,FETCH
	JRST BPLUP		;BREAKPOINT LOOPING OR FETCH FAILED
	MOVEM T,LEAV
IXCT5:	MOVE T,LEAV		; GET INSTRUCTION TO BE DONE
IXCT5A:	LDB W1,[POINT 4,T,17]	; GET INDEX FIELD
	CAIE W1,0
	MOVE W1,AC0(W1)		; GET CONTENTS OF INDEX REG
	ADD W1,T		; EFFECTIVE ADDRESS SO FAR
	TLNN T,20		; INDIRECT?
	JRST IXCT5B		; NO, DONE
	HRRZ R,W1
	SOSL TEM1
	PUSHJ P,FETCH		; FETCH THE INDIRECT ADDRESS
	JRST BPLUP		; LOOPING OR OUT OF RANGE
	JRST IXCT5A

IXCT5B:	HRRZS W1
	DPB W1,[POINT 23,LEAV,35]	; STORE IN INSTRUCTION
	LDB W1,[POINT 4,LEAV,12]	;PICK UP AC FIELD
	LDB T,[POINT 9,LEAV,8]		;PICK UP INSTRUCTION FIELD
	MOVE P,PS
;NOW INTERPRET INSTRUCTION
	CAIL	T,400			;CHECK IF INST BETWEEN SETZ (400)
	CAILE	T,677			;AND TSON (677)
	  SKIPA				;NOT IN RANGE
	JRST	IXCT6			;IN RANGE
	CAIN	T,41			;INIT?
	  JRST	DOINIT			;YES, QUITE SPECIAL
	CAIN T,260
	JRST  IPUSHJ		;INTERPRET PUSHJ
	
	CAIN T,264
	JRST IJSR		;INTERPRET JSR
	CAIN T,265
	JRST IJSP		;INTERPRET JSP
	CAIN T,266
	JRST IJSA		;INTERPRET JSA
	MOVE R,LEAV
	TRNN T,700
	JRST IXCT4		;INTERPRET UUO
	CAIN T,256
	JUMPE W1,IXCT		;INTERPRET XCT IF AC=0 (NOT UXCT)
;CHECK IF WE ARE SINGLE-STEPPING
	SKIPN	EXU0		;ARE WE SINGLE-STEPPING?
	  JRST	IXCT6		;NO
	CAIN	T,254		;INTERPRET JRST
	  JRST	LEAV2
	CAIN	T,255		;INTERPRET JFCL
	  JRST	LEAV2
	CAIN	T,243		;INTERPRET JFFO
	  JRST	LEAV2
	CAIN	T,252		;AOBJP
	  JRST	LEAV2
	CAIN	T,253		;AOBJN
	  JRST	LEAV2
	CAIN	T,267		;JRA
	  JRST	LEAV2	
	CAIN	T,263		;POPJ
	  JRST	IPOPJ
	CAIG	T,317		;JUMP,AOJ,SOJ
	  JRST	IXCT6		;NONE OF THOSE	
	CAIL	T,370		;IN RANGE?
	  JRST	IXCT6	
	TRNN	T,10		;HAS TO JUMP TO EXCT6
	  JRST	LEAV2	


IXCT6:		JSP T,RESTOR	; RESTORE ACS & PI
LEAV:	0			;INSTRUCTION MODIFIED
	JRST	LEFT
	AOSA	SAVPI		;+2
	AOSA	SAVPI		;+3	
	JRST 	LEFT		;
	JRST LEAV+2

LEFT:
	SKIPN	EXU0		;SINGLE-STEPPING?
	  JRST	@SAVPI		;YES
	JSR	SAVE
	JFCL
	HRRZ	T,SAVPI
	JRST	XREST		;PUT IN NEXT BREAKPOINT

LEAV2:
	MOVEI	T,LEAV3
	HRRZ 	R,LEAV		;PUT LEAV3 IN EFF ADR
	HRRM	T,LEAV
	MOVEM	R,LEAV4		;
	JRST	IXCT6
LEAV3:	JSR	SAVE		;COME HERE AFTER JUMP
	JFCL
	HRRZ	T,LEAV4		;PICK UP EFF. ADDR.
	JRST	XREST
LEAV4:	0



BPLUP:	PUSHJ P,REMOVB		;BREAKPOINT PROCEED ERROR
BPLUP1:	JSR SAVE
	JFCL
	JRST ERR

IPOPJ:
	HRRZ	R,AC0(W1)	;GET THE PDL-POINTER
	PUSHJ	P,FETCH		;GET THE PC-WORD IN T
	  JRST	BPLUP		;CANNOT GET WORD
	PUSHJ	P,XECU0		;SET UP BREAK POINT
	JRST	IXCT6		;AND EXECUTE


DOINIT:	MOVE	R,LEAV		;INSTRUCTION
	MOVEM	R,DINIT
	MOVE	T,SAVPI		;ADDR OF NEXT INSTRUCTION
	MOVE	R,(T)		;GET DEVICE
	MOVEM	R,DINIT+1
	MOVE	R,1(T)		;BUFFER INFO
	MOVEM	R,DINIT+2
	ADDI	T,2		;INCREMENT RETURN ADDRESS
	MOVEM	T,SAVPI		;AND SAVE
	JSP	T,RESTOR	;RESTORE USER STUFF
DINIT:	INIT			;MOD FOR INIT
	SIXBIT/DSK/		;MOD FOR INIT
	0			;MOD FOR INIT
	JRST	LEFT		;ERROR RETURN
	AOS	SAVPI		;NORMAL RETURN
	JRST	LEFT		;AND CONTINUE





IPUSHJ:	DPB W1,[POINT 4,CPUSHP,12]
	SETZM TEM3
	MOVE T,LEAV
	JRST XRSTC1

IJSA:	MOVE T,SAVPI		;INTERPRET JSA
	HRL T,LEAV
	EXCH T,AC0(W1)
	JRST IJSR2

IJSR:	MOVE T,SAVPI		;INTERPRET JSR
IJSR2:	MOVE R,LEAV
	PUSHJ P,DEP
	JRST BPLUP		; CANNOT DEPOSIT
	AOSA T,LEAV
IJSR3:	MOVE T,LEAV
IJSR4:	JRST XRESTC

IJSP:	MOVE W,SAVPI		;INTERPRET JSP
	MOVEM W,AC0(W1)
	JRST IJSR3

;SINGLE-STEPPING STUFF
EXU0:	0			;TRUE IF SINGLE-STEPPING
EXU1:	0			;TRUE IF SINGLE-CALLING

XRSTC1:
	PUSHJ	P,XECUC		;SINGLE-CALLING
	JRST	RESTR1


XREST1:	
	PUSHJ	P,XECU0		;SINGLE-STEPPING
	JRST	RESTR1

XRESTC:
	PUSHJ	P,XECUC		;SINGLE-CALLING
	JRST	RESTORE


XREST:	PUSHJ	P,XECU0		;SINGLE-STEPPING
	JRST	RESTORE




XECU0:
	MOVEM	T,SAVE
	SKIPN 	EXU0		;SINGLE-STEPPING?
	  POPJ	P,		;NO
XECUB:	PUSHJ	P,REMOVB	;REMOVE ALL BP'S
	HRRZ	T,SAVE
;DO NOT SINGLE STEP INTO DDT
CKDDT:	CAIL	T,DDT		;WITHIN DDT?
	CAILE	T,DDTEND
	SKIPA			;CONTINUE CHECKING
	  JRST	INDDT		;NO
;NOW BE SURE THAT ANOTHER BP IS NOT ALREADY THERE
CKBPS:
	MOVEI	S,BP1		;START LOOKING AT BP'S
CKBP1:	HRRZ	R,B1ADR-BP1(S)	;GET THIS BP
	CAMN	R,T		;SAME BP?		
	  JRST	INDDT		;YES, DONT USE
	ADDI	S,4		;NEXT BP
	CAIG	S,BPN-4		;LOOK THRU NEXT-TO-LAST BP
	  JRST 	CKBP1		;MORE
	JRST	CKDUN		;OK, NO DUPLICATION HERE

INDDT:	SETZM	NBP*4+B1ADR-4
	JRST XECU1		;SETUP BP
CKDUN:
	HRRM	T,NBP*4+B1ADR-4	;SET UP BP ADDR

XECU1:	PUSHJ	P,AUTOP
	PUSHJ	P,INSRTB	;PUT ALL BP'S BACK
	MOVE	T,SAVE
	POPJ	P,		

;HERE IF SINGLE-CALLING
XECUC:	MOVEM	T,SAVE
	SKIPN	EXU0		;SINGLE-STEPPING?
	  POPJ	P,		;NO
	SKIPN	EXU1		;SINGLE-CALLING?
	  JRST 	XECUB		;NO, SO SINGLE-STEP.
	PUSHJ	P,REMOVB	;REMOVE BPS
;NOW GET THE ADDRESS INTO RH OF T
	HRRZ	T,SAVPI		;CHECK ADDRESS
CKOP:	PUSH	P,T		;SAVE IT
	MOVE	R,T		;ARG

	PUSHJ	P,FETCH	
	  JRST	BPLUP 		;ERROR
	LDB	R,[POINT 9,T,8]	;GET INSTRUCTION FIELD
	POP	P,T		;RESTORE
	CAIN	R,0		;NOT UUO 0
	   JRST	OPERR
	CAIN	R,320		;NOR JUMP (FOR F40)
	   JRST	OPERR
	JRST	CKDDT 		;USE THIS ADDRESS, IF OTHERWISE OK
	
OPERR:	AOJ	T,		;LOOK AT NEXT ADDR IN SEQUENCE
	JRST 	CKOP		;AGAIN		


;INSERT BREAKPOINTS

INSRTB:	MOVE S,[JSR BP1]
INSRT1:	SKIPE R,B1ADR-BP1(S)
	PUSHJ P,FETCH
	JRST INSRT3
	MOVEM T,B1INS-BP1(S)
	MOVE T,S
	PUSHJ P,DEP
	JFCL 0			;READ ONLY PAGE
INSRT3:	ADDI S,4
	CAMG S,[JSR BPN]
	JRST INSRT1
	POPJ P,

;REMOVE BREAKPOINTS

REMOVB:	MOVEI S,BNADR
REMOV1:	MOVE T,B1INS-B1ADR(S)
	SKIPE R,(S)
	PUSHJ P,DEP
	JFCL 0			;READ ONLY PAGE
	SUBI S,4
	CAIL S,B1ADR
	JRST REMOV1
	POPJ P,


;ALL $B COMMANDS OF FORM <A>$<N>B

BPS:	TLZE F,QF
	JRST BPS1
	TRZE F,Q2F
	JRST BPS2
	MOVE T,[XWD B1ADR,B1ADR+1]
	SETZM  B1ADR
	BLT T,AUTOPI	;CLEAR OUT ALL BREAKPOINTS AND AUTO PROCEDE REGESTER
	JRST RET

BPS1:	TRZN F,Q2F
	JRST BPS3
	MOVE R,T
	TRO F,2
BPS2:	MOVE T,WRD2
	CAIL T,1
	CAILE T,NBP
	JRST ERR
	IMULI T,4
	ADDI T,B1ADR-4
	TRZN F,ITF
	JRST MASK2
	EXCH R,T
	JRST BPS5

BPS3:	MOVEI R,B1ADR		;PROCESS THE A$B
BPS4:	HRRZ W,(R)
	CAIE W,(T)
	SKIPN (R)
	JRST BPS5
	ADDI R,4
	CAIG R,BNADR
	JRST BPS4
	JRST ERR
BPS5:	MOVEM T,(R)
	SETZM 1(R)
	SETZM 2(R)
	SETZM 3(R)
AUTOP:	SUBI R,B1ADR		;AOUT PROCEED SETUP
	IDIVI R,4
	MOVEI S,1
	LSH S,(R)
	ANDCAM S,AUTOPI
	TLNE F,CCF
	IORM S,AUTOPI
	POPJ P,


;FETCH AND DEPOSIT INTO MEMORY


DEPRS:	MOVEM T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE R,LLOCO		;QUAN TYPED IN REGIS EXAM
	TLZE F,ROF
	TLNN F,QF
	POPJ P,0
	PUSHJ P,DEP		;STORE AWAY
	JRST ERR		;CAN'T STORE (IN DDT OR OUT OF BOUNDS)
	POPJ P,			;RETURN

;DEPOSIT INTO MEMORY SUBROUTINE

DEP:	TRNN R,777760
	JRST DEPAC		;DEPOSIT IN AC
	JSP TT1,CHKADR		;CHECK ADDRESS
	JUMPE TT,DEP2		;IF NO PAGE, OK TO STORE
	TLNN TT,(1B3+1B9)	;STORE OK IF WRITE OR WRITE-COPY
	POPJ P,
DEP2:	SETOM LASTPG		;STORING MAY CHANGE ACCESS OF PAGE
	SKIPGE MMODF		;USER MODE?
	JRST UDEP		;YES
	MOVEM T,(R)
	JRST CPOPJ1		;SKIP RETURN

UDEP:	UMOVEM T,0(R)		;DEPOSIT INTO USER SPACE
	JRST CPOPJ1

DEPAC:	MOVEM T,AC0(R)		;DEPOSIT IN AC
	JRST CPOPJ1		;SKIP RETURN


;FETCH FROM MEMORY SUBROUTINE

FETCH:	TRNN R,777760		;IN AC?
	JRST FETAC		;YES
	JSP TT1,CHKADR
	TLNN TT,(1B2)		;READ ACCESS?
	POPJ P,			;NO
	SKIPGE MMODF		;USER?
	JRST UFET		;YES
	MOVE T,(R)		;NO
	JRST CPOPJ1		;SKIP RETURN ONLY FOR LEGAL ADDRESS

UFET:	UMOVE T,0(R)		;FETCH FROM USER SPACE
	JRST CPOPJ1

FETAC:	MOVE T,AC0(R)
	JRST CPOPJ1

CHKADR:	PUSH P,1
	PUSH P,2
	MOVEI 1,0(R)
	ANDI 1,777000
	MOVE 2,LASTPG		;LAST PAGE CHECKED AND ACCESS
	CAIN 1,0(2)		;SAME PAGE?
	JRST CHKA3		;YES
	MOVEM 1,LASTPG		;REMEMBER LAST PAGE CHECKED
	JSP 2,.+1		;GET USER/MON MODE
	SKIPL MMODF		;USER MODE REQUEST? OR
	TLNE 2,(1B5)		;RUNNING IN USER MODE?
	JRST CHKA1		;YES
	MRPAC			;NO, DO MONITOR RPACS
	JRST CHKA2

CHKA1:	LSH 1,-^D9		;SHIFT TO PAGE NUMBER
	HRLI 1,400000		;CURRENT FORK
	RPACS			;READ ACCESSIBILITY OF PAGE
CHKA2:	HLLM 2,LASTPG		;SAVE ACCESS OF PAGE
CHKA3:	HLLZ TT,2		;ACCESS RETURNED IN 2
	POP P,2
	POP P,1
	JRST 0(TT1)


FIRARG:	MOVEM T,DEFV
	TLO F,FAF
	JRST ULIM1
ULIM:	TLO F,SAF
	HRRZM T,ULIMIT
ULIM1:	TLNN F,QF
	JRST ERR
	JRST LIS0


LOOK:	TLNN T,-1		;IF LEFT HALF NON-0, OR
	CAIGE T,140		;VALUE LESS THAN 140,
LOOKE:	TLOA F,(1B2)		;SKIP LOCALS OUTSIDE CURRENT PGM
	TLZ F,(1B2)		;OTHERWISE, ALLOW LCLS AND SAVE CONTEXT
	SETZM SVFB
	SETZM SVTB
	SETOM BLVL
	HLRE S,@SYMP
	ASH S,-1
	TLZ F,600000
	HRLZI W2,DELO+DELI
	MOVEM T,TEM
	SKIPL R,PRGM
	JRST TOPDWN
LOOK1:	SUB R,[XWD 2,2]
	TDNE W2,(R)
	JRST LOOK3
	LDB T,[POINT 4,(R),3]
	CAIN T,3
	JRST BLNME
	JUMPE T,PNAM
	TRNE T,LOCAL/40000
	TLZA F,(1B1)
	TLO F,(1B1)
	MOVE T,TEM
	MOVE W,1(R)
	XOR W,T
	JUMPL W,LOOK3
	SUB T,1(R)
	JUMPL T,LOOK3
	JUMPGE F,LOOK2
	MOVE W,1(R)
	SUB W,1(W1)
	JUMPL W,LOOK3
	JUMPG W,LOOK2
	SKIPN SVTB		; THIS SYMBOL NO PREFIX
	SKIPN SVFB		; AND LAST SYMBOL WITH PREFIX?
	JRST LOOK3		; NO


LOOK2:	HRR W1,R
	TLO F,(1B0)		; REMEMBER WE HAVE FOUND SOME SYMBOL
	MOVE W,SVTB
	TLNE F,(1B1)		; IF THIS SYMBOL IS GLOBAL,
	MOVEI W,0		; THEN DON'T SAVE BLOCK
	MOVEM W,SVFB
	SKIPN W			; ANY PREFIX?
	JUMPE T,SPT0		; NO, THEN EXACT MATCH IS BEST
LOOK3:	CAMN R,@SYMP
	JRST TOPDWN
LOOK3A:	AOJLE S,LOOK1
	MOVE T,TEM
	TLNE F,(1B0)
	SUB T,1(W1)
	JUMPE T,SPT0
	JRST CPOPJ1

TOPDWN:	TLNE F,(1B2)
	TLO W2,LOCAL
	HLRE R,@SYMP
	MOVNS R
	ADD R,@SYMP
	JRST LOOK3A

PNAM:	TLNE F,(1B2)
	TLO W2,LOCAL
	SKIPA T,[-1]		; PROGRAM NAMES LIKE BLOCKS OF LEVEL -1
BLNME:	MOVE T,1(R)		; GET BLOCK LEVEL
	MOVEM R,SVTB		; SAVE THIS BLOCK LOCATION
	CAMN R,BLOCK		; IS THIS THE CURRENT BLOCK?
	JRST BLNM1		; YES
	CAML T,BLVL		; IS BLOCK BELOW CURRENT?
	JRST LOOK3		; YES, RETAIN PREFIX
BLNM1:	SETZM SVTB		; THIS IS CURRENT OR ABOVE
	MOVEM T,BLVL
	JRST LOOK3


CONSYM:	MOVEM T,LWT
	TRNN F,LF1
	JRST (SCH)		;PIN OR FTOC
	TRNE F,CF1
	JRST  FTOC

PIN:				;PRINT INSTRUCTION
	TLC T,700000
	TLCN T,700000
	JRST INOUT		;IN-OUT INSTRUCTION OR NEG NUM
	AND T,[XWD 777000,0]	;EXTRACT OPCODE BITS
	JUMPE T,HLFW		;TYPE AS HALF WORDS
	PUSHJ P,OPTYPE
PIN1:	TRNE F,ITF		;INSTRUCTION TYPED?
	JRST PFULI1		;YES
	MOVE T,LWT		;TRY TO FIND FULL WORD MATCH
	TLNE T,777		;BUT NOT IF AC, @, OR X FIELDS NON-0
	JRST PFULI1
IFN IMSSS,<
COMMENT ! HERE LOOKING FOR A MATCH IN THE JSYS TABLE. !
	PUSH	P,R
	MOVE	R,[XWD -JTBLSZ,JTBL]
JLAGN:  CAMN	T,1(R)		;DOES THE VALUE MATCH?
	  JRST	ULFND		;YES
	ADD	R,[XWD 2,2]	;INCREMENT POINTER	
	JUMPL	R,JLAGN		;LOOK AGAIN
	JRST	NJFND		;NO LUCK	
ULFND:
	MOVEI	W1,(R)		;ADDRESS OF SYMBOL
	PUSHJ	P,SPT1W		;PRINT OUT, LESS BLK NAME
	POP	P,R
	JRST	PADS1		;FOUND
NJFND:	POP	P,R		;AND FALL THROUGH
>;IFN IMSSS
	PUSHJ	P,LOOK
	  JRST	PADS1		;FOUND
PFULI1:
	MOVSI	T,777000
	AND 	T,LWT
	TRNN F,ITF		;HAS INSTRUCTION BEEN TYPED?
	PUSHJ P,LOOK		;NO, LOOK IN SYMBOL TABLE
	TROA F,NAF		;INSTRUCTION TYPED, ALLOW NEG ADDRESSES
	JRST HLFW		;NOT FOUND, OUTPUT AS HALFWORDS
	PUSHJ P,TSPC
	LDB T,[XWD 270400,LWT]	;GET AC FIELD
	JUMPE T,PI4
	PUSHJ P,PAD
PI3A:	MOVEI W1,","
	PUSHJ P,TEXT
PI4:	MOVE W1,LWT
	MOVEI T,"@"
	TLNE W1,20		;CHECK FOR INDIRECT BIT
	PUSHJ P,TOUT
	HRRZ T,LWT
	LDB W,[XWD 331100,LWT]	;INSTRUCTION BITS
	TLNE W1,20
	JRST PI8
	CAIL W,240
	CAILE W,247
	JRST PI8A		;ALL (EXCEPT ASH,ROT,LSH) HAVE SYMBOLIC ADRS
	CAIN W,<JFFO>_-33
	JRST PI8		;JFFO AND @ GET SYMBOLIC ADDRESSES
	PUSHJ P,PADS3A	;ONLY ABSOLUTE ADDRESSING FOR LSH, ASH, AND ROT
PI7:	TRZ F,NAF	
	LDB R,[XWD 220400,LWT]	;INDEX REGISTER CHECK
	JUMPE R,PADS1		;EXIT
	MOVEI T,"("
	PUSHJ P,TOUT
	MOVE T,R
	PUSHJ P,PAD
	MOVEI T,")"
	JRST TOUT		;EXIT


PI8A:	CAIL W,600		; IS THIS A TEST INSTRUCTION?
	CAILE W,677
	JRST [	LDB W,[POINT 13,LWT,12]
		ANDI W,16007
		CAIL W,16003	; OP GREATER THAN DATAO?
		CAIN W,16005	; AND NOT CONI?
		JRST PI8	; NO
		PUSHJ P,PADFLG
		JRST PI7]	; YES CONO, CONSZ AND CONSO PRINT BITS
	TRNE W,10		; DIRECT OR SWAPPED?
	JRST PI8		; YES, PRINT SYMBOLIC ADDRESS
	PUSHJ P,PADFLG		; TLXX OR TRXX, PRINT ADDRESS AS FLAGS
	JRST PI7

PI8:	PUSHJ P,PAD
	JRST PI7


HLFW:	HLRZ T,LWT		;PRINT AS HALF WORDS
	JUMPE T,HLFW1		;TYPE ONLY RIGHT ADR IF LEFT ADR=0
	TRO F,NAF		;ALLOW NEGATIVE ADDRESSES
	PUSHJ P,PAD
	MOVSI W1,(ASCII /,,/)
	PUSHJ P,TEXT2		;TYPE ,,
HLFW1:	HRRZ T,LWT

;PRINT ADDRESSES (ARG USUALLY 18 BITS BUT CAN BE 36 BITS)

PAD:	ANDI T,-1
	JRST @AR		;PADSO OR PAD1

PADSO:	JUMPE T,FP7B		;PRINT A ZERO
	PUSHJ P,LOOK
PADS1:	POPJ P,0
	JUMPGE F,PADS3		;PRINT NUMBER OF NO SYMBOL FOUND
	MOVE W2,1(W1)
	CAIGE T,100
	CAIGE W2,60
	JRST PADS3
	MOVEM T,TEM
	PUSHJ P,SPT0
	MOVEI T,"+"
PADS1A:	PUSHJ P,TOUT
	HRRZ T,TEM
PAD1:	JRST TOC		;EXIT

PADS3:	MOVE T,TEM
PADS3A:	TRNE F,NAF
	CAIGE T,776000
	JRST TOC
PADS3B:	MOVNM T,TEM
	MOVEI T,"-"
	JRST PADS1A


; PRINT ADDRESS AS FLAGS

PADFLG:	PUSH P,T		; SAVE ADDRESS
	MOVEI W1,3		;COUNT BITS TO SEE IF MORE THAN 3
	MOVN W2,T		;BIT COUNTING SEQUENCE, STOLEN FROM
	TDZE T,W2		;SYSTEM REFERENCE MANUAL
	SOJGE W1,.-2		;STOP COUNTING IF MORE THAN 3
	JUMPL W1,PADFL6		;GO TYPE NUMBER IF MORE THAN 3 BITS
	MOVEI T,400000		; START WITH LEFT MOST BIT
PADFL1:	TDNN T,(P)		; IS THIS BIT IN THE THING
	JRST PADFL2		; NO, GO TO NEXT BIT
	PUSHJ P,LOOKE		; LOOK UP THIS BIT
	JRST PADFL3		; EXACT MATCH FOUND AND PRINTED
	JRST PADFL4

PADFL3:	MOVE T,TEM
	ANDCAM T,(P)		; REMOVE BIT FROM ADDRESS
	SKIPN (P)		; ANY MORE TO BE OUTPUT?
	JRST PADFL5		; NO
	MOVEI T,"+"
	PUSHJ P,TOUT		; YES, TYPE !
PADFL4:	MOVE T,TEM
PADFL2:	ASH T,-1		; SHIFT TO NEXT BIT
	CAILE T,10		;DONE BITS 18-31?
	JRST PADFL1		;NO, GO DO NEXT BIT
PADFL6:	POP P,T			; ELSE TYPE OUT THE REST AS A NUMBER
	JRST TOC

PADFL5:	POP P,T
	POPJ P,


INOUT:	TDC T,[XWD -1,400000]	;IO INSTRUCTION OR NEG NUM
	TDCN T,[XWD -1,400000]
	JRST PADS3B		;TYPE AS NEG NUM
	LDB R,[POINT 7,T,9]	;PICK OUT IO DEVICE BITS
	CAIL R,700_-2		;IF DEVICE .L. 700, THEN TYPE
	JRST HLFW		;TYPE AS HALF WORDS
	LDB R,[POINT 3,T,12]
	DPB R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	PUSHJ P,OPTYPE
	PUSHJ P,TSPC
	MOVSI T,077400
	AND T,LWT
	JUMPE T,PI4
	PUSHJ P,LOOK		;LOOK FOR DEVICE NUMBER
	JRST PI3A
	MOVE T,TEM
	LSH T,-30
	PUSHJ P,TOC
	JRST PI3A
MASK:	TLNE F,QF
	JRST MASK1
	MOVEI T,MSK
MASK2:	MOVEI W,1
	MOVEM W,FRASE1
	JRST QUANIN
MASK1:	MOVEM T,MSK
	JRST RET


EFFEC:	TLO F,LTF
	HRRZ T,T
WORD:	MOVEI R,322000-326000	;JUMPE-JUMPN
NWORD:	ADDI R,326000+40*T	;JUMPN T,
	HRLM R,SEAR2
	TLZN F,QF
	JRST ERR
	SETCAM T,WRD
	MOVSI T,FRASE-DEN-1		;PREVENT TYPE OUT OF DDT PARTS
	SETCMM FRASE(T)
	AOBJN T,.-1
	MOVE T,ULIMIT
	TLNE F,SAF
	TLO F,QF		;SIMULATE A $Q TYPED
	PUSHJ P,SETUP
	PUSHJ P,CRF
SEAR1:	PUSHJ P,FETCH
	JRST SEAR2B
	TLNE F,LTF	;CHECK FOR EFFECTIVE ADDRESS SEARCH
	JRST EFFEC0
	EQV T,WRD
	AND T,MSK
SEAR2:	JUMPE T,SEAR3		;OR JUMPN T
SEAR2A:	AOS R,DEFV	;GET NEXT LOCATION
	PUSHJ P,LISTEN	;ANYTHING TYPED?
	CAMLE R,ULIMIT	;OR END OF SEARCH?
	JRST SEARFN	;YES
	JRST SEAR1	;NO, LOOK SOME MORE

SEAR2B:	MOVEI R,777
	IORB R,DEFV		;SKIP TO NEXT PAGE
	JRST SEAR2A

SEARFN:	SETCMM LWT		;COMPLEMENT BITS BACK AND STOP SEARCH
	JRST DD1


SEAR3:	MOVE R,DEFV
	PUSHJ P,FETCH
	JRST ERR
	TLZ F,STF	;GET RID OF SUPPRESS TYPEOUT MODE
	MOVE T,DEFV
	PUSHJ P,LI1	;CALL REGISTER EXAMINATION LOGIC TO TYPE OUT
	PUSHJ P,CRF
	SETCMM LWT
	SETCMM TEM
SEAR4:	JRST  SEAR2A

EFFEC0:	MOVEI W,20
	MOVEM W,TEM
EFFEC1:	MOVE W,T
	LDB R,[POINT 4,T,17]	;GET IR FIELD
	JUMPE R,EFFEC2
	PUSHJ P,FETCH
	JRST ERR
	ADD T,W
EFFEC2:	HRR R,T
	TLNN W,20		;INDIRECT BIT CHECK
	JRST EFFEC3
	SOSE,TEM
	PUSHJ P,FETCH
	JRST SEAR4
	JRST EFFEC1
EFFEC3:	EQV T,WRD
	ANDI T,777777
	JRST SEAR2


SETUP:	TLNN F,QF		;QUANTITY TYPED?
	IFE EDDT&1,<MOVEI T,777777>
	IFN EDDT&1,<MOVEI T,DDT-1>
	HRRZM T,ULIMIT		;SAVE LAST ADDRESS OF SEARCH
	HRRZS R,DEFV		;GET 1ST ADDRESS
	TLNN F,FAF		;WAS A 1ST ADR SPECIFIED?
	SETZB R,DEFV		;NO, MAKE IT ZERO
	CAMLE R,ULIMIT		;LIMITS IN A REASONABLE ORDER?
	JRST ERR		;NO
	POPJ P,		;YES, RETURN

ZERO:	TLNN F,CCF
	JRST ERR
	PUSHJ P,SETUP
	HRRZ S,@SYMP	;GET 1ST ADR OF SYMBOL TABLE
	HLRE W1,@SYMP	;GET LENGTH OF SYM TABLE
	SUB W1,S	;GET NEG OF LAST ADR
	MOVNS W1	;GET POS LAST ADR
	MOVEI T,0	;0 TO STORE IN MEMORY
ZERO1:	TRNN R,777760
	JRST ZEROR	;OK TO ZERO AC'S
	SKIPGE MMODF		;USER MODE?
	JRST ZEROU		;YES, NO DDT OR SYMBOL TABLE CHECKS
	CAIL R,DDT
	CAILE R,DDTEND
	JRST .+2
	MOVEI R,DDTEND	;DON'T ZERO DDT
	CAML R,S
	CAMLE R,W1
	JRST .+2
	HRRZ R,W1	;DON'T ZERO SYMBOL TABLE
ZEROU:	CAILE R,ZLOW
	JRST .+3
	MOVEI R,ZLOW
	JRST ZERO3
	TRNN R,777		;START OF PAGE?
	JRST ZERO3		;YES, CHECK FOR EXISTANCE
ZEROR:	CAMLE R,ULIMIT	;ABOVE LIMITS?
	JRST DD1	;YES, STOP
	PUSHJ P,DEP	;DEPOSIT T
	JRST ZERO2		;WOULDN'T DEPOSIT
	AOJA R,ZERO1

ZERO3:	PUSHJ P,ZERO5		;SEE IF PAGE EXISTS
	JRST ZERO2		;NO, DON'T DO STORES IN IT
	JRST ZEROR		;YES, PUSH AHEAD

ZERO2:	IORI R,777		;GO TO NEXT PAGE
	AOJA R,ZERO1

ZERO5:	JSP TT1,CHKADR		;RETURNS +1 FOR OK, DOES POPJ FOR BAD
	JRST CPOPJ1		;DO SKIP RETURN


FTOC:		;NUMERIC OUTPUT SUBROUTINE
TOC:	HRRZ W1,ODF
	CAIN W1,10		;IS OUPUT RADIX NOT OCTAL, OR
	TLNN T,-1		;ARE THERE  NO LEFT HALF BITS?
	JRST TOCA		;YES, DO NOTHING SPECIAL
	HRRM T,TOCS		;NO, TYPE AS HALF WORD CONSTANT
	HLRZS T			;GET LEFT HALF
	PUSHJ P,TOC0		;TYPE LEFT HALF
	MOVSI W1,(ASCII /,,/)
	PUSHJ P,TEXT2		;TYPE ,,
TOCS:	MOVEI T,.-.		;GET RIGHT HALF BACK
TOCA:	HRRZ W1,ODF		;IS OUTPUT RADIX DECIMAL?
	CAIN W1,12
	JRST TOC4		;YES,TYPE SIGNED WITH PERIOD
TOC0:	LSHC T,-43
	LSH W1,-1		;W1=T+1
	DIVI T,@ODF
	HRLM W1,0(P)
	SKIPE T
	PUSHJ P,TOC0
	HLRZ T,0(P)
	ADDI T,"0"
	JRST TOUT

TOC4:	MOVM A,T		;TYPE AS SIGNED DECIMAL INTEGER
	JUMPGE T,TOC5
	MOVEI T,"-"
	PUSHJ P,TOUT
TOC5:	PUSHJ P,FP7		;DECIMAL PRINT ROUTINE
TOC6:	MOVEI T,"."
	JRST TOUT


;SYMBOL OUTPUT SUBROUTINE

SPT0:	HRRZM W1,SPSAV		;SAVE POINTER TO TYPED SYM
SPT:	;RADIX 50 SYMBOL PRINT
	MOVE T,SVFB
	JUMPE T,SPT1W
	CAMN T,BLOCK
	JRST SPT1W
	PUSH P,W1
	LDB T,[POINT 32,(T),35]
	PUSHJ P,SPT1
	MOVEI T,"&"
	PUSHJ P,TOUT
	POP P,W1
SPT1W:	LDB T,[POINT 32,(W1),35]	;GET SYMBOL
SPT1:	IDIVI T,50
	HRLM W1,0(P)
	JUMPE T,SPT2
	PUSHJ P,SPT1
SPT2:	HLRZ T,0(P)
	JUMPE T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI T,260-1
	CAILE T,271
	ADDI T,301-272
	CAILE T,332
	SUBI T,334-244
	CAIN T,243
SPT3:	MOVEI T,256
	JRST TOUT

SYMD:	MOVEI T,DELO/200000	;$D ;DELETE LAST SYM & PRINT NEW
	HRRZ R,SPSAV		;PICK UP POINTER TO LAST SYM
	JUMPE R,ERR
	DPB T,[POINT 2,(R),1]	;STORE SEMI-DELETE BITS IN SYMBOL
	MOVE T,LWT
	JRST CONSYM		;PRINT OUT NEXT BEST SYMBOL


;FLOATING POINT OUTPUT

TFLOT:	MOVE A,T
	JUMPG A, TFLOT1
	JUMPE A,FP1A
	MOVNS A
	MOVEI T,"-"
	PUSHJ P,TOUT
	TLZE A,400000
	JRST FP1A
TFLOT1:	TLNN A, 400
	JRST TOC5		;IF UNNORMALIZED, TYPE AS DECIMAL INTEGER

FP1:	MOVEI B,0
	CAMGE A,FT01
	JRST FP4
	CAML A,FT8
	AOJA B,FP4
FP1A:	MOVEI C,0

FP3:	MULI A,400
	ASHC B,-243(A)
	SETZM TEM1	;INIT 8 DIGIT COUNTER
	SKIPE A,B	;DON'T TYPE A LEADING 0
	PUSHJ P,FP7	;PRINT INTEGER PART OF 8 DIGITS
	PUSHJ P,TOC6		;PRINT DECIMAL POINT
	MOVNI A,10
	ADD A,TEM1
	MOVE W1,C
FP3A:	MOVE T,W1
	MULI T,12
	PUSHJ P,FP7B
	SKIPE,W1
	AOJL A,FP3A
	POPJ P,

FP4:	MOVNI C,6
	MOVEI W2,0
FP4A:	ASH W2,1
	XCT,FCP(B)
	JRST FP4B
	FMPR A,@FCP+1(B)
	IORI W2,1
FP4B:	AOJN C,FP4A
	PUSH P,W2	;SAVE EXPONENT
	PUSH P,FSGN(B)	;SAVE "E+" OR "E-"
	PUSHJ P,FP3	;PRINT OUT FFF.FFF PART OF NUMBER
	POP P,W1	;GET "E+" OR "E-" BACK
	PUSHJ P,TEXT
	POP P,A		;GET EXPONENT BACK


FP7:	IDIVI A,12		;DECIMAL OUTPUT SUBROUTINE
	AOS,TEM1
	HRLM B,(P)
	JUMPE A,FP7A1
	PUSHJ P,FP7

FP7A1:	HLRZ T,(P)
FP7B:	ADDI T,260
	JRST TOUT

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1

FCP:	CAMLE A, FT0(C)
	CAMGE A, FT(C)
	Z FT0(C)

FSGN:	ASCII .E-.
	ASCII .E+.

TEXTT:	MOVE W1,T
TEXT:	TLNN W1,774000		;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH W1,35
TEXT2:	MOVEI T,0		;7 BIT ASCII TEXT OUTPUT SUBROUTINE
	LSHC T,7
	PUSHJ P,TOUT
	JUMPN W1,TEXT2
	POPJ P,


TBLK:	0
TEM:	0
BLOCK:	0
SVF:	0
SW1:	0
SVFB:	0
SVTB:	0
BLVL:	0


WRD:	0
WRD2:	0
PRNC:	0

FRASE:	0	;DONT CHANGE ORDER, SEE  SEARC+3
SYL:	0
LWT:	0
TEM2:	0
FRASE1:
TEM3:	0
DEN:	0

PRGM:	0
ESTU:	0
ESTUT:	0
FSV:	0
FH:	0
SYM:	0
SPSAV:	0	;POINTER TO LAST SYMBOL TYPED
DEFV:	0
ULIMIT:	0
LLOC:	0
LLOCO:	0
SAVLOC:	0		;THE ADR OF OLD REGISTER EXAMINATION SEQUENCE
SYMP:	XWD PID,JOBSYM
SKPCT:	0
STRING:	0
LASTPG:	0		;LAST PAGE CHECKED AND ACCESS
MMODF:	0		;USER MODE MEMORY REFS IF  .L. 0

JOBSYM:	XWD -2,DDT-2
SAVPI:	0
SAVCHN:	0		;SAVED INTERRUPT CHANNEL MASK
SAVSTS:	0		;SAVED STATUSES
SAVTTY:	0
SAVTT2:	0		;TTY CONTROL CHARACTER MODES
SAVTT3:	0


MSK:	XWD -1,-1
B1ADR:	0
B1SKP:	0
B1CNT:	0
B1STR:	0

DEFINE DBPNT(Z.) <$'Z.'B=B1ADR+4*Z.-4
>

RADIX ^D10
QZ==1
REPEAT NBP,<
DBPNT \QZ
QZ==QZ+1
>
RADIX 8
REPEAT NBP*4-4, <	0>

BNADR==.-4
AUTOPI:	0

AC0:	BLOCK 17

AC17:	0

SCHM:	PIN		;DO NOT CHANGE ORDER
	PADSO
ODFM:	10

SARS:	0
TEM1:	0


SAVE:	0		;SAVE THE ACS AND PI SYSTEM
	SKIPN SARS
	JRST SAV1
	AOS SAVE
	JRST SAV5
SAV1:	MOVEM 17,AC17
	HRRZI 17,AC0
	BLT 17,AC0+16
	MOVE P,PS
	MOVE T, SAVE
	HLLM T, SAVPI
	MOVSI T,(1B0)
	MOVEI 1,400000
	SKPIR			;PSI SYSTEM ON?
	TLZ T,(1B0)		;NO
	MOVEM T,SAVSTS		;SAVE STATUSES
	RCM			;READ CHANNEL MASK
	MOVEM 1,SAVCHN
SAV5:	SETOM SARS			;FLAG PROTECTING SAVED REGISTERS
	MOVE P,PS
	PUSHJ P,TTYRET		;IN USER MODE, GET INTO DDT MODE
	MOVE T,[XWD SCHM,SCH]
	BLT T,ODF		;LOAD THE ACS WITH MODE SWITCHES
	SETOM LASTPG
	SETZ F,			;CLEAR FLAGS
	JRST @SAVE

RESTOR:	SETOM TEM3	;RESTORE ACS AND PI SYSTEM
RESTR1:	HRRM T,SAVE
	MOVE T,SAVSTS
	MOVEI 1,400000
	TLNE T,(1B0)		;PSI SYSTEM ON BEFORE?
	EIR			;YES, TURN BACK ON
	MOVE 2,SAVCHN		;REENABLE USERS CHANNELS
	AIC
	MOVE T,SAVPI		;GET FLAGS
	HLLM T, SAVE
	HRLZI 17,AC0
	BLT 17,17
	SETZM SARS
	SKIPL,TEM3
CPUSHP:	PUSH SAVPI	;PROGRAM MODIFIED AT IPUSHJ
	JRST 2,@SAVE


CRN:	MOVEI T,15		;CARRIAGE RETURN
	JRST TOUT

CRNRB:	PUSHJ P,CRN
	MOVEI T,177
	JRST TOUT

CRF:	PUSHJ P,CRN
	MOVEI T,12		;LINE FEED
	JRST TOUT

LCT:	PUSHJ P,TSPC
	PUSHJ P,TSPC

TSPC:	MOVEI T,40		;SPACE
	JRST TOUT


TEXIN:
TIN:	SKIPE T,STRING		; ARE WE INPUTTING FROM A STRING?
	JRST [	ILDB T,STRING	; YES, GET A BYTE
		JUMPN T,TIN3	; AND RETURN IF NOT NULL
		SETZM STRING
		JRST .+1]
	EXCH T,1
	TYI			;CHARACTER INTO 1
	CAIN 1,37		;EOL?
	MOVEI 1,15		;CHANGE TO CR
	CAIE 1,33		;ALTMODE?
	JRST .+4		;NO
	MOVEI 1,"$"		;ECHO DOLLARS
	TYO
	MOVEI 1,33
	EXCH T,1
TIN2:	CAIN T,177		;RUBOUT?
	JRST WRONG		;YES
	POPJ P,

TIN3:	CAIE T,33
	JRST TIN1
	MOVEI T,"$"
	PUSHJ P,TOUT
	MOVEI T,33
	JRST TIN2

TIN1:	PUSHJ P,TOUT
	JRST TIN2

TOUT:	EXCH 1,T
	TYO			;CHARACTER OUT FROM 1
	EXCH 1,T
	POPJ P,


LISTEN:	PUSH P,1
	MOVEI 1,100		;PRIMARY INPUT
	SIBE
	AOS -1(P)		;BUFFER NOT EMPTY MEANS SKIP
	POP P,1
	POPJ P,

TTYRET:	SKIPE SAVTTY		;ALREADY HAVE STATE?
	JRST TTYR1		;YES
	MOVEI 1,100
	RFMOD
	MOVEM 2,SAVTTY
	RFCOC
	MOVEM 2,SAVTT2
	MOVEM 3,SAVTT3
TTYR1:	MOVEI 1,100
	MOVE 2,TTYMOD		;SET DDT STATE
	SFMOD
	MOVE 2,TTYCC2
	MOVE 3,TTYCC3
	SFCOC
	MOVEI 1,400000
	DIR
	SETO 2,
	DIC
	POPJ P,

TTYMOD:	EXP ^D66B10+^D72B17+17B23+2B25+1B29+1B31
TTYCC2:	BYTE (2) 0,0,1,1,1,1,1,2,1,0,2,1,1,2,1,1,1,1
TTYCC3:	BYTE (2) 1,1,1,1,1,1,1,1,1,0,1,1,1,2

TTYLEV:	MOVEI 1,100
	MOVE 2,SAVTTY		;REESTABLISH USER MODES
	SFMOD
	MOVE 2,SAVTT2
	MOVE 3,SAVTT3
	SFCOC
	SETZM SAVTTY
	POPJ P,


BDISP:	POINT 12,DISP(R),11
	POINT 12,DISP(R),23
	POINT 12,DISP(R),35
DISP:	
DEFINE D (Z1,Z2,Z3)<		<Z1-DDT>_30+<Z2-DDT>_14+Z3-DDT>
	;THIS MACRO PACKS 3 ADDRESSES INTO ONE WORD; EACH ADR IS 12 BITS

	PUNCH==ERR
	BLKEND==ERR
	LOADER==ERR

D ERR,RDX50,ERR
D ERR,ERR,ERR
D ERR,ERR,VARRW
D TAB,LINEF,ERR
D ERR,CARR,ERR
D ERR,ERR,ERR
D PUNCH,ERR,ERR
D ERR,ERR,ERR
D ERR,ERR,ERR
D CONTROL,ERR,ERR
D ERR,ERR,SPACE
D SUPTYO,TEXI,ASSEM
D DOLLAR,PERC,SETBLK
D DIVD,LPRN,RPRN
D MULT,PLUS,ACCF
D MINUS,PERIOD,SLASH
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,NUM,NUM
D NUM,TAG,SEMIC
D FIRARG,EQUAL,ULIM
D QUESTN,INDIRECT,ABSA
D BPS,CON,SYMD
D EFFEC,SFLOT,GO
D HWRDS,PILOC,BLKEND
D KILL,MKLIST,MASK
D NWORD,BITO,PROCEDE
D QUAN,RELA,SYMBOL
D TEXO,UMOD,PROCDN
D WORD,XEC,PROCDC
D ZERO,OCON,ICON
D OSYM,VARRW,PSYM

;THIS TABLE DOES NOT HAVE ENTRIES FOR CHARS .GE. 140; THESE
; ARE DETECTED AS ERRORS NEAR L21:


BITO:	MOVEI	R,BITT	;BYTE OUTPUT SUBROUTINE
	HRRZI	AR,TOC
	TRZN	F,Q2F
	JRST	ERR
	MOVE	T,WRD2
	MOVEM	T,SVBTS
	MOVEI	T,^D36
	IDIV	T,WRD2
	SKIPE	T+1
	ADDI	T,1
	MOVEM	T,SVBTS2
	HRRZ	SCH,R
	JRST	BASE1

BITT:	MOVE	T,SVBTS2
	MOVEM	T,SVBT2
	MOVE	T+1,LWT
	MOVEM	T+1,SVBT3
	PUSH P,LWT
BITT2:	MOVEI	T,0
	MOVE	T+2,SVBTS
	LSHC	T,(T+2)
	MOVEM	T,LWT
	MOVEM	T+1,SVBT3
	CAIE	AR,PADSO
	PUSHJ	P,TOCA
	CAIE	AR,TOC
	PUSHJ	P,PIN
	SOSG	SVBT2
	JRST BITT4
	MOVEI	T,","
	PUSHJ	P,TOUT
	MOVE	T+1,SVBT3
	JRST	BITT2

BITT4:	POP P,LWT
	POPJ P,

SVBTS:	0
SVBTS2:	0
SVBT3:	0
SVBT2:	0

	SUBTTL	OP DECODER

;DESCRIPTION OF OP DECODER FOR DDT:
;
;         THE ENTIRE INSTRUCTION SET FOR THE PDP-6 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-6.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;     	THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;0-37(8):	THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INSTX N+1 GIVES THE NUMBER OF BITS IN INST; P GIVES THE
;	POSITION (FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;;	C(INST) = .010 101 100(2)
;
;	THE RESULT = D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT OR ARE THE EXTEND BYTE, 41-73(8))
;	ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.
;41(8)-72(8)	THE ALPHABET IS ENCODED INTO THIS RANGE.
;	41- A
;	42- B
;	72- Z
;	WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	LETTER IS TYPED.
;73(8)	THIS IS THE "EXTEND" BYTE. THE NEXT BYTE IN THE TABLE
;	IS A TRANSFER BYTE BUT MUST HAVE THE ADDRESS EXTENDED
;	BY <1000-74*2+FIR.> FIRST.
;
;74(8)-777(8)	THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	CONSIDERED TO BE A, TRANSFER INTERPRETATION TO THE 
;	<A-74(8)+FIR.>RD BYTE IN THE TABLE.
;
;MACROS ASSEMBLE THE TABLE TBL:
; 1.   A NUMBER FOLLOWED BY ^ ASSEMBLES A DISPATCH BYTE.  THE FIRST
;	DIGIT IS THE POSITION; THE SECOND DIGIT IS THE SIZE.
; 2.   A POINT (.) ASSEMBLES A STOP CODE.
; 3.   A NAME FOLLOWED BY A SLASH ASSEMBLES A TRANSFER TO THE
;	SYMBOLICALLY NAMED BYTE.
; 4.   A STRING OF LETTERS TERMINATED BY A SPACE, COMMA, OR POINT,
;	ASSEMBLE INTO A STRING OF BYTES, EACH BYTE BEING ONE LETTER.
;
;EXAMPLE OF BINARY TO SYMBOLIC DECODING:
;	THE MACHINE CODE FOR JRST IS 254
;		INST    0  1  0  1  0  1  1  0  0
;	THE INTERPRETER STARTS WITH THE FIRST BYTE IN THE TABLE (63^).
;	THE RESULT OF APPLYING THIS TO C(INST) GIVES 2.  SKIPPING OVER
;	2 BYTES IN THE TABLE AND INTERPRETING THE THIRD RESULTS IN
;	HAK/ BEING INTERPRETED.  AT HAK:, THERE IS A 33^.  APPLYING
;	THIS TO C(INST) RESULTS IN 5 NON PRINTING BYTES BEING SKIPPED
;	OVER:
;		1.  MV/
;			MOV	PRINTING TEXT
;		2.  MO/
;		3.  ML/
;		4.  DV/
;		5.  SH/
;
;H1/ IS THE NEXT BYTE INTERPRETER.  AT H1: 03^ IS FOUND SO
;4 BYTES ARE SKIPPED OVER:
;		EXC	PRINTING TEXT
;		1.  S3/
;		BL	PRINTING TEXT
;		T	PRINTING TEXT
;		2.  .
;		3.  AO/
;		4.  AOB/
;		THE NEXT LETTERS JRS ARE TYPED OUT.  THEN T/ IS FOUND.  AT
;T; A T IS TYPED OUT; THEN A "." IS FOUND AND EVERYTHING STOPS.
;
;		THE TABLE IS ALSO USED GOING FROM SYMBOLIC TO BINARY BUT A
;	TREE SEARCH METHOD IS USED.
REPEAT 0,<

DEFINE REDEF (XX)<
DEFINE INFO (AA,BB)<
AA XX'BB>>


DEFINE BYT9 (L)<
XLIST
REDEF %
	ZZ==0
	ZZZ==0
	ZZM==1

	IRPC	L,<
	Z=="L"
	IFE	Z-":",<INFO <>,<==CLOC>
		IFNDEF FIR.,<FIR.==CLOC>
		IFGE CLOC+73-1000-FIR.,<PRINTX OPTABLE TOO LONG>
		Z==0>
	IFE	Z-"/",<IF1 <OUTP 1>
		IF2,<INFO OUTP,+73-FIR.>
		Z==0>
	IFE	Z-"^",<OUTP <ZZ&70/2+ZZ&7-1>
	Z==0>
	IFE	<Z-",">*<Z-".">*<Z-40>,<IFN ZZZ,<
				REPEAT 5,<ZZ==ZZZ&77
					IFN ZZ,<OUTP ZZ>
					ZZZ==ZZZ/100>>
				IFE Z-".",<OUTP 40>
				Z==0>
	IFN	Z,<INFO REDEF,L
	ZZ==ZZ*10+Z&7
	ZZZ==ZZZ+<Z-40>*ZZM
	ZZM==ZZM*100>
	IFE	Z,<REDEF %
	ZZ==0
	ZZZ==0
	ZZM==1>>
LIST>

DEFINE OUTP (A)<
	BINRY==BINRY*400+BINRY*400+A
	BINC==BINC-1
	IFE	BINC,<EXP BINRY
		BINRY==0
		BINC==4>
	CLOC==CLOC+1>
TBL:		;OPDECODER BYTE TABLE

BINRY==0
CLOC==0		;SET BYTE LOCATION COUNTER TO 0
BINC==4		;INIT BYTES/WORD COUNTER

BYT9 <63^UUO/FLO/HAK/ACCP/BOOLE/H HWT/T ACBM/>

;IO INSTRUCTIONS
BYT9 <21^BD/CON,11^OI/S,01^Z/O/>
BYT9 <BD:01^BLK,IO/DATA,IO:11^I/O/OI:01^O/I/>

;UUOS
BYT9 <UUO:51^.,32^U40/U50/U60/21^U703/11^USET/01^>
BYT9 <LOOKU,P/ENTE,R/USET:USET,01^I/O/>
BYT9 <U40:03^CAL/INI T/.....,CALL I/>
BYT9 <U60:21^U603/01^IN,BPUT/OUT,BPUT:11^BU,F:F.,PU,T/>
BYT9 <U603:01^U6062/STAT,11^O:O.,Z:Z.,U6062:11^S,U62/G,U62:ETST,S/>
;BYTE AND FLOATING INSTRUCTIONS

BYT9 <FLO:51^BYTE/F 32^ AD A/SB A/MP A/DV A:>
BYT9 <21^LMB/R,IMB/LMB:02^.,L:L.,M:M.,B:B.,BYTE:32^.,I110//,I120/,03^UF,PA/DF,N/>
BYT9 <FS C/IB P:P.,I LD/LD:LD B/I DP/DP:DP B/>

;FWT,FIXED POINT ARITH,MISC.

BYT9 <HAK:33^MV/MV:MOV MO/ML/DV/SH/H1/JP/>
BYT9 <21^ADD IMB/SU BIMB:B IMB:02^.,I:I.,M/B/MO:22^>
BYT9 <EIMS:E IMS/S IMS/N IMS/M IMS:02^.,I/M/S:S.,>
BYT9 <ML:21^I ML1/ML1:MUL IMB/DV:21^I DV1/DV1:>
BYT9 <DI DV2:V IMB/H1:03^EXC S3/BL T:T.,AO/AO:AOBJ,>
BYT9 <AOB/JRS T/JFC L/XC T/.AOB:01^P/N/>
BYT9 <JP:03^PU/PU:PUSH PUS/PO/PO:POP POP/JS,R:R.,>
BYT9 <JS P/JS PA:A.,JR PA/PUS:01^J:J..,POP:>
BYT9 <01^.,J/SH:02^A S2/ROT S1/L S2:S S3:H S1/21^JFF O/.,S1:21^.,C:C.,>

;ARITH COMP,SKIP,JUMP

BYT9 <ACCP:42^CA CA1/SJ/A JS/S JS:O 31^>
BYT9 <J COMP/S COMP/CA1:31^I COMP/M COMP/>
BYT9 <SJ:31^JUM PSJ/SKI PSJ:P COMP:>
BYT9 <03^.,L/E:E.,L E/PA/G E/N:N.,G.,>
;HALF WORDS

BYT9 <HWT:51^HW1/21^R HW2/L HW2:R HW3/HW1:>
BYT9 <21^L HW4/R HW4:L HW3:32^IMS/Z IMS/O IMS/EIMS/>

;TEST INSTRUCTIONS

BYT9 <ACBM:31^AC1/01^D AC2/S AC2/AC1:01^R AC2/L,>
BYT9 <AC2:42^N EAN/Z EAN/C EAN/O EAN:12^.,E/PA/N/>


;BOOLEAN

BYT9 <BOOLE:24^ST/AN:AND B2/AN/ST/AN/ST/>
BYT9 <X OR:OR B2/I OR/AN/EQ DV2/ST/OR/ST/OR/OR/>
BYT9 <ST:SET B2:24^Z IMB/IMB/CA:C TA/TM:M IMB/>
BYT9 <CM:C TM/TA:A IMB/IMB/IMB/CB:C BIMB/IMB/CA/>
BYT9 <CA/CM/CM/CB/O IMB/>

;INSTRUCTION GROUP 120
BYT9 <I120:11^ DMOV/ 01^ FIX,FIX2/ 21^.,FLT,FIX2: 21^. R/>
BYT9 <DMOV:DMOV,01^ E,EM// N,EM:21^. M/>

;MORE UUO'S
BYT9 <U50:03^OPE,N/TT,CAL:CAL L/...,RENAM,E/I,N/OU,T/>
BYT9 <U703:02^CLOS,E/RELEA,S/MTAP,E/UGET,F/>

;INSTRUCTION GROUP 110 - DF ARITHMETIC
BYT9 <I110:21^DF DF// ., DF:02^AD.,SB.,M P/ DV.>

REPEAT BINC,<BINRY==BINRY*400+BINRY*400>
IFN BINRY,<EXP BINRY>
>	;END OF REPEAT 0
DEFINE BYT9 (A) <IRP A,<
A>>

IF1,<

DEFINE	.ADR	(A) <
%'A==	CLOC
FIR.==	CLOC
DEFINE	.ADR	(B) <
%'B==	CLOC
LASTB==CLOC+74-FIR.>>

DEFINE	.TRA (A)<CLOC==CLOC+1>
DEFINE .TRAX (A)<CLOC==CLOC+2>

SYN	.TRA,	.DIS

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>
CLOC==	CLOC+1>

>	;END OF IF1
IF2,<

DEFINE .ADR (A)<IFN %'A-CLOC,<PRINTX PHASE ERR AT: %'A>>

DEFINE .TRA (A) <OUTP %'A+74-FIR.>

DEFINE .TRAX (A),<OUTP 73
	OUTP	74+<Z1==%'A-FIR.-1000+74>
	IFL	Z1,<PRINTX "A" TOO SMALL FOR .TRAX>>

DEFINE .DIS (A) <OUTP A&70/2+A&7-1>

DEFINE .TXT (A) <IFNB <A>,<IRPC A,<OUTP "A"-40>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>
OUTP	40>

DEFINE OUTP (A)<
IFGE <A>-1000,<PRINTX OPTABLE BYTE "A" TOO BIG>
IFE <BINC==BINC-9>-^D27,<BINR1==A>
IFE BINC-^D18,<BINR2==A>
IFE BINC-9,<BINR3==A>
	IFE	BINC,<	BYTE (9) BINR1,BINR2,BINR3,<A>
	BINC==^D36>
CLOC==CLOC+1 >
>
TBL:  ;OPDECODER BYTE TABLE

CLOC== 0 ;SET BYTE LOCATION COUNTER TO 0
BINC== ^D36 ;INIT BYTES/WORD COUNTER

;**********THE ARGUMENT FOR THE FOLLOWING "BYT9" MACRO
;**************TERMINATES AT THE NEXT COMMENT WITH: **************

BYT9 <

.DIS 63,.TRA UUO,.TRA FLO,.TRA HAK,.TRA ACCP,.TRA BOOLE
	.TXT H,.TRA HWT,.TXT T,.TRA ACBM


;IO INSTRUCTIONS

.DIS 21,.TRA BD,.TXT CON,.DIS 11,.TRA OI,.TXT S,.DIS 01,.TRA Z,.TRA O
.ADR BD,.DIS 01,.TXT BLK,.TRA IO,.TXT DATA,.ADR IO,.DIS 11,.TRA I,.TRA O
	.ADR OI,.DIS 01,.TRA O,.TRA I
;UUOS

.ADR UUO,.DIS 51,.END,.TXT,.DIS 32,.TRA U40,.TRAX U50,.TRA U60
	.DIS 21,.TRAX U703,.DIS 11,.TRA USET,.DIS 01
.TXT LOOKU,.TRA P,.TXT ENTE,.TRA R,.ADR USET,.TXT USET,.DIS 01,.TRA I,.TRA O
.ADR U40,.DIS 03,.TRAX CAL,.TXT INI,.TRA T,.END,.END,.END,.END,.END,.TXT CALL,.TRA I
.ADR U60,.DIS 21,.TRA U603,.DIS 01,.TXT IN,.TRA BPUT,.TXT OUT
	.ADR BPUT,.DIS 11,.TXT BU,.ADR F,.END F,.TXT,.TXT PU,.TRA T
.ADR U603,.DIS 01,.TRA U6062,.TXT STAT,.DIS 11,.ADR O,.END O,.TXT,.ADR Z,.END Z,.TXT
	.ADR U6062,.DIS 11,.TXT S,.TRA U62,.TXT G,.ADR U62,.TXT ETST,.TRA S

;BYTE AND FLOATING INSTRUCTIONS

.ADR FLO,.DIS 51,.TRA BYTE,.TXT F,.DIS 32,.TXT,.TXT AD,.TRA A,.TXT SB
	.TRA A,.TXT MP,.TRA A,.TXT DV,.ADR A
.DIS 21,.TRA LMB,.TXT R,.TRA IMB,.ADR LMB,.DIS 02,.END,.TXT
	.ADR L,.END L,.TXT,.ADR M,.END M,.TXT
.ADR B,.END B,.TXT,.ADR BYTE,.DIS 32,.END,.TRAX I110,.TRA I120,.TXT
	.DIS 03,.TXT UF,.TRA PA,.TXT DF,.TRA N
.TXT FS,.TRA C,.TXT IB,.ADR P,.END P,.TXT,.TXT I,.TRA LD
	.ADR LD,.TXT LD,.TRA B,.TXT I,.TRA DP,.ADR DP,.TXT DP,.TRA B
;FWT-FIXED POINT ARITH-MISC

.ADR HAK,.DIS 33,.TRA MV,.ADR MV,.TXT MOV,.TRA MO,.TRA ML,.TRA DV
	.TRA SH,.TRA H1,.TRA JP
.DIS 21,.TXT ADD,.TRA IMB,.TXT SU,.ADR BIMB,.TXT B,.ADR IMB,.DIS 02,.END,.TXT
	.ADR I,.END I,.TXT,.TRA M,.TRA B,.ADR MO,.DIS 22
.ADR EIMS,.TXT E,.TRA IMS,.TXT S,.TRA IMS,.TXT N,.TRA IMS,.TXT M
	.ADR IMS,.DIS 02,.END,.TXT,.TRA I,.TRA M,.ADR S,.END S,.TXT
.ADR ML,.DIS 21,.TXT I,.TRA ML1,.ADR ML1,.TXT MUL,.TRA IMB
	.ADR DV,.DIS 21,.TXT I,.TRA DV1
.ADR DV1,.TXT DI,.ADR DV2,.TXT V,.TRA IMB,.ADR H1,.DIS 03,.TXT EXC,.TRA S3,.TXT BL
	.ADR T,.END T,.TXT,.TRA AO,.ADR AO,.TXT AOBJ
.TRA AOB,.TXT JRS,.TRA T,.TXT JFC,.TRA L,.TXT XC,.TRA T,.TXT MA,.TRA P
	.ADR AOB,.DIS 01,.TRA P,.TRA N
.ADR JP,.DIS 03,.TRA PU,.ADR PU,.TXT PUSH,.TRA PUS,.TRA PO
	.ADR PO,.TXT POP,.TRA POP,.TXT JS,.ADR R,.END R,.TXT
.TXT JS,.TRA P,.TXT JS,.ADR PA,.END A,.TXT,.TXT JR,.TRA PA
	.ADR PUS,.DIS 01,.ADR J,.END J,.END,.TXT,.ADR POP
.DIS 01,.END,.TXT,.TRA J,.ADR SH,.DIS 02,.TXT A,.TRA S2,.TXT ROT,.TRA S1,.TXT L
	.ADR S2,.TXT S,.ADR S3,.TXT H,.TRA S1,.DIS 21,.TXT JFF,.TRA O,.END
	.ADR S1,.DIS 21,.END,.TXT,.ADR C,.END C,.TXT

;ARITH COMP-SKIP-JUMP

.ADR ACCP,.DIS 42,.TXT CA,.TRA CA1,.TRA SJ,.TXT A,.TRA JS,.TXT S
	.ADR JS,.TXT O,.DIS 31
.TXT J,.TRA COMP,.TXT S,.TRA COMP,.ADR CA1,.DIS 31,.TXT I,.TRA COMP,.TXT M,.TRA COMP
.ADR SJ,.DIS 31,.TXT JUM,.TRA PSJ,.TXT SKI,.ADR PSJ,.TXT P,.ADR COMP
.DIS 03,.END,.TXT,.TRA L,.ADR E,.END E,.TXT,.TXT L,.TRA E,.TRA PA,.TXT G,.TRA E
	.ADR N,.END N,.TXT,.END G,.TXT
;HALF WORDS

.ADR HWT,.DIS 51,.TRA HW1,.DIS 21,.TXT R,.TRA HW2,.TXT L,.ADR HW2,.TXT R,.TRA HW3
.ADR HW1,.DIS 21,.TXT L,.TRA HW4,.TXT R,.ADR HW4,.TXT L
	.ADR HW3,.DIS 32,.TRA IMS,.TXT Z,.TRA IMS,.TXT O,.TRA IMS,.TRA EIMS

;TEST INSTRUCTIONS

.ADR ACBM,.DIS 31,.TRA AC1,.DIS 01,.TXT D,.TRA AC2,.TXT S,.TRA AC2
	.ADR AC1,.DIS 01,.TXT R,.TRA AC2,.TXT L
.ADR AC2,.DIS 42,.TXT N,.TRA EAN,.TXT Z,.TRA EAN,.TXT C,.TRA EAN,.TXT O
	.ADR EAN,.DIS 12,.END,.TXT,.TRA E,.TRA PA,.TRA N

;BOOLEAN

.ADR BOOLE,.DIS 24,.TRA ST,.ADR AN,.TXT AND,.TRA B2,.TRA AN,.TRA ST,.TRA AN,.TRA ST
.TXT X,.ADR OR,.TXT OR,.TRA B2,.TXT I,.TRA OR,.TRA AN,.TXT EQ
	.TRA DV2,.TRA ST,.TRA OR,.TRA ST,.TRA OR,.TRA OR
.ADR ST,.TXT SET,.ADR B2,.DIS 24,.TXT Z,.TRA IMB,.TRA IMB
	.ADR CA,.TXT C,.TRA TA,.ADR TM,.TXT M,.TRA IMB
.ADR CM,.TXT C,.TRA TM,.ADR TA,.TXT A,.TRA IMB,.TRA IMB,.TRA IMB
	.ADR CB,.TXT C,.TRA BIMB,.TRA IMB,.TRA CA
.TRA CA,.TRA CM,.TRA CM,.TRA CB,.TXT O,.TRA IMB
;INSTRUCTION GROUP 120
.ADR I120,.DIS 11,.TRA DMOV,.DIS 01,.TXT FIX,.TRA FIX2,.DIS 21,.END
	.TXT FLT,.ADR FIX2,.DIS 21,.END,.TRA R
.ADR DMOV,.TXT DMOV,.DIS 01,.TXT E,.TRAX EM,.TXT N
	.ADR EM,.DIS 21,.END,.TRA M

;MORE UUO'S

.ADR U50,.DIS 03,.TXT OPE,.TRA N,.TXT TT,.ADR CAL,.TXT CAL,.TRA L,.END,.END,.END
	.TXT,.TXT RENAM,.TRA E,.TXT I,.TRA N,.TXT OU,.TRA T
.ADR U703,.DIS 02,.TXT CLOS,.TRA E,.TXT RELEA,.TRA S
	.TXT MTAP,.TRA E,.TXT UGET,.TRA F

;INSTRUCTION GROUP 110 - DF ARITHMETIC
.ADR I110,.DIS 21,.TXT DF,.TRAX DF,.END,.ADR DF,.DIS 02
	.END AD,.END SB,.TXT M,.TRA P,.END DV

;**********THIS TERMINATES THE "BYT9" MACRO ARGUMENT******
>

IF1,<	BLOCK	<CLOC+3>/4>
	IF2,<	IFN BINC-^D36,<BYTE (9) BINR1,BINR2,BINR3,0> >

IFNDEF CLOC.,<CLOC.==CLOC>
IFN CLOC.-CLOC,<PRINTX PHASE ERROR IN OPTABLE>
PNTR:	EXP	INST		;POINTER TO BITS IN INST
INST:	0		;BINARY FOR INSTRUCTION
CHP:	0		;CHAR POINTER INTO TXT, TXT+1
TXT:	BLOCK	2		;STORE INPUT TEXT FOR OPEVAL
SAVPDL:	0		;SAVE PUSH DOWN LIST POINTER

BTAB:	POINT	9,TBL		;TABLE USED TO GET NEXT BYTE POINTER
	POINT	9,TBL,8		;FOR TRANSFER BYTE
	POINT	9,TBL,17
	POINT	9,TBL,26

OPEVAL:	MOVEI	T,0		;EVALUATE FOR AN OP CODE
	IDPB	T,CHP		;INSERT NULL IN TEXT FOR SYMBOL
	MOVEM	P,SAVPDL
	TRZA	F,OUTF
OPTYPE:	TRO	F,OUTF		;TYPE AN OPCODE SYMBOLICALLY
	LSH	T,-33
	MOVEM	T,INST		;GET OPCODE INTO RIGHT 9 BITS
	MOVE	T,[XWD 440700,TXT]
	MOVEM	T,CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	TRZ	F,ITF		;CLEAR INSTRUCTION TYPED FLAG
	CLEARB	R,W1
	MOVE	W2,BTAB
DC1:	ILDB	T,W2		;GET NEXT BYTE IN TBL
	CAILE	T,40
	CAIL	T,74
	SOJGE	R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG	R,DC1		;SKIP OVER ALPHA TEXT (AND EXTEND BYTES) WITHOUT COUNTING
	SUBI	T,40
	JUMPE	T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG	T,DC2
	DPB	T,[XWD 340500,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ	T,-4
	AOS	T
	DPB	T,[XWD 300600,PNTR]
	TRNN	F,OUTF
	JRST	DC6		;FOR OPEVAL ONLY
	LDB	R,PNTR		;GET # BYTES TO SKIP OVER
	JRST	DC1

DC2:	HRREI	T,-33(T)	;TOTAL SUBTRACTED NOW IS 73
	JUMPL	T,DECT		;TYPE OUT A LETTER
	JUMPG	T,DC3		;XFER IF BYTE .GE. 74
	ILDB	T,W2		;BYTE IS EXTEND BYTE (73), GET NEXT
	MOVEI	T,1000-74*2+1(T)	; BYTE AND ADD IN EXTENSION (-OFFSET)
DC3:	MOVEI	W1,FIR.-1(T)	;BYTE IS AN XFER (1ST XFER IS 74)
	IDIVI	W1,4
	MOVE	W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI	W2,(W1)
	JRST	DC1
DECT:	TRNE	F,OUTF
	JRST	DC8		;TYPE OUT A LETTER
	ILDB	W1,CHP		;GET NEXT INPUT LETTER
	CAIE	W1,133(T)	;COMPARE WITH ASSUMED NEXT LETTER
	JRST	NOMAT		;DOESNT MATCH
	JRST	DC1		;MATCHES, TRY NEXT

DECX:	TRNE	F,OUTF		;STOP (CODE 40) HAS BEEN SEEN
	POPJ	P,		;IF FOR OUTPUT, RETURN
	ILDB	W1,CHP		;GET NEXT INPUT CHAR IF ANY
	JUMPE	W1,DC7		;DOES # OF CHARS MATCH
NOMAT:	POP	P,R		;NO, BACK UP AND TRY SOME MORE
	POP	P,W2
	POP	P,PNTR
	POP	P,CHP
NOMAT1:	AOS	R		;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB	R,PNTR		;STUFF INTO ANSWER
	LDB	R,PNTR
	JUMPN	R,DC6AA		;IF =0, BYTE WAS TOO BIG
	CAME	P,SAVPDL
	JRST	NOMAT		;NOT AT TOP LEVEL
	POPJ	P,		;UNDEFINED, FINALLY

DC6:	MOVEI	R,0		;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB	R,PNTR
DC6AA:	CAMN	P,SAVPDL
	JRST	DC6BB
	LDB	T,-2(P)		;OLD VALUE OF PNTR
	CAME	T,(P)
	JRST	NOMAT1
DC6BB:	PUSH	P,CHP
	PUSH	P,PNTR
	PUSH	P,W2
	PUSH	P,R
	JRST	DC1

DC7:	MOVE	P,SAVPDL	;RESTORE PUSH DOWN POINTER
	MOVE	T,INST
	LSH	T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	LDB	R,[POINT 3,T,8]
	TLC	T,700000
	TLCN	T,700000
	DPB	R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST	CPOPJ1		;SYMBOL FOUND, SKIP RETURN

DC8:	TRO	F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI	T,133(T)
	PUSHJ	P,TOUT		;OUTPUT A LETTER
	CLEARM	SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST	DC1
	LIT


PS:	IOWD LPDL,.+1
	BLOCK LPDL


IFE IMSSS,<
DDTEND:		IFN EDDT&1,<
EMDDT==.
	DEPHASE
>

	END
>;IFE IMSSS

