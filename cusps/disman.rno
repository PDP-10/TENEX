^^
.ptab 8
.justify
.fill
.left margin 0
.paper size 58,72
.page
.right margin 68
.title DECsystem-10 Display Systems          March 1974
.tab STOPS 8 16 24 32 40 48 56 64
.spacing 1
#####
.blank 14
.center
DECsystem-10 Display Systems
.BLANK 1
.CENTER
March 1974
.NUMBER 0
#####
.page
.skip 4
	This document describes the 
software available for graphics on the DECsystem-10
at the Division of Computer Research and Technology.
The graphics software is called Omnigraph, a collection
of routines for interactive graphics which can be accessed by
the user from FORTRAN, SAIL, or LISP.
.skip 4
.center
TABLE OF CONTENTS
.skip 3
.nojustify
.nofill
I.###Omnigraph tutorial

	Intended to "bootstrap" a novice graphics programmer 
	so that he might graduate to more advanced graphics.
	Contains many examples and some advanced topics, such
	as matrix transformations and three-dimensional displays.

II.##Omnigraph reference manual

	A deeper discussion of Omnigraph.

III.#Making off-line plots

	How to use PLOTX for generating off-line plots which
	resemble the display shown on the screen. Also, how
	to use OMPLOT to review and check the off-line plots
	before the actual plotting.


.fill
.justify
.SKIP 2
.CENTER
APPENDICES
.nojustify
.nofill

A.###References
.justify
.fill
.PAGE
####
.blank 15
.center
Blank page
.tab stops 10,15,20
.spacing 1
.subtitle Omnigraph Tutorial
.page
.center
Omnigraph Tutorial
.skip 1
.center
Table of Contents
.skip 2
.nojustify
.nofill
1.  Introduction
2.  Describing  pictures
3.  Concerning  units  of  measure
4.  Windowing
5.  Displaying  pictures
6.  Graphical  display  devices
7.  Preparations  for  displaying  pictures
8.  Removing  pictures  from  the  display  screen
9.  Concerning  the  deletion  of  pictures
10. A complete example
11. Appending to a picture
12. Viewports and screen utilization
13. Some additional routines
14. Interactive programming
15. Methods for providing input for interaction
16. Events
17. Function box
18. Grafacon tablet
19. Syncronizing events to program execution
20. DEVENT
21. DOUT
22. A technique for describing irregular pictures
23. Dynamic graphics (animation)
24. Loading and executing Omnigraph pictures
25. Advanced topics

	25.1. More examples
	25.2. Discussion of matrix transformations
	25.3. Discussion of three-dimensional displays
.justify
.fill
.page
.skip 3
1. ^&Introduction\&
.skip 3
Omnigraph is the primary graphics software for the DECsystem10
computer at NIH, providing extensive graphics capabilities
on a wide variety of devices.  This tutorial provides
a survey of Omnigraph with emphasis placed on programming
techniques.
.skip 1
It appears that computer graphics programming is most
successful when approached "philosophically" rather than
in a "follow the recipe" manner.  That is, the programmer
should
understand the overall concepts upon which Omnigraph
is structured.
These aspects of "Omnigraphics" may
not be apparent from random accesses into the reference
manual.
.skip 1
This tutorial is intended to bootstrap an otherwise
competent programmer to a certain level of self-sufficiency
toward graphics programming, and Omnigraph in particular.
The philosophy of
Omnigraphics will be presented in a graduated manner.
Throughout the tutorial, you must be patient with regard
to details, and trust that the reference
manual will satisfy your whetted curiosity.
.skip 1
If you are pursuing computer graphics, you probably
have some data that you would like to have DISPLAYED rather
than merely printed or whatever.  If that is true, then it
is important that you know how to describe it to the
computer.
.skip 1
Let's discuss then, the Omnigraph way of describing graphic
data so that the computer in turn can present it to you.
Then we will see how the data can be manipulated in order
to gain useful information from the display.
First realize that in Omnigraph, you
.nojustify
.nofill

		1. describe individual pictures,
		2. decide which display device to use,
		3. then show them on the display screen.

.justify
.fill
Remember that merely describing pictures to Omnigraph does
not result in images on the display screen.  The above three
steps are quite distinct, and will be discussed separately.
.skip 3
2. ^&Describing Pictures\&
.index DMOVE
.index DDRAW
.index Picture
.skip 3
Omnigraph allows just-plain folk to generate pictures
through an unpretentious set of routines that can be used
in FORTRAN, SAIL, or LISP.  This allows the user some
degree of freedom in choosing a language with which he feels
comfortable.
.skip 1
.index DMOVE
.index DDRAW
Not setting our sights too high, let's first describe
a picture of a triangle.
.nojustify
.nofill
                        / (3,5)
                       /_^
                      / _^
                     /  _^
                    /   _^
                   /    _^
                  /     _^
                 /      _^
                /       _^
               /        _^
              /         _^
             /          _^
      (0,0) /_______________________^ (3,0)


.justify
.fill
Let's go through the step-by-step procedure:
.nojustify
.nofill

Step 1.  Move to (0,0) to start, then draw a line to (3,0).


      (0,0) __________________________ (3,0)


.justify
.fill
.nojustify
.nofill
Step 2.  Draw a line from (3,0) up to (3,5).


                        _^ (3,5)
                        _^
                        _^
                        _^
                        _^
                        _^
                        _^
                        _^
                        _^
                        _^
                        _^
                        _^
      (0,0) _________________________^ (3,0)


.justify
.fill
.nojustify
.nofill
Step 3.  Draw a line from (3,5) back to the beginning (0,0).


                        / (3,5)
                       /_^
                      / _^
                     /  _^
                    /   _^
                   /    _^
                  /     _^
                 /      _^
                /       _^
               /        _^
              /         _^
             /          _^
      (0,0) /_______________________^ (3,0)


.justify
.fill
That's essentially how you would describe
a triangle to a computer.  Note that it's important to
.index Current position
keep track of where you are at all times (referred to as
the "current position").  The series of (FORTRAN) calls to
Omnigraph routines to describe such a triangle would be:
.nojustify
.nofill

		CALL DMOVE (0,0)
		CALL DDRAW (3,0)
		CALL DDRAW (3,5)
		CALL DDRAW (0,0)

.justify
.fill
The DMOVE routine allowed us to define (0,0) as the initial
"current position", effectively locating the start point of
our triangle.
The DDRAW routine is then used to describe a line segment that
starts at the current position and extends to a specified
point (e.g., the first line
goes from 0,0 to 3,0).  The DDRAW also redefines the current
position to be the endpoint of that line.  Hence, the startpoint
for the next DDRAW will be the endpoint of the last line,
unless one uses another DMOVE.
.skip 1
.index DDOT
.index DVECT
Omnigraph also provides the DDOT routine
which puts a dot at a specified position, and redefines the
current position as a side effect.
To describe a dot at the point (5,6), program the following:
.nojustify
.nofill

		CALL DDOT (5,6)

.justify
.fill
.skip 1
Similarly, you can save a little coding time when
describing a line that doesn't necessarily start at
the current position by using the DVECT routine.
For example, one can describe a line from (2,5) to
(-3,-6) by either:
.nojustify
.nofill

		CALL DMOVE (2,5)
		CALL DDRAW (-3,-6)

or

		CALL DVECT (2,5,-3,-6)

.fill
.justify
.skip 1
.index DTEXT
.index Text string
.index Character strings
So much for describing points and lines. Now you would
probably want to position some textual matter in the
picture as labels.  The DTEXT routine
performs this task.  You pass the character string
as an argument to DTEXT, and it places it at the
current position.  Note that you may need a DMOVE if
the current position is not
where you want the text.
DTEXT positions the first character that you pass
in the text string so that the lower left corner
of the character
is at the current position, and positions each additional
character in the string (if any) to the right.
DTEXT also redefines the current position as the
lower left corner of the "next character" as if there were
another character.  In this way, one can append to the
first text string by another DTEXT call without requiring
another DMOVE.  Remember that if you do a DDRAW just after
a DTEXT, the line starts just after the last character
of the text string.
.skip 1
The DTEXT routine has slightly different formats for FORTRAN
and SAIL.  In both languages, the character string is passed
as either a variable or constant, however in FORTRAN, the length
of the string must also be passed as a second argument.
In SAIL, the DTEXT routine can deduce this length, hence you
need only pass the string itself.
.skip 1
Let's use the DTEXT call to place a label above the
previously described triangle, starting at (0,5.5), and
place another label just to the right of the vertex at
(3,5).
.nojustify
.nofill

		CALL DMOVE (0,0)
		CALL DDRAW (3,0)
		CALL DDRAW (3,5)
		CALL DDRAW (0,0)

		CALL DMOVE (0,5.5)
		CALL DTEXT (18HTHIS IS A TRIANGLE,18)

		CALL DMOVE (3,5)
		CALL DTEXT (7HX=1,Y=1,7)

.justify
.fill
The above code describes the following picture:
.nojustify
.nofill

          THIS IS A TRIANGLE


                        / X=1,Y=1
                       /_^
                      / _^
                     /  _^
                    /   _^
                   /    _^
                  /     _^
                 /      _^
                /       _^
               /        _^
              /         _^
             /          _^
            /_______________________^ 


.justify
.fill
.index DOPEN
.index Picture number
.index DCLOSE
Now we have discussed the way you would describe a
picture to Omnigraph in a methodical, point-by-point
manner.  Since you may want to describe many such pictures,
you must give each such picture a unique integer
number with the DOPEN routine, which tells Omnigraph that you
are about to describe a picture.  This will allow you to later
show these pictures on the display screen by referring to their
numbers.
When you have finished the description of your picture,
you tell Omnigraph by using the DCLOSE routine.  Let's now
describe the triangle picture to Omnigraph as picture
number 1:
.nojustify
.nofill

		CALL DOPEN (1)

		CALL DMOVE (0,0)
		CALL DDRAW (3,0)
		CALL DDRAW (3,5)
		CALL DDRAW (0,0)
		CALL DMOVE (0,5.5)
		CALL DTEXT (18HTHIS IS A TRIANGLE,18)
		CALL DMOVE (3,5)
		CALL DTEXT (7HX=1,Y=1,7)

		CALL DCLOSE

.justify
.fill
Note that the DCLOSE call doesn't need an argument, for
Omnigraph will remember that you were
describing picture 1.  Now, if you want to describe another
picture, just use another DOPEN with another integer name.
Always DCLOSE each picture before DOPEN'ing another.
Don't try to get fancy and nest the description of pictures,
for it has no meaning to Omnigraph.
.skip 3
3. ^&Concerning units of measurement\&
.index Units of measurment
.skip 3
We have discussed the basic means for describing
pictures to Omnigraph.  The notion of lines, dots
and textual matter as composing a picture should
sound reasonable now.  However, we have blithely
described lines as starting at (1,2) and ending at
(2,6) or whatever, apparently with no regard for
units (feet, Angstroms, parsecs) and certainly no
dependence on the particular coordinate space of
a CRT terminal (e.g., 0:1023,0:1023 raster units).
This is one of the beauties of Omnigraph...you DON'T
have to worry about the particular units: just be
consistent unto yourself.  That is, if you describe
a triangle as the distances between three atoms or
three galaxies, just talk in terms of pure REAL numbers
and don't bother Omnigraph with the particular units
involved.
.skip 3
4. ^&Windowing\&
.index Windowing
.skip 3
Omnigraph is happy with pure numbers but should be given
some clue as to the extent of the picture.  That is, you
should describe an imaginary fence around your picture
that delimits the area with which you will be concerned.
This border is considered to be a rectangular WINDOW,
defined in the same units as pertain to the pictures that
will lie within it.  This rectangle
.index DWIND
is defined by the DWIND routine, and should be stated BEFORE
you DOPEN any picture WITHIN THAT WINDOW.  If you are 
content to work in a square region with x and y both ranging
from -1 to +1.
then you need not call DWIND, for
that is the default.
.skip 1
Please realize that the window is quite independent of the
pictures, and indeed may be smaller than the total
extent of a picture or pictures.  Its total purpose
is to delineate that portion that is to be
DISPLAYED on the CRT, when the time comes.  If the window
only covers a small portion of a picture, then only that
portion will ever get displayed, and the rest will be
.index Clipping
CLIPPED out, as if you drew the picture on
a tablecloth, then drew the window, and cut the cloth
along the edges of the window.  Now, upon throwing away the
rest of the tablecloth, the remaining rectangle would
be all that Omnigraph would ever display.  You realize that
this may only be a portion of the total picture, much more
than the picture, or none of the picture!
.skip 1
Here then, is the way you describe the window to Omnigraph.
You specify four points: first the minimum and maximum x
values, and then the minimum and maximum y values.
Let's now define some windows for picture 1:
.nojustify
.nofill

		CALL DWIND (-1,6,-1,6)

or

		CALL DWIND (-100,100,-100,100)

or

		CALL DWIND (0,.5,.2,.5)

.justify
.fill
.index Scaling pictures by windowing
The first DWIND call defines a rectangular window that
comfortably encloses the triangle with one "inch" (or
whatever units you think in terms of) surrounding the
triangle.
.skip 1
The second window, however, is much larger, making the
triangle itself appear
tiny within the large rectangle.  In contrast, the last
window is just a fraction the size of the triangle: apparently
one is interested in displaying the left corner of the
triangle ONLY, and CLIPPING out the rest of the picture.
.skip 1
All picture descriptions are interpreted in terms of the
existing window (or default window if none was explicitly
declared).  Omnigraph then considers the resulting picture
only to be that portion that fitted within the window boundaries
at the time the picture was defined.
Suppose that you set up a window and describe a picture that
only partially fits within those boundaries.  When posted, the
resulting display will show only that region.
Now, if you redefine the window (by another DWIND call) to 
include the entire picture, and DPOST that picture again,
you will NOT see the entire picture as originally described,
unless you again DOPEN and redescribe the picture.
.skip 1
You can perform any number of DWIND's, each call affecting
the subsequently defined pictures, however you must be
aware that a new set of window boundaries will not pertain
to a previously defined picture.
.skip 1
We can now describe pictures to Omnigraph, and provide
it with some nice information about that portion of
the picture (and surrounding space) with which you are
concerned.
Omnigraph must know the window boundaries BEFORE
it starts listening to your
picture descriptions.  Hence, call DWIND before DOPEN, or
be content with the default window.
.skip 1
At this point, we can fully describe a
picture to Omnigraph as well as its extent.  Now you may
be itchy to see your picture on the CRT screen.  Here comes
Omnigraph's forte.
.skip 3
.test page 10
5. ^&Displaying Pictures\&
.skip 3
.index Displaying pictures
Omnigraph allows you to display your pictures on a large
selection of graphics devices.  As mentioned before, Omnigraph
distinguishes between describing pictures and showing pictures.
In order to show a picture on the screen of a display device,
one must perform three operations:
.nojustify
.nofill

		1.  tell Omnigraph which display to use,
		2.  tell Omnigraph which pictures to show, and
		3.  physically obtain control of the device.

.justify
.fill
This approach allows one program to operate on many devices,
as long as the program asks the user which device is desired.
Furthermore, it allows several users to share one device, for
each user in turn can take control of the display and release
it in a cooperative manner.
Perhaps some mention of the various display devices should
be made at this point.
.skip 3
6. ^&Graphical Display Devices\&
.index Display devices
.index Storage tube displays
.index Refresh-type displays
.skip 3
There are basically two types
of displays: refresh-type, and storage tube. Refresh-type
displays repetitively draw the pictures on the scren, while
storage tube displays hold the image on the screen without
the need for refreshing.  Each device has its advantages.
The storage tube is cheaper for it doesn't need all the
hardware to continually redraw the pictures,
however the refresh-type display generally is
more dynamic (screen updates are easier) and has better
resolution.  Omnigraph currently provides support for
a number of refresh-type displays (DEC340, Adage AGT-30, and
DEC GT40) as well as storage tube devices (Tektronix 4010,
ARDS, and Computek C400).  Additional devices can be included
depending on the needs of the scientific community.  These
hardware matters are discussed in detail in the reference
manual.
.skip 3
7. ^&Preparations for Displaying Pictures\&
.index DINI
.index DGET
.skip 3
To select a particular display device, use the DINI routine
(where INI denotes INItialize).
This routine must be called before any other Omnigraph routine,
for Omnigraph must know which device you intend to use.  Among
other information, you pass either the symbolic name (DEC340,
4010, etc.) or corresponding number of the desired display.
Omnigraph now knows which device to use, however it hasn't
physically seized control of the device.
That is, the display may be waiting for you, or someone else
might be using it.
If the latter is the case, one
might program another DINI that requests another device,
so that he may see his pictures elsewhere!
.skip 1
Anyway, to get the display for yourself, use the DGET
call, which will indeed grab the device for your own use.
If the DGET fails, for the aforementioned reason, then it
will return a false value to that effect, allowing you to
either give up, or try another device.  Let's continue our
example, being ever aware of the order of the various
Omnigraph calls (blank lines are added to empahasize logical
steps):
.nojustify
.nofill

		CALL DINI (0,CH,ARRAY,SIZE)

		CALL DWIND (-1,6,-1,6)
		CALL DOPEN (1)
		CALL DMOVE (0,0)
		CALL DDRAW (3,0)
		CALL DDRAW (3,5)
		CALL DDRAW (0,0)
		CALL DMOVE (0,5.5)
		CALL DTEXT (18HTHIS IS A TRIANGLE,18)
		CALL DMOVE (3,5)
		CALL DTEXT (7HX=1,Y=1,7)
		CALL DCLOSE

		CALL DGET

.justify
.fill
Note that the DINI must come first.
The DINI call won't be discussed in
detail now, just notice the first argument.
The value 0 refers to the DEC340.
If you wish to use another device, you would substitute
another integer (or symbolic name).
.index DREL
.index Releasing the display
The DGET call resulted in your actually seizing the display.
It need not be called until you intend to actually use the
device.  You can later release the display to another user
by programming in a call to DREL, which performs the inverse
function of DGET.
.skip 1
One note more: Pictures can be drawn and "shown" even though
no display is "owned", i.e. even though no DGET has been
issued. The pictures will be held in computer memory ready
for display when a DGET is done.
.skip 1
.index DPOST
We are now close to actually seeing a picture
on the Cathode Ray Tube (CRT) screen.  You have told Omnigraph
which device
to use (DINI), described a picture, and even seized the
display device.
Now you want to see it; therefore use the DPOST routine
for displaying it on the CRT.  The use of the integer
picture number is now apparent, for to display picture 1:
.nojustify
.nofill

		CALL DPOST (1)

.justify
.fill
.skip 1
As a convenience, if one is
ready to see a picture as soon as he has described it, he
can substitute DPOST for the DCLOSE (remembering to pass the
picture number to DPOST).
.skip 1
.index DDONE
.index Storage tube display devices
The above is sufficient for refresh-type CRT devices
however there is another step required for
storage tube displays.
Storage tubes are ponderous devices, and it is advantageous
to do all posting and unposting of pictures at one time, hence
the DDONE routine.  DDONE is intended to be called after
you have decided which pictures are to be shown (DPOST),
not shown (DUNPOST), or deleted (see below).  However, the
screen will show no change until the DDONE call, at which
time the posted pictures will appear, and any pictures currently
on the screen that were unposted or deleted (since the last
DDONE) will then disappear.
.skip 1
DDONE was not designed into Omnigraph as a nuisance, but rather
as a synchronizing point: a call that in one step performs all
screen updates.  Optimally, you should use them sparingly, for
if there are 10 pictures on the screen, and you delete one, the
screen is actually erased, and the remaining nine pictures
painfully redrawn.  That is the nature of the beast.
Anyway, for completeness, if we wanted the triangle picture
to appear on a storage tube device (and we passed the proper
device identifier to DINI), we would:
.nojustify
.nofill

		CALL DPOST (1)
		CALL DDONE

.justify
.fill
The DDONE routine, while necessary for storage tube devices,
is not required when dealing with refresh-type displays.
In the latter case, the DDONE routine merely returns back to
the user program without performing any operation (termed
a NO-OP).
However, be careful to code in DDONE's if you wish to have
your programs work on both types of devices.
.skip 3
8. ^&Removing Pictures from the Display Screen\&
.index DUNPOST
.index Removing (unposting) pictures
.skip 3
There are many applications in which several pictures are
defined, and various combinations of these pictures may
be posted at any one time.  Therefore, there must be a mechanism
for selectively removing or "unposting" an already posted
picture.
Note that this does not
destroy the picture, it merely blanks it from the screen.
Again, you refer to the picture by its number:
.nojustify
.nofill

		CALL DUNPOST (1)
		CALL DDONE

.justify
.fill
DPOST and DUNPOST therefore are responsible for actually
providing visual images.
.skip 1
The operations of posting, unposting and deleting (described
below) can be done independently of the DGET operation.  In
fact, one can post a series of pictures, do a DGET call and
see the results of the posts once the display is actually
obtained.  Furthermore, one can then DREL the display,
perform some additional DPOST's and DUNPOST's then DGET the
display, and see the results of the operations performed
while the display was released.
Of course, if no further posting or unposting was performed,
when the display is obtained by the second DGET, the screen
will be the same as before it was DREL'd.
.skip 3
9. ^&Concerning the Deletion of Pictures\&
.index DKILL
.index Deleting pictures
.skip 3
The above discussion provided us with the means of describing,
posting, and unposting of pictures.  However, you may wish to
delete a picture outright, thus freeing up its number,
removing it from the CRT screen, and releasing the
memory space devoted to its internal representation.  Hence,
use the DKILL routine, passing to it the number of the picture
to be deleted, e.g.,
.nojustify
.nofill

		CALL DKILL (1)
		CALL DDONE

.justify
.fill
.skip 3
10. ^&A Complete Example\&
.skip 3
At this point, we have covered the basic tools provided by
Omnigraph for the description and displaying of pictures.
We should now exercise the techniques for posting and unposting
pictures.
Therefore, let's have the the triangle and labels as separate
pictures.  At execution time, the first triangle will appear,
and the program will pause (wait for input).  After
the pause, the labels will also appear, and again pause.  After
the second pause, let's delete the triangle, leaving only the
labels.  Finally, after the last pause, let's delete both
pictures.
.nojustify
.nofill

		DIMENSION ARRAY (1000)
		CALL DINI (5,10,ARRAY,1000)
		CALL DGET
		CALL DWIND (-1,6,-1,6)
		CALL DOPEN (1)
		CALL DMOVE (0,0)
		CALL DDRAW (3,0)
		CALL DDRAW (3,5)
		CALL DDRAW (0,0)
		CALL DPOST (1)
		CALL DDONE
		PAUSE
.justify
.fill
.nojustify
.nofill
		CALL DOPEN (2)
		CALL DMOVE (0,5.5)
		CALL DTEXT (18HTHIS IS A TRIANGLE,18)
		CALL DMOVE (3,5)
		CALL DTEXT (7HX=1,Y=1,7)
		CALL DPOST (2)
		CALL DDONE
		PAUSE
		CALL DUNPOST (1)
		CALL DDONE
		PAUSE
		CALL DKILL (1)
		CALL DKILL (2)
		END

.justify
.fill
It is recommeded that you copy this example or any variations
that you may desire and see your results on a display screen.
In the above example, the DEC GT40 (display number 5) is
referenced, and ARRAY provides 1000 words of storage for
the pictures.  Refer to the reference manual if you desire
to use another display.  The DDONE's are necessary only
for storage tube devices, but was included in this example
for generality.
.skip 1
It is important to realize that you need to "hang" the execution
of your program (by pauses, or input waits) in order to give
you time to see the pictures on the screen.  Otherwise, the
program would flash to completion, leaving you staring at a
blank screen.
.skip 3
11. ^&Appending to a Picture\&
.index DAPPEND
.index Appending to a picture
.skip 3
You can add to the description of a picture by the
DAPPEND routine (which requires a picture number as an 
argument).  After the DAPPEND call, one can continue
the various calls to DMOVE, DDRAW, DTEXT, etc., as if the
DCLOSE (or DPOST) did not occur.  If the picture is currently
posted, the new additions will not appear until the picture
is again DCLOSE'd.  For example, let's say we wanted to
post the triangle by itself, then append the two labels
at a later time:
.nojustify
.nofill

		CALL DINI (0,CH,ARRAY,SIZE)
		CALL DGET
		CALL DWIND (-1,6,-1,6)
		CALL DOPEN (1)
.justify
.fill
.nojustify
.nofill
		CALL DMOVE (0,0)
		CALL DDRAW (3,0)
		CALL DDRAW (3,5)
		CALL DDRAW (0,0)
		CALL DPOST (1)
		CALL DDONE
		... additional code ...
		CALL DAPPEND (1)
		CALL DMOVE (0,5.5)
		CALL DTEXT (18HTHIS IS A TRIANGLE,18)
		CALL DMOVE (3,5)
		CALL DTEXT (7HX=1,Y=1,7)
		CALL DCLOSE

.justify
.fill
You can think of the DAPPEND as a DOPEN on an already
defined picture, which merely continues the description of
the picture.  Note that since we wanted to see the
picture immediately, we substituted a DPOST for the initial
DCLOSE.
.skip 3
12. ^&Viewports and Screen Utilization\&
.index DPORT
.index Viewports
.skip 3
Some mention of screen coordinates and units is appropriate
at this point.  If you remember, the user coordinate space
is specified in terms of real numbers, and while the numbers
generally have some unit of measure (in the user's mind),
the choice of inches
versus millimeters is irrelevant.  Essentially, a relative
scale is formed by comparing the extent of the picture
to that of the (explicit or default) window.  This frees the
user from carefully scaling the picture to insure that it
will fit within the screen dimensions.
.skip 1
Omnigraph goes one
step further and allows you to define a rectangular region
on the surface of the CRT within which the pictures will
be displayed.  This "viewport" is specified by the DPORT
routine.  Again, in order to stay device independent, the
rectangular region is specified in unitless
coordinates (0 to 1) with the origin (0,0) at the lower left
corner of the screen (regardless of device type).
The viewport is specified in the same manner as the
window, with the minimum and maximum x values followed by the
minimum and maximum y values.
The default viewport is (0,1,0,1).  Note that the default
viewport is a square, specifically, the largest square that
will fit a rectangular screen.
The picture(s) that fall within the window will then be 
scaled to fill up the viewport.
.skip 1
If you want to use various portions of the screen for
different purposes (e.g., devoting a column along the left
side of the screen to a "menu" of responses, as is often
used in interactive dialogs), then you can define various
viewports.  This task is sensitive, for various side effects
can occur.
.skip 1
One must be careful to keep the width-to-height
ratio of the viewport equal to that of the window, otherwise
the picture will be DISTORTED TO FIT THE VIEWPORT!  Think of
your picture as elastic.  If the window is a tall rectangle,
and the picture in the window is a circle, then if the viewport
is a square (perhaps the default viewport) the poor circle
will be squashed into a short wide ellipse when displayed.
On the other hand, controlled use of this feature can be
very useful.
.skip 1
Secondly, in order to be effective, the viewport MUST be specified before describing a
picture.  Since the default viewport is in effect initially,
you must call DPORT before doing any DDRAWS, or whatever,
if you wish to have that
picture in a special viewport.  Furthermore, all succeeding
pictures will be displayed (superimposed) in that viewport
until the next DPORT call.  The viewport is
similar to the window in that it applies to all subsequently
described pictures until redefined.  
.skip 3
13. ^&Some Additional Routines\&
.skip 3
At this point, some additional Omnigraph routines should
be introduced, just so that you know of their existence.
Included are DINT,DSTAT,DCODE,DRAST,DTSCAL,DCHAR,DENQ,DCURSOR, and
DPLOT (all of which are documented in the reference manual).
After this discussion, we will approach some of the more
"advanced" topics of graphics.
.skip 1
.index DINT
.skip 1
The DINT routine is provided to allow one to change the
intensity of lines and text at will.  The routine expects
a real value in the range 0 to 1 which is converted into
a corresponding screen intensity.  This is an attempt at
device independence, however the result of a DINT call
varies from device to device.  Storage tube devices have
only one intensity, the DEC340 has 8 while the Adage has
essentially a continuous range of intensities.  Like DPORT
and DWIND, the DINT call provides an alternative to the
default value, and affects all subsequently described 
pictures.  Furthermore, DINT can be called inside or outside
of a picture description.
For devices with multiple intensities, the default is a
medium intensity.
.skip 1
.index DSTAT
The DEC GT40 has some hardware features that are utilized
by the DSTAT routine.  Italics, blinking, and various
vector types are set and reset by this command.  It also 
has some applicability with the Adage and it controls vertical
text placing for the DEC340; however it is a no-op
for all other devices.
The default is solid-type lines, no blinking,  no italics, and horizontal text.
.skip 1
.index DCODE
If you wish to get fancy and directly program the hardware
itself you can send individual hardware commands by the
DCODE routine.  Of course, this is hardware dependent.
.index DRAST
.index Raster mode pictures
.skip 1
The DEC340 has special hardware which allows "raster mode"
pictures.  Before generating raster mode pictures (via the
DCODE routine), you should call DRAST to put the 340 in
raster mode and to preallocate a large enough core block.
.skip 1
.index DTSCAL
DTSCAL finds applicability when programming for devices
with various hardware character sizes  (storage tube displays
are restricted to one character size  while the DEC340 has
four).  Omnigraph doesn't get upset if you code some strange
character size for a one-character-size device, it merely
gives you what it can.
.skip 1
.index DCHAR
The DCHAR routine is useful for a fancy Omnigrapher that
is concerned with the character display capabilities of
a given device.  When passed the code for a specific
character, DCHAR returns a value that indicates whether or
not the device can display it.
.skip 1
.index DENQ
For hearty souls, the DENQ routine can return an array
of information concerning hardware matters, current x and
y beam position and the like.
This is useful when doing precise graphics, such as
accurately positioning characters, and computing the actual
dimensions of pictures as they appear on the display screen.
.skip 1
.index DCURSOR
Finally, one should mention DCURSOR, which is useful when
programming for storage tube displays.  You pass the
coordinates to DCURSOR in order to specify the
position for the hardware cursor after the next DDONE.
.skip 1
.index DPLOT
.index Plotting
Omnigraph provides a facility for generating hard copy
graphics.  The DPLOT routine allows the user to
take a "snapshot" which accurately portrays the
status of the display screen at the time DPLOT is executed.
When executed, a file is generated in your area which can
later be processed by PLOTX, a program that reads the
previously generated plot file, and performs the actual
plotting (or generates a plot tape for offline Calcomp
plots).
The file generated by DPLOT will either be given the
name that was passed as an argument, or if that argument is 0,
DPLOT will find a unique integer name for you.
The extension "PLX" is appended to the file name.
.skip 1
DPLOT produces a recording of the state of the screen
at the time the routine is called.  Consequently, only
those pictures currently posted will be recorded, hence
plotted when you run the PLOTX program.
For example, let's say that you have just posted picture 1
and want to make a plot of it, then unpost it, and post picture
2 and plot it separately:
.nojustify
.nofill

		CALL DPOST (1)
		CALL DPLOT (A,100)
		CALL DUNPOST (1)
		CALL DPOST (2)
		CALL DPLOT (A,200)

.justify
.fill
When executed, the first plot file (100.PLX) would be a
snapshot of picture 1, and similarly, 200.PLX would provide
a plot of picture 2.  If the second arguments were both 0,
then DPLOT would have generated some file names such as
000001.PLX and 000002.PLX.  In both calls to DPLOT, the
first argument (A) refers to a 128-word array in your 
program that can specify various plotting parameters (pen color,
paper type, etc.).
.skip 3
14. ^&Interactive Programming\&
.index interaction
.skip 3
Up to now, the emphasis has been on describing pictures
as a sequence of calls to various Omnigraph routines.
With these tools, you should be able
to describe and display a picture on a graphics CRT.
However, there is a consideration of timing that has
yet to be introduced.  If one merely DOPEN'ed, DCLOSE'd,
DPOST'ed and terminated execution, the program would
probably be finished before the picture ever appeared on
the screen.  Consequently, you must make your program
pause according to your desires.  The fundamental
technique for
maintaining control over a program is to cause it to wait for
input from you.  This may be merely a carriage return
or some more sophisticated action.
This discussion is leading toward the concept of
INTERACTIVE GRAPHICS.  The goal is to design a program
that waits for an action from you (request), and responds
with a useful sequence of operations (typically the posting,
unposting, of pictures, etc.).
.skip 1
.index Menu, uses of in interaction
You can then envision a program with a nice "menu" of possible
responses.   Each action would elicit a well defined
response which, upon completion, would leave the program
waiting for another action from you.
The program should signal that it has indeed completed
its task.
Also, you might have
the program gracefully acknowledge when it doesn't understand
an action that you request, whereupon it patiently awaits
another action.
.skip 3
15. ^&Methods for Providing Input for Interaction\&
.index Input
.skip 3
Now, let's consider your means for input.  Of course,
there is the keyboard (from which you run your job), in
which you might have each action
numbered or otherwise encoded.  Then, the program would
wait for input (by the ACCEPT statement in FORTRAN, for
example) and do a transfer of control to the appropriate
portion of the program, depending on the value of the
input.  Eventually, the program would again wait for
input.
.skip 1
For example, let's again use the triangle, however
this time let's interactively input the various window and
viewport boundaries, then the three endpoints of the triangle,
and finally, post and unpost the picture interactively.
.nojustify
.nofill

	DIMENSION ARRAY (1000)
	CALL DINI (5,10,ARRAY,1000)
	CALL DGET
900	TYPE 10
10	FORMAT(' SPECIFY WINDOW BOUNDARY'/)
	TYPE 20
20	FORMAT(' (XMIN,XMAX,YMIN,YMAX)'/)
	ACCEPT 30,XMIN,XMAX,YMIN,YMAX
30	FORMAT(4F)
	CALL DWIND(XMIN,XMAX,YMIN,YMAX)
	TYPE 40
40	FORMAT(' SPECIFY VIEWPORT BOUNDARY'/)
	TYPE 50
50	FORMAT(' MIN AND MAX VALUES IN RANGE 0-1'/)
	ACCEPT 60,XMIN,XMAX,YMIN,YMAX
60	FORMAT(4F)
.justify
.fill
.nojustify
.nofill

	CALL DPORT(XMIN,XMAX,YMIN,YMAX)
	CALL DOPEN (1)
	TYPE 100
100	FORMAT(' INPUT FIRST POINT OF TRIANGLE'/)
	ACCEPT 200, X,Y
200	FORMAT(2F)
	X1=X
	Y1=Y
	CALL DMOVE (X,Y)
	TYPE 300
300	FORMAT(' INPUT SECOND POINT NOW'/)
	ACCEPT 400,X,Y
400	FORMAT(2F)
	CALL DDRAW (X,Y)
	TYPE 500
500	FORMAT(' INPUT THIRD AND FINAL POINT'/)
	ACCEPT 600,X,Y
600	FORMAT(2F)
	CALL DDRAW (X,Y)
	CALL DDRAW (X1,Y1)
	CALL DPOST (1)

1200	TYPE 700
700	FORMAT(' TYPE 1 TO POST, 0 TO UNPOST, -1 TO RESTART'/)
	ACCEPT 800,N
800	FORMAT(I)
	IF (N) 900,1000,1100
1000	CALL DUNPOST(1)
	GO TO 1200
1100	CALL DPOST(1)
	GO TO 1200
	END

.justify
.fill
Notice that the program waits at each accept statement
for input from the user.  Of course, the user has been
"prompted" by the program as to what data it desires.
Once the three endpoints have been specified, the program
posts the picture, then reaches a central point.
A message is typed that asks the user to type 0 to unpost
the picture, 1 to post it again, or -1 to restart the
dialog.  In the latter case, the program again asks the
user for window and viewport parameters and a new triangle.
Eventually the program falls back into the -1,0,1 decision
point.
.skip 1
Performing interactive graphics through a keyboard
can be
ponderous, however there are seldom any alternatives for
remote users.  For those with access to the DEC340 (located
in the DECsystem-10 computer room), Omnigraph provides
additional means for interactive input
through the DEVENT and DOUT routines.
.skip 3
16. ^&Events\&
.index Events
.skip 3
Omnigraph refers to a basic input action as an "event."
An event can be the striking of a function key
or a tablet stylus motion.  Let's now discuss these input
devices.
.skip 3
17. ^&Function Box\&
.index Function box
.skip 3
The DEC340 has a function box with 16 keys
which can be used during an interactive dialog.  The user
may program a "special meaning" for each key, thus allowing
many operations to be conveniently automated.
Each key can be individually illuminated under program control,
providing an indication of which key was hit, or should be hit,
etc.  We
will discuss the techniques for programming the function
box later.
.skip 3
18. ^&Grafacon Tablet\&
.index Graphacon tablet
.index Tablet input
.skip 3
The second input device on the DEC340 is the Grafacon,
which allows one to point to any
place on the display screen by touching a stylus to the
corresponding point on a tablet (located below, and just in
front of the screen).
The tablet has the same dimensions as the CRT screen, and
a given
motion across the tablet will result in a bright dot crossing
the same distance on the screen.  One can easily coordinate
the pen motions in order to locate points of interest, or
draw curves "on the CRT".  In turn, we will discuss the 
programming necessary to accomplish this.
.skip 3
19. ^&Synchronizing Events to Program Execution\&
.index Events, synchronizing
.skip 3
Events occur asynchronously.  For example, an event occurs
every time you hit a function key, whether or not your program
was ready for it.  The computer is kind enough to save a limited
number of these events (in chronological order)
in case your program is not ready to accept them
precisely when they occur.  That is, the description of each
event is saved internally in an "event buffer" which may later
be examined by Omnigraph.
On the other hand, unless you
tell your program to wait for an event, it may well finish
execution before you ever get around to hit a function
key (or move the tablet stylus).
Consequently, you must provide a means for synchronizing the
occurrence of events and the processing of them by your
program.  Now, we should discuss the Omnigraph calls that
provide for handling these events.
.skip 3
20. ^&DEVENT\&
.index DEVENT
.skip 3
The DEVENT call has two functions.  First, it is used to
define which events you are interested in, and what to do
with them when they occur.  Second, the same routine is
called either to wait for an event, or see if one has occurred.
The DEVENT routine also specifies a small array that will be
used by Omnigraph to store information about the event.
.skip 1
Let's now study the arguments required by DEVENT:
.nojustify
.nofill

		CALL DEVENT (EVENT,OP,A)

.justify
.fill
The first argument, EVENT is an integer which specifies 
an event:
.nojustify
.nofill

		1= function key hit
		2= tablet stylus is raised after being moved
                   while touching the tablet
		4= tablet stylus is touching and has moved

.justify
.fill
The second argument, OP is also an integer:
.nojustify
.nofill

		1= clear out event buffer
		2= enable specified event
		4= wait until the specified event occurs

.justify
.fill
And the final argument, A is a real (floating point)
array with three entries that will receive information
about a single event.
At any time, the array will either
be "empty" (first element = 0) or hold a report on a single
previous event.  Note that if you generate a series of events
(perhaps by hitting several function keys), the first such
event will be reported first (by a DEVENT call), and each
successive DEVENT call will return the next event,
in chronological order until all events have been reported,
wherein the array will again be empty.
.skip 1
Both the EVENT and OP values are designed so that you can
combine them for convenience (instead of requiring separate
DEVENT calls for each type of event and operation).
Now for some examples:
.nojustify
.nofill

		CALL DEVENT (1,3,A)

.justify
.fill
This call clears out the event buffer and enables the
function box.  Notice that these two operations were
accomplished by one DEVENT call by combining the OP values
(1+2=3).
Let's now tell Omnigraph that we wish to consider the
moving of the tablet stylus (when in contact with the
tablet) as an event.  And for good measure, let's clean
out the event buffer:
.nojustify
.nofill

		CALL DEVENT (4,3,A)

.justify
.fill
Actually, if we want both events to be enabled, we could
have combined the EVENT argments (1+4=5) as:
.nojustify
.nofill

		CALL DEVENT (5,3,A)

.justify
.fill
These examples use the DEVENT routine in order to do
initialization:  notify Omnigraph of which events to
expect, and clear out the event buffer.
.skip 1
When programming for events, the above housekeeping chores
need be performed once, but they MUST be done before you
expect to process any events.  Then, once you have "enabled"
all events that you will expect, you should have your
graphics program either wait for an event (OP=4), or
provide a loop so that DEVENT is repetitively called (OP=0).
Looping is not recommended, however, for it tends to waste
computer time as your program continually tests for your input.
You pay for this
useless execution, and degrade the overall system response as
well.
.skip 1
In the first case,
the program will wait at the DEVENT call until
an event occurs, wherein a description of the event will
be placed in A and execution will continue.  The program
can then look in the array to see what happened, and perform
some appropriate response.  In the latter case, where you
do not wait, each time that you loop through
the DEVENT call, the first entry of A will be set to 0
until an event occurs.
In either case, after an event occurs, the type of event
(1,2 or 4) would be in A(1) and additional information in 
the other two entries of A.
.skip 1
Let's say that your Omnigraph program just executed a
DEVENT call and an event has occurred.
If it was a function key hit, then A(1)=1, and the
key number will be in A(2).
.skip 1
If instead, you had raised the stylus off the tablet (after
moving it a bit), then A(1)=2, and the x and y coordinates
of the point at which the stylus was raised would be found
in the second two entries of A.  Note that the values
of x and y are in the same measure as used to
describe the window, hence "in scale", and not in screen
coordinates or any other ugly form.
Be careful, for the window boundaries used to scale the input
data are those that exist at the time the DEVENT is executed.
.skip 1
Finally, if you had touched the stylus to the tablet and
moved it a bit, A(1)=4 and the x and y coordinates of
the final stylus position would be in A's second and
third entries, again in the user's coordinate range.
.skip 1
Now let's use the routine to wait for a function
key hit, and if key 10 is hit, let's post picture 1:
.nojustify
.nofill

		CALL DEVENT (1,3,A)
	100	CALL DEVENT (1,4,A)
		IF (A(1) .NE. 1) GO TO 100
		IF (A(2) .EQ. 10) CALL DPOST (1)
		... additional code ...

.justify
.fill
The first line allows function key events to occur.  The
second line causes the program to actually wait for an
event (not necessarily a function key hit) to occur.
When an event occurs, we see if it was a function key hit,
and if it was key 10 then the response is to post picture
1.  An actual program would probably loop back to statement
100 in order to wait for another event.  Of course, the
above example ignores all events other than functon key hits.
The line following statement 100 could have been a computed
go to, or the like, which would transfer control to different
portions of code for tablet hits as well.
.skip 1
The above example used a DEVENT that waited for an event.
If one does not want to wait, but rather just check every once
in a while whether an event occurred, then he can just pass
a 0 for the OP argument.  The following is equivalent to the
previous method, but loops rather than waits:
.nojustify
.nofill

		CALL DEVENT (1,3,A)
	100	CALL DEVENT (1,0,A)
		IF (A(1) .NE. 1) GO TO 100
		IF (A(2) .EQ. 10) CALL DPOST (1)
		... additional code ...

.justify
.fill
Note that A(1) will be 0 until an event occurs.
.skip 3
21. ^&DOUT\&
.index DOUT
.index Input devices, initializing
.skip 3
Initially, once the first DEVENT is performed for the function
box, all lights are extinguished.  Similarly, a DEVENT call
to initialize either tablet event results in a dot following the
stylus, however inking is not enabled.
Therefore, to provide a mechanism for controlling the
illumination of the function keys and inking, Omnigraph provides
DOUT:
.nojustify
.nofill

		CALL DOUT (INPUT DEVICE,OP)

.justify
.fill
The first argument
specifies the physical device: 1 for function box and 2 for
the Grafacon tablet (if desiring either type of tablet
event, or both).
.skip 1
The second argument OP has quite a different function than
with DEVENT.  If the first argument specified the function
box, then OP controls the lights that illuminate the individual
keys.  If OP is a positive integer in the range 1 to 16, then
the corresponding key is illuminated.  Conversely, a negative
number turns off the illumination of that key.  Finally a
value of 0 turns off all key lights.  Hence, DOUT can be
used to illuminate a key, thus acknowledging that the key
was hit.
Let's combine DEVENT and DOUT calls to illuminate a function
key when it is hit:
.nojustify
.nofill

	100	CALL DEVENT (1,7,A)
		I=A(2)
		CALL DOUT (1,I)
		GO TO 100

.justify
.fill
The DEVENT tells Omnigraph to expect
function key events, to clear the event buffer, and wait for
an event.  Finally, since we don't expect any other kind
of event, we merely pass the returned key number to the
second DOUT, which illuminates that key.  Then, the program
loops to wait for another key hit.
.skip 1
The DOUT call with 2 as the first argument is necessary
to initialize inking.  If OP is positive, a trail of
"ink" on the screen will follow the path of the stylus
whenever the stylus is depressed.  The value of OP is
taken to be the maximum length of ink to use before
"running out."  This value is approximately in inches, but
should be established more accurately by trial.
In addition, a dot will
follow the stylus whether it is depressed or not.  If OP is
zero, the inking is disabled, but the dot will still
follow the stylus.  Finally, if OP is negative, both the
inking and dot are disabled. 
.skip 1
The use of DOUT for the tablet is independent of DEVENT,
and as long as the tablet has been initialized
either by a DOUT or DEVENT, then a dot
(and optionally, ink when the stylus is touching) will
trace your stylus motions.  This tracking occurs at high
speed, and can be considered to be independent of your
program control.  You do not have to generate the ink by
DDRAW's or such.  Furthermore, the dot occurs independent
of any pictures that may be on the screen.
.skip 1
Let's just initialize the tablet, and allow 50 inches of
ink:
.nojustify
.nofill

		CALL DOUT (2,50)
		... additional code (loop, etc.) ...

.justify
.fill
We can now demonstrate the use of DEVENT concerning tablet
events.  For example, let's draw a polygon on the screen
by hand, using inking to show our path.  When we get to each
corner, let's lift the stylus off of the tablet to signify
the end of that line, and when done, hit function key 1 to
replace the freehand figure with a more precise picture
consisting of DMOVE's and DDRAW's:
.nojustify
.nofill

		DIMENSION A (3)
		CALL DINI (0,10,A,0)
		CALL DGET
	100	CALL DOUT (2,50)
		CALL DOPEN (1)
		CALL DEVENT (4,7,A)
		CALL DMOVE (A(2),A(3))
	200	CALL DEVENT (3,7,A)
		IF (A(1) .EQ. 1) GO TO 300
		CALL DDRAW(A(2),A(3))
		GO TO 200
	300	CALL DOUT (2,50)
		CALL DPOST (1)
		CALL DDONE
	400	CALL DEVENT (1,4,A)
		IF (A(1) .NE. 1) GO TO 400
		CALL DKILL (1)
		CALL DDONE
		GO TO 100
		END

.justify
.fill
The above program is shown in its entirety.  
The DINI call deserves some more attention.  The first argument
told Omnigraph to use the DEC340, while the second argument
specified a software channel which Omnigraph would need for
its communication with the DECsystem-10 monitor.  You need
merely pass an integer in the range 0-15.
The next argument specified an array A destined to hold the
the picture descriptions.
The last argument gives the length to be allocated for pictures
(generally the length of the array).  However,
a length of 0 means
to use a separate area for building pictures (called a high
segment), and to not really use array A at all!) 
Hence the third argument is a dummy in the case of length 0.
Consequently, we can get away with A, which is really
intended for the event reporting.  Note that the DEC340 requires
the use of a high segment, hence you must specify 0 as the
last argument.
.skip 1
The next step is to get the display by DGET.  Statement 100
initializes the tablet hardware, and allows 50 inches of ink.
Note that as soon as that call is executed, you can draw all
over the screen, leaving a line where you go.
Then the first DEVENT does the
following:
.nojustify
.nofill

	1. clear the event buffer,
	2. allow stylus motion events to occur,
	3. wait for the first such event.

.justify
.fill
As soon as the stylus touches the tablet and moves a tiny bit,
an event occurs which we consider to be the initial point
in our polygon, hence the x and y values of that point are
passed to a DMOVE.  Now, we enable the other two types of
events in the second DEVENT, and again wait for the next event.
That is, we now allow function key hits, as well as events
generated whenever the stylus is raised from the tablet.
Then, we do a DDRAW to each corner, as defined by the event
that occurs when the stylus is raised.  Finally, after any
number of DDRAW's, we exit from that wait loop when a function
key hit is detected, wherein the ink is reinitialized (erasing
the hand drawn polygon), and the newly described polygon
is closed and posted by the DPOST.  Finally, in order that
you can repeat this feat, we wait for another function key
hit.  When that occurs, we kill the old picture and loop
back.
.skip 3
22. ^&A Technique for Describing Irregular Pictures\&
.index Freehand drawings using the tablet
.index Tablet techniques
.skip 3
Perhaps it is fair to give an example of a program written
in SAIL.  This program utilizes DEVENT and DOUT in order to
allow the input of general freehand curves.  Operationally,
one positions the tablet stylus to a desired start point, and
hits function key 1 to denote that fact, then proceeds to
draw the curve.  When completed, the stylus is raised, and
function key 2 is hit, whereupon the freehand inking is 
replaced with a series of line segments.  Note that this
program "thins" the inputted points, by drawing every fourth
point.  This is recommended when you either don't need the
resolution that the tablet delivers to you, or you cannot
afford to process the multitude of events that are generated.
Actually, this thinning facility could be built-in to the
Omnigraph routine.
The program loops indefinitely.
.nojustify
.nofill

	REAL ARRAY A[1:3];
	REAL X,Y;
	DINI (0,10,D[1],0);
	DWIND (0.,1.,0.,1.);
	DGET;
	WHILE TRUE DO BEGIN
		DOPEN (1);
		DOUT (2,40);
		DOUT (1,0);
		WHILE TRUE DO BEGIN
   		   DEVENT (5,7,A[1]);
		   IF A[1]=4 THEN BEGIN
			X<-A[2]; Y<-A[3];
			END;
		   IF A[1]=1 AND A[2]=1 THEN DONE;
		   END;
		DMOVE (X,Y);
		DOUT (2,100);
		NUMBER<-0;
		WHILE TRUE DO BEGIN
	   	   DEVENT (5,4,A[1]);
		   IF A[1]=4 AND NUMBER=4 THEN BEGIN
			DDRAW (A[2],A[3]);
			NUMBER<-0;
			END;
	   	   IF A[1]=1 AND A[2]=2 THEN DONE;
		   NUMBER<-NUMBER+1;
	   	   END;
		DOUT (2,100);
		DPOST (1);
		DDONE;
		DEVENT (1,5,A[1]);
		DKILL (1);
		DDONE;
		END;
	END;
.justify
.fill
Note that a window was defined in this example.  Since the
x and y coordinates are returned by DEVENT within the range
of the window.  This effectively scales the inputted lines.
If instead, it were convenient to consider the maximum
vertical or horizontal length as 100 (perhaps Angstroms), with
the minimum x and y values of -100,61 (that would be the
lower left corner of the window), you would program:
.nojustify
.nofill

		DWIND (-100,0,61,161)

.justify
.fill
Then, for example, if you touched the stylus to the lower
right corner of the tablet, DEVENT would return the point
(0,61).  In both of the above examples the DEVENT
call waited for an event, rather than be executed
repetitively.  It is recommended that this be done when
possible as it synchronizes the program to the
input, and tends to be easier to code.
.skip 1
The last example, which provides a freehand drawing
ability is valuable in describing irregular pictures. It
finds applications in tracing curves (that can either be
projected onto the tablet, or traced directly from paper).
Once the stylus is positioned, the input stream of x and y
coordinates can be placed in an array (incrementing
the array pointers before looping back to the DEVENT each
time), or written onto a disk file, or utilized immediately.
.skip 1
Of course, the function
keys are useful in signaling certain actions (start drawing,
end of picture, erase last attempt).  Furthermore, the
.index Menu, uses of in interaction
stylus can be used to control the program.  A menu (list
of desired actions) is placed on the screen (a
picture consisting of DMOVE's and DTEXT's), and the stylus
is moved to the vicinity of one of the entries.  The program
compares the x,y coordinates returned by DEVENT to the
known positions of the entries, and selects the indicated
entry.  The program then performs a response based on the
selection.  Be careful, however, to program this menu
selection routine to be distinct from curve drawing, and
to give some feedback as to which menu entry the program
thought you chose.
.skip 3
23. ^&Dynamic Graphics (Animation)\&
.index Animation
.index Dynamic graphics
.skip 3
If you have a graphics application in which dynamically
changing pictures are desired, then you can use some simple
programming techniques to achieve animation on the CRT screen.
The fundamental principle is to post and unpost a series
of similar pictures in rapid succession.  Each picture
differs incrementally from its predecessor, so that they
produce an affect of one picture gradually changing.
Such animation can show motion (an object moving across the
screen or rotating in space, etc.) or evolution (the dynamic
behavoir of a mathematical function as various parameters
are modified, or even the gradual growth of an embryo).
.skip 1
To achieve such dynamics, one must use dynamic hardware, and
this fairly well rules out storage tubes.  Storage tubes
generally have no provision for gracefully removing a picture
from the screen.  Rather, the screen is erased in one flash
(literally) in which all pictures are removed, whereupon any
that are not to be unposted must be redrawn.  This annoying
outburst between successive pictures in an animation sequence
would tend to nullify the desired effect.  Consequently, you
should use refresh-type displays.
.skip 1
In order to appear smooth to the eye, the sequence should
occur as rapidly as possible (ideally 30 times a second
or better).  Hence you should generally have the program
display the sequence at a high rate.  If you generate each
successive picture just before posting it, you should be
careful that the time required between the DOPEN and DPOST
is not excessive, otherwise the animation effect will be
degraded (the sequence will be jerky).  On the other hand, if
you generate all the individual pictures that comprise the
animation sequence ahead of time, then run through a tight
loop DPOST'ing and DUNPOST'ing each successive picture, the
animation might very well be too rapid.  Clearly one must
empirically decide the appropriate method.  Remember that
a 30 picture/second display rate would exhaust a sequence of
30 predefined pictures in one second.  Obviously, if each
such picture has any complexity, the memory space required
for a reasonably long sequence would be prohibitive.
Generally, you must resort to generating each successive
picture just before displaying it, and hope that the time
between pictures is tolerable.
.skip 1
In the latter case, you can use one picture number, and
continually perform a DOPEN/DPOST loop.  Omnigraph provides
the necessary "double buffering" to allow you to be
simultaneously showing a picture and redefining it.  That is,
in the following sequence, picture 1 is described, then
shown.  Then when completely redescribed (at DPOST), the
old version is rapidly replaced by the new version.  This
process is automatic and readily lends itself to animation.
.nojustify
.nofill

	100	CALL DOPEN (1)

		... description of picture which ...
		... changes slightly each time ...
		... this code is executed ...

		CALL DPOST (1)
		GO TO 100

.justify
.fill
Note that the loop is closed, so that the code within
the picture description must keep track of itself, so that each
successive time it is executed, the picture is modified
slightly.  One could also program:
.nojustify
.nofill

		... code to initialize ...
		... the parameters used ...
		... to generate the animation ...
		... effect ...

	100	CALL DOPEN (1)

		... code to generate picture ...
		... based on parameters that ...
		... are changed slightly by ...
		... code that lies below ...

		CALL DPOST (1)
		... code to modify certain ...
		... parameters in order to ...
		... generate animation effect ...
		GO TO 100

.justify
.fill
especially when the changes in the pictures is of importance,
rather than any specific picture.  Furthermore, dynamic
graphics allows one to accumulate a feel for less tangible
properties such as the rate of change of various features of
a picture.
.skip 3
24. ^&Loading and Executing Omnigraph Programs\&
.index Loading and executing Omnigraph programs
.index FORTRAN
.index SAIL
.skip 3
Once your program has been coded (let's call the file YOUR.F4),
you must first debug any 
compile errors by typing (to the monitor):
.nojustify
.nofill

	COMPILE YOUR.F4

.justify
.fill
Once your program compiles correctly, you must include the
appropriate Omnigraph routines.  This is performed when you
load your program along with either DISFOR or DISSAI, depending
on the language that you used.  If your program was in FORTRAN,
then after compiling it, the loading procedure would be:
.nojustify
.nofill

	LOAD YOUR.REL,SYS:DISFOR.REL

.justify
.fill
You could now save the resultant load module 
by typing:
.nojustify
.nofill

	SAVE YOUR

.justify
.fill
Now that you have the program ready to run, you can run it by typing:
.nojustify
.nofill

	RUN YOUR

or merely type the program name (as SAVEd), e.g.,

	YOUR

.justify
.fill
If you wish to merely execute the program, and not save it
for later runs, you can instead type:
.nojustify
.nofill

	EXECUTE YOUR.F4,SYS:DISFOR.REL

.justify
.fill
However, the load and save procedure is recommended as you
need not reload each time you run (as occurs when you just
execute the program).
.skip 1
If you program in SAIL, then the procedure would also apply
(merely substitute DISSAI for DISFOR), however you could
simplify the procedure by using the REQUIRE statement in you
program itself:
.nojustify
.nofill

	REQUIRE "SYS:DISSAI" LOAD!MODULE;

.justify
.fill
.test page 10
This then allows you to merely say:
.nojustify
.nofill

	LOAD YOUR.SAI

and

	SAVE YOUR

and

	RUN YOUR

or simply

	EXECUTE YOUR

.justify
.fill
Notice that the extension .SAI is included to signify that
your program is written in SAIL.
^^
.tab STOPS 8 16 24 32 40 48 56 64
.subtitle Omnigraph Tutorial - Advanced Topics
.PAGE
25. ^&Advanced topics\&
.skip 3
This section contains the following:
.SKIP 1
.nofill
.nojustify
25.1. Various "straight" examples

      Example 1	Program to show how the number of terms in
		the Fourier expansion of a square wave affects
		the display of the wave.

      Example 2	A board for tick-tack-toe

      Example 3	A simple way of displaying a 'three-dimensional'
		function, giving an impression of depth rather
		than true perspective.

25.2. Discussion of matrix transformations

      Example 4	A program which rotates squares at various
		spots on the screen.

      Example 5	Example 4 modified to rotate an origin-centered
		square through an angle.

25.3. Discussion of three-dimensional displays

      Example 6	A cube centered about the origin, rotated about
		all three axes, and viewed from a fixed point.

      Example 7	A cube fixed in position but viewed from varying
		positions.
.justify
.fill
.PAGE
25.1 ^&Various "straight" examples\&
.skip 3
.index Example 1, Fourier expansion of square wave

^&Example 1\&
	We have now covered most of the details
necessary to use the Omnigraph routines.
A few examples are now in order.
	The first one is a program to show how the number
of terms in the Fourier expansion of a square wave affects
the display of the wave.  It uses two viewports, one
to show an entire cycle of the wave, and one to show
just the region near a sharp corner (see Figure 1).
The program is given in SAIL and FORTRAN.
.figure 27
.nofill
.nojustify

BEGIN "EXAMPLE -- 1: FOURIER EXPANSION OF SQUARE WAVE"
DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

	EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
	EIP DGET;

	EP  DOPEN (INTEGER N);
	EIP DPOST (INTEGER N);
	EP  DDONE;

	EP  DWIND (REAL L,R,B,T);
	EP  DPORT (REAL L,R,B,T);
	EIP DMOVE (REAL X1,Y1);
	EIP DDRAW (REAL X1,Y1);

	REQUIRE "SYS:DISSAI" LOAD!MODULE;


	INTEGER ARRAY D[1:1];
	INTEGER N,I; REAL X,Y;

	OUTSTR("DISPLAY NUMBER: ");
	DINI (CVD(INCHWL),10,D[1],0);
	DGET;

	WHILE TRUE DO BEGIN
		OUTSTR("HOW MANY TERMS? ");
		N<-CVD(INCHWL)*2+1;
		DOPEN (1);
		DWIND (0,2*3.14159,-1,1);
		DPORT (0,1,0,1);
		DMOVE (0,0);
		FOR X<-0 STEP .05 UNTIL 2*3.5 DO BEGIN
		Y<-0;
		FOR I<-1 STEP 2 UNTIL N DO Y<-Y+SIN(I*X)/I;
		DDRAW (X,Y);
		END;
		DWIND (0,.4,.7,1);
		DPORT (.7,1,.6,1);
		DMOVE (0,0);
		FOR X<-0 STEP .005 UNTIL .4 DO BEGIN
		Y<-0;
		FOR I<-1 STEP 2 UNTIL N DO Y<-Y+SIN(I*X)/I;
		DDRAW (X,Y);
		END;
		DPOST (1); DDONE;
	END;
END;

.fill
.justify
.TEST PAGE 20
.SKIP 2
.NOFILL
.NOJUSTIFY
C	EXAMPLE -- 1
	DIMENSION D(1)
	TYPE 1001
1001	FORMAT (' DISPLAY NUMBER: '/)
	ACCEPT 1002,NDIS
1002	FORMAT (I4)
	CALL DINI (NDIS,10,D,0)
	CALL DGET
C
10	TYPE 1003
1003	FORMAT (' HOW MANY TERMS? '/)
	ACCEPT 1002,N
	CALL DOPEN (1)
C  SHOW ONE PERIOD OF THE SQUARE WAVE (0 TO 2 PI)
	CALL DWIND (0,2*3.14159,-1,1)
	CALL DPORT (0,1,0,1)
	CALL DMOVE (0,0)
	X=0
11	IF (X .GE. 2*3.5) GO TO 16
	Y=0
	DO 15 I=1,N,2
15	Y=Y+SIN(I*X)/I
	CALL DDRAW (X,Y)
	X=X+.05
	GO TO 11
C  NOW THE SMALLER VIEWPORT INSET
16	CALL DWIND (0,.4,.7,1)
	CALL DPORT (.7,1,.6,1)
	CALL DMOVE (0,0)
	X=0
17	IF (X .GE. .4) GO TO 20
	Y=0
	DO 18 I=1,N,2
18	Y=Y+SIN(I*X)/I
	CALL DDRAW (X,Y)
	X=X+.005
	GO TO 17
20	CALL DPOST (1)
	CALL DDONE
	GO TO 10
C	THAT'S ALL
	END
.FILL
.JUSTIFY
.page
.index Example 2, Tick-tack-toe board
^&Example 2\&
	The following program will provide a board for tick-tack-toe
on any display served by the Omnigraph routines (see Figure 2).
.figure 27

.nofill
.nojustify

BEGIN "EXAMPLE -- 2: TICK-TACK-TOE"
DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

	EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
	EIP DGET;

	EP  DOPEN (INTEGER N);
	EP  DCLOSE;
	EIP DPOST (INTEGER N);
	EIP DUNPOST (INTEGER N);
	EP  DKILL (INTEGER N);
	EP  DDONE;

	EP  DWIND (REAL L,R,B,T);
	EP  DPORT (REAL L,R,B,T);
	EIP DMOVE (REAL X1,Y1);
	EIP DDRAW (REAL X1,Y1);
	EIP DVECT (REAL X1,Y1,X2,Y2);

	EP  DTSCAL (REAL S);
	EP  DTEXT (STRING S);

	REQUIRE "SYS:DISSAI" LOAD!MODULE;

	INTEGER ARRAY D[1:1];
	INTEGER ARRAY M[1:3,1:3];
	INTEGER I,J,MOVE,BR,N;

	OPEN (1,"TTY",0,1,1,200,BR,BR);
	OUTSTR("DISPLAY NUMBER: ");
	DINI (CVD(INCHWL),10,D[1],0);	DGET;
	DWIND (0,1,0,1);
	DPORT (0,1,0,1);

	DOPEN (1);
	  DMOVE (.1,.9); DTSCAL (.0244);
	  DTEXT ("X MOVES");
	DCLOSE;
	DOPEN (2);
	  DMOVE (.1,.9);
	  DTEXT ("O MOVES");
	DCLOSE;
	DOPEN (3);
	  DWIND (0,3,0,3); DPORT (.2,.8,.2,.8);
	  FOR I<-0 STEP 1 UNTIL 3 DO BEGIN
		DVECT (I,0,I,3);
		DVECT (0,I,3,I);
	  END;
	  DPOST (3);

	WHILE TRUE DO BEGIN "GAME"
		FOR I<-1 STEP 1 UNTIL 3 DO
		FOR J<-1 STEP 1 UNTIL 3 DO M[I,J]<-0;
		DWIND (0,3,0,3);
		DPORT (.2,.8,.2,.8);
		MOVE <- 1;

	FOR N<-1 STEP 1 UNTIL 9 DO BEGIN "MOVE"
		DPOST (MOVE); DDONE;
		I<-INTIN(1); J<-INTIN(1);
		DUNPOST (MOVE);
		IF M[I,J]=0 THEN M[I,J]<-MOVE ELSE MOVE<-3-MOVE;
		DOPEN (4);
		FOR I<-1 STEP 1 UNTIL 3 DO
		FOR J<-1 STEP 1 UNTIL 3 DO BEGIN
		  IF M[I,J]=1 THEN BEGIN
		    DVECT (I-.75,J-.75,I-.25,J-.25);
		    DVECT (I-.75,J-.25,I-.25,J-.75);
		  END ELSE
		  IF M[I,J]=2 THEN BEGIN
		    DMOVE (I-.75,J-.75);
		    DDRAW (I-.75,J-.25); DDRAW (I-.25,J-.25);
		    DDRAW (I-.25,J-.75); DDRAW (I-.75,J-.75);
		  END;
		END;
		DPOST (4);

		FOR I<-1 STEP 1 UNTIL 3 DO
		  IF MOVE=M[I,1]=M[I,2]=M[I,3] OR
		     MOVE=M[1,I]=M[2,I]=M[3,I] THEN I<-5;
		IF I=6 OR
		   MOVE=M[1,1]=M[2,2]=M[3,3] OR
		   MOVE=M[3,1]=M[2,2]=M[1,3] THEN DONE; "WINNER"

		MOVE<-3-MOVE;
	END "MOVE";
		DOPEN (5);
		DWIND (0,1,0,1);
		DPORT (0,1,0,1);
		DMOVE (.1,.9);
		DTEXT ((IF MOVE=1 THEN "X" ELSE "O")<-_&" WINS");
		DPOST (5); DDONE;

		CALL (1,"SLEEP");
		DKILL (4); DKILL (5);
	END "GAME";

END


.fill
.justify

.PAGE
.index Example 3, 3-dimensional function
^&Example 3\&
	The following  example is a simple way of displaying a
'three-dimensional' function (see Figure 3).  This method does not use true
perspective techniques such as those described later on,
but merely gives an impression of depth.
.figure 30
	We wish to 'plot' a function z#=#f(x,y).
We shall let the x axis be horizontal, the z axis vertical,
and the y axis point into the screen.  We achieve the
three-dimensional effect by the following computation for
the screen position of a three-dimensional point (x,y,z):
.nojustify
.nofill

	Xscreen = x + y cos alpha
	Yscreen = z + y sin alpha

.justify
.fill
where the angle alpha is shown in Figure 4.  
.FIGURE 24
The function we shall plot is 
.nojustify
.nofill

		       y x
	      z = x  e

.justify
.fill
We shall store in 6 variables, Xmin, Xmax, Ymin, Ymax,
and Zmin, Zmax the ranges of the values on the coordinate
axes.

.nofill
.nojustify

BEGIN "EXAMPLE -- 3: THREE-DIMENSIONAL FUNCTION"
DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

	EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
	EIP DGET;

	EP  DOPEN (INTEGER N);
	EIP DPOST (INTEGER N);
	EP  DDONE;

	EP  DWIND (REAL L,R,B,T);
	EP  DPORT (REAL L,R,B,T);
	EIP DMOVE (REAL X1,Y1);
	EIP DDRAW (REAL X1,Y1);

	REQUIRE "SYS:DISSAI" LOAD!MODULE;

REAL PROCEDURE F (REAL X,Y);
	RETURN (X* EXP (Y*X));

REAL X,Y,XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX,XSTEP,YSTEP;
INTEGER ARRAY D[1:1];
DEFINE ALPHA="30";

PROCEDURE T (REAL X,Y,Z; INTEGER I);
  BEGIN "DO THE TRANSFORMATION AND DISPLAY"
    X <- (X-XMIN)/(XMAX-XMIN);
    Y <- (Y-YMIN)/(YMAX-YMIN);
    Z <- (Z-ZMIN)/(ZMAX-ZMIN);

    X <- X + Y* COSD(ALPHA);
    Y <- Z + Y* SIND(ALPHA);

    IF I THEN DDRAW (X,Y) ELSE DMOVE (X,Y);
  END;


DINI (CVD(INCHWL),10,D[1],0);
DGET; 
DWIND (0,1+COSD(ALPHA),0,1+SIND(ALPHA));
DPORT (0,1,0,1);

"NOW DRAW AXES"
  XMIN<-0;  XMAX<-3;
  YMIN<--2; YMAX<-0;
  ZMIN<-0;  ZMAX<-2;


DOPEN (1);
T (XMAX,YMIN,ZMIN,0);
T (XMIN,YMIN,ZMIN,1);
T (XMIN,YMAX,ZMIN,1);
T (XMIN,YMIN,ZMIN,0);
T (XMIN,YMIN,ZMAX,1);

"NOW PLOT THE FUNCTION"

XSTEP <- (XMAX-XMIN)/20;
YSTEP <- (YMAX-YMIN)/10;

FOR Y <- YMIN STEP YSTEP UNTIL YMAX DO
FOR X <- XMIN STEP XSTEP UNTIL XMAX DO
   T (X,Y,F(X,Y), IF X=XMIN THEN 0 ELSE 1);

DPOST (1); DDONE;
INCHWL;  "WAIT -- LET HIM SEE PICTURE"

END;

.fill
.justify






.page
The material from this point on covers 'advanced' topics:
two-dimensional coordinate transformations such as rotation,
scaling and translation; three-dimensional transformations
and perspective.  This information is not essential for
elementary use of the Omnigraph routines.
.skip 2
.index Matrix transformations
.index Transformations
.index Scaling
.index Translating
.index Rotating
25.2. ^&Matrix Transformations\&
	The Omnigraph routines provide a mechanism for transforming
page coordinates prior to the final windowing operation.  The operations
of scaling, rotating, and translating can all be performed,
although the method is not limited to these
transformations.
	Let us write mathematical expressions for these
three fundamental operations.  A point (x,y) is transformed
to a new point (x',y') as follows:
.nojustify
.nofill

	^&Scaling\&

		x' = x <x-scale>

		y' = y <y-scale>

	^&Translating\&

		x' = x + <x-translation>

		y' = y + <y-translation>

	^&Rotating about the origin\&

		x' = x cos <angle> - y sin <angle>

		y' = x sin <angle> + y cos <angle>

.justify
.fill
The quantities given inside angle brackets (<>) are parameters
of the transformations.
	All of these transformations may be expressed in
a uniform way as matrices in the following equation:
.nojustify
.nofill

  [ x  y  1 ]     -  -  0    = [ x'  y'  1 ]
		  -  -  0
		  -  -  1

.justify
.fill
The '-' symbols are numbers which vary from transformation to transformation.
The 3x3 matrix is often called the 'transformation matrix', because
its 9 numbers completely specify the transformation.
The notation for a matrix element is: matrix-name#[#row-number#,#column-number#].
	We use 3x3 matrices for two-dimensional vectors (and add
the third component of 1 to each two-dimensional vector) because
this "jump into the next higher dimensional space" permits the
convenient handling of translations as linear transformations.
Otherwise translations would be a special non-linear transformation.
	If you have forgotten how to multiply a vector by
a matrix, consider the following helpful method: turn the
vector on end as follows:
.nojustify
.nofill

		x   -  -  0
		y   -  -  0
		1   -  -  1

.justify
.fill
Now multiply each vector element through each column of the row
it is in:
.nojustify
.nofill

		x*-  x*-  x*0
		y*-  y*-  y*0
		1*-  1*-  1*1

.justify
.fill
And finally, add up the columns:
.nojustify
.nofill

		x*-  x*-  x*0
		y*-  y*-  y*0
		1*-  1*-  1*1
	     -------------------
		xx    xx   1

.justify
.fill
These three numbers are the new vector.  Examples:
.nojustify
.nofill

	[ 2 3 1 ]   1  0  0   = [ 2 3 1 ]
		    0  1  0
		    0  0  1

	[ 3 2 1 ]   0  1  0   = [-2 3 1 ]
		   -1  0  0
		    0  0  1

	[ 2 4 1 ]   0 -2  0   = [ 4 0 1 ]
		    0  1  0
		    4  0  1

.justify
.fill
The three kinds of transformations can be expressed in matrix form
as follows:
.nojustify
.nofill

		<x-scale>        0            0
		    0        <y-scale>        0
		    0            0            1


		    1            0            0
		    0            1            0
		 <x-tran>     <y-tran>        1


		cos <angle>  sin <angle>      0
		-sin <angle> cos <angle>      0
		    0            0            1

.justify
.fill
The Omnigraph routines allow such a matrix transformation to be applied to
each point given in the 'move' or 'draw' commands
(DMOVE, DDRAW, etc.).  The default transformation is the
identity.  In fact, the matrix is 4x4 in order to permit
three-dimensional transformations, as described below.
The 4x4 is created from the 3x3 by adding a row and a column,
indicated by underlined zeroes:
.nojustify
.nofill

    [ x  y  &0  1 ]    -  -  &0  0    = [ x'  y'  &0  1 ]
		      -  -  &0  0
		      &0  &0  &0  &0
		      -  -  &0  1

.justify
.fill
(In fact, for two-dimensional transformations, it does not matter
what values are placed in the third row and third column of
this matrix.)  The call DAPPLY specifies the transformation
to the Omnigraph routines:
.nojustify
.nofill

	DAPPLY ( array, name )

.justify
.fill
('name' is described in the Reference Manual, and should be
zero here.)
As an example, the following program shows a square rotated by various amounts:
.nofill
.nojustify

BEGIN "SQUARE EXAMPLE"
DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
EIP DGET;

EP  DOPEN (INTEGER N);
EIP DPOST (INTEGER N);
EP  DDONE;

EP  DAPPLY (REFERENCE REAL AR; INTEGER NAME);

EP  DWIND (REAL L,R,B,T);
EIP DMOVE (REAL X1,Y1);
EIP DDRAW (REAL X1,Y1);

REQUIRE  "SYS:DISSAI" LOAD!MODULE;

REAL ARRAY M[1:4,1:4];
REAL ANGLE; INTEGER ARRAY D[1:1];

DINI (0,10,D[1],0);	"DEC340 DISPLAY"
DGET;
WHILE TRUE DO BEGIN
   OUTSTR("ANGLE: ");
   ANGLE<-CVD(INCHWL);
   M[1,1]<-M[2,2]<-COSD(ANGLE);
   M[2,1]<--(M[1,2]<-SIND(ANGLE));
   M[4,4]<-1;

   DAPPLY (M[1,1],0);  "GIVE M'S VALUES TO Omnigraph ROUTINES"
   DWIND (-4,4,-4,4);  "AND SET UP WINDOW-- VIEWPORT
			WILL BE THE WHOLE SCREEN"
   DOPEN (1);	       "START GENERATING PICTURE"
   DMOVE (-1,-1);
   DDRAW (-1,1); DDRAW (1,1); DDRAW (1,-1); DDRAW (-1,-1);
		       "SHOW THE SQUARE -- ALL POINTS
		        WILL BE TRANSFORMED AND CLIPPED"
   DPOST (1); DDONE;
END;
END;

.fill
.justify
Very often we wish to apply a sequence of such transformations
to a point.  Suppose we wish to display four squares, each
rotated a different amount, at four different places on the
screen.
The transformations might be expressed as:
.nojustify
.nofill

	1. Get a vertex of the square
	2. Rotate it the correct amount (angle1)
	3. Translate it to the desired position (xtran1,ytran1)
	4. Clip against the window and display the result
    -- repeat steps 1 through 4 for all vertices of the square

	5. Get a vertex of the square
	6. Rotate it by angle2
	7. Translate with xtran2, ytran2
	8. Clip and display
    -- repeat steps 5 through 8 for all vertices of the square

    -- etc.

.justify
.fill
The two transformations (rotation, translation) can be expressed in
matrix notation as:
.nojustify
.nofill

  [ x  y  0  1 ]    cos a  sin a   0    0   = [ x'  y'  0  1 ]
		   -sin a  cos a   0    0
		      0      0     0    0
		      0      0     0    1

.justify
.fill
.nojustify
.nofill
  [ x' y' 0  1 ]    1    0    0    0   = [ x"  y"  0  1 ]
		    0    1    0    0
		    0    0    0    0
		    xt   yt   0    1

.justify
.fill
These can be combined to read:
.nojustify
.nofill

[ x y 0 1 ]  cos a sin a 0  0    1   0   0  0  = [ x" y" 0 1 ]
	    -sin a cos a 0  0    0   1   0  0
	       0     0   0  0    0   0   0  0
	       0     0   0  1    xt  yt  0  1

.justify
.fill
In fact, the two matrices can be multiplied together to
form one which represents the same transformation as the
sequence of two!  This ^&concatenation\& can be repeated
any number of times.  The result is that the Omnigraph routines
can perform any sequence of matrix transformations merely by
applying ^&one\& suitably-chosen matrix to every input point.
	Five Omnigraph routine calls are used to control the transformation
sequence.
The 'name' parameter in all of these calls should be zero for
our present purposes (see section 1.12 of the Reference Manual
for a description of the name parameter).
.skip 1
.left margin 6
.index DAPPLY
.indent -6
DAPPLY ( matrix, name )
.break
Copy the 16 elements of the matrix into the current
transformation matrix.  (The way of giving the 'matrix' argument
varies slightly among programming languages: in SAIL,
you must give the first matrix-element, e.g. M[1,1];
in FORTRAN, the array name itself suffices.)
.skip 1
.index DCOMPOSE
.indent -6
DCOMPOSE ( new-matrix, name )
.break
Multiply the new-matrix by the current transformation matrix 
on the right and
leave the result in the current transformation matrix
( current#<-#new*current ).
.skip 1
.index DRCOMPOSE
.indent -6
DRCOMPOSE ( new-matrix, name )
.break
Multiply the current transformation matrix on the right by the
new-matrix and leave the result as the current transformation
matrix (current#<-#current*new).
.skip 1
.index DPUSH
.indent -6
DPUSH ( name )
.break
Push a ^&copy\& of the current transformation matrix onto 
the transformation  push-down
stack.
.skip 1
.index DPOP
.indent -6
DPOP ( name )
.break
Load the current transformation matrix to be the matrix at the
top of the stack.  Then pop the stack, i.e. discard the entry
at the top of the stack.
.left margin 0
.skip 1
The stack is used for saving and restoring transformations.
It is conceptually loaded with an infinite number of identity
matrices, I. The current transformation is also initialized
as an identity matrix.
.skip 1
To clarify the stack operation, consider the following before-after
comparisons:

.nojustify
.nofill
			^&Before		Operation	After\&

current transformation:	  I		 DAPPLY(C)	  C
stack:			  I,...				  I,...


current transform:	  C		 DPUSH		  C
stack:			  I,...				  C,I,...


current transform:	  B		 DPUSH		  B
stack:			  C,I,...			  B,C,I,...


current transform:	  A		 DPOP		  B
stack:			  B,C,I,...			  C,I,...


current transform:	  B		 DPOP		  C
stack:			  C,I,...			  I,...


current transform:	  C		 DPOP		  I
stack:			  I,...				  I,...

.justify
.fill
.page
.index Example 4, rotated squares
.index Matrix transformation, example program
^&Example 4\&
	As an example of these matrix transformation operations, consider the following program
which displays rotated squares at various spots on the screen
(we described this problem above).  In addition, the
user can control the scale of the whole picture
(see Figures T-5a and T-5b).
.figure 30
.nofill
.nojustify

BEGIN "EXAMPLE -- 4: ROTATED SQUARES"
DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
EIP DGET;

EP  DOPEN (INTEGER N);
EIP DPOST (INTEGER N);
EP  DDONE;

EP  DWIND (REAL L,R,B,T);
EIP DMOVE (REAL X1,Y1);
EIP DDRAW (REAL X1,Y1);

EP  DPUSH (INTEGER NAME);
EP  DPOP  (INTEGER NAME);
EP  DAPPLY (REFERENCE REAL AR; INTEGER NAME);
EP  DCOMPOSE (REFERENCE REAL AR; INTEGER NAME);

REQUIRE  "SYS:DISSAI" LOAD!MODULE;

REAL ARRAY M,IDENTITY[1:4,1:4];
INTEGER I; INTEGER ARRAY D[1:1];

FOR I<-1 STEP 1 UNTIL 4 DO IDENTITY[I,I]<-1;
			"THIS SETS UP AN IDENTITY TRANSFORM"
DINI (0,10,D[1],0); 	"DEC340 WITH SECOND SEGMENT"
DGET;
DWIND (-100,100,-100,100);   "SET WINDOW -- USE FULL SCREEN
			      FOR VIEWPORT"
WHILE TRUE DO BEGIN
  PROCEDURE SQUARE (REAL X,Y,ANGLE);
    BEGIN "SHOW A SQUARE AT X,Y ROTATED BY 'ANGLE'"
	DPUSH (0);	     "SAVE PRESENT TRANSFORM"
	ARRTRAN (M,IDENTITY); "COPY IDENTITY INTO M"
	M[4,1]<-X; M[4,2]<-Y;   "SET UP TRANSLATION"
	DCOMPOSE (M[1,1],0);
	ARRTRAN (M,IDENTITY);
	M[1,1]<-M[2,2]<-COSD(ANGLE);
	M[2,1]<--(M[1,2]<-SIND(ANGLE));
	DCOMPOSE (M[1,1],0);  "AND NOW INCLUDE ROTATION"
	DMOVE (-1,-1);
	DDRAW (-1,1); DDRAW (1,1); DDRAW (1,-1); DDRAW (-1,-1);

	DPOP (0);	      "RESTORE OLD TRANSFORMATION"
    END;

    OUTSTR("SCALE: ");
    ARRTRAN (M,IDENTITY);
    M[1,1]<-M[2,2]<- CVD(INCHWL)/100; "FILL IN SCALE"
    DAPPLY (M[1,1],0);	      "AND SET UP MATRIX"

    DOPEN (1);		      "START A PICTURE SEGMENT"
    SQUARE (4,4,15);
    SQUARE (4,0,90);
    SQUARE (4,-4,-15);
    SQUARE (-4,0,0);
    DPOST (1); DDONE;
END;
END;

.fill
.justify
As in the case of windowing, the management of the transformation
is independent of the management of segments; the
DAPPLY, DCOMPOSE, DPUSH or DPOP
calls may be given at any time.
	As another example, consider rotating an object about
an arbitrary point, not just about the origin.  We shall set
up a transformation to rotate points through an angle
&a about the point (X,Y).  First, we apply a translation
to map the point (X,Y) into the origin:
.nojustify
.nofill

   [ x  y  0  1 ]     1   0   0   0    = [ x' y' 0  1 ]
		      0   1   0   0
		      0   0   0   0
		     -X  -Y   0   1

.justify
.fill
Then we rotate about the origin through an angle &a:
.nojustify
.nofill

   [ x' y' 0  1 ]   cos &a  sin &a  0   0   = [ x" y" 0  1 ]
		   -sin &a  cos &a  0   0
		      0      0    0   0
		      0      0    0   1

.justify
.fill
An finally we map the origin back to the point (X,Y):
.nojustify
.nofill

   [ x" y" 0  1 ]     1   0   0   0    = [ x''' y''' 0  1 ]
		      0   1   0   0
		      0   0   0   0
		      X   Y   0   1

.justify
.fill
These matrices may of course all be multiplied together:
.nofill
.nojustify

[ x y 0 1 ]  1  0  0  0   cos sin 0  0   1  0  0  0
	     0  1  0  0  -sin cos 0  0   0  1  0  0
	     0  0  0  0    0   0  0  0   0  0  0  0
	    -X -Y  0  1    0   0  0  1   X  Y  0  1

.justify
.fill
.page
.index Example 5, rotated squares
.index Matrix transformation, example program
^&Example 5\&
	As an example, we will modify the procedure 'square' above to
rotate our standard origin-centered square through an angle 'angle'
^&about\& the point x,y (see Figure 6).
.figure 21
.nofill
.nojustify

PROCEDURE SQUARE (REAL X,Y,ANGLE);
  BEGIN
    DPUSH (0);			"SAVE OLD TRANSFORMATION"
    ARRTRAN (M,IDENTITY);	"COPY IDENTITY INTO M"
    M[4,1]<-X; M[4,2]<-Y;
    DCOMPOSE (M[1,1],0);	"THIS IS FIRST MATRIX"
    ARRTRAN (M,IDENTITY);
    M[1,1]<-M[2,2]<-COSD(ANGLE);
    M[2,1]<--(M[1,2]<-SIND(ANGLE));
    DCOMPOSE (M[1,1],0);	"THIS IS THE SECOND"
    ARRTRAN (M,IDENTITY);
    M[4,1]<--X; M[4,2]<--Y;
    DCOMPOSE (M[1,1],0);	"THIS IS THE THIRD"

    DMOVE (-1,-1);		"NOW OUR GOOD OLD SQUARE"
    DDRAW (-1,1); DDRAW (1,1); DDRAW (1,-1); DDRAW (-1,-1);
    DPOP (0);			"AND RESTORE OLD TRANSFORM"
  END;

.FILL
.JUSTIFY

.PAGE
.index Three-dimensional display
^&Three-Dimensional Displays\&
	The Omnigraph routines provide a facility for creating
perspective line-drawings of three-dimensional objects
(see Figure 7).
This section describes the basic perspective transformation,
the rotation, scaling and translation transformations in
three dimensions, and the Omnigraph subroutines which aid
these computations.
.figure 27
	We shall assume that the object to be displayed can
be expressed as a collection of lines and/or points  in a three-dimensional
.index Object coordinate system
Cartesian coordinate system, called the ^&object coordinate
system\&.  We shall apply a coordinate transformation
&V (called the viewing transformation) to convert
measurements in the object coordinate system into measurements
.index Eye coordinate system
in the ^&eye coordinate system\& (the construction of
V will be described later).  The eye coordinate system can
be visualized as being fixed on the viewer's eye.  Figure 8
shows an object and the object coordinate system, together
with a viewpoint and the eye coordinate system.  The function
of V is to convert from the first coordinate system to the
second.  If the user decides to observe
the same scene from a different point, V will have to be altered.
.figure 27
	Once coordinates of points and lines are available
in eye coordinates, the perspective generation is easy.
Figure 9 shows how the eye coordinate system is related to
the display screen: the x and y axes are aligned with the x and y
axes of the screen, and z points away from the eye.
The rays from the eye through the four corners of the
.index Viewing pyramid
viewport define a ^&viewing pyramid\&.
.figure 15
	Any line or point
which lies within this pyramid will be visible within the
viewport.  The pyramid itself can be described by two angles,
alpha and beta, the vertex half-angles in x and y respectively.
That is, the visible volume in the eye coordinate system is:
.nojustify
.nofill

	-z tan alpha &< x &< z tan alpha

	-z tan beta  &< y &< z tan beta

.justify
.fill
or
.nojustify
.nofill

	   -z &< x cot alpha &< z

  	   -z &< y cot beta  &< z

.justify
.fill
.index Clipping, three-dimensional
A process called ^&three-dimensional pyramid clipping\& is invoked to
decide whether points lie within these bounds and to calculate
what portions of lines lie within these bounds.
	If a point or line falls within the pyramid, we must calculate
the location of its perspective image  on the display screen.  Figure 10 shows a view of
the y-z plane.  
.figure 21
	The image of point P is P'.  The y-coordinate
of P' can be calculated by observing that triangle OSP'
is similar to OQP, so
.nojustify
.nofill

	    y'             y
         --------   =   -------
	    OS             z

.justify
.fill
But OS#=#(viewport-height/2) cot beta.  Hence
.nojustify
.nofill

	      y cot beta      viewport-height
	y' =  ----------  *  -----------------
	          z                  2

.justify
.fill
Similarly,
.nojustify
.nofill

	      x cot alpha      viewport-width
	x' =  -----------  *  ----------------
	          z                  2

.justify
.fill
Notice that, since the x-to-y aspect ratio of the viewing
pyramid is (tan alpha):(tan beta), the x-to-y aspect ratio
of the viewport should be the same (viewport-width#:#viewport-height).
	The Omnigraph routines perform all phases of the clipping
and perspective transformations with the exception of the
multiplication by cot#alpha and cot#beta.  That is, if you
say
.nojustify
.nofill

	DDOT3 (X*cot(alpha),Y*cot(beta),z)

.justify
.fill
and if no matrix transformations are in effect,
the Omnigraph routines will clip the point against the viewing
pyramid; if the point lies within the visible volume, the
screen coordinates are computed using the viewport parameters
set by DPORT.
	However, the matrix transformation of coordinates, which
precedes the clipping and perspective calculations, can be used
to perform the cot#alpha and cot#beta multiplications.
The transformation we require is given as the 4x4 matrix P:
.nojustify
.nofill

 [ x y z 1 ]   cot alpha 0    0  0   =  [ x' y' z' 1 ]
	          0  cot beta 0  0
		  0      0    1  0
		  0      0    0  1

.justify
.fill
The matrix transformation capability of the Omnigraph routines can
be used for more than just specifying the viewing pyramid -- it
can be used to perform the viewing transformation V.
	The transformation V can be made up of a sequence of
simple transformations such as scaling, translation, and
rotation.  The scaling transformation is:
.nojustify
.nofill

 [ x y z 1 ]  <xscale>  0      0      0   =  [ x' y' z' 1 ]
	         0   <yscale>  0      0
		 0      0   <zscale>  0
		 0      0      0      1

.justify
.fill
which is a simple extension of the two-dimensional scaling matrix.
Translation can be performed with
.nojustify
.nofill

 [ x y z 1 ]     1      0      0      0   =  [ x' y' z' 1 ]
		 0      1      0      0
		 0      0      1      0
	      <xtran> <ytran> <ztran> 1

.justify
.fill
There are three elementary rotations of three-dimensional
coordinates.  First, rotation about the x-axis through an
angle &a.
.nojustify
.nofill

 [ x y z 1 ]     1      0      0      0   =  [ x' y' z' 1 ]
		 0   cos a  -sin a    0
		 0   sin a   cos a    0
		 0      0      0      1

.justify
.fill
Rotation about the y-axis through an angle &a:
.nojustify
.nofill

 [ x y z 1 ]   cos a    0   sin a     0
		 0      1      0      0
	      -sin a    0   cos a     0
		 0      0      0      1

.justify
.fill
Rotation about the z axis through an angle &a:
.nojustify
.nofill

 [ x y z 1 ]   cos a sin a     0      0
	      -sin a cos a     0      0
		 0      0      1      0
		 0      0      0      1

.justify
.fill
These matrix transformations can be passed to the Omnigraph
routines with the DAPPLY, DCOMPOSE, and DRCOMPOSE calls,
as described in the 2-D section above.  These matrices
may be multiplied together (concatenated) to form
a single matrix, just as with their 2-D counterparts.
	The 'move' and 'draw' repertoire for three
dimensional information is similar to the 2-D commands:
.nojustify
.nofill

	DDOT3  (x,y,z)
	DMOVE3 (x,y,z)
	DDRAW3 (x,y,z)
	DVECT3 (x1,y1,z1,x2,y2,z2)

.justify
.fill
These routines perform (1) a matrix transformation by the current
transformation matrix, (2) the three-dimensional clipping 
calculation, (3) the perspective and viewport calculations,
and (4) finally add instructions to the display file.
Note that the resulting instructions are strictly
two-dimensional lines; the perspective calculation transforms
3-space into 2-space.
.page
.index Example 6, 3-dimensional cube
.index Three dimensional display, example
^&Example 6\&
	Let us start with a ^&very\& simple example.  We shall define
a 2 by 2 cube centered about the origin of the object coordinate system,
and shall view the cube from the point (0,0,9) looking
toward the origin (Figure 11).
.figure 21
The following transformation V defines the view:
.nojustify
.nofill

 [ X Y Z 1 ]    1     0     0     0   = [ Xe Ye Ze 1 ]
		0     1     0     0
		0     0    -1     0
		0     0     9     1

.justify
.fill
This matrix transforms a point in object space (X,Y,Z) into
the corresponding point in the eye coordinate system (Xe,Ye,Ze).
Further, we shall use a viewing pyramid with alpha#=#beta#=#30 degrees.
.nojustify
.nofill

		cot 30  0     0     0
	P =	  0   cot 30  0     0
		  0     0     1     0
		  0     0     0     1

.justify
.fill
We shall apply the transformation V#P to each point before
it is clipped, perspective calculated, and displayed.
The resulting display is shown in Figure 12.
.figure 15
.nofill
.nojustify

BEGIN "EXAMPLE -- 6: SIMPLE PERSPECTIVE OF CUBE"
DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
EIP DGET;

EP  DOPEN (INTEGER N);
EIP DPOST (INTEGER N);
EP  DDONE;

EIP DMOVE3 (REAL X1,Y1,Z1);
EIP DDRAW3 (REAL X1,Y1,Z1);

EP  DPUSH (INTEGER NAME);
EP  DPOP  (INTEGER NAME);
EP  DAPPLY (REFERENCE REAL AR; INTEGER NAME);
EP  DCOMPOSE (REFERENCE REAL AR; INTEGER NAME);

REQUIRE  "SYS:DISSAI" LOAD!MODULE;

REAL ARRAY V,P,R,IDENTITY[1:4,1:4];
REAL X,Y,Z,ANGLE; INTEGER I;
INTEGER ARRAY D[1:1];

FOR I<-1 STEP 1 UNTIL 4 DO IDENTITY[I,I]<-1;
DINI (0,10,D[1],0);		"DEC 340 DISPLAY"
DGET;

ARRTRAN (P,IDENTITY);	"GENERATE PYRAMID-MATRIX"
P[1,1]<-P[2,2]<-COSD(30)/SIND(30);
DAPPLY (P[1,1],0);		"AND MAKE IT CURRENT TRANSFORM"
  
ARRTRAN (V,IDENTITY);	"GENERATE VIEWING TRANSFORM"
V[3,3]<--1; V[4,3]<-9;
DCOMPOSE (V[1,1],0);		"AND COMPOSE THE TRANSFORMS"
				"NOW POINTS WILL BE TRANSFORMED
				 BY V*P   "
BEGIN "CUBE"
DOPEN (1);
FOR Z<-1,-1 DO BEGIN
	DMOVE3 (-1,-1,Z);
	DDRAW3 (-1, 1,Z);
	DDRAW3 ( 1, 1,Z);
	DDRAW3 ( 1,-1,Z);
	DDRAW3 (-1,-1,Z);
END;
FOR X<--1,1 DO
FOR Y<--1,1 DO BEGIN
	DMOVE3 (X,Y,-1);
	DDRAW3 (X,Y, 1);
END;

DPOST (1); DDONE;
END "CUBE";

INCHWL;			"LOOK AT IT"

END;

.fill
.justify
We could change this program to make the cube rotate about its
y-axis by replacing the line above which reads 'BEGIN "CUBE"'
by:
.nojustify
.nofill

	ARRTRAN (R,IDENTITY);
	R[1,1]<-R[3,3]<-COSD(5);
	R[1,3]<--(R[3,1]<-SIND(5));
   WHILE TRUE DO BEGIN "CUBE"
	DCOMPOSE (R[1,1],0);

.fill
.justify
The matrix R is set up as a rotation matrix, which is
DCOMPOSEd with the current matrix every time through
the loop.  The transformation applied to the cube points is thus:
.nojustify
.nofill

		 n
		R  V P

.justify
.fill
where n is the number of times the loop has been executed.
This is actually a bad idea, because roundoff errors will
eventually make a very peculiar matrix.  A better scheme is as follows
(see Figure 13):
.figure 15
.nojustify
.nofill

	ARRTRAN (R,IDENTITY);
	ANGLE<-0;
    WHILE TRUE DO BEGIN "CUBE"
	DPUSH (0);	"SAVE TRANSFORMATION"
	R[1,1]<-R[3,3]<-COSD(ANGLE);
	R[1,3]<--(R[3,1]<-SIND(ANGLE));
	ANGLE<-ANGLE+5;
	DCOMPOSE (R[1,1],0);
	   ...
	   ...NOW DRAW CUBE
	   ...
	DPOP (0);
    END "CUBE";

.fill
.justify
We could, in fact, perform rotations about all three axes in order
to present ^&any\& view of the cube.
	The above example illustrates one strategy for viewing
three-dimensional objects; the strategy can be summarized as follows:
.skip 1
.left margin 6
.indent -3
1.#Position the object to be viewed near the origin of the
object coordinate system.
.skip 1
.indent -3
2.#Choose a viewing distance, and locate the viewpoint
at that distance from the origin along some convenient axis.
Use this information to generate the viewing transformation V.
.skip 1
.indent -3
3.#Choose a viewing angle for the pyramid.  Use this to
generate the matrix P.
.skip 1
.indent -3
4.#Use three orthogonal rotations Rx, Ry, and Rz to give
the desired view of the object.  These rotations are controlled
by the three angles of rotation; if the angles
change with time, the object will appear to 'tumble'.
.skip 1
.indent -3
5.#Set up the Omnigraph routines to transform each point on the
object by the transformation sequence:
.nojustify
.nofill

        Rx Ry Rz V P

.justify
.fill
The first three transformations rotate the object about the origin
of object space.  The fourth transforms points into the eye coordinate
system, and the fifth specifies the viewing pyramid.
.skip 1
.left margin 0
There are five parameters (the viewing distance, viewing
angle, and the three rotations) to this transformation scheme.
They may be specified by the user, or the program could attempt
to generate them.  The following notes clarify some points:
.skip 1
.left margin 6
.indent -3
1.#The viewing distance and viewing angles are, in some ways,
related.  If we move farther away from the object without narrowing
the viewing angle, the object will get smaller and smaller on the
screen.  If we wish the nominal size of the object to remain
fairly constant, we choose
.nojustify
.nofill

     <viewing-distance> * tan#<viewing-angle> = constant

.justify
.fill
.skip 1
.indent -3
2.#The viewing angle and viewing distance control the 'perspective'
of the scene.  Increasing the angle gives a 'wide angle' view
(Often, however, the viewing distance will have to be decreased
in order to make the object size reasonable -- see note 1).
Decreasing the angle gives a 'telephoto' effect.
.skip 1
.indent -3
3.#The requirement that the object be located near the origin
(number 1, above) is really needless.  We can add a translation
transformation O:
.nojustify
.nofill

      1     0     0     0
      0     1     0     0
      0     0     1     0
     -a    -b    -c     1

.justify
.fill
to the transformation sequence, making it:
.nojustify
.nofill

      O Rx Ry Rz V P

.justify
.fill
This will make the point (a,b,c) be the center of rotations.
.skip 1
.indent -3
4.#Notice that the 3-D clipping pyramid can
serve to select a small portion of an object for viewing.  This
is particularly useful when, say, displaying a molecule; the center
of attention might be a particular atom site, located at
(a,b,c).  The technique of note 3 can be used to center
that point in the viewing pyramid; then the viewing angle can be narrowed
(or the viewing distance decreased) to exclude any unwanted
portions of the molecule.
.skip 1
.left margin 0
.page
.index Example 7, 3-dimensional cube
.index Three dimensional display, example
^&Example 7\&
	We shall now illustrate a second, more complicated
strategy for viewing three-dimensional objects.  In the
method above, we placed the eye somewhat away from the
origin of object space (this is the viewing distance) and then
used transformations to 'rotate' the object about its origin
until we saw a useful view.  We could leave the object fixed,
and move the viewing position so that the view is acceptable.
Figure 8 shows such a viewing position; it is characterized
by 6 parameters: the x, y and z location of the eye
(measured in object space), and three direction cosines
which describe the direction the eye is pointed.
	Direction cosines may seem forbidding, but they are
really a very simple way of representing a vector, or
direction.
Suppose the direction cosines are Cx, Cy and Cz
and that the coordinates of the eye are (EYEx,#EYEy,#EYEz).
This simply means that points on the line from the viewpoint
along the viewing direction can be given by the parametric
equation:
.nojustify
.nofill

	x = EYEx + t Cx
	y = EYEy + t Cy
	z = EYEz + t Cz

.justify
.fill
where t is distance from the viewpoint.
Alternatively, we could write
.nojustify
.nofill

	x = EYEx + t cos Ax
	y = EYEy + t cos Ay
	z = EYEz + t cos Az

.justify
.fill
in which the A's are the angles between the viewing direction
and the coordinate axes.
	Example: we wish to establish a viewing position
at (3,4,5), and aim the view toward the origin (0,0,0).
The vector from the viewpoint to the origin is thus (-3,-4,-5).
The 'cosines' are computed by dividing these components by
the total length of the vector, SQRT(3*3+4*4+5*5)#=#5*SQRT(2).
Hence, the direction cosines are:
.nojustify
.nofill

	Cx = -3/10  SQRT(2)
	Cy = -4/10  SQRT(2)
	Cz = -5/10  SQRT(2)

.justify
.fill
	Now we are ready to compute the viewing transformation.
First, we translate points in object space in order to make the
viewpoint become the origin (Figure 14).  
.page
 ########
.page
Note that the
object coordinate system is right-handed.
.nojustify
.nofill

		1      0      0      0
	T =     0      1      0      0
		0      0      1      0
	      -EYEx  -EYEy  -EYEz    1

.justify
.fill
We shall call the ^&point\& (Cx,Cy,Cz) the 'cosines point' (see
The object of the next three transformations will be to point the
z-axis in that direction, i.e. to make the 'cosines point' become
the point (0,0,1).
	Next, we convert to a left-handed coordinate system, as
required by the Omnigraph routines (see Figure 15).
.nojustify
.nofill

		1      0      0      0
	L =     0      1      0      0
		0      0     -1      0
		0      0      0      1

.justify
.fill
The cosines point (Cx,Cy,Cz) is transformed by L into
(Cx,Cy,-Cz).  Now we rotate about the y axis
until the x-component of the cosines point becomes
0 (Figure 16).
.nojustify
.nofill

	       -Cz/s   0      Cx/s   0
	R1 =    0      1      0      0
	       -Cx/s   0     -Cz/s   0
		0      0      0      1

.justify
.fill
where s#=#SQRT#(Cx*Cx#+#Cz*Cz).  The cosines point
(Cx,Cy,-Cz) is transformed into (0,Cy,s).
	Now we rotate about the x axis until the y-component
of the cosines point becomes 0 (Figure 17):
.nojustify
.nofill

	        1      0      0      0
	R2 =    0      s      Cy     0
	        0     -Cy     s      0
		0      0      0      1

.justify
.fill
This finally transforms the cosines point (0,Cy,s) into (0,0,1).
The four transformations T#L#R1#R2 thus define the viewing
transformation V, the transformation which computes eye
coordinates from object coordinates.
	Lastly, we must apply the scaling transformation P to
define a viewing pyramid.  The complete transformation is thus:
.nojustify
.nofill

 [ x y z 1 ]  T L R1 R2 P  --> clip, perspective and display

.justify
.fill
Actually, we could insert another rotation transformation,
R3, to rotate about the z axis.  This would exhaust the
last degree of freedom in the transformation.
	The following program accepts a viewpoint and another point
to determine the viewing direction, and then displays our friendly
cube:
.nofill
.nojustify

BEGIN "EXAMPLE -- 7: CUBE; SECOND METHOD"
DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
EIP DGET;

EP  DOPEN (INTEGER N);
EIP DPOST (INTEGER N);
EP  DDONE;

EIP DMOVE3 (REAL X1,Y1,Z1);
EIP DDRAW3 (REAL X1,Y1,Z1);

EP  DPUSH (INTEGER NAME);
EP  DPOP  (INTEGER NAME);
EP  DAPPLY (REFERENCE REAL AR; INTEGER NAME);
EP  DCOMPOSE (REFERENCE REAL AR; INTEGER NAME);

REQUIRE  "SYS:DISSAI" LOAD!MODULE;

INTEGER B;
REAL EYEX,EYEY,EYEZ,CX,CY,CZ,T,X,Y,Z;
REAL ARRAY M,IDENTITY[1:4,1:4];
INTEGER ARRAY D[1:1];

OPEN (1,"TTY",0,1,1,200,B,B);
DINI (0,10,D[1],0);	"DEC 340 DISPLAY"
DGET;

FOR B<-1 STEP 1 UNTIL 4 DO IDENTITY[B,B]<-1;

WHILE TRUE DO BEGIN "VIEW"
   ARRTRAN (M,IDENTITY);  "MAKE 'P' MATRIX"
   M[1,1]<-M[2,2]<-COSD(30)/SIND(30);
   DAPPLY (M[1,1],0);     "MAKE IT THE CURRENT TRANSFORMATION"
   OUTSTR("VIEWPOINT: ");
   EYEX<-REALIN(1); EYEY<-REALIN(1); EYEZ<-REALIN(1);
   OUTSTR("ANOTHER POINT: ");
   CX<-REALIN(1)-EYEX; CY<-REALIN(1)-EYEY; CZ<-REALIN(1)-EYEZ;
   T<-SQRT(CX*CX+CY*CY+CZ*CZ);	"LENGTH OF VECTOR"
   CX<-CX/T; CY<-CY/T; CZ<-CZ/T;   "NORMALIZE COSINES"
   T<-SQRT (CX*CX+CZ*CZ);
   ARRTRAN (M,IDENTITY);   "NOW MAKE R2"
   M[2,2]<-M[3,3]<-T;
   M[3,2]<--(M[2,3]<-CY);
   DCOMPOSE (M[1,1],0);
   ARRTRAN (M,IDENTITY);   "NOW MAKE R1"
   M[1,1]<-M[3,3]<--CZ/T;
   M[3,1]<--(M[1,3]<-CX/T);
   DCOMPOSE (M[1,1],0);
   ARRTRAN (M,IDENTITY);   "NOW THE CONCATENATION OF T AND L"
   M[3,3]<--1;
   M[4,1]<--EYEX; M[4,2]<--EYEY; M[4,3]<-EYEZ;
   DCOMPOSE (M[1,1],0);    "THAT IS THE LAST OF THE XFORMS"

   BEGIN "CUBE"
   DOPEN (1);
   FOR Z<-1,-1 DO BEGIN
	DMOVE3 (-1,-1,Z);
	DDRAW3 (-1, 1,Z);
	DDRAW3 ( 1, 1,Z);
	DDRAW3 ( 1,-1,Z);
	DDRAW3 (-1,-1,Z);
   END;
   FOR X<--1,1 DO
   FOR Y<--1,1 DO BEGIN
	DMOVE3 (X,Y,-1);
	DDRAW3 (X,Y, 1);
   END;

   DPOST (1); DDONE;
   END "CUBE";

END "VIEW";

END;
.FILL
.JUSTIFY
	Figures 18, 19, and 20 were created with this example program.
The values for 'viewpoint' and 'other point' typed in are
as follows:
.nofill
.nojustify

	Figure		Viewpoint	Other point

	18		-3,1.5,2.5	  0,0,0
	19		.6,0,5		  .6,0,0
	20		-1.65,0,1.6	  0,0,0

.fill
.justify
.page
 #####
.page
	This brief introduction to three-dimensional graphics
does not do justice to the range of techniques available; nor does
it do justice to the complexity that accompanies much 3-D
display generation.  Getting familiar with coordinate transformations,
the technique of adjusting viewing distances and angles, etc.
are not easily-acquired skills.
.skip 2
.index Examples, source files for
^&A note about the examples\&
	Source files for the seven examples titled "EXAMPLE -- 1", etc.
are all available for your experimentation.  They are
stored in one text file, SYS:DISEXP.SAI.
Each example is on a separate 'page' of the file.
.page
####
.blank 15
.center
Blank page
.subtitle Omnigraph Reference Manual
.page
.center
Omnigraph Display Routines
.center

.center
Reference Manual
.center

.center
Table of Contents
.skip 2
.nojustify
.nofill

1.0	The Display-File Compiler
1.1	Free Storage
1.2	Notation
1.3	Initialization
1.4	Generating Pictures
1.5	Showing Pictures on the Display Screen
1.6	Deleting Pictures from the Display File
1.7	Updating the Display Screen
1.8	Generating lines
	1.8.1   Coordinate Transformation
	1.8.2   Windowing
	1.8.3   Two-Dimensional Points and Lines
	1.8.4   Three-Dimensional Points and Lines
1.9	Text Display
1.10	Intensity Control
1.11	Display Subroutines
1.12	Dynamic Three-Dimensional Displays
1.13	Input Facilities
1.14	Plotting
1.15	Miscellaneous Subroutines
1.16	Sequencing of Omnigraph Routine Calls
1.17	Technical Considerations

2.0	Language Considerations
2.1	SAIL
2.2	LISP
2.3	FORTRAN

3.0	Terminal Considerations
3.1	DEC340 Display
3.2	Computek 400 Terminal
3.3	Adage AGT-30 Display
3.4	ARDS Terminal
3.5	Tektronix 4010 Terminal
3.6	DEC GT40 Display

4.0	Error Reporting



.justify
.fill
.page
.index reference manual

	This document describes a  set of subroutines available on
the DECsystem-10 for creating graphic displays.  These routines are
called the "Omnigraph Display Routines", and have been designed so that
they may be used with three popular programming languages
(SAIL, LISP, FORTRAN), and with a variety
of different display terminals (DEC-340, Adage AGT-30,
Computek 400, ARDS, Tektronix 4010, and DEC GT40).  
	The description of the routines has three distinct sections.
The first is concerned with general concepts for creating,
modifying, and destroying pictures.  These concepts are
common to all programming languages and to all terminals
served by the routines.  The second section deals with
language dependencies: the precise usage of the routines
in LISP differs from that in SAIL, etc.
The third section deals with particular terminal dependencies:
certain aspects of the  terminals currently supported
are documented.
	The general approach of these routines is that they
should be able to handle all simple graphical chores, and
most complicated ones.  The desire to use the same general
framework to drive display devices of quite different character
has necessitated a compromise of some of the graphical
power of the fancier terminals.  For those who desire to
make extensive use of the subtleties, these routines are
occasionally inadequate.
	In addition, these routines do not impose (yea, permit)
any elaborate fixed structure on the picture images.  In some
graphical applications, the structure of the picture on the
display screen can be related to a data structure required
by the graphical program (e.g. a circuit diagram probably has
a data structure which details connections among components --
these connections are manifested as lines on the display
screen).  Display subroutines are often useful in these
circumstances to save space and to reflect the program
data structure in the display file itself.
These routines provide no aids to this process, because
subroutining interferes with windowing unless the display
terminal has windowing hardware.
.test page 10
.skip 2
1.0 ^&The Display-File Compiler\&
.index Display files
	These routines are properly called a display-file compiler.
They interpret subroutine calls from the user's program, and
create a file of display instructions.  This file is then
used to actually create an image on the terminal.  For example,
in the case of the DEC-340 display, the file is examined
by a hardware device, called the ^&display processor\&, which
is responsible for actually drawing lines, text characters, etc.
on the face of the screen.  In the case of a storage tube,
the file is transmitted to the terminal in the form of 
graphical orders, and lines and text are drawn in response to these
orders.
	The Omnigraph routines will interpret a variety of requests to
add graphical instructions to a display file.  For example,
the user may specify coordinates of points and lines in 
a two-dimensional coordinate system.  The coordinates are
(1) transformed by an arbitrary matrix transformation specified
by the user, (2) checked against the limits of a ^&window\& to
see what parts of the line specified should be visible, and
finally (3) instructions to draw the visible section of the
transformed line are added to the display file. 
Notice that the transformations are applied before
a display file is built.
The 
details of these three operations are described below.
.index Segmented display files
	The display-file itself is divided into ^&pictures\& or
^&segments\&.
Each picture is probably a logically separate part of the display.
Each picture is identified by an integer number supplied by
the user program.  For example, the display file might look like:
.nojustify
.nofill


		|-----------------------|
		|			|
		|      Picture 24	|
		|			|
		|-----------------------|
		|			|
		|      Picture 211	|
		|			|
		|-----------------------|
		|			|
		|      Picture 2	|
		|			|
		|-----------------------|
		|			|
		|    ...etc		|


.justify
.fill
Each picture is a list of display instructions: orders to draw
lines, to display points, or to show text characters.
The function of the display file compiler is to create and
manage these pictures.
	The existence of a picture in the display file
is not inextricably linked with its image on the display
screen.  Pictures may be created and not immediately displayed.
 A picture which is shown is called
^&posted\&; one which is not shown is ^&unposted\&.
The idea is that unposted pictures may be later
posted and thus become visible on the display screen.
We can thus avoid using the display file compiler to
regenerate the picture.
.test page 10
.skip 2
.index Free storage
1.1 ^&Free Storage\&
	The Omnigraph routines store the display file in a free storage
area specified by the programmer.  As the number of display
instructions in the display file grows, so will the
consumption of space in the free storage area.  In fact, the
demands for space to store picture information may exceed
the size of the free storage area.  What then?
The Omnigraph routines will, under certain circumstances, request more
core from the timesharing system in which to continue storing
picture data.
	The user may request that free-storage be handled
in one of two ways:
	(1) The user may specify a fixed array of core to be used
for all free-storage activities.  If the demands for space exceed
the size of the array, the Omnigraph routines can take no corrective
action (However, see section 4.0).
	(2) Alternatively, the user may specify that the Omnigraph
routines are to create a ^&second segment\& core area, and
use that piece of core exclusively for free-storage.
If expansion of that area is required, the Omnigraph routines will
issue the appropriate calls to the operating system to
request expansion.  Under most circumstances, the area can
expand, and display-file generation can proceed.  If, for any
reason, the second segment cannot expand, the Omnigraph routines
can take no corrective action (See section 4.0).
	Both mechanisms for free-storage management are provided
because: (1) some of the display terminals (e.g. the 340) require that 
a second segment be used to hold display files, and
(2) some users may wish to use the second segment facilities
of the operating system for other purposes, e.g. sharing
a common program or run-time system.
.test page 10
.skip 2
.index Notation for manual
1.2 ^&Notation\&
	In the description of the subroutine calls interpreted by
the Omnigraph routines, we shall adopt a common notation for describing
the subroutine name, its arguments, and its return values, if any.
These forms are neither SAIL, nor LISP, nor
FORTRAN, but a notation which will yield the correct
SAIL, LISP, or FORTRAN calling sequence
if interpreted appropriately.  The section on language
conventions describes these interpretations.
	A subroutine call looks like:
.nojustify
.nofill

	result <-  ^&name\& ( argument list )

.justify
.fill
The subroutine called ^&name\& is being described: it requires
a list of arguments, and may return a result.  For some subroutines, the
argument list or the result may be omitted.
	The argument list is composed of a list of 
specifications of the arguments, e.g.
.nojustify
.nofill

	( picture number [integer], size [real] )

.justify
.fill
Each argument is given a name for descriptive purposes, and
its type is given inside square brackets ([]).  Arguments
are separated by commas.  All arguments are mandatory (i.e.
if an argument is listed, it must be given in the subroutine call).
	The types are:
.nojustify
.nofill

	[integer]	integer value
	[real]		real value (floating point)
	[boolean]	either 'true' or 'false'
	[pointer]	address of an entity in core

.justify
.fill
If a result is returned, it is specified in a fashion similar
to an argument (i.e. descriptive name and type).
.test page 10
.skip 2
.index Omnigraph routines, initialization
.index Initialization or Omnigraph routines
.index DINI
1.3 ^&Initialization\&
	The most useful feature of these routines (and indeed, the
hardest feature to implement) is that the exact specification
of which display terminal is to be used can be deferred until
the program begins execution.
 A program may be loaded and 'SAVED' without
specifying which display terminal is to be used.
Then, when the Omnigraph routines are initialized, the routines for
driving the particular terminal desired are loaded into your
program and executed.
	The initialization of the routines is accomplished with
the following call:
.nojustify
.nofill

	success [boolean] <- ^&DINI\& ( display-number [integer],
				    I/O-channel-number [integer],
				    free-storage-area [pointer],
				    free-storage-size [integer] )

.justify
.fill
This call initializes the subroutine package for the correct display,
and initializes the free-storage area.  The display-number
argument specifies which display terminal is to be used.
The numbers corresponding to each display are listed below
with the terminal descriptions.
(DINI will also accept the SIXBIT name of the
display, as given in section 3, as an argument).
The Omnigraph routines ^&do not initialize the display hardware at this time\&,
but merely load in the subroutines for driving that terminal.
These routines are stored on the system area.
	The I/O-channel-number argument specifies the number
of an I/O channel (in the sense of I/O channels used
by DECsystem-10 user programs when communicating with the
timesharing system; a number between 0 and 15 decimal) which can be used
by the display routines if needed.  The exact use of this
channel varies from terminal to terminal, but it is certainly
used when creating plotter output.
	The free-storage-area argument points to an array of
core which will be used by the display routines as free-storage.
The free-storage-size argument is the total length of this array.
If the length is 0, then the display routines will create a
second segment core area, and use it for free storage, expanding
it as required.
	If a display file currently exists and (perhaps)
contains visible pictures, DINI will, with one exception,
destroy the display file and re-initialize the space
(see more details in section 1.17).
	The value returned by the initialization call specifies
whether the initialization was successful.  The possible
reasons for failure are (1) the free-storage-size was so small
that the routines could not adequately initialize the area, or
(2) the free-storage-size was 0, but the operating system could not
allocate 2048 words of core to the second segment.
Either of these circumstances will cause all subsequent subroutine
calls to give meaningless results.
.index DGET
	The subroutine call which actually seizes the display terminal
is:
.nojustify
.nofill

	SUCCESS [boolean] <- ^&DGET\&

.justify
.fill

The Omnigraph routines attempt to reserve the use of the display
terminal requested by the user in the DINI call.
If the terminal is available (i.e. not already seized by some
other user), the DGET call returns 'true', otherwise
'false'.  
	If the display can be seized, then any pictures which
are currently in the display file (and POSTed; see below) are
shown on the display screen.
.index DREL
	The display terminal may be released so that others
may seize it with the call:
.nojustify
.nofill

	^&DREL\&

.justify
.fill
This call always succeeds, and leaves the screen blank.
It has absolutely no effect on the display file itself, i.e.
the lists of display instructions still reside in the free-storage
area.  If, at some later time, DGET is used to seize the
display, any pictures still in the display file will be shown.
	For displays which also serve as the user's 'keyboard'
terminal, no other user can ever 'seize' the display.  In this
case, DREL only serves to inhibit picture transmission.

	Modifications to the display file may be made with
the subroutines listed below even if the display terminal
is not seized.  Thus, the terminal may need be seized only infrequently
in order to view the results of some long computation.
It is good practice to design your graphics programs to operate
in this fashion.  Contention for a particular sharable display terminal
such as the DEC-340 is then easily
resolved because users are utilizing the display terminals only
during the periods when they wish to look at the pictures, and
not during the periods when their programs are performing long
computations.
.test page 10
.skip 2
.index Generating pictures
1.4 ^&Generating Pictures\&
	Each picture in the display file is a separate entity,
identified by its ^&picture number\&.  The subroutines described
below are used for creating, modifying, and destroying pictures.
The general strategy is as follows: we shall declare our
intention to create a new picture by DOPENing
a picture, and specifying a number &n which will identify that
picture.  Then, we will issue a series of subroutine calls
which request that display instructions be added to the
list of instructions for this picture, e.g. lines, text,
points.  Each subroutine call will request that a particular
line, point, or text string be added to the picture.
After the last entry is made, we will DCLOSE the picture.
Now picture &n is complete, and becomes part of the display
file.
	The picture will not appear on the screen during the
process of generation.  Other Omnigraph routine calls are
required in order to post the picture
which has been generated.
	The actual subroutine calls to accomplish opening and
closing of pictures are:
.index DOPEN
.index DCLOSE
.nojustify
.nofill

	^&DOPEN\& ( picture-number [integer] )

	^&DCLOSE\&

.justify
.fill
Subroutine calls which add instructions to the display file
are only legal inside a DOPEN-DCLOSE sequence.
	The DOPEN-DCLOSE subroutines automatically
provide a double-buffering ability.  Consider the following
sequence:
.nojustify
.nofill

	DOPEN (21)
		...
		...calls which generate display file
		...instructions (period A)
		...
	DCLOSE
		...
		...other activities (period B)
		...
	DOPEN (21)
		...
		...calls which generate display file
		...instructions (period C)
		...
	DCLOSE
		...
		...other activities (period D)
		...

.justify
.fill
During period A, picture number 21 is being generated.
During period B, picture number 21 is part of the display
file because it has been fully generated (DOPENed and
DCLOSEd).  During period C, the first version of
picture 21 is still part of the display file, even though
a new version of picture 21 is being generated.  After
the new version is DCLOSEd (period D), the new
version becomes part of the display file and the old version is
deleted.
.index DAPPEND
	The DAPPEND call allows a user to ^&add\& display
file instructions to any picture already in existence.
The call is:
.nojustify
.nofill

	^&DAPPEND\& ( picture-number [integer] )

.justify
.fill
For example:
.nojustify
.nofill

	DOPEN (21)
		...
		...calls which generate display file
		...instructions (period A)
		...
	DCLOSE
		...
		...other activities (period B)
		...
	DAPPEND (21)
		...
		...calls which generate display file
		...instructions to be added to picture
		...number 21 (period C)
		...
	DCLOSE
		...
		...other activities (period D)
		...

.justify
.fill
During period C, subroutine calls generate a list of display
file instructions which will be added to picture 21.  When the
DCLOSE is given, the additions are actually made.  During
period D, picture number 21 will show the effects of
the instructions generated during period A and during
period C.








.test page 10
.skip 2
1.5 ^&Showing Pictures on the Display Screen\&
	The DOPEN-DCLOSE sequences listed above are
only used to create display file.  They do not control
the use to which that display file is put.  The
subroutines DPOST and DUNPOST are used to
add and delete pictures from the ^&display screen\&.
.index DPOST
.index DUNPOST
The calls are:
.nojustify
.nofill

  post-number [integer] <- ^&DPOST\& ( picture-number [integer] )

  post-number [integer] <- ^&DUNPOST\& ( picture-number [integer] )

.justify
.fill
The DPOST call adds the specified picture-number to the list
of pictures which should be displayed on the screen.
The DUNPOST call removes the specified picture-number
from the list of pictures currently displayed on the screen
(UNPOSTing an unknown or already unposted picture
causes no error message).
In either case, the value returned is the number of pictures
posted after the call is interpreted.
	Note that DPOST and DUNPOST may
not have an immediate effect on the displayed picture.
(see DDONE, below).
	As an added convenience, if DPOST is called
for a picture which is currently opened, a DCLOSE will
be automatically done.  Thus the sequence:
.nojustify
.nofill

	DOPEN (21)
		...
		...subroutine calls which add
		...to the display file
		...
	DCLOSE
	DPOST (21)

.justify
.fill
can be abbreviated:
.nojustify
.nofill

	DOPEN (21)
		...
		...subroutine calls which add
		...to the display file
		...
	DPOST (21)

.justify
.fill
.test page 10
.skip 2
.index DKILL
1.6 ^&Deleting Pictures from the Display File\&
	When the usefulness of a picture expires, it may
be deleted from the display file.  The space required to
store the display instructions can then be reused by subsequent
Omnigraph routine calls.  The deletion is accomplished with the call:
.nojustify
.nofill

	^&DKILL\& ( picture-number [integer] )

.justify
.fill
The appropriate picture will be deleted from the display file.
If the picture was POSTed at the time of the DKILL call,
it will be UNPOSTed first.
.test page 10
.skip 2
.index DDONE
1.7 ^&Updating the Display Screen\&
	The operations DPOST, DUNPOST, DKILL,
and DAPPEND all may cause changes to the visible display.
DPOST adds graphic information; DUNPOST and
DKILL remove it.  If we DAPPEND to a picture which
has previously been DPOSTed, then the effect of the append operation
will be to make more graphic items visible.
	On some display terminals, the display screen can be
changed very rapidly; in this case, the effect of the
DPOST, DUNPOST, DKILL or DAPPEND calls
will be immediately manifested on the screen.  However, for those
terminals which use storage-tubes of any variety,
updating the screen frequently can consume great quantities
of time. It would be preferable to update the screen ^&once\&
after each collection of changes (DPOSTs, DUNPOSTs,
etc.) is made.
	The call
.nojustify
.nofill

	^&DDONE\&

.justify
.fill
requests that the screen be updated. 
This may cause a preliminary  erasure of a storage-tube screen.
 For example, if the
graphics program accepts commands from the user's keyboard and
interprets them, possibly creating a new display, a DDONE
call should be performed after the interpretation of every
command.  If any display information is to be added to or deleted
from the display screen, the operations will be done at that time.
	Using storage tube terminals interactively is
inconvenient at best; the Omnigraph subroutines permit several
strategies which should help reduce the absurdly long times
required to update the screen with new displays.
The idea of the DDONE command is that it should
be issued once for every group of display modifications.
For example, suppose the user is prompted to type in a command.
The interpretation of that command may involve several
DOPENings and DCLOSings of pictures,
DPOSTs, etc.  However, we should delay actually
updating the screen (i.e. issuing the DDONE call)
until we are sure that the present rush of modifications
is terminated.  If we issue DDONE too often,
many screen erasures and redrawings will be required.
The most natural time to issue DDONE is when
the interpretation of the user's command is finished
and the program is about to prompt him for another.
.index DCURSOR
	There is an additional problem on display terminals which
are used for both graphical output (pictures, lines, etc.) and
for the echoing of text typed at the keyboard.  Most of these
terminals have 'cursors', which control the position at which text
will be added to the screen.  It is important, after each screen
update, that the text cursor be positioned so that text echoes
will be visible to the typer.  Furthermore, the position of
the text echo may be of some importance to the programmer.
The call
.nojustify
.nofill

	^&DCURSOR\& ( cursor-x [real],
		  cursor-y [real] )

.justify
.fill
tells the Omnigraph routines where to position the cursor at the conclusion
of the next DDONE operation. 
The x and y coordinates are
measured in the standard viewport coordinate system (see section 1.8.2).
The default position for the cursor is equivalent to
DCURSOR#(0,.95).
	The user can request that the cursor be positioned immediately,
rather than at the end of the next DDONE operation, by
specifying negative arguments to DCURSOR.
.test page 10
.skip 2
1.8 ^&Generating Lines\&
	This section describes subroutine calls used to add
instructions to draw lines to the the display file of the currently
DOPENed picture.  
The routines will draw lines from  two-dimensional descriptions
of the endpoints of the lines, or will draw perspective views
of lines from three-dimensional descriptions of the endpoints.
(If the display terminal has hardware for showing three-dimensional
pictures, as does the Adage AGT-30, the perspective generation
can be bypassed.  The three-dimensional information is then
delivered intact to the terminal, where appropriate views can
be generated; see section 1.12).
	The processing of a request to draw a line or point goes through
three separable operations:
.nojustify
.nofill

	1. Coordinate transformation
	2. Windowing (and perspective generation)
	3. Generating the display file instruction

.justify
.fill
These operations are described in the next sections.
.test page 10
.skip 2
.index Transformations
1.8.1 ^&Coordinate Transformation\&
	Each group of coordinates used to describe a point
or an endpoint of a line may be first transformed by
according to some parameters
given by your program.  The transformation is capable of
introducing rotation, scaling, and translation to your
coordinate values before being displayed.
The transformations for two and three dimensions can be
thought of as operations on the coordinate vectors:
.nojustify
.nofill

	[ x y ]     T   ==>  [ x' y' ]

	[ x y z ]   T   ==>  [ x' y' z' ]

.justify
.fill
	In practice, the transformation T is a 4x4 matrix
supplied by your program.  The transformations may thus
be accurately stated:
.nojustify
.nofill

     [ x  y  *  1 ]     -  -  -  -    ==>  [ x' y'  *  * ]
                        -  -  -  -
                        -  -  -  -
                        -  -  -  -

     [ x  y  z  1 ]     -  -  -  -    ==>  [ x' y' z'  * ]
                        -  -  -  -
                        -  -  -  -
                        -  -  -  -

.justify
.fill
The values (x,y,z) are those provided by the user; the
values (x',y',z') are the transformed counterparts of the
user's values.  The '*' entry in a vector means that that
position in the vector is unused.
The array of '-' symbols is the 4x4 matrix.
	The 4x4 transformation matrix can be used to
express any linear transformation of the x, y and z coordinate
values.  In the discussion which follows, M[i,j] is an element
of the transformation matrix: row i, column j.
	The identity transformation is simply
M[1,1]#=#M[2,2]#=#M[3,3]#=#M[4,4]#=#1.0, with all other elements equal
to zero.
The effect of the identity transformation is to leave the
coordinate values unchanged. 
When the Omnigraph routines are initialized, the transformation is
set to the identity.
	Translations can be achieved by modifying the
identity matrix with:
.nojustify
.nofill

	M[4,1] = x translation
	M[4,2] = y translation
	M[4,3] = z translation

.justify
.fill
You can easily verify that the transformation schemes given
above do actually cause the 'translation' values to be added
to the x, y, and z values supplied by the user.
	Simple rotations can be specified.  For example,
the rotation through an angle theta about the origin of a
two-dimensional domain is specified by the following
modifications to the identity matrix:
.nojustify
.nofill

	M[1,1] = M[2,2] = cos (theta)
	M[1,2] = sin (theta)
	M[2,1] = -sin (theta)

.justify
.fill
Three-dimensional rotations about coordinate axes are similar.
.index Concatenation, of transformations
	Simple 4x4 matrix transformations can be concatenated
to form more complicated transformations by matrix multiplication.
For example, if we wish to first rotate an object and then
translate it, we could express this sequence of transformations
as:
.nojustify
.nofill

	[ x1 y1 * 1 ] = [ x0 y0 * 1 ] M

followed by

	[ x' y' * * ] = [ x1 y1 * 1 ] N

.justify
.fill
The matrices M and N are simple rotation and translation
matrices respectively.  The two operations can be merged into
one as follows:
.nojustify
.nofill

	[ x' y' * * ] = [ x0 y0 * 1 ] M N

.justify
.fill
The two 4x4 matrices M and N can be multiplied together to
form one matrix Q, which has the effect of the combined transformations:
.nojustify
.nofill

	[ x' y' * * ] = [ x0 y0 * 1 ] Q

.justify
.fill
The full ramifications of this technique are very useful in
graphics applications.  References are given below to
literature about computer graphics which describes the
properties of this approach.
	Each point (x,y and possibly z) presented
to the Omnigraph routines is first transformed according to the
^&current\& 4x4 transformation matrix.  The current matrix
is established with the call:
.index DAPPLY
.nojustify
.nofill

	^&DAPPLY\& ( matrix [pointer], name [integer] )

.justify
.fill
This call provides the Omnigraph routines 
16 floating-point numbers which are loaded into the current
transformation matrix.
All subsequent points and lines will be subject to this transformation,
until the current transformation is changed.
The 'name' parameter should be zero for our purposes;
it is used for dynamic three-dimensional displays
(see section 1.12).
If the DAPPLY call is omitted in your display program,
the identity transformation will be assumed, since the current.
matrix is initialized as the identity.
	Note: the row/column conventions in the storage of the
matrix are identical to those of the programming language used.
M[i,j] refers to row i, column j regardless of the programming
language used -- the versions of the routines for the different
programming languages take account of the differing storage
schemes.
.index Concatenation, of transformations
	The usefulness of the matrix transformations is greatly
enchanced by being able to ^&concatenate\& two transformations into
one which has the same effect as the sequential application
of the two.
The call
.index DCOMPOSE
.nojustify
.nofill

	^&DCOMPOSE\& ( new-matrix [pointer], name [integer] )

.justify
.fill
causes the current transformation to be replaced by the
matrix product of new-matrix and the current transformation
matrix.
The order of multiplication is <new-matrix> * <current-matrix>.
If one wishes to reverse the order of multiplication (namely
<current-matrix> * <new-matrix>), call
.index DRCOMPOSE
.nojustify
.nofill

	^&DRCOMPOSE\& ( new-matrix [pointer], name [integer] )

.justify
.fill
DCOMPOSE is useful for structured pictures, while
DRCOMPOSE is useful for global incremental transformations.
.index DPUSH
	The 16 values of the current transformation 
can be 'pushed' and 'popped' from a stack provided by the 
Omnigraph routines.  The call
.nojustify
.nofill

	^&DPUSH\& ( name [integer] )

.justify
.fill
causes the current 16 values to be copied into a piece of
free-storage, and placed at the top of the ^&transformation
stack\&.
(Again, 'name' should be zero.)
The call
.index DPOP
.nojustify
.nofill

	^&DPOP\& ( name [integer] )

.justify
.fill
causes the 16 values on the top of the transformation stack
to be stored in the 16 locations of the current matrix;
then these 16 values are removed from the top of the stack.
If the stack is has no transformation present due to DPUSHing
and hence is putatively empty, then this operation results an identity
matrix being placed into the current transform matrix.
In order to determine the contents of the current transform
matrix, call
.index DCURRENT
.nojustify
.nofill

	^&DCURRENT\& ( matrix [pointer], name [integer] )

.justify
.fill
This will return a copy of the curret transform in the specified
array.  In order to completely purge the pushdown stack of
any transform matricies, call
.index DFLUSH
.nojustify
.nofill

	^&DFLUSH\&

.nojustify
.nofill
which has the effect of repetitively calling DPOP. The
current matrix transform becomes in an identity matrix.
Finally, use of the call
.index DVMULT
.nojustify
.nofill

	^&DVMULT\& (new-point [pointer], point [pointer] )

.justify
.fill
allows one to apply the current matrix transform to a
specified point, resulting in a new transformed point.
The point to be transformed in placed in a 3-element array
<point>, and the transformed point is returned in a
similar array <new-point>.
	Note: one can use DPUSH, DAPPLY, DCOMPOSE,
or DRCOMPOSE, DCURRENT or DVMULT, and DPOP
to do matrix multiplications quite unrelated to graphics
transformations.
.test page 10
.skip 2
.index Windowing transformation
1.8.2 ^&Windowing\&
	The windowing operation is applied to each line or
point before a display instruction is generated.  Windowing
is described in detail in several of the references; only a
short summary is given here.
	In two dimensions, the user may specify a rectangular window
which surrounds the area of the two-dimensional plane which 
should be visible on the display screen.  Lines and points
which lie partly or wholly within the specified window area
will be displayed; lines or portions of lines which do not
intersect the window area will not be displayed.  In Figure R-1,
the line A will be displayed; B will not; a portion of C will be displayed.
.index DWIND
	The window rectangle is aligned with the x-y coordinate
system in which lines and points are specified.  It can thus be
determined by four numbers: the left, right, bottom, and top of
the rectangle as measured in the page coordinate system (the
coordinate system used by the user in his
calls to have lines and points generated).
This coordinate system is Cartesian, but the actual size and
position of the system is immaterial: user's coordinates are
compared to the window edge coordinates to decide whether a
line is visible.  The call
.nojustify
.nofill

	^&DWIND\& ( left-edge [real], right-edge [real],
		bottom-edge [real], top-edge [real] )

.justify
.fill
specifies the window to be used when processing all subsequent 
requests to draw lines, points, or text in two dimensions.
	This window area can be mapped onto any rectangular area
of the display screen; it need not fill the screen.
.index Viewport
.index DPORT
The image of the window on the screen is called the ^&viewport\&,
and is specified in the call
.nojustify
.nofill

	^&DPORT\& ( left-edge [real], right-edge [real],
		bottom-edge [real], top-edge [real] )

.justify
.fill
For the purposes of the DPORT call, we establish a
^&standard viewport coordinate system\& which will be useful
for all types of display.  The coordinate system is as follows:
.nojustify
.nofill

	x-coordinate
		left edge of screen	 0.0
		right edge of screen	 1.0

	y-coordinate
		bottom edge of screen	 0.0
		top edge of screen	 1.0

.justify
.fill
	The standard viewport coordinate system is an attempt
at making most programs work correctly on most displays.
However, some displays do not have square screen areas.
For these displays, the conventions are as follows:
the area of the screen represented by the viewport
bounds (0,1,0,1) will be the largest ^&square\& area
that can be located on the screen.  The square area will
be positioned at the botton left-hand corner of the screen
(see Figure R-2).
If you wish to refer to areas outside this square area,
appropriate values outside the range 0 to 1 are permitted in the
DPORT call (see DENQ, below).
An empty viewport is perfectly legal.
	When the Omnigraph routines are first initialized, the
default values of the window and viewport edges are as if
the following calls were executed:
.nojustify
.nofill

		DWIND ( -1, 1, -1, 1 )
		DPORT (  0, 1,  0, 1 )

.justify
.fill
The region of the page bounded by x and y of plus/minus 1.0
will be mapped onto a square viewport on the screen.

.test page 10
.skip 2
1.8.3 ^&Two-Dimensional Points and Lines\&
	The following calls specify the generation of
points and lines in two dimensions:
.index DMOVE
.index DDRAW
.index DVECT
.index DDOT
.nojustify
.nofill

	in [integer] <- ^&DMOVE\& ( x1 [real], y1 [real] )
	in [integer] <- ^&DDRAW\& ( x2 [real], y2 [real] )
	in [integer] <- ^&DVECT\& ( x1 [real], y1 [real], 
			        x2 [real], y2 [real] )
	in [integer] <- ^&DDOT\&  ( x1 [real], y1 [real] )

.justify
.fill
	These subroutines can be viewed as manipulating a
fictional beam in the page coordinate system.
DMOVE moves the fictional beam to the specified
point without drawing a line.
DDRAW moves the fictional beam from its present position
to the specified point; if the fictional beam passes through
the window, a line-drawing instruction which will show
the visible part of the line will be added
to the display file.
DVECT#(x1,y1,x2,y2) is equivalent to the sequence
DMOVE#(x1,y1);#DDRAW#(x2,y2).  DDOT causes
a dot to be displayed at the specified point, provided it is
within the window.
	The value returned as a result of any of  the 4 calls
tells whether the object was within the window, and hence
displayed (true return), or did not result in any
display (false return).
	As an aid to making other decisions about the relation of
a display to the current window, the following call
.index DTEST2
.nojustify
.nofill

	code [integer] <- ^&DTEST2\& ( x [real], y [real] )

.justify
.fill
computes a code which tells whether the transform of the
point (x,y) is within the current window.  If the code
is 0, the point is within the window.  If the code is non-zero,
four of the bits of the code specify in which way the point
is outside the window:
.nojustify
.nofill

	0001 (octal)	x value is to the left of the window
	0010 (octal)	x value is to the right of the window
	0100 (octal)	y value is below the bottom of the window
	1000 (octal)	y value is above the top of the window

.justify
.fill
For example, the code 1001 (octal) means that the point
is above and to the left of the window.




.test page 10
.skip 2
1.8.4 ^&Three-Dimensional Points and Lines\&
.index Three-dimensional display
	Generation of perspective views of three-dimensional
objects can be accomplished with calls very similar to the
above two-dimensional calls:
.index DMOVE3
.index DDRAW3
.index DVECT3
.index DDOT3
.nojustify
.nofill

       in [integer] <- ^&DMOVE3\& ( x1 [real], y1 [real], z1 [real] )
       in [integer] <- ^&DDRAW3\& ( x2 [real], y2 [real], z2 [real] )
       in [integer] <- ^&DVECT3\& ( x1 [real], y1 [real], z1 [real],
                                x2 [real], y2 [real], z2 [real] )
       in [integer] <- ^&DDOT3\&  ( x1 [real], y1 [real], z1 [real] )

.justify
.fill

The interpretations of the various calls are analogous to those
for two dimensions; the fictional beam now moves in a space with
a three-dimensional Cartesian  coordinate system.
	The coordinates are transformed by the current transformation
matrix, and then clipped, unless otherwise specified
(see section 1.12). The clipping operation for three-dimensional
points is different from that for two-dimensional ones:
.index Viewing pyramid
a point must lie within a three-dimensional viewing pyramid
in order to be visible.  This pyramid is always shaped
as shown in Figure R-3.
The condition that a point lie within the pyramid is:
.nojustify
.nofill

		-z &< x &< z
and
		-z &< y &< z

.justify
.fill
The transformation matrix can be used to deform the desired
pyramid of vision into this 'standard' pyramid used for clipping.
	Any visible portion of a line is then subjected to the
following computation in order to compute a screen
location:
.nojustify
.nofill

screen x =  (x/z) * (viewportright - viewportleft)/2 + 
		    (viewportright + viewportleft)/2

screen y =  (y/z) * (viewporttop - viewportbottom)/2 +
		    (viewporttop + viewportbottom)/2

.justify
.fill

The division of x and y by z is the central operation in
the generation of a perspective display image.  The
viewport computations merely position the image on the screen
in some desired position.
	Notice that the coordinate system used in these computations
is a left-handed one: if you face the display screen, the
x axis points to the right (as does the x coordinate system on
the display), the y axis points up, and the z axis is directed
ahead, into the screen.  If the three-dimensional coordinates
of lines and points are in a right-handed system, the transformation
matrix can be used to convert it to a left-handed system
(merely setting M[3,3]#=#-1 will have the correct effect).
	A function is available for testing points to see if
they are inside the three-dimensional window.  This function
merely makes the tests described above.
.index DTEST3
.nojustify
.nofill

	code [integer] <- ^&DTEST3\& ( x [real], y [real], z [real] )

.justify
.fill
The value of the code returned is similar to that for the two-dimensional
case:
.nojustify
.nofill

	0001 (octal)	x < -z
	0010 (octal)	x >  z
	0100 (octal)	y < -z
	1000 (octal)	y >  z

.justify
.fill
.test page 10
.skip 2
.index Text display
1.9 ^&Text Display\&
	All of the terminals supported by these subroutines
have conventions for displaying text.  The Omnigraph routines transform
a request for text display into the form required by the
particular terminal.  Text display will therefore differ
from one terminal to another: some will not have lower-case
characters; some will not be able to vary the size of
characters at all; some will be able to vary the size only in
discrete steps.
	The call
.index DTSCAL
.nojustify
.nofill

	^&DTSCAL\& ( height [real] )

.justify
.fill
sets the character size desired.  The size is measured
in the same units used to specify the viewport.  For example,
if you desire characters 1/4 inch high on a screen which
is 10 inches high, the appropriate size is 1/4#*#(1/10)
or 0.025.
  The Omnigraph routines
will choose a size available on the terminal you are using
which corresponds most closely to the size you have specified.
The height setting remains in effect until set with another
DTSCAL call.  There is no default.
	The call
.index DTEXT
.nojustify
.nofill

	^&DTEXT\& ( character-string [text] )

.justify
.fill
is used to actually display text.  The exact format of this
call will vary for different programming languages.
	The Omnigraph routines will start displaying text at the
position of the fictional beam; the lower left-hand corner
of the first character will start where the fictional beam is.
  Thus, the DTEXT call will
usually be preceded by a DMOVE call (or whatever) to
position the fictional beam in the desired spot.
After each character is drawn, the beam is positioned to be
at the lower left-hand corner of the next character.
The Omnigraph routines will decide what part of the text
to display in one of two ways:
.skip 1
.left margin 6
.indent -3
1.#Display a character only if the entire
character lies within the window.
.skip 1
.indent -3
2.#Display a character regardless of whether
it lies in the window.
It will not be displayed if any part of the character
is off the display screen.
.left margin 0
.skip 1
The mode is determined by the ^&sign\& of the size parameter
last given to DTSCAL: if the size is positive or zero, mode 1
is used; otherwise mode 2.
Note that mode 2 may request text characters to be displayed which would
exceed the hardware limits of the screen; any such characters
are discarded.
	The characters may be windowed in the 2D sense or the 3D
sense, depending which type of call was last executed before
the DTEXT call.  In other words, if you are displaying
3D vectors, and call DTEXT, characters will
be windowed in three dimensions.  The width and height of the
character in the three-dimensional object coordinate system are
determined at the time of the DTEXT call; this determination
uses the current Z coordinate of the fictional beam
at the time of the call.
	The fictional beam position in two or three dimensions is remembered when
DTEXT is called.  This position is used as the left margin
whenever a carriage-return character is encountered in the
text to be displayed.
	For those who wish to position characters accurately
on the screen, several aids are provided.  The DENQ call
(see below) and figures listed with each terminal
provide information about the actual size of characters on the
screen.
Four numbers are given: the x and y sizes of the actual character,
and the x and y sizes of the 'box' in which that character
is drawn (see Figure R-4).
	Not all display terminals have the same character
repertoires.  The Omnigraph routines adopt several conventions
to facilitate character display on a variety of terminals:
(1) if the terminal has no lower case facility, lower case
characters will be converted to upper, (2) if a character
cannot be displayed on a terminal, a * is substituted.
In addition, the call
.index DCHAR
.nojustify
.nofill

	status [integer] <- ^&DCHAR\& ( character [integer] )

.justify
.fill
can be used to discover whether the terminal in use can
faithfully show the ASCII character whose code is
passed as an argument to DCHAR.  The function will
return 0 if there is no equivalent character that can
be displayed, -1 if the display can display the character
exactly, and 1 if it can display the character by
transliteration (e.g. lower case transliterated to
upper case).
.test page 10
.skip 2
.index Intensity control
.index Italics control for GT40
.index Line types, for GT40 and Adage AGT-30
1.10 ^&Intensity and Special Feature Control\&
	For those terminals which can draw lines of various
intensities, the call
.index DINT
.nojustify
.nofill

	^&DINT\& ( intensity [real] )

.justify
.fill
is provided.  This will set the intensity value for any
subsequent lines, points, and text.  The intensity is specified
in a standard range: 0 is the lowest intensity, 1 is the highest.
	Various displays provide facilities for
various special features, such as italics and dashed lines.
These features are controlled by the use of
.index DSTAT
.nojustify
.nofill

	^&DSTAT\& ( combination-of-flags [integer] )

.justify
.fill
where the single argument is an encoding of your desire to
turn on or off certain features.  The GT40 offers the greater
number of possibilities, while the Adage responds to a small
subset of these codes (all other possibilities are ignored).
In describing the coding scheme, remember that you are forming
a single signed integer by the addition of certain values.  The
sign is important in that a positive value implies "turn on", 
negative means "turn off", and the value 0 is used to reset to
the defaults.  The GT40 features are 
.nojustify
.nofill

	1	solid line (default)
	2	long dashed lines
	3	short dashed lines
	4	dot dashed lines
	8	blink (characters and lines)
	16	italics

.justify
.fill
For example, if one wishes to turn on blinking he would pass
a value of 8 to the DSTAT routine.  Later, if he wishes to turn
it off, he would then use an argument of -8.  If he is unsure
whether at some time blinking is in effect, but he is sure that
he wants it off, then he could pass 0, for the default is no-BLINKING
(and no italics as well).
Similarly, if one desires blinking, italics, and dot-dashed
lines, then pass 28 (4+8+16).  Now you can turn off italics and
not affect the blinking or line type by calling DSTAT(-16).
Note that since there are four line types, one can only reset to
solid.  That is, 11 (8+3) implies blinking and short dashes;
however -11 is interpreted as no-blinking and since a negative
component in the range 1-4 was implied, the line type is reset to
solid.
.skip 1
	The Adage only offers two line types (and no blinking
or italics feature).  Hence code 0 for default (solid), 1 for
solid (explicitly), and 2 for dashed.  Again, all other possibilities
would be ignored.

.test page 10
.skip 2
1.11 ^&Display Subroutines\&
	The Omnigraph display routines, as currently written, do not rule out
providing subroutine capabilities (e.g. SAIL display routines).
These may be added in the future.
The complication of display subroutines is that they interfere with
windowing: a particular subpicture will appear differently if drawn on
different parts of the screen because different parts of the
subpicture will be clipped.
.test page 10
.skip 2
1.12 ^&Dynamic Three-Dimensional Displays\&
.index Three-dimensional displays (dynamic)
	The Omnigraph routines include special features to take advantage
of display terminals which have hardware for performing
coordinate transformations, projective transformations,
and viewport transformations.  The procedure described
above for generating perspective displays is called
^&static\&: the transformations are all applied prior to
building the display file.  Thus the only way to alter such
a display is to regenerate segments of the display file,
perhaps using different transformations.
The ^&dynamic\& process, on the other hand, builds display
files which contain x, y and z coordinates ^&prior\& to
transformation -- the required transformations are performed by
special display hardware.  This process acquires a dynamic
character because altering the transformations will alter
the display without regenerating the display file.
	The ideal structure for the display file for dynamic
displays would include specifications for lines and points in three
dimensions, for applying, composing, pushing and popping transformations,
and for viewport limits.  The ideal structure is, however, unattainable
with any present-day display equipment, largely because of the
lack of floating-point hardware; at the very least, we must scale
every coordinate so that it lies within the limits of the
display's fixed-point number system.  The discussion below
presents the Omnigraph solution to this problem and to
others encountered when designing the driver for an Adage
AGT-30 graphics terminal.
For additional details, see the Omnigraph Display Routines --
Implementation Manual.
	The coordinates (x,#y,#z) passed 
via a DMOVE3, DDRAW3, DVECT3 or DDOT3 call 
to the Omnigraph routines for dynamic display
are transformed as follows:
.nojustify
.nofill

	            |
	S   W T     |       D    P
	            |
	'static'    |      'dynamic'
	transforms  |      transforms

.justify
.fill
S is called the 'static matrix transformation'; it is expressed
as one matrix, the current transformation matrix, just as
described above for static perspective generation.  W is a
'box clip' step which clips lines and points against a three-dimensional
box specified with an Omnigraph call, and T maps the box limits
into fixed-point numbers acceptable for the display hardware.
These first three transformations are performed before the display
file is built.
The display hardware applies one more transformation, the combination
D#P, to the display-file points as the display is refreshed.
In the case of the AGT-30, the x,y,z point which results from the 
transformation is projected orthographically onto the screen,
i.e. the displayed point is at (x,y).
	The hardware transformation D to be applied is computed as
the display is being refreshed.  Codes may be placed in the display
file which cause the 'current dynamic transformation' to be altered
just as Omnigraph calls cause the current static transformation
to be altered: applying or composing new matrices; pushing
the current matrix onto a stack; popping the stack into the current
matrix.  In order to alter the display image, we need only
alter the values of one of the matrices taking part in an
application or composition.  We shall permit such 'dynamic matrices'
to be given names, integer numbers, which can be used later on
to name a matrix to be altered.
	Matrices may be altered in two ways.  First, the Omnigraph
call DSETR will change values in any named dynamic matrix.  Thus the
graphics program can control the view of a three-dimensional
scene without regenerating the display file.  Second, the 
graphics terminal itself may provide commands which cause
matrices to be given new values specified by dial readings,
keyboard values, or constantly-changing values
(thus giving a 'tumbling' effect).  The AGT-30
software provides several commands of this sort; in addition some
commands affect the entire display, regardless of the
user's matrices.
	The foregoing discussion represents a somewhat simplified
view of the display process.  Let us describe in more detail
the operation of the Omnigraph routines and the AGT-30.
The transformation applied to a point is ^&precisely\&:
.nojustify
.nofill

                     |
    Sn ... S2 S1 W T | T'Dm T ... T'D2 T T'D1 T T'PA
                     |
                     |   dynamic transformation

.justify
.fill
The Si sequence of transformations is expressed as one matrix,
the product of all the Si.  This matrix is called the
'current static transformation'.  The box clip has already
been described.  T is a scaling and translation transformation
which maps the box limits into the AGT coordinate system:
coordinate values vary from -1 to +1.  The dynamic transform is one
matrix, composed from several entities:
.left margin 3
.skip 1
.indent -3
1.#A dynamic transformation sequence Dm#...#D2#D1 modified
by the Omnigraph routines to include the effect of the
transformation T (T' is the matrix inverse of T).  Thus
a floating-point matrix D, specified by an Omnigraph call,
is actually given to the Adage as T'DT.  The user of the
Omnigraph routines can thus ignore the fact that T has
been applied ^&before\& the Di; he should think of the
transformation of each point as being S#W#D#P#A.
.skip 1
This transformation sequence varies as the display file
is executed, i.e. 'apply matrix', 'compose matrix',
'push' and 'pop' commands in the display file will cause
this sequence to change.
.skip 1
.indent -3
2.#P is a transformation which establishes the viewport.
It is multiplied by T' in order to account for the scaling.
.skip 1
.indent -3
3.#A is a matrix controlled by the dials on the Adage.
If values in A change, the whole picture will appear to
rotate, translate, etc.  Thus, even if the Omnigraph
user provides no dynamic transformation D, the transformation
A can still be used to alter the view of the scene.
.skip 1
.left margin 0
Each of the matrices T'DiT, T'P, and A is constrained
to have values in the range -1 to 1.  If the dynamic matrices are
used solely to ^&rotate\& the image about the origin, this
constraint should not offer difficulties.
	The Omnigraph routines for controlling static and dynamic three-dimensional
display are listed below:
.left margin 6
.skip 1
.indent -6
DBYP ( n [integer] )
.break
This call is used to specify exactly now each point
presented to the Omnigraph routines (DMOVE3, DDRAW3,
DVECT3, DDOT3) is to be processed.  The default is the
static process: static transformation, pyramid clip, and perspective
divide, as described in section 1.8.  That default can be altered
by DBYP calls as follows:
.left margin 16
.indent -6
n#=-1#Set 'static processing' mode.  Static transformations,
pyramid clip, and perspective divide are the default operations.
These defaults may be overriden with further calls to
DBYP as described below.
.indent -6
n#=#1#Set 'dynamic processing' mode.  Static transformations,
box clip, the T transformation, and dynamic transformations are
the default operations.  These defaults can be overriden with further
calls to DBYP as described below.
.indent -6
n#=-2#Omit the box-clip step.
.indent -6
n#=#2#Enable the box-clip step.
.indent -6
n#=-3#Disable pyramid clipping and perspective division.
.indent -6
n#=#3#Enable pyramid clipping and perspective division.
If box clipping is also enabled, it is performed first.
.indent -6
n#=-4#Disables the use of T, i.e. sets T to the
identity matrix.
.indent -6
n#=#4#Enables use of T (see below).
.left margin 6
.skip 2
.indent -6
DWIND3 ( left [real], right [real], bottom [real], top [real],
.indent 3
zmin [real], zmax [real] )
.break
This call specifies the limits of the box to be used for the box clipping
step.  It thus gives minimum and maximum values that the x, y, and z
coordinates can assume.  If matrix T is enabled, it is
set to:
.nojustify
.nofill

      2
 -----------         0              0              0
 right-left         

                     2
      0         -----------         0              0
                top-bottom

                                    2
      0              0         -----------         0
                                zmax-zmin

 right+left     top+bottom      zmax+zmin
 ----------     ----------      ---------          1
 right-left     top-bottom      zmax-zmin

.justify
.fill
.skip 1
.indent -6
DPORT ( left [real], right [real], bottom [real], top [real] )
.break
This call is precisely as described in section 1.8.2.  It
defines the area of the screen in which the picture is to appear.
The matrix P is set to:
.nojustify
.nofill

 right-left       0            0            0
     0       top-bottom        0            0
     0            0            1            0
   left        bottom          0            1

.justify
.fill
.skip 1
.indent -6
DAPPLY ( new-matrix [pointer], name [integer] )
.break
^&Static processing\&: If static processing is in effect, or if the
terminal has no dynamic transformation capability, this
call has the effect described in section 1.8.1: the
new-matrix is loaded into the current static transformation.
.break
^&Dynamic processing\&: If dynamic processing is in effect,
the value of 'name' controls the use of new-matrix: if name#=-1, new-matrix
replaces the current static transformation, as above.  Otherwise,
a dynamic 'apply matrix' command, which references a copy
of new-matrix, is added to the display file.  If name is positive,
it is taken as the 'name' of the matrix.  (If a matrix of the same name
already exists, new-matrix will not supersede it.)  If the
transformation T is enabled, the matrix
which will actually be applied is T'DT, where D is new-matrix.
Warning: applying a dynamic matrix nullifies the effect
of T'PA; DCOMPOSE is preferred.
.skip 1
.indent -6
DCOMPOSE ( new-matrix [pointer], name [integer] )
.break
^&Static\&: This call has the effect described in section 1.8.1: the
product <new-matrix>#*#<current#static#matrix> replaces
the current static matrix.
.break
^&Dynamic\&: If name#=-1, the product <new-matrix>#*#<current#static#matrix>
replaces the current static matrix.  Otherwise, a dynamic
'compose matrix' command which references a copy of new-matrix
is added to the display file.  If name is positive, it defines
a name for the matrix.  (Again, if matrix T is enabled, the
matrix transmitted to the display terminal is really T'DT,
where D is new-matrix.)
.indent -6
.skip 1
DRCOMPOSE ( new-matrix [pointer], name [integer] )
.break
^&Static\&: This call has the effect described in section 1.8.1: the
product <current#static#matrix>#*#<new-matrix> replaces
the current static matrix.
.break
^&Dynamic\&: If name#=-1, the product <current#static#matrix>#*#<new-matrix>
replaces the current static matrix.  Otherwise, a dynamic
'compose matrix' command which references a copy of new-matrix
is added to the display file.  If name is positive, it defines
a name for the matrix.  (Again, if matrix T is enabled, the
matrix transmitted to the display terminal is really T'DT,
where D is new-matrix.)
.skip 1
.indent -6
DPUSH ( name [integer] )      
.INDENT -6
DPOP ( name [integer] )
.break
^&Static\&: The local stack is manipulated as required: DPUSH pushes
a copy of the current top transformation back onto the local stack.
DPOP pops the local stack.
.break
^&Dynamic\&: If name#=#-1, DPUSH and DPOP apply to the local stack.
Otherwise an appropriate 'push' or 'pop' command is added to the
display file.
The Adage maintains a transformation stack which is manipulated by
the display-file commands 
'push' and 'pop', just as the local stack is maintained in
the static protocol.  The current top of stack is the
transformation in force at any time.
	The stacks are both initialized with the identity
transformation: this initialization is performed in the Omnigraph
routines when they are loaded, and by the Adage each time
a new picture segment is refreshed.
If ever DPOP is applied to an empty stack, an error message
is issued and the request is ignored.
.skip 1
.indent -6
DSETR ( new-matrix [pointer], name [integer] )
.break
^&Static\&: this is a no-op.
.break
^&Dynamic\&: If name is positive, new-matrix replaces the previous
matrix with name 'name'.
(Again, if transformation T is enabled, T'DT is the actual matrix used for replacement,
where D is new-matrix.)
If no such matrix exists, an error message is issued and the
DSETR request is ignored.
.left margin 0

.test page 10
.skip 2
.index Input facilities
.index RAND Tablet
.index Grafacon
.index Function box
1.13 ^&Input Facilities\&
	Some of the terminals served by the Omnigraph routines
have hardware for inputting information to the program.  This
section describes two calls for utilizing that hardware.
Section 3 gives additional details about the input facilities
of each terminal.
	The input facilities are organized around ^&events\&.
The user may enable several different classes of input operations
to be reported.  The call
.index DEVENT
.nojustify
.nofill

	^&DEVENT\& (device [integer], op [integer], answer [pointer])

.justify
.fill
is used to control the recording and reporting of events.
	Events may be generated by two devices:
(1) a function key
is depressed by the user, (2) the tablet stylus is
raised after having been depressed, or (4) the tablet stylus
is depressed and has moved a little bit since the last event.
Notice that these devices are numbered as powers of 2, and
can therefore be combined.  For example, to enable
function key hits and tablet 'pushes,'  the 'device' parameter
would be 3 (=1+2).
	The 'op' argument specifies 
 combinations of the following:
(1) clear the list of incoming events, (2) enable the 'device' or devices
to report events to the list, and (4) wait for an event to
happen.  Notice that the numbers for these operations are
1, 2 and 4.  They may be combined: 5 (=4+1) means clear the
current list of events and then wait until an event happens.
	The general strategy for initializing input devices
is to enable appropriate devices and clear the event buffer.
Thereafter, events can be 'read' from the buffer, using
the 'wait' option if desired.  The enable option
should be used sparingly; it is only necessary when ^&changing\&
input devices.  It is a good practice never to clear the
event buffer (except initially); each event in the buffer
represents a user action which should be processed in some way
by the program.
	The DEVENT routine is also used to retrieve events
from the event buffer.
If an event has arrived, the DEVENT routine fills
the 'answer' array with information about the event.
Answer[1] contains the number of the 'device' which caused
the event (if it is 0, then no event is being reported).
The remainder of the 'answer' array depends on the type of
event being reported.  
	If the reported event is a key-hit, Answer[1]
is 1, and Answer[2] is the (floating-point) number of the
key which was depressed.
	If the reported event is due to the raising of the
tablet stylus, Answer[1] is 2, and Answer[2] and Answer[3]
contain the x and y coordinates of the pen when it was
raised.  The values for x and y are in the current page coordinate
system, i.e. they are in the same coordinate system as
is used when passing arguments to the two-dimensional
point and line-drawing subroutines.
	If the reported event is due to the motion of
the tablet stylus, Answer[1] is 4, and Answer[2] and
Answer[3] are loaded with the x and y page coordinate values
for the new stylus position.
	The input devices often have output counterparts,
e.g. a key stroke may want to be answered by turning off
a light under the key, etc.  The following function
controls the output effects of the tablet and keys:
.index DOUT
.nojustify
.nofill

	^&DOUT\& ( device [integer], op [integer] )

.justify
.fill
The DOUT call with device#=#1 can be used to turn a light on by
giving in 'op' the number of the light (same numbering system as
that for keys) or to turn a light off by giving the negative
number of the light.
DOUT#(1,0) turns all lights off.
.index Inking
	The DOUT call with device#=#2 is used to control
the tablet.
If 'op' is positive, a trail of ink on the display
will follow the path of the stylus whenever the stylus is
depressed. In addition, a dot will follow the path of the
stylus, whether it is depressed or not.
If 'op' is zero, the ink is disabled, but the dot will still follow the
stylus.  This is the default that exists if no DOUT (2,x) is performed.
If 'op' is -1, ink and dot are disabled and erased.
The DOUT#(2,x) call may be repeated.  In particular,
it is used to erase from the screen any ink left
over from previous tablet input.
A positive value of 'x' passed to DOUT specifies (approximately)
how long the maximum ink trace can be (the actual value of
x should be established by trial; it corresponds roughly
to inches of ink).
	The following brief example is a SAIL program
which does nothing but allow inking -- a carriage return
causes the DOUT#(2,x) call to be executed again,
thus clearing any existing ink.
.nojustify
.nofill

	DINI (0,10,D[1],0); DGET;  "GET 340 DISPLAY"
	WHILE TRUE DO BEGIN
		DOUT (2,40);	   "INITIALIZE AND CLEAR INK"
		INCHWL;		   "WAIT FOR USER CARRIAGE RETURN"
	END;

.justify
.fill
.test page 10
.skip 2
.index Plotting
1.14 ^&Plotting\&
	An off-line plot of any display can be made with the
call
.index DPLOT
.nojustify
.nofill

	^&DPLOT\& ( buffer [pointer], filename [integer] )

.justify
.fill
This call writes a small disk file which contains the
display file instructions for any pictures which are currently
DPOSTed. If a non-zero SIXBIT filename is specified, the
file will be so named (extension .PLX).
Otherwise, the file name will be chosen so as not to
conflict with other plot files already on the disk.
(Names will be of the form 000000.PLX, 000001.PLX, 000002.PLX, etc.)
	The operation of writing the file requires the use of
a 128-word core buffer.  This buffer cannot, in general, be
obtained from the display free-storage, so the user is expected
to supply a pointer to a free buffer area.  After the 
DPLOT subroutine returns, the buffer area can be used
for other purposes.
	The buffer also provides a way of communicating to the
plotting package a variety of special parameters related to the
plot.   At present, the following conventions are established:
.nojustify
.nofill

	buffer [1]		[real] 314159 (the number!)
	buffer [2]		[real] x scale value
	buffer [3]		[real] y scale value
	buffer [4]		[real] x offset value
	buffer [5]		[real] y offset value

	buffer [6]		[real] paper type:
					1 -- standard
					2 -- vellum
					3 -- grid
	buffer [7]		[real] paper width:
					11 inches
					30 inches
	buffer [8]		[real] pen type:
					1 -- ball point
					2 -- felt tip pen
					3 -- wet ink
	buffer [9]		[real] pen color:
					1 -- black
					2 -- read
					3 -- green
					4 -- blue
					5 -- turquoise
					6 -- purple
					7 -- yellow
					8 -- orange
					9 -- brown
				       10 -- pink
	buffer [10]		[real] overlay next plot
					(if 1, will overlay)

.justify
.fill
If buffer[1] is not 314159, then default values are assumed
for the remaining parameters: 1.0, 1.0, 0., 0., 1, 11, 2, 1.
If entries 6, 7, 8, or 9 are 0, they are individually
defaulted to 1, 11, 2, and 1.
	The plotter output will mirror, as successfully
as possible, the display image shown at the time of the
DPLOT call (The display does not have to be
seized, however; DPLOT merely examines
the display file).  The scale factors and offset values
can be used to enlarge the display when plotting.
If the scale factors are 1 and the offsets 0, then the
plot will be exactly the same size as the display was when
it was  viewed.  The following computation is performed:
.nojustify
.nofill

(plotter x in inches) = 
	(x in standard viewport coords) *
	(screen width in inches) * scale + offset

.justify
.fill
along with a similar computation for y.
The computation has the effect that 'scale' is an enlargement factor
and 'offset' is the offset in inches of the lower left corner of the plot.
.index PLOTX, use with Omnigraph routines
	A program called PLOTX reads the
 .PLX files created and actually accomplishes the plotting.
This program will produce output for the off-line
Calcomp plotter, for the SC 4070 microfilm unit,
and for the ZETA plotter.  The operation of the
program is very simple, and is directed by various
promptings.


.test page 10
.skip 2
1.15 ^&Miscellaneous Subroutines\&
	The enterprising programmer may want to know several
details about the terminal actually being used.  The subroutine
call
.index DENQ
.nojustify
.nofill

	^&DENQ\& ( array [pointer] )

.justify
.fill
can be used to enquire about many salient characteristics of
the terminal, and about the current state of the display routines.
The effect of the subroutine is to fill the array with
floating-point numbers which describe the terminal:
.left margin 14
.skip 1
.indent -14
array[1]######^&Storage Tube\&?  This value is non-zero if
the terminal does not have a dynamic-refresh display.
Otherwise, it is zero.
.skip 1
.indent -14
array[2]######^&Three-Dimensional Hardware\&?  This value is
non-zero if the terminal has hardware for rotating three-dimensional
objects.
.skip 1
.indent -14
array[3]######^&Tablet\&?  This value is non-zero if the terminal
has some kind of stylus tablet attached to it.
.skip 1
.indent -14
array[4]######^&Keys\&?  This value is 1 if the terminal
has function keys attached.
The value is 2 if the terminal has keys and also has lights
under the keys.
.skip 1
.indent -14
array[5]######^&Points per unit Viewport\&. This is the number of resolvable points
which corresponds to a viewport value of 1.0.
.skip 1
.indent -14
array[6]######^&Inches per unit Viewport\&. This is the size (in inches)
of the screen which corresponds to a unit viewport (value = 1.0).
.skip 1
.indent -14
array[7]######^&Maximum value of X Viewport\&. This is the maximum
value which an X viewport value can take, in the DPORT call.
.skip 1
.indent -14
array[8]######^&Maximum value of Y Viewport\&.   This is the maximum value
which a Y viewport value can take, in the DPORT call.
.skip 1
.indent -14
array[9]######^&Character Height\&.  This is the actual height of
characters, as set by the last DTSCAL call.  The
height is measured in page coordinates, as specified
in the last DWIND call.
.skip 1
.indent -14
array[10]#####^&Character Width\&.  This is the width
of characters, as set by the last DTSCAL call,
as measured in the page coordinate system.
.skip 1
.indent -14
array[11]#####^&Character Box Height\&.  This is the height,
in page coordinates, of the box which surrounds a character.
.skip 1
.indent -14
array[12]#####^&Character Box Width\&.  This is the width,
in page coordinates, of the box which surrounds a character.
It can be used to answer questions like: "How many characters
can I fit between x#=#1 and x#=#5500 in the page coordinate
system."
.skip 1
.indent -14
array[13]#####^&Current Fictional X Beam\&.
.skip 1
.indent -14
array[14]#####^&Current Fictional Y Beam\&.
.skip 1
.indent -14
array[15]#####^&Current Fictional Z Beam\&.
.skip 1
.indent -14
array[16-19]##^&Current Viewport Limits\&.  These four numbers
are the left, right, bottom, and top limits of the
viewport.  These are merely copies of the last arguments
passed to DPORT.
.skip 1
.indent -14
array[20-23]##^&Current Window Limits\&.  These four
numbers are the left, right, bottom and top limits of the
window.  These are values of the last arguments
passed to DWIND.

.skip 2
.left margin 0

	The display routines have a dynamic storage
allocation facility for managing the free-storage area.
This facility is used extensively by the various picture-generating
routines described above.  As a convenience, the two basic
subroutines are also made available to the user program.
They can be used to reserve and release space within the
free-storage area. 
The calls are:
.nojustify
.nofill

	address [integer] <- ^&DCORGET\& ( size [integer] )

		             ^&DCORREL\& ( address [integer] )

.justify
.fill
DCORGET reserves a space of length 'size,' and returns
the address of the first word of that space.
If no core of that size can be found, 0 is returned.  DCORREL
releases the space beginning at 'address.'  Users should
be very careful to stay within the bounds of the piece of
core given them; a faulty program can destroy vital
information in the Omnigraph routines.
.index DCODE
	Several of the displays served by the Omnigraph
routines have special features which do not fit into the
Omnigraph framework.  In order to partially
circumvent this problem, the call
.nojustify
.nofill

	^&DCODE\& ( code [integer] )

.justify
.fill
can be used to specify special actions.  For most remote terminals,
the 'code' is merely transmitted to the terminal.  Section
3 explains the function of DCODE for each terminal.
Since this feature is terminal-dependent,
use of DCODE is not recommended unless absolutely
necessary.
.index DRAST
.index Raster mode pictures
	The DEC340 has a special mode, called raster, which
permits the 340 to operate in a TV-type scan. The call
.nojustify
.nofill

        ^&DRAST\& ( n [integer] )

.justify
.fill
puts the DEC340 in raster mode, and therefore should
be called immediately before (i.e., with no intervening 340
code generated) the DCODEs which generate the raster picture.
The user must still generate an ESCAPE from raster mode as part
of his last raster instruction.  The argument n is the
number of points in the raster mode picture.  DRAST preallocates
enough core for the entire raster picture in the 340
display file.  The use of this routine is advisable since the
340 may not remember the previous left margin (X-coordinate)
when the display file crosses a core block boundary.

.test page 10
.skip 2
1.16 ^&Sequencing of Omnigraph Routine Calls\&
	Certain calls may be issued at any time; others
can only be issued when a picture has been DOPENed
(or is being DAPPENDed to). All calls must follow
the DINI initialization call.
The classes of calls are as follows:
.nojustify
.nofill

1. Can appear anywhere:
	DINI
	DGET, DREL, DCURSOR, DDONE, DKILL, DPOST, DUNPOST,
	DOPEN, DAPPEND, DCLOSE, DCHAR
	DAPPLY, DCOMPOSE,DRCOMPOSE, DPOP, DPUSH, DSETR, DBYP
	DCURRENT,DFLUSH,DVMULT
	DWIND, DPORT, DWIND3, DTEST2, DTEST3,
	DTSCAL, DINT, DPLOT, DENQ, DEVENT, DOUT, DSTAT.

	(The effect of DTSCAL and DINT when called outside
	a picture is to remember the parameters as global
	defaults).

2. Can appear only inside DOPEN-DCLOSE pair:
	DMOVE, DDRAW, DVECT, DDOT
	DMOVE3, DDRAW3, DVECT3, DDOT3
	DTEXT

.justify
.fill
.test page 10
.skip 2
1.17 ^&Technical Considerations\&
	This section describes some particularly complicated
uses of the Omnigraph routines and the various caveats which
pertain to the complication:

.left margin 10
.skip 1
.indent -10
Overlays: If you request that the second
segment be used for display data, then ^&all\& internal
data in the Omnigraph routines is saved there.
Even if the Omnigraph display-dependent code in the  first 
segment is destroyed, and an entirely new one
is read in as an overlay, the second segment data remains untouched.
If a second segment exists when DINI is called, it checks to
see whether that segment was created by the Omnigraph routines for the
same display.  If so, the DINI call does not initialize the free-storage
area, but leaves all pictures intact.  It is thus possible
to create a picture with one overlay, post it with a second,
and kill it with a third!
	The DINI call is required each time an overlay
replaces the place where the display
subroutines were loaded.

The effect of the call is simply to reload the device-dependent
code for your display.
.skip 1
.indent -10
Using several displays:  DINI can
be called once to read in the code segment for one display,
say the DEC340, and then again to read in the code
segment for another display, say the ARDS.  The
usefulness of this strategy is questionable, but the
routines do permit the activity and thus you can dynamically
switch displays.
 The program should
be sure to release (DREL) the first display before
reading in code for the second.  In addition,
when the new routines are initialized, the display
file is of necessity destroyed completely.  Your program
will thus have to regenerate the display.

.left margin 0


.page
2.0 ^&Language Considerations\&
.index Language considerations
	This section describes the special behaviour of the
Omnigraph routines in each of the three programming languages 
SAIL, LISP, and FORTRAN.
.test page 10
.skip 2
.index SAIL use
2.1 ^&SAIL\&
	A relocatable copy of the Omnigraph routines is saved as
SYS:DISSAI.REL.
The SAIL 'REQUIRE' verb can be used to cause this
file to be loaded with your program.
	The declarations to be included in your SAIL
program are:

.nofill
.nojustify

DEFINE EP="EXTERNAL PROCEDURE", EIP="EXTERNAL INTEGER PROCEDURE";

	EIP DINI (INTEGER N,CH; REFERENCE INTEGER AR; INTEGER S);
	EIP DGET;
	EP  DREL;

	EP  DOPEN (INTEGER N);
	EP  DAPPEND (INTEGER N);
	EP  DCLOSE;

	EIP DPOST (INTEGER N);
	EIP DUNPOST (INTEGER N);

	EP  DKILL (INTEGER N);

	EP  DDONE;
	EP  DCURSOR (REAL X,Y);

	EP  DAPPLY (REFERENCE REAL AR; INTEGER NAME);
	EP  DCOMPOSE (REFERENCE REAL AR; INTEGER NAME);
	EP  DRCOMPOSE (REFERENCE REAL AR; INTEGER NAME);
	EP  DPUSH (INTEGER NAME);
	EP  DPOP (INTEGER NAME);
	EP  DFLUSH;
	EP  DCURRENT (REFERENCE REAL AR; INTEGER NAME);
	EP  DVMULT (REFERENCE REAL AR; REAL AR);
	EP  DSETR (REFERENCE REAL AR; INTEGER NAME);

	EP  DWIND (REAL L,R,B,T);
	EP  DPORT (REAL L,R,B,T);
	EP  DWIND3 (REAL L,R,B,T,ZMIN,ZMAX);

	EIP DMOVE (REAL X1,Y1);
	EIP DDRAW (REAL X2,Y2);
	EIP DVECT (REAL X1,Y1,X2,Y2);
	EIP DDOT (REAL X1,Y1);
	EIP DTEST2 (REAL X,Y);

	EIP DMOVE3 (REAL X1,Y1,Z1);
	EIP DDRAW3 (REAL X2,Y2,Z2);
	EIP DVECT3 (REAL X1,Y1,Z1,X2,Y2,Z2);
	EIP DDOT3 (REAL X1,Y1,Z1);
	EIP DTEST3 (REAL X,Y,Z);
	EP  DBYP (INTEGER CODE);

	EP  DTSCAL (REAL S);
	EP  DTEXT (STRING S);
	EIP DCHAR (INTEGER I);

	EP  DINT (REAL I);
	EP  DSTAT (INTEGER N);

	EP  DEVENT (INTEGER DEV,OP; REFERENCE REAL ANS);
	EP  DOUT (INTEGER DEV,OP);

	EP  DPLOT (REFERENCE REAL AR; INTEGER FILE);
	EP  DENQ (REFERENCE REAL AR);
	EIP DCORGET (INTEGER SIZE);
	EP  DCORREL (INTEGER ADDRESS);
	EP  DCODE (INTEGER CODE);

	REQUIRE "SYS:DISSAI" LOAD!MODULE;

.fill
.justify
.test page 10
.skip 2
.index LISP use
2.2 ^&LISP\&
	The Omnigraph routines are loaded into LISP in two steps:
first the relocatable file is loaded; then a file of S-expressions
is loaded which actually defines all the appropriate SUBRs.
The relocatable file is SYS:DISLIS.REL; the
S-expressions are SYS:DISLIS.LSP.
	All of the Omnigraph subroutines become LISP functions
after these two files have been read into LISP.
Integer and real numbers can be passed to these routines in
the usual way:
.nojustify
.nofill

	(DWIND 0 1 0 1)

.justify
.fill
The Omnigraph routines will perform any type conversions from
integer-to-real or real-to-integer which may be required.
Pointers are passed to the Omnigraph routines by means of LISP
arrays, e.g.
.nojustify
.nofill

	(ARRAY FOO () @(1 . 4) @(1 . 4))
	(DAPPLY @FOO 0)

.justify
.fill
Text is passed to the Omnigraph routines via the call
.nojustify
.nofill

	(DTEXT ...)

.justify
.fill
which precisely mimics (PRINT ...).
.test page 10
.skip 2
.index FORTRAN use
2.3 ^&FORTRAN\&
	The Omnigraph routines for FORTRAN are found in the
file SYS:DISFOR.REL.
You must specify that this file be loaded with the FORTRAN
program, e.g.:
.nojustify
.nofill

	LOAD MY.F4,SYS:DISFOR

.justify
.fill
	The arguments of type real, integer, and pointer may
all be passed to Omnigraph routines as you would pass arguments to
any FORTRAN subroutine. The Omnigraph routines will 
convert from integer-to-real and from real-to-integer if
necessary.  However, when pointers are specified, no
conversions are performed (i.e. be sure that arrays
passed to DAPPLY, DCOMPOSE and DPLOT are floating-point).
	The functions which return values will have to be
declared INTEGER, unless you wish their return values to be
ignored (e.g. the DMOVE, DDRAW calls, etc.).
	Text is passed to FORTRAN in a rather uncomfortable
way: the ENCODE statement must be used to create an
array of ASCII text to be displayed.  Then
the call 
.nojustify
.nofill

	CALL DTEXT ( asciiarray, length )

.justify
.fill
will display text from the ASCII array; 'length' specifies the
number of characters to be displayed.




.PAGE
3.0 ^&Terminal Considerations\&
	This section describes the idiosyncracies of the various
terminals supported by the Omnigraph routines. 
At the very least, each display terminal is assigned a number
which is used in the call to DINI to specify which terminal
is to be used.

.skip 2
.index DEC 340 Display
3.1 ^&DEC-340 Display\&: display number 0, name "DEC340"
	The DEC-340 display is one of the higher quality
display terminals we have (alas), with the following properties:
.left margin 6
.skip 1
.indent -6
Coordinate resolution: 1024 by 1024 points on a 10 inch square
screen
.skip 1
.indent -6
Viewport maxima: X: 1.0; Y: 1.0.
.skip 1
.indent -6
Intensity resolution: 8 intensity levels
.skip 1
.indent -6
Character fonts: 64 ASCII characters, not including lower case;
text can appear in 4 sizes, corresponding to values of
the DTSCAL parameter of .0068, .0127, .0244, and .0479.
The character and box dimensions (in inches) are as
follows:
.nojustify
.nofill

DTSCAL	    CHARACTER		   BOX
		width	height		width	height

 .0068	.0489	.068		.0586	.107
 .0127	.0880	.127		.117	.215
 .0244	.166	.244		.235	.430
 .0479	.323	.479		.469	.860

.justify
.fill
.skip 1
.indent -6
Capacity: less than 200 inches of vectors
.skip 1
.indent -6
Input facilities: Lights and buttons are numbered
1 through 16.  The Grafacon tablet provides
inking and tracking facilities.
A comparitor which mimics light pen features is also present.
.skip 1
.indent -6
DCODE operation: Allows you to compose 340 display file instructions
yourself (and thus use raster,vector-continue and increment
modes) and allows you to set various parameters in the device
status area.  The DCODE argument is organized in 3 fields:
operation code (bits 0-5), suboperation code (bits 6-17), and
operand (bits 18-35).  The 5 defined opcodes are:
.nojustify
.nofill

        0        Store "operand" as a byte of the display file.
        1        Set next mode to "operand".
        2        Deposit "operand" in left half of one of the
                     status entries.
        3        Same as 2 except deposit right.
        4        Examine a location in the high segment.

.justify
.fill
.skip 1
.left margin 0
For complete information on these opcodes, see the Omnigraph
Implementation Manual.
.skip 1
.index DRAST
Before using raster mode, you should call DRAST to put
.index Raster mode pictures
the 340 in raster mode and to preallocate a large enough
core block.
.skip 1
The use of this display requires that free-storage come from a
second segment.  The third and fourth arguments to DINI
are thus ignored, and a second segment is always used.
.test page 10
.skip 2
.index Computek 400 display use
3.2 ^&Computek 400\&: display number 1, name "C400"
	This is a direct-view-storage-tube display, connected
to the DECsystem-10 via asynchronous communications lines.
The terminal is used both for graphics displays and for echoing
text typed in by the user.
Essential characteristics are:
.skip 1
.left margin 6
.indent -6
Coordinate resolution: 1024 by 780 points on a 8.25 by 6.4
inch screen
.skip 1
.indent -6
Viewport maxima: X: 1.279; Y: 1.0.
.skip 1
.indent -6
Intensity resolution:  one intensity level
.skip 1
.indent -6
Character fonts: 96 character ASCII (including lower case)
in exactly one size, corresponding to a DTSCAL
parameter of .015. The character measures .0645 by .0968
inches, and resides in a box .0968 by .16 inches.
.skip 1
.indent -6
Capacity: extremely large, but the time required to draw 
complicated pictures may get quite large
.skip 1
.indent -6
Input facilities: none
.skip 1
.indent -6
DCODE operation: low-order 8 bits of the argument are sent
directly to the terminal.
.skip 1
.indent -6
Special features: the ability to draw curves of various kinds
.skip 1
.left margin 0
.test page 10
.skip 2
.index Adage AGT-30 use
3.3 ^&Adage AGT-30\&: display number 2, name "ADAGE"
	The AGT-30 is a high-performance display with
analog vector generation and three-dimensional rotation hardware
built into the display.  The hardware does not produce an
accurate perspective view, but it can be used to achieve the
kinetic depth effect; that is, motions of the object in space
serve to communicate spatial relationships.
.skip 1
.left margin 6
.indent -6
Coordinate resolution: 16384 by 16384 points on a 10 by 10
inch screen. (An area 12 by 12 inches can in fact be
used, although some vectors may be distorted.  If you wish to
use this larger area, the X and Y viewport parameters may
be set to 12/10#=#1.2.)
.skip 1
.indent -6
Viewport maxima: X: 1.0; Y: 1.0  (nominally -- see above).
.skip 1
.indent -6
Intensity resolution: 1000 or more
.skip 1
.indent -6
Character fonts: 96 character ASCII (lower case included),
at discrete sizes corresponding to values of the DTSCAL
parameter of .015, .030, and .045.
.nojustify
.nofill

DTSCAL	    CHARACTER		   BOX
		width	height		width	height

 .015 	.1   	.15 		.125 	.3
 .030 	.2   	.30 		.250	.6
 .045 	.3  	.45 		.375	.9

.justify
.fill
.skip 1
.indent -6
Capacity: about 15000 inches of vectors
.skip 1
.indent -6
Input facilities: Lights and buttons are numbered 1 through 16.
Inking and tracking facilities are provided.
.skip 1
.indent -6
DCODE operation: low-order 16 bits are transmitted to the
Adage; refer to 'Adage Picture Transmission Language' for
coding information.
.skip 1
.indent -6
Special features: 3-D transformation hardware.
.skip 1
.left margin 0
.test page 10
.skip 2
.index ARDS display use
3.4 ^&ARDS\&: display number 3, name "ARDS"
	The ARDS display is a storage-tube device.
Characteristics:
.skip 1
.left margin 6
.indent -6
Coordinate Resolution: 1080 by 1414 points on a
6.375 by 8.25 inch screen.
.skip 1
.indent -6
Viewport maxima: X: 1.0; Y: 1.309.
.skip 1
.indent -6
Intensity resolution: one intensity level.
.skip 1
.indent -6
Character font: 96 character ASCII (including lower case).
The character size corresponds to a DTSCAL parameter
of .0134; it measures .067 by .086 inches; the box
size is .08 by .165 inches.
.skip 1
.indent -6
Capacity: very large, but may take some time to draw pictures.
.skip 1
.indent -6
Input facilities: none
.skip 1
.indent -6
DCODE operation: low-order 8 bits are sent directly to the terminal.
.skip 1
.left margin 0
.test page 10
.skip 2
.index Tektronix 4010 display use
3.5 ^&Tektronix 4010-1\&: display number 4, name "T4010"
	The Tektronix terminal is a small, quiet,
inexpensive storage-tube terminal. 
One nice feature of this terminal is that it can
be quickly changed to 150, 300, 600, 1200, 2400, 4800 or
9600 baud asynchronous operation.
 Characteristics:
.skip 1
.left margin 6
.indent -6
Coordinate resolution: 1023 by 780 points on an
8.25 by 6.4 inch screen.
.skip 1
.indent -6
Viewport maxima: X: 1.311; Y: 1.0
.skip 1
.indent -6
Intensity resolution: one intensity level.
.skip 1
.indent -6
Character font: 64 character ASCII; no lower case.
There is one character size, corresponding to a DTSCAL
parameter of .0179.  The character size is .09 by
 .12 inches; the box size is .10 by .16 inches.
.skip 1
.indent -6
Capacity: very large.
.skip 1
.indent -6
Input facilities: The cross-hairs are used for two-dimensional
input; they are enabled whenever 'tracking' is requested.
No inking is possible.  When the cross-hairs are
enabled, the coordinates are sent to the DECsystem-10 (thus
causing an 'event') by pressing the 'return' key.
.skip 1
.indent -6
DCODE operation: low order 8 bits are sent directly to the
display terminal.
.skip 1
.left margin 0
.test page 10
.skip 2
.index DEC GT40 display use
3.6 ^&DEC GT40\&: display number 5, name "GT40"
	The GT40 consists of a PDP-11 computer controlling a refresh-type
digital display.  The computer provides memory for local display files
used to refresh the CRT, interprets input commands from
the DECsystem10 computer, and provides some core management.
The device allows 4 line types (solid, long dash, short dash, and
dot dash), blinking lines, italics, and many special characters.
Characteristics:
.skip 1
.left margin 6
.indent -6
Coordinate resolution: 1023 by 767 points on a 6.75 by 9 inch screen.
.skip 1
.indent -6
Viewport maxima: X: 1.0; Y: 1.333.
.skip 1
.indent -6
Intensity resolution: 8 intensity levels.
.skip 1
.indent -6
Character font: 96 character ASCII, upper and lower case, and
31 special characters.  There is one character size, corresponding
to a DTSCAL parameter of .0209.  The character size is
 .11 by .14 inches; the box size is .12 by .19 inches.
.skip 1
.indent -6
Capacity: 1400 inches of vectors (flicker-free).
.skip 1
.indent -6
Input facilities:  light pen (unsupported by current Omnigraph
software).
.skip 1
.indent -6
DCODE operation: low order 8 bits are sent directly to the GT40.
.page
.index Error messages
4.0 ^&Error Reporting\&
	The Omnigraph routines report errors in a uniform manner.
Each error causes a message to be typed out on the user's
terminal.  If the error is fatal, the terminal is returned
to monitor mode; otherwise, the user program is allowed to
continue.
	Some care has been taken in the construction of the
Omnigraph routines to insure that errors which may depend on the
state of the time-sharing system or on the exact size of the
display file will not be fatal to the entire program.
For example, if the Omnigraph routines run out of free storage and
cannot acquire more from the operating system, the picture
currently being generated is flushed, and all subsequent
requests to add to the picture are ignored, up until the
picture is CLOSEd.  If the graphics program is
interactive, perhaps the user could DKILL some pictures
he no longer needs, thus reclaiming some free storage space,
and could attempt the generation process again.
	If the core routines must stop generation of 
a picture, the message 'No core for display' is typed
on the console to warn you that some picture may not
be generated correctly.
	The error message printed looks like:
.nojustify
.nofill

?DISPLAY ERROR NUMBER 7; ROUTINE DPORT
 CALLED FROM 5107

.fill
.justify
The error can be found in the table of errors given
below, together with a more verbose description of the
difficulty.
For debugging purposes, you can put a DDT breakpoint
at the location DERRHL. The breakpoint will
stop the program after the error message
is printed, but before any action is taken.
.skip 2
.left margin 18
.indent -17
Error##Fatal?####Description
.skip 1
.indent -16
#1######no######Free storage is exhausted and
we cannot get more from the
operating system.  The generation
of the present picture is
terminated.  At the next
DOPEN, however, generation will
be restarted.
.skip 1
.indent -16
#2######no######The type of a subroutine argument
is incorrect.  This is usually
a programming error of some sort.
.skip 1
.indent -16
#3######yes#####A subroutine attempted to 
generate a display file
instruction when no picture
was currently DOPENed.
.skip 1
.indent -16
#6######yes#####An attempt to DAPPEND to a
non-existent picture.
.skip 1
.indent -16
#7######no######One of the parameters to DPORT
is out of bounds.
.skip 1
.indent -16
#9######yes#####Bad core pointer.  The dynamic
storage allocation routines have
discovered an inconsistency in
the free-storage mechanism.
.skip 1
.indent -16
10######no######DPLOT cannot write the
 .PLX disk file.
.skip 1
.indent -16
11######no######DPUSH cannot find a piece
of core in which to save the
transformation.
.skip 1
.indent -16
12#######-######not used
.skip 1
.indent -16
13######no######Function is not implemented
for this device.
.skip 1
.indent -16
14######no######Cannot find the code segment
for the display you have
requested in DINI.
.skip 1
.indent -16
15######no######Cannot find a piece of core for the
event buffer, the inking buffer, or some other
function related to the DEVENT/DOUT routines.
.skip 1
.indent -16
16######yes#####Attempted posting of more pictures than 
can be handled by specific device (for Adage AGT-30,
DEC GT40).
.skip 1
.left margin 0
.subtitle Making offline plots
.page
.index PLOTX
.index Calcomp plotter, PLOTX use
.index Plotting, PLOTX program
.index Plotting, OMPLOT program
.index Calcomp Plotter, OMPLOT use
.index OMPLOT
.center
Making Off-line Plots
.SKIP 2
	In this chapter we describe two programs:
.SKIP 2
.nojustify
.nofill
1.#PLOTX	Generates offline plots which resemble the displays
		shown on the screen.

2.#OMPLOT	Generates pictures on a display device using the
		same input files as PLOTX. This allows one to 
		review plot files prior to the plotting. Hence
		one can check for errors or simply refresh one's
		memory.
.justify
.fill
.subtitle Making offline plots - PLOTX program
.skip 5
.center
PLOTX
	PLOTX is a program which reads specially-formatted disk files
and makes off-line plots.  The files are created as a result
of the DPLOT Omnigraph routine; they are essentially copies
of the display files for all posted pictures at the time
DPLOT is called.  The PLOTX program knows the format
of all display files used in the Omnigraph routines, and
can decode them and produce plots which mirror, as closely as
possible, the display shown on the screen.
	PLOTX can also be used to accomplish a number
of trivial transformations on the picture as it is plotted.
These include enlarging, offsetting, and overlaying.
	PLOTX is designed to produce plots on one of three
devices:
.nojustify
.nofill

   Off-line Calcomp Plotter
   SC 4060 Microfilm device (not implemented 8-73)
   ZETA Plotter

.justify
.fill
	The operation of PLOTX is best explained with
an example (see below). The dialog used by the program
observes several conventions: items listed inside square
brackets [#] are default values or actions that will be
obeyed if the question is answered with 'carriage-return'.
Items listed inside parentheses (#) describe admissible
answers to the question being posed.
Answers to yes or no questions may be abbreviated to Y or N.
	The first question
is whether the operation is to be 'automatic', or 'manual'.
Automatic operation means that all files with
extension .PLX on your disk area will be plotted.
Any information included in the PLX file about how the
plot is to be done (see the description of DPLOT, above)
will be obeyed, but the user will not be prompted for additional
commands.
In 'manual' operation, PLOTX will engage in an initial
dialog to permit changes to the plotting parameters associated
with each PLX file.  The discussion below assumes manual
mode is being used.
	Next, PLOTX wants to know which plotter you intend
to use.  The default is 1, the Calcomp.
	Now you must provide the names of the PLX files
which are to be plotted.  A response of 'carriage-return'
will cause all files with extension .PLX in your
disk directory to be plotted.  They will be plotted in
the same order that they are listed in the directory.
If you wish to specify precisely which files are to be plotted,
the names (without extensions) may be typed in.
If the name is a 6-digit number generated by DPLOT,
then only the number portion need be typed.  Examples:
.nojustify
.nofill

   12,  0,2
	... will plot 000012.PLX, 000000.PLX, and 000002.PLX
   1,NAM
	... will plot 000001.PLX, NAM.PLX
   1 ,1,1
	... will plot 000001.PLX, 000001.PLX, and 000001.PLX

.justify
.fill
The last example is useful when you wish to change the plotting
parameters so that each plot is different (e.g., enlarge
one plot, make one in red ink, etc.).
	Now PLOTX will ask, for each of the files specified
in the previous step, whether you wish to make changes
to the plotting parameters.  The default parameters
are supplied by PLOTX unless the parameter portion
of the PLX file specifies valid parameters (see DPLOT, above).
The defaults are:
.nojustify
.nofill

	X scale factor: 1
	Y scale factor: 1
	X offset: 0
	Y offset: 0
	Paper type: 1 		(standard)
	Paper width: 11 	(11-inch)
	Pen type: 2 		(felt tip)
	Pen color: 1 		(black)
	Overlay: 0 		(no overlay)

.justify
.fill
These options are almost self-explanatory.  The scale factor
is applied before the offset: the x coordinate of a point
is x#*#scale#+#offset.  The offset is measured in inches.
The overlay option allows the plotter medium to be
'rewound' before plotting the next PLX file.  The
origins of the two sucessive plots will thus coincide.
If, during the dialog for a particular PLX file, one wishes 
to start over, one need only type an up arrow.
	The remaining dialog depends on which kind of plotting
medium is selected; we shall assume that the off-line Calcomp
has been chosen.  In this case, PLOTX must write
a magnetic tape to drive the plotter -- it asks for the number
of a tape drive on which a scratch tape has been mounted
(The Zeta plotter, however, provides online plots;  Consequently, the plots are
generated directly from your PLX files, obviating the need for a plot tape).
	PLOTX then asks for various accounting information:
name, registered initials, account number, and box number.
The 'registered initials', 'account number', and
'box number' are assigned to CCB users by the
Project Control Office, Bldg. 12A, Room 3013.
This information will be scribed on your plot so the
Calcomp operator can collect accounting information.
	Now PLOTX takes over and begins to write on
magnetic tape appropriate codes to plot the files you requested.
It will type out the name of each file as it begins processing.
	When all files have been examined and plots written
on the magnetic tape, it is rewound (if you were generating a Calcomp plot tape).  PLOTX then asks
if you would like to have the PLX files deleted from your
disk area.  If you respond 'yes', it will delete only
those which have just been plotted.
.skip 2
Below is a teletype listing from a sample PLOTX run.
All underlined characters were typed in by the user; an
underline as the last character on a line means that the
user pressed the 'return' key at that point.
.skip 2
.nofill
.nojustify
_.^&DIRECTORY *.PLX\&& 

000000	PLX     3  <055>   16-Aug-73	DSKA:	[13,16]
000001	PLX     3  <055>   16-Aug-73

  Total of 6 blocks in 2 files on DSKA: [13,16]


_.^&R PLOTX\&& 

AUTOMATIC OR MANUAL OPERATION
        A=PLOT ALL PLX FILES IN YOUR AREA
        M=PLOT SPECIFIED PLX FILES ONLY    (A OR M) [M] =&M
PLOTTER TYPE (1=CALCOMP, 2=COM, 3=ZETA)[1]?&1& 
GIVE PLX FILES, IN ORDER [ALL, IN DIRECTORY ORDER]:&  
CHANGE PLOTX- OR FILE-SPECIFIED DEFAULTS FOR 000000.PLX?&Y& 
  OMIT PLOTTING THIS FILE? [NO] & 
  X SCALE FACTOR [1] & 
  Y SCALE FACTOR [1] & 
  X OFFSET (INCHES) [0] & 
  Y OFFSET (INCHES) [0] & 
  PAPER SIZE (11 OR 30 INCHES) [11] & 
  PAPER TYPE (1=REGULAR, 2=VELLUM, 3=GRAPH) [1] & 
  PEN TYPE (1=BALLPOINT, 2=FELTTIP, 3=WET INK) [2] &3& 
  COLOR (1=BLACK, 2=RED, 3=GREEN, 4=BLUE, 5=TURQUOISE
	 6=PURPLE, 7=YELLOW, 8=ORANGE, 9=BROWN, 10=PINK) [1] & 
  OVERLAY NEXT PLOT [NO] & 
CHANGE PLOTX- OR FILE-SPECIFIED DEFAULTS FOR 000001.PLX?&Y& 
  OMIT PLOTTING THIS FILE? [NO] & 
  X SCALE FACTOR [1] & 
  Y SCALE FACTOR [1] & 
  X OFFSET (INCHES) [0] & 
  Y OFFSET (INCHES) [0] & 
  PAPER SIZE (11 OR 30 INCHES) [11] & 
  PAPER TYPE (1=REGULAR, 2=VELLUM, 3=GRAPH) [1] & 
  PEN TYPE (1=BALLPOINT, 2=FELTTIP, 3=WET INK) [2] & 
  COLOR (1=BLACK, 2=RED, 3=GREEN, 4=BLUE, 5=TURQUOISE
	 6=PURPLE, 7=YELLOW, 8=ORANGE, 9=BROWN, 10=PINK) [1] &2& 
  OVERLAY NEXT PLOT [NO] & 
MOUNT A MAGNETIC TAPE. WHICH DRIVE (0,1 OR 2)?&0& 
NAME: ^&SPROULL\&& 
REGISTERED INITIALS: ^&RFS\&& 
ACCOUNT: ^&XXXX\&& 
BOX: ^&YY\&& 
PLOTTING 000001.PLX
FINISHED! DO YOU WANT TO DELETE PLOTTED FILES? [NO] &Y& 

.skip 1
EXIT
.justify
.fill

.subtitle Making offline plots - OMPLOT program

.page
.index Plotting, OMPLOT program
.index Calcomp Plotter, OMPLOT use
.index OMPLOT
.center
OMPLOT
	OMPLOT is a program that generates pictures on a display
device using the same input (.PLX) files as are used by PLOTX.
This allows one to review plot files, and
check for errors or refresh one's memory prior to offline plotting.
	OMNIGRAPH has facilities for generating a
plot (.PLX) file by execution of the DPLOT routine. 
The resultant plot file contains a description of all pictures that are posted
(displayed) at the time of the call to DPLOT.
Note: MLAB users utilize the DPLOT routine
indirectly by typing in "PLOT" to MLAB. This too results
in the generation of a .PLX file.
	To plot these files offline, one would run the PLOTX program.
OMPLOT however, allows one to reconstruct the displayed images
as they existed at DPLOT time. Of special value is the
fact that you are not restricted to generating the images
on the same device as originally used. That is, one may be
running MLAB on the DEC 340 display and later view
the .PLX files on a GT40 or Tectronix T4010, or whatever.
	The dialogue for OMPLOT is similar to that of
PLOTX.

.PAGE
#####
.BLANK 15
.center
Blank page
.subtitle Appendix A. References
.page
.center
Appendix A. References

.skip 1
.left margin 3
.indent -3
1.#^&Guide to the DECsystem-10 Timesharing System\&.  This
document describes the DEC-340 display system in detail,
and also the other two brands of display routines available
on the DECsystem-10.
(Available from the Technical Information Office).
.skip 1
.indent -3
2.#Sproull and Sutherland, ^&A Clipping Divider\&, FJCC 1968.
This article describes two-dimensional and three-dimensional
clipping and windowing.
.skip 1
.indent -3
3.#Sproull, ^&Notes for Computer Graphics\&.  These
notes for an NIH-CCB seminar on computer graphics
describe windowing and clipping algorithms, transformation
systems, etc.
(Available in the DCRT Library).
.SKIP 1
.INDENT -3
4.#Sproull and Stevens, ^&Omnigraph Display Routines\& -- ^&Implementation Manual\&, 
December 1973. Available from the DECsystem-10 Unit, DCRT.
.skip 1
.indent -3
5.#Lewis and Sproull, ^&DEC 340 Display\&, October 1972. 
This document provides technical information about the DEC 340 display hardware.
Available from the DECsystem-10 Unit, DCRT.
.skip 1
.indent -3
6.#Newman and Sproull, ^&Principles of Interactive Computer
Graphics\&, New York, McGraw Hill, 1973
.skip 1
.indent -3
7.#Hart and Duda, ^&Perspective Transformations\&, Stanford
Research Institute, Artificial Intelligence Group Technical
Report Note 3. Available in the DCRT Library.
.skip 1
.indent -3
8.#^&PDP-10 Display Systems\&, first edition October 1972.
This manual contains descriptions of the old display software 
as well as a slightly different tutorial discussion.
.left margin 0
.page
#####
.blank 15
.center
Blank page
.SUBTITLE Index
.PAGE
.CENTER
INDEX
.skip 2
.PRINT INDEX
