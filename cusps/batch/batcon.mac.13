;<BATCH>BATCON.MAC;13   4/2/76 11:00		EDIT BY RINDFLEISCH
;  Added JBSTAT and FKSTAT tables for current status
;  Added control functions for BATCON and job/queue management
;<BATCH>BATCON.MAC;12	3-MAR-76 16:45		EDIT BY RINDFLEISCH
;  Release job PTY's at startup
;  Fixed 131 Load Average calculation to use maximum value
;  Added to priority calc that each user can't have more than MAXJBS
;	at once during prime time
;  Fixed test for start of inferior fork to be sure its private data
;	page is copied before looking for other jobs
;  Fixed ^S status report on inferior forks to work
;<BATCH>BATCON.MAC;11    31-OCT-75 10:59:50    EDIT BY LIEB
;ADDED PATCHS FROM SRI-AI TO CURE RACE CONDITIONS
;<BATCH>BATCON.MAC;10    10-SEP-75 15:08:10    EDIT BY LIEB
;USE RECURSIVE ROUTINE TO GET A PTY THAT INSURES NO JOB AT OTHER END
;GET ALL THE OUTPUT FROM PTY AT EOJ TIME. REWORK TERMINATION LOGIC
;ADD CONTROLS OVER ELAPSED TIME,CPU TIME, AND LOG LENGTH
;REWORK RUN LOOP AND GET RID OF PUSHJ'S THAT NEVER RETURN ETC
;REWORK DEBUGGING STUFF AND REARRANGE FORK STARTING
;TO PREVENT MYSTERIOUS FORK DISAPPEARANCES
;<BATCH>BATCON.MAC;7     4-SEP-75 10:14:37    EDIT BY LIEB
;added tnx131 switchs and got rid of BUG STOPs (made sense of them)
;<BATCH>BATCON.MAC;143    15-AUG-75 09:28:33    EDIT BY MOUTON
;ADDED IMPROVEMENTS BY DENNIS SMITH AT ECL
;<BATCH>BATCON.MAC;137     8-AUG-75 13:39:24    EDIT BY UNTULIS
;ADDED ^S INFERIOR FORK STATUS CODE
;<BATCH>BATCON.MAC;133     7-AUG-75 15:26:11    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;132     7-AUG-75 15:13:33    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;131     7-AUG-75 13:30:40    EDIT BY MOUTON
;ADDED LENGTH AND TIME OPTIONS
;<BATCH>BATCON.MAC;129     5-AUG-75 10:01:20    EDIT BY UNTULIS
;CORRECTED EOJ31 ERROR OF FILE BUSY CHECK
;<BATCH>BATCON.MAC;128     2-AUG-75 12:18:02    EDIT BY UNTULIS
;FIXED Q COPY LOOPING PROBLEM
;<BATCH>BATCON.MAC;127     1-AUG-75 23:10:50    EDIT BY UNTULIS
;FIXED LOG FILE GTJFN FAILURES (ILLEGAL VERSION)
;<BATCH>BATCON.MAC;103    22-JUL-75 15:45:26    EDIT BY MOUTON
;ADD CODE TO KEEP TRACK OF BATCH JOBS IN DAYFILE
;<BATCH>BATCON.MAC;96    22-JUL-75 10:53:30    EDIT BY UNTULIS
;ADD CODE TO OUTPUT BUG MESSAGES TO FILE INSTEAD OF LOGGING TTY
;<BATCH>BATCON.MAC;95    22-JUL-75 10:23:49    EDIT BY UNTULIS
;ADDED CRASH NOTIFICATION CODE ON BUG MESSAGES
;<BATCH>BATCON.MAC;81    14-JUL-75 15:07:25    EDIT BY UNTULIS
;ADD LOAD AVERAGE THRESHOLD CODE
;<BATCH>BATCON.MAC;76     4-JUL-75 13:36:48    EDIT BY UNTULIS
;ADDED CODE TO PROCESS DESUBMIT REQUEST
;<BATCH>BATCON.MAC;49    13-JUN-75 14:12:41    EDIT BY UNTULIS
;<BATCH>MFORK.MAC;45    13-JUN-75 14:11:58    EDIT BY UNTULIS
;INTRODUCED MULTIPLE FORKS TO RUN BATCH JOBS
;ADDED PRIORITY COMMAND
;<BATCH>BATCON.MAC;48    19-MAY-75 13:57:38    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;47    30-APR-75 09:54:57    EDIT BY LYNCH
;ADD SYSTEM ACTIVITY FLAG SETTING
;<BATCH>BATCON.MAC;36    11-APR-75 14:11:33    EDIT BY UNTULIS
;CHANGED LPT OUTPUT FILE NAME TO LPT FROM LOG
;<BATCH>BATCON.MAC;33    28-MAR-75 10:10:21    EDIT BY UNTULIS
;ADD LARSON CHANGES
;<BATCH>BATCON.MAC;13     4-MAR-75 15:28:57    EDIT BY UNTULIS
;ADD SKUSR CODE FOR FORCING BATCH JOBS TO QUEUE 2
;<BATCH>BATCON.MAC;11     4-MAR-75 15:13:26    EDIT BY UNTULIS
;ADD SND MESSAGE CODE
;ADD CODE FOR EVOKING DDT
;<BATCH>BATCON.MAC;8    18-FEB-75 23:54:15    EDIT BY UNTULIS
;ADD LOCAL DIRECTORY NUMBER CHECK
;<BATCH>BATCON.MAC;2    10-FEB-75 10:24:51    EDIT BY UNTULIS
;EXPANDED QENT FOR STRING ACCOUNTS
;<LARSON>BATCON.MAC;110    31-DEC-74 11:19:57	EDIT BY LARSON
;FIXED INSERTION OF ESC IN LOGIN LINE
;<LARSON>BATCON.MAC;109    31-DEC-74 10:19:40	EDIT BY LARSON
;FIXED DOLOGI BUG BY MOVING THE LOAD OF DIRNUMB TO B AT END OF CKCTLS.
;<LARSON>BATCON.MAC;108    31-DEC-74 09:52:47	EDIT BY LARSON
;FIXED CKLOG0 BY ADDING THE RESTORE OF JFN
;<LARSON>BATCON.MAC;107    31-DEC-74 08:47:04	EDIT BY LARSON
;<LARSON>BATCON.MAC;106    31-DEC-74 08:43:45	EDIT BY LARSON
;PUT IN SPECIAL HANDLING FOR LOG FILES ON DEVICES:
;DSK: (NORMAL), NIL: (ALLOW), LPT: (CREATE NAME <PRINTER>LOG.USERNAME)
;<LARSON>BATCON.MAC;105    31-DEC-74 08:19:53	EDIT BY LARSON
;<LARSON>BATCON.MAC;104    31-DEC-74 08:14:27	EDIT BY LARSON
;PUT IN CHKACC
;<LARSON>BATCON.MAC;103    31-DEC-74 07:25:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;102    30-DEC-74 16:38:11	EDIT BY LARSON
;PUT IN CLOSF BEFORE DELF AT GETJB1 BECAUSE TENEX DOESN'T
;CLOSE IT AS JSYS MANUAL SEEMS TO SAY IT SHOULD.
;<LARSON>BATCON.MAC;101    30-DEC-74 15:31:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;100    30-DEC-74 14:18:12	EDIT BY LARSON
;<LARSON>BATCON.MAC;99    30-DEC-74 09:08:01	EDIT BY LARSON
;<LARSON>BATCON.MAC;98    30-DEC-74 08:27:26	EDIT BY LARSON
;<LARSON>BATCON.MAC;97    26-DEC-74 09:56:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;96    23-DEC-74 12:10:41	EDIT BY LARSON
;FIXED Q PROT TO 777700 FROM 770000
;<LARSON>BATCON.MAC;95    23-DEC-74 11:37:18	EDIT BY LARSON
;CHANGED THE QUEUE TO LIVE IN <BATCH>
;PUT IN SETNM FOR SYSTEM BATCH
;<LARSON>BATCON.MAC;92    21-DEC-74 16:29:35	EDIT BY LARSON
;PUT IN CODE TO SUPPORT THE USRACT FIELD OF QUEUE AND
;TO SUPPORT DUMB ACCOUNTING SYSTEM THAT WON'T TAKE ACCT # 1
;<LARSON>BATCON.MAC;91    20-DEC-74 12:37:16	EDIT BY LARSON
;<LARSON>BATCON.MAC;90    20-DEC-74 11:23:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;89    20-DEC-74 10:42:22	EDIT BY LARSON
;<LARSON>BATCON.MAC;88    20-DEC-74 10:29:24	EDIT BY LARSON
;<LARSON>BATCON.MAC;87    20-DEC-74 09:55:38	EDIT BY LARSON
;<LARSON>BATCON.MAC;86    20-DEC-74 09:13:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;85    20-DEC-74 08:26:20	EDIT BY LARSON
;<LARSON>BATCON.MAC;84    19-DEC-74 11:53:40	EDIT BY LARSON
;<LARSON>BATCON.MAC;83    19-DEC-74 11:49:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;82    19-DEC-74 10:51:38	EDIT BY LARSON
;<LARSON>BATCON.MAC;81    19-DEC-74 09:05:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;80    19-DEC-74 08:24:30	EDIT BY LARSON
;<LARSON>BATCON.MAC;79    18-DEC-74 17:00:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;78    18-DEC-74 15:26:44	EDIT BY LARSON
;<LARSON>BATCON.MAC;77    18-DEC-74 08:41:02	EDIT BY LARSON
;<LARSON>BATCON.MAC;76    18-DEC-74 08:29:26	EDIT BY LARSON
;<LARSON>BATCON.MAC;75    17-DEC-74 16:00:36	EDIT BY LARSON
;<LARSON>BATCON.MAC;74    17-DEC-74 09:40:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;73    17-DEC-74 09:21:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;72    17-DEC-74 09:15:18	EDIT BY LARSON
;<LARSON>BATCON.MAC;71    17-DEC-74 08:35:40	EDIT BY LARSON
;<LARSON>BATCON.MAC;70    16-DEC-74 16:50:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;69    16-DEC-74 16:07:50	EDIT BY LARSON
;<LARSON>BATCON.MAC;67    16-DEC-74 11:32:16	EDIT BY LARSON
;<LARSON>BATCON.MAC;66    10-DEC-74 11:58:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;65    10-DEC-74 11:48:59	EDIT BY LARSON
;<LARSON>BATCON.MAC;64    10-DEC-74 11:31:59	EDIT BY LARSON
;<LARSON>BATCON.MAC;63    10-DEC-74 11:07:56	EDIT BY LARSON
;<LARSON>BATCON.MAC;62    10-DEC-74 10:56:41	EDIT BY LARSON
;<LARSON>BATCON.MAC;61    10-DEC-74 10:33:29	EDIT BY LARSON
;<LARSON>BATCON.MAC;60    10-DEC-74 10:19:02	EDIT BY LARSON
;<LARSON>BATCON.MAC;54    16-NOV-74 13:24:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;53    15-NOV-74 08:59:00	EDIT BY LARSON
;<LARSON>BATCON.MAC;52    14-NOV-74 15:37:47	EDIT BY LARSON
;<LARSON>BATCON.MAC;51     4-NOV-74 15:17:24	EDIT BY LARSON
;<LARSON>BATCON.MAC;50    30-OCT-74 23:11:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;44    21-OCT-74 16:44:40	EDIT BY LARSON
;PUT IN PSI STUFF FOR EOF AND FILE ERRORS
;<LARSON>BATCON.MAC;40    14-OCT-74 17:27:19	EDIT BY LARSON
;FIXED ERR1 OPERATION
;<LARSON>BATCON.MAC;39    14-OCT-74 14:31:46	EDIT BY LARSON
;USED CONNECTED DIR, ACCT 1
;<LARSON>BATCON.MAC;31     3-OCT-74 09:22:27	EDIT BY LARSON
;<LARSON>BATCON.MAC;29     2-OCT-74 13:48:10	EDIT BY LARSON
;<LARSON>BATCON.MAC;28     1-OCT-74 13:43:48	EDIT BY LARSON
;ADDED END: AND FIXED SOME BUGS.
;<LARSON>BATCON.MAC;27    30-SEP-74 09:47:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;25    29-SEP-74 18:20:05	EDIT BY LARSON
;<LARSON>BATCON.MAC;21    26-SEP-74 16:16:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;18    20-SEP-74 09:08:46	EDIT BY LARSON
;<LARSON>BATCON.MAC;16    19-SEP-74 17:34:49	EDIT BY LARSON
;<LARSON>BATCON.MAC;14    13-SEP-74 18:38:22	EDIT BY LARSON
	TITLE	BATCON	BATCH CONTROLLER FOR TENEX
	SUBTTL	SUBTTL  BATCH PROCESSOR

	SEARCH	STENEX

;PTY OPDEFS
OPDEF	ASPTY	[JSYS 360]
OPDEF	REPTY	[JSYS 361]
OPDEF	PSTI	[JSYS 362]
OPDEF	PSTO	[JSYS 363]
OPDEF	SIBF	[JSYS 364]

;LUUO OPDEFS
OPDEF	ERR1	[1B8]

;ASSEMBLY SWITCHES
IFNDEF	FSUSER,<FSUSER==0>		;USER/SINGLE JOB VERSION
IFNDEF	FSTCPY,<FSTCPY==1>		;TRIM Q VIA COPY AND RENAME
					;INSTEAD OF RESET POINTER.

;VARIABLE DEFINITIONS
NAPMIN==^D250				;MINIMUM NAP TIME
NAPMAX==^D15000				;MAXIMUM NAP TIME - SUPERSEDED BY
					;NAPMIN IF "NAPMIN>NAPMAX"
MAXFK==16				;MAXIMUM NUMBER OF ACTIVE INFERIOR FORKS

CTLL==<^D100/5>+1			;MAX LENGTH OF CTL LINE
LOGL==<^D132/5>+1			;MAX LENGTH OF LOG LINE TO WRITE
PDLL==47				;SIZE OF PUSH DOWN LIST

;DEVICE DESIGNATORS.
DEVDSK==600000				;DSK:
DEVLPT==600007				;LPT:
DEVNIL==600015				;NIL:

CCODE==0				;INDEXES TO COMMAND QUEUE SUBFIELDS
CPARAM==1
CTIME==2
COPER==3

;JOB STATUS BIT DEFINITIONS
FEXIST==1B0		;FORK EXISTS MANAGING THIS JOB
FHLTED==1B1		;MANAGING FORK HALTED
FFREEZ==1B2		;MANAGING FORK FROZEN
FPURGE==1B3		;PURGE THIS JOB FROM QUEUE
FRESET==1B4		;RESET BATCON FLAGS FOR THIS JOB IN QUEUE
FDEFER==1B5		;DEFER EXECUTION OF THIS JOB INDEFINITELY
FFSTRT==1B6		;FORCE START THIS JOB
FINQUE==1B7		;THIS JOB EXISTS IN THE QUEUE


;FLAGS IN F
R.SEOL==1				;INTERNAL FLAG FOR RDCTL TO TELL ITSELF
					;THAT IT MUST SUPPRESS THE END OF THE
					;LINE (TRALING SPACES AND TERMINATOR)

R.SEMI==R.SEOL*2			;RDCTL RETURNS THIS FLAG TO TELL
					;THAT THIS LINE IS A COMMENT, AND THAT
					;IT SHOULD JUST BE COPIED TO THE
					;LOG FILE--DO NOT PASS IT TO THE
					;USER.  (IT IS NOT GUARANTEED TO
					;START WITH A ;).

R.MONC==R.SEMI*2			;THIS LINE IS TO GO TO THE MONITOR
					;(OR EXEC) LEVEL COMMAND INTERPETER

R.INTR==R.MONC*2			;THIS LINE CAN GO TO EITHER MONITOR
					;OR USER LEVEL, IT IS NOT SPECIFIED

R.USER==R.INTR*2			;THIS LINE GOES TO A USER LEVEL
					;PROGRAM AS DATA OR A COMMAND

R.BLNK==R.USER*2			;THIS PUT A BLANK LINE ON THE LOG
					;FILE, DO NOT PASS THIS LINE TO
					;THE USER JOB, DO NOT COPY THIS
					;LINE TO THE LOG FILE.

R.PCTF==R.BLNK*2			;THIS IS A FLAG INDICATING THAT
					;RESOURCE CONTROL INSTRUCTIONS
					;PRECEEDED THIS LINE.  DISPOSITION
					;DEPENDS ON WHETHER ENTERING EXEC
					;MODE OR CONTINUING IS PRESENT MODE.

R.RCTL==R.SEOL!R.SEMI!R.MONC!R.INTR!R.USER!R.BLNK	;ALL THE FLAGS SET BY
					;RDCTL, DEFINED FOR WHERE WE ZERO THEM
					;ALL AT ONCE.


L.NOEL==1				;FLAG TO TELL SNDLOG TO SUPPRESS THE CRLF


;MACRO DEFINITIONS
	DEFINE	ERROR(MSG,TO<0>)<
	XLIST
	ERR1	[TO,,[ASCIZ \MSG\]]
	LIST
	>


	DEFINE	BUG(STR,ADR<0>)<
;BUG MESSAGE AND HANDLING ROUTINE
;ON ENTRY:	@0(P) + 0  =  ADR OF BUG STRING
;		      + 1  =  RETURN ADDRESS
;		-1(P)  =  ADDRESS OF ERROR OCCURRENCE
;
;IF RETURN ADDRESS  = 0, GET MESSAGE, DUMP, AND RESTART/RELOAD
;		   GT 0, GET MESSAGE TO TTY0, CRASH FILE, AND SYSTEM
;			 PEOPLE, THEN CONTINUE AT RETURN ADDRESS

	XLIST
	PUSHJ	P,[PUSHJ P,BUGMSG
		[ASCIZ /STR/]
		ADR]
	LIST
	>				;END BUG MACRO


;MACRO TO TURN OFF INTERRUPT SYSTEM
	DEFINE	NOINT<
	PUSH	P,A
	MOVEI	A,400000
	SKPIR
	SKIPA
	DIR
	POP	P,A>

;MACRO TO TURN ON INTERRUPT SYSTEM
	DEFINE	OKINT<
	PUSH	P,A
	MOVEI	A,400000
	SKPIR
	EIR
	POP	P,A>


	SUBTTL	PRIMARY FORK CODE

;INITIALIZATION
START:	JRST	START0			;NORMAL START

START0:	RESET				;CLEAN ALL THINGS UP

	SETZ	0,			;CLEAR REGISTERS
	MOVEI	P,1
	BLT	P,16

	SETO	A,			;RELEASE ALL PTY'S
	REPTY
	BUG(<START: Error releasing PTY's>)
	MOVE	P,[IOWD PDLL,PDL]	;INITIALIZE THE STACK
	MOVE	A,116			;GET THE SYMBOL TABLE POINTER
	MOVEM	A,SYMPTR		;AND PUT IT WHERE THE INFERIORS 
					;CAN GET IT

	MOVE	A,[SIXBIT /TTYJOB/]	;GET SYSTEM TABLE NUMBERS
	SYSGT
	HRRZM	B,TTYJOB
	MOVE	A,[SIXBIT /JOBTTY/]
	SYSGT
	HRRZM	B,JOBTTY
	MOVE	A,[SIXBIT /JOBRT/]
	SYSGT
	HRRZM	B,JOBRT
	MOVE	A,[SIXBIT /JOBNAM/]
	SYSGT
	HRRZM	B,JOBNAM
	MOVE	A,[SIXBIT /SNAMES/]
	SYSGT
	HRRZM	B,SNAMES
	MOVE	A,[SIXBIT /JOBDIR/]
	SYSGT
	MOVEM	B,JOBDIR

;DETERMINE OUR STATUS (AND ENABLE OURSELF)
	SETZM	WHEEL			;ASSUME NON-WHEEL
	MOVEI	A,400000		;US
	RPCAP				;SEE WHAT WE HAVE
	MOVE	C,B			;ALL POSSIBLE
	EPCAP				;TURN THEM ON
	TRNE	C,600000		;WHEEL OR OPER?
	SETOM	WHEEL			;YES

;ARE WE DETACHED?
	GJINF				;FIND OUT ABOUT OURSELVES.
	MOVEM	D,DETSW			;SAVE STATUS
	MOVEM	C,JOBNO			;SAVE OUR JOB #
	SETOM	MYNAME			;SAY I'M THE TOP GUY IN THE PRIV PAGE
	MOVEI	A,101			;PRIMARY OUTPUT IS CRASH FILE
	MOVEM	A,CRSHJF		;FOR NOW

;CHECK IF WE HAVE TIME YET
WAITS:	GTAD			;GET WHAT WE HAVE
	CAME	A,[-1]		;GOT IT ?
	JRST	UUOINI		;YES, GO ON
	MOVEI	A,^D60000	;WAIT ONE MINUTE
	DISMS			;ZZZZ
	JRST WAITS		;DON'T GO ON TILL WE HAVE IT!!!!!
UUOINI:	MOVEM	A,BATSTT	;BATCH PROCESSOR START TIME

;INITIALIZE LUUO TRAP

	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

	MOVEI	A,400000		;PRESENT FORK
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	MOVE	A,[XWD ^D19,2]
	ATI			;SET ^S FOR INFERIOR FORK STATUS
	MOVEI	A,400000
	HRLZI	B,100000	;INFERIOR HALTED AND ^S STATUS CHANNELS
	HRRI	B,200000
	AIC
	OKINT

;INITIALIZE FLAGS
	SETZ	ZZ,			;CLEAR FLAG WORD
	SETZM	STRTFK			;CLEAR INFERIOR STARTING FLAGS
	SETZM	HLTDFK			;CLEAR INFERIOR HALTED FLAGS
	SETOM	ENTFLG			;SET ENTRY FLAG TO ALLOW EVERYONE
	SETZM	JOBHLT			;SET BATCON TO RUN
	SETOM	SNDLCK			;CLEAR ROUTINE LOCKS
	SETOM	BUGLCK
	SETOM	DAYLCK
	SETOM	WHOSND			;CLEAR USER INFORMATION
	SETOM	WHOBUG
	SETOM	WHODAY
	SETZM	FORK			;SNDMSG FREE
	SETZM	RELFRK
	SETZM	FORCST
	SETZM	CTLTSK			;FRESH CONTROL TASK COUNTER

	MOVE	A,[XWD FKSTAT,FKSTAT+1]	;CLEAR FORK STATUS ARRAY
	SETOM	FKSTAT
	BLT	A,FKSTAT+MAXFK

	MOVE	A,[XWD JBSTAT,JBSTAT+1]	;CLEAR JOB STATUS PAGE
	SETZM	JBSTAT
	BLT	A,JBSTAT+777

	IFN	GDDT,<
	PUSHJ	P,SETDDT	;SET UP DDT
	>

IFE	FSUSER,<			;STUFF IF SYSTEM BATCH
;DO A SETNM SO WE HAVE A NAME
	MOVE	A,[SIXBIT /BATCON/]	;OUR NAME IS 'BATCON'
	SETNM				;SET IT

;NOW GET CONNECTED TO THE BATCH Q DIRECTORY
	MOVEI	A,1			;TRY EXACT MATCH
	HRROI	B,BATDIR		;DIRECTORY NAME
	STDIR				;GET DIR #
	BUG(<Error return from STDIR for Q directory--no match>)
	BUG(<Error return from STDIR for Q directory--ambiguous>)
	TLZ	A,-1			;CLEAR LH
	MOVEM	A,BATDN			;SAVE SO WE CAN EXPUNGE DIR LATER
	SETZ	B,			;NO PASSWORD STRING
	CNDIR				;CONNECT TO IT
	BUG(<CNDIR to Q directory failed>)
;SETUP FILE TO GET BUG MESSAGES
	MOVSI	A,1			;SHORT
	HRROI	B,CRASH			;CRASH MESSAGE FILE NAME
	GTJFN
	BUG(<START: Error on GTJFN for crash file>)
	MOVEM	A,CRSHJF		;SAVE CRASH FILE MESSAGE JFN

	SKIPL	DETSW			;ARE WE DETACHED?
	JRST CRSHJ1			;NO,DON'T BOTHER SETTING TTY
	MOVEI	A,400000		;DETACHED - SET UP TTY0 AS PRIMARY
	MOVE	B,[XWD -1,400000]	;INPUT = CTL TTY, OUTPUT = TTY0
	SPJFN

CRSHJ1:
;[edit] messes up DDT and stuff on stand alone system
;;;	HRRZ	B,A			;OUTPUT JFN
;;;	MOVEI	A,400000		;THIS FORK
;;;	SPJFN				;MESSAGES TO FILE INSTEAD OF LOGGING TTY
	>				;END IFE FSUSER

	PUSHJ	P,QUECOP		;GO SCAN THROUGH QUEUE TO SET UP
					;JOB STATUS INFORMATION

	SETZM	CTLJFN			;SEND STARTUP MSG TO DAYFILE
	MOVE	A,BATDN
	MOVEM	A,QENT+USRDIR
	SETZM	QENT+BJOBNO
	HRROI	B,[ASCIZ /


*****[BATCON /]
	HRROI	C,[ASCIZ / RESTARTING AT /]
	PUSHJ	P,DAY

IFE	FSUSER,<			;GENERATE SYSTEM BATCON STUFF
;SCAN THE QUEUES FOR A JOB TO RUN, THEN SET UP THE
;PARAMETERS FOR THE RUN.

;FIRST, OPEN THE BATCH QUEUE
GETJOB:	

;NOW CHECK FOR ANY WORK TO ADD TO THE QUEUE
	MOVSI	A,(1B2!1B7!1B11!1B17)	;OLD,NO OTHER ACCESS,INPUT,*,SHORT
	HRROI	B,JBNAMS		;GET FORMAT OF JOB NAMES
	GTJFN				;GET THE JFN
	JRST	GETDSB			;NONE, CHECK FOR DESUBMISSIONS
	PUSH	P,A			;SAVE GROUP JFN

	MOVSI	A,(1B7!1B17)		;GET Q, NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG(<GETJOB: Gtjfn failure for Q>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

	MOVE	B,[1,,FDBUSW]		;GET THE USER SETTABLE WORD
	MOVEI	C,MXJBNO#		;WHERE TO PUT IT
	GTFDB
	MOVE	A,QJFN			;GET JFN OF Q
	MOVE	B,[44B5+1B22]		;OPEN FOR 36 BIT, APPEND
	QOPENF				;OPEN THE Q
	BUG	(<GETJOB: CANNOT OPEN Q FOR APPEND>)
	BUG	(<GETJOB: TIME OUT OPENING Q>,QOPTMO)

GETJB0:	MOVE	A,[POINT 36,QENT]	;BUFFER FOR JOB FILE ENTRY
	PUSHJ	P,CHKFIL		;OPEN JOB FILE, GET FDB, GET
					;ENTRY, AND CHECK VALIDITY
	JRST	GETJB1			;BAD ENTRY - DELETE IT
	JFCL				;GOOD ONE - USER NOT WHEEL
	HLRZ	C,FDBBLK+7		;GOOD ONE - WHEEL, GET VERSION
	CAMGE	C,MXJBNO		;GREATER THAN GREATEST
	 JRST	GETJB3			;NO
	AOS	C			;1 GREATER
	MOVEM	C,MXJBNO		;NEW MAXIMUM
	MOVE	A,QJFN			;JFN FOR Q
	HRLI	A,FDBUSW		;WORD TO CHANGE
	MOVEI	B,777			;WRAP AROUND AT 512
	CHFDB				;NEW VALUE
	HRRZ	A,0(P)			;GET JFN AGAIN FOR JOB FILE

;APPEND IT TO MASTER QUEUE - IT WAS LEGAL

GETJB3:	MOVE	A,QJFN			;GET Q'S JFN
	MOVE	B,[POINT 36,QENT]
	MOVNI	C,QESIZE		;IT'S LENGTH
	SOUT				;WRITE IT

	MOVE	A,QENT+BJOBNO		;SET UP JOB STATUS ENTRY TO SHOW
	MOVSI	B,(FINQUE)		;JOB IS IN QUEUE
	HRLZ	C,QENT+USRDIR		;ADD ON USER DIRECTORY NUMBER
	ADD	B,C
	MOVEM	B,JBSTAT(A)		;SAVE THE INFO IN JOB STATUS TABLE


;DELETE IT
GETJB1:	SETO	A,			;DELETE CURRENT FILE AND SEE IF
	PUSHJ	P,NXTFIL		;THERE IS MORE
	SKIPA				;NO MORE
	JRST	GETJB0			;ANOTHER ONE THERE - GO BACK

	POP	P,A			;GET JFN WE USED

	MOVE	A,QJFN			;CLOSE Q FOR NOW AND RELEASE JFN
	CLOSF
	BUG	<(CANNOT CLOSE Q JFN>)

;NOW CHECK FOR ANY WORK TO DELETE FROM THE QUEUE

GETDSB:	MOVSI	A,(1B2!1B7!1B11!1B17)	;OLD,NO OTHER ACCESS,INPUT *,SHORT
	HRROI	B,DJBNMS		;GET FORMAT OF JOB NAMES
	GTJFN				;GET THE JFN
	JRST	GETCTL			;NONE - GO LOOK FOR CONTROL TASKS
	PUSH	P,A			;SAVE GROUP JFN

OPDREQ:	MOVE	A,[POINT 36,DQENT]	;BUFFER FOR DESUBMIT REQUESTS
	PUSHJ	P,CHKFIL		;GO OPEN FILE, GET FDB, READ
					;REQUEST, AND CHECK VALIDITY
	JRST	DELDRQ			;NO GOOD - GO DELETE IT
	JFCL				;GOOD - NOT WHEEL

	MOVE	A,DQENT+BJOBNO		;GET JOB NUMBER AND STATUS INFORMATION
	MOVE	B,JBSTAT(A)		;FOR IT
	HLRZ	C,B			;ISOLATE USRDIR FOR THIS JOB
	ANDI	C,777
	CAME	C,DQENT+USRDIR		;IS THIS REQUEST LIGIT?
	JRST	DELDRQ			;NO - DELETE REQUEST

	NOINT				;TURN OFF INTERRUPTS
	PUSHJ	P,JOBSIT		;CHECK JOB SITUATION
	JRST	DELDRQ			;NO SUCH JOB - DELETE REQUEST
	JRST	SETDEL			;NOT RUNNING - POST PURGE BIT
	JRST	DELDRQ			;ALREADY HALTED - GO ON
	JRST	STOPRN			;RUNNING FROZEN - MELT AND STOP
	JRST	INTINF			;RUNNING MELTED - STOP IT

SETDEL:	TLO	B,(FPURGE)		;SET PURGE BIT
	MOVEM	B,JBSTAT(A)
	SETOM	RUNQCP			;SET TO RUN Q COPY
	JRST	DELDRQ			;NEXT REQUEST

;	MELT FROZEN FORK
STOPRN:	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;MELT IT

;	STOP INFERIOR WITH DESUBMIT INTERRUPT - CAUSES GRACEFUL CLEANUP
INTINF:	MOVE	A,DQENT+BJOBNO		;HAVE TO STOP A RUNNING JOB
	MOVEM	A,QENT+BJOBNO		;SO POST A DAY FILE MSG
	MOVE	B,DQENT+USRDIR
	MOVEM	B,QENT+USRDIR
	SETZM	CTLJFN
	HRROI	B,JOBDAY
	HRROI	C,[ASCIZ / RUNNING JOB DESUBMITTED AT /]
	PUSHJ	P,DAY			;GO SEND IT

	MOVE	A,DQENT+BJOBNO		;GET FORK HANDLE
	HRRZ	A,JBSTAT(A)
	MOVSI	B,(1B1)			;PSEUDO INTERRUPT ON CHANNEL 1
	IIC				;THIS WILL SET HALTED AND PURGE BITS
	JRST	DELDRQ			;THIS REQUEST TAKEN CARE OF -
					;GO TRY ANOTHER

;	DELETE DESUBMIT JOB REQUEST
DELDRQ:	OKINT				;REENABLE INTERRUPTS
	SETO	A,			;DELETE THIS ONE AND CHECK FOR MORE
	PUSHJ	P,NXTFIL
	SKIPA				;NO MORE
	JRST	OPDREQ			;GOT ANOTHER ONE - GO BACK

	POP	P,A			;GET JFN WE USED


;NOW SEE IF THERE ARE ANY CONTROL TASK REQUESTS - CJOB.*;*

GETCTL:	MOVSI	A,(1B2!1B7!1B11!1B17)	;OLD, NO ACCESS, *, SHORT
	HRROI	B,CJBNMS		;CJOB FILES
	GTJFN
	JRST	GETJB2			;NONE - GO EXPUNGE AND CHECK FOR
					;JOBS TO RUN
	PUSH	P,A			;YES, SAVE GROUP JFN ON STACK
	MOVEI	D,COMBUF		;POINT TO COMMAND BUFFER
	GTAD				;GET CURRENT TIME AND DATE
	MOVEM	A,NOWTIM		;SAVE IT FOR LATER

;NOW READ ALL EXECUTABLE COMMANDS INTO THE BUFFER AND SCAN THEM FROM THE
;OLDEST TO THE MOST RECENT FOR EXECUTION

PRCCTL:	MOVE	A,[POINT 36,QENT]	;BUFFER FOR CONTROL REQUEST -
					;MUST BE QENT BECAUSE FOLLOWING
					;USES "PRINT"
	PUSHJ	P,CHKFIL		;OPEN FILE, GET FDB, GET ENTRY,
					;AND CHECK VALIDITY
	JRST	DELCTL			;NO GOOD - DELETE IT
	JRST	NOTWHL			;NO GOOD - NOT A WHEEL
	SETZM	CTLJFN			;ZERO CONTROL JFN
	MOVE	A,QENT+COMCOD		;GET CONTROL CODE
	CAIL	A,0			;IS IT IN RANGE?
	CAILE	A,MCTLCD
	JRST	.ERRNG			;CODE IN ERROR - SEND MSG

	LSH	A,1			;CODE OK, INDEX DISPATCH ENTRY
	PUSH	P,A			;SAVE IT

	HRR	B,CTLDSP(A)		;MAKE STRING PTR FOR OUR DESCRIPTOR
	HRLI	B,440700
	MOVE	A,[POINT 7,QENT+COMNAM]	;GET STRING PTR FOR INPUT COMMAND
	PUSHJ	P,STRCMP		;GO COMPARE STRINGS
	JFCL				;DON'T MATCH
	JRST	.ERCMP			;NOT SAME LENGTH - GO LOG ERROR

					;OK, COMMAND IS GOOD.  DOES IT HAVE
					;A TIME TRIGGER READY TO FIRE?
	MOVE	A,QENT+AFTER		;CHECK FOR "AFTER JOB" REQUEST
	TLNE	A,-1			;LEFT HALF EMPTY?
	JRST	PRCCT1			;NO - MUST BE A DATE
	ANDI	A,777			;YES - EITHER NULL OR JOB REQUEST
	SKIPE	JBSTAT(A)		;IF JOB SPECIFIED AND IT'S STILL AROUND,
PRCCT0:	JRST	[POP	P,A		;DON'T RUN THIS ONE UNTIL IT IS GONE
		 SETZ	A,
		 JRST	NXTCTL]
	MOVE	A,NOWTIM		;OK JOB IS DONE - SET CURRENT
	MOVEM	A,QENT+AFTER		;DATE AND TIME AS EXECUTION TIME

PRCCT1:	MOVE	A,NOWTIM		;GET CURRENT TIME
	CAMN	A,[-1]			;WAS IT -1?
	JRST	PRCCT0			;REFUSE ALL TASKS IF TIME NOT SET
	CAMGE	A,QENT+AFTER		;CHECK IF IT CAN BE RUN YET.
	JRST	PRCCT0			;IT WANTS TO WAIT SOME MORE.
		 
	POP	P,A			;OK TO GO, RECOVER INDEX TO DISPATCH
	MOVEM	A,CCODE(D)		;ENTRY AND PUT IT IN THE COMM QUEUE
	MOVE	A,QENT+COMPAR		;SAVE THE COMMAND PARAMETER
	MOVEM	A,CPARAM(D)
	MOVE	A,QENT+AFTER		;WAS THIS A DELAYED COMMAND?
	TLNN	A,-1			;IF SO, USE ACTIVATION DATE
	MOVE	A,QENT+ENTERD		;ELSE USE TIME COMMAND ISSUED
	MOVEM	A,CTIME(D)
	MOVE	A,QENT+USRDIR		;SAVE THE ORIGINATOR
	MOVEM	A,COPER(D)

	ADDI	D,4			;BUMP QUEUE PTR, DELETE THIS FILE,
	JRST	DELCTL			;AND SEE IF THERE ARE MORE



;ERROR HERE - USER IS NOT A WHEEL AND HAS ISSUED A CONTROL COMMAND
NOTWHL:	HRROI	A,STRBUF		;NON-WHEEL TRYING - LOG IT
	HRROI	B,[ASCIZ /
** NON-WHEEL </]
	SETZ	C,
	SOUT
	HLRZ	B,FDBBLK+6		;GET AUTHOR
	DIRST
	JFCL				;IGNORE ERROR
	HRROI	B,[ASCIZ /> BATCH CTL REQUEST /]
	SOUT
	MOVEI	A,101			;DO PRIMARY TTY FIRST
	HRROI	B,STRBUF
	SETZ	C,
	SOUT
	MOVEI	B,37			;DO CRLF'S
	BOUT
	BOUT

	MOVE	A,0(P)			;GET FILE JFN
	HRROI	B,STRBUF		;NOW ENTER IN CRASH FILE
	HRROI	C,[ASCIZ / - FILE DELETED
**********
/]
	PUSHJ	P,BUGFIL		;ADD FILE NAME
	HRROI	B,BUGSTR
	PUSHJ	P,SNDCSH		;SEND TO CRASH FILE

	JRST	DELCTL


;ERROR HERE - COMMAND CODE IS NOT IN THE RANGE OF OUR DISPATCH TABLE
.ERRNG:	HRROI	A,STRBUF		;COMPOSE MESSAGE
	HRROI	B,[ASCIZ / OUT OF RANGE - FILE DELETED
    BAD CODE = /]
	SETZ	C,
	SOUT
	MOVE	B,QENT+COMCOD		;ADD COMMAND CODE
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / (OCTAL)
**********
/]
	SETZ	C,
	SOUT

	MOVE	A,0(P)			;GET FILE JFN
	HRROI	B,[ASCIZ /
CJOB CONTROL CODE ON /]
	HRROI	C,STRBUF
	PUSHJ	P,BUGFIL		;OUTPUT ERROR ON CRASH FILE
	HRROI	B,BUGSTR
	PUSHJ	P,SNDCSH

	HRROI	B,JOBCTL		;POST DETAILS IN DAY FILE
	HRROI	C,[ASCIZ / CONTROL CODE OUT OF RANGE AT /]
	PUSHJ	P,DAY

        JRST	DELCTL			;GO DELETE REQUEST


;ERROR HERE - COMMAND DESCRIPTOR MISMATCH BETWEEN INPUT COMMAND AND OUR
;DISPATCH TABLE
.ERCMP:	HRROI	A,STRBUF		;COMPOSE MESSAGE
	HRROI	B,[ASCIZ / DOESN'T MATCH - FILE DELETED
    INPUT CODE = /]
	SETZ	C,
	SOUT
	MOVE	B,QENT+COMCOD		;ADD COMMAND CODE
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / (OCTAL)
    INPUT DESCRIPTOR = </]
	SETZ	C,
	SOUT
	MOVE	B,[POINT 7,QENT+COMNAM]	;GET STRING PTR FOR INPUT COMMAND
	SOUT
	HRROI	B,[ASCIZ />
    OUR DESCRIPTOR = </]
	SOUT
	EXCH	A,0(P)			;FETCH CODE INDEX TEMPORARILY
	HRR	B,CTLDSP(A)		;MAKE STRING PTR FOR OUR DESCRIPTOR
	HRLI	B,440700
	POP	P,A			;GET BACK STRING POINTER
	SOUT
	HRROI	B,[ASCIZ />
**********
/]
	SOUT

	MOVE	A,0(P)			;GET FILE JFN
	HRROI	B,[ASCIZ /
CJOB CONTROL DESCRIPTOR ON /]
	HRROI	C,STRBUF
	PUSHJ	P,BUGFIL		;OUTPUT ERROR ON CRASH FILE
	HRROI	B,BUGSTR
	PUSHJ	P,SNDCSH

	HRROI	B,JOBCTL		;POST DETAILS IN DAY FILE
	HRROI	C,[ASCIZ / CONTROL CODE MISMATCH AT /]
	PUSHJ	P,DAY

        JRST	DELCTL			;GO DELETE REQUEST



;HERE WE CLEAN UP A REQUEST FILE AND CYCLE IF THERE ARE MORE

DELCTL:	SETO	A,			;DELETE THIS FILE AND GET THE NEXT
NXTCTL:	PUSHJ	P,NXTFIL
	SKIPA				;NO MORE FILES
	JRST	PRCCTL			;HAVE ANOTHER ONE - GO DO IT

	POP	P,A			;RECOVER GROUP JFN


;OK, AT THIS POINT WE HAVE ALL OF THE CURRENT COMMANDS IN THE QUEUE.  SEE IF
;THERE REALLY ARE ANY AND PROCEED TO EXECUTE THEM, STARTING WITH THE OLDEST.

	SUBI	D,COMBUF		;COMPUTE COMMAND COUNT
	LSH	D,-2
	JUMPLE	D,GETJB2		;NONE TO WORRY ABOUT.  GO LOOK AT
					;JOBS TO BE RUN

	PUSH	P,D			;GOT SOME, SAVE THE COUNT
SCNCOM:	SETOM	QPNTR			;SET UP POINTERS TO SCAN THE Q
	MOVE	A,[XWD 377777,777777]	;GREAT BIG DATE
	MOVEM	A,BESTPR
	MOVN	D,0(P)			;SET LOOP COUNTER
	MOVEI	C,COMBUF		;BUFFER ADDRESS

BSTCOM:	SKIPG	B,CTIME(C)		;STILL WAITING
	JRST	TRYNXT			;NO, LOOK SOME MORE
	CAMLE	B,BESTPR		;AGE AS GOOD OR BETTER THAN BEST?
	JRST	TRYNXT			;NO, LOOK SOME MORE
	MOVEM	B,BESTPR		;YES, SAVE THIS COMMAND TIME AND
	MOVEM	C,QPNTR			;ADDRESS

TRYNXT:	ADDI	C,4			;BUMP Q ADDRESS
	AOJN	D,BSTCOM		;SCAN THEM ALL

	SKIPG	B,QPNTR			;ARE THEY ALL EXECUTED?
	JRST	COMCLN			;YES, GO CLEAN UP

	SETZM	CTIME(B)		;NO, FLAG THIS ONE AS BEING DONE
	AOS	CTLTSK			;BUMP CONTROL TASK NUMBER
	MOVE	A,CTLTSK		;AND LABEL THIS COMMAND
	MOVEM	A,QENT+BJOBNO
	MOVE	A,COPER(B)		;IDENTIFY THE ORIGINATOR
	MOVEM	A,QENT+USRDIR
	MOVE	A,CCODE(B)		;PUT COMMAND INDEX IN A
	MOVE	B,CPARAM(B)		;AND THE PARAMETER IN B

	JRST	@CTLDSP+1(A)		;DISPATCH TO EXECUTE THE COMMAND

;HERE WE HAVE DONE ALL THE COMMANDS.  UNMAP THE QUEUE PAGE(S) AND GO LOOK
;FOR JOBS TO RUN
COMCLN:	SETO	A,			;SET TO REMOVE PAGES
	HRRI	B,COMBUF/1000		;FIRST PAGE
	HRLI	B,400000		;OUR FORK
	SETZ	C,			;ZERO ACCESS
	POP	P,D			;RESTORE STACK AND GET ENTRY COUNT
	IMULI	D,4			;NUMBER OF WORDS
	ADDI	D,777			;ROUND UPWARD
	IDIVI	D,1000			;NUMBER PAGES
COMUMP:	PMAP				;RELEASE PAGE 1 OF BUFFER
	AOS	B
	SOJG	D,COMUMP		;DO THEM ALL

	JRST	GETJB2			;GO GET ANY JOBS TO RUN



;FOLLOWING ARE THE ROUTINES TO IMPLEMENT THE CONTROL FUNCTIONS:
; .BSTAT	PRINTS BATCON AND LOWER FORK STATUS ON PRIM TTY
; .BDUMP	OUTPUTS BATCON AND LOWER FORK STATUS TO CRASH FILE,
;		TEMPORARILY FREEZES LOWER FORKS, PRINTS AC CONTENTS TO
;		CRASH FILE, AND CREATES A DUMP FILE FOR EACH FORK XX
;		<BATCH>BATCON-DUMP.XX-MO/DAY/YR-HRMIN.  INFERIORS ARE
;		THEN RESUMED.
; .BHALT	FREEZES INFERIOR FORKS AND SETS JOBHLT SO NO MORE JOBS
;		ARE RUN
; .BRESM	RESUMES INFERIOR FORKS AND RESETS JOBHLT IF HALTED
; .BRSTR	KILLS INFERIORS, AND RESTARTS CURRENT BATCON IMAGE
; .BRLOD	KILLS INFERIORS, LOADS A NEW BATCON, AND RESTARTS
; .ENTFG	SETS ENTRY CONTROL FLAG
;		= -1  => RUN ANY JOB WHICH IS VALID
;		=  0  => DON'T RUN ANY JOB
;		>  0  => RUN ONLY JOBS WITH USRDIR = ENTFLG
; .AFTER	INVALID CODE - IGNORE FILE
; .EXIT		INVALID CODE - IGNORE FILE
; .CLEAR	INVALID CODE - IGNORE FILE
; .GOTO(ADR)	DOES A PUSHJ TO ADR, THEN CONTINUES
; .FREEZ(JOB #) FREEZE FORK RUNNING JOB(PARAM) IF RUNNING MELTED
; .MELT(JOB #)	MELT FORK RUNNING JOB(PARAM) IF RUNNING FROZEN
; .DEFER(JOB #)	IF RUNNING, KILL JOB(PARAM) AND SET QUEUE (JOBSTT) SO IT
;		WILL NOT BE RESTARTED INDEFINITELY
; .RESET(JOB #)	IF RUNNING, KILL JOB(PARAM) AND RESET QUEUE DATA SO NORMAL
;		SCHEDULING OF THE JOB RESUMES
; .START(JOB #)	IF JOB(PARAM) IS RUNNING, IGNORE REQUEST.  OTHERWISE START
;		THE JOB ON THE NEXT BATCON CYCLE(S) IRRESPECTIVE OF SCHED
;		PROTOCOL
; .PURGE(JOB #)	IF RUNNING, KILL JOB(PARAM) AND REMOVE IT FROM QUEUE


;OUTPUT BATCON STATUS
.BSTAT:	MOVEI	A,101			;PRIMARY OUTPUT
	SETZ	B,			;DON'T BOTHER THE FORKS
	PUSHJ	P,INFSTO		;OUTPUT STATUS

	SOS	CTLTSK			;RESTORE CONTROL TASK COUNTER

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK

;DUMP SNAP SHOT OF BATCON AND LOWER FORKS
.BDUMP:	NOINT				;DISABLE INTERRUPTS WHILE WE
					;MESS WITH CURRENT FORKS

	MOVEM	P,CSHACS+P		;SAVE OUR AC CONTENTS AT ENTRY
	MOVEI	P,CSHACS
	BLT	P,CSHACS+16
	MOVEI	P,.BDUMP		;SAVE CURRENT PC
	MOVEM	P,CSHPC			;SAVE IT
	MOVE	P,CSHACS+P		;RESTORE STACK

	MOVE	A,CRSHJF		;OPEN CRASH FILE
	MOVE	B,[7B5!1B22]		;7 BIT, APPEND
	QOPENF
	BUG	(<.BDUMP: ERROR OPENING CRASH FILE>)
	BUG	(<.BDUMP: TIME OUT OPENING Q>,DELCTL)
	GTAD				;GET DATE/TIME STAMP
	PUSH	P,A			;SAVE IT
	MOVE	A,CRSHJF		;OUTPUT STATUS AND FREEZE LOWER
	SETO	B,			;FORKS
	PUSHJ	P,INFSTO

	MOVE	B,0(P)			;RECOVER DATE/TIME STAMP
	MOVEI	C,400000		;OUR HANDLE
	PUSHJ	P,FRKDMP		;NOW DUMP OUR IMAGE

	MOVE	E,[IOWD MAXFK,2]	;DO THE SAME FOR OTHERS
DMPLOP:	SETO	B,			;IS THIS FORK HERE?
	CAMN	B,FKSTAT(E)
	JRST	NOFRK			;NO, THEN GO ON
	MOVE	A,CRSHJF		;OUTPUT JFN
	MOVE	B,0(P)			;GET DATE/TIME STAMP
	MOVEI	C,400000(E)		;FORK HANDLE
	PUSHJ	P,FRKDMP		;DUMP IT

NOFRK:	AOBJN	E,DMPLOP		;LOOK AT ALL FORKS

	POP	P,A			;CLEAR DATE/TIME STAMP

	MOVE	A,CRSHJF		;CLOSE CRASH FILE AND SAVE JFN
	TLO	A,(1B0)
	CLOSF
	BUG	(<.BDUMP:  ERROR CLOSING CRASH FILE>)

	MOVE	C,[IOWD MAXFK,2]	;NO, SCAN ALL FORKS
	MOVSI	B,(FFREEZ)
.BDMP0:	SETO	A,			;IS THIS FORK ACTIVE?
	CAMN	A,FKSTAT(C)
	JRST	.BDMP1			;NO - LOOK AT THE NEXT ONE
	HRRZ	A,FKSTAT(C)		;YES, GET JOB NUMBER
	TDNE	B,JBSTAT(A)		;SHOULD IT STAY FROZEN?
	JRST	.BDMP1			;YES
	MOVEI	A,400000(C)		;NO - RESUME IT
	RFORK
.BDMP1:	AOBJN	C,.BDMP0		;SCAN THEM ALL

.BDMP2:	OKINT				;REENABLE INTERRUPTS
	HRROI	B,JOBCTL		;ENTER IN DAY FILE
	HRROI	C,[ASCIZ / SNAPSHOT DUMP AT /]
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;HALT BATCON - FREEZE ALL INFERIORS
.BHALT:	SETOM	JOBHLT			;SET HALTED FLAG

	NOINT				;DISABLE INTERRUPTS
	MOVE	C,[IOWD MAXFK,2]	;SHOW EXISTING FORKS AS FROZEN
	MOVSI	B,(FFREEZ)
.BHAL0:	SETO	A,			;DOES THIS FORK EXIST
	CAMN	A,FKSTAT(C)
	JRST	.BHAL1			;NO - CHECK NEXT ONE
	MOVEI	A,400000(C)		;YES, GET FORK HANDLE
	FFORK				;AND MAKE SURE IT IS FROZEN
	HRRZ	A,FKSTAT(C)		;GET JOB NUMBER
	IORM	B,JBSTAT(A)		;SET FROZEN BIT
.BHAL1:	AOBJN	C,.BHAL0

	OKINT				;REENABLE INTERRUPTS
	HRROI	B,JOBCTL		;ENTER IN DAY FILE
	HRROI	C,[ASCIZ / BATCON HALTED AT /]
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;RESUME BATCON IF HALTED
.BRESM:	SETZM	JOBHLT			;REMOVE FLAG

	NOINT
	MOVE	C,[IOWD MAXFK,2]	;SHOW EXISTING FORKS AS MELTED
	MOVSI	B,(FFREEZ)
.BRES0:	SETO	A,			;DOES THIS FORK EXIST
	CAMN	A,FKSTAT(C)
	JRST	.BRES1			;NO - CHECK NEXT ONE
	MOVEI	A,400000(C)		;YES, GET THE FORK HANDLE
	RFORK				;AND MAKE SURE IT IS MELTED
	HRRZ	A,FKSTAT(C)		;GET JOB NUMBER
	ANDCAM	B,JBSTAT(A)		;TURN OFF FROZEN BIT
.BRES1:	AOBJN	C,.BRES0

	OKINT
	HRROI	B,JOBCTL		;DAY FILE ENTRY
	HRROI	C,[ASCIZ / BATCON RESUMED AT /]
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;RESTART CURRENT CORE IMAGE
.BRSTR:	HRROI	B,JOBCTL		;MAKE DAY FILE ENTRY BEFORE WE GO
	HRROI	C,[ASCIZ / BATCON RESTART AT /]
	PUSHJ	P,DAY

	SETZM	DBUGSW			;SET TO RESTART
	JRST	BATRST			;PULL THE CHAIN


;RELOAD A NEW CORE IMAGE
.BRLOD:	HRROI	B,JOBCTL		;MAKE DAY FILE ENTRY BEFORE WE GO
	HRROI	C,[ASCIZ / BATCON RELOAD AT /]
	PUSHJ	P,DAY

	MOVEI	A,DBUGFG		;GET DBUG FLAG (FROM PARAMS)
	MOVEM	A,DBUGSW		;SET TO RELOAD
	JRST	BATRST			;GO PULL THE CHAIN


;SET ENTFLG TO CONTROL JOB LOADING:
;	-1  => RUN ANYONE QUALIFYING
;	 0  => DON'T RUN ANYONE
;	>0  => RUN JOBS WITH DIRECTORY NUMBER - ENTFLG

.ENTFG:	SKIPGE	B			;IS PARAMETER POS DEF
	SETO	B,			;NO - SET TO -1
	MOVEM	B,ENTFLG		;SET NEW VALUE

	HRROI	A,BUGSTR		;MAKE DAYFILE ENTRY
	HRROI	B,[ASCIZ / ENTRY FLAG(8) = /]
	SETZ	C,
	SOUT
	MOVE	B,ENTFLG		;TACK ON VALUE
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL
	HRROI	C,BUGSTR
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;HANDLE GOTO COMMAND <ADR> IS IN STRTED

.GOTO:	PUSH	P,B			;SAVE THE GOTO ADDRESS
	HRROI	A,STRBUF		;COMPOSE MESSAGE
	HRROI	B,[ASCIZ / GOTO (/]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;ADD ADDRESS
	MOVEI	C,10			;OCTAL
	NOUT
	JRST	[MOVEI	B,"*"
		 BOUT
		 BOUT
		 BOUT
		 JRST	.+1]
	HRROI	B,[ASCIZ /) COMMAND AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE BEFORE
	HRROI	C,STRBUF		;WE DO SOMETHING DUMB
	PUSHJ	P,DAY

	POP	P,B			;GET ADDRESS BACK
	PUSHJ	P,0(B)			;GO TO IT

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;FREEZE THE JOB SPECIFIED IN PARAM
.FREEZ:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JFCL				;NOT IN Q
	JFCL				;FORK HASN'T BEEN STARTED
	JRST	.FREZ2			;FORK HALTED - IGNORE REQUEST
	JFCL				;FORK SEEMS TO BE FROZEN - MAKE SURE

	PUSH	P,A			;FORK RUNNING - SAVE JOB NUMBER
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	FFORK				;AND FREEZE THE FORK
	MOVE	A,0(P)			;SET FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	IORM	B,JBSTAT(A)

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	POP	P,B			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / FROZEN AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	PUSHJ	P,DAY

.FREZ2:	OKINT
	JRST	SCNCOM			;NEXT COMMAND



;MELT JOB SPECIFIED IN PARAM
.MELT:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JFCL				;NOT IN Q
	JFCL				;FORK HASN'T BEEN STARTED
	JRST	.MELT2			;FORK ALREADY HALTED
	JFCL				;FORK FROZEN - GO THAW IT
	JFCL				;FORK ALREADY MELTED - MAKE SURE

	PUSH	P,A			;SAVE JOB NUMBER
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND MELT THE FORK
	MOVE	A,0(P)			;REMOVE FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	POP	P,B			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / MELTED AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	PUSHJ	P,DAY

.MELT2:	OKINT
	JRST	SCNCOM			;NEXT COMMAND



;DEFER THE EXECUTION OF THE JOB IN PARAM - STOP IT IF RUNNING NOW
.DEFER:	NOINT				;NO INTERRUPTS
	PUSH	P,B			;SAVE JOB #
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.DEFR3			;NOT IN Q - IGNORE REQUEST
	JRST	.DEFR2			;FORK HASN'T BEEN STARTED - SET BIT
	JRST	.DEFR3			;FORK ALREADY HALTED - IGNORE REQUEST
	JRST	.DEFR0			;FORK FROZEN - GO THAW IT AND KILL IT
	JRST	.DEFR1			;FORK ALREADY MELTED - GO KILL IT

.DEFR0: HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND MELT THE FORK
	MOVE	A,0(P)			;REMOVE FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.DEFR1:	PUSHJ	P,FRCHLT		;GO FOR THE FORK TO HALT

.DEFR2:	MOVE	A,0(P)			;SET DEFER BIT IN JOB STATUS
	MOVSI	B,(FDEFER+FINQUE)
	MOVEM	B,JBSTAT(A)

	SETOM	RUNQCP			;SET TO RUN Q COPY

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / EXECUTION DEFERRED AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	PUSHJ	P,DAY

.DEFR3:	OKINT
	POP	P,B
	JRST	SCNCOM			;NEXT COMMAND



;RESET QUEUE STATUS OF JOB IN PARAM SO NORMAL RESCHEDULING OCCURS
.RESET:	NOINT				;NO INTERRUPTS
	PUSH	P,B			;SAVE JOB #
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.REST3			;NOT IN Q - IGNORE REQUEST
	JRST	.REST2			;FORK HASN'T BEEN STARTED - SET BIT
	JRST	.REST3			;FORK ALREADY HALTED - IGNORE REQUEST
	JRST	.REST0			;FORK FROZEN - GO THAW IT AND KILL IT
	JRST	.REST1			;FORK ALREADY MELTED - GO KILL IT

.REST0: HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND MELT THE FORK
	MOVE	A,0(P)			;REMOVE FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.REST1:	PUSHJ	P,FRCHLT		;GO FOR THE FORK TO HALT

.REST2:	MOVE	A,0(P)			;SET RESET BIT IN JOB STATUS
	MOVSI	B,(FRESET+FINQUE)
	MOVEM	B,JBSTAT(A)

	SETOM	RUNQCP			;SET TO RUN Q COPY

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / STATUS RESET AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	PUSHJ	P,DAY

.REST3:	OKINT
	POP	P,B
	JRST	SCNCOM			;NEXT COMMAND



;FORCE START THE JOB SPECIFIED BY PARAM
.START:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.STRT4			;NOT IN Q - IGNORE REQUEST
	JRST	.STRT1			;FORK HASN'T BEEN STARTED - FLAG IT
	JRST	.STRT4			;FORK ALREADY HALTED - IGNORE REQUEST
	JRST	.STRT2			;FORK FROZEN - GO THAW IT
	JRST	.STRT4			;FORK ALREADY MELTED - IGNORE REQUEST

.STRT1:	PUSH	P,A			;FORK RUNNING - SAVE JOB NUMBER
	MOVSI	B,(FFSTRT)		;SET FORCE START BIT
	IORM	B,JBSTAT(A)
	AOS	FORCST			;BUMP FORCE START COUNT
	JRST	.STRT3			;GO POST MESSAGE

.STRT2:	PUSH	P,A			;FORK FROZEN - SAVE JOB NUMBER
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND RESUME IT
	MOVE	A,0(P)			;RECOVER JOB NUMBER
	MOVSI	B,(FFREEZ)		;AND REMOVE FROZEN FLAG
	ANDCAM	B,JBSTAT(A)

.STRT3:	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	POP	P,B			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / FORCE START SET AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	PUSHJ	P,DAY

.STRT4:	OKINT
	JRST	SCNCOM			;NEXT COMMAND



;PURGE THE JOB SPECIFIED BY PARAM - KILL IT IF RUNNING
.PURGE:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSH	P,B			;SAVE JOB #
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.PURG3			;NOT IN Q - IGNORE REQUEST
	JRST	.PURG2			;FORK HASN'T BEEN STARTED - FLAG IT
	JRST	.PURG3			;FORK ALREADY HALTED - IGNORE REQUEST
	JFCL	.PURG0			;FORK FROZEN - GO THAW IT
	JRST	.PURG1			;FORK ALREADY MELTED - GO ZAP IT

.PURG0:	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND THAW IT
	MOVE	A,0(P)			;GET JOB # AND REMOVE FROZEN BIT
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.PURG1:	PUSHJ	P,FRCHLT		;NOW GO FORCE IT TO STOP

.PURG2:	MOVE	A,0(P)			;GET JOB #
	MOVSI	B,(FPURGE)		;SET PURGE BIT
	IORM	B,JBSTAT(A)
	SETOM	RUNQCP			;SET TO RUN Q COPY

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / PURGE SET AT /]
	SETZ	C,
	SOUT

	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	PUSHJ	P,DAY

.PURG3:	OKINT
	POP	P,B
	JRST	SCNCOM			;NEXT COMMAND


;COMMAND TO CLEAR OUT ANY RUNNING JOBS AND SET ENTFLG = 0 SO NO NEW ONES
;ARE STARTED
.CLEAR:	SETZM	ENTFLG			;ZERO ENTRY FLAG
	MOVE	C,[IOWD MAXFK,2]	;NOW LOOK AT ALL FORKS - STOP ANY RUNNING
.CLER0:	NOINT				;NO INTERRUPTS WHILE WORKING ON THEM
	SETO	A,
	CAMN	A,FKSTAT(C)		;IS THIS ONE THERE?
	JRST	.CLER3			;NO - LOOK AT THE NEXT ONE

	HRRZ	A,FKSTAT(C)		;YES, GET THE JOB NUMBER
	PUSHJ	P,JOBSIT		;AND DECODE STATUS
	BUG	(<.CLEAR: NO APPARENT Q ENTRY FOR FORK IN PROGRESS>)
	BUG	(<.CLEAR: FORK EXISTS FOR JOB NOT STARTED>)
	BUG	(<.CLEAR: FORK STILL EXISTS FOR HALTED JOB>)
	JRST	.CLER1			;FORK IS FROZEN - THAW IT
	JRST	.CLER2			;FORK MELTED - GO KILL IT

.CLER1:	MOVEI	A,400000(C)		;GET FORK HANDLE
	RFORK				;AND THAW IT
	HRRZ	A,FKSTAT(C)		;CLEAR FROZEN BIT FOR THIS JOB NUMBER
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.CLER2:	HRRZ	A,FKSTAT(C)		;GET JOB # FOR THIS GUY AND
	PUSHJ	P,FRCHLT		;GO FORCE HALT THIS FORK
	MOVSI	B,(FRESET+FINQUE)	;REQUEST RESET FOR JOB SO IT WILL
	MOVEM	B,JBSTAT(A)		;RUN AGAIN LATER
	SETOM	RUNQCP			;AND MAKE SURE QCOPY RUNS

.CLER3:	AOBJN	C,.CLER0		;LOOK AT THEM ALL

	HRROI	B,JOBCTL		;NOW POST DAY FILE MESSAGE
	HRROI	C,[ASCIZ / BATCON CLEARED AND ENTFLG=0 AT /]
	PUSHJ	P,DAY

	OKINT				;INTERRUPTS AGAIN
	JRST	SCNCOM



;CALL TO TEST BUGNOTE ROUTINE HERE - TO BE CALLED WITH GOTO
BUGNTE:	BUG	(<*** TESTING BUG NOTE ***>,.+1)
	POPJ	P,


;CALL TO TEST FULL BUG HANDLING - TO BE CALLED WITH GOTO
BUGFUL:	BUG	(<*** TESTING FULL BUG HALT ***>)
	HALTF				;IN CASE WE COME BACK HERE, WE HAVE
					;TROUBLE
	

;ERROR CONTROL CODE HANDLING
.AFTER:	
.RUNIN:	
.EXIT:	HRROI	A,STRBUF
	HRROI	B,[ASCIZ / INVALID </]
	SETZ	C,
	SOUT
	HRROI	B,QENT+COMNAM		;ADD ON COMMAND STRING
	SOUT
	HRROI	B,[ASCIZ /> COMMAND AT /]
	SOUT

	HRROI	B,JOBCTL		;NOTE ERROR IN DAY FILE
	HRROI	C,STRBUF
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK



;'EXPUNGE' THE BATCH DIRECTORY

GETJB2:	MOVE	A,BATDN			;GET DIRECTORY NUMBER
	DELDF				;EXPUNGE IT


;IF ANYTHING HAS HAPPENED TO ALTER STATUS OF Q ENTRIES, GO CLEAN IT UP

	SKIPE	RUNQCP
	PUSHJ	P,QUECOP


;NOW REACQUIRE JOB QUEUE AND OPEN Q FOR READ TO SCAN FOR JOBS (ALSO WRITE SO WE
;CAN RECORD THAT WE SELECTED A JOB).
GETJBQ:	MOVSI	A,(1B7!1B17)		;GET Q, NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG(<GETJB2: GTJFN FAILURE FOR Q>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

	MOVE	B,[1,,FDBUSW]		;GET THE USER SETTABLE WORD
	MOVEI	C,MXJBNO#		;WHERE TO PUT IT
	GTFDB

	MOVE	A,QJFN			;JFN FOR THE BATCH Q
	MOVE	B,[44B5!1B19!1B20]	;36 BIT,READ,WRITE
	QOPENF
	BUG	(<GETJB2: ERROR OPENING Q>)
	BUG	(<GETJB2: TIME OUT OPENING Q>,GETJOB)

;SCAN THROUGH THE QUEUE FOR A JOB TO RUN
	SETOM	BESTPR			;BEST PRIORITY IS -1 (NOT USEABLE)
	SETZM	QPNTR			;INIT POINTER FOR Q SCAN

	SKIPE	FORCST			;ANY FORCE STARTS?
	JRST	SCANQ			;YES, GO FIND THEM
	SKIPN	ENTFLG			;DON'T DO ANYTHING IF ENTFLG=0
	JRST	NOJOBS
	SKIPE	JOBHLT			;OR IF JOBHLT=-1
	JRST	NOJOBS

;CHECK TO SEE THAT Q IS NOT SCREWED UP, ALSO GET THE
;SIZE OF THE Q SO WE CAN COMPUTE NUMBER OF ENTRYS.
SCANQ:	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,[2,,11]		;2 WDS, STARTING AT WD 11
	MOVEI	C,D			;WHERE TO STORE IT
	GTFDB				;READ FROM FDB
	JUMPE	E,NOJOBS		;CHECK FOR NULL QUEUE
	LDB	B,[POINT 6,D,11]	;GET BYTE SIZE
	CAIE	B,^D36			;MUST BE 36 BIT
	BUG(<BYTE SIZE OF Q IS NOT 36>)
	MOVE	B,E			;GET # WDS
	IDIVI	B,QESIZE		;DIVIDE BY ENTRY SIZE
	CAIE	C,0			;MUST GO EVENLY
	BUG(<QUEUE DOES NOT CONTAIN EVEN NUMBER OF ENTRIES>)
	MOVEM	B,NQENT			;SAVE NUMBER OF ENTRIES

	SKIPE	FORCST
	JRST	RDQ

;FETCH THE JOBDIR TABLE TO COUNT ACTIVE JOBS FOR EACH USER
	MOVE	A,[SIXBIT /JOBDIR/]	;FIRST GET TABLE DATA
	SYSGT
	HRRO	A,B			;NOW SET UP FOR GTBLT OF TABLE
	HLRE	B,B			;GET NUMBER OF ENTRIES
	MOVM	B,B
	MOVEM	B,NJOBTB
	HRLZ	B,B
	HRRI	B,JBDRTB		;TACK ON DESTINATION
	GTBLT				;FETCH ALL TABLE ENTRIES
	BUG(<GETJOB: Error on JOBDIR GTBLT>)

;NOW READ IN A QUEUE ENTRY SO WE CAN EXAMINE IT.
RDQ:	MOVE	A,QJFN			;GET JFN FOR Q
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;GET AMT TO READ
	SIN

;CHECK TO SEE IF THIS IS A REAL QUEUE ENTRY -
;IGNORE NULL ENTRIES.
	SKIPG	QENT+USRDIR		;DOES IT HAVE A DIR TO LOGIN?
	JRST	NOTTHS			;NO--CANNOT RUN HIM

	SKIPG	FORCST			;IS THIS A FORCED START
	JRST	RDQ1			;NO, GO THROUGH NORMAL PRIORITIES
	MOVE	A,QENT+BJOBNO		;YES, GET JOB #
	MOVE	B,JBSTAT(A)		;GET STATUS
	TLZN	B,(FFSTRT)		;IS THIS ONE FLAGGED?
	JRST	NOTTHS			;NO, TRY NEXT ONE

	PUSHJ	P,JOBSIT		;VERIFY JOB STATUS
	BUG	(<RDQ: FORCED START ON NON-EXISTENT JOB>,WATNXT)
	JRST	RDQ0			;JOB THERE BUT NOT STARTED YET
	BUG	(<RDQ: FORCED START ON JOB ALREADY RUN>,WATNXT)
	JFCL
	BUG	(<RDQ: FORCED START ON JOB ALREADY RUNNING>,WATNXT)

RDQ0:	MOVEI	A,1			;FAKE VALID PRIORITY
	MOVEM	A,BESTPR
	MOVE	A,QPNTR			;SAVE Q POINTER
	MOVEM	A,BESTPT		;SAVE IT
	JRST	STRTIT			;GO START IT

RDQ1:	MOVE	A,[XWD 377777,777777]	;IS THIS JOB DEFERRED
	CAMN	A,QENT+JOBSTT
	JRST	NOTTHS			;YES, LOOK AT THE NEXT ONE

;CHECK ENTFLG FOR THIS JOB AND IF LOAD AVERAGE IS LOW ENOUGH TO RUN IT
	MOVE	A,ENTFLG		;GET ENTRY FLAG
	CAME	A,QENT+USRDIR		;ENTFLG MUST BE = USRDIR OR -1
	JUMPGE	A,NOTTHS		;NO - DON'T CONSIDER THIS JOB

IFE	SRISYS,<
	MOVE	A,[SIXBIT /LOADTB/]	;SYSTEM LOAD TABLE
	SYSGT				;GET TABLE NUMBER
	MOVE	A,B			;SET UP TABLE NUMBER
	HRLI	A,3			;OFFSET TO LOAD AVERAGE
>
IFN	SRISYS,<
	MOVE	A,[SIXBIT /SYSTAT/]	;FIND THE MAXIMUM OF THE 1, 5,
	SYSGT				;AND 15 MINUTE LOAD AVERAGES
	SKIPN	A,B
	BUG	(<RDQ: Sysgt for SYSTAT failed>)
	HRLI	A,14			;ENTRY 14 IS 1 MIN LOAD AV
	GETAB
	BUG(<RDQ1: Error fetching 1 min LA>)
	MOVE	C,A
	MOVE	A,B
	HRLI	A,15			;5 MIN LOAD AV
	GETAB
	BUG	(<RDQ: Error fetching 5 min LA>)
	CAMLE	A,C			;IF THIS ONE BIGGER, SAVE IT
	MOVE	C,A
	MOVE	A,B
	HRLI	A,16			;15 MIN LOAD AV
	GETAB
	BUG	(<RDQ: Error fetching 15 min LA>)
	CAMG	A,C			;NOW PUT MAX VALUE IN A
	MOVE	A,C
>
	CAML	A,QENT+LOADAV		;COMPARE WITH REQUEST
	JRST	NOTTHS			;SYSTEM TOO BUSY

;CHECK TO SEE IF IT HAS ALREADY BEEN STARTED.
;BY ANOTHER BATCON, OR IF IT IS ONE WE DIED ON.
	HRRZ	A,QENT+STRTED		;GET WHO STARTED IT
	JUMPE	A,RDQ3			;DID ANYBODY-JUMP IF NOT
	CAME	A,JOBNO			;WAS IT US?
	JRST	NOTTHS			;NO-CAN'T CONSIDER IT
	MOVE	A,QENT+JOBSTT		;TIME BATCH JOB STARTED
	CAML	A,BATSTT		;TIME BATCH PROCESSOR STARTED
	JRST	NOTTHS			;HE IS PROBABLY ALREADY RUNNING
	SETZM	QENT+STRTED		;YES, CLEAR START WORD
	MOVE	A,QJFN			;GET SET TO WRITE IT BACK OUT
	MOVE	B,QPNTR			;WHERE IT GOES
	SFPTR				;RESET POINTER IN FILE
	BUG(<RDQ1: Failed to reset Q file pointer>)
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;AMOUNT TO WRITE
	SOUT				;WRITE IT BACK

;SEE IF RESTART COUNT EXCEEDED. IF SO, MARK ENTRY FOR DELETION.
RDQ3:	MOVNI	A,MAXRST		;GET MAXIMUM RESTARTS
	CAMGE	A,QENT+RESTRT		;LIMIT EXCEEDED
	JRST	RDQ4			;NO

	MOVE	A,QENT+BJOBNO		;YES, TOO MANY RESTARTS, GET JOB NUMBER
	MOVSI	B,(FDEFER)		;SET DEFER BIT
	IORM	B,JBSTAT(A)
	SETOM	RUNQCP			;SET TO RUN Q COPY

	SETZM	CTLJFN			;CLEAR CTL FILE JFN
	HRROI	B,JOBDAY		;MESSAGE TO DAY FILE
	HRROI	C,[ASCIZ / DEFERRED: TOO MANY RESTARTS /]
	PUSHJ	P,DAY

	JRST	NOTTHS			;IGNORE ENTRY


;NOW EVALUATE IT'S PRIORITY TO SEE IF WE WANT TO RUN IT
RDQ4:	PUSHJ	P,EVPRIO		;GO COMPUTE PRIORITY
	CAMG	A,BESTPR		;IS THIS ONE BETTER?
	JRST	NOTTHS			;NO

;GOT A BETTER ONE, SO COPY INFO TO ACTIVE ENTRY
	MOVEM	A,BESTPR		;IS NOW THE BEST PRIORITY
	MOVE	A,QPNTR			;GET WHERE WE ARE IN Q
	MOVEM	A,BESTPT		;SAVE IT

;NOW GO ON TO NEXT ONE (IF IT EXISTS) AND LOOP THROUGH Q
NOTTHS:	MOVEI	A,QESIZE		;GET ENTRY SIZE
	ADDM	A,QPNTR			;UPDATE POINTER

	SOSLE	NQENT			;COUNT ENTRY,
	JRST	RDQ			;READ NEXT IF MORE

;HERE WE HAVE RUN OUT OF QUEUE - THERE HAD BETTER NOT BEEN ANY FORCED
;STARTS REQUESTED

	SKIPE	FORCST
	BUG	<NOTTHS: NO JOB FOUND WITH FORCED START SET>


;DETERMINE IF THERE WAS AN ENTRY WORTH USING.
;GO IDLE IF NOT.  READ IT IN IF SO.
STRTIT:	SKIPG	BESTPR			;ONE WORTH DOING?
	JRST	NOJOBS			;NO

	MOVE	A,ACTFRK		;GET NUMBER OF ACTIVE FORKS
	CAIL	A,MAXFK			;COMPARE WITH MAXIMUM ALLOWABLE INFERIORS
	JRST	NOJOBS			;ALL FORKS BUSY

	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,BESTPT		;WHERE TO POINT TO
	SFPTR				;POINT TO ENTRY
	BUG(<NOTTHS: Failed to set Q file pointer>)

	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY BUFFER
	MOVNI	C,QESIZE		;GET ENTRY SIZE
	SIN				;GET ENTRY

;GET INFORMATION ABOUT THE USER WE ARE STARTING.
	MOVE	A,QENT+USRDIR		;GET HIS DIR NUMBER
	MOVEI	B,USRBLK		;POINT TO PLACE FOR DIR INFO
	SETZ	C,			;WE DON'T WANT HIS PASSWORD
	GTDIR				;FIND OUT ABOUT HIM

;GET THE LOG FILE
	SETZM	CTLJFN			;NULL CONTROL FILE JFN
	SETZM	LOGJFN			;NULL LOG FILE JFN
	MOVSI	A,(1B17)	; SHORT
	HRROI	B,QENT+LOGFIL		;GET PTR TO NAME
	GTJFN
	JRST CKLGF1			;CAN'T GET LOG, FLUSH JOB

;CHECK ACCESS TO LOG FILE
	PUSH	P,A			;SAVE JFN FOR LOG FILE
	MOVEM	A,LOGJFN

;FIRST CHECK IF ON DSK: OR LPT:, IF NOT BOMBOUT.
	DVCHR				;GET DEVICE CHARACTERISTICS
	HLRZ	A,A			;GET DEVICE DESIGNATOR
	CAIN	A,DEVDSK		;IS DEVICE DSK?
	JRST	CKLOG0			;YES
	CAIN	A,DEVNIL		;IS DEVICE NIL:?
	JRST	CKLOGS			;YES-ALLOW IT
	CAIE	A,DEVLPT		;IS IT LPT?
	JRST	CKLOGF			;NO - FAIL

;NOW WE KNOW IT IS LPT:, MAKE A REAL FILE NAME FOR IT
	POP	P,A			;FIRST RELEASE THE OLD JFN
	CAIGE	A,2		;LEGAL JFN ?
	JRST	.+3		;NO -- DON'T RELEASE IT
	RLJFN				;RELEASE IT NOW
	BUG(<RLJFN failed in release of LPT:>)
	HRROI	A,FDBBLK		;WHERE TO PUT USER NAME
	MOVE	B,QENT+USRDIR		;HIS DIR NUMBER
	DIRST				;MAKE A STRING OF IT
	BUG(<DIRST failed in LPT file creater>)
	TIME				;GET TIME AS FILE EXTENSION RANDOMIZER
	TRZ	A,400000		;VERSION NUMBERS MUST BE .LE. 400000
	HRRM	A,LOGBLK		;STORE IN LOG JFN BLOCK
	MOVEI	A,LOGBLK		;LOG JFN BLOCK
	SETZ	B,			;NO MAIN STRING POINTER
	GTJFN				;GET A JFN
	BUG(<Can't GTJFN file in <PRINTER>.>)
	PUSH	P,A			;SAVE THE JFN
	MOVEM	A,LOGJFN

;	INSURE UNIQUE TIME GENERATED VERSION BY DELAAYING 2 SECOND
	MOVEI	A,^D2000
	DISMS
	JRST	CKLOGS			;AND ALLOW ACCESS

;IT IS KNOWN TO BE ON DSK: IF WE GET HERE.
CKLOG0:	MOVE	A,(P)			;GET JFN BACK
	MOVSI	B,(1B1)			;WE WILL NEED WRITE ACCESS.
	PUSHJ	P,CHKACC		;CAN HE USE IT?
	JRST	CKLOGF			;NO-CLEAN UP
	MOVE	B,DIRNMF		;GET DIR # FILE IS IN (SAVED
					;BY CHKACC).
	CAILE	B,1			;SYSTEM DIRECTORY??  ***SRI-AIC***
	CAMN	B,BATDN			;IS IT <BATCH>?
	JRST	CKLOGF			;NOT A LEGAL DIRECTORY
	JRST	CKLOGS			;ALL SEEMS LEGAL
CKLOGF:	POP	P,A			;ILLEGAL ACCESS ATTEMPT IF HERE
	MOVE	A,LOGJFN		;GET LOG JFN
	SETZM	LOGJFN			;CLEAR IT IN QENT
	MOVEM	A,CTLJFN		;FAKE CTLJFN FOR MESSAGE

	RLJFN				;RELEASE THE JFN USED
	BUG(<CKLOGF RLJFN failure>)
CKLGF1:	MOVE	A,QENT+BJOBNO		;GET JOB NUMBER
	MOVSI	B,(FDEFER+FINQUE)	;MARK IT FOR DEFERRING
	MOVEM	B,JBSTAT(A)
	SETOM	RUNQCP

	HRROI	B,JOBDAY		;PUT OUT DAY FILE MESSAGE
	HRROI	C,[ASCIZ / DEFERRED: CAN'T GET LOG FILE AT /]
	PUSHJ	P,DAY
	SETZM	CTLJFN

	JRST NOJOBS			;FORGET ABOUT THIS JOB

CKLOGS:	POP	P,A			;RESTORE JFN-LEGAL ACCESS

;OPEN THE LOG FILE.
	MOVE	B,[7B5!1B20]		;7BIT,WRITE
	QOPENF
	JRST	CKLOGF+1		;GO ABORT - OPEN ERROR
	JRST	CKLOGF+1		;GO ABORT - OPEN TIME OUT
	MOVEM	A,LOGJFN		;SAVE LOGJFN

;GET THE CTL FILE
	MOVSI	A,(1B2!1B17)		;OLD FILE, SHORT
	HRROI	B,QENT+CTLFIL		;GET CTL FILE NAME
	GTJFN
	JRST	[PUSH	P,[-1]		;DUMMY CTL JFN
		 JRST   CKCTLF]

;CHECK ACCESS TO CTL FILE
	PUSH	P,A			;SAVE THE JFN
	MOVSI	B,(1B0)			;READ ACCESS
	PUSHJ	P,CHKACC		;CHECK ACCESS
	JRST	CKCTLF			;FAILURE
	JRST	CKCTLS			;SUCCESS
CKCTLF:	ERROR	<FATAL ERROR TRYING TO ACCESS CTL FILE>
	MOVE	A,LOGJFN		;WRITE TENEX REASON WHY
	HRLOI	B,400000		;ON LOG FILE WITH
	SETZ	C,			;THE ERSTR JSYS
	ERSTR
	BUG(<ERSTR +1 in CKCTLF>)
	BUG(<ERSTR +2 in CKCTLF>)
	PUSHJ	P,SCRLF			;SEND A CRLF TO LOG FILE
	POP	P,A			;RESTORE JFN
	JUMPL	A,CLLOG			;IF CTL JFN EXISTS,
	RLJFN				;RELEASE IT
	BUG(<RLJFN failure in CKCTLF>)

CLLOG:	HRRZ	A,LOGJFN
	MOVEM	A,CTLJFN		;SAVE LOG JFN FOR DAY FILE MSG
	CLOSF				;CLOSE LOG FILE
	JFCL
	SETZM	LOGJFN

	MOVE	A,QENT+BJOBNO		;GET JOB NUMBER
	MOVSI	B,(FDEFER+FINQUE)	;MARK IT FOR DEFERRING
	MOVEM	B,JBSTAT(A)
	SETOM	RUNQCP

	HRROI	B,JOBDAY		;PUT OUT DAY FILE MESSAGE
	HRROI	C,[ASCIZ / DEFERRED: CAN'T GET CTL FILE AT /]
	PUSHJ	P,DAY
	SETZM	CTLJFN

	JRST NOJOBS			;FORGET ABOUT THIS JOB

CKCTLS:	POP	P,A			;LEGAL ACCESS-RESTORE JFN
	MOVEM	A,CTLJFN		;SAVE CTL FILE JFN

;	MARK ENTRY AS STARTED

	MOVE	A,QJFN			;LOOK AT THE Q NOW
	MOVE	B,QENT+RESTRT		;GET RESTART COUNT
	SUBI	B,1			;BACK IT UP BY 1
	MOVE	C,BESTPT		;GET POINTER TO THIS ENTRY
	ADDI	C,RESTRT		;DISP TO RESTRT COUNTER
	ROUT

	GTAD				;GET TIME
	MOVE	B,A
	MOVE	A,QJFN			;QUEUE JFN
	MOVE	C,BESTPT		;GET POINTER TO THIS ENTRY
	ADDI	C,JOBSTT		;DISP TO JOB START TIME
	ROUT				;PUT IN FILE
	PUSH	P,A			;SAVE QUEUE JFN
;NOW GET A FORK AND START IT UP
; WE DISABLE THE INTERRUPT SYSTEM TO PREVENT THE INTERRUPT SIDE
; FROM KILLING A FORK BEFORE WE HAVE A CHANCE TO MARK IT NOT STARTED

GINFK:	NOINT				;DISABLE INTERRUPTS
	HRLZI	A,200000		;SAME CAPABILITIES ONLY
	CFORK
	JRST [	OKINT			;REENABLE INTERRUPTS
		MOVEI	A,^D1000
		DISMS			;AND GO AWAY FOR A WHILE
		JRST GINFK]		;TRY AGAIN
	AOS	ACTFRK			;INCREMENT NUMBER OF ACTIVE FORKS
	MOVEM	A,RELFRK		;SAVE RELATIVE FORK HANDLE

	ANDI	A,777			;KEEP ONLY RELATIVE FORK INDEX
	HRRZI	B,-1			;SET FORK STARTING FLAG
	MOVEM	B,FKSTAT(A)
	MOVE	A,QENT+BJOBNO
	MOVSI	B,(FEXIST+FHLTED+FINQUE)	;SET JOB STATUS WORK
	HRR	B,RELFRK		;TACK ON FORK HANDLE
	HRLZ	C,QENT+USRDIR		;PATCH IN USER DIRECTORY NUMBER
	ADD	B,C
	MOVEM	B,JBSTAT(A)

	OKINT				;SPRING THE INTERRUPT SYS

;COPY DATA FROM QUEUE ENTRY.
	MOVE	A,QENT+ETIME		;GET MAX ELAPSED TIME
	MOVEM	A,MAXETM		;SAVE IT

	MOVE	A,QENT+RTIME		;GET MAX CPU TIME
	MOVEM	A,MAXCPU		;SAVE IT

	MOVE	A,QENT+LOGLNS		;GET LIMIT OF LINES TO WRITE ON LOG
	MOVEM	A,MAXLOG		;SAVE IT
;START MAPPING THE LOWER FORKS ADDRESS SPACE

	HRLZI	D,-NINF			;NUMBER OF INFERIOR FORK PAGES
	MOVE	A,[XWD 400000,INFFK/1000]  ;SUPERIOR FORK PAGE
	HRRZ	B,A			;PAGE NUMBER OF INFERIOR
	HRL	B,RELFRK		;INFERIOR FORK HANDLE
	HRLZI	C,160000		;READ,EXECUTE, WRITE
MPLP:	PMAP
	AOS	A			;INCREMENT SOURCE PAGE
	AOS	B			;INCREMENT DESTINATION PAGE
	AOBJN	D,MPLP

	HRLZI	D,-NSHAR		;NUMBER OF INFERIOR SHARED PAGES
MPLPS:	MOVE	A,[XWD 400000,SHARE/1000]   ;SHARED PAGES
	HRRZ	B,A
	HRL	B,RELFRK
	HRLZI	C,160000		;READ,WRITE AND EXECUTE
	PMAP				;MAP PAGE TO INFERIOR
	AOS	A
	AOS	B
	AOBJN	D,MPLPS

;MAP PRIVATE INFERIOR PAGES TO INFERIOR. ONLY REALLY BELONG TO INFERIOR
;AFTER INFERIOR HAS TOUCHED THEM.
	MOVE	A,[XWD 400000,PRIV/1000]  ;SOURCE HANDLE FOR PMAP
	MOVE	B,A
	HRL	B,RELFRK		;DESTINATION HANDLE FOR PMAP
	HRLZI	C,120400		;READ,COPY WRITE,EXECUTE ACCESS
	HRLZI	D,-NPRIV			;NUMBER OF PRIVATE INFERIOR PAGES
MAPP:	PMAP				;MAP TO INFERIOR
	AOS	A
	AOS	B
	AOBJN	D,MAPP

;MAP SYMBOL TABLE PAGES TO INFERIOR. MAP SAME AS PRIV TO KEEP OVERLAPPED
;PAGES FROM CHANGING PROTECTION.

	SKIPN	A,SYMPTR		;GET SYMBOL TABLE POINTER
	JRST INFSRT			;GO START THE INFERIOR IF NO TABLE
	ASH	A,-^D9			;MAKE WORDS INTO PAGES
	HLLZ	D,A			;PACK AWAY THE COUNT AS AN AOBJN PTR
	SUB	D,[1,,0]		;TO GET THE LAST PAGE
	TRZ	A,777000		;GET RID OF THE SHIFTED LH BITS
	HRLI	A,400000		;SUPERIOR IS SOURCE
	MOVE	B,A
	HRL	B,RELFRK		;DESTINATION HANDLE FOR PMAP
MAPSYM:	PMAP				;MAP TO INFERIOR
	AOS	A
	AOS	B
	AOBJN	D,MAPSYM

; START IT UP AND WAIT FOR IT. TURN ON THE INTERRUPT SYSTEM
; WHEN WE KNOW IT IS OFF AND RUNNING

INFSRT:	NOINT				;FIRST TURN OFF THE INTERRUPTS
	MOVE	A,RELFRK		;RELATIVE FORK HANDLE
	MOVEI	B,INFFK			;STARTING ADDRESS
	SFORK				;START INFERIOR

;	MAKE SURE INFERIOR HAS STARTED BEFORE ATTEMPTING TO START ANOTHER
;	TO AVOID POSSIBLE RACE CONDITION AS FAR AS VARIOUS INFERIOR FORKS
;	TOUCHING THEIR RESPECTIVE DATA AREAS.
WATST:	MOVEI	A,^D5000		;WAIT 5 SECONDS FOR THINGS TO START
	DISMS
	MOVEI	A,PRIV			;CHECK THE STATUS OF THE PRIVATE PAGE
	LSH	A,-^D9
	HRL	A,RELFRK		;TACK ON FORK HANDLE OF INFERIOR
	RPACS				;GET PAGE STATUS
	TLNE	B,004000		;IS THE PAGE SHARED (INDIR PTR)
	JRST	WATST			;YES, WAIT A BIT MORE

;CLEAN UP THE Q BEFORE GOING FOR ANOTHER

WATCMP:	POP	P,A			;GET BACK QUEUE JFN
	MOVE	B,JOBNO			;GET OUR ID
	HRL	B,RELFRK		;ADD FORK HANDLE FOR RUNNING FORK
	MOVE	C,BESTPT		;ORIGIN OF BLOCK ON DISK
	ADDI	C,STRTED		;+DISPLACEMENT INTO IT
	ROUT				;PUT WORD IN BLOCK

	MOVE	A,QENT+BJOBNO		;FINISH SETTING JOB STATUS AS RUNNING
	MOVSI	B,(FHLTED)
	ANDCAM	B,JBSTAT(A)

	MOVE	B,RELFRK		;SET JOB RUNNING IN FORK STATUS
	ANDI	B,777			;FORK INDEX
	HRRM	A,FKSTAT(B)
	OKINT				;REENABLE INTERRUPTS

;SET POINTER TO EOF, THEN CLOSE FILE
WATNXT:	MOVE	A,QJFN
	SETO	B,			;-1 IMPLIES EOF
	SFPTR				;SET POINTER
	BUG	(<INFSRT: ERROR SETTING Q FILE POINTER FOR EOF>)

	CLOSF				;DONE WITH Q FILE
	BUG	(<INFSRT: CLOSF ON Q FILE FAILED>)
	SETZM	QJFN			;DONE WITH JFN
	SETZM	RELFRK			;ZERO OUT FORK HANDLE

	SKIPE	FORCST			;ANY MORE FORCED STARTS
	JRST	[SOSE	FORCST
		 JRST	GETJBQ		;YES - GO FIND THEM
		 JRST	.+1]		;NO - CYCLE NORMALLY

	MOVEI	A,^D60000		;WAIT FOR 1 MIN TO LET THE NEW
	DISMS				;JOB SETTLE IN AND THE LA STABILIZE
	JRST GETJOB			;GO START THE NEXT GUY

;PSI SERVICE FOR INFERIOR FORK HALTED

HLTNFK:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	MOVE	C,[IOWD MAXFK,2]	;START WITH INFERIOR FORKS
INFLP:	MOVEI	A,400000(C)		;FORK HANDLE
	RFSTS				;GET FORK STATUS
	HLLM	A,FKSTAT(C)		;SAVE THE STATUS
	MOVEM	B,FRKPCS(C)		;SAVE THE FORK PC
	HLRZ	A,A			;GET LEFT HALF
	CAIN	A,-1			;UNASSIGNED ?
	JRST	UNAS			;YES
	HRRZ	B,FKSTAT(C)		;GET THE JOB NUMBER
	CAIN	B,-1			;IS THE FORK BEING STARTED?
	JRST	UNAS			;YES - IGNORE IT

	HRRZ	B,JBSTAT(B)		;GET FRK HANDLE FOR THIS JOB
	CAIE	B,400000(C)		;IT BETTER AGREE WITH OURS
	BUG	<HLTNFK: JBSTAT AND FKSTAT FORK HANDLES DISAGREE>
	TRZ	A,(1B0)			;IGNORE FROZEN STATUS
	CAIE	A,2			;VOLUNTARY TERMINATION
	CAIN	A,3			;FORCED TERMINATION
	CAIA
	JRST	UNAS			;NOT TERMINATED

	HRRZI	A,400000(C)		;FORK HANDLE
	KFORK				;KILL HALTED FORK

	SETOM	RUNQCP			;YES, THIS ONE STOPPED
	HRRZ	A,FKSTAT(C)		;GET JOB NUMBER
	SETOM	FKSTAT(C)		;CLEAR FORK STATUS
	SETZM	FRKPCS(C)		;CLEAR FORK PC
	SETZ	B,			;CLEAR FORK HANDLE FROM JOB STATUS
	HRRM	B,JBSTAT(A)
	MOVSI	B,(FEXIST+FFREEZ)	;CLEAR EXIST AND FROZEN BITS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FHLTED+FPURGE)	;SET HALTED AND PURGE BITS
	IORM	B,JBSTAT(A)

	SOS	ACTFRK			;DECREMENT NUMBER OF ACTIVE FORKS

UNAS:	AOBJN	C,INFLP
	POP	P,C
	POP	P,B
	POP	P,A
	DEBRK
	BUG	<HLTNFK: DEBRK FAILED>




;THE FOLLOWING PRINTS OUT THE STATUS OF THE INFERIOR FORKS IN RESPONSE
;TO A ^S
INFSTS:	PUSH	P,A
	PUSH	P,B
	MOVEI	A,101			;SET OUTPUT AS PRIMARY JFN
	SETZ	B,			;FLAG NOT TO FREEZE FORKS
	PUSHJ	P,INFSTO		;GO OUTPUT STATUS
	POP	P,B			;RECOVER AC'S AND RETURN
	POP	P,A
	DEBRK
	BUG	<INFSTS: DEBRK FAILED>


;THIS ROUTINE PURGES COMPLETED AND CANCELLED JOBS FROM THE QUEUE
QUECOP:
	IFE	FSUSER,<
IFE	FSTCPY,<			;DO WE WANT PMAP TRIMMER?
;TRIM QUEUE WITH FANCY END POINTER AND PMAP TRIMMER.

EOJ10:	MOVEM	B,EOJFK		;SAVE FORK TO SEARCH QUEUE FOR
	MOVN	B,B			;NEGATIVE FORK INDEX
	MOVSI	A,400000		;STARTING BIT
	LSH	A,0(B)			;POSITION BIT
	ANDCAM	A,HLTDFK		;SHOW WE ARE TAKING CARE OF IT
EOJ3:	MOVSI	A,(1B7!1B17)		;NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG(<EOJ3: Gtjfn failed for Q file>)

	MOVE	B,[44B5!1B19!1B20]	;36 BIT,READ,WRITE
	QOPENF
	BUG(<EOJ3: ERROR OPENING QUEUE>)
	BUG(<EOJ3: TIME OUT OPENING QUEUE>,QOPTMO)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

;CHECK TO SEE THAT Q IS NOT SCREWED UP, ALSO GET THE
;SIZE OF THE Q SO WE CAN COMPUTE NUMBER OF ENTRYS.
	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,[2,,11]		;2 WDS, STARTING AT WD 11
	MOVEI	C,D			;WHERE TO STORE IT
	GTFDB				;READ FROM FDB
	JUMPG	D,.+2			;IF Q NON NULL
	BUG(<NULL QUEUE BUT WE RAN A JOB IN IT>)
	LDB	B,[POINT 6,D,11]	;GET BYTE SIZE
	CAIE	B,^D36			;MUST BE 36 BIT
	HALTF
	MOVE	B,E			;GET # WDS
	IDIVI	B,QESIZE		;DIVIDE BY ENTRY SIZE
	CAIE	C,0			;MUST GO EVENLY
	HALTF

;ZERO OUT THE Q ENTRY WE JUST DID
	SETZM	QENT			;ZERO OUT CORE AREA
	MOVE	A,[QENT,,QENT+1]	;BLT WORD
	BLT	A,QENT+QESIZE-1		;DO IT ALL

	MOVE	A,QJFN			;GET JFN FOR Q
	MOVE	B,BESTPT		;GET POINTER TO THIS ENTRY
	SFPTR				;POINT TO IT IN FILE
	BUG(<EOJ3: Sfptr failed on Q file>)
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;AND GET LENGTH
	SOUT				;WRITE ZEROS ON IT

;FIND POSITION OF LAST REAL QUEUE ENTRY.
	MOVE	C,E			;GET EOF POINTER
TRMSLP:	SUBI	C,QESIZE		;FIND POINTER TO LAST ENTRY
	JUMPL	C,TRMSLE		;IF WE WENT NEGATIVE,TRIM IT ALL
	RIN				;GET A BYTE (DIRNUM TO USE)
	JUMPE	B,TRMSLP		;IF 0,NOT A JOB,SO TRY ANOTHER
	MOVE	B,C			;YES,POINT PAST END AND CLEAN UP
	ADDI	B,QESIZE		;SKIP AROUND GOOD ONE
	JRST	.+2			;SKIP NEXT INSTRUCTION
TRMSLE:	SETZ	B,			;HERE IF WE TRIM IT ALL
	SFPTR				;SET FILE POINTER
	BUG(<TRMSLP: Sfptr failed on Q file>)

;FIND AND DELETE ANY PAGES OF Q BEYOND END
	SUBI	B,1			;GET LAST WORD ADDRESS
	JUMPL	B,TRMALL		;WE ARE TRIMMING IT ALL
	LSH	B,-^D9			;GET PAGE # LAST WORD ON
	MOVE	D,B			;PUT IT IN D
	ADDI	D,1			;GET FIRST FREE PAGE
	JRST	TRMQ			;SKIP NEXT INSTRUCTION
TRMALL:	SETZ	D,			;WE TRIM IT ALL
TRMQ:	HRLZ	A,QJFN			;GET Q JFN
	HRR	A,D			;GET PAGE #
	FFUFP				;FIND ANY PAGES
	JRST	NOTRMQ			;PERHAPS NO MORE
	MOVE	B,A			;PAGE TO KILL
	SETO	A,			;SAY KILL IT
	SETZ	C,			;NO ACCESS 
	PMAP				;KILL PAGE
	JRST	TRMQ			;GO FOR ANOTHER

NOTRMQ:	CAIE	A,FFUFX3		;REALLY NO MORE?
	BUG(<NOTRMQ: We thought there weren't more pages but..>)

;CLOSE THE QUEUE FILE
	HRRZ	A,QJFN			;BE SURE TO RELEASE JFN HERE
	CLOSF				;THE LH 0 PROVIDES THAT
	BUG(<NOTRMQ: Tried to close-release Q file after trim and lost>)
	SETZM	QJFN			;Q NOT OPEN

	JRST	GETJOB			;MORE WORK
	>				;END IFE FSTCPY-TRIM W/O COPY
;TRIM THE QUEUE WITH THE COPY OPERATION
IFN	FSTCPY,<			;ARE WE TRIMMING WITH A COPY?

;BEWARE--THESE ROUTINES DO NOT YET PROVIDE EXCLUSION OF OTHER
;ACCESS TO THE BATCH QUEUE DURING THESE OPERATIONS.  THUS IF
;THERE IS ANOTHER BATCON RUNNING, HE MAY ACCESS THE QUEUE
;AT THE SAME TIME, CAUSING BAD RESULTS.  ALSO A SUBMIT
;MAY HAVE ACCESS TO THE QUEUE WHICH WOULD CAUSE TROUBLE.

EOJ10:
EOJ3:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B
	PUSH	P,C
	MOVSI	A,(1B7!1B17)		;NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG(<FSTCPY EOJ3: GTJFN FAILURE ON Q>)

;OPEN THE OLD QUEUE FOR READ AND WRITE.
	MOVE	B,[44B5!1B19!1B20]	;36 BIT, READ, WRITE
EOJ31:	QOPENF
	BUG(<FSTCPY EOJ31: ERROR OPENING OLD QUEUE>)	;NO OTHER PROBLEM
	BUG(<FSTCPY EOJ31: TIME OUT OPENING OLD QUEUE>,QOPTMO)

	MOVEM	A,OLDQ#			;SAVE JFN FOR OLD Q
	MOVE	B,[XWD 1,FDBUSW]	;GET USER SETTABLE WORD
	MOVEI	C,MXJBNO		;OR CURRENT MAX JOB NUMBER
	GTFDB

	MOVSI	A,600001		;GET JFN FOR NEW NAME OF QUEUE
	HRROI	B,TMPNAM		;NAME OF THE TEMPORARY.
	GTJFN
	BUG(<FSTCPY EOJ31: GTJFN FAILED FOR NEWNAME FOR Q>)
	MOVEM	A,TMPQJF#		;SAVE IT
	MOVE	B,[44B5!1B20]		;OPEN FOR 36 BIT WRITE
	QOPENF
	BUG(<FSTCPY EOJ31: ERROR OPENING NEW QUEUE>)
	JRST	[HRRZ	A,TMPQJF	;RELEASE JFN
		 RLJFN
		 BUG	(<FSTCPY EOJ31: ERROR RELEASING TEMP Q JFN>)
		 BUG	(<FSTCPY EOJ31: TIME OUT OPENING NEW QUEUE>,QOPTMO)
		]

	MOVEM	A,QJFN			;SAVE THE JFN FOR THE Q

;COPY LOOP FOR THE QUEUE
	SETZM	QPNTR			;STARTING AT START OF Q
	HRRZ	A,OLDQ			;CHECK FOR 0 LENGTH FILE
	MOVE	B,[1,,12]		;DISPLACEMENT FOR BYTE SIZE
	MOVEI	C,C
	GTFDB
	JUMPG	C,QCPYST
	SETZM	HLTDFK
	JRST	QCOPYE

QCPYST:	NOINT				;TURN OFF INTERRUPTS

QCOPY:	MOVE	A,OLDQ			;GET OLD Q JFN
	MOVE	B,[POINT 36,QENT]	;WHERE TO PUT IT
	MOVNI	C,QESIZE		;AMOUNT TO READ
	SIN

	GTSTS				;READ STATUS BITS
	TLNE	B,1000			;WAS EOF READ?
	JRST	QCOPYE			;YES-END OPERATION

	SKIPG	QENT+USRDIR		;IS THIS ENTRY A VALID USER?
	JRST	QCOPY2			;YES-DELETE IT
;;;	HRRZ	A,QENT+STRTED		;GET STARTING JOB NUMBER
;;;	JUMPE	A,QANAL			;NOBODY STARTED IT - SEE WHAT TO DO
;;;	CAME	A,JOBNO			;SOMEONE DID - WAS IT US
;;;	JRST	QCOPYB			;NO, COPY IT AND LOOK AT THE NEXT ENTRY

QANAL:	MOVE	A,QENT+BJOBNO		;GET JOB NUMBER
	PUSHJ	P,JOBSIT		;FIND JOB STATUS
	JRST	JSTSET			;WE DON'T KNOW ABOUT THIS JOB - SET IT
	JFCL				;OK IT'S HERE - SEE WHAT TO DO
	JRST	QDISPO			;JOB DONE - SEE WHAT TO DO
	JFCL				;JOB STILL RUNNING - JUST COPY IT
	JRST	QCOPY1			;JOB STILL RUNNING - JUST COPY IT

JSTSET:	SETZ	B,			;INITIALIZE JOB STATUS
	SETZM	QENT+STRTED		;CLEAR STARTED FLAGS
	JRST	QCOPY1

QDISPO:	TLNE	B,(FPURGE)		;PURGE REQUEST?
	JRST	QPRG			;YES, GO DO IT
	TLNE	B,(FRESET)		;RESET REQUEST?
	JRST	QRSET			;YES, GO DO IT
	TLNE	B,(FDEFER)		;DEFER REQUEST?
	JRST	QDFER			;YES, GO DO IT
	TLNE	B,(FHLTED)		;WAS IT HALTED?
	BUG	<QANAL: JOB HALTED WITH NO DISPOSITION>	;YES - ERROR
	TLNN	B,(FFSTRT)		;FORCED START?
	JRST	JSTSET			;NO - JUST COPY IT. NOTHING GOING ON

	MOVSI	B,(FFSTRT)		;SET STATUS ENTRY FOR FORCED START
	JRST	QCOPY1

QPRG:	SETZM	JBSTAT(A)		;CLEAR JOB STATUS
	JRST	QCOPY2			;SKIP OVER ENTRY

QRSET:	TLNE	B,(FDEFER)		;DO WE HAVE DEFER TOO?
	BUG	<QDISPO: SIMULTANEOUS RESET AND DEFER REQUESTS>	;YES - ERROR
	SETZM	QENT+RESTRT		;OK - RESET QUEUE ENTRY
	SETZM	QENT+JOBSTT
	JRST	JSTSET			;NOW RESET STATUS ALSO AND COPY

QDFER:	MOVE	C,[XWD 377777,777777]	;SET LARGE DATE FOR JOB START
	MOVEM	C,QENT+JOBSTT
	JRST	JSTSET			;RESET STATUS

QCOPY1:	TLO	B,(FINQUE)		;SHOW JOB IN QUEUE
	TLZ	B,777			;RESET USER DIRECTORY NUMBER
	HRLZ	C,QENT+USRDIR
	ADD	B,C
	MOVEM	B,JBSTAT(A)
	
QCOPYB:	MOVE	A,QJFN			;YES
	MOVE	B,[POINT 36,QENT]	;POINT TO IT
	MOVNI	C,QESIZE		;SIZE OF IT
	SOUT				;PUT IT OUT

QCOPY2:	MOVEI	A,QESIZE		;AMOUNT WE DID
	ADDM	A,QPNTR			;COUNT IT

	JRST	QCOPY			;AND GO FOR MORE

QCOPYE:	OKINT				;RESTART INTERRUPTS SYSTEM

	HRRZ	A,QJFN			;CLOSE THE NEW QUEUE
	TLO	A,(1B0)			;BUT DON'T RELEASE JFN
	CLOSF
	BUG(<ERROR CLOSING NEW QUEUE>)

	HRRZ	A,OLDQ			;NOW CLOSE THE OLD ONE
	TLO	A,(1B0)			;ALSO KEEP THE JFN
	CLOSF
	BUG(<ERROR CLOSING OLD QUEUE>)

	MOVE	A,QJFN		;CHANGE USER SETTABLE WORD
	HRLI	A,FDBUSW		;WHAT TO CHANGE TO
	MOVE	C,MXJBNO		;CHANGE ALL BITS
	SETO	B,
	CHFDB
	MOVE	A,QJFN			;THE REAL Q NOW
	MOVE	B,OLDQ			;THE NAME WE GIVE IT
	RNAMF				;DO RENAME TO NORMAL NAME
	BUG(<RNAMF FAILED IN Q RENAME>)

	MOVE	A,OLDQ			;RELEASE THE QUEUE JFN
	RLJFN
	BUG(<CANNOT RELEASE Q JFN AFTER REWRITE>)

	SETZM	RUNQCP			;CLEAR RUN QCOPY FLAG

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN

;	*** STILL IN  IFE FSUSER  CONDITIONAL ***

;WAIT FOR WORK TO COME
NOJOBS:	HRRZ	A,QJFN			;BATCH QUEUE JFN
	GTSTS				;GET ITS STATUS
	TLNE	B,(1B0)			;IF OPEN CLOSE IT
	JRST	[CLOSF
		 BUG	(<NOJOBS: ERROR	CLOSING QUEUE>)
		 JRST	NOJB0]

	HRRZ	A,QJFN			;NOW RELEASE IT IF NEEDED
	TLNE	B,(1B10)
	JRST	[RLJFN
		 BUG	(<NOJOBS: ERROR RELEASING Q JFN>)
		 JRST	NOJB0]

NOJB0:	SETZM	QJFN			;ZERO QUEUE JFN

NOJB1:	SKIPGE	RUNQCP			;ENTRIES TO DELETE FROM BATCH QUEUE ?
	JRST	QUECOP			;YES, GO CLEAN UP QUEUE

	MOVEI	A,^D60000		;ONE MINUTE
	DISMS				;WAIT
	JRST	GETJOB			;TRY FOR ANOTHER JOB
	>
	>				;END IFE FSUSER
;CALL:	A/ JFN OF DESIRED FILE
;	B/ BIT FOR ACCESS DESIRED (IN BITS 0-5)
;RETURNS	+1 IF ILLEGAL ACCESS
;		+2 IF ACCESS OK

;VALUES USED HERE
ACCBWR==200000,,0
ACCBAP==040000,,0

CHKACC:	PUSH	P,A			;STASH THE ARGUMENTS
	PUSH	P,B			; ..
	HRROI	A,DIRBLK		;TEMP FOR THE DIRECTORY NAME
	HRRZ	B,-1(P)			;THE JFN
	MOVSI	C,(1B5)			;JFNS TO OUTPUT JUST DIRECTORY
	JFNS
	MOVEI	A,0			;FLAG TO NOT RECOGNIZE
	HRROI	B,DIRBLK		;WHERE NAME STRING IS
	STDIR				;GET THE NAME
	BUG(<STDIR failure in CHKACC returned +1>)
	BUG(<STDIR failure in CHKACC returned +2>)
	HRRZM	A,DIRNMF		;STASH DIRECTORY NUMBER OF FILE
	MOVEI	A,(A)			;JUST NUMBER
	MOVEI	B,DIRBLK		;PLACE FOR GTDIR DATA
	MOVEI	C,0			;NO NEED FOR PASSWORD
	GTDIR				;FIND OUT ABOUT THAT DIR
	HRRZ	A,-1(P)			;THE JFN AGAIN
	MOVSI	B,25			;ARG TO GTFDB FOR ALL DATA
	MOVEI	C,FDBBLK		;PLACE TO STORE IT
	GTFDB				;READ SAME
	MOVEI	C,0			;ROTATE COUNTER
	HRLZ	D,FDBBLK+4		;FILE PROTECTION BITS
	MOVE	A,DIRBLK+6		;DIRECTORY NUMBER OF FILE
	CAMN	A,USRBLK+6		;DIRECTORY NUMBER OF USER
	JRST	CHK1			;SAME. DON'T ROTATE
	MOVE	A,USRBLK+13		;GROUPS USER HAS ACCESS TO
	TDNE	A,DIRBLK+14		;FILE IN ONE OF THOSE GROUPS?
	SUBI	C,6			;YES. WILL MOVE TO GROUP BITS
	ADDI	C,14			;FOR UNIVERS OR GROUP BITS
CHK1:	ROT	D,0(C)			;ROTATE THE FILE'S BITS
	MOVE	A,FDBBLK+1		;GET STATUS BITS FOR FILE
	TLNN	A,(1B4)			;THIS FILE EXIST?
	JRST	CHK2			;YES.
	MOVE	A,0(P)			;NO. NEW FILE. GET ACCESS REQUEST.
	TLNN	A,(ACCBWR!ACCBAP)	;WRITE OR APPEND?
	JRST	CHK2			;NO.
	HRLZ	A,DIRBLK+10		;YES. LEGAL TO CREATE NEW FILE?
	ROT	A,(C)			;CHECK DIRECTORY PROTECTION FIELD
	TLNN	A,(ACCBAP)		;APPEND TO DIRECTORY OK? (NEW FILES)
	JRST	CHK3			;NO. THIS REQUEST ILLEGAL.
CHK2:	TDNE	D,0(P)			;IS THE ACCESS ALLOWED?
	AOS	-2(P)			;YES. SKIP RETURN
CHK3:	POP	P,B			;RESTORE REGS
	POP	P,A
	POPJ	P,			;RETURN
;ROUTINE TO RELEASE QJFN IF THERE AND TO RECYCLE TO GETJOB
;USED AS ADDRESS FOR TIME OUT BUG RETURN AFTER QOPENF

QOPTMO:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B

	HRRZ	A,QJFN			;BATCH QUEUE JFN
	GTSTS				;JFN STATUS
	TLNE	B,(1B0)			;IF OPEN, CLOSE IT
	JRST	[TLO	A,(1B0)		;DON'T RELEASE JFN
		 CLOSF
		 BUG	(<QOPTMO: ERROR CLOSING QUEUE>)
		 HRRZ	A,A		;RESTORE JUST QJFN
		 JRST	.+1]

	TLNE	B,(1B10)		;IF JFN VALID RELEASE IT
	RLJFN

	SETZM	QJFN			;CLEAR QUEUE JFN

	POP	P,B			;RESTORE AC'S
	POP	P,A

	JRST	GETJOB			;AND TRY AGAIN



;ROUTINE TO CHECK THE STATUS OF A JOB
;ON ENTRY:	A  = JOB #
;RETURNS	+1  NEVER HEARD OF THE JOB
;		+2  JOB IN Q ONLY - NOT RUNNING OR RUN
;		+3  JOB IN Q, HAS RUN AND HALTED
;		+4  JOB IN Q, IS RUNNING FROZEN
;		+5  JOB IN Q, IS RUNNING MELTED
;	B =  JOB STATUS BITS

JOBSIT:	ANDI	A,777			;MAXIMUM OF 512 JOBS
	SKIPN	B,JBSTAT(A)		;HAVE WE HEARD OF IT?
	JRST	JBSRET			;NO - RETURN +1
	AOS	0(P)			;YES, AT LEAST +2
	TRNE	B,-1			;DOES A FORK EXIST NOW?
	JRST	JOBSI1			;YES - CHECK STATE
	TLNN	B,(FHLTED)		;NO - HAS ONE HALTED?
	JRST	JBSRET			;NO - RETURN +2
	AOS	0(P)			;YES - RETURN +3
	JRST	JBSRET

JOBSI1:	TLNE	B,(FHLTED)		;FORK RUNNING - HALTED BIT ON?
	BUG	<JOBSIT: RUNNING FORK SHOWN AS HALTED>
	AOS	0(P)			;NO - RETURB AT LEAST +4
	AOS	0(P)
	TLNE	B,(FFREEZ)		;IS IT FROZEN?
	JRST	JBSRET			;YES - RETURN +4
	AOS	0(P)			;NO, RETURN +5
	JRST	JBSRET

JBSRET:	POPJ	P,			;RETURN WITH STATUS IN B



;ROUTINE TO FORCE HALT A LOWER FORK.  AN INTERRUPT IS SENT ON CHANNEL 3
;WHICH IS ARMED IN ALL INFERIORS AS A SUICIDE CHANNEL.
;ON ENTRY:	A  = JOB #
;IF IT DOESN'T DIE IN 1 MINUTE, IT IS KILLED.  THIS MAY LEAVE ITS PTY STILL
;ASSIGNED.  IT ALWAYS RETURNS WITH THE INTERRUPT SYSTEM ACTIVATED.

FRCHLT:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B
	PUSH	P,C

	NOINT				;DISABLE INTERRUPT SYSTEM - SO FORK
					;DOESN'T DISAPPEAR UNDER US
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	SKIPN	A			;IS IT REAL?
	JRST	FRCHL2			;NO - RETURN
	MOVSI	B,(1B3)			;USE CHANNEL 3
	IIC				;REQUEST SUICIDE
	ANDI	A,777			;KEEP ONLY FORK INDEX PART
	PUSH	P,A			;SAVE IT
	SETO	B,
	MOVEI	C,^D20			;20 5 SEC WAITS MAX
	OKINT				;RESTART INTERRUPTS

FRCHL0:	MOVE	A,0(P)			;GET FORK INDEX
	CAMN	B,FKSTAT(A)		;IS THE FORK GONE?
	JRST	FRCHL1			;YES, WIND IT UP

	SOJE	C,FRCKIL		;TOO LONG A WAIT - GO KILL IT
	MOVEI	A,^D5000		;OK, WAIT 5 SEC MORE
	DISMS
	JRST	FRCHL0			;TRY AGAIN

FRCKIL:	NOINT				;NO INTERRUPTS
	MOVE	A,0(P)			;FORK INDEX
	CAMN	B,FKSTAT(A)		;ONE LAST CHANCE
	JRST	FRCHL1
	MOVEI	A,400000(A)		;MAKE IT A FORK HANDLE AGAIN
	KFORK				;KILL IT
	ANDI	A,777			;FORK INDEX
	SETOM	FKSTAT(A)		;CLEAR FORK STATUS
	OKINT
	BUG	(<FRCHLT: HAD TO KILL LOWER FORK - PTY MAY BE HUNG>,.+1)

FRCHL1:	POP	P,A			;CLEAR FORK INDEX FROM STACK

FRCHL2:	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	OKINT
	POPJ	P,			;RETURN




;EVALUATE PRIORITY OF A JOB FOR EXECUTION
;EXPECTED TO USE REGS A,B,C,D,E (AND PERHAPS MORE)
;RETURNS +1 WITH THE PRIO IN A, IF .LT. 0 THEN
;THE JOB IS NOT TO BE RUN AT ALL AT THIS TIME.
;THE GREATER THE NUMBER IS, THE BETTER THE JOB IS TO RUN.

;COMPUTE HOW LONG (IN SECONDS) JOB HAS BEEN WAITING.
EVPRIO:	MOVE	A,QENT+AFTER		;CHECK FOR "AFTER JOB" REQUEST
	TLNE	A,-1			;LEFT HALF EMPTY?
	JRST	EVPRI1			;NO - MUST BE A DATE
	ANDI	A,777			;YES - EITHER NULL OR JOB REQUEST
	SKIPE	JBSTAT(A)		;IF JOB SPECIFIED IS THERE -
	JRST	NORUN			;DON'T RUN THIS ONE UNTIL IT IS GONE

EVPRI1:	GTAD				;GET CURRENT TIME
	CAMN	A,[-1]			;WAS IT -1?
	JRST	NORUN			;REFUSE ALL JOBS IF TIME NOT SET
	CAMG	A,QENT+AFTER		;CHECK IF HE CAN BE RUN YET.
	JRST	NORUN			;HE WANTS TO WAIT SOME MORE.

;IF THIS IS PRIME TIME, DON'T ALLOW MORE THAN MAXJBS JOBS FOR THIS USER
	MOVE	B,A
	SETZ	D,
	ODCNV				;GET LOCAL SECONDS PAST MIDNIGHT
	HRRZ	D,D
	CAIL	D,STPRM			;IS IT BEFORE PRIME START
	CAILE	D,ENDPRM		;NO, IS IT AFTER PRIME END
	JRST	NONPRM			;YES, THEN DON'T BOTHER

	MOVE	A,NJOBTB		;THIS IS PRIME TIME - HOW MANY JOBS
	SETZ	B,
JOBCNT:	SOJL	A,LSTENT
	HRRZ	C,JBDRTB(A)		;FETCH DIR NUM FOR THIS JOB
	CAMN	C,QENT+USRDIR		;IS IT THE SAME AS THE ONE WE WANT TO RUN
	AOJ	B,			;YES, THEN COUNT IT
	JRST	JOBCNT			;DO ALL OF THEM

LSTENT:	CAIL	B,MAXJBS		;ARE TOO MANY RUNNING
	JRST	NORUN			;YES, THEN IGNORE THIS ONE

NONPRM:	GTAD				;GET CURRENT DATE AND TIME
	HLRZ	B,A			;GET CURRENT DAY
	HLRZ	C,QENT+ENTERD		;GET TIME ENTERED
	MOVSI	D,-1			;ANY AFTER TIME SPECIFIED?
	TDNE	D,QENT+AFTER
	HLRZ	C,QENT+AFTER		;YES, USE IT FOR CALCULATION
	SUB	B,C			;FIND #DAYS WAITED
	IMULI	B,^D24*^D3600		;TIMES SECONDS/DAY
	HRRZ	C,QENT+ENTERD		;GET TIME ENTERED
	TDNE	D,QENT+AFTER		;IF AFTER GIVEN, US IT
	HRRZ	C,QENT+AFTER		;USE THIS INSTEAD IF GIVEN.
	HRRZ	A,A			;ISOLATE CURRENT TIME
	SUB	A,C			;GET SECONDS ELAPSED
	ADD	A,B			;ADD PART DUE TO DAYS
;A NOW HAS THE NUMBER OF SECONDS THE JOB HAS WAITED TO RUN.

	POPJ	P,			;RETURN PRIORITY IN A

NORUN:	SETO	A,			;-1 MEANS NO GO
	POPJ	P,			;RETURN
;ROUTINE TO COMPOSE A MESSAGE OF THE FORM:
;	HEADER <FILE NAME> TAIL
;MESSAGE IS PUT IN BUGSTR AND MADE ASCIZ
;ON ENTRY:	A = VALID FILE JFN
;		B = STRING POINTER TO HEADER
;		C = STRING POINTER TO TAIL

BUGFIL:	PUSH	P,A			;SAVE FILE JFN
	PUSH	P,B			;SAVE HEAD
	PUSH	P,C			;SAVE TAIL

	HRROI	A,BUGSTR		;OUTPUT TO BUGSTR
	SETZ	C,
	SOUT				;OUTPUT HEADER
	HRRZ	B,-2(P)			;GET JFN
	MOVE	C,[XWD 011110,1]
	JFNS				;DO FILE NAME
	MOVE	B,0(P)			;GET TAIL POINTER
	SETZ	C,
	SOUT

	POP	P,C			;RECOVER AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN



;ROUTINE TO OPEN CRASH FILE AND SEND A MESSAGE OF THE FORM:
;	<DATE/TIME>  MESSAGE
;CRASH FILE IS CLOSED WITHOUT RELEASING JFN AT END
;ON ENTRY:	B = STRING POINTER TO MESSAGE

SNDCSH:	PUSH	P,A			;SAVE WORKING AC'S AND PTR (B)
	PUSH	P,B
	PUSH	P,C

	MOVE	A,CRSHJF		;OPEN CRASH FILE
	MOVE	B,[7B5!1B22]		;7 BIT, APPEND
	QOPENF
	BUG	(<SNDCSH: ERROR OPENING CRASH FILE>)
	BUG	(<SNDCSH: TIME OUT OPENING CRASH FILE>,SNDCRT)

	MOVEI	B,37			;DO CRLF
	BOUT
	SETO	B,			;GET CURRENT DATE/TIME
	MOVSI	C,045000
	ODTIM
	MOVEI	B," "			;SPACE OVER
	BOUT
	BOUT
	MOVE	B,-1(P)			;GET MESSAGE POINTER
	SETZ	C,
	SOUT				;WRITE IT

	MOVE	A,CRSHJF		;CLOSE CRASH FILE
	TLO	A,(1B0)			;DON'T RELEASE JFN
	CLOSF
	BUG	(<SNDCSH: ERROR CLOSING CRASH FILE>)

SNDCRT:	POP	P,C			;RECOVER AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN


;ROUTINE TO INITIALIZE A USER-GENERATED QUEUE MANAGEMENT FILE INPUT
;FOR JOB.*;*, DJOB.*;*, AND CJOB.*;*.  THE FILE IS OPENED FOR READ,
;ITS BYTE COUNT CHECKED AGAINST QESIZE, ITS FDB AUTHOR CHECKED AGAINST
;THE USRDIR AUTHOR, AND THE CONTENTS READ INTO A BUFFER.  THE FILE FDB
;IS ALSO PUT IN FDBBLK.
;ON ENTRY:	STACK -1 (AFTER PUSHJ) CONTAINS FILE GROUP JFN
;		A = STRING POINTER TO BUFFER AREA
;
;RETURNS	+1  FAILURE IN ONE OR MORE CHECKS
;		+2  OK, BUT THE USER IS NOT A WHEEL
;		+3  OK, AND THE USER IS A WHEEL

CHKFIL:	PUSH	P,A			;SAVE BUFFER PTR AND WKG AC'S
	PUSH	P,B
	PUSH	P,C

	HRRZ	A,-4(P)			;GET FILE JFN
	MOVE	B,[44B5!1B19]		;OPEN 36 BIT, READ
	QOPENF
	JRST	[HRROI	B,[ASCIZ /
ERROR OPENING /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG ON CRASH FILE

	JRST	[HRROI	B,[ASCIZ /
TIME OUT OPENING /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG ON CRASH FILE

	MOVSI	B,25			;GET WHOLE FDB
	MOVEI	C,FDBBLK		;IN FDBBLK
	GTFDB
	MOVE	B,FDBBLK+12		;GET BYTE COUNT
	CAIE	B,QESIZE		;IS IT QESIZE
	JRST	[HRROI	B,[ASCIZ /
SIZE ERROR ON FILE /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG TO CRASH FILE

	MOVE	B,-2(P)			;GET BUFFER POINTER
	MOVNI	C,QESIZE		;READ QESIZE
	SIN

	HLRZ	A,FDBBLK+6		;GET LAST WRITER
	HRRZ	B,-2(P)			;GET BUFFER ADDRESS
	CAME	A,USRDIR(B)		;ARE DIRECTORIES THE SAME?
	JRST	[HRROI	B,[ASCIZ /
AUTHOR INCONSISTENCY ON /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG ON CRASH FILE

	AOS	-3(P)			;EVERYTHING CHECKS - RETURN +2
					;AT LEAST
	MOVEI	B,DIRBLK		;FETCH DIRECTORY PRIVILEGES
	MOVEI	C,0			;NO NEED FOR PASSWORD
	GTDIR
	HRRZ	A,DIRBLK+3		;STRIP PRIVILEGES
	TRNE	A,1B18!1B19		;IS HE WHEEL OR OPERATOR?
	AOS	-3(P)			;YES, RETURN +3

CHKFRT:	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN

;TACK ON TAIL OF MESSAGE AND SEND TO CRASH FILE
BUGCSH:	MOVE	A,-4(P)			;GET FILE JFN
	HRROI	C,[ASCIZ / - FILE DELETED
**********
/]
	PUSHJ	P,BUGFIL		;ENTER ERROR IN CRASH FILE
	HRROI	B,BUGSTR
	PUSHJ	P,SNDCSH
	JRST	CHKFRT			;RETURN +1




;ROUTINE TO CLOSE A JOB, DJOB, OR CJOB FILE IF OPEN, DELETE IT, AND
;GET THE NEXT JFN OF THE GROUP IF ANY.
;ON ENTRY:	STACK-1 = GROUP JFN (AFTER PUSHJ)
;		A =  0  => DON'T DELETE FILE
;		    -1  => DELETE IT
;
;RETURNS	+1 IF NO MORE FILES (JFN RELEASED)
;		+2 FOUND ANOTHER FILE

NXTFIL:	PUSH	P,A			;SAVE DELETE SWITCH, WORKING AC'S
	PUSH	P,B

	HRRZ	A,-3(P)			;GET FILE JFN
	GTSTS				;AND ITS STATUS
	TLO	A,(1B0)			;FLAG SO DON'T RELEASE JFN LATER
	TLNN	B,(1B0)			;SKIP IF OPEN
	JRST	FLCLSD			;NOT OPEN - JUST DELETE IT
	CLOSF				;CLOSE FILE
	BUG	(<NXTFIL: ERROR CLOSING FILE>)

FLCLSD:	MOVE	B,-1(P)			;GET DELETE SWITCH
	JUMPE	B,DNTDEL		;IF 0, DON'T DELETE IT
	DELF				;-1, DELETE FILE
	BUG	(<NXTFIL: ERROR DELETING FILE>)

DNTDEL:	MOVE	A,-3(P)			;GET GROUP JFN
	GNJFN
	JRST	NXTRLJ			;NO MORE FILES - RELEASE JFN
	AOS	-2(P)			;ANOTHER FOUND - RETURN +2

NXTRET:	POP	P,B			;RECOVER AC'S
	POP	P,A

	POPJ	P,			;RETURN

NXTRLJ:	HRRZ	A,-3(P)			;GET JFN
	GTSTS				;AND ITS STATUS
	TLNN	B,(1B10)		;IS JFN ASSIGNED
	JRST	NXTRET			;NO - RETURN +1
	RLJFN				;YES, RELEASE IT
	BUG	(<NXTFIL: ERROR RELEASING JFN>)
	JRST	NXTRET			;RETURN +1

;ROUTINE TO OUTPUT STATUS OF EXISTING INFERIOR FORKS
;ON ENTRY:	AC 1  = JFN OF OUTPUT FILE
;		   2  =  0 => DO NOT FREEZE FORKS
;			-1 => FREEZE FORKS AND FORCE THEM TO SAVE THEIR
;				AC'S IN PRIVATE CSHACS.  IN THIS MODE,
;				INFSTO RETURNS NOINT.

INFSTO:	PUSH	P,C			;SAVE AC'S TO BE USED
	PUSH	P,D
	PUSH	P,E
	PUSH	P,F

	PUSH	P,A			;SAVE OUTPUT JFN
	PUSH	P,B			;SAVE FREEZE FLAG
					;FIRST PUT OUT HEADER
	HRROI	B,[ASCIZ /
**BATCON STATUS:  /]
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /RUNNING    /]
	SKIPE	JOBHLT
	HRROI	B,[ASCIZ /HALTED    /]
	SOUT
	SETO	B,			;ADD DATE/TIME STAMP
	MOVSI	C,045000
	ODTIM

	HRROI	B,[ASCIZ /
  ENTRY SET FOR /]
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /ALL USERS
/]
	SKIPL	ENTFLG
	HRROI	B,[ASCIZ /NO USERS
/]
	SKIPLE	ENTFLG
	JRST	[MOVEI	B,"<"
		 BOUT
		 MOVE	B,ENTFLG
		 DIRST			;PRINT DIRECTORY NAME
		 JFCL			;IGNORE ERROR
		 HRROI	B,[ASCIZ />
/]
		 JRST	.+1]
	SOUT

	NOINT				;MAKE SURE NOTHING DISAPPEARS WHILE
					;WE ARE PLAYING
	MOVE	E,[IOWD MAXFK,2]	;SCAN ALL INFERIOR FORKS
	SETZ	F,			;COUNT FORKS OUTPUT
INFSTL:	MOVEI	A,400000(E)		;FORK HANDLE
	RFSTS				;GET FORK STATUS
	HLRE	A,A			;SET UP ACTUAL STATUS TO CHECK FKSTAT
	SETO	B,			;AND JBSTAT CONSISTENCY WITH STATUS
	CAME	A,B			;SYSTEM THINKS FORK THERE?
	JRST	INFST2			;YES - CHECK FKSTAT
	CAME	B,FKSTAT(E)		;NO - DOES FKSTAT
	BUG	<INFSTO: FKSTAT THINKS NONEXISTENT FORK EXISTS>		;YES
	JRST	UNASS			;OK - NOT THERE SO CHECK NEXT ONE

INFST2:	CAMN	B,FKSTAT(E)		;SYSTEM THINKS ITS THERE, DO WE?
	BUG	<INFSTO: FKSTAT THINKS RUNNING FORK DOESN'T EXIST>	;NO
	PUSH	P,A			;OK, THEY AGREE.  SAVE REAL STATUS
	HRRZ	A,FKSTAT(E)		;GET THE JOB NUMBER
	HRRZ	B,JBSTAT(A)		;AND THE RECORDED FORK HANDLE
	CAIE	B,400000(E)		;IS IT THIS ONE?
	BUG	<INFSTO: JBSTAT FRK HANDLE INCONSISTENT WITH FKSTAT JOB #>	;NOPE
	PUSHJ	P,JOBSIT		;NOW CHECK REST OF STATUS BITS
	JFCL				;OOPS, NOT EVEN IN JBSTAT
	BUG	<INFSTO: JBSTAT DOESN'T KNOW ABOUT RUNNING JOB>
	BUG	<INFSTO: JBSTAT THINKS RUNNING JOB IS HALTED>
	JRST	INFST3			;JBSTAT SAYS FROZEN - IS IT?
	JFCL				;JBSTAT SAYS MELTED - IS IT?

	POP	P,A			;RECOVER ACTUAL STATUS
	TRNN	A,1B18			;SYSTEM SAYS MELTED?
	JRST	INFST4			;YES - GO ON
	BUG	<INFSTO: JBSTAT THINKS FROZEN FORK IS MELTED>

INFST3:	POP	P,A			;RECOVER ACTUAL STATUS
	TRNE	A,1B18			;SYSTEM SAYS FROZEN?
	JRST	INFST4			;YES - GO ON
	BUG	<INFSTO: JBSTAT THINKS MELTED FORK IS FROZEN>

INFST4:	MOVEI	A,400000(E)		;NOW ITS FOR REAL - GET FORK HANDLE
	SKIPE	0(P)			;SHOULD WE FREEZE IT?
	FFORK				;YES
	RFSTS				;IN ANY CASE GET STATUS
	MOVE	D,B			;SAVE PC
	HLRZ	A,A			;GET LEFT HALF OF STATUS
	CAIN	A,-1			;UNASSIGNED ?
	BUG	<INFSTO: FORK DISAPPEARED FROM UNDER US>

	HRRZ	C,FKSTAT(E)		;GET JOB STATUS AND SET FORK STATUS TO
	MOVE	C,JBSTAT(C)		;TO SHOW PRIOR FROZEN/MELTED STATE
	TRZ	A,1B18			;CLEAR FROZEN BIT IN SYSTEM STATUS
	TLNE	C,(FFREEZ)		;WAS IT REALLY BE FROZEN?
	TRO	A,1B18			;YES - SET IT
	HRLM	A,FKSTAT(E)		;SAVE CURRENT STATUS IN FORK TABLE
	MOVEM	D,FRKPCS(E)		;AND PC IN PC TABLE.
					;NOTE - IF INPUT REQUEST SAID FREEZE
					;THE FORK, IT IS NOW FROZEN - TEMPORARILLY.
					;THE FORK STATUS BITS SHOW IT AS IT WAS
					;THOUGH SO THAT IT CAN BE RESUMED LATER
					;IF APPROPRIATE.

	SKIPL	0(P)			;SHOULD WE FORCE AC'S TO BE SAVED
	JRST	NOFRZ2			;NO - JUST PRINT RESULTS

	TRZ	A,1B18			;FORGET FROZEN BIT
	CAIE	A,2			;WAS THE FORK TERMINATED?
	CAIN	A,3
	JRST	NOFRZ2			;YES, DON'T TRY TO GET AC'S
	MOVEI	A,400000(E)		;NO, THEN GET THEM
	MOVSI	B,(1B4)			;INTERRUPT CHANNEL 4
	IIC
	AOSG	ACSDON			;SET FLAG SO KNOW WHEN AC'S SAVED:
					; ACSDON > 0 => SAVE AC'S REQ PENDING
					;	 = 0 => IDLE STATE
					;	 < 0 => REQUEST SATISFIED
	BUG	<INFSTO: TRYING TO SAVE AC'S BEFORE PREVIOUS REQUEST DONE>
	RFORK				;RESUME THE FORK TO GET THE INTERRUPT
					;NOTE, THE FORK WILL SET ACSDON = -1
					;WHEN THE AC'S ARE SAVED AND WILL
					;WAIT UNTIL ACSDON GEQ 0 BEFORE
					;RESUMING.

NOFRZ0:	SKIPG	ACSDON			;ARE THE AC'S SAVED YET?
	JRST	NOFRZ1			;YES - GO ON
	MOVEI	A,400000(E)		;NO - HAS THE FORK HALTED?
	RFSTS
	HLRZ	A,A			;STATUS IN RIGHT HALF
	TRZ	A,1B18			;CLEAR FROZEN BIT
	CAIE	A,2
	CAIN	A,3
	JRST	UNASS			;MISSED IT - GO ON
	MOVEI	A,^D5000		;WAIT A BIT
	DISMS
	JRST	NOFRZ0			;GO LOOK AGAIN

NOFRZ1:	MOVEI	A,400000(E)		;FORK HANDLE
	FFORK				;REFREEZE IT
	AOSE	ACSDON			;CLEAR FLAG AND PRINT RESULTS
	BUG	<INFSTO: INVALID ACSDON FLAG AFTER AC'S SAVED>

NOFRZ2:	MOVE	A,-1(P)			;GET OUTPUT JFN
	SKIPG	F			;IS THIS THE FIRST PRINTABLE ONE
	JRST	[HRROI	B,[ASCIZ /
  FORK/]
		 SETZ	C,
		 SOUT
		 MOVE	C,[XWD 120002,10]
		 JRST	.+2]
	MOVE	C,[XWD 120010,10]
	HRRZ	B,E			;OUTPUT FORK NUMBER
	NOUT
	JFCL
	MOVEI	B,40
	BOUT
	BOUT

	HLRZ	C,FKSTAT(E)		;RECOVER FORK STATUS BITS
	TRZ	C,1B18			;IGNORE FROZEN BIT FOR NOW
	MOVE	B,FST(C)		;POINTER TO DESCRIPTOR STRING
	SETZ	C,
	SOUT				;OUTPUT FORK RUN STATUS
	HRROI	B,[ASCIZ /(FROZEN) /]
	SKIPL	FKSTAT(E)		;SKIP IF FROZEN
	HRROI	B,[ASCIZ /(MELTED) /]
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /AT /]
	SOUT
	HRRZ	B,D			;RETRIEVE PC (ADDRESS PART ONLY)
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	MOVEI	B,37			;DO A CR
	BOUT
	AOJ	F,			;BUMP OUTPUT COUNT
UNASS:	AOBJN	E,INFSTL
	JUMPG	F,INFRET		;IF ANY FORKS DESCRIBED, RETURN NOW

	HRRZ	A,-1(P)			;NONE - SPECIAL MESSAGE.  GET OUTPUT JFN
	HRROI	B,[ASCIZ /
  NO ACTIVE FORKS
/]
	SETZ	C,
	SOUT

INFRET:	POP	P,B			;RECOVER JFN AND FLAG
	POP	P,A

	POP	P,F			;RESTORE AC'S
	POP	P,E
	POP	P,D
	POP	P,C

	JUMPL	B,INFRT1		;IF WE HAVE FROZEN THE FORKS, RETURN
					;NOINT
	OKINT				;OTHERWISE, TURN THE INTERRUPT
					;SYSTEM BACK ON

INFRT1:	POPJ	P,			;RETURN


; Batcon restart code. Restarts from old or new image depending upon DBUGSW
;
; DBUGSW/	0 = Restart from the current image
;		1 = Start a new one from <SYSTEM>BATCON.SAV
;		2 = Start a new one from <BATCH>TBATCON.SAV
;

BATRST:	HRROI	A,BUGSTR		;SET UP RESTART MESSAGE
	HRROI	B,[ASCIZ /
**BATCON RELOADING AT /]
	SKIPG	DBUGSW
	HRROI	B,[ASCIZ /
**BATCON RESTARTING AT /]
	SETZ	C,
	SOUT
	SETO	B,			;ADD DATE STAMP
	MOVSI	C,045000
	ODTIM
	MOVEI	B,37			;ADD <CRLF>
	BOUT
	BOUT
	SETZ	B,			;MAKE IT ASCIZ
	BOUT

	MOVEI	A,101			;SEND MESSAGE TO TTY
	HRROI	B,BUGSTR
	SETZ	C,
	SOUT

	MOVE	A,CRSHJF		;TRY OPENING CRASH FILE FOR MSG
	MOVE	B,[7B5!1B22]		;7 BIT AND APPEND
	QOPENF
	JFCL				;EITHER OPEN ERROR OR
	JRST	[MOVEI	A,101		;TIME OUT ERROR - PRINT ON TTY
		 HRROI	B,[ASCIZ /=>BATCON: ERROR OPENING CRASH FILE
     /]
		 SETZ	C,
		 SOUT
		 HRLOI	B,400000
		 ERSTR			;OUTPUT OPEN ERROR STRING
		 JFCL			;IGNORE ERROR RETURNS
		 JFCL
		 MOVEI	B,37		;TACK ON CRLF
		 BOUT
		 JRST	BATCLN]		;DON'T TRY TO OUTPUT TO CRASH FILE

	MOVE	A,CRSHJF		;OUTPUT RESTART MESSAGE TO FILE
	HRROI	B,BUGSTR
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /**********
/]
	SOUT

BATCLN:	RESET				;SET THE WORLD RIGHT
	SETO	A,			;RELEASE ALL PTY'S IN USE
	REPTY
	HALTF				;BAD NEWS - NOT MUCH WE CAN DO
					;ABOUT THIS ERROR!
	SKIPG	16,DBUGSW		;GET THE SWITCH, DO WE RELOAD?
	JRST [	MOVEI	16,DBUGFG	;NO, BUT MAKE SURE WE DO NEXT TIME
		MOVEM	16,DBUGSW	;JUST IN CASE...
		JRST START0 ]
	MOVSI	1,1			;SHORT
	HRRO	2,SAVNAM-1(16)		;OF THIS FILE
	GTJFN				;GET IT
	HALTF				;SHIT, CAN'T FIND IT
	HRRM	1,BATJFN		;SAVE IT FOR LATER
	HRL	16,DUMPSW		;DON'T FORGET THE DUMPSW
	MOVEM	16,REGCDE		;PUT IT WHERE WE CAN MOVE IT
	MOVSI	17,REGCDE		;MOVE THE FOLLOWING CODE
	BLT	17,17			;TO THE REGISTERS
	JRST REGSRT-REGCDE		;AND DO IT

REGCDE:
	0				;0--DUMPSW,,DBUGSW 
	-1				;1--FLAG TO UNMAP PAGES
	XWD 400000,0			;2--THIS FORK & PAGE NUMBER
	0				;3--
	IOWD 511,2			;4--COUNTER FOR ALL PAGES
REGSRT:	HRR	B,D			;5--PUT PAGE NUMBER IN RH OF B
	PMAP				;6--UNMAP IT
	AOBJN	D,REGSRT-REGCDE		;7--DO THEM ALL
	MOVE	A,BATJFN-REGCDE		;10--GET NEW BATCON JFN
	GET				;11--GET THE FILE CONTENTS
	HRRZM	0,DBUGSW		;12--SET UP THE SWITCHES
	HLREM	0,DUMPSW		;13--
	JRST	START			;14--START NEW PROGRAM
	0				;15--
	0				;16--
BATJFN:	XWD 400000,0			;17--THIS FORK,,JFN OF SAVE FILE


SAVNAM:	[ASCIZ /<SYSTEM>BATCON.SAV/]	;REGULAR SYSTEM
	[ASCIZ /<BATCH>TBATCON.SAV/]	;TEST SYSTEM

;CONSTANT DATA AND STUFF
;BLANK LINE FOR OUTPUT TO LOG FILE
BLANKL:	EXP	5,2			;MAX LENGTH, ACTUAL LENGTH
	BYTE	(7)15,12		;CR,LF


;NAMES OF QUEUE FILE AND QUEUE WORK FILE
	IFE	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCH.QUEUE;P777740/
TMPNAM:	ASCIZ	/<BATCH>TEMP-TO-RENAM.TO-BE-QUEUE;P770000;1/
JBNAMS:	ASCIZ	/<BATCH>JOB.*;*/	;MASK TO LOOK FOR JOBS WITH
DJBNMS:	ASCIZ	/<BATCH>DJOB.*;*/	;MASK TO LOOK FOR DESUBMIT REQUESTS
CJBNMS:	ASCIZ	/<BATCH>CJOB.*;*/	;MASK FOR CONTROL COMMANDS
CRASH:	ASCIZ	/<BATCH>CRASH.MSG/
	>
	IFN	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCHTEST.QUEUE;P777740/
TMPNAM: ASCIZ /<BATCH>TEST-TO-RENAM.TO-BE-TESTQUEUE;P770000;1/
JBNAMS:	ASCIZ /<BATCH>TESTJOB.*;*/
DJBNMS:	ASCIZ	/<BATCH>TESTDJOB.*;*/
CJBNMS:	ASCIZ	/<BATCH>TESTCJOB.*;*/
CRASH:	ASCIZ	/<BATCH>TCRASH.MSG/
	>
BATDIR:	ASCIZ	/BATCH/			;DIRECTORY FOR BATCH STUFF

	LIT				;GET LITERAL POOL
;DATA AND STUFF


BESTPR:	BLOCK	1			;PRIORITY OF BEST JOB TO RUN
BESTPT:	BLOCK	1			;POINT TO Q ENTRY OF BEST TO RUN
NQENT:	BLOCK	1			;NUMBER OF QUEUE ENTRYS FOUND (COUNTED)
QPNTR:	BLOCK	1			;POINTER TO CURRENT Q ENTRY IN SCAN
EOJFK:	BLOCK	1			;NUMBER OF FORK TO SEARCH QUEUE FOR
STRTFK:	BLOCK	1			;BIT SET FOR EACH FORK BEING STARTED
					;BIT IS CLEARED AFTER FORK UNDERWAY
HLTDFK:	BLOCK	1			;BIT SET FOR EACH FORK HALTED
ACTFRK:	BLOCK	1			;NUMBER OF ACTIVE INFERIOR FORKS
BATSTT:	BLOCK	1			;BATCH PROCESSOR START TIME
NOWTIM:	BLOCK	1			;CURRENT DATE AND TIME (CMMD PROC)
RUNQCP:	BLOCK	1			;RUN QCOPY FLAG TO DELETE DESUBMITTED
					;ENTRIES FROM QUEUE
CTLTSK:	0				;CONTROL TASK COUNTER
ENTFLG:	-1				;ENTRY CONTROL: -1 (ANYONE),
					;0 (NOONE), AND >0 (DIR NUM)
JOBHLT:	0				;HALT FLAG, 0 (PROCEED) AND
					;-1 FREEZE JOBS AND DON'T ENTER MORE
FORCST:	0				;NUMBER OF REQUESTED FORCE STARTS

;FOLLOWING IS A TABLE WITH A ONE WORD ENTRY FOR EACH INFERIOR FORK.  IT IS
;INDEXED BY FORK INDEX AND CONTAINS:
;	-1		FORK DOES NOT EXIST
;	0,,-1		FORK BEING ESTABLISHED - CREATED NOW BUT NOT STARTED
;	STATUS,,JOB #	FORK RUNNING.  STATUS UPDATED WHENEVER RFSTS PERFOMED
;			JOB # IS THE JOB BEING MANAGED BY THIS FORK
;THE SUCCEEDING TABLE CONTAINS THE FORK PC FROM RFSTS

FKSTAT:	BLOCK	MAXFK+1			;TABLE OF FORK STATUS INFORMATION
					;INDEXED BY FORK INDEX.
FRKPCS:	BLOCK	MAXFK+1			;PC'S OF FORKS AT STATUS AND CRASH


;HERE IS THE DISPATCH TABLE FOR THE CONTROL CODES.  SEE PARAMS FOR
;DEFINITION OF THE MACRO

CTLDSP:	CTLLST

	PURGE	CTLLST


;	LPT: LOG FILE JFN BLOCK
LOGBLK:	600000,,0		;SET UP A LONG GTJFN
	377777,,377777		;INJFN,,OUTJFN
	0			;NO DEFAULT DEVICE
	POINT 7,[ASCIZ /PRINTER/] ;DIRECTORY
	POINT 7,[ASCIZ /LPT/]	;FILENAME
	POINT 7,FDBBLK		;EXTENSION IS HIS NAME
	EXP 0,0,0		;PROTECTION,ACCOUNT,JFN




;STORAGE BLOCKS FOR FDBS, DIRECTORY INFO, ETC.
;PRIMARALY STUFF RELATED WITH CHKACC
DIRNMF:	BLOCK	1			;DIR NUMBER FILE WE CHECK IS IN
FDBBLK:	BLOCK	25			;STORAGE FOR FDB OF FILE WE CHECK
USRBLK:	BLOCK	20			;SPACE TO GTDIR INTO FOR USER WE
					;ARE RUNNING-WE READ HIS ACCESS FROM
					;HERE
DIRBLK:	BLOCK	20			;WE GTDIR THE DIRECTORY INFO OF
					;THE DIRECTORY THE FILE IS IN INTO
					;HERE TO CHECK ACCESS (GROUP, ETC.)

ACS:	BLOCK	20		;INFERIOR AC'S AREA
;GENERATED VARIABLES
	VAR				;GET THIS BEFORE PDL

PDL:	BLOCK	PDLL+1			;PUSH DOWN LIST

	LIT				;LITERAL POOL


;FOLLOWING IS A JOB STATUS TABLE WITH A ONE WORD ENTRY FOR EACH OF A POSSIBLE
;512 JOBS IN PAGE 7.  EACH ENTRY CONTAINS:
;	0			JOB NEVER HEARD OF (NOT IN Q OR NOT INITIALIZED)
;	STATUS,,0		JOB IN QUEUE BUT NOT RUNNING WITH LOWER FORK
;	STATUS,,FORK HANDLE	JOB RUNNING UNDER LOWER FORK

;STATUS BIT	0  ON  => JOB BEING RUN (FORK HANDLE IN RIGHT SIDE)
;		   OFF => NO EXISTING FORK CONNECTED WITH THIS JOB
;		1  ON  => THERE WAS A FORK HERE - IT IS NOW HALTED
;		   OFF => IF FORK EXISTS, IT IS RUNNING
;		2  ON  => FORK EXISTS AND RUNNING FROZEN
;		   OFF => IF FORK EXISTS AND RUNNING MELTED
;		3  ON  => PURGE THIS JOB FROM QUEUE (SET AUTOMATICALLY ON
;			  INFERIOR FORK HALT)
;		4  ON  => RESET QUEUE PARAMETERS FOR THIS JOB
;		5  ON  => SET QUEUE TO DEFER EXECUTION OF THE JOB INDEFINITELY
;		6  ON  => START THIS JOB IMMEDIATELY - NO SCHEDULING
;		7  ON  => THIS JOB HAS AN ENTRY IN THE QUEUE

	LOC	7000			;PAGE WITH JOB STATUS INFORMATION
JBSTAT:	0

	SUBTTL	SHARED CODE BETWEEN SUPERIOR AND INFERIORS
	LOC	11000
SHARE:
;BUG ROUTINES FOR BATCH
;BUGMSG - WRITE A BUG MESSAGE, CALLED VIA TWO PUSHJS
;USING THE BUG MACRO

BUGMSG: PUSH	P,A			;SAVE AC A
	AOSN	BUGLCK			;ONE BUG AT A TIME!
	JRST	BUGGO			;OK, GO TO IT
	MOVEI	A,^D15000		;WAIT 15 SEC
	DISMS
	JRST	BUGMSG			;NOW, TRY AGAIN

BUGGO:	MOVE	A,RELFRK		;IDENTIFY BUGGY FORK
	MOVEM	A,WHOBUG
	POP	P,A			;JUST AS IT WAS

	NOINT				;DISABLE INTERRUPTS

	MOVEM	P,CSHACS+P		;SAVE ALL AC'S
	MOVEI	P,CSHACS
	BLT	P,CSHACS+16
	MOVE	P,CSHACS+P		;AND RESTORE STACK POINTER
	MOVE	A,-1(P)			;SAVE PC OF CRASH POINT IN CSHPC
	SUBI	A,1			;GET ACTUAL CRASH INSTRUCTION
	MOVEM	A,CSHPC			;SAVE PC AND FLAGS

	MOVE	A,0(P)			;GET ADR OF BUG ARGUMENTS
	MOVE	A,1(A)			;SAVE RETURN ADDRESS
	MOVEM	A,BUGRET

	SKIPE	BUGRET			;IS IT A BAD BUG?
	JRST	BUGGO1			;NO - CARRY ON
	MOVEI	A,400000		;YES, DEACTIVATE ALL INTERRUPT
	SETO	B,			;CHANNELS
	DIC

BUGGO1:	HRROI	A,BUGSTR		;CONSTRUCT BUG MESSAGE
	MOVE	B,MYNAME		;IS IT THE MAIN PROGRAM?
	JUMPGE	B,LOWFRK		;NO-GO MAKE LOWER FORK MESSAGE
	HRROI	B,[ASCIZ /
**BATCON CRASH: PC = /]			;YES-MAKE MAIN PROGRAM MESSAGE
	SKIPE	BUGRET
	HRROI	B,[ASCIZ /
**BATCON BUGNOTE: PC = /]
	SETZ	C,
	SOUT
	JRST	CMPMSG			;GO FINISH MESSAGE

LOWFRK:	HRROI	B,[ASCIZ /
**BATCON SUBFORK /]			;MAKE LOWER FORK MESSAGE
	SETZ	C,
	SOUT
	HRRZ	B,RELFRK		;ADD FORK NUMBER
	ANDI	B,777
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ / CRASH: PC = /]	;ADD REST OF MESSAGE
	SKIPE	BUGRET
	HRROI	B,[ASCIZ / BUGNOTE: PC = /]
	SETZ	C,
	SOUT

CMPMSG:	MOVE	B,-1(P)			;GET PC AND FLAGS
	MOVEI	B,-1(B)			;BACK UP 1 AND PC ONLY
	MOVEI	C,10			;OUTPUT OCTAL VALUE
	NOUT
	JFCL
	MOVEI	B," "			;ADD SOME SPACES
	BOUT
	BOUT
	SETO	B,			;OUTPUT DATE AND TIME STAMP
	MOVSI	C,045000
	ODTIM
	MOVEI	B,37			;GET A NEW LINE
	BOUT

	POP	P,B			;FETCH ERROR STRING ADDRESS
	HRRO	B,0(B)			;MAKE IT A BYTE POINTER
	SETZ	C,
	SOUT
	MOVEI	B,37			;ADD CRLF
	BOUT
	SETZ	B,			;MAKE IT ASCIZ
	BOUT

	MOVEI	A,101			;OUTPUT MESSAGE TO MAIN TTY
	HRROI	B,BUGSTR
	SOUT

	MOVE	A,CRSHJF		;OPEN THE CRASH FILE
	MOVE	B,[7B5!1B22]		;7 BIT AND APPEND
	QOPENF
	JFCL				;IF EITHER OPEN ERROR OR TIME
	JRST	[MOVEI	A,101		;OUT ERROR - SEND MSG TO TTY
		 HRROI	B,[ASCIZ /
**BATCON @ BUGMSG: ERROR OPENING CRASH FILE
     /]
		 SETZ	C,
		 SOUT
		 HRLOI	B,400000	;ADD TENEX ERROR STRING
		 ERSTR
		 JFCL			;IGNORE ERRORS
		 JFCL
		 MOVEI	B,37		;ADD CRLF
		 BOUT
		 JRST	CRSSET]		;CAN'T USE CRASH FILES SO GO
					;SEND NOTES TO PEOPLE AND SEE
					;ABOUT RESTARTING
	HRROI	B,BUGSTR		;OK HERE OUTPUT BUG MESSAGE TO
	SOUT				;CRASH FILE

	SKIPL	MYNAME			;IF MAIN BATCON, OUTPUT LOWER
	JRST	TENXER			;FORK STATUS AND FREEZE THEM
	MOVE	C,[IOWD MAXFK,2]	;LOOK AT ALL THE FORKS
STATLP:	SETO	A,
	CAMN	A,FKSTAT(C)		;IS THIS FORK ACTIVE?
	JRST	STTLP1			;NO - LOOK AT THE NEXT ONE
	MOVEI	A,400000(C)		;FORK HANDLE AND
	RFSTS				;GET CURRENT FROZEN/MELT STATUS
	PUSH	P,A			;SAVE IT FOR NOW
	MOVEI	A,400000(C)		;FORK HANDLE AND
	FFORK				;FREEZE IT AND
	RFSTS				;FIXED STATUS
	MOVEM	B,FRKPCS(C)		;STORE THE CURRENT FORK PC
	POP	P,B			;RECOVER REAL STATUS
	TLNN	B,(1B0)			;WAS IT REALLY FROZEN?
	TLZ	A,(1B0)			;NO - CLEAR THE BIT IN THE STATUS
	HLLM	A,FKSTAT(C)		;STORE STATUS OF THE FORK
STTLP1:	AOBJN	C,STATLP		;DO THEM ALL


;TENXER - WRITE THE TENEX ERROR STRING FOR LAST ERROR THIS FORK
;CALLED VIA DIRECT JRST OR FALLEN INTO FROM BUGSTP

TENXER:	MOVE	A,CRSHJF		;CRASH OUTPUT FILE
	HRROI	B,[ASCIZ /
TENEX ERROR: /]
	SETZ	C,
	SOUT
	HRLOI	B,400000		;LAST ERROR, THIS FORK
	ERSTR				;WRITE ERROR MESSAGE
	JFCL				;IGNORE THESE
	JFCL				;TOO LATE TO WORRY ABOUT THEM.
	MOVEI	B,37			;DO CRLF
	BOUT

	SKIPE	BUGRET			;IF BUGNOYE, END OF OUTPUT
	JRST	[HRROI	B,[ASCIZ /
**********
/]
		 SETZ	C,
		 SOUT
		 JRST	TNXER1]


; Check and see if we are to dump the image first
; Then add a note about it to the file
; DUMPSW/	0 = Don't dump the image
;		1 = Dump image to file and note in message
;  *note: Dump is of fork that crashed, not all forks. Symbols in a separate
;	  file
	SKIPN	16,SYMPTR		;GET THE SYMBOL POINTER
	JRST .+7			;GO AROUND SINCE THERE IS NO TABLE
	HLRE	15,16			;THE LENGTH
	MOVM	15,15			;POSITIVE LENGTH
	ADD	15,16			;LAST ADDR
	MOVES	0(16)			;TOUCH THE PAGE TO MAKE IT OURS
	ADDI	16,1000			;NEXT PAGE
	CAMG	16,15			;THE END?
	JRST .-3			;LOOP TILL WE ARE

	GTAD				;GET DATE/TIME STAMP FOR DUMP
	MOVE	B,A
	MOVE	A,CRSHJF
	MOVEI	C,400000		;DO THIS FORK
	SKIPE	DUMPSW
	PUSHJ	P,FRKDMP		;GO DUMP IT

TNXER1:	MOVE	A,CRSHJF		;CRASH FILE JFN
	TLO	A,400000		;DON'T RELEASE JFN
	CLOSF				;CLOSE AND RELEASE JFN
	JFCL				;BAD NEWS, ERROR HERE.  PRESS ON.

;SEND MESSAGE TO INTERESTED PEOPLE THAT BATCH PROCESSOR CRASHED

CRSSET:	SKIPG	BUGRET			;IF A FULL BUG, RIP UP ANY
	JRST	FULBUG			;SNDMSG.  IF NOT, WAIT PATIENTLY

	SKIPE	A,FORK			;IF THERE IS A SNDMSG
	RFORK				;RESUME IT
	OKINT				;REENABLE INTERRRUPTS

HAFBUG:	SKIPN	FORK			;SNDMSG THROUGH
	JRST	CRSNOT			;YES, GET ON WITH IT
	MOVEI	A,^D10000		;NO, WAIT 10 SEC
	DISMS
	JRST	HAFBUG			;TRY AGAIN

FULBUG:	SKIPE	A,FORK			;IS SNDMSG RUNNING NOW
	KFORK				;YES - KILL IT
	SETOM	SNDLCK			;ALLOW SNDMSG
	SETZM	FORK

	MOVEI	A,400000		;SET UP INTERRUPT SYSTEM TO
					;BE ABLE TO DETECT SNDMSG STOP
	CIS				;CLEAR INTERRUPTS
	OKINT				;ENABLE 

CRSNOT:	MOVE	A,CTLJFN		;SAVE OLD CTLJFN AND SET TO
	MOVEM	A,CTLHLD		;0 TEMPORARILY
	SETZM	CTLJFN

	HRROI	A,STRBUF		;COMPOSE MESSAGE
	SKIPG	BUGRET
	JRST	CRSNRT			;FULL BUG - MSG FOR NO RETURN
	HRROI	B,[ASCIZ /- CONTINUING WITH PC = /]
	SETZ	C,
	SOUT
	MOVE	B,BUGRET		;PRINT ADDRESS
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ /
AT /]
	JRST	CRDOIT			;GO SEND THEM

CRSNRT:	SKIPE	MYNAME			;ARE WE THE BIG ONE
	JRST	[HRROI	B,[ASCIZ /- ATTEMPTING RELOAD AT /]	;YES
		 SKIPG	DBUGSW
		 HRROI	B,[ASCIZ /- ATTEMPTING RESTART AT /]
		 JRST	CRDOIT]

	JRST	[HRROI	B,[ASCIZ /- FORK HALTING AT /]		;NO
		 JRST	CRDOIT]

CRDOIT:	SETZ	C,
	SOUT
	
	MOVSI	D,-NNOT			;NUMBER OF PEOPLE TO NOTIFY

CRSLOP:	MOVE	B,CRSHLS(D)		;DIR NAME POINTER FOR SEND
	MOVEI	A,1			;POSITIVE FOR NO COMPLETION
	STDIR				;GET HIS NUMBER
	JFCL				;WRONG SYSTEM OR SOMETHING?
	MOVE	A,BATDN			;SEND TO SELF THEN
	HRRZM	A,QENT+USRDIR

	HRROI	B,[ASCIZ /BATCH PROCESSOR CRASHED /]  ;MESSAGE
	SKIPN	MYNAME			;WHO AM I?
	HRROI	B,[ASCIZ /BATCH SUBFORK CRASHED /]  ;MILD MSG FOR INFERIOR
	HRROI	C,STRBUF		;AND TAIL MESSAGE

	PUSH	P,D
	PUSHJ	P,SEND			;SEND MESSAGE
	POP	P,D
WTMSG:	MOVEI	A,^D5000		;5 SECOND DELAY
	DISMS
	SKIPE	FORK			;MESSAGE SENT ?
	JRST	WTMSG			;NOT YET
	AOBJN	D,CRSLOP		;DO THEM ALL

	MOVE	A,CTLHLD		;RESTORE CTLJFN
	MOVEM	A,CTLJFN

	NOINT				;DISABLE INTERRUPTS
	SKIPG	BUGRET			;IF BUG NOTE, RESTORE WORLD AND
	JRST	BFLUSH			;CARRY ON, ELSE FLUSH IT.

;HERE WE HAD ONLY A MINOR BUG, SO CLEAN UP, RESTORE THINGS, AND CARRY ON

	SKIPL	MYNAME			;IF WE ARE NOT MAIN BATCON
	JRST	BRETN2			;JUST GO BACK
	MOVE	C,[IOWD MAXFK,2]	;OTHERWISE, RESTART LOWER FORKS
BRETN0:	SETO	B,			;IS THIS ONE ACTIVE?
	CAMN	B,FKSTAT(C)
	JRST	BRETN1			;NO - LOOK AT THE NEXT ONE
	HRRZ	A,FKSTAT(C)		;YES, GET THE JOB NUMBER
	MOVSI	B,(FFREEZ)
	TDNE	B,JBSTAT(A)		;SHOULD IT STAY FROZEN?
	JRST	BRETN1			;YES, TRY THE NEXT ONE
	MOVEI	A,400000(C)		;NO, THAW IT
	RFORK
BRETN1:	AOBJN	C,BRETN0		;DO THEM ALL

BRETN2:	MOVE	A,BUGRET		;SET STACK TO NEW RETURN ADDRESS
	HRRM	A,0(P)
	HRLZI	16,CSHACS		;RESTORE AC'S (EXCEPT STACK - IT
					;SHOULD BE READY TO GO)
	BLT	16,16
	MOVE	A,CSHACS+A		;RECOVER AC A
	SETOM	WHOBUG			;OPEN LOCK
	SETOM	BUGLCK

	OKINT				;REENABLE INTERRUPTS
	POPJ	P,			;AND WE ARE OFF AGAIN



BFLUSH:	SKIPE	MYNAME
	JRST BATRST			;RESTART BATCON FOR TOP GUY, ELSE
	RESET				;LOWER FORK, HANG IT UP (CLEANLY)
	MOVE	A,PTY			;RELEASE OUR PTY
	REPTY
	JFCL				;SOME DAYS NOTHING WORKS RIGHT

	HALTF				;STOP
	JRST	.-1			;DON'T CONTINUE

;	HANDLE UNEXPECTED INTERRUPTS

UNEX:	DEBRK


;THIS ROUTINE TRYS TO OPEN A FILE AND RETURNS +1 ON ANY FAILURE BUT BUSY.
;IF FILE IS BUSY, IT TRYS AGAIN IN 1/2 MINUTE, GIVES UP AFTER 20 TRIES.
;EVOKED BY THE 'QOPENF'MACRO (OPDEF).

.OPENF:	OPENM


DBUGSW:	DBUGFG				;see BATRST for definitions of
DUMPSW:	DUMPFG				;DBUGSW and DUMPSW

TTYJOB:	BLOCK	1			;TABLE NUMBERS FOR NAMED TABLES
JOBTTY:	BLOCK	1			;TABLE NUMBER
JOBRT:	BLOCK	1			;TABLE NUMBER
JOBNAM:	BLOCK	1			;TABLE NUMBER
SNAMES:	BLOCK	1			;TABLE NUMBER
JOBDIR:	BLOCK	1			;TABLE NUMBER
NJOBTB:	BLOCK	1			;NUMBER OF ENTRIES IN JOBDIR TABLE
JBDRTB:	BLOCK	^D50			;ARRAY FOR JOBDIR TABLE ENTRIES

WHEEL:	BLOCK	1			;NON-ZERO IF WE ARE A WHEEL
DETSW:	BLOCK	1			;NEGATIVE IF DETACHED
BATDN:	BLOCK	1			;DIRECTORY NUMBER FOR <BATCH>
JOBNO:	BLOCK	1			;JOB NUMBER OF THIS BATCON
					;SHOULD IDENTIFY WHICH BATCON
					;STARTED JOB, SO IF MULTIPLE IN
					;ONE JOB-WE MUST USE SOMETHING
					;HERE. IT IS NOT IMPORTANT THAT
					;IT BE THE JOB NUMBER

QJFN:	BLOCK	1			;JFN OF THE BATCH QUEUE
CRSHJF:	BLOCK	1	       		;JFN FOR CRASH MESSAGE FILE
SNDLCK:	-1				;SEND MESSAGE LOCK(ONE COPY 
WHOSND:	-1				;FORK ID OF GUY SENDING MSG
BUGLCK:	-1				;BUGMSG LOCK - ONE AT A TIME
WHOBUG:	-1				;WHO IS BUGGY
DAYLCK:	-1				;DAY FILE LOCK - ONE AT A TIME
WHODAY:	-1				;WHO IS WRITING IN DAY FILE
ACSDON:	0				;SIGNAL INDICATING LOWER FORK AC'S
					;ARE SAVED AND THE FORK IS REFROZEN

;DIRECTORY NUMBERS OF PEOPLE TO NOTIFY IF BATCH PROCESSOR CRASHES
CRSHLS:	
	CRSHUS
NNOT==.-CRSHLS				;NUMBER TO NOTIFY
NSHAR==<<<.-SHARE>+777>/1000>	;NUMBER OF INFERIOR FORK SHARED PAGES
					;AT A TIME)
;IMAGE DUMP FILE NAMES

CSHBAT:
IFE DBGFIL,<
	POINT 7,[ASCIZ /<BATCH>BATCON-DUMP./] 
>
IFN DBGFIL,<
	POINT 7,[ASCIZ /<BATCH>TBATCON-DUMP./] 
>

	LIT
	SUBTTL	INFERIOR FORK CODE
	LOC	12000
;OPEN CTL FILE NOW

	IFE	FSUSER,<
INFFK:	SETZM	PTY			;TOUCH PAGE TO GET COPY
	SETZM	MYNAME			;AND SAY I'M A LITTLE GUY
	MOVE	A,SYMPTR		;GET THE SYMBOL TABLE POINTER
	MOVEM	A,116			;AND SET IT UP FOR DDT ON A CRASH
	MOVE	P,[IOWD PDLL,IPDL]  ;SET UP STACK

	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

;SET UP INTERRUPT SYSTEM
	MOVEI	A,400000
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	HRLI	B,(1B1+1B3+1B4+1B10+1B11)	;ACTIVATE CHANNELS 1,3,4,10,
						;AND 11:
						;  1 - FORK DESUBMITTED
						;  3 - EMERGENCY ABORT
						;  4 - SAVE AC'S AND FREEZE
						; 10 - FILE EOF
						; 11 - FILE DATA ERROR
	AIC
	OKINT			;ENABLE INTERRUPT SYSTEM FOR THIS FORK

	MOVE	A,CTLJFN		;JFN OF CONTROL FILE
	MOVE	B,[7B5!1B19]		;7 BIT, READ
	QOPENF
	ERROR	<ERROR OPENING CTL FILE>,ABEND
	ERROR	<TIME OUT OPENING CTL FILE>,ABEND

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Tenex Batch System.  Version /]
	SETZ	C,
	SOUT

	MOVEI	B,MAJORV
	MOVE	C,[1B2+2B17+^D10]	;LEADING FILLER, 2 COL, DECIMAL
	NOUT
	JFCL
	MOVEI	B,"."
	BOUT
	MOVEI	B,MINORV
	MOVE	C,[1B3+2B17+^D10]	;LEADING ZEROS, 2 COL, DECIMAL
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - BATCH SYSTEM VERSION

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Batch job number /]
	SETZ	C,
	SOUT

	MOVE	B,QENT+BJOBNO		;JOB NUMBER
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ/ Started /]
	SETZ	C,
	SOUT
	SETOB	B,C			;CURRENT DATE AND TIME, THE WORKS
	ODTIM

	PUSHJ	P,INTMSG		;OUTPUT - JOB NUMBER AND TIME MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum log length (lines):  /]
	SETZ	C,
	SOUT
	MOVE	B,MAXLOG
	MOVEI	C,^D10
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - LOG LENGTH MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum elapsed time (minutes): /]
	SETZ	C,
	SOUT
	MOVE	B,MAXETM
	IDIVI	B,^D60000		;CONVERT MILLISECONDS TO MINUTES
	MOVEI	C,^D10
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum CPU time (seconds): /]
	SETZ	C,
	SOUT
	MOVE	B,MAXCPU
	IDIVI	B,^D1000		;CONVERT MILLISECONDS TO SECONDS
	MOVEI	C,^D10
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Input file : /]
	SETZ	C,
	SOUT

	HRRZ	B,CTLJFN		;LOG FILE JFN
	MOVE	C,[XWD 011110,110011]
	JFNS

	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Output file : /]
	SETZ	C,
	SOUT

	HRRZ	B,LOGJFN		;LOG FILE JFN
	MOVE	C,[XWD 011110,110011]
	JFNS

	PUSHJ	P,INTMSG		;OUTPUT - OUTPUT FILE MESSAGE

	MOVE	B,QENT+USRDIR		;GET DIR TO LOGIN WITH
	>				;END NORMAL JOB STARTUP
;GET A LOGIN LINE IN CTLLIN.
DOLOGI:	MOVE	C,[ASCII /LOG /]	;COMMAND
	MOVEM	C,CTLLIN+2		;SAVE IT
;	USE CONNECTED DIR FROM B
	HRROI	A,CTLLIN+3		;POINT TO DEST
	DIRST				;GET DESTINATIN
	BUG(<DOLOGI: Dirst failed for login line>)
	MOVEI	C," "			;BLANK FOR AFTER NAME
	IDPB	C,A			;STORE IT
	MOVE	C,A			;WHERE TO PUT PW
	MOVE	A,B			;DIR#
	MOVEI	B,1(P)			;THROW THIS OUT ABOVE STACK
	GTDIR				;HOPE IT WORKS, OR WE DIE
	MOVE	A,C			;GET BYTE POINTER
	MOVEI	B," "			;SPACE BEFORE ACCT#
	IDPB	B,A			;STORE IT

IFE	FSUSER,<			;IN SYSTEM BATCH WE WANT THIS
	MOVE	B,QENT+USRACT		;GET ACCOUNT REQUESTED
	JUMPN	B,DOLOG2		;HE KNOWS HIS ACCOUNT STRING ***SRI-IC***
	>				;END IFN FSUSER

	IFE	STRACT,<
;THE FOLLOWING IS BECAUSE WE HAVE A DUMB ACCOUNTING
;SYSTEM THAT REQUIRES THAT A VALID ACCOUNT NUMBER BE
;GIVEN--AND REFUSES TO ACCEPT ACCOUNT NUMBER 1
	MOVEI	B,33			;ESCAPE
	IDPB	B,A			;STORE IT IN ACCOUNT FIELD
	JRST	DOLOG3			;SKIP OVER THE NOUT

	MOVEI	B,^D1			;USE THIS GOOD ACCT #
DOLOG2:	MOVEI	C,^D10			;DECIMAL
	NOUT
	BUG(<DOLOG2: Nout failed>)
	>
	IFN	STRACT,<
	ERROR	<NO ACCOUNT STRING>,ABEND
DOLOG2:
	HRROI	B,QENT+USRACT	;USER ACCOUNT STRING POINTER
	SETZ	C,		;ZERO BYTE TERMINATION
	SOUT			;OUTPUT ACCOUNT STRING
	>

DOLOG3:	MOVEI	B,15			;CR
	IDPB	B,A			;SAVE IT IN LINE

;KLUDGE THE LENGTH OF STRING COMPUTATION.
	MOVE	B,[POINT 7,CTLLIN+2]	;POINT TO FIRST BYTE OF STRING
	MOVEM	B,CTLLIN-1		;STORE LOC OF LINE
	SETZ	C,			;INIT VALUE
	CAMN	B,A			;THERE YET?
	JRST	.+3			;YES
	IBP	B			;NO--GET NEXT
	AOJA	C,.-3			;COUNT AND LOOP
	MOVEM	C,CTLLIN+1		;SAVE LENGTH
;START THE JOB
RUNJOB:	MOVE	A,MAXCPU		;COMPUTE 10% CPU TIME USED TRIGGER
	ADDI	A,^D5
	IDIVI	A,^D10
	CAIG	A,^D15000		;TRIGGER AT LEAST 15 CPU SEC
	MOVEI	A,^D15000
	MOVEM	A,CPUTRG

	MOVE	A,MAXLOG		;COMPUTE 10% OUTPUT USED TRIGGER
	ADDI	A,^D5
	IDIVI	A,^D10
	CAIG	A,^D50			;TRIGGER AT LEAST 50 PRINT LINES
	MOVEI	A,^D50
	MOVEM	A,LOGTRG

	PUSHJ	P,.ASPTY		;FIRST WE GET A PTY
	JRST	[MOVEI A,^D60000	;NO PTY'S OR NO LOGINS
		 DISMS			;WAIT ONE MINUTE
		 JRST RUNJOB]		;RETRY ASPTY
	MOVEM	A,PTY

	HRROI	B,JOBMSG		;START MESSAGE
	HRROI   C,STRMSG		;END OF MESSAGE
	SKIPGE	QENT+MESAG		;MESSAGE WANTED?
	PUSHJ	P,SEND			;YES
	HRROI	B,JOBNOT
	HRROI	C,STRNOT		;NOTIFY STRINGS
	SKIPGE	QENT+NOTFY
	PUSHJ	P,NOTIFY
	HRROI	B,JOBDAY		;DAY FILE STRINGS
	HRROI	C,STRDAY
	PUSHJ	P,DAY			;ADD NOTICE TO DAYFILE

WAITJ:	TIME				;GET TODCLK
	MOVE	C,A			;SAVE IT
	ADDI	C,^D120000		;THIS IS WHEN WE WANT TO RETRY
	MOVE	A,PTY			;GET PTY NUMBER
	TRO	A,400000		;BE SURE TTY DESIGNATOR
	CFIBF				;CLEAR HIS INPUT
	CFOBF				;AND OUTPUT BUFFERS

;SEND A CONTROL C TO WAKE UP JOB.
	MOVE	A,PTY			;GET PTY NUMBER
	MOVEI	B,3			;GET A ^C
	PSTI
	ERROR	<CAN'T SEND ^C TO START SUBJOB>,ABEND	;OOPS-DIE

;WAIT FOR JOB TO START
WAITJ1:	MOVEI	A,^D1000		;WAIT 1 SECOND BEFORE CHECKING
	DISMS
	PUSHJ	P,TTYJ			;FIND LINE STATUS
	JRST	NOTASS			;TTY NOT ASSIGNED
	JRST	NOTASS			;TTY NOT ASSIGNED
	JRST WAITTM			;YES, AND JOB RUNNING - GO ON
	JRST WAITTM			;YES, AND JOB IN TTY WAIT - GO ON
NOTASS:	TIME				;GET TODCLK NOW
	CAMGE	A,C			;HAS TIME EXPIRED?
	JRST WAITJ1			;NO,GO BACK AND WAIT,TTY NOT ASSIGNED
	MOVE	A,PTY			;TOO LONG HERE, RELEASE PTY AND
	CFIBF				;START OVER
	CFOBF
	REPTY
	BUG(<RUNJOB: Can't release PTY to retry ^C>)
GETONE:	PUSHJ	P,.ASPTY		;GO GET A NEW PTY
	JRST	[MOVEI	A,^D60000	;NO PTY'S
		 DISMS			;WAIT 1 MIN
		 JRST	GETONE]		;TRY AGAIN
	MOVEM	A,PTY			;SAVE THE NEW PTY NUMBER
	JRST WAITJ			;TRY LOGGING IN AGAIN

WAITTM:	TIME				;SET UP TIME OUT FOR GETTING
	MOVE	C,A			;@ PROMPT BACK FOR LOGIN
	ADDI	C,^D120000

;WAIT FOR THE @ FROM EXEC BEFORE LOGIN.
WAITL:	MOVE	A,PTY			;GET A CHAR
	SETZ	B,			;DON'T BLOCK FOR CHAR
	PSTO				;GET IT
	JRST	WAITL2			;DIDN'T GET ONE
	PUSH	P,B			;SAVE B
	PUSHJ	P,ADDLOG		;PUT ON LOG FILE
	POP	P,B			;RESTORE B
	CAIE	B,"@"			;WAS IT AN @?
	JRST	WAITL			;NO-CONTINUE WAIT
	JRST	RUN			;YES-GO START RUNNING

WAITL2:	TIME				;CHECK FOR TIME OUT
	CAMLE	A,C			;HAS TIME EXPIRED
	ERROR	<NO @ PROMPT TO LOGIN SUBJOB>,ABEND	;YES, GO DIE
	MOVEI	A,^D1000		;NO, WAIT ONE SECOND MORE
	DISMS
	JRST	WAITL			;AND TRY AGAIN
;RUN THE JOB

RUN:	TIME
	ADD	A,MAXETM		;THIS IS THE TIME TO PULL THE CHAIN
	MOVEM	A,RUNTIM		;SAVE IT FOR DURING THE RUN
	MOVE	A,MAXETM		;COMPUTE 10% ELPSED TIME USED TRIGGER
	ADDI	A,^D5
	IDIVI	A,^D10
	CAIG	A,^D60000		;TRIGGER AT LEAST 60 ELAPSED SEC
	MOVEI	A,^D60000
	MOVEM	A,RUNTRG

	SETZB	D,JOBN			;ZERO JOB NUMBER AND CTL SAVED CHAR
RUN0:	PUSHJ	P,CHKOUT		;GO CHECK FOR PTY OUTPUT
	JFCL				;NO OUTPUT, KEEP GOING
	CAIN	D,15			;IS INPUT CHAR A (CR)-SKIPS FIRST TIME
	JRST RUN02			;YES,END OF LOGIN, NO MORE FOR NOW
	PUSHJ	P,RCCTL			;GET CHAR OF LOGIN SEQUENCE
	BUG(<RUN0: Non skip return from RCCTL>) ;NO,JOB CHECK WITH LOG LINE!?
	MOVE	D,B			;SAVE IT TO KNOW WHEN TO QUIT
RUN01:	MOVE	A,PTY			;GET OUR PTY
	PSTI				;STUFF IT
	JRST [	MOVEI	A,^D100		;BUFFER FULL
		DISMS			;COME BACK IN 100MS
		JRST RUN01]		;AND TRY AGAIN
	CAIE	D,15			;JUST SEND CR?
	JRST	RUN0			;NO, GO BACK AND DO NEXT CHAR
	TIME				;YES, SET TIME OUT TRIGGER
	ADDI	A,^D240000		;TIME OUT IN 4 MINUTES
	PUSH	P,A			;STASH IT

RUN02:	MOVEI	A,^D1000		;WAIT A SEC BEFORE CHECKING
	DISMS
	TIME				;HAS TIME OUT PASSED?
	CAMLE	A,0(P)
	ERROR	<TIME OUT WHILE ATTEMPTING LOGIN>,ABEND		;OOPS!
	PUSHJ	P,TTYJ			;GET JOB NUMBER
	JRST	RUN0			;NONE YET
	JRST	RUN0			;NONE YET
	JFCL				;JOB SEEMS TO BE HERE
	JFCL
	TLNE	A,400000		;BE SURE REAL JOB NUMBER
	JRST	RUN0			;NOT QUITE YET
	HLRZM	A,JOBN			;ISOLATE JOB NUMBER AND PARK IT
	HRR	A,JOBDIR		;SEE IF LOGGED IN YET
	GETAB
	BUG(<RUN02: Getab on JOBDIR failed>)
	TRNN	A,-1			;LOGGED IN?
	JRST 	RUN0			;NO, go back till we are

	POP	P,A			;OK LOGGED IN - CLEAR TIME OUT
IFN	SKUSER,<
RUN03:	MOVEI	A,^D1000
	DISMS				;WAIT TILL THE EXEC SETTLES DOWN
	PUSHJ	P,CHKOUT		;GET ANY OUTPUT SO HE DOESN'T 
	JFCL				;CHOKE ON HIS OUTPUT BUFFER
	MOVE	A,PTY
	PUSHJ	P,TTYJ			;ARE WE IN TTY WAIT?
	JFCL				;NO - TTY NOT THERE NOW
	ERROR	<TTY DISAPPEARED DURING STARTUP>,ABEND
	JRST	RUN03			;STILL RUNNING - WAIT SOME MORE
	MOVE	A,JOBN			;GET BACK JOB NUMBER
IFE TNX131, <
	SKIPGE	B,QENT+PRIOR		;GET PRIORITY ,DON'T BOTHER IF NORMAL
	SKUSR				;SET IF BATCH PRIOR
	>
IFN TNX131, <
	SKIPL	QENT+PRIOR		;STD BATCH PRIORITY?
	JRST	RUN1			;NO SPECIAL REQUEST - DON'T REDUCE IT
	MOVEI	B,1			;SET MAX AND WORKING TO 1%
	HRL	B,B
	SJPCT
	ERROR	<INVALID JOB PRIORITY PERCENTAGE>,ABEND
>
	>		;END OF IFN SKUSER
; Main run loop for feeding job
; Some terminating conditions jump in here because
; They have no place else to go !?

RUN1:	MOVE	A,JOBTTY
	HRL	A,JOBN
	GETAB
	BUG(<RUN1: Getab on JOBTTY failed>)
	CAIG	A,0
	ERROR <BATCH JOB HAS DETACHED ITSELF>,ABEND
	PUSHJ	P,CHKOUT		;GET OUTPUT CHAR IF ONE EXISTS
	JRST RUN2			;NONE EXISTED
	SETZM	NAPTIM			;CLEAR WAIT TIME CAUSE WE GOT CHAR
RUN2:	SKIPL	FRCTRM			;FORCED TERMINATION IN EFFECT?
	JRST RUN4			;YES, FORGET CHECKS OR INPUT CHARS
	PUSHJ	P,CHKLIM		;GO CHECK RESOURCE CONSUMPTION
					;AGAINST LIMITS

	PUSHJ	P,TTYJ			;GET TTY STATE INFO
	JRST	RUNNOJ			;THERE'S NO JOB HERE ANYMORE
	BUG	(<RUN2:  PTY BEING ASSIGNED IN MIDDLE OF JOB>)
	JRST	RUN3			;JOB IS STILL RUNNING
	PUSHJ	P,RCCTL			;JOB IS IN TTY WAIT - GET A
					;CHAR FROM CONTROL FILE
	JRST RUNNOJ			;NO JOB, CLEAN UP
RUN21:	CAIE	B,3			;IS THE CHARACTER ^C
	JRST	RUN24			;NO - GO TREAT AS REGULAR CHAR

;HERE WE HAVE TO SEND A ^C - MAKE SURE JOB IS STABLE IN TTY WAIT MODE
;AND THEN DO IT

	PUSH	P,[-1]			;SET DUMMY INPUT BUFFER SIZE
RUN22:	PUSHJ	P,CHKOUT		;CHECK OUTPUT
	SKIPA				;NONE SO LOOK AT INPUT BUFFER
	JRST	[MOVEI	A,^D1000	;HAD OUTPUT - WAIT 1 SEC
		 DISMS
		 PUSHJ	CHKLIM		;RESOURCES OUT
		 JRST	RUN22]		;NO, GO TRY AGAIN
	MOVE	A,PTY			;CHECK INPUT BUFFER
	SIBE
	JRST	[EXCH	B,0(P)		;SOME STUFF IN THE BUFFER
		 SUB	B,0(P)		;ANY CHANGE FROM LAST TIME
		 JUMPE	B,RUN23		;NO, GO CHECK TTY STATE
		 MOVEI	A,^D15000	;YES, WAIT A WHILE - BE SURE HE
		 DISMS			;WON'T TAKE IT BEFORE FLUSHING IT
		 JRST	RUN22]		;CHECK STATUS AGAIN

RUN23:	PUSHJ	P,TTYJ			;CHECK TTY STATE
	JRST	RUNNOJ			;NO JOB - GO CLEAN UP
	BUG	(<RUN23: PTY REASSIGNED IN MIDDLE OF JOB>)
	JRST	[PUSHJ	P,CHKLIM	;RUNNING - CHECK RESOURCES
		 MOVEI	A,^D5000	;OK - WAIT 5 SEC
		 DISMS
		 JRST	RUN22]		;GO TRY IT AGAIN
	POP	P,A			;OK STABLE NOW - STICK ^C
	PUSHJ	P,CTLCO
	JRST	RUN25			;PROCEED

RUN24:	MOVE	A,PTY			;GET PTY#
	PSTI				;GIVE JOB THE CHAR
	JRST [	MOVEI	A,^D100		;GO AWAY FOR A WHILE
		DISMS			;BUT COME BACK HERE
		JRST RUN24]		;SO WE DON'T LOSE THE CHAR 

RUN25:	SETZM	NAPTIM			;CLEAR WAIT CAUSE HE TOOK CHAR.
	JRST RUN1			;GO BACK FOR OUTPUT (PROBABLY ECHO)

RUN3:	MOVE	A,NAPTIM		;GET WAIT TIME
	CAILE	A,NAPMAX		;TOO LONG
	MOVEI	A,NAPMAX		;SET TO MAX
	MOVEM	A,NAPTIM		;RESET TIME (IF CHANGED)
	CAIGE	A,NAPMIN		;TOO SHORT?
	MOVEI	A,NAPMIN		;IF SO, RESET TO MIN
	DISMS				;TAKE NAP, ZZZZZZ...

;INCREASE WAIT TIME SO THAT WE WILL LOOK LESS FREQUENTLY
;AT A JOB THAT IS NOT DOING TERMINAL IO.
;THIS ROUTINE IS A SOMEWHAT ARBITRARY HEURISTIC.
;IT SHOULD ALSO BE NOTED THAT THE LOWERING OF THE WAIT TIME
;BY THE SETZM IN RUN1 AND RUN2 ARE A PART OF THIS WAIT TIME
;CALCULATION.  IT MAY NOT ALWAYS BE DESIRED TO RESET TO 0
;THE WAIT TIME ON ACTIVITY, BUT IT SEEMS VERY LIKELY, SINCE
;IF A JOB TYPES A CHAR OR READS ONE, HE IS LIKELY TO DO
;ONE OF THOSE OPERATIONS AGAIN IN A VERY SHORT TIME (EACH
;GROUP OF CHARS IN AN IO STREAM HAS ONLY ONE LAST CHAR.)
;THUS IF GROUPS ARE N CHARS IN LENGTH, THERE IS
;A PROBABILITY OF (N-1)/N THAT ANOTHER FOLLOWS.
	MOVEI	A,^D1000		;ADD ONE SECOND
	ADDM	A,NAPTIM		;TO WAIT TIME
	JRST	RUN1			;AND CHECK FOR OUTPUT

;IF A CTL FILE IS NOT TERMINATED BY A .LOGO OR .K STATEMENT,
;THEN FORCE FEED THE JOB A LOGO TO LOG IT OUT
RUN4:	SKIPE	FRCTRM			;IN LOGOUT PROCESS
	JRST	RUN5			;NO, GO WAIT FOR JOB TO TERMINATE
	ILDB	B,LOGSTR		;GET NEXT CHARACTER OF LOGO
	SKIPE	B			;END OF LOGO REACHED ?
	JRST	RUN21			;NO, FEED CHARCTER TO JOB
	AOS	FRCTRM			;YES, NOW WAIT FOR TERMINATION
;;;	MOVEI	1,NAPMAX		;TAKE A NAP BEFORE CHECKING FOR
;;;	MOVEM	1,NAPTIM		;SUCCESSFUL LOGOUT
	JRST	RUN1

;	WAIT UNTIL OUTPUT BUFFER EMPTY AND THEN WAIT FOR JOB TO
;	GO AWAY. INSURES ALL OUTPUT IS MOVED TO LOG FILE.
RUN5:	MOVE	A,PTY			;PSEUDO-TTY NUMBER
	SOBE				;SKIP IF OUTPUT BUFFER EMPTY
	JRST RUN3			;DATA IN BUFFER, TRY LATER
	PUSHJ	P,JBST			;CHECK JOB STATUS
	JRST RUNNOJ			;JOB IS LOGGED OUT
	JFCL				;DON'T CARE IF IN EXEC
	JRST RUN3			;JOB STILL RUNNING, TRY LATER


; KILLIT routine
; Forces a ^C down the job's throat to get the attention of the EXEC
; And then sets the FRCTRM flag so we can put a LOGOUT on it

KILLIT:	SETZM	FRCTRM			;SAY WE WANT A LOGOUT ON HIM
	PUSHJ	P,CTLCO			;SEND HIM A ^C
	JRST RUN1			;IN EXEC TTY WAIT - GO DO OUR
					;OWN LOGOUT


;ROUTINE FOR IMMEDIATE SUICIDE

KILLME:	ERROR	(<JOB ABORTED BY SYSTEM STAFF>,IFEOJ1)


;PSEUDO INTERRUPT HANDLER FOR SUICIDE CALL
SUICID:	PUSH	P,A			;CHANGE INTERRUPT RETURN TO
	MOVEI	A,KILLME		;SUICIDE ROUTINE
	MOVEM	A,LEV3PC
	POP	P,A
	DEBRK



;	PSEUDO INTERRUPT CODE TO SET FORK DESUBMISSION FLAG
DESUBF:	SETOM	INFDSB			;SET DESUBMIT FLAG
	DEBRK


;PSEUDO INTERRUPT ROUTINE TO SAVE FORK AC'S IN CSHACS AND THEN TO FREEZE
SAVACS:	MOVEM	P,CSHACS+P		;SAVE STACK POINTER
	MOVEI	P,CSHACS		;DO THE REST
	BLT	P,CSHACS+16
	MOVE	P,LEV3PC		;SAVE PC IN RIGHT PLACE
	MOVEM	P,CSHPC
	MOVE	P,CSHACS+P		;RESTORE THE STACK POINTER
	SETOM	ACSDON			;SIGNAL WE HAVE THE AC'S

SAVAC0:	SKIPL	ACSDON			;FLAG RESET YET?
	JRST	SAVAC1			;YES, CARRY ON
	MOVEI	A,^D1000		;NO, THEN WAIT A SECOND
	DISMS
	JRST	SAVAC0			;AND TRY AGAIN

SAVAC1:	MOVE	A,CSHACS+A		;RESTORE AC A
	DEBRK				;AND TAKE OFF AGAIN



;NO JOB FOUND THERE, CHECK WHAT HAPPENED
RUNNOJ:	PUSHJ	P,TTYJ			;GET TTY INFORMATION AGAIN
	JRST	IFEOJ			;TTY UNASSIGNED, END RUN
	ERROR	<RUNNOJ:  TTY BEING REASSIGNED>,ABEND
	ERROR	<RUNNOJ:  ACTIVE JOB REAPPEARED>,ABEND
	ERROR	<RUNNOJ:  ACTIVE JOB REAPPEARED>,ABEND


;ABEND ROUTINE--KILL WITH MESSAGE
ABEND:	ERROR	<ABORTING JOB>,IFEOJ



;ROUTINE TO SEND ^C TO PTY AND TO ENSURE JOB IS IN EXEC TTY WAIT

CTLCO:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	MOVEI	C,4			;MAX # OF ^C'S TO SEND

SENDC:	MOVE	A,PTY
	MOVEI	B,3			;LETS HAVE A ^C
	PSTI				;AND STICK IT TO HIM
	JRST	[MOVE	A,PTY		;BUFFER IS FULL SO CLEAR IT
		 CFIBF
		 MOVEI	A,^D1000	;WAIT A BIT
		 DISMS			;TRY AGAIN LATER
		 JRST	SENDC]
	SOSGE	C			;HAVE WE SENT ENOUGH?
	ERROR	<JOB NOT RESPONDING TO ^C>,ABEND	;YES, FLUSH HIM
	MOVEI	D,^D15			;WAIT 15 CHECK CYCLES FOR ^C TO BE READ
	SETZ	F,			;FLAG INDICATING SOME OUTPUT RECEIVED

EXECWT:	MOVEI	A,^D1000		;WAIT A BIT TO LET THINGS HAPPEN
	DISMS
	SOSGE	D			;HAVE WE HAD ENOUGH CYCLES FOR THIS ^C?
	JRST	SENDC			;YES, GIVE HIM ANOTHER ONE
	PUSHJ	P,CHKOUT		;SEE IF ANY OUTPUT
	JRST	[SKIPE	F		;MAKE SURE WE HAVE GOTTEN SOMETHING
		 JRST	EXCWT0		;OK - MOVE ON
		 PUSHJ	P,JBST		;NOTHING YET - JOB STILL THERE?
		 JRST	RUNNOJ		;NO - FINISH THINGS OFF
		 JFCL
		 JRST	EXECWT]		;STILL THERE - WAIT SOME MORE
	AOS	F			;GOT SOMETHING NOW - SET FLAG

EXCWT0:	MOVE	A,PTY			;INPUT BUFFER EMPTY?
	SIBE
	JRST	EXECWT			;YES, WAIT A BIT AND CHECK AGAIN

	PUSHJ	P,JBST			;FIND OUT IF HE IS IN EXEC YET
	JRST RUNNOJ			;JOB NOT THERE ANYMORE - END IT
	JRST 	EXECWT			;NOT IN EXEC - WAIT OUT 15 SEC

					;HERE HE IS IN THE EXEC BUT WE
	PUSHJ	P,TTYJ			;ALSO NEED HIM IN TTY WAIT
	JRST	RUNNOJ			;LINE UNASSIGNED - JOB GONE
	BUG	(<CTLCO: PTY BEING ASSIGNED IN MIDDLE OF JOB>)
	JRST	EXECWT			;STILL RUNNING - WAIT SOME MORE
					;TO SEE WHAT HAPPENS, COULD BE
					;LOGO

EXFIN0:	PUSHJ	P,CHKOUT		;OK, SEEMS TO BE READY - FINAL CHECK
	SKIPA				;NO NEW OUTPUT - CARRY ON
	JRST	EXECWT			;OOPS, GOT SOME MORE - GO BACK
	MOVE	A,PTY			;SEND ";^G" AND DEMAND RIGHT RESPONSE
	PUSH	P,C			;SAVE ^C LEFT COUNT
	MOVEI	C,^D3			;COUNT OF CHARS TO BE SENT
	MOVE	D,[POINT 7,[BYTE (7) ";",7,15,0,0]]	;STRING ";^G<CR><LF>"
EXFIN1:	ILDB	B,D			;GET FIRST BYTE
	PSTI
	JRST	EXFERR			;BAD NEWS
	SOJG	C,EXFIN1		;DO THEM ALL

	MOVEI	C,^D5			;PREPARE TO GET THE OUTPUT
	MOVE	D,[POINT 7,[BYTE (7) ";",7,15,12,"@"]]
EXFIN2:	MOVEI	E,^D15			;WAIT MAX 15 SEC FOR EACH ECHO
EXFIN3:	SETZ	B,			;DON'T WAIT IF NO OUTPUT
	PSTO				;GET A RESPONSE
	JRST	[MOVEI	A,^D1000	;BAD NEWS, WAIT A BIT AND TRY AGAIN
		 DISMS
		 MOVE	A,PTY
		 SOJGE	E,EXFIN3
		 JRST	EXFERR]		;OUT OF LUCK
	ILDB	E,D			;GET WHAT CHARACTER IS SUPPOSED TO BE
	CAME	B,E			;IS IT WHAT WE SENT?
	JRST	[CAIE	E,"@"		;DID WE JUST TRY "@"?
		 JRST	EXFERR		;NO - THEN WE HAVE TROUBLE
		 CAIE	B,"!"		;YES - THEN TRY "!", HE MAY BE ENABLED
		 JRST	EXFERR		;NOT THAT EITHER - BAD NEWS
		 JRST	.+1]		;WHEW, MADE IT!
	SOJG	C,EXFIN2		;ANY MORE LEFT?

	POP	P,C			;RECOVER REMAINING ^C COUNT

	POP	P,D			;ALL SET NOW SO RETURN
	POP	P,C
	POP	P,B
	POP	P,A

	POPJ	P,


EXFERR:	POP	P,C			;RECOVER REMAINING ^C COUNT
	MOVE	A,PTY			;CLEAR BUFFERS
	CFIBF				;INPUT FIRST
	CFOBF				;THEN OUTPUT
	JRST	SENDC			;HIT HIM AGAIN.



;ROUTINE TO CHECK RESOURCE LIMIT USAGE.  IF ANY IS EXCEEDED, IT IS AUGMENTED
;BY 10% AND A CONTROL SIGNAL SENT IF REQUESTED.  THE JOB IS TERMINATED IF THE
;AUGMENTED LIMITED IS AGAIN EXCEEDED.  IF AN INTERRUPT IS ARMED, THE
;APPROPRIATE CONTROL CHARACTER IS SENT TO THE JOB (ONCE).  UPON ENTERING
;THE EXEC, CONTROL CHARACTERS ARE RESET TO NULL.
;CLOBBERS AC 1

CHKLIM:	PUSH	P,B			;SAVE AC
	PUSHJ	P,JBST			;JOB STATUS
	JRST	CHKLM2			;NO JOB, RETURN
	JRST	CHKLM0			;RUNNING, BUT NOT EXEC - SET FLAG

	SKIPE	CEXCSW			;IN EXEC NOW, HAVE WE BEEN?
	JRST	CHKLM1			;YES, DON'T RESET CONTROLS
	SETOM	CEXCSW			;NO, SET SWITCH AND CLEAR CONTROLS
	SETZM	CPUCHR
	SETZM	RUNCHR
	SETZM	LINCHR
	JRST	CHKLM1			;NOW GO CHECK LIMITS

CHKLM0:	SETZM	CEXCSW			;NON-EXEC FLAG

CHKLM1:	MOVE	A,JOBRT
	HRL	A,JOBN
	GETAB
	BUG(<RUN2: Getab on JOBRT failed>)
	CAMG	A,MAXCPU		;LIMIT EXCEEDED?
	JRST	CPLIM0			;NO - SEE IF SIGNAL NEEDED
	MOVEM	A,MAXCPU		;STORE CURRENT VALUE
	SKIPN	A,CPUTRG		;YES, KILL IT IF AUGMENT GONE
	ERROR <Job exceeded max CPU time>,KILLIT 	;KILL HIS ASS
	SETZM	CPUTRG
	ADDM	A,MAXCPU		;AUGMENT LIMIT ONCE
CPLIM0:	MOVEI	B,CPUCHR		;NOT OVER YET - NEEDS WARNING?
	SKIPN	CPUTRG
	PUSHJ	P,LIMTKL		;YES - TICKLE HIM

	TIME				;GET TODCLK
	CAMG	A,RUNTIM		;IS HE RUNNING BEYOND HIS LIMIT
	JRST	RNLIM0			;NO - SEE IF SIGNAL NEEDED
	MOVEM	A,RUNTIM		;STORE CURRENT VALUE
	SKIPN	A,RUNTRG		;YES, KILL IT IF AUGMENT GONE
	ERROR <Job exceeded max elapsed time>,KILLIT 	;KILL HIS ASS
	SETZM	RUNTRG
	ADDM	A,RUNTIM		;AUGMENT LIMIT ONCE
RNLIM0:	MOVEI	B,RUNCHR		;NOT OVER YET - NEEDS WARNING?
	SKIPN	RUNTRG
	PUSHJ	P,LIMTKL		;YES - TICKLE HIM

	SKIPGE	INFDSB			;THIS JOB DESUBMITTED
	ERROR <Job Desubmitted>,KILLIT	;YES

	SKIPL	MAXLOG			;HAS LOG GONE OVER THE LIMIT?
	JRST	LGLIM0			;NO - SEE IF SIGNAL NEEDED
	SKIPN	A,LOGTRG		;YES, KILL IT IF AUGMENT GONE
	ERROR <Log file size exceeded limit>,KILLIT 	;KILL THE JOB
	SETZM	LOGTRG
	MOVEM	A,MAXLOG		;AUGMENT LIMIT ONCE
LGLIM0:	MOVEI	B,LINCHR		;NOT OVER YET - NEEDS WARNING?
	SKIPN	LOGTRG
	PUSHJ	P,LIMTKL		;YES - TICKLE HIM

CHKLM2:	POP	P,B			;RESTORE AC
	POPJ	P,			;ALL OK - RETURN



;ROUTINE TO GIVE RESOURCE LIMIT WARNING TO USER IF APPROPRIATE CONTROL
;CHARACTER IS NON-ZERO AND IF IT HASN'T BEEN SENT YET.
;ON ENTRY:	B CONTAINS ADDRESS OF CONTROL CHARACTER

LIMTKL:	SKIPE	CEXCSW			;ARE WE IN THE EXEC?
	POPJ	P,			;YES, THEN NO INTERRUPTS

	PUSH	P,B			;SAVE CHARACTER ADDRESS
	SKIPG	B,0(B)			;IS THERE ONE THAT HASN'T BEEN SENT?
	JRST	LIMTK0			;NO RETURN
	MOVE	A,PTY			;SEND CHARACTER TO PTY
	PSTI
	JRST	LIMTK0			;BUFFER FULL - WAIT UNTIL NEXT TIME
	SETZM	@0(P)			;NULL OUT CHARACTER

LIMTK0:	POP	P,B			;RESTORE AC
	POPJ	P,			;RETURN


;END OF JOB REACHED.  CLEAN UP NOW.

IFEOJ:	PUSHJ	P,CHKOUT		;GET THE LAST OF THE OUTPUT(IF ANY)
	JFCL				;NONE, FINE
	HRROI	B,JOBMSG		;JOB FINISHED MESSAGE
	HRROI	C,FINMSG
	SKIPGE	QENT+MESAG		;MESSAGE WANTED ?
	PUSHJ	P,SEND			;YES

	HRROI	B,JOBNOT
	HRROI	C,FINNOT
	SKIPGE	QENT+NOTFY
	PUSHJ	P,NOTIFY
	HRROI	B,JOBDAY		;DAY FILE STRINGS
	HRROI	C,FINDAY
	PUSHJ	P,DAY			;ADD NOTICE TO DAYFILE
IFEOJ1:	MOVE	A,PTY			;RELEASE PTY
	JUMPLE	A,IFEOJ2		;JUMP IF NULL PTY NUMBER
	REPTY				;GIVE IT UP
	ERROR	<REPTY FAILED--BAD NEWS>,IFEOJ2
IFEOJ2:	HRRZ	A,CTLJFN		;CLOSE INPUT FILE
	CLOSF
	ERROR	<ERROR CLOSING CTL FILE>
	SETZM	CTLJFN			;SAY NONE AROUND
	HRRZ	A,LOGJFN		;CLOSE LOG FILE
	CLOSF
	JFCL				;WHO COULD WE TELL ABOUT IT?
	SETZM	LOGJFN			;NO MORE LOG FILE
IFEOJ4:	SKIPE	FORK			;IS SNDMSG FORK STILL ACTIVE
	JRST	[MOVEI	A,^D10000	;YES, TRY AGAIN LATER
		 DISMS
		 JRST	IFEOJ4]		;GO CHECK AGAIN
	NOINT				;KILL INTERRUPTS
	HALTF				;NO, EXIT
	JRST	.-1


;PUTS IT IN LOGLIN IF THERE IS ANY
;SKIPS IN RETURN IF THERE WAS OUTPUT.
CHKOUT:	MOVE	A,PTY			;GET PTY ID
	SETZ	B,			;DON'T WAIT IF NONE READY
	PSTO				;TRY FOR OUTPUT
	POPJ	P,			;NO OUTPUT
	AOS	(P)			;OUTPUT, SO SKIP
CHKOU2:	ANDI	B,177			;ONLY 7 BITS
	PUSHJ	P,ADDLOG		;ADD THE CHAR TO THE LOG
	MOVE	A,PTY			;GET PTY ID AGAIN
	SETZ	B,			;DON'T BLOCK FOR OUTPUT
	PSTO				;TRY FOR ANOTHER CHAR
	POPJ	P,			;RETURN
	JRST	CHKOU2			;WE GOT IT, SO TAKE CARE OF IT.

;APPEND A CHAR TO LOGLIN, OUTPUT BUFFER IF NEEDED.

ADDLOG:	MOVE	A,LOGLIN+1		;GET COUNTER
	CAML	A,LOGLIN		;IS IT IN RANGE?
	PUSHJ	P,ADLOG2		;NO-WRITE FULL BUFFER
	IDPB	B,LOGLIN-1		;SAVE CHARACTER

;CHECK IF FIRST CHARACTER OF LINE, IF SO GET THE SUBSYS NAME
	SKIPE	LOGLIN+1		;FIRST?
	JRST	ADLOG1			;NO

;IF FORCED TERMINATION, OUTPUT CHARCTERS UNTIL PTY OUTPUT BUFFER IS EMPTY
	SKIPL	FRCTRM			;FORCED TERMINATION ?
	JRST	ADLOG1			;YES, CONTINUE TO OUTPUT CHARACTERS

	PUSHJ	P,JBST			;GET HIS STATUS
	MOVE	A,[SIXBIT /BATCON/]	;NO JOB SO SAY JUST US
	JFCL				;A SUBSYSTEM
	MOVEM	A,SBJBNM		;EXEC, SAVE NAME

ADLOG1:	AOS	LOGLIN+1		;COUNT IT
	CAIE	B,15			;IGNORE EOL'S THAT ARE CR
	PUSHJ	P,SKEOL			;WAS IT AN EOL OF SOME SORT?
	POPJ	P,			;NO--RETURN
	TLO	ZZ,L.NOEL		;SEND NO EOL BY SNDLOG, WE ALREADY HAD ONE

ADLOG2:	PUSH	P,B			;SAVE REGISTERS SO WE CAN WRITE LINE
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E

	MOVE	C,SBJBNM		;GET NAME OF SUBSYS SUBJOB IS IN

	MOVEI	D,LOGLIN		;POINT TO LINE TO SEND
	PUSHJ	P,SNDLOG		;SEND THE LINE
	MOVE	A,[POINT 7,LOGLIN+2]	;RESTORE THE POINTERS
	MOVEM	A,LOGLIN-1		;GET BYTE POINTER AGAIN
	SETZM	LOGLIN+1		;AND CLEAR COUNT
	POP	P,E			;RESTORE REGISTERS SAVED
	POP	P,D
	POP	P,C
	POP	P,B
	POPJ	P,			;RETURN
;	SET UP FOR SENDING INTERNAL MESSAGE TO USER LOG FILE
INTMSG:	MOVE	C,[SIXBIT /BATCON/]		;SUBSYSTEM NAME
	MOVEI	D,MSGLIN			;MESSAGE ADDRESS
	SETOM	MSGLIN+1			;TERMINATE ON ZERO BYTE RATHER
						;THAN BYTE COUNT
	PUSHJ	P,SNDLG0			;SEND MESSAGE TO FILE
	SETZM	MSGLIN+1			;CLEAR CHARACTER COUNT
	POPJ	P,0

;SEND LOG LINE TO LOG, CALL
;	IN C SIXBIT, MSG TYPE
;	IN D ADDRESS OF LINE BUFFER
;	LINE BUFFER: FIRST WORD MAX # CHARS 
;	2ND WD, # CHARS DATA
;	3RD WD ON, THE DATA
;	DESTROYS REGISTERS A,B,C,D,E

SNDLOG:	SOS	MAXLOG			;COUNT THE USER LOG LINE (CHK IN MAIN)
SNDLG0:	MOVE	A,LOGJFN		;GET THE LOG JFN
	CAIGE	A,2			;LEGAL JFN ?
	BUG (<Output jfn illegal in SNDLOG>)

	PUSH	P,C			;SAVE C
	SETO	B,			;USE INTERNAL TIME
	MOVSI	C,(1B0)			;DON'T PRINT DATE
	ODTIM				;GIVE HH:MM:SS
	MOVEI	B," "			;SPACE AFTER TIME
	BOUT
	POP	P,C			;RESTORE C

	MOVEI	E,6			;LENGTH OF TYPE
SNDLG1:	SETZ	B,			;CLEAR WORD TO BUILD TYPE
	LSHC	B,6			;GET CHAR IN SIXBIT
	ADDI	B,40			;MAKE 7BIT
	BOUT
	SOJG	E,SNDLG1		;LOOP UNTIL DONE

	MOVEI	B,11			;TAB
	BOUT				;BEFORE LINE

	MOVE	E,1(D)			;GET LENGTH
	MOVEI	D,2(D)			;POINT TO LINE
	HRLI	D,440700		;MAKE BYTE POINTER TO IT

	JUMPL	E,SNDLG5		;JUMP FOR ZERO BYTE TERMINATION

SNDLG2:	ILDB	B,D			;GET A CHARACTER
	JUMPE	B,.+2			;DON'T OUTPUT NULLS
	BOUT				;PUT IT OUT
	SOJG	E,SNDLG2		;LOOP UNTIL DONE

SNDLG4:	TLZE	ZZ,L.NOEL		;DOES HE WANT US TO APPEND EOL SEQ?
	POPJ	P,			;NO--SO RETURN

;SCRLF - ROUTINE TO SEND CRLF TO DESIRED FILE (JFN IN A)
;FALLEN INTO BY SNDLOG.
SCRLF:	MOVEI	B,15			;CR
	BOUT
	MOVEI	B,12			;LF
	BOUT

	POPJ	P,			;RETURN

SNDLG5:	MOVE	E,0(D)			;MAXIMUM NUMBER OF CHARACTERS IN BUFFER
SNDLG6:	ILDB	B,D
	JUMPE	B,SNDLG4		;END OF OUTPUT IF ZERO
	BOUT				;OUTPUT CHARACTER
	SOJG	E,SNDLG6
	JRST	SNDLG4			;FINISH OUTPUT

;FIND SUBJOB STATUS
;NON-SKIP RETURN IF NO JOB
;SKIP RETURN IF THERE IS AND
;DOUBLE SKIP RETURN IF THE SUBJOB IS IN EXEC

JBST:	PUSHJ	P,TTYJ			;FIND THE JOB #
	POPJ	P,			;NO JOB HERE
	POPJ	P,			;NO JOB HERE
	JFCL				;THERE IS A JOB
	AOS	0(P)			;SKIP AT LEAST ONCE
	TLZ	A,400000		;ISOLATE JUST JOB NUMBER
	HRR	A,JOBNAM		;GET TABLE NUMBER
	GETAB				;GET TABLE ENTRY
	BUG(<JBST: Couldn't get JOBNAM table>)
	HRLZ	A,A			;GET INDEX TO USE FOR DETERMINING STATE
	HRR	A,SNAMES		;GET TABLE #
	GETAB				;GET WHAT HE IS IN
	BUG(<JBST: Couldn't get SNAMES table>)
	CAMN	A,[SIXBIT /EXEC/]	;ARE WE IN EXEC
	AOS	(P)			;YES, MAKE SKIP (+2)
	POPJ	P,			;RETURN

;INDEX TABLE TTYJOB TO FIND JOB# FOR THIS LINE
;AND JOB STATUS (WHETHER OR NOT IT IS IN STATE TI IN ANY FORK).
;RETURN WITH LH A 	>0 JOB #
;			OR 400000+JOB#
;			OR -1 IF UNASSIGNED LINE
;			OR -2 IF LINE IN PROCESS OF BEING ASSIGNED
;		RH A	-1 IF NO FORK WAITING FOR INPUT
;			NOT -1 SOME FORK IS WAITING FOR INPUT FROM THIS LINE
;SKIP RETURN:	+1 => UNASSIGNED LINE
;		+2 => LINE BEING ASSIGNED
;		+3 => LINE ASSIGNED AND JOB RUNNING
;		+4 => LINE ASSIGNED AND JOB IN TTY WAIT

TTYJ:	PUSH	P,B			;SAVE WORKING AC'S
	MOVE	A,TTYJOB		;GET TABLE NUMBER
	HRL	A,PTY			;GET PTY LINE # (AS INDEX)
	TLZ	A,400000		;TURN OFF THIS BIT
	GETAB				;GET JOB NUMBER AND STUFF
	BUG(<TTYJ: Couldn't find job number>)
	HLRZ	B,A			;GET LEFT HALF INFO
	CAIN	B,-1			;IS IT -1
	JRST	TTYDON			;YES - GO CLEAN UP
	AOS	-1(P)			;NO - BUMP SKIP BY 1
	CAIN	B,-2			;IS IT -2
	JRST	TTYDON			;YES - GO CLEAN UP
	AOS	-1(P)			;NO - BUMP SKIP BY 1
	HRRZ	B,A			;GET RIGHT HALF INFO
	TRC	B,-1			;COMPLEMENT JOB STATE BITS
					;NOW A = 0 => RUNNING
	TRNN	B,-1			;IS JOB IN TTY WAIT
	JRST	TTYDON			;NO - GO CLEAN UP
	AOS	-1(P)			;YES - BUMP SKIP BY 1

TTYDON:	POP	P,B			;RESTORE AC'S

	POPJ	P,			;RETURN



;GET A PTY, RECURSIVELY CHECK FOR A JOB AT THE OTHER END
;AND GO GET ANOTHER TILL WE FIND ONE WITHOUT..
;RETURNS +1	NO PTY AVAILABLE
;	 +2	GOT A PTY DESIG IN 1

.ASPTY:	SETZ	A,			;DO SYSTEM CHECK
	ASPTY				;GO GET ONE
	POPJ	P,			;NOTHING TO GET FAIL
	MOVEM	A,PTY			;PUT IT HERE FOR TTYJ
	PUSHJ	P,JBST			;JOB AT OTHER END?
	JRST [	MOVE	A,PTY		;NO JOB, GOOD GET THE DESIGNATOR
		AOS	(P)		;DO SKIP RETURN
		POPJ	P,]
	JFCL				;DON'T CARE WHAT STATE JOB IS IN
	MOVE	A,PTY			;GET THE DESIGNATOR
	PUSH	P,A			;AND SAVE IT TO RELEASE LATER
	PUSHJ	P,.ASPTY		;GO GET ANOTHER ONE
	JRST [	POP	P,A		;NO MORE LEFT,GET THE OLD ONE
		REPTY			;GET RID OF IT
		BUG(<.ASPTY: REPTY (1) failed>) ;SHOULDN'T HAPPEN RIGHT?!
		POPJ	P,]		;FAIL 'CUZ THER AIN'T ANY
	EXCH	A,(P)			;GOT A GOOD ONE, RETRIEVE THE OLD 1
	REPTY				;AND GET RID OF IT
	BUG(<.ASPTY REPTY (2) failed>)	;THIS SHOULDN'T HAPPEN EITHER--RIGHT?
	POP	P,A			;GET THE GOOD ONE
	AOS	(P)			;SKIP SAYS WE GOT A GOOD ONE
	POPJ	P,


;SUBROUTINE TO READ ONE CHARACTER FROM THE CTL FILE
;SKIPS IF THE JOB IS STILL THERE, NON-SKIP IF NO

RCCTL:	SKIPE	MODEI			;DOES HE NEED MODE CHANGE?
	JRST	RCCTL5			;YES, GO DO IT
	SOSGE	CTLLIN+1		;COUNT THE CHARACTER
	JRST	RCCTL2			;NEED TO GO READ IN A LINE
	ILDB	B,CTLLIN-1		;GET BYTE
	JUMPE	B,RCCTL			;GET RID OF NULLS
	AOS	(P)			;SKIP RETURN EVEN IF AT THIS LEVEL
	POPJ	P,			;WE DON'T REALLY KNOW

RCCTL2:	PUSHJ	P,RDCTL			;GO DO ACTUAL READ
	TRNN	ZZ,R.SEMI		;WAS LINE A COMMENT
	JRST	RCCTL3			;NO
	SOS	CTLLIN+1		;DROP OFF END OF LINE CHAR
	MOVEI	D,CTLLIN		;POINT TO INPUT BUFFER
	MOVE	C,[SIXBIT /USER/]	;GIVE LINE TYPE
	PUSHJ	P,SNDLOG		;SEND LINE TO LOG FILE
	JRST	RCCTL2			;GO READ ANOTHER LINE FROM CTL FILE

RCCTL3:	TRNN	ZZ,R.BLNK		;DOES HE WANT BLANK LINE ON LOG FILE?
	JRST	RCCTL4			;NO
	MOVE	C,[SIXBIT /USER/]	;GIVE RECORD TYPE
	MOVEI	D,BLANKL		;A BLANK LINE
	TLO	ZZ,L.NOEL		;DON'T APPEND CRLF
	PUSHJ	P,SNDLOG		;SEND IT TO LOG FILE
	JRST	RCCTL2			;GET ANOTHER LINE

RCCTL4:	TRZE	ZZ,R.PCTF		;DID WE GET ANY RESOURCE CONTROL STUFF
	PUSHJ	P,SETPCT		;YES, GO SET IT
	MOVEM	ZZ,MODEI		;SAVE CURRENT MODE

RCCTL5:	MOVE	ZZ,MODEI		;GET CURRENT MODE
	TRNE	ZZ,R.INTR		;INTERMEDIATE MODE WILL
					;GO WITH ANY JOB MODE
	JRST	RCCTL6			;IS AT INTERMEDIATE LEVEL.

	PUSHJ	P,JBST			;GET JOB STATUS
	POPJ	P,			;NO JOB, NON-SKIP RETURN
	JRST	RCCTL7			;HE IS USER LEVEL
	JRST	RCCTL8			;HE IS AT EXEC LEVEL

RCCTL6:	SETZM	MODEI			;CLEAR MODE REQUIREMENTS
	JRST	RCCTL			;GO GET THE INPUT

;AT USER LEVEL, DID CTL FILE WANT EXEC (MONITOR) LEVEL?
RCCTL7:	TRNN	ZZ,R.MONC		;DO WE WANT MONITOR?
	JRST	RCCTL6			;NO, BE HAPPY WITH THIS

;CHANGE LEVEL TO EXEC FROM USER BY GIVING A ^C
	MOVEI	B,"C"-100		;SET CHAR TO ^C
	AOS	(P)			;JOB STILL HERE, SKIP RETURN
	POPJ	P,			;RETURN

;AT MONITOR (EXEC) LEVEL, WHAT DID CTL FILE WANT?
RCCTL8:	TRNN	ZZ,R.USER		;DO WE WANT USER LEVEL?
	JRST	RCCTL6			;NO,  SO ACCEPT WHAT WE HAVE.

;HERE WE MUST FLUSH FOR A MONITOR LEVEL LINE.
;AS WE HAVE FOUND SUBJOB AT EXEC, INPUT IN USER MODE
RCCTL9:	PUSHJ	P,RDCTL			;GET A LINE
	TRNN	ZZ,R.MONC		;IS IT MONITOR LEVEL?
	JRST	RCCTL9			;NO
	JRST	RCCTL2+1		;YES-GO INTERPET IT.
;SUBROUTINE TO READ AND CLASSIFY A LINE FROM CTL FILE
RDCTL:	TRZ	ZZ,R.RCTL		;TURN OFF THE FLAGS WE WILL USE
	SETZM	CTLLIN+1		;ZERO COUNT OF CHARS READ
	MOVE	A,[POINT 7,CTLLIN+2]	;RESET POINTER TO LINE START
	MOVEM	A,CTLLIN-1		;WHERE WE USE IT

;READ A LINE FROM CTL FILE
	MOVE	A,CTLJFN		;GET THE JFN FOR INPUT FILE
	MOVE	C,[POINT 7,CTLLIN+2]	;POINT TO THE LINE
	MOVE	D,CTLLIN		;GET THE NUMBER OF CHARACTERS
					;THAT WE HAVE ROOM FOR.
RDLP:	BIN				;GET A CHARACTER
	IDPB	B,C			;STORE CHARACTER
	PUSHJ	P,SKEOL			;WAS IT EOL
	JRST	.+2			;NOT EOL
	SOJA	D,RDLPEL		;COUNT CHARACTER AND CONTINUE
	SOJG	D,RDLP			;COUNT CHARACTER AND LOOP

;ERROR HERE--INPUT LINE IS TOO LONG FOR OUR BUFFER
	ERROR	<INPUT LINE TOO LONG FOR BUFFER>,ABEND
;WE HAVE READ AN END OF LINE
RDLPEL:	SUB	D,CTLLIN		;COMPUTE HOW MUCH WAS IN LINE
	MOVMM	D,CTLLIN+1		;SAVE # CHARS WE HAVE STORED
	CAIE	B,15			;WAS IT A CR?
	JRST	RDEX1			;NO--GO EXAMINE LINE
	BIN				;READ THE LF
	CAIN	B,12			;WAS IT REALLY A LF?
	JRST RDEX1			;YES
	BKJFN				;NO--PUT IT BACK
					;THIS MAKES IT IMPOSSIBLE TO HAVE
					;CR NOT FOLLOWED BY LF IF THE CTL
					;FILE IS FROM DECTAPE OR SOMETHING
					;ELSE THAT WON'T ALLOW BKJFN
	ERROR <RDLPEL: BKJFN failed.>,ABEND ;DROP THE JOB
RDEX1:	MOVE	A,[POINT 7,CTLLIN+2]	;POINT TO LINE AGAIN
	MOVE	C,CTLLIN+1		;GET NUMBER OF CHARACTERS WE HAVE
RDEX2:	ILDB	B,A			;GET A CHAR
	CAIE	B,40			;SPACE OR
	CAIN	B,11			;TAB?
	JRST	.+2			;YES--SKIP OVER IT
	JRST	RDEX3			;NO--GOT SIGNIFIGANT CHARACTER
	SOJG	C,RDEX2			;EXAMINE NEXT CHARACTER IF MORE
	JRST	RDDUN			;GOTTA FILL IN ADDR--SEND LINE
					;IT HAS NO NON SPACE OR TAB CHARACTERS
RDEX3:	CAIN	B,"."			;DOES LINE START WITH A . ?
	JRST	EXPT			;YES
	CAIN	B,"@"			;DOES LINE START WITH A @ ?
	JRST	EXAT			;YES
	CAIN	B,"*"			;DOES LINE START WITH A * ?
	JRST	EXSTAR			;YES
	CAIN	B,";"			;DOES LINE START WITH A ; ?
	JRST	EXSEMI			;YES
	CAIN	B,"!"			;DOES LINE START WITH A ! ?
	JRST	EXSEMI			;YES (SAME AS ;)
	CAIN	B,"="			;DOES LINE START WITH A = ?
	JRST	EXEQ			;YES
	CAIN	B,"$"			;DOES LINE START WITH A $ ?
	JRST	EXDOLR			;YES
	CAIN	B,"%"			;DOES LINE START WITH A % ?
;	ERROR	<% IS RESERVED FOR BATCH SYSTEM LABELS--CONTINUING>
	JRST	EXPCT			;YES

;FALL THROUGH TO FLAG AS NOT SPECIAL
RDEX4:	TRO	ZZ,R.INTR		;SAY THAT LINE IS NEITHER SPECIFICALLY
					;DESTINED FOR MONITOR OR USER LEVEL
	JRST	RDTR2			;GO TAKE CARE OF ^'S, STARTING WITH
					;THIS CHARACTER IN B

EXPCT:	MOVE	D,[POINT 7,STRBUF]	;% MEANS SET RESOURCE LIMIT CONTROLS
					;FIRST ISOLATE COMMAND AFTER BLANKS
					;AND TABS
PCTSBL:	SOJLE	C,PCTERR		;ERROR - NOTHING BUT BLANKS
	ILDB	B,A			;NEXT CHAR
	PUSHJ	P,SKEOL			;EOL CHAR?
	SKIPA				;NO
	JRST	PCTERR			;YES - EMPTY LINE
	CAIN	B," "			;BLANK?
	JRST	PCTSBL			;YES, SKIP IT
	CAIN	B,11			;TAB?
	JRST	PCTSBL			;YES, SKIP IT

PCTCOM:	CAIL	B,"a"			;GOOD COMMAND CHAR - CONVERT TO
	CAILE	B,"z"			;UPPER CASE AND SAVE IT
	SKIPA
	SUBI	B,"a"-"A"
	IDPB	B,D
	SOJLE	C,PCTCPR		;END - RECOGNIZE COMMAND?
	ILDB	B,A			;NEXT CHAR
	PUSHJ	P,SKEOL			;EOL?
	SKIPA				;NO
	JRST	PCTCPR			;YES - RECOGNIZE COMMAND?
	CAIN	B," "			;BLANK?
	JRST	PCTCPR			;YES - RECOGNIZE COMMAND?
	CAIN	B,11			;TAB?
	JRST	PCTCPR			;YES - RECOGNIZE COMMAND?
	JRST	PCTCOM			;MORE CHARACTERS IN COMMAND

PCTCPR:	PUSH	P,A			;SAVE PTR INTO INPUT STRING
	PUSH	P,C			;SAVE REMAINING CHAR COUNT
	SETZ	B,			;MAKE COMMAND STRING ASCIZ
	IDPB	B,D
	MOVSI	C,-NLMTSW		;NUMBER OF POSSIBLE COMMANDS
	SETZ	D,			;NUMBER OF HITS
	SETZ	E,			;INDEX OF LAST HIT
PCTCP0:	MOVE	A,[POINT 7,STRBUF]	;INPUT "COMMAND" STRING
	HRRZ	B,C			;PTR TO COMMAND LIST
	LSH	B,1
	HRRZ	B,LMTSGL(B)
	HRLI	B,440700
	PUSHJ	P,STRCMP		;COMPARE THEM
	JRST	PCTCP1			;NO MATCH - TRY NEXT ONE
	JFCL
	AOJ	D,			;BUMP HIT COUNT
	HRRZ	E,C			;SAVE INDEX
PCTCP1:	AOBJN	C,PCTCP0		;TRY THEM ALL

	CAIE	D,1			;UNIQUE MATCH?
	JRST	PCTERR			;NO - POST ERROR
	POP	P,C			;RECOVER CHAR COUNT
	POP	P,A			;AND INPUT STRING POINTER
PCTLET:	SOJLE	C,PCTLT0		;NOW FIND THE CONTROL CHARACTER
	ILDB	B,A			;NEXT CHAR
	PUSHJ	P,SKEOL			;EOL
	SKIPA				;NO
	JRST	PCTLT0			;YES - SET NULL
	CAIN	B," "			;BLANK?
	JRST	PCTLET			;YES - GET NEXT ONE
	CAIN	B,11			;TAB?
	JRST	PCTLET			;YES - GET NEXT ONE
	SKIPA				;NON-SEPARATOR LETTER, TEST IT

PCTLT0:	MOVEI	B,"@"			;NO CHAR SPECIFIED - DEFAULT NULL
	TRNN	B,100			;IN RIGHT ALPHA RANGE?
	JRST	PCTERR			;NO - FLAG ERROR
	TRZ	B,140			;YES, MAKE IT A CONTROL CHARACTER

	TRNE	ZZ,R.PCTF		;IS THIS A NEW RESOURCE CTL SETTING?
	JRST	PCTLT1			;NO, DON'T CLEAR THINGS OUT
	SETO	C,			;YES, CLEAR OUT TEMP STORAGE FOR 
	HRLM	C,CPUCHR		;NEW CHARS 
	HRLM	C,RUNCHR
	HRLM	C,LINCHR
	TRO	ZZ,R.PCTF		;SET FLAG FOR RESOURCE SETTINGS

PCTLT1:	LSH	E,1			;GO STORE IT
	JRST	@LMTSGL+1(E)

DEFSET:	SKIPGE	CPUCHR			;SET ANY CHARACTERS NOT YET SET
	HRLM	B,CPUCHR
	SKIPGE	RUNCHR
	HRLM	B,RUNCHR
	SKIPGE	LINCHR
	HRLM	B,LINCHR
	JRST	RDCTL			;GET ANOTHER LINE

CPUSET:	HRLM	B,CPUCHR		;SET CPU OVERRUN CHARACTER
	JRST	RDCTL			;GET ANOTHER LINE

RUNSET:	HRLM	B,RUNCHR		;SET ELAPSED TIME CHARACTER
	JRST	RDCTL			;GET ANOTHER LINE

LINSET:	HRLM	B,LINCHR		;SET LOG OVERRUN CHARACTER
	JRST	RDCTL			;GET ANOTHER LINE

PCTERR:	HRROI	A,STRBUF		;SOMETHING WRONG - OUTPUT ERROR MSG
	HRROI	B,[ASCIZ / *** INVALID RESOURCE LIMIT SIGNAL - IGNORED:  /]
	SETZ	C,
	SOUT
	MOVE	C,[POINT 7,CTLLIN+2]	;PTR TO INPUT LINE
	MOVE	D,CTLLIN+1		;NUMBER OF CHARACTERS
PCTER0:	ILDB	B,C			;TRANSFER ONE
	IDPB	B,A			;TO ERROR STRING
	SOJG	D,PCTER0		;DO THEM ALL
	SETZ	B,			;MAKE RESULT ASCIZ
	IDPB	B,A

	ERR1	[0,,STRBUF]		;SEND ERROR MESSAGE TO LOG FILE
	JRST	RDCTL			;GET ANOTHER INPUT LINE


EXSEMI:	TRO	ZZ,R.SEMI		;SAY IT IS A COMMENT
;	JRST	RDTR			;GO TRANSILATE ^'S, STARTING WITH NEXT
	JRST	RDDUN			;CHARACTER.  WOULD GO TO RDDUN IF WE
					;DON'T WANT TO TRANSILATE COMMENT LINES

EXDOLR:	MOVE	D,A			;SAVE LOCATION OF $
	ILDB	B,D			;GET NEXT CHARACTER
	PUSHJ	P,SKALPH		;SKIP IF ALPHA CHAR IN B
	JRST	.+2			;NOT ALPHA
	JRST	EXSEMI			;TREAT THIS LINE AS A COMMENT
	CAIN	B,"$"			;IS NEXT CHAR ANOTHER $ ?
	JRST	EXSTAR			;YES, DELETE FIRST CHAR, THEN
					;CONTINUE WITH THIS AT USER LEVEL
	CAIE	B,12			;IS CHAR AFTER $ A LF?
	CAIN	B,13			;IS CHAR AFTER $ A VT?
	JRST	EXBLNK			;YES--GO SET R.BLNK
	CAIN	B,14			;IS CHAR AFTER $ A FF?
	JRST	EXBLNK			;YES--GO SET R.BLNK

;HERE WHEN WE HAVE A DATA LINE TO LEAVE AS IT IS.
EXDATA:	TRO	ZZ,R.USER		;SAY IT IS USER LEVEL
	JRST	RDTR2			;GO TRANSILATE--INCLUDE THIS CHAR IN B

EXBLNK:	TRO	ZZ,R.BLNK		;SAY BLANK LINE
	JRST	RDDUN			;JUST RETURN--THIS IS REALLY SIMPLE

EXPT:	MOVE	D,A			;GET POINTER TO CURRENT CHARACTER
	ILDB	B,D			;GET NEXT CHARACTER
	CAIL	B,"0"			;IS THE NEXT CHAR A DIGIT
	CAILE	B,"9"
	JRST	EXAT			;NO - TREAT AS "@"
	JRST	EXDATA			;YES - TREAT IT AS USER DATA
;;;	PUSHJ	P,SKALPH		;SKIP IF ALPHA CHAR
;;;	JRST	EXDATA			;IF NOT, TREAT AS DATA AS IS
					;IF SO, FALL THROUGH TO EXAT
					;WHICH WILL STRIP THE FIRST CHAR
					;AND MAKE US MONITOR MODE

EXAT:	TRO	ZZ,R.MONC		;SAY A MONITOR (EXEC) LEVEL COMMAND
	JRST	EXDELC			;GO DELETE THE FIRST CHARACTER

EXSTAR:	TRO	ZZ,R.USER		;USER COMMAND
	JRST	EXDELC			;GO DELETE FIRST CHARACTER

EXEQ:	TRO	ZZ,R.USER!R.SEOL	;USER DATA, MUST SUPPRESS END OF LINE

EXDELC:	SETZ	D,			;COMMON ROUTINE TO NULL OUT THE
	DPB	D,A			;FIRST CHARACTER TO DESTROY IT
;TRANSLATE THE ^'S INTO THE APPROPRIATE CODES
RDTR:	SOJLE	C,RDTREX		;ARE WE DONE?
	ILDB	B,A			;NO--GET ANOTHER CHAR
RDTR2:	CAIE	B,"^"			;IS THIS CHAR AN ^ ?
	JRST	RDTR			;CONTINUE IF NOT
	MOVE	D,A			;SAVE WHERE IT WAS.
RDTR3:	SOJLE	C,RDTREX		;ARE WE DONE NOW?
	ILDB	B,A			;IF NOT, CONTINUE BY GETTING NEXT CHAR
	CAIN	B,"^"			;ANOTHER ^ ?
	JRST	RDTRUP			;YES.
;	PUSHJ	P,SKALPH		;CHECK IF IT IS ALPHA
	TRNN	B,100			;TEST IF ALPHA OR SUCH
	JRST	RDTR			;NO, SO LEAVE IT AS IS
	TRZ	B,140			;FORCE IT TO A CONTROL CHARACTER
	DPB	B,A			;STORE IT BACK WHERE WE GOT IT
	SETZ	B,			;AND DESTROY THE ^ THAT PRECEEDED IT
	DPB	B,D			;BY DUMPING A NULL ON TOP OF IT
	JRST	RDTR			;CONTINUE TO TRANSILATE

RDTRUP:	SETZ	B,			;DESTROY THE FIRST ^ BY DROPPING
	DPB	B,D			;A NULL ON TOP OF IT
;	JRST	RDTR3			;GO BACK IF ^^^^ MEANS ^^^ (DEC'S WAY)
	JRST	RDTR			;GO BACK IF ^^^^ MEANS ^^ (FORTRAN WAY)

RDTREX:	TRNN	ZZ,R.SEOL		;DO WE WANT TO SUPPRESS EOL STUFF?
	JRST	RDDUN			;NO--GO TO DONE ROUTINE
	SOS	CTLLIN+1		;DELETE THE TERMINATOR CHARACTER
	MOVE	A,[POINT 7,CTLLIN+2]	;POINT TO LINE
	MOVE	C,CTLLIN+1		;GET # CHARS TO DO
RDSCL:	ILDB	B,A			;GET CHARACTER
	JUMPE	B,RDSCLE		;IGNORE NULLS FOUND IN LINE
	CAIN	B," "			;IS IT BLANK?
	JRST	.+2			;SKIP IF EITHER
	MOVN	D,C			;GET COUNT HERE
RDSCLE:	SOJG	C,RDSCL			;COUNT CHARS AND LOOP
	AOJ	D,			;FUDGE SO THE ADDM GIVES RIGHT RESULT
	ADDM	D,CTLLIN+1		;COMPUTE NEW LENGTH FOR LINE

RDDUN:	POPJ	P,			;RETURN TO CALLER
;ROUTINE TO UPDATE RESOURCE CONTROL SETTINGS
SETPCT:	PUSH	P,A			;SAVE AC
	TRNE	ZZ,R.MONC		;IS THE NEXT INPUT AN EXEC COMMAND?
	JRST	SETPC1			;YES, GO DO IT
SETPC0:	SKIPL	A,CPUCHR		;NO NEW EXEC COMMAND - UPDATE CTLS
	HLRZ	A,A			;NEW CHAR HERE - STORE IT
	HRRZM	A,CPUCHR
	SKIPL	A,RUNCHR
	HLRZ	A,A			;NEW CHAR HERE - STORE IT
	HRRZM	A,RUNCHR
	SKIPL	A,LINCHR
	HLRZ	A,A			;NEW CHAR HERE - STORE IT
	HRRZM	A,LINCHR
	JRST	SETPC2

SETPC1:	SKIPE	CEXCSW			;HAVE WE BEEN IN EXEC?
	JRST	SETPC0			;YES, ONLY DO UPDATE
	SKIPGE	A,CPUCHR		;NO, UPDATE EVERYTHING.  CLEAR IT IF
	SETZ	A,			;NO NEW SPECIFICATION
	HLRZM	A,CPUCHR
	SKIPGE	A,RUNCHR
	SETZ	A,			;NO NEW SPECIFICATION
	HLRZM	A,RUNCHR
	SKIPGE	A,LINCHR
	SETZ	A,			;NO NEW SPECIFICATION
	HLRZM	A,LINCHR

SETPC2:	POP	P,A			;RESTORE AC

	POPJ	P,			;RETURN




;SKIP IF END OF LINE CHARACTER IN B
SKEOL:	CAIE	B,15			;CR
	CAIN	B,12			;LF
	JRST	SKEOLS			;YES-GOT AN EOL

	CAIE	B,13			;VT
	CAIN	B,14			;FF
	JRST	SKEOLS			;YES-GOT SOME EOL

	CAIN	B,37			;EOL
SKEOLS:	AOS	(P)			;SET SKIP
	POPJ	P,			;RETURN

;SKIP IF AN ALPHA CHAR IN B
SKALPH:	CAIGE	B,"A"			;COULD IT BE UPPER CASE?
	POPJ	P,			;FAIL, CODE IS TOO LOW
	CAIG	B,"Z"			;IS IT IN RANGE FOR UPPER CASE?
	JRST	SSALPH			;YES-SUCCEED
	CAIGE	B,"A"+40		;IS IT LOWER CASE?
	POPJ	P,			;NO-TOO LOW TO BE LC.
	CAIG	B,"Z"+40		;IS IT IN LC RANGE?
SSALPH:	AOS	(P)			;SUCCESS-SET SKIP
	POPJ	P,			;RETURN




;ROUTINE TO COMPARE TWO ASCIZ STRINGS.
;ON ENTRY	A = STRING PTR FOR 1ST
;		B = STRING PTR FOR 2ND
;
;RETURNS	+1 IF THERE IS A NON-MATCHING CHARACTER
;		+2 IF THEY MATCH, BUT NOT THE SAME LENGTH
;		+3 PERFECT MATCH
;
;UPDATED PTRS IN A AND B

STRCMP:	PUSH	P,C			;SAVE WORKING AC'S
	PUSH	P,D

STRLOP:	ILDB	C,A			;GET NEXT CHAR OF 1ST
	ILDB	D,B			;GET NEXT CHAR OF 2ND
	CAME	C,D			;ARE THEY EQUAL
	JRST	STREND			;NO - CHECK IF ONE ENDED
	SKIPE	C			;WAS THAT THE END
	JRST	STRLOP			;NO GET THE NEXT ONE

	JRST	STRRT3			;WE HAVE A PERFECT MATCH, RETURN +3

STREND:	SKIPE	C			;IS ONE OF THEM AT AN END?
	SKIPN	D			;NOT FIRST, TRY SECOND
	JRST	STRRT2			;YES, RETURN +2
	JRST	STRRT1			;NO, RETURN +1

STRRT3:	AOS	-2(P)			;RETURN +3
STRRT2:	AOS	-2(P)			;RETURN +2
STRRT1:	POP	P,D			;RESTORE AC'S
	POP	P,C

	POPJ	P,			;RETURN



;LUUO ROUTINES
LUUOI:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E
	MOVE	A,40			;GET TRAP CAUSE
	ROT	A,^D9			;GET IT'S OPCODE
	ANDI	A,37			;THESE BITS ARE ALL THAT CAN COUNT
	JRST	@.(A)			;TRANSFER TO ROUTINE
	EXP	ERRLOG			;TRANSFER VECTOR TO LUUO STUFF

ERRLOG:	MOVE	A,@40			;GET WORD WITH ADDRESSES
	HRLI	A,440700		;MAKE BYTE POINTER
	MOVE	B,[POINT 7,MSGLIN+2]	;DESTINATION STRING
	SETZM	MSGLIN+1		;INIT COUNT
	ILDB	C,A			;GET CHAR
	JUMPE	C,.+4			;OUT IF DONE
	IDPB	C,B			;STORE CHAR
	AOS	MSGLIN+1		;COUNT CHAR
	JRST	.-4			;GO AGAIN
	MOVE	C,[SIXBIT /BAERR/]	;ERROR
	MOVEI	D,MSGLIN		;POINT TO LINE
	PUSHJ	P,SNDLOG		;WRITE IT ON LOG FILE

	HLRZ	A,@40			;GET RETURN ADDR
	JUMPE	A,LUUORE		;GO RETURN IF NONE SPECIAL
	HRRM	A,-5(P)			;RESET REUTURN ADDR IF ONE GIVEN

LUUORE:	POP	P,E			;RESTORE THE REGISTERS
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,			;RETURN
	IFN	GDDT,<
;	SET UP^D EVOCATION OF DDT
SETDDT:	MOVEI	A,400000	;FORK HANDLE
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	MOVE	A,[XWD 4,0]	;;^D
	ATI
	MOVEI	A,400000
	MOVE	B,[XWD 400000,0]	;ACTIVATE CHANNEL 0
	AIC
	OKINT
	IIC
	POPJ	P,
STDDT:	HRROI	A,[ASCIZ /GOING INTO DDT - TYPE RESM$G TO RESUME
/]
	PSOUT
	JRST	DDT##
RESM:	DEBRK
	>
	IFN	SRINOT,<
;	NOTIFY USER
;	AC2 = MESSAGE TO BE SENT TO USER
;
NOTIFY:	PUSH	P,D
	PUSH	P,C		;SAVE MESSAGE PTRS: B = JOBNOT AND
	PUSH	P,B		;C = STRNOT OR FINNOT

	HLLZ	D,JOBDIR	;AOBJN POINTER FOR FETCHING JOBDIR ENTRIES
NOTLOP:	MOVE	A,JOBDIR	;GET JOBDIR TABLE NUMBER
	HRL	A,D		;TACK IN JOB INDEX
	GETAB			;GET DIRECTORY INFO FOR THIS JOB
	BUG	(<NOTIFY: GETAB ERROR ON JOBDIR>)
	HRRZ	A,A		;ISOLATE LOGIN DIRECTORY NUMBER
	CAME	A,QENT+USRDIR	;IS THIS JOB OURS ?
	JRST	NOTND1		;NO, EXAMINE NEXT

	MOVE	A,JOBTTY	;YES, FIND TTY CONTROLLING JOB
	HRL	A,D		;TACK IN JOB INDEX
	GETAB
	BUG	(<NOTIFY: GETAB ERROR ON JOBTTY>)
	HLRE	A,A		;ISOLATE TTY NUMBER
	JUMPLE	A,NOTND1	;IGNORE IF DETACHED OR TTY0
	TRO	A,1B18		;MAKE INTO TTY DESIGNATOR
	CAME	A,PTY		;DON'T BOTHER NOTIFYING BATCH JOB PTY
	PUSHJ	P,PRINT		;PRINT NOTIFY MESSAGE
NOTND1:	AOBJN	D,NOTLOP	;LOOK AT ALL ACTIVE JOBS

	POP	P,B		;RESTORE AC'S
	POP	P,C
	POP	P,D

	POPJ	P,		;RETURN
>
;MESSAGE PRINTOUT FOR NOTIFY AND DAYFILE
PRINT:	MOVE	B,-1(P)		;RETRIEVE STRING POINTER
	SETZ	C,
	SOUT			;OUTPUT MESSAGE
;OUTPUT JOB NUMBER
	MOVE	B,QENT+BJOBNO	;GET JOB NUMBER
	MOVEI	C,^D10		;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ /, /]
	SETZ	C,
	SOUT

	SKIPG	CTLJFN			;IF CTLJFN 0, OUTPUT DIRECTORY ONLY
	JRST	PRINT0

	HRRZ	B,CTLJFN		;OUTPUT CONTROL FILE NAME
	MOVE	C,[XWD 011110,000001]
	JFNS				;OUTPUT JOB NAME
	JRST	PRINT1

PRINT0:	MOVEI	B,"<"			;OUTPUT DIRECTORY NAME
	BOUT
	HRRZ	B,QENT+USRDIR
	DIRST
	JFCL				;ERROR - IGNORE IT
	HRROI	B,[ASCIZ />,/]
	SETZ	C,
	SOUT
	JRST	PRINT1

PRINT1:	MOVE	B,-2(P)
	SETZ	C,
	SOUT			;OUTPUT MESSAGE END
	HRROI	B,-1
	MOVSI	C,245201
	ODTIM			;TIME OF MESSAGE
	MOVEI	B,"]"
	BOUT
	MOVEI	B,37		;AND EOL
	BOUT
	POPJ	P,

;ROUTINE TO MAKE DAYFILE, RECORD OF ENTRIES STARTED AND COMPLETED.
;
;
DAY:	AOSN	DAYLCK			;ANYONE ELSE HERE - AVOID FILE CONFLICT
	JRST	DAY0			;NO - GO AHEAD
	MOVEI	A,^D10000		;WAIT 10 SEC
	DISMS
	JRST	DAY			;TRY AGAIN

DAY0:	PUSH	P,D			;SAVE WORKING AC'S
	PUSH	P,C
	PUSH	P,B

	MOVE	A,RELFRK		;SAY WHO WE ARE
	MOVEM	A,WHODAY

	MOVE	A,[1B7!1B17!]		;SHORT, NO ACCESS BY OTHER FORKS
	HRROI	B,DAYNAM
	GTJFN
	BUG	(<DAY: GTJFN FAILED FOR DAY FILE>,DAYEND)
	MOVEM	A,DAYJFN		;OPEN DAY FILE
	MOVE	B,[44B5!1B19!1B20]	;36 BIT, READ, WRITE
	QOPENF
	BUG	(<DAY: ERROR OPENING DAY FILE>,DAYERR)
	BUG	(<DAY: TIME OUT OPENING DAY FILE>,DAYERR)

	MOVE 	B,[XWD 1,12]		;FIND FILE LENGTH
	MOVEI	C,C			;PUT IN C
	GTFDB

	MOVE	A,[XWD DAYBUF,DAYBUF+1]	;NULL FIRST 100 CHARACTERS (20 WORDS)
	MOVE	B,NULL
	MOVEM	B,DAYBUF

	BLT	A,DAYBUF+^D19
	MOVE	A,DAYJFN
	MOVE 	B,[POINT 36,DAYBUF+^D20]
	MOVN	C,C
	SKIPE	C		;SKIP THE SIN IF NOTHING TO READ IN
	SIN			;MOVE FILE INTO BUFFER
	SETZ	B,
	SFPTR			;SET POINTER TO BEGINNING OF FILE
	BUG	(<DAY: SFPTR FAILED >,DAYCLS)

	HRROI	A,DAYBUF		;POINTER TO DAYBUF
	PUSHJ	P,PRINT

	MOVE	A,DAYJFN
	MOVE	B,[POINT 36,DAYBUF]	;36 BIT OUTPUT
	MOVNI	C,DAYSIZ
	SOUT				;OUTPUT BUFFER BACK TO FILE

DAYCLS:	MOVE	A,DAYJFN
	CLOSF
	BUG	(<DAYCLS: ERROR CLOSING DAYFILE>,DAYERR)
	SETO	A,
	HRRI	B,DAYBUF/1000
	HRLI	B,400000
	SETZ	C,
	MOVE	D,[IOWD <<DAYSIZ+777>/1000>,1]
DAYRLS:	PMAP				;RELEASE PAGE 1 OF BUFFER
	AOS	B
	AOBJN	D,DAYRLS
DAYEND:	POP	P,B			;RESTORE AC'S
	POP	P,C
	POP	P,D

	SETOM	WHODAY			;RELEASE ROUTINE
	SETOM	DAYLCK

	POPJ	P,			;RETURN

DAYERR:	MOVE	A,DAYJFN		;RELEASE DAY JFN
	RLJFN
	BUG	(<DAYERR: ERROR RELEASING DAYFILE JFN>,DAYEND)

;	SRI MESSAGE SENDING CODE
;	SEND MESSAGE TO SUBMITTER
;	AC2= STRING POINTER TO MESSAGE (LESS THAN EQUAL 39 CHARACTERS)
SEND:
	AOSN	SNDLCK			;CHECK IF WE CAN SEND A MESSAGE
	JRST	SEND0			;YES
	MOVEI	A,^D30000		;TRY AGAIN IN 30 SECS.
	DISMS
	JRST	SEND
SEND0:
	MOVEM	B,MSGPTR		;SAVE FOR MESSAGE PRINT OUT
	MOVEM	C,MSGPT1
	MOVEI	C,10
SEND1:	SKIPN	FORK		;FORK OCCUPIED
	JRST	SEND2		;NO
	MOVEI	A,^D1000	;YES, WAIT AWHILE AND TRY AGAIN
	DISMS
	SOJGE	C,SEND1		;TRIED 10 TIMES
	POPJ	P,0		;FORGET IT
SEND2:	MOVE	A,[XWD 340000,0]
	MOVEM	A,SNDMSF	;SEND MESSAGE FLAGS
	HRROI	A,SUBJCT	;SUBJECT OF MESSAGE
	SETZ	C,
	SOUT			;PUT MESSAGE IN INFERIOR FORKS ACS
	MOVE	A,[XWD 440700,MSG]
	MOVEI	B,"<"
	IDPB	B,A
	MOVE	B,QENT+USRDIR
	DIRST			;DIRECTORY NUMBER TO STRING
	JRST	[HRROI	B,[ASCIZ /BATCH/]	;NO ADRESSEE, USE BATCH
		 SETZ	C,
		 SOUT
		 JRST	.+1]
	MOVEI	B,">"
	IDPB	B,A
	HRROI	B,MSGTXT
	SETZ	C,
	SOUT
	MOVSI	A,(1B8+1B17)		;OLD, IGN DEL, SHORT
SNDAGN:	HRROI	B,MSG
	GTJFN
	JRST	[CAIL	A,GJFX18	;NO SUCH NAME
		 CAILE	A,GJFX20	;NO SUCH EXTENSION
		 JRST	ABMSG
		 MOVSI	A,(1B1+1B17)	;TRY TO CREATE MESSAGE.TXT
		 JRST	SNDAGN]		;IF IT DIDN'T EXIST
	HRRZM	A,MSGJFN	;MESSAGE.TXT JFN

	HRLI	A,1			;MAKE SURE FILE IS NOT DELETED
	MOVSI	B,(1B3)
	SETZ	C,
	CHFDB

	MOVSI	A,(1B0+1B5+1B17)	;OUTPUT, TEMPORARY, SHORT
	HRROI	B,TEMP
	GTJFN
	JRST	[MOVE	A,BATDN		;TRY EXPUNGING
		 DELDF
		 MOVSI	A,(1B0+1B5+1B17)	;GO AGAIN
		 HRROI	B,TEMP
		 GTJFN			;IF NO GO THIS TIME, CRASH
		 JRST	ABMSG
		 JRST	.+1]		;WHEW, MADE IT

	HRRZM	A,TMPJFN
	MOVE	B,[7B5!1B20]		;WRITE, 7 BIT
	QOPENF
	JFCL
	JRST	ABMSG			;CAN'T OPEN IT - ABORT

	MOVE	B,MSGPTR		;GET POINTER TO MESSAGE
	SETZ	C,
	SOUT			;OUTPUT TO FILE
	SKIPN	CTLJFN
	JRST	SEND5
	MOVE	B,QENT+BJOBNO
	MOVEI	C,^D10
	NOUT
	JFCL
	MOVEI	B,","
	BOUT
	MOVE	B,CTLJFN		;CTL FILE NAME
	MOVE	C,[XWD 011110,000001]
	JFNS			;OUTPUT JOB NAME

SEND5:
	MOVE	B,MSGPT1
	SETZ	C,
	SOUT
	HRROI	B,-1		;CURRENT TIME AND DATE
	MOVSI	C,245201
	ODTIM
	MOVEI	B,37			;CR,LF
	BOUT
	SETZ	B,			;MAKE IT ASCIZ
	BOUT
	MOVE	A,TMPJFN
	TLO	A,(1B0)		;DON'T RELEASE JFN
	CLOSF
	JRST	ABMSG			;BAD NEWS - ABORT IT

	MOVEI	B,INFACS	;INFERIOR FORK ACS
CFAGN:	HRLZI	A,240000	;SAME CAPABILITIES
	CFORK
	JRST	[MOVEI A,^D60000  ;NO FORKS, TRY AGAIN IN 1 MINUTE
		 DISMS
		 JRST CFAGN]
	MOVEM	A,FORK		;FORK HANDLE
	MOVSI	A,(1B2+1B17)		;GET OLD SNDMSG.SAV
	HRROI	B,SNDMSG
	GTJFN
	JRST	[MOVE	A,FORK		;KILL LOWER FORK
		 KFORK
		 JRST	ABMSG]		;MUST NOT BE A SNDMSG.SAV
	HRRZM	A,SNDJFN	;SNDMSG JFN
	HRL	A,FORK
	GET			;GET SNDMSG

	MOVE	A,CHNTAB+^D19		;SAVE OLD CHAN 19 DISPATCH
	MOVEM	A,OCHN19
	MOVEI	A,400000		;RECORD IF CHAN 19 ACTIVATED
	RCM
	SETZM	ACTV19
	TRNE	A,1B19
	SETOM	ACTV19

	MOVEI	A,400000		;RESET CHAN 19 TO TRAP SNDMSG STOP
	MOVE	B,[XWD 3,HMSGFK]
	MOVEM	B,CHNTAB+^D19	;SET UP CHANNEL TABLE
	HRRZI	B,1B19
	AIC
	MOVE	A,FORK
	MOVEI	B,4		;FOURTH ENTRY IN ENTRY VECTOR
	SFRKV			;START FORK

	MOVE	A,RELFRK		;RECORD WHO IS DOING THIS
	MOVEM	A,WHOSND

SNDRTN:	POPJ	P,

ABMSG:	SETOM	SNDLCK		;CLEAR MESSAGE LOCK
	SETZM	FORK		;CLEAR FORK ID
	POPJ	P,		;RETURN

HMSGFK:	PUSH	P,A
	PUSH	P,B
	MOVE	A,FORK		;RECORD SNDMSG FORK CONDITIONS
	RFSTS
	MOVEM	A,FKSTS
	MOVEM	B,FKPC
	MOVE	A,FORK
	MOVEI	B,FKACS
	RFACS

	MOVE	A,OCHN19	;RESTORE CHAN 19 DISPATCH
	MOVEM	A,CHNTAB+^D19

	MOVEI	A,400000
	MOVEI	B,1B19
	SKIPL	ACTV19		;IF CHAN 19 WAS NOT ACTIVATED,
	DIC			;DISABLE FORK TERMINATION CHANNEL

	MOVE	A,MSGJFN	;MESSAGE.TXT JFN
	RLJFN
	JFCL
	MOVE	A,FORK		;GET FORK HANDLE
	KFORK			;KILL IT TO GET RID OF SNDMSG
	SETZM	FORK		;CLEAR FORK ACTIVE FLAG
	MOVE	A,TMPJFN
	RLJFN
	JFCL
	SETOM	SNDLCK		;CLEAR MESSAGE LOCK
	SETOM	WHOSND		;CLEAR SENDER
	POP	P,B
	POP	P,A
	DEBRK

;PSEUDO INTERRUPT ROUTINES
PSIEOF:	PUSH 	P,A			;SAVE A
	CAME	A,CTLJFN		;WAS IT ON CTL FILE?
	ERROR	<PSIEOF: EOF ON FILE OTHER THAN CTL FILE>,EOFNCT
	MOVEI	A,KILLIT		;ADDRESS TO START TERMINATION PROCESS
	MOVEM	A,LEV2PC		;SET UP DEBRK PC VALUE
	CAME	D,CTLLIN		;WAS THERE ANY INPUT?
	ERROR	<PSIEOF: EOF ON CTL FILE BUT CHARACTERS IN BUFFER>,EOFNCT
	POP	P,A
	DEBRK				;CONTINUE
EOFNCT:	MOVEI	A,ABEND			;GO END JOB
	MOVEM	A,LEV2PC		;PUT IN RETURN PC
	POP	P,A
	DEBRK				;RETURN TO TOP LEVEL

;FILE DATA ERROR
PSIERR:	CAME	A,CTLJFN		;WAS IT CTL FILE
	ERROR	<DATA ERROR ON FILE OTHER THAN CTL FILE>,.+2
	ERROR	<DATA ERROR ON CTL FILE>
	MOVEI	A,ABEND
	MOVEM	A,LEV2PC
	DEBRK				;RETURN TO PROG


;ROUTINE TO DUMP THE IMAGE OF A FORK AND ENTER A NOTE IN SOME LOG FILE
;ON ENTRY:	AC 1  = JFN FOR LOG FILE
;		   2  = DATE STAMP FOR DUMP FILE (INTERNAL FORMAT)
;		   3  = RELATIVE FORK HANDLE FOR DUMP (THIS MAY NOT BE
;			THE ACTUAL FORK NUMBER IN THE HIERARCHY IF A
;			LOWER FORK IS DUMPING ITSELF)
;THE ROUTINE USES BUGSTR TO BUILD THE OUTPUT FILE NAME
;  BATCON-DUMP.XX-MO/DAY/YR-HRMIN
;WHERE XX IS THE OCTAL FORK NUMBER RELATIVE TO THE MAIN PROGRAM (FORK 0)

FRKDMP:	PUSH	P,A			;SAVE LOG JFN
	PUSH	P,B			;SAVE DATE/TIME STAMP
	PUSH	P,C			;SAVE FORK HANDLE

	HRROI	A,BUGSTR		;CONSTRUCT NAME IN BUGSTR
	MOVE	B,CSHBAT
	SETZ	C,
	SOUT
	HRRZ	B,0(P)			;RECOVER FORK HANDLE
	SKIPL	MYNAME			;USE IT IF WE ARE TOP FORK
	HRRZ	B,RELFRK		;ELSE, USE REAL ONE STORED FOR US
	ANDI	B,777			;ONLY THE INDEX PART
	PUSH	P,B			;SAVE THIS INDEX
	MOVEI	C,10			;OCTAL OUTPUT
	NOUT
	JFCL
	MOVEI	B,"-"
	BOUT
	MOVE	B,-2(P)			;RECOVER DATE/TIME STAMP
	MOVSI	C,045401
	ODTIM				;TACK ON DATE PART
	MOVEI	B,"-"
	BOUT
	MOVE	B,-2(P)			;GET DATE/TIME AGAIN
	MOVSI	C,400241
	ODTIM				;DO TIME PART NOW

	MOVE	A,-3(P)			;GET LOG FILE JFN AND OUTPUT MSG
	HRROI	B,[ASCIZ /
DUMPING BATCON FORK /]
	SETZ	C,
	SOUT
	POP	P,B			;RECOVER REAL FORK INDEX
	MOVEI	C,10			;OCTAL OUTPUT
	NOUT
	JFCL
	HRROI	B,[ASCIZ / ON FILE:  /]
	SETZ	C,
	SOUT

	MOVSI	A,402001		;TRY TO GTJFN THE DUMP FILE
	HRROI	B,BUGSTR
	GTJFN
	JRST	[MOVE	A,-2(P)		;FAILURE MSG TO LOG FILE
		 HRROI	B,[ASCIZ /XXX
   GTJFN ERROR ON /]
		 SETZ	C,
		 SOUT
		 HRROI	B,BUGSTR
		 SOUT
		 HRROI	B,[ASCIZ /
   IMAGE NOT DUMPED
   TENEX ERROR:  /]
		 SOUT
		 HRLOI	B,400000
		 ERSTR
		 JFCL
		 JFCL
		 SETO	A,		;DUMMY JFN = -1
		 PUSH	P,A
		 JRST	ASTLIN]

	PUSH	P,A			;SUCCESSFUL - SAVE REAL JFN
	MOVE	B,A			;SET UP FOR JFNS
	MOVE	A,-3(P)
	MOVE	C,[XWD 011110,1]
	JFNS

ASTLIN:	HRROI	B,[ASCIZ /
**********
/]
	SETZ	C,
	SOUT

	POP	P,A			;RECOVER DUMP FILE JFN
	JUMPL	A,NOSAVE		;IF BAD, DON'T TRY TO SAVE
	HRL	A,0(P)			;TACK FORK HANDLE ON LEFT HALF
	MOVE	B,[777760,20]		;SAVE WHOLE MESS
	SAVE

NOSAVE:	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN


MSGTXT:	ASCIZ	/MESSAGE.TXT;1/
SNDMSG:	ASCIZ	/<SUBSYS>SNDMSG.SAV/
SNDJFN:	BLOCK	1
JOBMSG:	ASCIZ	/ BATCH JOB /
STRMSG:	ASCIZ	/ STARTED ON 
   /
FINMSG:	ASCIZ	/ FINISHED ON 
   /
TEMP:	ASCIZ	/BATCH.MSG/
JOBNOT:	ASCIZ	/
  [BATCH JOB /
STRNOT:	ASCIZ	/ STARTED ON /
FINNOT:	ASCIZ	/ FINISHED ON /
JOBDAY:	ASCIZ	/
  [BATCH JOB /
STRDAY:	ASCIZ	/ STARTED ON /
FINDAY:	ASCIZ	/ FINISHED ON /
JOBCTL:	ASCIZ	/
--[CONTROL TASK /
NULL:	ASCIZ	/     /
IFE	DBGFIL,<
DAYNAM:	ASCIZ	/<BATCH>DAYFILE.ENTRIES;P777740;1/
	>
IFN	DBGFIL,<
DAYNAM:	ASCIZ	/<BATCH>TDAYFILE.ENTRIES;P777740;1/
	>
FST:	POINT	7,[ASCIZ /RUNNING /]		;0
	POINT	7,[ASCIZ /IO WAIT /]		;1
	POINT	7,[ASCIZ /VOL TERM /]		;2
	POINT	7,[ASCIZ /INVL TERM /]		;3
	POINT	7,[ASCIZ /FORK WT /]		;4
	POINT	7,[ASCIZ /DISMISSED /]		;5
	POINT	7,[ASCIZ /AT BKPNT /]		;6


;FOLLOWING ARE THE VALID COMMANDS FOR SETTING RESOURCE LIMIT CONTROL SIGNALS
;WHEN THE RESOURCE IS 90% DEPLETED.
CQQ==0
LMTSGL:	TE	(DEFSET,<DEFAULT>)
	TE	(CPUSET,<CPUTIME>)
	TE	(RUNSET,<RUNTIME>)
	TE	(LINSET,<LOGLINES>)
	0
NLMTSW==CQQ

	PURGE	TE,CQQ

	LIT				;LITERAL POOL

PATCH:	BLOCK	100			;PATCH AREA - COMMON PAGES

NINF==<<<.-INFFK>+777>/1000>

	SUBTTL	INFERIOR FORK PRIVATE PAGE
	LOC	20000
PRIV:					;LABEL FOR MAPPING
;	SEND MESSAGE STORAGE
MYNAME:	BLOCK	1			; -1 FOR SCHED LEVEL, 0 FOR INFR FORK
					;USED TO TELL WHO GOT BUG AND HOW TO
					;RESTART 
SBJBNM:	BLOCK	1			;NAME OF SUBSYS SUBJOB IS IN
SYMPTR:	BLOCK	1			;COPY OF SYMTAB WORD FOR CRASH COPY
JOBN:	BLOCK	1			;JOB NUMBER OF ACTIVE PROCESS
FORK:	BLOCK	1			;FORK HANDLE OF SNDMSG FORK (PRIVATE)
FRCTRM:	-1				;FORCE TERMINATION FLAG
CTLJFN:	BLOCK	1			;JFN FOR CTL FILE
CTLHLD:	BLOCK	1			;HOLD CTLJFN TEMPORARILY
LOGJFN:	BLOCK	1			;JFN FOR LOG FILE
PTY:	BLOCK	1			;PTY DESIGNATOR
MODEI:	BLOCK	1			;FLAGS FROM RDCTL TO DESC. INP.
RELFRK:	BLOCK	1			;RELATIVE FORK HANDLE
BUGRET:	BLOCK	1			;RETURN ADDRESS FOR BUGMSG
OCHN19:	BLOCK	1			;OLD CHAN 19 DISPATCH
ACTV19:	BLOCK	1			;FLAG FOR CHAN 19 ACTIVATED BEFORE

MAXETM:	BLOCK	1			;MAX ELAPSED TIME ALLOWED
RUNTIM:	BLOCK 	1			;TIME JOB ELAPSED TIME OVER(TODCLK FORMAT)
RUNTRG:	BLOCK	1			;90% OF ALLOWED RUN TIME
RUNCHR:	BLOCK	1			;CTL CHAR TO BE SENT WHEN AT RUNTRG
MAXCPU:	BLOCK	1			;MAX CPU TIME JOB CAN USE
CPUTRG:	BLOCK	1			;90% OF ALLOWED CPU TIME
CPUCHR:	BLOCK	1			;CTL CHAR TO BE SENT WHEN AT CPUTRG
MAXLOG:	BLOCK	1			;MAX LINES JOB CAN WRITE ON LOG FILE
LOGTRG:	BLOCK	1			;90% OF ALLOWED LOG LINES
LINCHR:	BLOCK	1			;CTL CHAR TO BE SENT WHEN AT LOGTRG
CEXCSW:	-1				;SWITCH SHOWING TRANSITION BETWEEN
					;EXEC AND USER PGM (-1 => IN EXEC)

NAPTIM:	BLOCK	1			;HOW LONG TO DISMS BETWEEN CHECKS
INFDSB:	BLOCK	1			;INFERIOR DESUBMIT FLAG

QENT:	BLOCK	QESIZE			;QUEUE ENTRY
DQENT:	BLOCK	QESIZE			;DESUBMIT REQUEST ENTRY
NUMENT:	BLOCK	1			;NUMBER OF ENTRIES IN QUEUE
CSHACS:	BLOCK	24			;AC SAVE BLOCK FOR CRASH DUMP+ A BIT
CSHPC:	BLOCK	1			;PC FOR THIS FORK AT CRASH OR STATUS
BUGSTR:	BLOCK	60			;AREA FOR BUILDING BUG MESSAGE
STRBUF:	BLOCK	60			;AREA FOR BUILDING MESSAGES
IPDL:	BLOCK	PDLL+1
LEVTAB:	EXP	LEV1PC,LEV2PC,LEV3PC	;PC STORAGE ADDRESSES FOR INTERRUPTS
CHNTAB:	
	IFN	GDDT,<
	3,,STDDT			;DDT FOR DEBUGGING (CHAN 0)
	>
	IFE	GDDT,<
	3,,UNEX				;UNEXPECTED INTERRUPT (CHAN 0)
	>
	3,,DESUBF			;DESUBMIT FORK (CHAN 1)
	3,,INFSTS			;INFERIOR FORK STATUS (CHAN 2)
	3,,SUICID			;INFERIOR FORK SUICIDE (CHAN 3)
	3,,SAVACS			;SAVE AC'S AND FREEZE (CHAN 4)
	REPEAT	^D5,<3,,UNEX>		;UNEXPECTED INTERRUPT (CHAN 5-9)
	2,,PSIEOF			;FILE COND 1, EOF (CHAN 10)
	2,,PSIERR			;FILE COND 2, DATA ERROR (CHAN 11)
	REPEAT	^D7,<3,,UNEX>		;UNEXPECTED INTERRUPT (CHAN 12-18)
	3,,HLTNFK			;HALTED FORK (CHAN 19)
	REPEAT	^D17,<3,,UNEX>		;UNEXPECTED INTERRUPT (CHAN 20-36)


;	STRING TO FORCE LOGOUT WHEN NO LOGO APPEARS IN CTL FILE
LOGSTR:	POINT 7,[ASCIZ /LOGOUT
/]
;LINE FOR MESSAGES FROM BATCH, COMMENTS COPIED OVER, ETC.
	POINT	7,MSGLIN+2		;POINTER TO STORE IN MSGLIN
MSGLIN:	LOGL*5				;MAX LENGTH MSG LINE
	BLOCK	LOGL+1			;ACTUAL LENGTH AND THE TEXT
;LINE FOR INPUT TO SUBJOB
	POINT	7,CTLLIN+2		;POINTER TO DATA IN LINE
CTLLIN:	CTLL*5				;MAX LENGTH INPUT LINE CTL FILE
	BLOCK	CTLL+1			;LENGTH OF ACTUAL DATA AND LINE

;LINE FOR OUTPUT FROM SUBJOB
	POINT	7,LOGLIN+2		;POINTER TO STORE IN LOGLIN
LOGLIN:	LOGL*5				;MAX LENGTH LOG LINE
	BLOCK	LOGL+1			;LENGTH ACTUALLY THERE, AND LINE
DAYJFN:	BLOCK 1
	LIT			;FORCE ALL LITERALS BEFORE NEW PAGE
	VAR
INFACS:			;INFERIOR FORK ACS
	BLOCK	1	;0
MSGJFN:	BLOCK	1	;1, MESSAGE.TXT JFN
SNDMSF:	BLOCK	1	;2, SEND MESSAGE FLAGS
TMPJFN:	BLOCK	4	;3-6
SUBJCT:	BLOCK	8	;7-16, SUBJECT OF MESSAGE
	BLOCK	1	;17
MSG:	BLOCK	10
MSGPTR:	BLOCK	1	;INPUT MESSAGE POINTER
MSGPT1:	BLOCK 1		;INPUT MESSAGE POINTER, PART 2
FKSTS: BLOCK 1
FKPC:	BLOCK 1
FKACS:	BLOCK	20
;PSEUDO-INTERRUPT SYSTEM STORAGE
LEV1PC:	0				;STORAGE FOR PC AT TIME OF INTERRUPT
LEV2PC:	0
LEV3PC:	0
NPRIV==<<<.-PRIV>+777>/1000>	;NUMBER OF INFERIOR FORK PRIVATE PAGES

;SPACE FOR THE COMMAND QUEUE
COMBUF==30*1000			;PAGE 30

; MOVE DAYBUFFER UP HIGHER THAN SYMBOL TABLE BUT DON'T ASSIGN A LABLE
; BECAUSE LOADER WILL TRY TO PUT THE SYMBOLS ABOVE IT
DAYBUF==60*1000			;FIRST WORD ADDRESS OF DAYFILE BUFFER
DAYSIZ==<^D10000/5>		;NUMBER OF WORDS ASSIGNED TO DAYFILE BUFFER
	END	START
