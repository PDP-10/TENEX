; Following are a set of accounting routines that emulate (are actually
; the precursors for) the TENEX 133/134 string accounting JSYS's
;	$VACCT	- Emulates the VACCT JSYS:  Verify account
;	$GDACC	- Emulates the GDACC JSYS:  Get default account

;THESE ROUTINES ARE ONLY FOR USE UNDER 131 TENEX
;
;$VACCT Called by PUSHJ P,$VACCT
;	AC 1	= User directory # (-1 means connected dir)
;	AC 2	= Account designator
;		    Numeric accts:  5B2+NUMBER
;		    String accts:   String pointer
;
;   RETURNS	+1	Error - No match
;				or RUNAC failed to run
;		+2	Account OK
;
; ***************************

$VACCT:	PUSH	P,1		;USER NUMBER
	PUSH	P,2		;ACCOUNT DESIGNATOR
	SETZM	UACBLK
	MOVE	1,[UACBLK,,UACBLK+1]
	BLT	UACBLK+17	;CLEAR AC ARG BLOCK
	MOVE	2,-1(P)		;GET USER NUMBER
	CAME	2,[-1]		;SELF?
	JRST $VACC1		;NO
	PUSH	P,3
	PUSH	P,4
	GJINF			;GET JOB INFO CONN DIR IN 2
	POP	P,4
	POP	P,3
$VACC1:	HRROI	1,UACBLK	;FIRST 8 AC'S CONTAIN DIRST
	DIRST
	JRST $VAFXT		;DO FAIL RETURN
	MOVE	1,0(P)		;GET ACCT DESG
	LDB	2,[POINT 3,1,2]	;STRIP NUMERIC INDICATOR
	CAIE	2,5		;IS IT NUMERIC?
	JRST $VASTR		;NO STRING
	MOVEM	1,UACBLK+10	;NUMERIC DESIG IN AC10
	MOVEI	1,UACBLK	;POINT TO ARG BLOCK
	MOVEI	2,1		;START AT NUMERIC ENTRY POINT
	PUSHJ	P,RUNUAC
	JRST 	$VAFXT		;FORK FAILED TO RUN
	JRST 	$VACC3		;FORK RAN, CHECK RESULT

$VASTR:	MOVE	2,[POINT 7,UACBLK+10] ;POINT TO AC10-17 FOR ACCT STRING
	TLC	1,-1		;DSP?
	TLCN	1,-1		;SKIP IF NOT DSP
	HRLI	1,440700	;CONVERT TO STRING POINTER
	PUSH	P,3
	PUSH	P,4
	MOVNI	4,^D39		;WE ONLY TAKE 39 CHARS
$VALUP:	ILDB	3,1
	IDPB	3,2
	CAIN	3,0		;SKIP IF NOT NULL BYTE
	JRST	$VALDN
	AOJL	4,$VALUP	;GET 39 CHARS MAX
	SETZ	3,		;FINISH AS ASCIZ
	IDPB	3,2
$VALDN:	POP	P,4
	POP	P,3
	MOVEI	1,UACBLK	;POINT TO AC BLOCK
	MOVEI	2,2		;ENTRY POINT FOR STRING
	PUSHJ	P,RUNUAC
	JRST	$VAFXT		;DIDN'T RUN - ERROR RETURN
$VACC3:	CAIN	1,0		;FIND A MATCH?
	AOS	-2(P)		;YES, SKIP RETURN
$VAFXT:	POP	P,2	
	POP	P,1
	POPJ	P,

;$GDACC Called by PUSHJ P,$GDACC
;	AC 1	=  Destination string pointer for account (numeric or
;			string)
;	AC 2	=  User directory number (-1 for connected dir)
;
;   RETURNS	+1	Error (No error code returned)
;		+2	Success, string returned with default account
;
; ***************************
;
$GDACC:	PUSH	P,1		;DSP FOR ACCT
	PUSH	P,2		;USER NUMBER
	SETZM	UACBLK
	MOVE	1,[UACBLK,,UACBLK+1]
	BLT	1,UACBLK+17	;CLEAR AC ARG BLOCK
	CAME	2,[-1]		;SELF?
	JRST $GDAC1		;NO
	PUSH	P,3
	PUSH	P,4
	GJINF			;GET CONN DIR NUM IN 2
	POP	P,4
	POP	P,3
$GDAC1:	HRROI	1,UACBLK	;POINT TO AC0-7	FOR DIRST
	DIRST
	JRST $GDFXT		;DO FAIL RETURN
	MOVEI	1,UACBLK	;POINT TO AC BLOCK
	SETZ	2,		;0 ENTRY POINT FOR DEFAULT
	PUSHJ	P,RUNUAC
	JRST	$GDFXT		;NON-SKIP IF FORK FAILED
	CAIE	1,0		;DID WE FIND DEFAULT?
	JRST 	$GDFXT		;NO, NON-SKIP
	PUSH	P,3
	PUSH	P,4
	MOVNI	3,^D39		;39 CHARS MAX
	HRRZ	2,UACBLK+2	;GET POINTER REL TO AC BLOCK
	ADD	2,[POINT 7,UACBLK] ;MAKE IT A USEFULL POINTER
	MOVE	4,-3(P)		;GET USERS POINTER
	TLC	4,-1		;DEFAULT POINTER?
	TLCN	4,-1
	HRLI	4,440700	;YES, MAKE IT A REAL POINTER
$GDACL:	ILDB	1,2
	IDPB	1,4
	CAIN	1,0		;SKIP IF NOT A NULL
	JRST	$GDACM
	AOJL	3,$GDACL
	SETZ	1,		;FINISH AS ASCIZ
	IDPB	1,4
$GDACM:	POP	P,4
	POP	P,3
	AOS	-2(P)		;DO SKIP RETURN
$GDFXT:	POP	P,2
	POP	P,1
	POPJ	P,


;RUNS UACHK PROGRAM DOES NON-SKIP RETURN ON PROGRAM FAILURE
;	1/ POINTER TO AC ARG BLOCK
;	2/ ENTRY VECTOR OFFSET
;	   0=DEFAULT, 1=NUMERIC CHECK, 2=STRING CHECK

RUNUAC:	PUSH	P,1		;ARG POINTER
	PUSH	P,2		;ENTRY VECTOR
	MOVSI	1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI	2,[ASCIZ /<SYSTEM>UACHK.SAV/]
	GTJFN
	JRST [	POP	P,2
		POP	P,1
		POPJ	P, ]	;DO FAIL RETURN IF CANT FIND FILE
	PUSH	P,1		;JFN
RUNUA1:	MOVSI	1,(1B1)		;SET CAP DONT START
	CFORK
	JRST [	MOVEI	1,^D1000
		DISMS		;TRY AGAIN IN 1 SEC
		JRST RUNUA1]
	PUSH	P,1		;FORK HANDLE
	MOVSI	1,0(1)		;MOVE HANDLE TO LH
	HRR	1,-1(P)		;AND PUT JFN IN RH
	GET
	MOVE	1,(P)
	MOVE	2,-3(P)		;GET POINTER TO ARG BLOCK
	SFACS			;LOAD ACS
	MOVE	2,-2(P)		;GET VECTOR OFFSET
	SFRKV			;START IT
	WFORK			;WAIT FOR IT
	FFORK			;FREEZE IT
	MOVE	2,-3(P)		;POINT TO ARG BLOCK
	RFACS			;COPY BACK THE ACS
	RFSTS			;GET FORK STATUS
	TLZ	1,(1B0)		;KILL THE FREEZE BIT
	CAME	1,[2,,0]
	TLOA	2,-1		;INVOL TERMINATE
	TLZ	2,-1		;CLEAN HALT
	POP	P,1		;GET FORK HANDLE
	KFORK			;GET RID OF IT
	POP	P,1		;GET THE JFN
	RLJFN			;RELEASE IT
	JFCL			;SHOULDNT HAPPEN!!??
	MOVE	1,-1(P)		;POINT TO BLOCK
	MOVE	1,1(1)		;WE WANT THE AC1
	CAIL	2,0		;INVOL TERMINATE?
	CAILE	1,0		;OR PROGRAM ERROR?
	JRST	$GDRTN		;YES, DO NON-SKIP RETURN
	AOS	-2(P)		;NO, DO SKIP RETURN
$GDRTN:	POP	P,2
	SUB	P,[1,,1]	;POP STACK AGAIN
	POPJ	P,

UACBLK:	BLOCK	20			;AC STORAGE
