;<BATCH>SUBCTL.MAC;20   1/16/77			EDIT BY RINDFLEISCH
;  Changed STATUS command to print info about LOGIN dir as default
;  Added stuff to STATUS to tell why job isn't running
;<BATCH>SUBMIT.MAC;19	12/3/76			EDIT BY RINDFLEISCH
;  Added MODIFY/CHANGE, LIST, specific STATUS, and RESET commands
;<BATCH>SUBMIT.MAC;18	10/9/76			EDIT BY RINDFLEISCH
; Added IMSSS stuff for line labelling options
; Fixed error return from GTJFN to allow ?
; Added code to use JOB-SEQUENCE.LOCK for job sequencing including lock
;  in SUBMIT shared page to allow only one SUBMIT user at a time.
;<BATCH>SUBMIT.MAC	4/2/76 			EDIT BY RINDFLEISCH
; Added BATCON control commands and conditional assembly for them
; Removed DIRECT and CLEAR from user access
; Added display support with SUMEX switch
; Added facility for subcommands
; Added facility for ? help at any time
;<BATCH>SUBMIT.MAC;102    15-AUG-75 11:38:17    EDIT BY MOUTON
;ADDED LENGTH AND TIME PARAMETERS
;<BATCH>SUBMIT.MAC;97     4-AUG-75 17:38:29    EDIT BY UNTULIS
;MOVED QLPEND LABEL,CORRECTED NNOT CODE AND DELETED REMNANT CODE
;<BATCH>SUBMIT.MAC;96     1-AUG-75 23:52:34    EDIT BY UNTULIS
;FIXED ILLEGAL VERSION PROBLEM FOR JOB AND DJOB
;<BATCH>SUBMIT.MAC;84    14-JUL-75 15:15:08    EDIT BY UNTULIS
;ADD LOAD AVERAGE THRESHOLD CODE
;ADD DEFAULT LOG AND SMART TIME CODE FROM LIEB@SUMEX
;<BATCH>SUBMIT.MAC;55     4-JUL-75 13:43:43    EDIT BY UNTULIS
;ADDED DESUBMIT COMMAND AND CODE
;ADDED CLEAR QUEUE AND EXIT COMMANDS
;<BATCH>SUBMIT.MAC;37    24-JUN-75 12:14:41    EDIT BY UNTULIS
;<BATCH>SUBMIT.MAC;36    17-JUN-75 10:49:13    EDIT BY UNTULIS
;<BATCH>SUBMIT.MAC;32    31-MAY-75 16:23:03    EDIT BY UNTULIS
; ADD JOBSTT SLOT IN QENTRY (JOB START TIME)
;<BATCH>SUBMIT.MAC;18     9-APR-75 11:21:06    EDIT BY UNTULIS
;ADDED CODE TO TOUCH LOG FILE TO DEFINE VERSION
;<BATCH>SUBMIT.MAC;5    10-FEB-75 14:03:51    EDIT BY LYNCH
;MAKE ACOUNT STRING CODE CONDITIONAL
;<BATCH>SUBMIT.MAC;3    10-FEB-75 10:07:12    EDIT BY UNTULIS
;EXPAND QENT ONE WORD FOR ACCOUNT STRINGS
;CHANGE .ACCOU FOR ACCOUNT STRINGS
;<LARSON>SUBMIT.MAC;64    31-DEC-74 14:16:12	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;63    31-DEC-74 13:51:36	EDIT BY LARSON
;REMOVED CHFDB TO LOWER ACCESS TO NEW JOB FILE BECAUSE
;CAN'T DO IT WITHOUT OWNERSHIP RIGHTS
;<LARSON>SUBMIT.MAC;62    31-DEC-74 13:10:41	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;61    31-DEC-74 13:02:17	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;60    31-DEC-74 12:29:01	EDIT BY LARSON
;<LARSON>XSUBMIT.MAC;2    31-DEC-74 12:10:31	EDIT BY LARSON
;PUT IN JFNS ON FAILING JOB ENTRY FILE NAME
;<LARSON>SUBMIT.MAC;59    31-DEC-74 11:08:06	EDIT BY LARSON
;PUT IN PROTECTION STUFF FOR INDIRECT SUBMIT JOB FILES.
;<LARSON>SUBMIT.MAC;58    30-DEC-74 13:59:17	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;57    30-DEC-74 09:42:32	EDIT BY LARSON
;PUT IN DIRECT SUB COMMAND AND INDIRECT SUBMIT DEFAULT
;<LARSON>SUBMIT.MAC;56    26-DEC-74 14:07:13	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;55    26-DEC-74 13:58:12	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;54    26-DEC-74 12:35:18	EDIT BY LARSON
;FIXED AMBIG TO GIVE THE ? ERROR
;<LARSON>SUBMIT.MAC;53    26-DEC-74 11:57:10	EDIT BY LARSON
;PUT IN HANDLING OF DEL ON INPUT, MOVED CTL CHAR CHECK OUT OF
;MAIN LOOP IN CMDRDR
;<LARSON>SUBMIT.MAC;52    26-DEC-74 11:49:14	EDIT BY LARSON
;PUT IN 'LEGAL DELIMITERS' AT EOC ROUTINE.
;PUT IN CONFRM
;PUT IN AFTER COMMAND
;PUT IN ACCOUNT COMMAND
;<LARSON>SUBMIT.MAC;49    23-DEC-74 12:12:34	EDIT BY LARSON
;PUT PROTECTION IN QNAME
;<LARSON>SUBMIT.MAC;48    23-DEC-74 11:28:01	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;47    23-DEC-74 11:21:54	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;46    23-DEC-74 10:45:28	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;45    23-DEC-74 10:13:58	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;44    23-DEC-74 10:04:44	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;43    23-DEC-74 08:44:23	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;42    20-DEC-74 22:16:16	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;41    20-DEC-74 21:35:27	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;40    20-DEC-74 15:17:05	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;39    20-DEC-74 15:11:18	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;38    20-DEC-74 15:04:14	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;37    20-DEC-74 13:02:33	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;36    17-DEC-74 15:36:35	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;35    10-DEC-74 09:43:36	EDIT BY LARSON
IFNDEF	SBMTSW,<
SBMTSW==1			;SBMTSW = 1  - PRODUCE SUBMIT
				;	= 0  - PRODUCE BATCH CONTROL PGM
	>

IFN	SBMTSW,<
	TITLE	SUBMIT	BATCH JOB SUBMITTER
	>
IFE	SBMTSW,<
	TITLE	BATCTL	BATCH CONTROLLER
	>

	XALL

	SEARCH	STENEX


;GENERAL PROGRAM EQUATES
PDLL==^D47				;SIZE OF PUSH DOWN LIST

;FOLLOWING ARE FLAGS TO DIRECT CMDRDR IN PROCESSING INPUT COMMANDS
COMLST==1B0			;INPUT FROM PRIME COMMAND LIST
SUBLST==1B1			;INPUT FROM SUBCOMMAND LIST
DIRSTR==1B2			;INPUT CAN BE DIRECTORY NAME STRING
FIXNUM==1B3			;INPUT CAN BE DECIMAL NUMBER
OCTNUM==1B4			;INPUT CAN BE OCTAL NUMBER
FLTNUM==1B5			;INPUT CAN BE SINGLE FLOATING NUMBER

IFNDEF	LPTLOG,<LPTLOG==1>	;DEFAULT LOG FILE IS LPT
IFNDEF TNX131,<TNX131==0>	;DEFAULT TO 133 AND ABOVE


;OPDEFS
OPDEF	CALL	[PUSHJ P,0]
OPDEF	RET	[POPJ  P,0]
OPDEF	ERR1	[1B8]			;MAIN USER ERROR UUO
OPDEF	TENXER	[2B8]			;PRINT LAST TENEX ERROR
OPDEF	NOISE	[3B8]			;NOISE WORD PROCESSOR
OPDEF	CONFRM	[4B8]			;CONFIRM FUNCTION
OPDEF	WAIT10	[CALL	[PUSH P,A
			MOVEI	A,^D10K	;TEN SECONDS
				DISMS
				POP  P,A
				RET]]

;MACRO DEFINITIONS
DEFINE	BUG(STR)<
	XLIST
	JRST	[PUSHJ P,BUGMSG
		ASCIZ /STR/]
	LIST
	>				;END BUG MACRO

DEFINE	TENERR(STR,ADR<0>)<
	XLIST
	TENXER	[ADR,,[ASCIZ \STR\]]
	LIST
	>				;END OF TENERR MACRO

DEFINE	ERROR(STR,ADR<0>)<
	XLIST
	ERR1	[ADR,,[ASCIZ /STR/]]
	LIST
	>				;END OF ERROR MACRO

DEFINE	NOISEM(STR)<
	XLIST
	NOISE	[ASCIZ /STR/]
	LIST
	>				;END OF NOISEM MACRO

DEFINE	.SAVE(NUM)<
	XLIST
	QQ==1
	REPEAT	NUM,<
	PUSH	P,QQ
	QQ==QQ+1>
	LIST
	>				;END OF .SAVE MACRO

DEFINE	.RSTOR(NUM)<
	XLIST
	QQ==NUM
	REPEAT	NUM,<
	POP	P,QQ
	QQ==QQ-1>
	LIST
	>				;END OF .RSTOR MACRO

DEFINE	NOCTLC<
	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C
	MOVEI	A,400000		;GET CAPABILITIES OF THIS FORK
	RPCAP
	TLO	C,(1B0)			;TURN ON ^C TRAPPING
	EPCAP
	MOVE	A,["C"-100,,1]		;ASSIGN ^C TO CHANNEL 1
	ATI
	MOVEI	A,400000		;ACTIVATE CHANNEL 1
	MOVSI	B,(1B1)
	AIC

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A
	>				;END OF NOCTLC MACRO


DEFINE	OKCTLC<
	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C

	MOVEI	A,400000		;DEACTIVATE CHANNEL 1
	MOVSI	B,(1B1)
	DIC
	MOVEI	A,"C"-100		;DEASSIGN ^C
	DTI
	MOVEI	A,400000		;GIVE UP RIGHT TO USE ^C
	RPCAP
	TLZ	C,(1B0)
	EPCAP

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A
	>				;END OF OKCTLC MACRO

DEFINE	TSTCTC(ADR,%CONT,%NOC,%PRC)<
	SKIPG	CTLCSW			;ANY ^C HITS?
	JRST	%NOC			;NOPE, CARRY ON

%PRC:	PPRINT	< ^C>			;NOW PRINT OUT ACKNOWLEDGMENTS
	SOSE	CTLCSW			;DECREMENT COUNT AND
	JRST	%PRC			;TYPE ANOTHER ONE IF MORE
	PPRINT	<
>					;FINISH WITH NEW LINE

	HALTF				;NOW GO SEE WHAT HE WANTS
	JRST	%CONT			;CONTINUING, TAKE OFF

%CONT:	JFCL
%NOC:					;NO ^C - CONTINUE IN LINE
	>				;END OF TSTCTC MACRO

;
;	.JSYSR	JSYS ERROR PRINT ROUTINE
;
DEFINE	.JSYSR<
JSYSER:
	.SAVE	3
	  HRRZ	2,1
	  MOVEI	1,101
	  HRLOI	2,400000
	  SETZ	3,
	  ERSTR
	  JFCL
	  JFCL
	  PPRINT	< AT >
	  HRRZ	B,-4(P)
	  SUBI	2,1
	  MOVEI	C,10
	  MOVEI	A,101
	  NOUT
	  JFCL
	  .RSTOR	3
	  RET>
;
;	FSOUT	STRING TO FILE
;		STRING - STRING ADDRESS (STRING CANNOT CONTAIN ","'S)
;		JFN - FILE JFN (IF NOT SPECIFIED , ASSUMED IN AC1)
;			 (ASSUME "0" TERMINATOR)
;
DEFINE	FSOUT	(STRING,JFN)<
	  IFNB	<JFN>,<MOVE 1,JFN>
	  HRROI	2,[ASCIZ /'STRING'/]
	  SETZ	C,
	  SOUT	>			;END OF FSOUT MACRO

DEFINE	PPRINT (A)<
	XLIST
	HRROI	1,[ASCIZ "A"]
	PSOUT
	LIST>				;END OF PPRINT MACRO

;INITALIZATION
START:	RESET				;CLEAN UP THE WORLD
	MOVE	P,[IOWD PDLL,PDL]	;SET UP STACK

;INITALIZE LUUO TRAP
	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

;GET CAPABILITIES
	MOVEI	A,400000		;THIS PROCESS
	RPCAP				;READ OUR CAPABILITIES
	MOVEM	C,CAPS			;SAVE ENABLED IN RH
	HRLM	B,CAPS			;SAVE POSSIBLE IN LH

IFE	SBMTSW,<
	TRNN	B,1B18+1B19		;IS HE A WHEEL OR OPER?
	ERROR	(<SORRY, WHEELS ONLY>,.EXIT)	;TOUGH LUCK
	>


;SET UP INTERRUPT SYSTEM TO RESTART WITH ^O
	MOVEI	A,400000
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR

	HRLZI	A,"O"-100		;SET UP ^O ON CHANNEL 0
	ATI

	MOVEI	A,400000
	MOVSI	B,(1B0)			;ACTIVATE CHANNEL 0
	AIC

	EIR				;ENABLE INTERRUPTS

;SET UP TERMINAL AND DEFAULTS.  FOR THE SPECIAL CASE WHERE THIS JOB RUNS
;UNDER ANOTHER (LIKE LISP), AND IF BOTH INPUT AND OUTPUT ARE TTY:, MAKE SURE
;THAT THE PRIMARY JFNS AGREE SO ECHOING IS DONE PROPERLY.

STRT1:	MOVEI	A,400000		;NOW LOOK AT PRIMARY JFN
	GPJFN
	PUSH P,B
	HLRZM	B,TTJFN#		;SAVE THE INPUT JFN FOR LATER (BKJFN)
	HRRZ	B,B
	CAIN	B,-1			;IS IT DEFAULT TTY?
	JRST	INPTTY			;YES, GO CHECK THE OUTPUT
	HRROI	A,LOGNAM		;NO, GET ITS NAME
	SETZ	C,
	JFNS
	MOVE	D,[ASCIZ /TTY:/]
	CAME	D,LOGNAM		;IS IT TTY:?
	JRST	STRT2			;NO, FORGET IT AND START PROCESSING

INPTTY:	HLRZ	B,0(P)			;OK, INPUT IS TTY: - HOW ABOUT OUTPUT
	CAIN	B,-1			;DEFAULT TTY:?
	JRST	OUTTTY			;YES, GO SET THE PRIMARY JFNS
	HRROI	A,LOGNAM		;NO, CHECK ITS REAL NAME
	SETZ	C,
	JFNS
	MOVE	D,[ASCIZ /TTY:/]
	CAME	D,LOGNAM		;IS IT TTY:?
	JRST	STRT2			;NO, FORGET IT AND START PROCESSING

OUTTTY:	MOVEI	A,400000		;OK, BOTH ARE TTY: - MAKE SURE THE
	HRR	B,0(P)			;INPUT AND OUTPUT JFNS ARE THE SAME
	HRL	B,B			;(AS OUTPUT) SO ECHOING WORKS
	HRRZM	B,TTJFN
	SPJFN

STRT2:	POP	P,B			;RESET STACK
	SETZM	QENT			;CLEAR Q ENTRY
	MOVE	A,[QENT,,QENT+1]
	BLT	A,QENT+QESIZE-1		;QUICKLY

;FIND OUT DIRECTORY NUMBER FOR BATCH JOB, SHOULD BE PROTECTED FROM
;MEDDLING ONCE SET.
	GJINF				;GET INFO ABOUT OURSELVES
	MOVEM	A,QENT+USRDIR		;SAVE OUR DIRECTORY NUMBER

	MOVE	B,A			;WANT IN STRING FORM TOO
	HRROI	A,JBNAME
	DIRST
	BUG	(<DIRST FAILED ON LOGGED IN DIRECTORY>)

IFE	SBMTSW,<
	SETOM	QENT+COMCOD	      	;ZERO COMMAND CODE
	SETOM	QENT+COMPAR	      	;ZERO COMMAND VALUE
	>		;END OF CONDITIONAL TO INIT BATCH CONTROL

IFN	SBMTSW,<
; SET UP DEFAULT LOAD AVERAGE
	MOVE	A,[MAXLA]
	MOVEM	A,QENT+LOADAV

;SET UP DEFAULT LOGLNS(# OF LINES/LOG FILE)
	MOVE	A,[DEFLLN]
	MOVEM	A,QENT+LOGLNS

;INITALIZE SWITCHES
IFN	NOTDEF,<
	SETOM	QENT+NOTFY		;SET DEFAULT TO NOTIFY
	>
IFE	NOTDEF,<
	SETOM	QENT+MESAG		;SET DEFAULT TO MESSAGE
	>
	SETZM	DIRECT#			;INDIRECT SUBMIT TO QUEUE
	SETZM	DESUB			;ASSUME SUBMIT
	SETOM	QENT+PRIOR			;BATCH PRIORITY

	IFN STRACT,<
	PUSHJ	P,DEFACT		;GET DEFAULT ACCOUNT STRING
	>
	IFE STRACT,<
	AOS	QENT+USRACT		;SET DEFAULT ACCOUNT NUMBER = 1
	>
	IFN	LPTLOG,<
	MOVE	A,[ASCII /LPT:/]	;DEFAULT LOG FILE
	MOVEM	A,QENT+LOGFIL		;SET IT
	>

	MOVE	A,[DEFETM]		;MAX ELAPSED DEFAULT (12 HRS)
	MOVEM	A,QENT+ETIME		;SET IT
	MOVE	A,[DEFRTM]		;MAX CPU TIME JOB CAN RUN
	MOVEM	A,QENT+RTIME		;SET IT
	SETZM	QENT+CTLFIL		;SAY WE HAVE NO CTL FILE

IFN IMSLOG,<
IFN SUMEX,<
	MOVEI	A,1B18			;DEFAULT LABEL SUBSYSTEM CHANGES
	MOVEM	A,QENT+LINLAB
	>
IFN IMSSS,<
	SETOM	QENT+LINLAB		;DEFAULT SUPPRESS ALL LOG FILE LABELS
	>
	>
	>		;END OF CONDITIONAL TO INIT SUBMIT

	IFN	SRIPTY,<
;FIGURE OUT WHERE THE PSEUDOTTYS ARE AT SRI
	MOVE	A,['LOGDES']
	SYSGT
	MOVE	A,B		;ENTRY 1 IS 'JOB0TT'
	HRLI	A,1
	GETAB
	JRST	NOPTYE		;FUNNY
	AOS	A		;JOB0TT+1 IS FIRST PTY
	TRZ	A,400000	;JUST THE INDEX
	MOVE	C,A		;SAVE IT
	MOVE	A,['LHOSTN']
	SYSGT
	MOVE	A,B
	HRLI	A,110		;ENTRY 1 IS 1ST NETWORK TTY
	GETAB
	JRST	NOPTYE		;STRANGE
	TRZ	A,400000	;INDEX ONLY
	SUBM	C,A		;GET -#PTY'S IN C
	HRL	C,A		;GET -#PTYS,,1ST-PTY IN C
	MOVEM	C,PSEUD1	;SAVE IN PSEUD1
NOPTYE:	;USE WHATS IN PSEUD1 NOW IF CANT FIND PTYS ECL STYLE
	>			;END OF IFN SRIPTY
;READ THE MAIN COMMAND IN

PROMPT:	MOVE	P,[IOWD PDLL,PDL]	;BE SURE OF STACK, ERROR EXITS
					;COULD HAVE LEFT IT MESSED UP.
	MOVSI	ZZ,(COMLST)		;INPUT PRIME COMMAND
	SETZM	SUBLAD			;CLEAR SUBCOMMAND LIST ADDRESS
	MOVEI	A,HELPER		;SET HELPER ADDRESS
	MOVEM	A,HELPAD
	MOVEI	A,"A"			;SET ACCEPTABLE CHARACTER RANGE
	MOVEM	A,SCHRNG		; "A" - "Z"
	MOVEI	A,"Z"
	MOVEM	A,ECHRNG

	PUSHJ	P,CCRLF			;CRLF IF NEEDED
	MOVEI	A,"*"			;PROMPT CHAR
	MOVE	B,[POINT 7,COMMAN]	;POINT TO COMMAND
	MOVEM	B,PCMD			;STORE FOR ^R ROUTINE
	IDPB	A,B			;STORE THE * FOR ^R
	MOVEM	B,PCMD2			;POINT TO THIS COMMAND
	PBOUT				;GIVE IT TO USER
PROMP2:	MOVEI	A,LIST1			;POINT TO MAIN COMMAND LIST
	MOVEM	A,ALIST			;SAVE FOR SCAN ROUTINE

	PUSHJ	P,CMDRDR		;READ THE COMMAND, RECOGNIZE IT
	JRST	PROMPT			;HE DID ^X
	JRST	[MOVEI	A,7		;HE DID ^A OFF RANGE
		 PBOUT			;RING BELLS
		 JRST	PROMP2]
	JRST	PROMPT			;HE ENTERED UNRECOGNIZABLE COMMAND
	BUG	(<HELP RETURN FROM CMDRDR>)	;OOPS
	JRST	.GO			;HE JUST HIT RETURN
	JRST	GOTONE			;GOOD COMMAND - GO DO IT


;HERE WE HAVE A SUBCOMMAND

SUBPRM:	MOVEI	A,101			;DO WE NEED A NEW LINE PROMPT
	MOVE	B,EOCCH			;WAS LAST CHAR AN EOL?
	CAIN	B,37
	JRST	[HRROI	A,[ASCIZ /**/]
		 PSOUT
		 JRST	.+1]

	MOVSI	ZZ,(SUBLST)		;INPUT SUBCOMMAND
	MOVEI	A,HELPER		;SET HELPER ADDRESS
	MOVEM	A,HELPAD
	MOVEI	A,"/"			;SET ACCEPTABLE CHARACTER RANGE
	MOVEM	A,SCHRNG		; "A" - "Z"
	MOVEI	A,"Z"
	MOVEM	A,ECHRNG

	MOVE	B,[POINT 7,COMMAN]	;SET UP FOR COMMAND PROCESSOR
	MOVEM	B,PCMD
	MOVE	B,EOCPTR		;POST PROMPT FOR CTLR
	MOVEM	B,PCMD2

PROMP3:	MOVE	A,SUBLAD		;NEW COMMAND LIST FROM STACK
	MOVEM	A,ALIST
	PUSHJ	P,CMDRDR
	JRST	PROMPT			;^X - RESET TO 0
	JRST	[MOVEI	A,7		;^A - OFF END OF RANGE, BELLS
		 PBOUT
		 JRST	PROMP3]
	JRST	PROMPT			;UNRECOGNIZED COMMAND
	BUG	(<HELP RETURN FROM CMDRDR>)
	ERROR	(<SUBCOMMAND REQUIRED>,PROMPT)
	JRST	GOTSUB




;WE COME HERE IF WE GOT A GOOD COMMAND.
;LAST CHAR IS IN CMDTRM.
;POINTER TO LIST ENTRY IS IN A
GOTONE:	
GOTSUB:	MOVE	B,1(A)			;GET FLAGS,,ADR
	JRST	(B)			;GO TO ROUTINE



IFE	SBMTSW,<
;ROUTINE TO FILL IN COMMAND CODE AND TEXT INTO FILE RECORD

FILLIT:	.SAVE	3			;SAVE TABLE ADDRESS AND AC'S

	SUBI	A,LIST1			;COMPUTE COMMAND INDEX
	LSH	A,-1
	MOVEM	A,QENT+COMCOD		;STORE IT

	SETZM	QENT+COMNAM		;CLEAR FIELD FOR COMMAND TEXT
	MOVE	A,[XWD QENT+COMNAM,QENT+COMNAM+1]
	BLT	A,QENT+COMCOD-1

	HRROI	A,QENT+COMNAM		;OUTPUT COMMAND STRING
	MOVE	B,-2(P)			;RECOVER LIST ADDRESS
	HRRO	B,0(B)			;MAKE STRING POINTER
	SETZ	C,
	SOUT

	.RSTOR	3			;RESTORE WORKING AC'S

	POPJ	P,			;RETURN
	>		;END OF SBMTSW CONDITIONAL FOR CONTROL COMMAND CODE



;ROUTINE TO FETCH A POSITIVE JOB NUMBER.  IT IS RETURNED IN AC 1.
GETJBN:	PUSH	P,B			;SAVE AC'S
	PUSH	P,C

	MOVSI	ZZ,(FIXNUM)		;INPUT DECIMAL NUMBER
	MOVEI	A,GTJHEP		;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD

	PUSHJ	P,GETSTR		;GO GET AN INPUT STRING

	CAILE	B,0			;MAKE SURE IT IS POSITIVE
	CAILE	B,NQJBS			;AND LESS THAN MAXIMUM
	ERROR	(<JOB # OUT OF RANGE>,PROMPT)	;TOUGH

	MOVE	A,B			;GOOD ONE, PUT IT IN AC A

	POP	P,C			;RESTORE AC'S
	POP	P,B

	POPJ	P,			;RETURN


;HELP ROUTINE FOR GETTING JOB NUMBER
GTJHEP:	HRROI	A,[ASCIZ /

  ENTER DECIMAL JOB NUMBER

/]
	PSOUT
	POPJ	P,



;ROUTINE TO FETCH A NUMERICAL STRING SUBCOMMAND
;   EXPECTS ZZ TO CONTAIN NUMBER TYPE FLAG
;   CLOBBERS AC'S A, B, AND C
;	A RETURNS 0
;	B = VALUE
;	C = PARAMETER TYPE FLAG

GETSTR:	MOVEI	A,"+"			;SET ACCEPTABLE CHARACTER RANGE
	MOVEM	A,SCHRNG		; "+" - "9"
	MOVEI	A,"9"
	MOVEM	A,ECHRNG
	MOVE	B,EOCCH
	CAIN	B,37
	JRST	[HRROI	A,[ASCIZ /**/]
		 PSOUT
		 JRST	.+1]

	MOVE	B,[POINT 7,COMMAN]	;SET UP FOR COMMAND PROCESSOR
	MOVEM	B,PCMD
	MOVE	B,EOCPTR		;POST PROMPT FOR CTLR
	MOVEM	B,PCMD2

GETST0:	PUSHJ	P,CMDRDR		;READ THE COMMAND, RECOGNIZE IT
	JRST	PROMPT			;HE DID ^X
	JRST	[MOVEI	A,7		;HE DID ^A OFF RANGE
		 PBOUT			;RING BELLS
		 JRST	GETST0]
	JRST	PROMPT			;HE ENTERED UNRECOGNIZABLE COMMAND
	BUG	(<HELP RETURN FROM CMDRDR>)	;OOPS
	JRST	[SETZ	A,		;HE JUST HIT RETURN - MAKE IT 0
		 SETZ	B,
		 MOVE	C,ZZ
		 JRST	.+1]
	JFCL				;GOOD COMMAND - RETURN WITH IT

	POPJ	P,			;RETURN




;COMMAND ERROR - GENERAL COMMAND ABORT ROUTINE
CMDERR:	HRROI	A,[ASCIZ /  <?>/]	;COMPLAIN
	PSOUT				;SEND MSG TO USER
	JRST	PROMPT			;TRY AGAIN
;COMMAND EXECUTION ROUTINES.
;EVERYTHING ON THIS PAGE IS FOR BATCON CONTROL PROGRAM


IFE	SBMTSW,<
;COMMAND FOR SNAPSHOT DUMP
.BDUMP:	NOISEM	<OF BATCON AND INFERIOR FORKS>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO HALT BATCON TEMPORARILY
.BHALT:	NOISEM	<BATCON TEMPORARILY>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO RESUME BATCON AFTER HALT
.BRESM:	NOISEM	<BATCON RUNNING>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO FORCE BATCON RESTART
.BRSTR:	NOISEM	<BATCON IN CURRENT CORE IMAGE>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO FORCE BATCON RELOAD
.BRLOD:	NOISEM	<FRESH BATCON IMAGE AND RESTART>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;SETUP COMMAND FOR BATCON STATUS OR BATCON CLEAR
.CBATC:
.SBATC:	SETZM	QENT+COMPAR
	MOVE	A,SUBACA		;RESTORE LIST POINTER
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO GO TO A GIVEN ADDRESS
.GOTO:	NOISEM	<BATCON ADDRESS>
	MOVEM	A,SUBACA		;SAVE COMMAND PTR
	MOVEI	A,101			;GET OCTAL ADDRESS
	MOVEI	C,10
	NIN
	ERROR	(<INVALID ADDRESS>,PROMPT)
	SKIPG	B			;IS IT POS DEF
	ERROR	(<ADDRESS MUST BE POSITIVE>,PROMPT)
	MOVEM	B,QENT+COMPAR		;OK

	MOVE	A,SUBACA		;RESTORE COMMAND PTR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMANDS TO:
;	DEFER JOB EXECUTION INDEFINITELY - DEFER
;	RESET QUEUE STATUS DATA - RESET
;	FREEZE A RUNNING JOB - FREEZE
;	MELT A FROZEN RUNNING JOB - MELT
;	PURGE A JOB - PURGE
;	FORCE START A JOB - START
;
;ALL HAVE THE FORM:	COMMAND + JOB NUMBER

.DEFER:
.RESET:
.FREEZ:
.MELT:
.PURGE:
.START:	NOISEM	<JOB NUMBER>
	MOVEM	A,SUBACA		;SAVE AC A - COMMAND INDEX
	PUSHJ	P,GETJBN		;GET JOB NUMBER
	MOVEM	A,QENT+COMPAR		;PUT IT IN COMMAND PARAMETER
	MOVE	A,SUBACA		;RESTORE COMMAND INDEX
	PUSHJ	P,FILLIT		;OK, FILL IN DATA
	JRST	PROMPT			;GO FOR MORE INPUT

	>		;END OF SBMTSW CONDITIONAL FOR CONTROL PROGRAM

;EVERYTHING ON THIS PAGE IS FOR THE CONTROL PROGRAM

IFE	SBMTSW,<
;COMMAND TO CHANGE BATCON ENTFLG SETTING

.ENTFG:	NOISEM	<SETTING>
	MOVEM	A,SUBACA		;SAVE LIST PTR
	MOVSI	ZZ,(DIRSTR+OCTNUM)	;ALLOW DIR NAMES AND OCT NUMBERS
	MOVEI	A,.ENHEP		;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD
	MOVEI	A,"+"			;SET UP VALID CHAR RANGE
	MOVEM	A,SCHRNG
	MOVEI	A,"Z"
	MOVEM	A,ECHRNG
	MOVE	B,EOCCH
	CAIN	B,37
	JRST	[HRROI	A,[ASCIZ /**/]
		 PSOUT
		 JRST	.+1]

	MOVE	B,[POINT 7,COMMAN]	;SET UP FOR COMMAND PROCESSOR
	MOVEM	B,PCMD
	MOVE	B,EOCPTR		;POST PROMPT FOR CTLR
	MOVEM	B,PCMD2			;AND AS START FOR INTERPRETER

.ENTF0:	PUSHJ	P,CMDRDR		;GO GET THE INPUT
	JRST	PROMPT			;HE DID ^X
	JRST	[MOVEI	A,7		;HE DID ^A OFF RANGE
		 PBOUT			;RING BELLS
		 JRST	.ENTF0]
	JRST	PROMPT			;HE ENTERED UNRECOGNIZABLE COMMAND
	BUG	(<HELP RETURN FROM CMDRDR>)	;OOPS
	ERROR	(<>,PROMPT)		;HE JUST HIT RETURN
	JFCL				;GOOD COMMAND - GO DO IT

	TLNN	C,(OCTNUM)		;WAS IT A NUMBER?
	JRST	.ENTF2			;NO, MUST BE GOOD DIRECTORY
	CAIG	B,0			;NUMBER, IS IT GT 0?
	JRST	[CAIE	B,0		;NO, LT 0
		 SETO	B		;YES, MAKE IT -1
		 JRST	.ENTF2]
	HRROI	A,FENT			;GT 0 - SEE IF REAL DIRECTORY
	DIRST
	ERROR	(<INVALID DIRECTORY NUMBER>,PROMPT)

.ENTF2:	MOVEM	B,QENT+COMPAR		;STORE DIRECTORY NUMBER

	MOVE	A,SUBACA		;RESTORE LIST PTR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE

	JRST	PROMPT			;GO FOR MORE


;HELP ROUTINE FOR ENTRY FLAG STUFF
.ENHEP:	HRROI	A,[ASCIZ /

  ENTFLG VALUE:
   -1          RUN ANY USER
    0          RUN NO USERS
  DIR NUM (8)  RUN SINGLE USER
  USER NAME    RUN SINGLE USER

/]
	PSOUT
	POPJ	P,



;
;CLEAR BATCH PROCESSOR QUEUE (WHEEL ONLY)
;
.CLEAR:	NOISEM	<BATCON OR QUEUE>
	MOVEM	A,SUBACA		;SAVE COMMAND INDEX
	MOVEI	A,LIST4			;ADDRESS OF SUBCOMMAND LIST
	MOVEM	A,SUBLAD
	JRST	SUBPRM			;GET NEXT PART OF COMMAND

;THIS SECTION CLEARS THE BATCH QUEUE
.CQUE:	CONFRM			;BETTER CONFIRM THIS!

	MOVSI	A,2001		;NO ACCESS BY OTHER FORKS
	HRROI	B,QNAME		;QUEUE NAME STRING
	GTJFN
	TENERR	(<CLEAR Q: CANNOT GTJFN BATCH QUEUE>,START)
	MOVE	B,[440000,,100000]	;WRITE ACCESS
CLEAR1:	NOCTLC			;TURN OFF ^C
	QOPENF
	JFCL
	TENERR	(<CLEAR Q: CANNOT OPEN BATCH QUEUE>,START)
	HRLI	1,12		;OFFSET INTO FDB OF BYTE COUNT
	HRROI	2,-1		;BIT CHANGE MASK
	SETZ	3,		;NEW VALUE
	CHFDB			;CLEAR BYTE COUNT OF FDB
	HRRZS	1
	CLOSF
	TENERR	(<CLEAR Q: CLOSE ERROR ON BATCH QUEUE>,START)
	OKCTLC			;RESTORE ^C
	JRST	PROMPT
	>		;END OF SBMTSW CONDITIONAL FOR CONTROL PROGRAM


;FOLLOWING ARE TWO VERSIONS OF GO COMMAND - ONE FOR CONTROL PGM AND ONE
;FOR SUBMIT PGM


IFE	SBMTSW,<
;GO - SUBMIT THE CONTROL TASK
.GO:	SKIPN	QENT+COMNAM		;HAS A COMMAND BEEN ENTERED
	JRST	[FSOUT<  BYE>,[101]			;NO
		 JRST	.EXIT]

	CONFRM				;HAVE HIM CONFIRM THIS

	GTAD				;GET CURRENT TIME AND DATE
	MOVEM	A,QENT+ENTERD		;PUT IN Q ENTRY

GO2:	MOVEI	A,CJBBLK		;LONG FROM CJBBLK
	SETZ	B,
	GTJFN
	JRST	[WAIT10			;TRY AGAIN IN A BIT
		 JRST	GO2]
	MOVEM	A,TJFN#			;SAVE JFN IN CASE OF ERROR
	MOVE	B,[^D36B5+1B20]		;WRITE 36 BITS
	NOCTLC				;TURN OFF ^C
	OPENF
	JRST	[MOVE	A,TJFN		;NEED TO RELEASE IT
		RLJFN
		JFCL
		WAIT10			;TRY AGAIN IN A BIT
		JRST	GO2]
	MOVE	B,[1,,FDBVER]		;FIND OUT WHAT VERSION WE HAVE
	MOVEI	C,C			;INTO C
	GTFDB
	HLRZM	C,QENT+BJOBNO
GO3:
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;IT'S LENGTH
	SOUT				;WRITE REQUEST

	CLOSF				;CLOSE JOB ENTRY
	TENERR	(<GO: Cannnot CLOSF new control job>,START)
	OKCTLC				;RESTORE ^C

SUBBED:	HRROI	A,[ASCIZ /CONTROL TASK /]
	PSOUT
	MOVEI	A,101
	MOVE	B,BJOBNO+QENT
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	A,[ASCIZ / SUBMITTED./]
	PSOUT				;REPORT IT

	JRST	START
	>		;END OF SBMTSW CONDITIONAL - CONTROL GO COMMAND



IFN	SBMTSW,<
;GO - DO THE SUBMIT

.GO:	SKIPN	QENT+CTLFIL		;DID HE GIVE CTL FILE?
	JRST	[FSOUT	<  NO CONTROL FILE - BYE>,[101]
		 JRST	.EXIT]

	CONFRM				;HAVE HIM CONFIRM THIS

	IFE	LPTLOG,<
	SKIPN	QENT+LOGFIL		;SKIP IF ALREADY SPECIFIED
	PUSHJ	P,LOGDEF		;GENERATE A DEFAULT FILE NAME
	>
	GTAD				;GET CURRENT TIME AND DATE
	MOVEM	A,QENT+ENTERD		;PUT IN Q ENTRY
	SKIPE	C,DESUB			;NEW JOB OR CHANGE?
	JRST	GO2			;CHANGE, JUST GET A FILE

REPEAT	0,<
;CHECK FOR DIRECT SUBMIT REQUEST
	SKIPN	DESUB			;NO DIRECT FOR DESUBMIT REQUEST
	SKIPN	DIRECT			;DIRECT?
	CAIA
	JRST	DSUB			;YES
	>


IFE FDBSEQ,<

;INDIRECT SUBMIT ACTION.  THE FOLLOWING CODE TRIES TO OPEN THE JOB-
;SEQUENCE.LOCK FILE THAWED, READ THE CONTENTS, DETERMINE THE NEXT
;AVAILABLE JOB SLOT, GRAB IT, AND WRITE THE FILE BACK OUT NOTING THAT
;THE NEW SLOT IS IN USE.  THERE IS A CORE LOCK THAT ALLOWS ONLY
;ONE SUBMIT USER TO ACCESS THE FILE AT ONCE.  IF THE LOCK FILE IS
;NOT AVAILABLE IN A REASONABLE TIME, THE OLD USER WORD IN THE FDB
;THRASH IS INVOKED.  THE LOCK IS ACQUIRED WITH ^C DISABLED SO THAT THE
;LOCK CANNOT BE HELD.  ANY JOB NUMBER CONFLICTS OR INVALID
;NUMBERS ARE CAUGHT BY BATCON AND THE JOB IS RENUMBERED.

GO1:	MOVSI	A,(1B2+1B17)		;GTJFN ON OLD LOCK FILE
	HRROI	B,SEQLOK		;OUT TO JOB-SEQUENCE FILE
	GTJFN
	TENERR	(<GTJFN ERROR ON JOB SEQ FILE>,USEFDB)
	MOVEM	A,SEQJFN		;SAVE THE JFN
	MOVE	B,[44B5+1B19+1B20+1B25]	;OPEN IT 36 BIT, READ, WRITE, THAWED
	OPENF
	JRST	[TENERR	(<ERROR OPENING JOB SEQ FILE - CONTINUING>)
		 MOVE	A,SEQJFN	;RELEASE LOCK FILE JFN
		 RLJFN
		 TENERR	(<ERROR RELEASING JOB SEQ FILE JFN - CONTINUING>)
		 JRST	USEFDB]		;AND USE THE FDB # ANYWAY

	MOVE	B,[1,,12]		;GET FILE SIZE FROM FDB
	MOVEI	C,C
	GTFDB
	CAIE	C,NJBWRD+2		;RIGHT SIZE?  ROOM FOR LOCK, FMXJBN,
					;AND NJBWRD FJBBIT WORDS
	 JRST	[PPRINT	<
? JOB SEQUENCE FILE SIZE WRONG - CONTINUING
>
		 PUSHJ	P,LOKCLS	;GO CLOSE FILE
		 JRST	USEFDB]		;GO RELEASE JFN AND USE FDB #

	HRLZ	A,SEQJFN		;OK,NOW MAP THE CONTROL PAGE 0
	MOVE	B,[400000,,CTLPAG]	;INTO CTLPAG
	MOVSI	C,(1B2+1B3)		;READ AND WRITE ACCESS
	PMAP

; Now we have the control page, try to get the lock ...

	MOVEI	C,^D5			;WAIT 5 CYCLES MAXIMUM
TRYAGN:	NOCTLC				;DON'T ALLOW ^C INTERRUPTIONS
	AOSN	JBSQLK			;TRY TO GET LOCK
	JRST	GOTLOK			;OK, GOT IT
	OKCTLC				;RESTORE ^C FOR NOW
	TSTCTC				;SEE IF WE GOT ANY
	CAIL	C,^D5			;FIRST TIME?
	 JRST	[PPRINT	<   [BUSY->
		 JRST	WTABIT]		;NOW GO WAIT A WHILE
	MOVEI	A,"-"			;NOT FIRST, ADD A "-"
	PBOUT

WTABIT:	MOVEI	A,^D3000		;WAIT A BIT
	DISMS
	SOJGE	C,TRYAGN		;NOPE, TRY TO GET LOCK AGAIN
	PPRINT	<
? LOCK UNAVAILABLE: CONTINUING
>
	PUSHJ	P,LOKUMP		;GIVE UP, GET RID OF JOB SEQ FILE
	JRST	USEFDB			;AND USE THE FDB #

GOTLOK:	CAIL	C,^D5			;DID WE HAVE TO WAIT?
	JRST	PRCLOK			;NO, SO CARRY ON
	PPRINT	<GO]
>					;YES, SO FINISH MSG


PRCLOK:	MOVE	A,FMXJBN		;OK, NOW SCAN FOR THE NEXT
	CAILE	A,0			;IS IT WITHIN RANGE?
	CAILE	A,NQJBS
	MOVEI	A,1			;NO, RESET IT
	MOVEM	A,FMXJBN		;SAVE IT IF UPDATED
	IDIVI	A,^D36			;COMPUTE BIT TABLE ADDRESS
	MOVN	B,B			;AND SET UP BIT MASK
	MOVSI	C,(1B0)
	LSH	C,0(B)
	MOVE	B,FMXJBN		;PUT CURRENT GUESS IN AC B
SCANJB:	TDNN	C,FJBBIT(A)		;IS THIS SLOT FREE?
	JRST	GOODJB			;YES, GO GRAB IT
	AOJ	B,			;BUSY, TRY ANOTHER
	ROT	C,-1			;NEXT BIT MASK SLOT
	TLNE	C,(1B0)			;DID IT WRAP?
	AOJ	A,			;YES, THEN BUMP TO NEXT BIT TABLE WORD
	CAILE	B,NQJBS			;DID JOB NUMBER WRAP?
	JRST	[SETZ	A,		;YES, THEN RESET TO START OF TABLE
		 MOVEI	B,1		;NO JOB 0
		 MOVSI	C,(1B1)
		 JRST	.+1]
	CAME	B,FMXJBN		;HAVE WE COME FULL CIRCUIT?
	JRST	SCANJB			;NO - TRY THIS NEXT ONE

	PPRINT	<
? JOB Q FULL - ASSIGNING AN OLD JOB NUMBER
>
	PUSHJ	P,LOKDON		;CLEAN UP THE JOB SEQ FILE
	JRST	USEFDB			;AND GO USE THE FDB #

GOODJB:	IORM	C,FJBBIT(A)		;SHOW THIS SLOT NOW IN USE
	MOVE	D,B			;SAVE THE JOB NUMBER IN AC D
	AOJ	B,			;UPDATE TO THE NEXT NUMBER
	CAILE	B,NQJBS			;WRAP AROUND?
	MOVEI	B,1			;YES, RESET TO LOWEST JOB
	MOVEM	B,FMXJBN		;UPDATE THE NEXT NUMBER
	PUSHJ	P,LOKDON		;AND GIVE UP THE LOCK

	MOVEM	D,QENT+BJOBNO		;SAVE AS THIS JOB'S NUMBER
	MOVEM	D,LSTJOB		;ALSO FOR LATER IF NECESSARY

HAVJOB:	HRRM	D,JBBLK			;TRY FOR THIS VERSION NUMBER
	MOVEI	A,JBBLK			;ON THE NEW JOB FILE
	SETZ	B,
	GTJFN				;TRY FOR JFN
	AOJA	D,HAVJOB		;OOPS, TRY THE NEXT ONE
	MOVEM	A,TJFN#			;SAVE IT FOR LATER
	MOVE	B,[^D36B5+1B20]		;OPEN 36 BIT, WRITE
	OPENF
	 JRST	[MOVE	A,TJFN		;OOPS, RELEASE THIS ONE
		 RLJFN
		 JFCL
		 AOJA	D,HAVJOB]	;AND TRY ANOTHER
	JRST	GO3			;OK, NOW WRITE THE NEW JOB


; THE FOLLOWING ROUTINES RELEASE THE JOB SEQ LOCK AND CLOSE OUT THE FILE

LOKDON:	SETOM	JBSQLK			;CLEAR THE LOCK
	OKCTLC				;TURN ON ^C AGAIN
	TSTCTC				;ANY BEEN HIT WHILE WE WERE AT IT?

LOKUMP:	SETO	A,			;UNMAP OUR PAGE IN JOB SEQ FILE
	MOVE	B,[400000,,CTLPAG]
	SETZ	C,
	PMAP

LOKCLS:	MOVE	A,SEQJFN		;AND CLOSE OUT THE FILE
	CLOSF				;OPEN, CLOSE IT
	TENERR	(<ERROR CLOSING JOB SEQ FILE - CONTINUING>)
	SETZM	SEQJFN			;NOTE IT IS GONE
	POPJ	P,			;RETURN TO THE CALLER

	>	;END OF FDBSEQ CONDITIONAL


; THE FOLLOWING STUFF IS THE OLD CODE USING THE USER SETTABLE WORD IN THE
; Q FDB FOR THE NEXT JOB NUMBER.  THIS MAY NOT HAVE BEEN UPDATED SO THERE
; MAY BE DUPLICATE JOB NUMBERS FLOATING AROUND.  THESE WILL BE FIXED UP
; LATER WHEN BATCON PICKS UP THE JOB.

USEFDB:	MOVSI	A,(1B2+1B17)		;OLD AND SHORT
	HRROI	B,QNAME			;GTJFN ON JOB QUEUE
	GTJFN
	JRST	[WAIT10			;ILLEGAL VERSION NUMBER
		JRST	USEFDB]		;TRY AGAIN
	MOVE	B,[1,,FDBUSW]		;USER SETTABLE WORD
	MOVEI	C,C			;PUT IN C
	GTFDB
	RLJFN				;GIVE BACK JFN
	JFCL

GO2:	CAILE	C,0			;IS THE JOB NUMBER IN RANGE?
	CAILE	C,NQJBS
	MOVEI	C,1			;NO, RESET IT
	SKIPN	DESUB			;IF NOT A CHANGE REQUEST,
	MOVEM	C,BJOBNO+QENT		;SAVE NEW JOB NUMBER
	HRRM	C,JBBLK
	MOVEI	A,JBBLK
	SETZ	B,
	GTJFN
	AOJA	C,GO2			;TRY AGAIN WITH NEXT VERSION
IFE FDBSEQ,<
	MOVEM	A,TJFN			;SAVE JFN IN CASE OF ERROR
	>
IFN FDBSEQ,<
	MOVEM	A,TJFN#			;SAVE JFN IN CASE OF ERROR
	>
	MOVE	B,[^D36B5+1B20]		;WRITE 36 BITS
	NOCTLC				;TURN OFF ^C
	OPENF
	JRST	[MOVE	A,TJFN		;NEED TO RELEASE IT
		RLJFN
		JFCL
		OKCTLC			;RESTORE ^C
		AOJA	C,GO2]		;TRY AGAIN WITH NEW NUMBER
	MOVE	B,[1,,FDBVER]		;FIND OUT WHAT VERSION WE HAVE
	MOVEI	C,C			;INTO C
	GTFDB
	SKIPN	DESUB			;IF THIS IS A NEW JOB
	HLRZM	C,QENT+BJOBNO		;UPDATE THE JOB #
	HLRZM	C,LSTJOB		;SAVE JOB NUMBER FOR LATER

	JRST	GO3

REPEAT	0,<	;DOESN'T WORK--DON'T HAVE OWNERSHIP RIGHTS
	PUSH	P,A			;SAVE THE JFN
	HRLI	A,4			;DISP IN FDB
	MOVEI	B,77			;MASK OF BITS TO CHANGE
	SETZ	C,			;SET THEM TO 0
	CHFDB				;CHANGE THEM
	POP	P,A			;RESTORE JFN AS IT WAS
	>			;END THE BAD PART


REPEAT	0,<	;GET RID OF DIRECT SUBMIT COMMAND
;;;;; DIRECT SUBMIT ;;;;;

;THE FOLLOWING CODE SHOULD BE RUN WITH ^C DISABLED, SO THAT
;THE USER CANNOT ^C HALFWAY THOUGH AND LEAVE THE QUEUE FILE
;OPEN.
;*****FOR NOW, WE WILL TRUST THE USER (ME)*****
DSUB:				
	TIME
	TRZ	A,400000			;NOT NEGATIVE
	TRO	A,100000		;SO BATCH KNOWS IT IS FUNNY
	HRRM	A,BJOBNO+QENT		;FUNNY JOB NUMBER
	MOVSI	A,1			;FLAGS FOR GTJFN
	HRROI	B,QNAME			;NAME OF BATCH QUEUE
	GTJFN
	TENERR	(<DSUB: CANNOT GTJFN BATCH QUEUE>,START)
	MOVEM	A,TJFN
	MOVE	B,[440000,,20000]	;OPEN FOR APPEND
DSUB1:	QOPENF				;OPEN QUEUE FILE
	JFCL
	TENERR	(<DSUB: CANNOT OPEN Q FILE FOR APPEND>,START)
	MOVE	B,[POINT 36,QENT]	;STRING POINTER TO DATA
	MOVNI	C,QESIZE		;LENGTH TO SEND (36 BIT BYTES)
	SOUT				;SEND IT

	TLZ	A,-1			;TO BE SURE WE RELEASE JFN
	CLOSF				;CLOSE Q FILE
	TENERR	(<DSUB: UNABLE TO CLOSE Q FILE>,START)
	>		;END OF DELETE OF DIRECT COMMAND


GO3:	MOVE	A,TJFN			;RECOVER JOB FILE JFN
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;IT'S LENGTH
	SOUT				;WRITE REQUEST

	CLOSF				;CLOSE JOB ENTRY
	TENERR	(<GO: Cannnot CLOSF new job file>,START)
	OKCTLC				;RESTORE ^C

SUBBED:	HRROI	A,[ASCIZ /JOB /]
	PSOUT
	MOVEI	A,101
	MOVM	B,BJOBNO+QENT
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	A,[ASCIZ / SUBMITTED/]	;REGULAR SUBMIT
	SKIPGE	DESUB			;OR DESUBMIT REQUEST
	HRROI	A,[ASCIZ / DESUBMISSION REQUEST/]
	SKIPLE	DESUB			;OR CHANGE REQUEST
	HRROI	A,[ASCIZ / MODIFICATION REQUEST/]
	PSOUT				;REPORT IT

	JRST	.EXIT			;THAT'S IT
	>		;END OF SBMTSW CONDITIONAL FOR SUBMIT GO COMMAND


; Following are two versions of the LIST command - one for BATCTL (SBMTSW=0)
; and one for SUBMIT (SBMTSW=1)

IFE SBMTSW,<
;This routine prints out the command and parameters specified for the
;current session
.LIST:	NOISEM	<CURRENT CONTROL COMMAND>
	PUSHJ	P,CCRLF			;CRLF IF NEEDED
	PUSHJ	P,CRLF			;AND ANOTHER ONE

	SKIPE	QENT+COMNAM		;ANYTHING INPUT AT THIS TIME?
	JRST	.LIST0			;YES, GO PRINT IT
	PPRINT	<  No command entered
>
	JRST	.LIST1

.LIST0:	MOVE	C,QENT+COMCOD		;GET THE COMMAND CODE
	MOVE	D,C			;AND INDEX INTO THE TABLE
	LSH	D,1			;(2 WORDS PER ENTRY)
	MOVEI	A," "			;SKIP OVER A BIT
	PBOUT
	PBOUT
	HRRO	A,LIST1(D)		;SET UP STR PTR FOR NAME FROM TABLE
	HRROI	B,QENT+COMNAM		;POINTER FOR NAME FROM Q ENTRY
	PUSHJ	P,STRMA			;GO MATCH THEM
	JFCL
	BUG	(<.LIST: COMMAND STRING DOES NOT MATCH TABLE>)
	HRROI	A,QENT+COMNAM		;AGREES, SET UP NAME AGAIN

	MOVEI	B,33			;PUT AN ESC IN EOCCH
	MOVEM	B,EOCCH			;TO FAKE OUT NOISE WORD PROCESSOR
	JRST	@.LISTB(C)		;NOW DISPATCH TO PRINT COMMAND

.LISTB:	LSTERR				;.AFTER - ERROR
	LSTCLR				;.CLEAR
	LSTDEC				;.DEFER JOB  #
	LSTTXT				;.BDUMP BATCON
	LSTENT				;.ENTFG #
	LSTERR				;.EXIT - ERROR
	LSTDEC				;.FREEZ JOB #
	LSTOCT				;.GOTO ADR
	LSTTXT				;.BHALT BATCON
	LSTERR				;.RUNIN - ERROR
	LSTERR				;.LIST - ERROR
	LSTDEC				;.MELT JOB #
	LSTDEC				;.PURGE JOB #
	LSTTXT				;.BRLOD BATCON
	LSTDEC				;.RESET JOB #
	LSTTXT				;.BRSTR BATCON
	LSTTXT				;.BRESM BATCON
	LSTDEC				;.START JOB #
	LSTSTA				;.BSTAT OF BATCON

LSTERR:	BUG	(<.LIST: INVALID CONTROL COMMAND STORED>)

LSTTXT:	PSOUT				;PRINT COMMAND STRING
	MOVEI	A," "			;SPACE OVER
	PBOUT
	XCT	@LIST1+1(D)		;DO NOISE WORDS FOR COMMAND
	PUSHJ	P,CRLF			;NEXT LINE
	JRST	.LIST1

LSTDEC:	MOVEI	C,^D10			;SET UP BASE 10
	SKIPA
LSTOCT:	MOVEI	C,^D8			;SET UP BASE 8
	PSOUT
	MOVEI	A," "			;SPACE OVER
	PBOUT
	XCT	@LIST1+1(D)		;DO NOISE WORDS
	MOVEI	A,101
	MOVEI	B," "			;SPACE AGAIN
	BOUT
	MOVE	B,QENT+COMPAR		;PRINT THE PARAMETER
	NOUT
	JFCL
	PUSHJ	P,CRLF			;NEW LINE
	JRST	.LIST1

LSTCLR:	PPRINT	<CLEAR (ALL JOBS AND HALT BATCON TEMPORARILY)
>
	JRST	.LIST1

LSTENT:	PSOUT				;PRINT COMMAND STRING
	MOVEI	A," "			;SPACE OVER
	PBOUT
	XCT	@LIST1+1(D)		;ADD NOISE WORDS
	MOVEI	A,101
	MOVEI	B," "			;SPACE AGAIN
	BOUT
	SKIPG	B,QENT+COMPAR		;SPECIFIC USER NAME?
	JRST	LSTEN0			;NO, 0 OR -1
	DIRST				;SPECIFIC USER - GET HIS NAME
	BUG	(<.LIST: DIRST FAILED ON ENTFLG COMMAND>)
	JRST	LSTEN1

LSTEN0:	MOVEI	C,^D10
	NOUT
	JFCL
	SKIPL	QENT+COMPAR		;ADD TEXT DESCRIBING STATE
	 JRST	[PPRINT	< (NO users)>
		 JRST	LSTEN1]
	 JRST	[PPRINT	< (ALL users)>
		 JRST	LSTEN1]

LSTEN1:	PUSHJ	P,CRLF			;NEW LINE
	JRST	.LIST1

LSTSTA:	PPRINT	<STATUS (OF BATCON AND INFERIOR FORKS)
>
	JRST	.LIST1

.LIST1:	SKIPN	B,QENT+AFTER		;ANY TIME SPEC ON ISSUING COMMAND?
	JRST	.LIST3			;NO, WRAP IT UP
	TLNE	B,-1			;AFTER JOB #?
	JRST	.LIST2			;NO, GO PRINT THE TIME
	PPRINT	<  AFTER job # >	;YES, PRINT IT
	MOVEI	A,101
	MOVEI	C,^D10
	NOUT
	JFCL
	PUSHJ	P,CRLF
	JRST	.LIST3

.LIST2:	PPRINT	<  AFTER >		;PRINT DATE/TIME
	MOVEI	A,101
	MOVSI	C,245201		;FORMAT: FRI 10/8/76 15:38
	ODTIM
	PUSHJ	P,CRLF			;NEW LINE

.LIST3:	PUSHJ	P,CRLF
	JRST	PROMPT			;NOW GO BACK FOR NEXT COMMAND

	>		;END OF SBMTSW CONDITIONAL


IFN SBMTSW,<
;The following is the LIST command for SUBMIT jobs

.LIST:	NOISEM	<CURRENT SUBMIT JOB>
	PUSHJ	P,CCRLF
	PUSHJ	P,CRLF			;SET UP NEW LINE

	SKIPE	QENT+CTLFIL		;ANY CTL FILE YET?
	JRST	.LTCTL
	PPRINT	<  No CTL file input>	;NO, SAY SO
	JRST	.LSLOG
.LTCTL:	PPRINT	<  CTL file: >		;YES, PRINT IT
	HRROI	A,QENT+CTLFIL
	PSOUT

.LSLOG:	PUSHJ	P,CRLF			;NEW LINE
	SKIPE	QENT+LOGFIL		;ANY LOG FILE?
	JRST	.LTLOG
	SKIPE	QENT+CTLFIL		;NOPE, CAN WE SAY DEFAULT?
	JRST	.LULOG			;YES, DO IT
	PPRINT	<  No LOG file input>	;NO, SAY SO
	JRST	.LSACC
.LTLOG:	PPRINT	<  LOG file: >		;YES, PRINT IT
	HRROI	A,QENT+LOGFIL
	PSOUT
	JRST	.LSACC
.LULOG:	PPRINT	<  Default LOG file: >
	MOVEI	A,"<"			;CONSTRUCT FILE NAME
	PBOUT
	MOVE	A,DEFTBL+3		;POINTER TO DIRECTORY
	PSOUT
	MOVEI	A,">"
	PBOUT
	MOVE	A,DEFTBL+4		;NOW FILE NAME
	PSOUT
	MOVEI	A,"."
	PBOUT
	MOVE	A,DEFTBL+5		;AND THE EXTENSION
	PSOUT
	JRST	.LSACC

.LSACC:	PUSHJ	P,CRLF			;NEW LINE
	SKIPE	B,QENT+USRACT		;ANY ACCOUNT?
	JRST	.LTACC
	PPRINT	<  No ACCOUNT input>	;NOPE
	JRST	.LSAFT
IFE STRACT,<
.LTACC:	PPRINT	<  ACCOUNT # >		;OUTPUT ACCOUNT NUMBER
	MOVEI	A,101
	MOVEI	C,^D10
	NOUT
	JFCL
	>
IFN STRACT,<
.LTACC:	PPRINT	<  ACCOUNT: >		;OUTPUT ACCOUNT STRING
	HRROI	A,QENT+USRACT
	PSOUT
	>

.LSAFT:	PUSHJ	P,CRLF			;NEW LINE
	SKIPN	B,QENT+AFTER		;ANY RUN SPECIFICATION?
	JRST	.LSPRI+1		;NOPE
	TLNE	B,-1			;YES, JOB # SPECIFIED?
	JRST	.LTAFT			;NO
	PPRINT	<  Run AFTER job # >	;YES, PRINT IT
	MOVEI	A,101
	MOVEI	C,^D10
	NOUT
	JFCL
	JRST	.LSPRI

.LTAFT:	PPRINT	<  Run AFTER >		;PRINT START DATE/TIME
	MOVEI	A,101
	MOVSI	C,245201
	ODTIM

.LSPRI:	PUSHJ	P,CRLF			;NEW LINE
	SKIPL	QENT+PRIOR		;LOW PRIORITY?
	 JRST	[PPRINT	<  Run at HIGH priority>
		 JRST	.LSLOD]
	 JRST	[PPRINT	<  Run at LOW priority>
		 JRST	.LSLOD]

.LSLOD:	PUSHJ	P,CRLF			;NEW LINE
	SKIPG	B,QENT+LOADAV		;LOAD AVERAGE THRESHOLD?
	JRST	.LSNOT			;NOPE
	PPRINT	<  Run when LOAD AVE below >
	MOVEI	A,101
	SETZ	C,
	FLOUT
	JFCL
	PUSHJ	P,CRLF			;NEW LINE

.LSNOT:	SKIPE	QENT+NOTFY		;NOTIFY REQUEST?
	JRST	.LTNOT			;YES,
	SKIPE	QENT+MESAG		;NO, HOW ABOUT MESSAGE?
	JRST	.LTMSG			;YES,

	PPRINT	<  NO message/notify at job start & stop>
	JRST	.LSKIL

.LTMSG:	PPRINT	<  MESSAGE at job start & stop>
	JRST	.LSKIL

.LTNOT:	SKIPE	QENT+MESAG		;BOTH NOTIFY AND MESSAGE?
	JRST	.LTNM			;YES,
	PPRINT	<  NOTIFY at job start & stop>
	JRST	.LSKIL

.LTNM:	PPRINT	<  NOTIFY and MESSAGE at job start & stop>

.LSKIL:	PUSHJ	P,CRLF			;NEW LINE
	PPRINT	<  Kill job after: >
	MOVEI	A,101
	MOVE	B,QENT+LOGLNS		;MAX LOG FILE LINES
	MOVEI	C,^D10
	NOUT
	JFCL
	PPRINT	< LOG LINES
               or >
	MOVEI	A,101
	MOVE	B,QENT+RTIME		;MAX CPU TIME
	ADDI	B,^D30000		;ROUND OFF TIME
	IDIVI	B,^D60000
	MOVEI	C,^D10
	NOUT
	JFCL
	PPRINT	< MIN CPU TIME
               or >
	MOVEI	A,101
	MOVE	B,QENT+ETIME		;MAX ELAPSED TIME
	ADDI	B,^D30000		;ROUND OFF TIME
	IDIVI	B,^D60000
	MOVEI	C,^D10
	NOUT
	JFCL
	PPRINT	< MIN ELAPSED TIME>

IFN IMSLOG,<				;IMSSS STYLE LABELING OPTIONS
	PUSHJ	P,CRLF			;NEW LINE
	SKIPGE	D,QENT+LINLAB		;WANT ANY LABELS?
	 JRST	[PPRINT	<  NO labels in log file>	;NO
		 JRST	.LSDON]

	JUMPG	D,.LSSUB		;LABELS, INTRA OR INTER LINE FORMAT?
	PPRINT	<  Label START of each log line>	;INTRA
	JRST	.LSDON

.LSSUB:	TRNE	D,1B18			;INTERLINE - SUBSYS CHANGES ONLY?
	 JRST	[PPRINT	<  Label SUBSYSTEM changes only>	;YES
		 JRST	.LSDON]

	PPRINT	<  Insert log file labels: after SUBSYSTEM changes>
.LSLAB:	HLRZ	B,D			;GET MAX TIME BETWEEN LOG LABELS
	JUMPE	B,.LTLAB		;SPECIFIED?
	PPRINT	<
                       or if >
	MOVEI	A,101
	MOVEI	C,^D10
	NOUT
	JFCL
	PPRINT	< SEC since last log label>
	JRST	.LTLAB

.LTLAB:	HRRZ	B,D			;GET MAX LOG LINES BETWEEN LABELS
	JUMPE	B,.LSDON		;SPECIFIED?
	PPRINT	<
                       or if >
	MOVEI	A,101
	MOVEI	C,^D10
	NOUT
	JFCL
	PPRINT	< LOG LINES since last label>
	JRST	.LSDON

	>	;END OF IMSLOG CONDITIONAL

.LSDON:	PUSHJ	P,CRLF			;NEW LINES
	PUSHJ	P,CRLF
	JRST	PROMPT			;NEXT COMMAND

	>	;END OF SBMTSW CONDITIONAL

;EVERYTHING ON THIS PAGE IS FOR THE SUBMIT PROGRAM


IFN	SBMTSW,<
;ENABLE/DISABLE

.ENABL:	MOVEI	A,400000		;GET OUR CAPS
	RPCAP
	MOVE	C,B			;ALL POSSIBLE
	EPCAP				;TURN THEM ON
	HRL	C,B			;REBUILD CAPS WORD
	MOVEM	C,CAPS			;SAVE IT
	JRST	PROMPT

.DSABL:	MOVEI	A,400000		;US
	RPCAP				;GET OURS
	TRZ	C,-1			;TURN OFF USER CAPS
	HRRM	C,CAPS			;TELL THEY ARE OFF
	EPCAP				;TURN THEM OFF
	JRST	PROMPT



REPEAT	0,<;SPECIFY DIRECT SUBMISSION
.DIREC:		NOISEM	<SUBMISSION TO MASTER QUEUE>
	SETOM	DIRECT			;SET FLAG
	JRST	PROMPT			;GO FOR NEXT COMMAND
	>


;
.PRIO:	NOISEM	<JOB EXECUTION>
	REPEAT 0,<
	MOVE	A,CAPS			;GET CAPABILITIES
	TRNN	A,600000		;IS HE A ENABLED
	ERROR	(<MUST BE WHEEL TO SET PRIORITY - 1% USED>,PROMPT)
	>
	SETZM	QENT+PRIOR		;SET TO RUN WITH NORMAL SCHEDULING
	JRST	PROMPT



;SPECIFY USER ACCOUNT TO USE FOR RUN
	IFE STRACT,<
.ACCOU:	NOISEM	<NUMBER FOR JOB>
	MOVEI	A,ACCHEP		;SET UP FOR HELP MESSAGE
	MOVEM	A,HELPAD
	MOVSI	ZZ,(FIXNUM)		;ACCEPT NUMERIC INPUT
	PUSHJ	P,GETSTR

	MOVEM	B,QENT+USRACT		;SAVE ACCOUNT NUMBER
	JRST	PROMPT			;GO FOR MORE

ACCHEP:	PPRINT	<

ENTER ACCOUNT NUMBER UNDER WHICH TO RUN THIS JOB

>
	POPJ	P,
	>
	IFN	STRACT,<
.ACCOU:	NOISEM	<STRING FOR JOB>
	SETZ	ZZ,			;RETURN ALL INPUT W/O SCANNING
	MOVEI	A,ACCHEP		;SET UP HELP ADDRESS
	MOVEM	A,HELPAD
	MOVEI	A,"0"			;SET UP VALID CHAR RANGE
	MOVEM	A,SCHRNG
	MOVEI	A,"Z"
	MOVEM	A,ECHRNG

	SETZM	QENT+USRACT
	MOVE	A,[XWD QENT+USRACT,QENT+USRACT+1]
	BLT	A,QENT+USRACT+7		;CLEAR DEFAULT ACCOUNT STRING
	MOVE	B,[POINT 7,COMMAN]
	MOVEM	B,PCMD
	MOVE	B,EOCPTR		;SET UP FOR CTLR
	MOVEM	B,PCMD2
	MOVE	B,EOCCH
	CAIN	B,37			;DID HE DO EOL
	JRST	[MOVEI	A,"*"		;YES, GIVE HIM PROMPT
		 PBOUT
		 PBOUT
		 JRST	.+1]

.ACCO1:	PUSHJ	P,CMDRDR			;GET ACCOUNT STRING
	JRST	ACCDEF			;^X FOUND - GET DEFAULT ACCT
	JRST	[MOVEI	A,7		;^A OFF LEFT END - RING BELLS
		 PBOUT
		 JRST	.ACCO1]
	ERROR	(<ILLEGAL FORMAT FOR ACCOUNT STRING>,ACCDEF)
	BUG	<HELP RETURN FROM CMDRDR>
	JRST	ACCDEF			;NULL INPUT - USE DEFAULT
	JFCL				;OK, STRING THERE - IS IT GOOD

.ACCRT:	HRROI	A,QENT+USRACT		;PUT STRING IN PLACE
	MOVE	B,PCMD2
	SETZ	C,
	SOUT

	MOVE	A,QENT+USRDIR		;DIRECTORY NUMBER
	MOVE	B,[440700,,QENT+USRACT]		;ACCOUNT STRING POINTER
IFE TNX131,<
	VACCT				;VERIFY ACCOUNT STRING
>
IFN TNX131,<
	PUSHJ	P,$VACCT
>
	ERROR	(<ILLEGAL ACCOUNT STRING - DEFAULT ASSUMED>,ACCDEF)
	SKIPE	QENT+USRACT		;IS THERE AN ACCOUNT STRING?
	JRST	ACCDE1			;YES
ACCDEF:	MOVE	A,[XWD QENT+USRACT,QENT+USRACT+1]
	BLT	A,QENT+USRACT+7		;CLEAR DEFAULT ACCOUNT STRING
	PUSHJ	P,DEFACT		;GET DEFAULT ACCOUNT STRING
ACCDE1:	JRST	PROMPT			;GO FOR MORE
DEFACT:		;GET DEFAULT ACCOUNT STRING FOR USER
	MOVEI	A,QENT+USRACT		;USER ACCOUNT STRING STORAGE
	MOVE	B,QENT+USRDIR		;GET USER DIRECTORY NUMBER
IFE TNX131,<
	GDACC				;OBTAIN DEFAULT ACCOUNT STRING (133-TENEX)
>
IFN TNX131,<
	PUSHJ	P,$GDACC
>
	TENERR	(<DEFACT: CANNOT GET DEFAULT ACCOUNT STRING>,START)
	POPJ	P,


ACCHEP:	HRROI	A,[ASCIZ /

ENTER ACCOUNT NAME UNDER WHICH TO RUN THIS JOB

/]
	PSOUT
	POPJ	P,			;RETURN TO GET INPUT
	>



; ROUTINE TO PROCESS COMMANDS WITH "NO" QUALIFIER.
.NO:	NOISEM	<>
	MOVEI	A,LIST5			;GET POSSIBLE SUBCOMMANDS
	MOVEM	A,SUBLAD
	JRST	SUBPRM			;READ THE SUBCOMMAND




.NNTMG:	NOISEM	<AT JOB START & STOP>
	SETZM	QENT+MESAG		;SET FOR NO MESSAGES
	SETZM	QENT+NOTFY		;OR NOTIFICATION
	JRST	PROMPT


;	SET FLAG TO SIGNAL THAT USER WISHES TO BE NOTIFIED BY MESSAGES
;	AT THE BEGINING AND END OF A BATCH JOB
.MESS:	NOISEM	<AT JOB START & STOP>
	SETOM	QENT+MESAG
	SETZM	QENT+NOTFY		;CLEAR NOTIFY FLAG
	JRST	PROMPT



;	SET FLAG THAT USER WISHES TO BE NOTIFIED BY NOTIFY MESSAGES
;	AT BEGINIG AND END OF JOB
;
.NOTFY:	NOISEM	<AT JOB START & STOP>
	SETOM	QENT+NOTFY
	SETZM	QENT+MESAG		;CLEAR MESSAGE FLAG
	JRST	PROMPT



;INPUT LOAD AVERAGE BELOW WHICH JOB SHOULD BE RUN
.LOAD:	NOISEM	<AVERAGE THRESHOLD>

	MOVSI	ZZ,(FLTNUM)		;INPUT FLOATING POINT
	MOVEI	A,LDHEP			;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD

	PUSHJ	P,GETSTR		;GO GET AN INPUT STRING

	REPEAT 0,<
	CAMLE	B,[MAXLA]		;SPECIFIED LOWER ONE THAN DEFAULT?
	JRST	[MOVE	A,CAPS		;NO, THEN HE BETTER BE A WHEEL
		 TLNN	A,600000	;CHECK HIM
		 ERROR	(< MUST BE WHEEL TO SET HIGH LA - DEFAULT USED>,PROMPT)
		 JRST	.+1]		;OK, LET HIM DO IT
	>

	CAIG	B,0			;IS IT POSITIVE?
LOAD0:	ERROR	(<INVALID LOAD AVERAGE>,PROMPT)
	MOVEM	B,QENT+LOADAV		;SAVE THRESHOLD
	JRST	PROMPT

LDHEP:	HRROI	A,[ASCIZ /

ENTER FLOATING PT LOAD AVERAGE BELOW WHICH JOB CAN BE STARTED

/]
	PSOUT
	POPJ	P,			;RETURN FOR INPUT


;SET FLAG THAT GIVES A MAXIMUM TIME JOB CAN RUN IN MINUTES
;
;
.ELTIM:	NOISEM	<TIME MAX FOR JOB (MIN)>
	SKIPA
.TIME:	NOISEM	<MAX ELAPSED TIME FOR JOB (MIN)>

	MOVSI	ZZ,(FIXNUM)		;INPUT DECIMAL NUMBER
	MOVEI	A,.ELHEP		;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD

	PUSHJ	P,GETSTR		;GO GET AN INPUT STRING

	CAIG	B,0			;IS IT POSITIVE?
.TIM0:	ERROR	(< INVALID NUMBER>,PROMPT)
	IMULI	B,^D60000
	MOVEM	B,QENT+ETIME
	JRST PROMPT

.ELHEP:	HRROI	A,[ASCIZ /

ENTER ELAPSED TIME CUTOFF FOR JOB IN MINUTES

/]
	PSOUT
	POPJ	P,			;RETURN FOR INPUT



;SET FLAG THAT GIVES A MAXIMUM TIME JOB CAN RUN IN MINUTES
;
;
.CPUT:	NOISEM	<TIME MAX FOR JOB (SEC)>
	SKIPA
.RUNT:	NOISEM	<MAX CPU TIME FOR JOB (SEC)>

	MOVSI	ZZ,(FIXNUM)		;INPUT DECIMAL NUMBER
	MOVEI	A,.RTHEP		;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD

	PUSHJ	P,GETSTR		;GO GET AN INPUT STRING

	CAIG	B,0			;IS IT POSITIVE?
.RUNT0:	ERROR	(< INVALID NUMBER>,PROMPT)
	IMULI	B,^D1000		;CONVERT TO MILLISECS
	MOVEM	B,QENT+RTIME
	JRST PROMPT

.RTHEP:	HRROI	A,[ASCIZ /

ENTER CPU TIME CUTOFF FOR JOB IN SECONDS

/]
	PSOUT
	POPJ	P,			;RETURN FOR INPUT



;SET UP A MAXIMUM LENGTH FOR THE LOG FILE
;
.LENGTH:NOISEM	<MAX FOR LOG FILE>

	MOVSI	ZZ,(FIXNUM)		;INPUT DECIMAL NUMBER
	MOVEI	A,.LEHEP		;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD

	PUSHJ	P,GETSTR		;GO GET AN INPUT STRING

	CAIG	B,0			;IS IT POSITIVE?
.LEN0:	ERROR	(<INVALID LENGTH>,PROMPT)
	MOVEM	B,QENT+LOGLNS
	JRST	PROMPT

.LEHEP:	HRROI	A,[ASCIZ /

ENTER MAXIMUM FOR NUMBER OF OUTPUT LINES TO LOG FILE

/]
	PSOUT
	POPJ	P,			;RETURN FOR INPUT


;  REQUEST TO CHANGE PARAMETERS IN EXISTING JOB
.JBMOD:	NOISEM	<JOB NUMBER>
	PUSHJ	P,GETJBN		;GET JOB NUMBER
	MOVEM	A,DESUB			;SAVE AND SET DESUB FLAG
	PUSH	P,JBBLK			;SAVE USUAL GTJFN TABLE ENTRY
	HRLI	A,(1B2)			;REQUIRE OLD FILE
	MOVEM	A,JBBLK			;SET UP LONG GTJFN TABLE TO
	MOVEI	A,JBBLK			;FIND NEWLY SUBMITTED JOB
	SETZ	B,
	GTJFN
	JRST	.JBMD0			;MUST BE IN THE Q

	POP	P,JBBLK			;RESTORE GTJFN TABLE ENTRY
	PUSH	P,A			;SAVE THE JFN
	MOVE	B,[^D36B5+1B19+1B20]	;OPEN 36 BIT, READ, WRITE
	NOCTLC				;TURN OFF ^C
	OPENF
	JRST	[POP	P,A		;OOPS, BATCON MUST HAVE GOTTEN
		 RLJFN			;THERE BEFORE US. RELEASE JFN
		 JFCL
		 JRST	.JBMD0]		;AND TRY THE Q
	MOVNS	B,DESUB			;FLAG ENTRY TO DELETE AS WELL
	JRST	.JBMD1			;GO READ IT

.JBMD0:	POP	P,JBBLK			;RESTORE GTJFN TABLE ENTRY
	MOVSI	A,(1B2+1B17)		;GET THE Q, OLD
	HRROI	B,QNAME
	GTJFN
	TENERR	(<JOB MOD: CANNOT GTJFN Q>,START)
	PUSH	P,A			;SAVE JFN
	MOVE	B,[^D36B5+1B19]		;OPEN 36 BIT, READ
	NOCTLC				;TURN OFF ^C
	QOPENF
	JFCL
	TENERR	(<JOB MOD: CANNOT OPEN Q FOR READ>,START)

.JBMD1:	MOVE	B,[1,,12]		;FETCH FILE SIZE
	MOVEI	C,SIZE
	GTFDB
	MOVE	D,SIZE			;MUST BE INTEGRAL QESIZE
	IDIVI	D,QESIZE
	CAIE	E,0
	ERROR	(<JOB MOD: Q ENTRY LENGTH ERROR>,START)
	POP	P,A			;RECOVER JFN
	HRRZS	A
	MOVE	B,[POINT 36,FENT]
	MOVN	C,SIZE			;BYTE COUNT
	CAIE	C,0			;IF NON-ZERO
	SIN				;READ THE JOB(S)
	SKIPG	DESUB			;JOB ENTRY OR Q?
	JRST	[MOVE	E,D		;FIND BUFFER TO ZERO JOB ENTRY
		 IMULI	E,QESIZE
		 ADDI	E,FENT
		 SETZM	0(E)		;ZERO THE JOB ENTRY
		 MOVSI	B,0(E)		;BLT POINTER
		 HRRI	B,1(E)
		 BLT	B,QESIZE-1(E)
		 MOVE	B,[POINT 36,0(E)]
		 MOVNI	C,QESIZE
		 SOUT
		 JRST	.+1]
	CLOSF				;NOW CLOSE FILE
	TENERR	(<JOB MOD: CANNOT CLOSE Q>, START)

	OKCTLC				;RESTORE ^C
	JUMPE	D,.JBMD3		;IF NOTHING READ IN, CARRY ON
	MOVE	A,QENT+USRDIR		;CURRENT USER DIR
	MOVM	B,DESUB			;JOB NUMBER SOUGHT
	MOVEI	E,FENT
	SETZM	FOUND			;ADDRESS OF LAST ONE FOUND
.JBMD2:	MOVM	C,BJOBNO(E)		;IS THIS OUR JOB?
	CAMN	B,C			;OR ITS NEGATIVE?
	JRST	[CAME	A,USRDIR(E)	;OK, IS IT THE RIGHT USER?
		 JRST	.JBM30		;NO, DUMP HIM NOW
		 MOVEM	E,FOUND		;YES, SAVE THE POINTER
		 JRST	.+1]
	ADDI	E,QESIZE		;SOME OTHER JOB
	SOJG	D,.JBMD2		;LOOK AT NEXT ONE
	SKIPE	E,FOUND			;ANY HITS?
	JRST	.JBMD5			;YUP, MOVE IT OVER

.JBMD3:	PUSHJ	P,CCRLF			;JOB NOT IN QUEUE
	PPRINT	<
  THAT JOB NUMBER IS NOT IN THE QUEUE

>
	JRST	.JBMD4

.JBM30: PUSHJ	P,CCRLF			;NO GO, WIPE OUT
	PPRINT	<
  THAT JOB NOT UNDER YOUR NAME - CAN'T MODIFY IT!

>

.JBMD4:	SETZM	DESUB			;CLEAR OUR TRACKS AND
	JRST	PROMPT			;TRY ANOTHER COMMAND

.JBMD5:	MOVSI	A,0(E)			;THIS IS IT.  MOVE IT TO THE
	HRRI	A,QENT			;REGULAR WORK SPACE
	BLT	A,QENT+QESIZE-1
	SETZM	QENT+STRTED		;CLEAR OUT POSSIBLE FLAGS
	SETZM	QENT+JOBSTT
	SETZM	QENT+RESTRT
;
;  Fix job number sign (+ = regular job, - = change existing job).
;  Following table gives resultant sign as function of present sign and
;  whether job was fetched from Q or fresh job file:
;
;		   Current Job #
;		    (+)   (-)
;    D
;    e        Q(+)   -	   -
;    s
;    u Job File(-)   +	   -
;    b

	SKIPL	QENT+BJOBNO		;JOB # ALREADY NEGATIVE?
	SKIPG	DESUB			;POS:  RETRIEVED FROM Q?
	CAIA				;LEAVE IT AS IS
	MOVNS	A,QENT+BJOBNO		;MAKE IT NEGATIVE
	MOVMS	A,DESUB
	JRST	PROMPT			;AND TAKE OFF TO LET HIM CHANGE
					;THINGS



;	SET DE-SUBMIT FLAG JOB
;
.DESUB:	NOISEM	<JOB NUMBER>

	PUSHJ	P,GETJBN		;GO GET A GOOD JOB NUMBER
	HRRM	A,DJBBLK		;OK, STORE THE JOB NUMBER
	MOVEM	A,BJOBNO+QENT

	MOVE	A,EOCCH			;HAVE WE DONE AN EOL?
	CAIN	A,37
	JRST	.DESB1			;YES, GO ON
	MOVEI	A,37			;NO, DO ONE
	PBOUT

.DESB1:	CONFRM				;GET CONFIRMATION TO WRITE THE FILE

	MOVEI	A,DJBBLK		;OK, GO DO IT
	SETZ	B,
	GTJFN
	TENERR	(<DESUB: CANNOT GTJFN FOR DESUBMIT FILE>,START)
	MOVEM	A,TJFN
	MOVE	B,[^D36B5+1B20]		;WRITE 36 BITS
	NOCTLC				;TURN OFF ^C
	QOPENF
	JFCL
	TENERR	(<DESUB: CANNOT OPEN DESUBMIT FILE>,START)
	SETOM	DESUB
	JRST	GO3


IFN IMSLOG,<
; FOLLOWING HANDLES LOG FILE LABELLING OPTIONS

.LABEL:	NOISEM	<LOG FILE LINES>
	MOVEI	A,LIST3			;HAVE TO GET QUALIFIER
	MOVEM	A,SUBLAD
	JRST	SUBPRM

.LALWY:	SETZM	QENT+LINLAB		;DO OLD STYLE LABELS ON EACH LINE
	JRST	PROMPT

.LNEVR:	SETOM	QENT+LINLAB		;SUPPRESS ALL LABELLING
	JRST	PROMPT

.LEVRY:	MOVSI	ZZ,(FIXNUM)		;INPUT DECIMAL NUMBER
	MOVEI	A,LEVHEP		;SET UP FOR HELP
	MOVEM	A,HELPAD
	PUSHJ	P,GETSTR		;GO GET NUMERIC STRING

	CAIGE	B,0			;IS IT POSITIVE?
	ERROR	(< NUMBER MUST BE POSITIVE - TRY AGAIN>,.LEVR0)
	MOVEM	B,SUBACA		;SAVE IT FOR LATER
	MOVEI	A,LIST4			;NOW GO FIND OUT IF ITS LINES
	MOVEM	A,SUBLAD		;OR SECONDS
	JRST	SUBPRM

.LEVR0:	MOVEI	A,37
	PBOUT				;ONE MORE CRLF
	MOVEM	A,EOCCH			;FORCE ** PROMPT
	JRST	.LEVRY

LEVHEP:	PPRINT	<

ENTER A DECIMAL NUMBER OF LINES OR SECONDS BETWEEN LOG FILE LABELS
PER THE FOLLOWING SUBCOMMAND.  SUBSYSTEM CHANGES ARE ALSO LABELLED.

>
	POPJ	P,			;RETURN FOR MORE


.LALIN:	NOISEM	<OF OUTPUT>
	MOVE	B,SUBACA		;NOW RECOVER THE COUNT
	CAILE	B,377777		;TOO BIG?
	MOVEI	B,377777		;YES, THEN CLIP IT
	MOVE	C,[1B0+1B18]		;IF HE SAID NO LABELS OR SUBSYS
	TDNE	C,QENT+LINLAB		;ONLY BEFORE, CLEAR IT
	SETZM	QENT+LINLAB		;CLEAR IT
	HRRM	B,QENT+LINLAB		;AND STORE LINE COUNT THRESHOLD
	JRST	PROMPT


.LASEC:	NOISEM	<OF ELAPSED TIME>
	MOVE	B,SUBACA		;RECOVER NUMBER OF SECONDS
	CAILE	B,377777		;TOO BIG?
	MOVEI	B,377777		;YES, THEN CLIP IT
	MOVE	C,[1B0+1B18]		;IF HE SAID NO LABELS OR SUBSYS
	TDNE	C,QENT+LINLAB		;ONLY BEFORE, CLEAR IT
	SETZM	QENT+LINLAB		;CLEAR IT
	HRLM	B,QENT+LINLAB		;AND STORE TIME THRESHOLD
	JRST	PROMPT


.LSUBS:	NOISEM	<CHANGES ONLY>
	MOVEI	B,1B18			;SET SUBSYS ONLY FLAG
	MOVEM	B,QENT+LINLAB
	JRST	PROMPT

	>		;END OF IMSLOG CONDITIONAL

	>		;END OF SBMTSW CONDITIONAL FOR SUBMIT PROGRAM

;EVERYTHING ON THIS PAGE IS FOR THE SUBMIT PROGRAM

IFN	SBMTSW,<
;GET CTL FILE FILENAME
.CTL:	NOISEM	<FILE NAME>
	MOVEI	A,CTLTBL		;LONG CALL
	SETZ	B,			;NO MAIN STRING
	GTJFN
	JRST	.CTLHP			;GO SEE IF HE WANTS HELP
	MOVEM	A,CTLJFN#		;SAVE CTL FILE
	DVCHR				;GET DEVICE CHARACTERISTICS
	HLRZ	A,A			;ONLY DEVICE TYPE
	CAIE	A,600000		;IS IT DISK?
	ERROR	(<CTL file must be on disk>,.CTL1)

	MOVE	A,CTLJFN		;OK, SEE IF WE CAN GET IT
	MOVE	B,[70000,,200000]	;7BIT,INPUT
	QOPENF
	JFCL
	TENERR	(<CTL: ERROR OPENING CTL FILE>,.CTL1)

	HRROI	A,QENT+CTLFIL		;POINT TO CTL FILE LOC
	MOVE	B,CTLJFN		;JFN TO MAKE NAME FROM
	MOVE	C,[011110,,1]		;<DIR>NAME.EXT;VER
	JFNS

IFE LPTLOG, <				;DEFAULT LOG TO SAME-NAME.LOG
	SETZM	LOGNAM
	MOVE	A,[LOGNAM,,LOGNAM]
	BLT	A,LOGNAM+7		;CLEAR FIELD
	HRROI	A,LOGNAM		;POINT TO IT
	MOVSI	C,(1B8)			;NAME ONLY, NO PUNCT
	JFNS
>

	HRRZ	A,CTLJFN		;GET JFN BACK
	CLOSF				;DONE WITH IT
	TENERR	(<CTL: CANNOT CLOSE CTL FILE>,START)

	JRST	PROMPT

.CTL1:	MOVE	A,CTLJFN		;GET THE JFN
	RLJFN				;RELEASE IT
	TENERR	(<CTL: CTL FILE RLJFN FAILED>,START)
	JRST	PROMPT

.CTLHP:	MOVEI	A,101
	BKJFN				;BACK UP 1 CHARACTER
	TENERR	(<CTL: BKJFN ERROR ON PRIMARY INPUT>,START)
	BIN				;GET IT
	CAIE	B,"?"			;WAS IT "?"
	TENERR	(<CTL: GTJFN ERROR ON CTL FILE>,START)	;NO, BAD NEWS
	PPRINT	<

  ENTER CONTROL FILE NAME: >
	JRST	.CTL+1			;GO TRY AGAIN

CTLTBL:	160000,,0		;OLD FILE, SAY [OLD FILE], TTY
	100,,101		;IN/OUT
	0			;DEV
	0			;DIR
	0			;NAME
	-1,,[ASCIZ /CTL/]	;EXT
	0			;PROT
	0			;ACCT
	0			;DESIRED JFN




;SPECIFY LOG FILE

.LOG:	NOISEM	<FILE NAME>
	MOVEI	A,LOGTBL		;LONG CALL
	SETZ	B,			;NO MAIN STRING
	GTJFN				;GET FILE NAME
	JRST	.LOGHP			;GO SEE IF HE WANTS HELP
	MOVEM	A,LOGJFN		;SAVE LOG FILE JFN
	DVCHR				;WHAT ARE THE DEVICE CHARACTERISTICS?
	HLRZ	A,A			;KEEP ONLY THE DEVICE TYPE
	CAIN	A,600000		;IS IT ON DISK?
	JRST	.LOG0			;YES, SEE ABOUT OPENING IT
	CAIE	A,600015		;NO, THEN IS IT NIL: OR
	CAIN	A,600007		;LPT:?
	SKIPA				;YES, RECORD THE NAME AS LOGFIL
	ERROR	(<LOG file must be a disk file, NIL:, or LPT:>,.LOG1)

	HRROI	A,QENT+LOGFIL		;OK, IT'S LPT:, PUT THE NAME IN Q
	MOVE	B,LOGJFN		;SET UP FOR JFNS
	MOVE	C,[100000,,1]		;FORMAT CONTROL
	JFNS
	JRST	.LOG1			;YES, OK NO FURTHER CHECKING

.LOG0:	MOVE	A,LOGJFN
	MOVE	B,[XWD 70000,100000]	;7 BIT, WRITE
	OPENF
	JRST	[CAIE	A,OPNX9		;FILE BUSY
		 TENERR	(<LOG: OPENF ERROR ON LOG FILE>,START)
		 MOVE	A,LOGJFN
		 RLJFN
		 JFCL			;IGNORE ERROR MESSAGE
		 JRST	PROMPT]		;ASSUME THAT BATCON IS USING AND THAT
					;THIS IS A DESUBMIT REQUEST

	HRROI	A,QENT+LOGFIL		;OK, IT CAN BE ACCESSED, WRITE NAME
	MOVE	B,LOGJFN		;SET UP FOR JFNS
	MOVE	C,[011110,,1]		;FORMAT CONTROL
	JFNS

	HRRZ	A,LOGJFN		;RETREIVE LOG FILE JFN
	CLOSF				;CLOSE AND RELEASE JFN
	TENERR	(<LOG: CLOSF ERROR ON LOG FILE>,START)
	JRST	PROMPT

.LOG1:	MOVE	A,LOGJFN		;GET JFN
	RLJFN				;RELEASE IT
	TENERR	(<LOG: LOG FILE RLJFN FAILED>,START)
	JRST	PROMPT

.LOGHP:	MOVEI	A,101
	BKJFN				;BACK UP 1 CHARACTER
	TENERR	(<LOG: BKJFN ERROR ON PRIMARY INPUT>,START)
	BIN				;GET IT
	CAIE	B,"?"			;WAS IT "?"
	TENERR	(<LOG: GTJFN ERROR ON LOG FILE>,START)	;NO, BAD NEWS
	PPRINT	<

  ENTER LOG FILE NAME: >
	JRST	.LOG+1			;GO TRY AGAIN

LOGTBL:	660000,,0		;OUTPUT,SAY [----], REQ CONFIRM
	100,,101		;IN,,OUT
	0			;DEV
	0			;DIR
	-1,,LOGNAM		;NAME
	-1,,[ASCIZ /LOG/]	;EXT
	0			;PROT
	0			;ACCT
	0			;JFN


IFE LPTLOG, <
;MAKES DEFAULT LOGFILE

LOGDEF:	PPRINT	<
  Default LOG file is: >
	MOVEI	A,DEFTBL	;LOONG CALL
	SETZ	B,		;NO MAIN STRING
	GTJFN
	TENERR	(<GTJFN FOR DEFAULT LOG FAILED>,START)
	MOVEM	A,LOGJFN		;SAVE IT

	MOVE	B,[XWD 70000,100000] ;7 BIT WRITE
	QOPENF			;POKE IT TO MAKE IT REAL
	JFCL
	TENERR	(<OPEN FAILED ON DEFAULT LOG FILE>,START)

	HRROI	A,QENT+LOGFIL
	MOVE	B,LOGJFN	;JFN
	MOVE	C,[011110,,1]	;GET EVERYTHING
	JFNS

	MOVE	A,LOGJFN	;GET BACK THE JFN
	CLOSF			;CLOSE AND RELEASE
	TENERR	(<CLOSF OF DEFAULT LOGFILE FAILED>,START)

	HRROI	A,QENT+LOGFIL		;PRINT FILE NAME SO USER KNOWS IT
	PSOUT
	PPRINT	<

>

	POPJ	P,

DEFTBL:	400000,,0		;OUTPUT LOG FILE
	377777,,377777		;NIL:,,NIL:
	0			;DEV
	-1,,JBNAME		;DIR
	-1,,LOGNAM		;NAME
	-1,,[ASCIZ /LOG/]	;EXT
	0			;PROT
	0			;ACCT
	0			;JFN
	>		;END OF LPTLOG CONDITIONAL

	>		;END OF SBMTSW CONDITIONAL FOR SUBMIT PROGRAM
;ROUTINES COMMON TO SUBMIT AND BATCH CONTROL


; THE FOLLOWING HANDLES THE STATUS COMMAND FOR SUBMIT AND BATCTL.
;
;   STATUS (CR)	     = STATUS OF JOBS WITH USRDIR = LOGIN DIR (submit)
;		     = STATUS OF ALL JOBS		     (batctl)
;	   DIR NAME  = STATUS OF JOBS WITH USRDIR = DIR NAME
;	   JOB #     = STATUS OF JOBS WITH BJOBNO = JOB #
;	   ALL	     = STATUS OF ALL JOBS
;	   QUEUE     = STATUS OF ALL JOBS
;	   TRASH     = STATUS OF TRASH QUEUE    (batctl)
;	   BATCON    = STATUS OF BATCON PROGRAM (batctl)

.BSTAT:	NOISEM	<OF>
	MOVE	B,EOCCH			;ALREADY EOL?
	CAIE	B,37
	JRST	.BSTA1			;NO, GET THE SUBCOMMAND

.BSTA0:
IFN	SBMTSW,<
;;;	GJINF				;GET CURRENT CONN DIR
	MOVE	B,QENT+USRDIR		;GET CURRENT LOGIN DIR
	MOVEM	B,QCODE			;SET REG Q AND DIR #
	JRST	STATDO			;NOW PRINT THE RESULTS
	>	;END SBMTSW CONDITIONAL
IFE	SBMTSW,<
	JRST	.STATU			;DO ALL JOBS
	>	;END SBMTSW CONDITIONAL

.BSTA1:	MOVSI	ZZ,(SUBLST+DIRSTR+FIXNUM)	;ALLOW ALL THESE OPTIONS
IFN	SBMTSW,<
	MOVEI	A,LIST6			;SET UP SUBCOMMAND LIST
	>	;END SBMTSW CONDITIONAL

IFE	SBMTSW,<
	MOVEM	A,SUBACA		;SAVE INDEX
	MOVEI	A,LIST3			;ADDRESS OF SUBCOMMAND LIST
	>	;END SBMTSW CONDITIONAL

	MOVEM	A,ALIST
	MOVEI	A,.BSHEP		;AND HELP MESSAGE
	MOVEM	A,HELPAD
	MOVEI	A,"+"			;SET UP INPUT CHAR RANGE
	MOVEM	A,SCHRNG
	MOVEI	A,"Z"
	MOVEM	A,ECHRNG
	MOVE	B,[POINT 7,COMMAN]
	MOVEM	B,PCMD
	MOVE	B,EOCPTR
	MOVEM	B,PCMD2

.BSTA2:	PUSHJ	P,CMDRDR		;FETCH THE INPUT
	JRST	PROMPT			;ABORTED WITH ^X
	JRST	[MOVEI	A,7		;^A OFF END - RING BELLS
		 PBOUT
		 JRST	.BSTA2]
	JRST	PROMPT			;UNRECOGNIZED COMMAND
	BUG	(<HELP RETURN FROM CMDRDR>)
	JRST	.BSTA0			;JUST HIT RETURN
	JFCL				;GOOD WHATEVER IT WAS

	TLNN	C,(SUBLST)		;WAS IT A SUBCOMMAND?
	JRST	.BSTA3			;NO, TRY NEXT KIND
	MOVE	B,1(A)			;YES, GO TO ROUTINE TO HANDLE IT
	JRST	0(B)

.BSTA3:	TLNN	C,(FIXNUM)		;WAS IT A JOB #?
	JRST	.BSTA4			;NO, TRY NEXT KIND
	CAILE	B,0			;YES, WAS IT IN RANGE?
	CAILE	B,NQJBS
	ERROR	(<JOB # OUT OF RANGE>,PROMPT)
	TRO	B,1B18			;FLAG AS JOB #
	MOVEM	B,QCODE			;STORE IT
	PUSHJ	P,CCRLF			;CRLF IF NEEDED
	JRST	STATDO			;AND PRINT CANDIDATES

.BSTA4:	MOVEM	B,QCODE			;DIRECTORY NUMBER HERE
	PUSHJ	P,CCRLF			;CRLF IF NEEDED
	JRST	STATDO			;PRINT CANDIDATES


.BSALL:	NOISEM	<JOBS>			;PRINT ALL JOBS
	PUSHJ	P,CCRLF			;CRLF IF NEEDED
	JRST	.STATU


IFE	SBMTSW,<
.BSTRH:	NOISEM	<QUEUE JOBS>		;PRINT ALL JOBS IN TRASH QUEUE
	PUSHJ	P,CCRLF			;CRLF IF NEEDED
	JRST	.TRASH
	>	;END SBMTSW CONDITIONAL


.BSHEP:	HRROI	A,.BSMSG		;PRINT HELP MESSAGE
	PSOUT
	POPJ	P,			;RETURN

IFN	SBMTSW,<
.BSMSG:	ASCIZ \

SPECIFY QUEUE JOBS TO BE LISTED.  ENTER:
   (CR)  - LOGIN DIRECTORY
   USER NAME
   JOB #
   ALL   - LIST ALL JOBS
   QUEUE - LIST ALL JOBS

\
	>	;END SBMTSW CONDITIONAL

IFE	SBMTSW,<
.BSMSG:	ASCIZ \

SPECIFY STATUS INFORMATION TO BE LISTED.  ENTER:
   (CR)   - LIST ALL JOBS IN Q
   USER NAME
   JOB #
   ALL    - LIST ALL JOBS IN Q
   BATCON - BATCON STATUS TO TTY0
   QUEUE  - LIST ALL JOBS IN Q
   TRASH  - LIST ALL JOBS IN TRASH Q

\
	>	;END SBMTSW CONDITIONAL




.AFTER:	NOISEM	<JOB # OR DATE - TIME>
	SETZ	ZZ,			;JUST GET A RAW STRING
	MOVEI	A,TIMHEP		;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD
	MOVEI	A," "			;SET ACCEPTABLE CHARACTER RANGE
	MOVEM	A,SCHRNG		; " " - "Z"
	MOVEI	A,"Z"
	MOVEM	A,ECHRNG
	MOVE	B,EOCCH
	CAIN	B,37
	JRST	[HRROI	A,[ASCIZ /**/]
		 PSOUT
		 JRST	.+1]

	MOVE	B,[POINT 7,COMMAN]	;SET UP FOR COMMAND PROCESSOR
	MOVEM	B,PCMD
	MOVE	B,EOCPTR		;POST PROMPT FOR CTLR
	MOVEM	B,PCMD2			;SAVE AS CURRENT END OF INPUT
.AFTR0:	PUSHJ	P,CMDRDR		;READ THE COMMAND, RECOGNIZE IT
	JRST	PROMPT			;HE DID ^X
	JRST	[MOVEI	A,7		;HE DID ^A OFF RANGE
		 PBOUT			;RING BELLS
		 JRST	.AFTR0]
	JRST	PROMPT			;HE ENTERED UNRECOGNIZABLE COMMAND
	BUG	(<HELP RETURN FROM CMDRDR>)	;OOPS
	ERROR	(<>,PROMPT)		;HE JUST HIT RETURN
	JFCL				;GOOD COMMAND - GO DO IT

	MOVE	A,PCMD2			;FIRST SEE IF IT IS A JOB NUMBER
	SETZ	C,			;COUNTER
.AFTR1:	ILDB	B,A			;LOOK FOR "." - AFTER LAST ENTRY
	CAIN	B,0			;END OF STRING?
	JRST	.AFTR2			;YES, GO LOOK AT WHAT WE HAVE
	CAIN	B," "			;SKIP BLANKS
	JRST	.AFTR1
	CAIN	B,11			;AND TABS
	JRST	.AFTR1
	CAIE	B,"."			;A DOT?
	JRST	.AFTR4			;NO - INPUT CANNOT BE "."
	AOJA	C,.AFTR1		;YES, BUMP COUNTER AND GO ON

.AFTR2:	CAIE	C,1			;ONLY 1 DOT?
.AFTR3:	ERROR	(<INVALID INPUT>,.AFTXT)	;NOPE - BOMB OUT
	SKIPE	LSTJOB			;ANY PREVIOUS JOB NUMBER?
	JRST	[MOVEI	A,101		;YES, PRINT IT AND STORE IT
		 HRROI	B,[ASCIZ /  (AFTER JOB /]
		 SETZ	C,
		 SOUT
		 MOVE	B,LSTJOB
		 MOVEI	C,^D10		;DECIMAL
		 NOUT
		 ERROR	(<INVALID PREVIOUS JOB NUMBER>,.AFTXT)
		 HRROI	A,[ASCIZ /)
/]
		 PSOUT
		 JRST	.AFTFN]		;GO STORE IT
	ERROR	(<NO PREVIOUS JOB # AVAILABLE>,.AFTXT)

.AFTR4:	MOVE	A,PCMD2			;TRY REAL JOB NUMBER
	MOVEI	C,^D10			;DECIMAL
	NIN
	JRST	.AFTR5			;NOT THIS TIME - TRY DATE
	MOVE	C,EOCPTR		;GET EOCPTR - POINTS TO BLANK AFTER
					;INPUT.  NIN STOPS 1 LONG SO THIS
					;SHOULD AGREE WITH PTR IN AC A IF
					;THIS WAS A JOB NUMBER
	CAME	A,C			;DID WE TAKE THE WHOLE STRING?
	JRST	.AFTR5			;NO - TRY IT AS A DATE
	CAILE	B,0			;OK WE HAVE A JOB #, IS IT IN RANGE?
	CAILE	B,NQJBS			;1 LEQ JOB # LEQ 511
	ERROR	(<JOB NUMBER OUT OF RANGE>,.AFTXT)
	JRST	.AFTFN			;IT'S OK - GO STORE IT

.AFTR5:	MOVE	A,PCMD2			;TRY DATE - POINT TO BEGINNING
	SETZ	B,			;TAKE ANYTHING THAT LOOKS RIGHT
	IDTIM				;GET THE DATE/TIME INFO
	SKIPA				;OOPS WE HAVE TO FAKE IT UP
	JRST	.AFTFN			;HE GAVE US THE WHOLE THING-QUIT
	CAIE	B,DILFX1		;SKIP IF ONLY DATE FORMAT ERROR
.AFTR6:	ERROR	(<INVALID DATE FORMAT>,.AFTXT)
	GTAD				;WHAT TIME IS IT?
	PUSH	P,A			;SAVE INTERNAL TIME
	IBP	EOCPTR			;STEP OVER NULL
	MOVE	A,EOCPTR		;THIS POINTS PAST NULL
	MOVE	B,0(P)			;GET THE TIME
	MOVSI	C,(1B8+1B9+1B17)	;JUST DATE AS SMALL AS WE CAN GET IT
	ODTIM				;MOVE IT IN BEHIND TIME
	MOVEI	B," "			;GET A SPACE
	IDPB	B,A			;AND PUT IT ON THE NULL
	MOVE	C,PCMD2			;POINT TO THE INPUT STRING
.AFTRL:	ILDB	B,C			;ROLL TIME IN
	IDPB	B,A			;AFTER DATE
	CAIE	B,0			;AND QUIT AFTER PUTTING DOWN NULL
	JRST .AFTRL
	MOVE	A,EOCPTR		;POINT TO THE BEGINNING AGAIN
	IDTIM				;CONVERT TIME ANY WAY THAT WORKS
	JRST [	SUB P,[1,,1]		;RESET STACK
		JRST	.AFTR6]		;AND LOSE AFTER ALL THAT WORK
	POP	P,A			;GET BACK TIME-O-DAY
	CAMGE	B,A			;AFTER GT NOW?
	ADD	B,[1,,0]		;NO, THE SAY TOMORROW
.AFTFN:	MOVEM	B,QENT+AFTER		;SAVE TIME TO RUN
.AFTXT:	JRST PROMPT


;HELP ROUTINE FOR TIME ENTRY
TIMHEP:	HRROI	A,[ASCIZ $

 ENTER  A) JOB NUMBER AFTER WHICH THIS JOB CAN BE RUN
	   ("." = LAST JOB ENTERED BY THIS SUBMIT RUN)$]
	PSOUT
	HRROI	A,[ASCIZ $
    OR	B) TIME (HH:MM) WHEN NEXT TO START THE JOB
    OR	C) SPECIFIC DATE AND TIME (MM/DD/YY HH:MM)

$]
	PSOUT
	POPJ	P,			;RETURN TO INPUT




;ROUTINE TO ENTER STARTING TIME FOR TASK BASED ON INCREMENTAL TIME
;FROM NOW
;
;
.RUNIN:	NOISEM	<>
	MOVSI	ZZ,(FIXNUM)		;INPUT DECIMAL NUMBER
	MOVEI	A,.RIHEP		;SET HELP ROUTINE ADDRESS
	MOVEM	A,HELPAD

	PUSHJ	P,GETSTR		;GO GET AN INPUT STRING

	CAIGE	B,0			;IS IT POSITIVE?
.RUNI0:	ERROR	(< INVALID NUMBER>,PROMPT)

	MOVEM	B,SUBACA		;SAVE NUMERICAL VALUE AND
	MOVEI	A,LIST2			;GO GET THE UNITS
	MOVEM	A,SUBLAD
	JRST	SUBPRM

.RIDYS:	MOVE	B,SUBACA		;RECOVER TIME VALUE - IN DAYS
	GTAD				;GET CURRENT TIME
	HLRZ	C,A			;STRIP OUT DAYS PORTION AND
	ADD	C,B			;INCREMENT IT
	HRL	A,C			;RESTORE UPDATED VALUE
	JRST	.RIRET			;GO FINISH THINGS OFF

.RIHRS:	MOVE	B,SUBACA		;RECOVER TIME VALUE - IN HRS
	IMULI	B,^D3600		;CONVERT TO SECONDS
	JRST	.RIDAT			;GO MAKE IT INTO A DATE

.RIMIN:	MOVE	B,SUBACA		;RECOVER TIME VALUE - IN MIN
	IMULI	B,^D60			;CONVERT TO SECONDS
	JRST	.RIDAT			;GO MAKE IT INTO A DATE

.RISEC:	MOVE	B,SUBACA		;RECOVER TIME VALUE - IN SEC

.RIDAT:	GTAD				;GET CURRENT DATE AND TIME
	HRRZ	C,A			;GET TIME PART
	ADD	C,B			;INCREMENT IT
	IDIVI	C,^D24*^D3600		;SPLIT OUT WHOLE DAYS AND PARTS
	HLRZ	A,A			;AUGMENT DAY PART OF CURRENT DATE
	ADD	A,C
	HRLZ	A,A			;RESTORE IT TO INTERNAL FORMAT
	HRR	A,D			;PATCH IN TIME SINCE MIDNIGHT

.RIRET:	MOVEM	A,QENT+AFTER		;SET AS STARTUP TIME
	JRST PROMPT

.RIHEP:	HRROI	A,[ASCIZ /

ENTER INTEGER TIME FROM NOW (IN DAYS, HRS, MIN, OR SEC)
WHEN JOB CAN BE RUN

/]
	PSOUT
	POPJ	P,			;RETURN FOR INPUT




;EXIT ROUTINE
.EXIT:	MOVEI	A,400000		;CLOSE ALL FILES (TTY:)
	CLZFF
	HALTF
	JRST	START			;IF HE TYPES CONTINUE


;
;	STATUS OF BATCH SYSTEM
;
;   QCODE CONTROLS THE PRINTING OF INFORMATION:
;
;	QCODE =  LH,,RH
;
;	   LH = 0 => PRINT FROM THE REGULAR QUEUE
;		-1 => PRINT FROM THE TRASH QUEUE
;
;	   RH = 0	   => PRINT ALL ENTRIES
;		#	   => PRINT ALL ENTRIES WITH THIS DIR #
;		400000 + # => PRINT ALL ENTRIES WITH THIS JOB #
;
IFE SBMTSW,<
.TRASH:	MOVSI	A,-1
	MOVEM	A,QCODE			;DO THE TRASH QUEUE
	JRST	STATDO
	>
.STATU:	SETZM	QCODE
	JRST	STATDO

STATDO:	MOVE	A,[SIXBIT /JOBACT/]
	SYSGT			;GET INDEX FOR JOBACT TABLE (LAST CPU USED)
	JUMPE	B,NOTWHL	;NO SUCH TABLE
	HRR	A,B		;ISOLATE INDEX
	HRLI	A,2		;BATCH PROCESSOR JOB NUMBER
	GETAB			;GET LAST ACTIVITY
	JRST	NOTWHL		;PROBLEM
	MOVE	C,A		;SAVE LAST ACTIVITY
	TIME			;GET ELAPSED TIME SINCE SYSTEM START UP
	SUB	C,A		;GET DIFFERENCE FORM LAST ACTIVITY
	CAIG	C,1500		;.GT. THAN 1.5 MINUTES
	JRST	NOTWHL		;NO
	HLRZ	A,CAPS		;GET CAPABILITIES
	TRNN	A,600000
	JRST	NOTWHL		;NOT WHEEL
	PPRINT	<*** BATCH PROCESSOR STOPPED ***>  ;YES
NOTWHL:
	MOVSI	A,1			;FLAGS FOR GTJFN
	HRROI	B,QNAME			;NAME OF BATCH QUEUE
IFE SBMTSW,<
	SKIPGE	QCODE			;OR DO YOU WANT THE TRASH?
	HRROI	B,TQNAME		;YES, GET IT
	>

	GTJFN
	TENERR	(<STATUS: CANNOT GTJFN QUEUE>,START)
	MOVEM	A,QJFN			;SAVE QJFN
	HRRZS	A
	MOVE	B,[1,,12]		;FDBSIZ
	MOVEI	C,SIZE
	GTFDB				;GET FILE LENGTH IN BYTES (36)
	MOVE	A,SIZE			;BE SURE Q CONTAINS AN INTEGRAL
	IDIVI	A,QESIZE		;NUMBER OF ENTRIES
	CAIE	B,0
	ERROR	(<Q ENTRY LENGTH ERROR>,START)
NTWHL1:	HRRZ	A,QJFN			;QUEUE JFN
	MOVE	B,[44B5!1B19]		;36 BIT, READ
	NOCTLC				;TURN OFF ^C
	QOPENF				;OPEN QUEUE FILE
	JFCL
	TENERR	(<STATUS: CANNOT OPEN Q FILE FOR READ>,START)  
	MOVE	A,QJFN
	MOVE	B,[POINT 36,FENT]
	MOVN	C,SIZE
	SIN				;INPUT DATA FROM QUEUE
	HRRZ	A,QJFN			;QUEUE JFN
	CLOSF				;CLOSE QUEUE JFN
	TENERR	(<NTWHL: CAN'T CLOSE QUEUE JFN>,START)
	OKCTLC				;RESTORE ^C

;  Now fetch the JOBDIR table and the SYSTAT load averages so we can
;  tell why a job isn't running.

	MOVE	A,[SIXBIT /JOBDIR/]	;SET UP FOR JOBDIR GTBLT
	SYSGT
	CAIN	B,0			;BAD NEWS?
	ERROR	(<STATUS: JOBDIR TABLE ERROR>,PROMPT)	;YES

	HRRO	A,B			;FROM START OF TABLE
	HLREM	B,NJOBTB		;MAKE SIZE POS AND SAVE IT
	MOVNS	B,NJOBTB
	HRLZS	B
	HRRI	B,JBDRTB		;STORE IT HERE
	GTBLT
	TENERR	(<STATUS: GTBLT ERROR ON JOBDIR>,PROMPT)	;OOPS

	MOVE	A,[SIXBIT /SYSTAT/]	;NOW FIND THE MAX LD AVE
	SYSGT
	CAIN	B,0			;BAD NEWS?
	ERROR	(<STATUS: SYSTAT TABLE ERROR>,PROMPT)	;YES

	MOVSI	A,14			;START AT SYSTAT+14
	HRR	A,B
	MOVSI	B,3			;GET 1, 5, AND 15 MIN LA'S
	HRRI	B,C			;INTO AC'S 3, 4, AND 5
	GTBLT
	TENERR	(<STATUS: GTBLT ERROR ON SYSTAT>,PROMPT)	;OOPS

	CAMGE	C,D			;PICK MAX VALUE
	 MOVE	C,D			;5 MIN .GT. 1 MIN - USE IT
	CAMGE	C,E
	 MOVE	C,E			;15 MIN BIGGEST - USE IT
	MOVEM	C,MXLDAV		;SAVE IT FOR LATER

IFE FDBSEQ,<
; The following code attempts to get access to the JOB SEQ file and
; reads the current status of the contents.

	SKIPGE	QCODE			;IF TRASH Q DON'T BOTHER
	JRST	NTWHL3
	MOVSI	A,(1B2+1B17)		;NO, TRY FOR OLD VERSION OF
	HRROI	B,SEQLOK		;THE JOB-SEQUENCE FILE
	GTJFN
	TENERR	(<GTJFN ERROR ON JOB SEQ FILE>,BADTRY)
	MOVEM	A,SEQJFN		;SAVE THE JFN
	MOVE	B,[44B5+1B19+1B20+1B25]	;OPEN IT 36 BIT, READ, WRITE, THAWED
	OPENF
	TENERR	(<ERROR OPENING JOB SEQ FILE>,BADOPN)

	HRLZ	A,SEQJFN		;GET PAGE 0 OF THE FILE
	MOVE	B,[400000,,CTLPAG+1]	;INTO SEQPAG OF THIS FILE
	MOVSI	C,(1B2+1B3)		;READ AND WRITE ACCESS
	PMAP

	MOVEI	C,^D20			;WAIT 20 SECONDS
TRYMOR:	NOCTLC				;TURN OFF ^C FOR A BIT WHILE WE TRY
	AOSN	TMPLOK			;CAN WE HAVE IT?
	JRST	GOTLCK			;YUP, SO CARRY ON
	OKCTLC				;TURN ^C BACK ON
	TSTCTC				;DID WE GET ANY?
	CAIL	C,^D20			;ALREADY WAITED ONCE?
	JRST	[PPRINT	<[JOB SEQ FILE BUSY ->
		 JRST	TRYWAT]
	MOVEI	A,"-"			;YES, JUST ADD A -
	PBOUT
TRYWAT:	MOVEI	A,^D1000		;NOT NOW, WAIT A SEC
	DISMS
	SOJGE	C,TRYMOR		;NOW TRY IT AGAIN

	PPRINT	< TIME-OUT TRYING FOR JOB SEQ LOCK>
FALLOK:	SETO	A,			;UNMAP THAT PAGE THEN
	MOVE	B,[400000,,CTLPAG+1]
	SETZ	C,
	PMAP
	MOVE	A,SEQJFN		;CLOSE THE FILE
	CLOSF
	TENERR	(<CLOSF ERROR ON JOB SEQ FILE>,BADTRY)

BADTRY:	SETOM	JBSQOK			;FLAG AS TROUBLE
	JRST	NTWHL3

; OPENF failure - probably someone opened it frozen ... make a new one
BADOPN:	MOVE	A,SEQJFN		;RELEASE OLD JFN
	RLJFN
	BUG	(<RLJFN ERROR ON JOB LOCK FILE>,BADTRY)
	JRST	BADTRY

; Here we got the lock, check the file parameters and check out the
; JOB SEQ file version of the world against our bit table and correct
; any differences - we are right of course.

GOTLCK:	CAIE	C,^D20			;WAS IT BUSY?
	JRST	[PPRINT	< GO
>
		 JRST	.+1]
	MOVE	A,SEQJFN		;MAKE SURE THE BYTE SIZE IS RIGHT
	MOVE	B,[1,,11]		;ADDRESS BYTE SIZE WORD
	MOVEI	C,C			;STICK IT IN AC C
	GTFDB
	LDB	B,[POINT 6,C,11]	;STRIP BYTE SIZE BITS
	CAIN	B,^D36			;BETTER BE 36 BIT
	JRST	BTSZOK			;OK
	SETOM	TMPLOK			;OOPS, FREE THE LOCK
	OKCTLC				;RESTORE ^C
	TSTCTC				;SEE IF WE GOT ANY
	PPRINT	<WRONG BYTE SIZE IN JOB SEQ FILE>
	SETOM	JBSQOK			;SET BAD FLAG
	JRST	NTWHL2

BTSZOK:	MOVE	A,SEQJFN		;JFN AGAIN
	MOVE	B,[1,,12]		;ADDRESS BYTE COUNT WORD
	MOVEI	C,C			;INTO AC C
	GTFDB
	CAIN	C,2+NJBWRD		;BETTER INCLUDE LOCK, MXJBNO, AND JBBITS
	JRST	BTCTOK			;OK
	SETOM	TMPLOK			;OOPS, FREE THE LOCK
	OKCTLC				;RESTORE ^C
	TSTCTC				;SEE IF WE GOT ANY
	PPRINT	<WRONG BYTE COUNT IN JOB SEQ FILE>
	SETOM	JBSQOK			;SET BAD FLAG
	JRST	NTWHL2

BTCTOK:	MOVE	A,[TMPLOK,,JBSQLK]
	BLT	A,JBSQLK+NJBWRD+1	;MOVE ALL NJBWRD+2 ENTRIES
	SETOM	TMPLOK			;CLEAR THE LOCK
	SETZM	JBSQOK			;INDICATE SUCCESS
	OKCTLC				;RESTORE ^C
	TSTCTC				;SEE IF WE GOT ANY

NTWHL2:	SETO	A,			;UNMAP THAT PAGE THEN
	MOVE	B,[400000,,CTLPAG+1]
	SETZ	C,
	PMAP
	MOVE	A,SEQJFN		;CLOSE THE FILE
	CLOSF
	TENERR	(<CLOSF ERROR ON JOB SEQ FILE>,BADTRY)

NTWHL3:	SETZM	JBBITS			;CLEAR BIT TABLE
	MOVE	A,[JBBITS,,JBBITS+1]
	BLT	A,JBBITS+NJBWRD-1

	>		;END OF FDBSEQ CONDITIONAL

;  The following code loops through all the jobs in the queue and if
;  visible to the user, prints out the appropriate information.

	MOVE	6,SIZE
	JUMPE	6,FILES
	IDIVI	6,QESIZE
	MOVEM	6,COUNT			;SAVE TOTAL ENTRIES
	MOVEI	E,FENT

QLOOP:	
IFE SEEJBS,<
	MOVE	A,USRDIR(E)		;CAN THIS USER SEE THIS ENTRY?
	CAME	A,QENT+USRDIR
	JRST	[MOVE	A,CAPS		;NOT UNLESS HE IS ENABLED
		 TRNN	A,1B18+1B19
		 JRST	QLPND0		;TOUGH LUCK
		 JRST	.+1]		;OK, LET HIM GO
	>	;END SEEJBS CONDITIONAL

	SKIPG	A,QCODE			;SEE THEM ALL?
	JRST	QLOOPP			;YES
	TRZE	A,1B18			;NO, IS THIS A DIR # OR JOB #
	JRST	[CAME	A,BJOBNO(E)	;JOB #, IS IT RIGHT?
		 JRST	QLPND0		;NO, LOOK AT THE NEXT ONE
		 JRST	QLOOPP]		;YES, PRINT IT
	JRST	[CAME	A,USRDIR(E)	;DIR # - IS IT RIGHT?
		 JRST	QLPND0		;NO, LOOK AT THE NEXT ONE
		 JRST	QLOOPP]		;GOOD, PRINT IT

QLOOPP:	SKIPE	FFLAG			;ANY OUTPUT YET?
	JRST	QLPNPR			;YES, SKIP PRELIMINARIES
IFN	STRACT,<
	PPRINT	<
JOB, USER, CTL FILE, LOG FILE, MESSAGE, NOTIFY, ACCOUNT STRING
>
	>		;END STRACT CONDITIONAL
IFE	STRACT,<
	PPRINT	<
JOB, USER, CTL FILE, LOG FILE, MESSAGE, NOTIFY, ACCOUNT NUMBER
>
	>		;END STRACT CONDITIONAL

	MOVE	B,CAPS		;GET CAPABILITIES
IFE	SBMTSW,<
	TLNN	B,600000	;CONTROL - IS HE A WHEEL?
	>
IFN	SBMTSW,<
	TRNN	B,600000	;SUBMIT - IS HE ENABLED?
	>
	JRST	QLPNPR		;NO - WRONG PRIVILEGES

IFE	IMSLOG,<
	PPRINT	<   BATJB(FRK), RESTRT, JOB %, LD AV, LINES, ELPSED LIM, CPU LIM, ENTRED
>
	>	;END IMSLOG CONDITIONAL

IFN	IMSLOG,<
	PPRINT	<   BATJB(FRK), RESTRT, JOB %, LD AV, LINES, ELPSED LIM, CPU LIM, ENTRED, LABEL
>
	>	;END IMSLOG CONDITIONAL

QLPNPR:	PPRINT	<
>
	SETOM	FFLAG
	MOVM	B,BJOBNO(E)		;ENTER BIT TABLE ENTRY FOR THIS JOB
	CAILE	B,0			;IF IT IS IN THE RIGHT RANGE
	CAILE	B,NQJBS
	JRST	[PPRINT	<*** THE FOLLOWING JOB NUMBER IS OUT OF RANGE
>
		 JRST	QLOOP0]
IFE SBMTSW,<
	IDIVI	B,^D36			;COMPUTE BIT TABLE ADDRESS
	MOVN	C,C
	MOVSI	D,(1B0)
	LSH	D,0(C)
	IORM	D,JBBITS(B)		;TURN ON THE BIT
	>		;END OF SBMTSW CONDITIONAL

QLOOP0:	MOVEI	A,101
	MOVE	B,BJOBNO(E)
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	MOVEI	B,","
	BOUT
	MOVEI	A,101
	SKIPLE	B,USRDIR(E)		;VALID DIRECTORY NUMBER
	JRST	OUTDIR			;YES, GO OUTPUT DIRECTORY NAME
	HRROI	B,[ASCIZ /DESUBMITTED/]
	SETZ	C,
	SOUT				;OUTPUT DESUBMITTED INSTEAD OF NAME
	JRST	DSBDIR			;CONTINUE
OUTDIR:	DIRST
	JFCL
DSBDIR:	MOVEI	B,","
	BOUT
	MOVEI	B,CTLFIL(E)
	HRLI	B,440700
	SETZ	C,
	SOUT
	MOVEI	B,","
	BOUT
	MOVEI	B,LOGFIL(E)
	HRLI	B,440700
	SETZ	C,
	SOUT

	SKIPN	MESAG(E)
	JRST	NMES
	HRROI	B,[ASCIZ /,MESSAGE/]
	SOUT
NMES:	SKIPN	NOTFY(E)
	JRST	NNOT
	HRROI	B,[ASCIZ /,NOTIFY/]
	SOUT
NNOT:	SKIPN	MESAG(E)		;IF NEITHER MSG OR NOTIFY
	SKIPE	NOTFY(E)
	JRST	PRTACT
	HRROI	B,[ASCIZ \,NO MSG/NTFY\]
	SOUT

PRTACT:	MOVEI	B,","
	BOUT
	IFN	STRACT,<
	HRLZI	2,440700
	HRRI	2,USRACT(E)
	SETZ	3,
	SOUT
	>
	IFE	STRACT,<
	MOVE	2,USRACT(E)
	MOVE	3,[6,,^D10]	;WIDTH,DECIMAL
	NOUT
	JFCL
	>
	FSOUT	<
>,[101]

	MOVE	A,CAPS		;GET CAPABILITIES
IFE	SBMTSW,<
	TLNN	A,600000	;CONTROL - IS HE A WHEEL?
	>
IFN	SBMTSW,<
	TRNN	A,600000	;SUBMIT - IS HE ENABLED?
	>

	JRST	QLPENC		;NO - WRONG PRIVILEGES
	FSOUT	<   >,[101]

	HRRZ	B,STRTED(E)
	MOVEI	C,^D10			;DECIMAL OUTPUT
	NOUT
	TENERR	(<>,PROMPT)		;ERROR ROUTINE

	SKIPE	B,STRTED(E)		;IF JOB/FORK NEQ 0, ADD FORK INDEX
	JRST	[MOVEI	B,"("
		 BOUT
		 HLRZ	B,STRTED(E)
		 TRZ	B,1B18			;LEAVE ONLY THE INDEX
		 MOVEI	C,10			;OCTAL OUTPUT
		 NOUT
	TENERR	(<>,PROMPT)		;ERROR ROUTINE
		 MOVEI	B,")"
		 BOUT
		 JRST	.+1]
	FSOUT	<, >,[101]
	MOVE	B,RESTRT(E)
	MOVEI	C,10			;OCTAL OUTPUT
	NOUT
	TENERR	(<>,PROMPT)		;ERROR ROUTINE
	HRROI	B,[ASCIZ /, LOW, /]
	SKIPL	PRIOR(E)
	HRROI	B,[ASCIZ /, HIGH, /]
	SETZ	C,
	SOUT				;PRINT PRIORITY LEVEL
	MOVE	B,LOADAV(E)		;LOAD AVERAGE THRESHOLD
	SETZ	C,
	FLOUT
	TENERR	(<>,PROMPT)		;ERROR ROUTINE
	FSOUT	<, >,[101]
	MOVE	B,LOGLNS(E)
	MOVEI	C,^D10			;DECIMAL OUTPUT
	NOUT
	TENERR	(<>,PROMPT)		;ERROR ROUTINE
	FSOUT	< LIN, >,[101]
	MOVE	B,ETIME(E)
	IDIVI	B,^D60000		;CONVERT ELAPSED LIM TO MIN
	MOVEI	C,^D10			;DECIMAL OUTPUT
	NOUT
	TENERR	(<>,PROMPT)		;ERROR ROUTINE
	FSOUT	< MIN, >,[101]
	MOVE	B,RTIME(E)
	IDIVI	B,^D1000		;CONVERT CPU LIM TO SEC
	MOVEI	C,^D10			;DECIMAL OUTPUT
	NOUT
	TENERR	(<>,PROMPT)		;ERROR ROUTINE
	FSOUT	< SEC, >,[101]
	MOVE	B,ENTERD(E)
	MOVE	C,[XWD 245201,0]
	ODTIM

IFN	IMSLOG,<
	SKIPN	B,LINLAB(E)		;OLD STYLE LABELS?
	JRST	[PPRINT	(<, OLD>)	;YES
		 JRST	QLPENB]
	CAIG	B,0			;ANY LABELS AT ALL?
	JRST	[PPRINT	(<, NONE>)	;NO LABELS
		 JRST	QLPENB]
	TRZE	B,1B18			;SUBSYS CHANGES?
	JRST	[PPRINT	(<, SUBSYS>)	;YES
		 JRST	.+1]
	HRRZ	B,B			;ONLY THE LINE COUNT
	CAIE	B,0
	JRST	[PPRINT	(<, >)
		 MOVEI	A,101
		 MOVEI	C,^D10
		 NOUT
		 TENERR	(<>,PROMPT)
		 PPRINT	(< LIN>)
		 JRST	.+1]
	HLRZ	B,LINLAB(E)		;GET TIME INTERVAL
	CAIE	B,0
	JRST	[PPRINT	(<, >)
		 MOVEI	A,101
		 MOVEI	C,^D10
		 NOUT
		 TENERR	(<>,PROMPT)
		 PPRINT	(< SEC>)
		 JRST	.+1]

QLPENB:
	>	;END IMSLOG CONDITIONAL

	FSOUT	<
>,[101]

QLPENC:	SKIPN	STRTED(E)		;IS IT RUNNING?
	JRST	QLPEND			;NO - GO ON
	FSOUT	<  (RUNNING)
>,[101]					;YES - PRINT MSG
	JRST	QLPND0			;LOOK AT THE NEXT ONE

QLPEND:	MOVE	B,[XWD 377777,777777]
	CAME	B,JOBSTT(E)		;IS THE JOB DEFERRED?
	JRST	QLPENE			;NO, IS THERE A START TRIGGER?
	FSOUT	<  (EXECUTION DEFERRED INDEFINITELY)
>,[101]
	JRST	QLPND0			;GET THE NEXT ONE
QLPENE:	SKIPN	B,AFTER(E)		;ANYTHING IN AFTER FIELD?
	JRST	QLPENH			;NO - GO ON
	TLNE	B,-1			;JOB NUMBER ONLY?
	JRST	QLPENF			;NO - MUST BE DATE

	IDIVI	B,^D36			;COMPUTE BIT INDEX FOR PRECURSOR
	MOVNS	C			;JOB
	MOVSI	D,(1B0)
	LSH	D,0(C)
	TDNN	D,FJBBIT(B)		;PRECURSOR STILL THERE?
	 JRST	QLPENH			;NO, MUST BE ANOTHER REASON

	FSOUT	<  (RUN AFTER JOB NUMBER >,[101]
	HRRZ	B,AFTER(E)		;ADD JOB NUMBER
	MOVEI	C,^D10
	NOUT
	JFCL
	JRST	QLPENG			;FINISH STRING

QLPENF:	GTAD				;CURRENT TIME
	CAML	A,AFTER(E)		;HAVE WE TRIPPED TIME TRIGGER?
	JRST	QLPENH			;YES, FORGET PRINT OUT
	FSOUT	<  (RUN AFTER >,[101]
	MOVE	B,AFTER(E)		;ADD DATE AND TIME
	MOVE	C,[XWD 245201,0]
	ODTIM
QLPENG:	FSOUT	<)
>,[101]
	JRST	QLPND0			;NOW LOOK AT THE NEXT ONE

;  Here the job has not been started.  Check to see if the load average
;  is too high or if it is prime time, the guy may have too many other
;  jobs running.  If none of these, then he should be scheduled soon.

QLPENH:	SETZ	ZZ,			;CLEAR HOLD REASON FLAG
	MOVE	A,MXLDAV		;IS LA CAUSING HOLD?
	CAMGE	A,LOADAV(E)
	 JRST	QLPENI			;NO, TRY JOB COUNT
	TLO	ZZ,(1B0)		;YES, FLAG THIS REASON
	FSOUT	(<  (PENDING: LD AVE NOW >, [101])
	HRROI	A,COMMAN		;BUFFER NUMBER IN COMMAN
	MOVE	B,MXLDAV
	MOVE	C,[5,,2]		;OUTPUT F8.2 FORMAT
	PUSHJ	P,FLFMT			;GO DO IT W/O EXTRA BLANKS
	FSOUT	(<, JOB THRESHOLD IS >, [101])
	HRROI	A,COMMAN		;SAME THRASH FOR USER THRESHOLD
	MOVE	B,LOADAV(E)
	MOVE	C,[5,,2]		;OUTPUT F8.2 FORMAT
	PUSHJ	P,FLFMT			;GO DO IT W/O EXTRA BLANKS

QLPENI:	GTAD				;CHECK FOR PRIME TIME
	MOVE	B,A			;GET SEC SINCE MIDNIGHT
	SETZ	D,
	ODCNV
	HRRZS	D
	CAIL	D,STPRM			;PRIME TIME?
	CAILE	D,ENDPRM
	 JRST	QLPENJ			;NO, MOVE ON

	MOVE	A,NJOBTB		;YES, SEE HOW MANY HE HAS NOW
	SETZ	B,
QLPEI0:	SOJL	A,QLPEI1
	HRRZ	C,JBDRTB(A)
	CAMN	C,USRDIR(E)
	AOJ	B,
	JRST	QLPEI0			;LOOK AT THEM ALL

QLPEI1:	CAIGE	B,MAXJBS		;TOO MANY?
	 JRST	QLPENJ			;NO, MOVE ON
	PUSH	P,B			;YES SAVE COUNT FOR MSG
	CAIN	ZZ,0			;FMT MSG FROM PREV OUTPUT
	 JRST	[FSOUT	(<  (PENDING: >, [101])
		 JRST	.+2]
	 JRST	[FSOUT	(<
            >, [101])
		 JRST	.+1]

	TLO	ZZ,(1B1)		;FLAG THIS REASON
	HRROI	B,[ASCIZ /PRIME TIME - /]
	SOUT
	POP	P,B
	MOVEI	C,^D10
	NOUT
	JFCL
	FSOUT	(< JOBS LOGGED IN, ONLY >, [101])
	MOVEI	B,MAXJBS
	MOVEI	C,^D10
	NOUT
	JFCL
	FSOUT	(< ALLOWED>, [101])

QLPENJ:	CAIE	ZZ,0			;ANY REASONS OUTPUT?
	 JRST	QLPENG			;YES, FINISH MESSAGE

	FSOUT	(<  (SHOULD RUN SHORTLY)
>, [101])

QLPND0:	ADDI	E,QESIZE
	SOJG	6,QLOOP

	SKIPE	FFLAG			;ANY OUTPUT?
	JRST	QLPND1			;YES, ADD REST OF OUTPUT
	SKIPG	B,QCODE			;SPECIFIC JOBS REQUESTED?
	JRST	[FSOUT	(<
NO VIEWABLE JOBS IN QUEUE
>,[101])
		 JRST	QLPND1]
	TRZE	B,1B18			;JOB # OR DIR #?
	JRST	[FSOUT	(<
JOB >,[101])
		 MOVE	B,QCODE		;RECOVER JOB NUMBER W/O FLAG
		 TRZ	B,1B18
		 MOVEI	C,^D10
		 NOUT
		 TENERR	(<>,PROMPT)
		 FSOUT	(< NOT IN QUEUE
>,[101])
		 JRST	QLPND1]
	JRST	[HRROI	A,[ASCIZ /
</]
		 PSOUT
		 MOVEI	A,101
		 DIRST
		 TENERR	(<>,PROMPT)
		 HRROI	A,[ASCIZ /> HAS NO JOBS IN QUEUE
/]
		 PSOUT
		 JRST	QLPND1]

QLPND1:	PPRINT	<

   >
	MOVEI	A,101			;NOW PRINT TOTAL JOB COUNT
	MOVE	B,COUNT
	MOVEI	C,^D10
	NOUT
	JFCL
	PPRINT	< JOB(S) IN QUEUE
>
	JRST	FILES1


;  The following is a routine to output a compressed format floating
;  point number.  FLOUT does not have a way of suppressing leading
;  blanks without putting them at the end - this routine finds the
;  first such blank and nulls it.
;
;  On entry:
;
;	AC 1 = string pointer to core buffer for number string
;	   2 = floating point number
;	   3 = # integer digits ,, # fraction digits
;
;  Output goes to primary output JFN

FLFMT:	PUSH	P,A			;SAVE AC A-D
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D

	AND	C,[77,,77]		;ONLY 6 BIT SIZES
	HLRZ	D,C			;ISOLATE INTEGER SIZE
	LSH	D,6			;POSITION IT
	HRRZS	C			;ISOLATE FRACTION SIZE
	ADD	D,C			;TACK IT ON
	LSH	D,6			;FINAL POSITION
	MOVSI	C,(3B3+1B4+1B6+1B11)	;FIX UP FORMAT WORD
	HRR	C,D			;TACK IN SIZES
	FLOUT
	JFCL

	MOVE	A,-3(P)			;SCAN FOR FIRST " " OR 0
	TLC	A,-1			;MAKE SURE PROPER BYTE PTR
	TLCN	A,-1
	HRLI	A,440700
FLFMT0:	ILDB	B,A
	JUMPE	B,FLFMT1
	CAIE	B," "			;IF IT'S A " "
	JRST	FLFMT0
	SETZ	B,			;CONVERT IT TO NULL
	DPB	B,A

FLFMT1:	MOVEI	A,101			;NOW DUMP STRING ON PRI JFN
	MOVE	B,-3(P)
	SETZ	C,
	SOUT

	POP	P,D			;RESTORE AC'S
	POP	P,C
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER

;  The following loops print out all jobs waiting to enter the queue,
;  all jobs waiting to be desubmitted, and all control jobs waiting
;  to be executed.

;
FILES:	SKIPE	FFLAG
	JRST	FILES1
	FSOUT	<
NO JOBS IN QUEUE>,[101]

FILES1:	SETZM	FFLAG
	MOVSI	A,100101		;OLD, ACCEPT INPUT, RETURN FLAGS
	MOVE	B,JOBFS			;JOB.*;* DESCRIPTOR
	GTJFN
	JRST	QDSB			;NONE FOUND
	MOVEM	A,JBJFN			;SAVE JFN
FILES2:
	FSOUT	<
QUEUED JOB FILES:>,[101]
FILES3:	FSOUT	<
      >,[101]
	HRRZ	B,JBJFN
	SETOM	FFLAG
	MOVE	C,[XWD 001110,1]
	JFNS

	MOVE	A,JBJFN
	GNJFN
	JRST	QDSB
	JRST	FILES3

QDSB:	SKIPE	FFLAG
	JRST	FILES4
	FSOUT	<
NO QUEUED JOB FILES >,[101]



;	OUTPUT LIST OF DESUBMIT REQUESTS
;
FILES4:	SETZM	FFLAG
	MOVSI	A,100101		;OLD, ACCEPT INPUT, RETURN FLAGS
	MOVE	B,DJOBS			;DJOB.*;* DESCRIPTOR
	GTJFN
	JRST	JOBER			;NONE FOUND
	MOVEM	A,JBJFN			;SAVE JFN
FILES5:
	FSOUT	<
QUEUED DESUBMIT FILES:>,[101]
FILES6:	FSOUT	<
      >,[101]
	HRRZ	B,JBJFN
	SETOM	FFLAG
	MOVE	C,[XWD 001110,1]
	JFNS

	MOVE	A,JBJFN
	GNJFN
	JRST	JOBER
	JRST	FILES6
JOBER:
	SKIPE	FFLAG
IFE	SBMTSW,<
	JRST	CJOBO			;CONTROL - GET CTL JOBS
	>
IFN	SBMTSW,<
	JRST	RUNING			;SUBMIT - ALL DONE
	>

	FSOUT	<
NO DESUBMIT FILES >,[101]



IFE	SBMTSW,<
;	OUTPUT LIST OF CONTROL TASKS PENDING
;
CJOBO:	SETZM	FFLAG
	MOVSI	A,(1B2+1B11+1B17)	;OLD, *, SHORT
	MOVE	B,CJOBS			;CJOB.*;* DESCRIPTOR
	GTJFN
	JRST	NOCJOB			;NONE FOUND
	MOVEM	A,JBJFN			;SAVE JFN
	SETOM	FFLAG

	SETO	D,			;FIRST READ IN ALL CONTROL FILES
	MOVE	B,[POINT 36,FENT]	;INTO FENT WITH COUNT IN D
	MOVEM	B,STRPTR
CJBLP:	HRRZ	A,JBJFN			;OPEN THE FILE AND GET THE ENTRY
	MOVE	B,[44B5+1B19]		;36 BIT, READ
	NOCTLC				;TURN OFF ^C
	OPENF
	TENERR	(<CJOBO: OPENF ERROR ON FILE>,START)
	MOVE	B,STRPTR		;READ THE RECORD
	MOVNI	C,QESIZE
	SIN
	MOVEM	B,STRPTR
	AOJ	D,			;COUNT IT
	TLO	A,(1B0)			;CLOSE FILE BUT DON'T RELEASE JFN
	CLOSF
	TENERR	(<CJOBO: ERROR CLOSING CONTROL FILE>,START)
	OKCTLC				;RESTORE ^C

CJBLP1:	MOVE	A,JBJFN
	GNJFN
	JRST	CJOBO1
	JRST	CJBLP			;MORE - GO GET IT

CJOBO1:	IMULI	D,QESIZE		;COMPUTE ADDRESS OF LAST ENTRY (OLDEST)
	FSOUT	<
QUEUED CONTROL TASKS:>,[101]

CJOBO2:	FSOUT	<
   >,[101]
	MOVE	B,FENT+BJOBNO(D)	;GET JOB NUMBER
	MOVEI	C,^D10			;PRINT IT DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ /)  </]
	SETZ	C,
	SOUT
	MOVE	B,FENT+USRDIR(D)	;OUTPUT DIRECTORY NAME OF AUTHOR
	DIRST
	JFCL

	HRROI	B,[ASCIZ />	/]
	SOUT
REPEAT	0,<MOVE	B,FENT+COMCOD(D)	;PRINT COMMAND CODE
	MOVEI	C,10				;OCTAL
	NOUT
	JFCL
	MOVEI	B,"-"
	BOUT
	SETZ	C,
	>

	HRROI	B,FENT+COMNAM(D)	;PUT OUT COMMAND NAME STRING
	SOUT
	HRROI	B,[ASCIZ /  (/]			;AND THE PARAMETER VALUE
	SOUT
	MOVE	B,FENT+COMPAR(D)
	MOVEI	C,10				;OCTAL
	NOUT
	JFCL
	MOVEI	B,")"
	BOUT
	SKIPN	B,FENT+AFTER(D)			;IF DELAYED, PRINT TIME
	JRST	CJOBO4				;NO - GO ON
	TLNN	B,-1				;JOB TRIGGERED DELAY?
	JRST	[HRROI	B,[ASCIZ /	AFTER JOB # /]	;YES - PRINT JOB
		 SETZ	C,
		 SOUT
		 MOVE	B,FENT+AFTER(D)
		 MOVEI	C,^D10			;DECIMAL
		 NOUT
		 JFCL
		 JRST	CJOBO4]			;MOVE ON

	JRST	[HRROI	B,[ASCIZ /	AFTER /]
		 SETZ	C,
		 SOUT
		 MOVE	B,FENT+AFTER(D)
		 MOVSI	C,245201
		 ODTIM
		 JRST	CJOBO4]

CJOBO4:	SUBI	D,QESIZE			;INDEX NEXT COMMAND RECORD
	JUMPGE	D,CJOBO2			;GO PRINT IT IF ANY LEFT

NOCJOB:
	SKIPE	FFLAG
	JRST	RUNING
	FSOUT	<
NO CONTROL TASKS PENDING >,[101]
	>		;END OF SBMTSW CONDITIONAL FOR CTL JOB OUTPUT


;  The following loops examine the job bit table and list any jobs not
;  accounted for properly.  Finally a tabulation of PTY jobs running
;  now is made before terminating the STATUS command.

RUNING:
IFE SBMTSW,<
IFE FDBSEQ,<
; Now compare the core bit table (JBBITS) against the file bit table (FJBBIT)
; noting any jobs in our table but not theirs and jobs which are in theirs
; but not ours.

	SKIPE	QCODE			;DON'T EXPECT TRASH Q TO MATCH
	JRST	SUNING
	SETZM	FFLAG			;FIRST TIME PRINT FLAG
	SETZM	COUNT			;COUNT OF ANY BAD ENTRIES
	SKIPE	JBSQOK			;DID WE GET THE JOB SEQ FILE?
	JRST	SUNING			;NOPE, BOMB OUT

	MOVSI	C,-NJBWRD		;FIRST SCAN FOR Q JOBS NOT IN THE FILE
SQBCHK:	MOVE	A,FJBBIT(C)		;GET BITS IN FILE WORD
	ANDCA	A,JBBITS(C)		;LEAVE ONLY THOSE NOT IN JBBITS
SQBCH0:	JFFO	A,SQBCH1		;AND COUNT THEM (DON'T WORRY ABOUT
					;BEING TOO EFFICIENT - NOT MANY HITS)
	JRST	SQBCH2			;NO MORE, MOVE ON
SQBCH1:	PUSH	P,A			;SAVE THE BIT CONFIGURATION FOR NEXT ROUND
	PUSH	P,B			;AND SOME WORKING AC'S FOR I/O
	PUSH	P,C
	SKIPN	FFLAG			;PRINT HEADER?
	JRST	[SETOM	FFLAG		;NOTE WE HAVE DONE THE HEADER
		 PPRINT	<
FOLLOWING JOBS ARE IN Q BUT NOT IN JOB SEQ FILE:
  >
		 JRST	SQB10]
	PPRINT	<, >
SQB10:	HRRZ	D,C			;COMPUTE THE JOB NUMBER
	IMULI	D,^D36			;FIRST THE BIT TABLE ADR PART
	ADD	B,D			;THEN THE BIT POSITION
	MOVEI	A,101			;PRINT THE NUMBER
	MOVEI	C,^D10
	NOUT
	JFCL
	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A
	MOVN	B,B			;CLEAR THIS BIT
	MOVSI	D,(1B0)
	LSH	D,0(B)
	XOR	A,D
	AOS	COUNT			;BUMP COUNTER FOR THIS ONE
	JRST	SQBCH0			;GO FIND THE NEXT ONE
SQBCH2:	AOBJN	C,SQBCHK		;EXAMINE ALL JBBITS WORDS

; NOW CHECK FOR BITS IN FJBBIT AND NOT IN JBBITS
	SETZM	FFLAG			;FIRST TIME PRINT FLAG
	MOVSI	C,-NJBWRD
SQBCH3:	MOVE	A,FJBBIT(C)		;GET THE FILE VERSION OF THIS WORD
	ANDCM	A,JBBITS(C)		;LEAVE THOSE EXTRA IN THE FILE
SQBCH4:	JFFO	A,SQBCH5		;AND COUNT THEM (DON'T WORRY ABOUT
					;BEING TOO EFFICIENT - NOT MANY HITS)
	JRST	SQBCH6			;NO MORE, MOVE ON
SQBCH5:	PUSH	P,A			;SAVE THE BIT CONFIGURATION FOR NEXT ROUND
	PUSH	P,B			;AND SOME WORKING AC'S FOR I/O
	PUSH	P,C
	SKIPN	FFLAG			;PRINT HEADER?
	JRST	[SETOM	FFLAG		;NOTE WE HAVE DONE THE HEADER
		 PPRINT	<
FOLLOWING JOBS ARE IN JOB SEQ FILE BUT NOT IN Q:
  >
		 JRST	SQB50]
	PPRINT	<, >
SQB50:	HRRZ	D,C			;COMPUTE THE JOB NUMBER
	IMULI	D,^D36			;FIRST THE BIT TABLE ADR PART
	ADD	B,D			;THEN THE BIT POSITION
	MOVEI	A,101			;PRINT THE NUMBER
	MOVEI	C,^D10
	NOUT
	JFCL
	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A
	MOVN	B,B			;CLEAR THIS BIT
	MOVSI	D,(1B0)
	LSH	D,0(B)
	XOR	A,D
	AOS	COUNT			;BUMP COUNTER FOR THIS ONE
	JRST	SQBCH4			;GO FIND THE NEXT ONE
SQBCH6:	AOBJN	C,SQBCH3		;EXAMINE ALL JBBITS WORDS

; Now make sure that the MXJBNO in the JOB SEQ file points to an empty slot.
	MOVE	A,FMXJBN		;GET CURRENT VALUE
	CAILE	A,0			;MAKE SURE IT IS IN RANGE
	CAILE	A,NQJBS
	MOVEI	A,1			;NOPE, RESET IT
	IDIVI	A,^D36			;COMPUTE BIT TABLE INDEXES
	MOVN	B,B			;AND SET UP THE BIT MASK
	MOVSI	C,(1B0)
	LSH	C,0(B)
	MOVE	B,FMXJBN		;AND THE CURRENT JOB COUNT AGAIN

SQBCH7:	TDNN	C,FJBBIT(A)		;IS THIS ONE FREE?
	JRST	SQBCH8			;YES, JUST MOVE ON
	AOJ	B,			;NO, BUMP TO NEXT JOB SLOT
	ROT	C,-1			;NEW BIT MASK
	TLNE	C,(1B0)			;IF IT WRAPPED AROUND,
	AOJ	A,			;UPDATE WORD ADDRESS
	CAILE	B,NQJBS			;DID THE JOB NUMBERS WRAP AS WELL?
	JRST	[SETZ	A,		;YES, SET UP AS START OF TABLE TO
		 MOVEI	B,1		;CONTINUE - NO JOB 0
		 MOVSI	C,(1B1)
		 JRST	.+1]
	CAME	B,FMXJBN		;HAVE WE GONE AROUND ONCE?
	JRST	SQBCH7			;NO, TRY NEXT SLOT

	PPRINT	<
JOB SEQ FILE BIT TABLE FULL>
	JRST	SUNING

SQBCH8:	CAMN	B,FMXJBN		;WAS THE VALUE GOOD?
	JRST	[SKIPE	COUNT		;ANY BAD ENTRIES
		 JRST	SUNING		;YES, MOVE ON
		 PPRINT	<
QUEUE AND JOB SEQ FILE BIT TABLES AGREE>
		 JRST	SUNING]
	PPRINT	<
PTR TO NEXT FREE JOB IN JOB SEQ FILE WRONG: IS >
	PUSH	P,B			;SAVE RIGHT VALUE
	MOVEI	A,101
	MOVE	B,FMXJBN		;PRINT OLD VALUE
	MOVEI	C,^D10
	NOUT
	JFCL
	PPRINT	<, SHOULD BE >
	MOVEI	A,101
	POP	P,B			;GET RIGHT VALUE
	MOVEI	C,^D10
	NOUT
	JFCL
	JRST	SUNING			;NOW MOVE ON
					;UP TO DATE

SUNING:	SETO	A,			;UNMAP OUR VERSION OF JOB SEQ FILE
	MOVE	B,[400000,,CTLPAG]
	SETZ	C,
	PMAP

	>		;END OF FDBSEQ CONDITIONAL
	>		;END OF SBMTSW CONDITIONAL

	SETZM	COUNT			;CLEAR ACTIVE PTY COUNT
	FSOUT	<
PTY(S) ACTIVE :>,[101]
;
;	OUTPUT JOB(S) RUNNING
;
	MOVE	A,[SIXBIT /TTYJOB/]
	SYSGT
	HRRZM	B,TTYJNM	;SAVE TTYJOB TABLE INDEX
	MOVE	D,PSEUD1  ;FIRST PSEUDO TTY
RUNLP:	HRL	A,D		;GET TABLE OFFSET
	HRR	A,TTYJNM	;GET TABLE NUMBER
	GETAB
	JRST	RUNEND
	JUMPLE	1,RUNEND		;JUMP IF NO JOB RUNNING
	AOS	COUNT			;ACTIVE PTY COUNT
	HLRZ	E,A		;SAVE JOB NUMBER
	MOVE	A,[SIXBIT /JOBDIR/]
	SYSGT
	HRRZ	A,B		;GET INDEX
	HRL	A,E		;RETREIVE JOB NUM
	GETAB
	JRST	RUNEND
	HRRZ	B,A		;ISOLATE DIR NUM
	MOVE	A,[XWD 440700,JOBSTR]
	DIRST
	JRST	RUNEND

	MOVEI	1,101
	MOVEI	B,37
	BOUT
	HRRZ	B,D		;GET TTY NUMBER
	MOVEI	C,10		;OCTAL OUTPUT
	NOUT
	JFCL
	MOVEI	B," "
	BOUT
	MOVE	B,[XWD 440700,JOBSTR]
	MOVEI	1,101
	SETZ	C,
	SOUT
;NOW TELL WHAT SUBSYS THE PTY JOB IN IN
	MOVEI	B," "
	BOUT
	MOVE	A,[SIXBIT 'JOBNAM']
	SYSGT
	SKIPN	A,B		;TABLE INDEX
	JRST	RUNEND		;FAILED
	HRL	A,E
	GETAB	
	JRST	RUNEND			;FAILED
	HRRZ	C,A			;SAVE INDEX INTO SNAMES
	MOVE	A,[SIXBIT 'SNAMES']
	SYSGT
	SKIPN	A,B		;TABLE INDEX
	JRST	RUNEND		;FAILED
	HRL	A,C		;INDEX BY # FROM JOBNAM
	GETAB
	JRST	RUNEND		;FAILED
;GOT SIXBIT OF SUBSYS NAME IN NOW
	MOVEI	C,6
	MOVE	B,A
NAMLP:	SETZ	A,
	LSHC	A,6		;ISOLATE 1 SIXBIT CHAR
	ADDI	A,40		;MAKE IT ASCII
	PBOUT			;OUTPUT IT
	SOJG	C,NAMLP		;MORE

RUNEND:	AOBJN	D,RUNLP
	SKIPE	COUNT
	JRST	PROMPT
	FSOUT	< NONE>,[101]
	JRST	PROMPT

	.JSYSR
;COMMAND RECOGNIZER AND SCANNER
;USE:
;BEFORE CALL THE FOLLOWING LOCS MUST BE SET
;PCMD - MUST CONTAIN BYTE POINTER TO BEGINNING OF COMMAND STRING
;		FOR ^R TO RETYPE WHOLE LINE
;PCMD2 - MUST CONTAIN BYTE POINTER FOR WHERE THIS COMMAND WORD
;		IS TO BE ENTERED STARTING AT.
;EOCCH - HOLDS TERMINATOR FOR COMMAND.
;EOCPTR - POINTS TO LAST CHAR STORED (NOT THE NULL)

;ALIST - MUST POINT TO HEAD OF LIST OF ENTRYS
;		AS FOLLOWS
;		DEFINE	TE(ADR,STR,FLAGS<0>)<
;		[ASCIZ /STR/]
;		FLAGS,,ADR
;		>
;		A ZERO WORD ENDS THE LIST OF ENTRYS
;
;FLAGS---
;	B0 - INVISIBLE (EXCEPT TO ENABLED WHEELS)
;	B1 - MUST BE ENABLED WHEEL TO EXECUTE THIS COMMAND
;	B2 - INVISIBLE (EXCEPT TO WHEELS (DON'T NEED ENA))
;	B3 - MUST BE WHEEL TO DO. (DON'T NEED ENA)
;
;THE CONTENTS OF AC 0 CONTROL INTERPRETATIONS OF INPUTS:
;   B0 - LOOK UP IN PRIME COMMAND LIST (RETURN INDEX IN A ON SUCCESS)
;   B1 - LOOK UP IN SUBCOMMAND LIST (RETURN INDEX IN A ON SUCCESS)
;   B2 - TRY AS DIRECTORY NAME (DIR # IN B ON SUCCESS)
;   B3 - TRY AS DECIMAL NUMBER (VALUE IN B ON SUCCESS)
;   B4 - TRY AS OCTAL NUMBER (VALUE IN B ON SUCCESS)
;   B5 - TRY AS FLOATING POINT NUMBER (VALUE IN B ON SUCCESS)

;  ON RETURN, AC C CONTAINS THE FLAG SPECIFYING PARAMETER TYPE RETURNED

;A MULTI SKIP RETURN WILL GIVE DIFFERENT MEANINGS
;	+1	HE DID ^X, IT ALREADY HAS DONE ___
;	+2	HE DID ^A OFF OF LEFT END OF FIELD
;	+3	HE ENTERED TOTALLY UNRECOGNIZEABLE COMMAND
;	+4	HE ENTERED A "?" AS THE FIRST CHARACTER
;	+5	HE ENTERED A NULL LINE ENDED WITH EOL
;		(HE JUST HIT RETURN)
;	+6	HE ENTERED SOMETHING RECOGNIZEABLE.
;
;IF THE RETURN IS +3,+4,+5,+6, THE LAST CHAR IS IN EOCCH.
;
;MAIN ENTRY TO SCANNER

CMDRDR:	SETZ	D,			;CLEAR INPUT CHAR COUNT - NEXT ENTRY
					;IS FOR ADDING TO CURRENT INPUT
					;IT ASSUMES AC D HAS PROPER COUNT
CMDRNT:	MOVEI	A,101			;PRIM OUTPUT
	RFCOC				;GET CONTROL CHARS
	MOVEM	B,COC1#			;SAVE THEM
	MOVEM	C,COC2#
	TLZ	B,(3B3)			;^A
	TDZ	C,[3B1!3B13!3B19]	;^R,^X,AND ESC
	SFCOC

CMDRD1:	MOVE	B,PCMD2			;POINT TO WHERE TO PUT IT

GCCH:	PBIN				;GET A CHARACTER
	CAIN	A,0			;NULL?
	JRST	GCCH			;YES, IGNORE IT
	CAIL	A,"A"+40		;CHECK FOR LOWERCASE
	CAILE	A,"Z"+40		;CONTINUE CHECK
	JRST	.+2			;NOT LOWERCASE
	SUBI	A,40			;MAKE UPPERCASE

	CAIN	A,"?"			;DOES HE NEED HELP
	JRST	EOCNSP			;YES, ALWAYS BREAK FOR IT

	CAML	A,SCHRNG		;CHECK IF INPUT WITHIN LEGAL RANGE
	CAMLE	A,ECHRNG
	JRST	EOC			;NO - THEN IT BETTER BE A SPECIAL ONE

	IDPB	A,B			;STORE CHARACTER
	AOJA	D,GCCH			;COUNT IT AND CONTINUE

CTLA:	JUMPLE	D,RETN2			;RETURN +2

IFN	SUMEX+IMSSS,<
	MOVEI	A,-1			;CONTROLLING TTY
	DELCH				;DELETE A CHARACTER - NICELY
	TENERR	(<CTLA: DELCH ERROR - NON TERMINAL>,START)
	JRST	RETN2			;ALREADY AT 0
	JRST	CTLA0			;OK, TAKEN CARE OF
	JFCL				;NON-DISPLAY, DO IT THE MESSY WAY
	>	;END SUMEX+IMSSS CONDITIONAL

	MOVEI	A,"\"			;GET A \
	PBOUT				;INDICATE DELETE
	LDB	A,B			;GET LAST CHARACTER
	PBOUT				;SHOW IT
CTLA0:	SETZ	A,			;DESTROY IT WITH NULL
	DPB	A,B			;ZOT!!
	SOS	B			;BACK UP BY 5 CHARS
REPEAT	4,<IBP B>			;FOWARD 4 AGAIN
	SOJA	D,GCCH			;DELETE IT FROM COUNT AND GO ON

CTLR:	PUSH	P,B			;SAVE B
	PUSHJ	P,CCRLF			;SEND CRLF IF NEEDED
	POP	P,B			;RESTORE B
	MOVE	C,PCMD			;POINT TO TOTAL COMMAND
CTLR1:	CAMN	B,C			;ARE WE AT END?
	JRST	GCCH			;YES, GO FOR INPUT
	ILDB	A,C			;GET A CHARACTER
	PBOUT				;PUT IT OUT
	JRST	CTLR1			;LOOP IT OUT

DELDEL:	HRROI	A,[ASCIZ /XXX/]		;MARK ACTION
	SKIPA				;REST IS LIKE CTL X
CTLX:	HRROI	A,[ASCIZ /___/]		;REPORT DELETION
	PSOUT
	JRST	RETN1			;RETURN +1

EOC:	CAIN	A,"A"-100		;^A?
	JRST	CTLA			;YES
	CAIN	A,"X"-100		;^X?
	JRST	CTLX			;YES
	CAIN	A,"R"-100		;^R?
	JRST	CTLR			;YES
	CAIN	A,177			;DEL?
IFE	SUMEX+IMSSS,<
	JRST	DELDEL			;YES - ARPANET THEN ABORT
	>
IFN	SUMEX+IMSSS,<
	JRST	CTLA			;YES - SUMEX/IMSSS THEN DEL CHAR
	>

;COMMAND IS NOW COMPLETE--CHAR READ WAS NOT A CTL CHAR OR SPECIAL
EOCNSP:	CAILE	A,15			;FORMS CONTROL CHARACTER?
	JRST	EOCSTR			;NO, JUST STORE IT
	CAIE	A,11			;YES, IS IT TAB?
	JRST	EOCNTB			;NO, CHECK CR
	MOVEI	A," "			;YES, CHANGE IT TO SPACE
	JRST	EOCSTR			;GO STORE IT

EOCNTB:	CAIE	A,15			;IS IT CR?
	JRST	EOCNCR			;NO, CHECK FURTHER
	PBIN				;READ NEXT CHAR
	CAIN	A,12			;IS IT LF?
	JRST	[MOVEI	A,37		;YES, IGNORE IT AND SET TO EOL
		 JRST	EOCSTR]
;	MOVEI	A,100
	MOVE	A,TTJFN			;NO, BACK UP
	BKJFN
	TENERR	(<EOCNTB: BKJFN ERROR ON PRIMARY INPUT>,START)

EOCNCR:	MOVEI	A,37			;DO A CRLF
	PBOUT
	
EOCSTR:	MOVEM	A,EOCCH			;SAVE CHARACTER
	CAIN	A,37			;EOL?
	JUMPE	D,RETN5			;AS FIRST CHAR?
					;RETURN +5 IF SO.

	CAIE	A,"?"			;DOES HE WANT HELP?
	JRST	CHKEOL			;NO - CHECK FOR EOL
	PUSH	P,B			;SAVE INPUT STATE
	PUSH	P,D
	SKIPN	HELPAD			;HAS A ROUTINE BEEN SUPPLIED?
	JRST	[HRROI	A,[ASCIZ /

SORRY, NO HELP AVAILABLE

/]					;NOPE, TOUGH LUCK
		 PSOUT
		 JRST	HEPRET]
	PUSHJ	P,@HELPAD		;YES, GO TO HIS ROUTINE (HE MUST
					;POPJ RETURN!
HEPRET:	POP	P,D			;RESTORE INPUT STATE
	POP	P,B
	JRST	CTLR			;GO RETYPE INPUT AND GET MORE

;;;	CAIN	A,"?"			;DOES HE WANT HELP?
;;;	JUMPE	D,RETN4			;RETURN +4 IF SO
;;;	JUMPE	D,HELPER		;GIVE IT TO HIM

;CHECK FOR A LEGAL DELIMITER
CHKEOL:	CAIE	A,37			;EOL IS OK
	CAIN	A," "			;SO IS SPACE
	JRST	EOCOK			;GOOD
	CAIE	A,33			;ESC IS GOOD
	JRST	EOCNO			;OTHERWISE NO-GO

EOCOK:	SETZ	A,			;ENSURE COMMAND ENDS WITH NULL
	MOVEM	B,EOCPTR		;SAVE END COMMAND POINTER
	IDPB	A,B			;STORE NULL TO END COMMAND

	CAIN	ZZ,0			;INPUT CHECKING DESIRED?
	JRST	[PUSH	P,ZZ		;SET UP NULL RETURN AC'S
		 PUSH	P,ZZ
		 PUSH	P,ZZ
		 JRST	ESCE]
	TLNN	ZZ,(COMLST+SUBLST)	;YES, COMMAND LIST?
	JRST	TRYDIR			;NO, TRY AS DIRECTORY
	MOVE	E,ALIST			;GET POINTER TO LIST
	SETZM	MATCNT			;ZERO MATCH COUNT AND
	SETZM	MATIND			;MATCHED INDEX

EOCLP:	SKIPN	(E)			;AN ENTRY HERE?
	JRST	EOCMAT			;THAT'S THE LIST, SEE WHAT WE HAVE
	PUSHJ	P,CKM			;CHECK FOR MATCH
	JFCL				;WRONG PRIVILEGES
	JRST	EOCLP0			;NO MATCH HERE - TRY NEXT ONE
	SKIPA				;MATCH SO FAR - SOME STRING LEFT
	JRST	EOCMM			;SUPER MATCH - TAKE IT!
	AOS	MATCNT			;RECORD THIS MATCH
	MOVEM	E,MATIND		;AND ITS INDEX
EOCLP0:	ADDI	E,2			;GO TO NEXT
	JRST	EOCLP			;AND LOOP

;CHECK FOR AMBIGUITY
EOCMAT:	MOVE	B,MATCNT		;GET COUNT OF HITS
	CAIG	B,0			;ANY AT ALL?
	JRST	TRYDIR			;NOPE, SEE IF IT CAN BE A DIRECTORY
	CAIE	B,1			;WAS IT UNIQUE?
	JRST	AMBIG			;NO - BEEP HIM

	MOVE	E,MATIND		;UNIQUE HIT - FILL IT OUT

EOCMM:	MOVE	A,E			;INDEX IN AC A
	SETZ	B,
	MOVSI	C,(COMLST+SUBLST)	;SET TYPE FLAG
	AND	C,ZZ
	PUSH	P,A			;SAVE PARAMETER LIST ON STACK
	PUSH	P,B
	PUSH	P,C

	PUSHJ	P,CKM			;SEE HOW MUCH DID MATCH
	BUG	(<SECOND CKM RETURN +1>)
	BUG	(<SECOND CKM RETURNED +2>)
	JFCL				;OK BUT SOME LEFT TO GO
ESCML:	MOVE	B,EOCCH			;PERFECT, GET DELIM
	CAIE	B,33			;WAS IT ESC?
	JRST	ESCE			;NO ESC, FINISH INPUT

	MOVE	B,A			;GET PTR TO FULL NAME
ESCL:	ILDB	A,B			;GET NEXT CHAR
	JUMPE	A,ESCE			;CHECK IF DONE
	PBOUT				;SEND TO TERMINAL
	IDPB	A,EOCPTR		;INCLUDE IN LINE
	JRST	ESCL

ESCE:	MOVEI	A,40			;AND A BLANK
	MOVE	B,EOCCH			;DO WE NEED A BLANK?
	CAIN	B," "
	JRST	ESCE0			;LAST ONE WAS BLANK, DON'T DO ANOTHER
	CAIN	B,37			;WAS IT EOL?
	JRST	ESCE0			;YES, DON'T OUTPUT A BLANK
	PBOUT				;TYPE IT
ESCE0:	IDPB	A,EOCPTR		;SAVE IT
	SETZ	A,			;A NULL
	MOVE	B,EOCPTR		;GET EOCPTR
	IDPB	A,B			;TERMINATE LINE

	POP	P,C			;RESTORE PARAMETERS
	POP	P,B
	POP	P,A

RETN6:	AOS	(P)			;RETURN +6
RETN5:	AOS	(P)			;RETURN +5
RETN4:	AOS	(P)
RETN3:	AOS	(P)
RETN2:	AOS	(P)
RETN1:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	MOVEI	A,101			;PRIM OUTPUT
	MOVE	B,COC1			;RESET SFCOC WORDS
	MOVE	C,COC2
	SFCOC

	POP	P,C			;RESTORE THESE
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN +1

;AMBIGUOUS INPUT - RING HIS CHIMES
AMBIG:	MOVEI	A,7			;RINGS BELL
	PBOUT
	MOVE	B,EOCPTR		;REUP WHERE TO PUT CHARACTER
	JRST	GCCH			;GO BACK FOR MORE


TRYDIR:	TLNN	ZZ,(DIRSTR)		;TRY IT AS DIRECTORY?
	JRST	TRYNUM			;NO, SEE ABOUT A NUMBER
	MOVE	B,EOCCH			;SEE IF RECOGNITION WANTED
	SETO	A,			;ASSUME YES
	CAIE	B,33			;REALLY AN ESC?
	SETZ	A,			;NO, CAN RECOGNITION
	MOVE	B,PCMD2			;POINT TO STRING
	SETZ	C,
	STDIR				;SEE IF A DIRECTORY
	JRST	TRYNUM			;NO WAY
	JRST	AMBIG			;OK BUT NOT UNIQUE
	HRRZ	B,A			;RIGHT ON - SAVE NUMBER IN B
	SETZ	A,
	MOVSI	C,(DIRSTR)
	PUSH	P,A			;SAVE RESULTS ON STACK
	PUSH	P,B
	PUSH	P,C
	MOVE	A,EOCPTR		;RESTORE END OF INPUT STRING PTR
					;SO NAME CAN BE COMPLETED IF RECOG
	JRST	ESCML			;GO COMPLETE STRING IF NEEDED

TRYNUM:	TLNN	ZZ,(FIXNUM+OCTNUM+FLTNUM)	;TRY IT AS A #?
	JRST	EOCNO			;NOPE, BAD NEWS
	MOVE	A,PCMD2			;YES, SET UP TO CONVERT
	TLNE	ZZ,(FIXNUM)		;DECIMAL?
	JRST	[MOVEI	C,^D10		;YES
		 JRST	TRYNM0]
	TLNE	ZZ,(OCTNUM)		;NO, OCTAL?
	JRST	[MOVEI	C,10
		 JRST	TRYNM0]

	FLIN				;NO, MUST BE FLOATING
	JRST	EOCNO			;DIDN'T WORK - CAN HIM
	MOVSI	C,(FLTNUM)
	JRST	TRYNM1

TRYNM0:	NIN				;OK, CONVERT INTEGER
	JRST	EOCNO			;BAD LUCK
	MOVSI	C,(FIXNUM+OCTNUM)
	AND	C,ZZ

TRYNM1:	SETZ	A,			;GOT THE NUMBER
	JRST	RETN6			;WRAP IT UP


;UNRECOGNIZEABLE
EOCNO:	HRROI	A,[ASCIZ /  ?/]		;ERROR MESSAGE
	PSOUT
	JRST	RETN3			;RETURN +3

;CHECK FOR LEGALITY AND CHECK FOR MATCH IF LEGAL
;RETURN +1 IF NOT LEGAL
;	+2 IF LEGAL BUT NO MATCH
;	+3 LEGAL, MATCH BUT INCOMPLETE
;	+4 PERFECT MATCH!
CKM:	MOVE	B,CAPS			;GET CAPABILITIES
					;POSSIBLE,,ENABLED
	TRNE	B,600000		;ENABLED WHEEL OR OPER?
	JRST	CKM2			;ALL IS LEGAL
	MOVE	A,1(E)			;GET FLAGS AND ADR
	TLNE	A,(1B1)			;NEED HE BE WHEEL TO DO THIS?
	POPJ	P,			;YES-SO HE CAN'T

	TLNE	B,600000		;CHECK POSSIBLE CAPS
	JRST	CKM2			;HE IS NON-ENABLED WHEEL
	TLNE	A,(1B3)			;SHOULD HE HAVE BEEN?
	POPJ	P,			;YES-SO CANNOT DO

CKM2:	AOS	(P)			;AT LEASE THIS IS LEGAL FOR HIM
	HRRO	A,0(E)			;GET POINTER TO STRING IN LIST
	MOVE	B,PCMD2			;GET COMMAND POINTER
	PUSHJ	P,STRMA			;MATCH?
	POPJ	P,			;NO - RETURN +2
	SKIPA				;RETURN +3 - MATCH AS FAR AS IT WENT
	AOS	(P)			;RETURN +4 - PERFECT MATCH
	AOS	(P)
	POPJ	P,			;RETURN



;COMMAND LIST HELP ROUTINE
HELPER:	MOVE	E,ALIST			;POINT TO POSSIBLE COMMANDS
	HRROI	A,[ASCIZ /

COMMANDS ARE:
 /]
	TLNE	ZZ,(SUBLST)		;SUBCOMMAND?
	HRROI	A,[ASCIZ /

SUBCOMMANDS ARE:
 /]					;YES, GIVE RIGHT PROMPT
	PSOUT
	MOVE	D,CAPS			;GET CAPS (POSSIBLE,,ENABLED)
	PUSH	P,B			;SAVE AC B
	HRLZI	B,010700		;SET UP ENDING STRING POINTER MASK
					;ALLOW 10 CHARS FOR NAME
	PUSH	P,B			;SAVE IT
	SETZ	F,			;NUMBER OF COMMANDS PER LINE
HELP2:	MOVE	A,(E)			;GET POINTER TO STRING
	JUMPE	A,HELPEX		;EXIT TO ^R ROUTINE TO RETYPE LINE
	MOVE	A,1(E)			;GET FLAGS,,ADR
	TLNN	A,(1B0)			;NEED HE BE ENABLED TO SEE IT?
	JRST	.+3			;NO
	TRNN	D,600000		;CHECK IF HE IS ENABLED
	JRST	HELP4			;NO SEE THIS

	TLNN	A,(1B2)			;NEED HE BE WHEEL?
	JRST	.+3			;NO
	TLNN	D,600000		;CHECK IF A WHEEL POSSIBLE
	JRST	HELP4			;NO- CANNOT SEE THIS

	AOJ	F,			;BUMP COUNTER
	CAIG	F,5			;HAVE WE DONE 5?
	JRST	HELP25			;NO, SPACE OVER
	HRROI	A,[ASCIZ /
 /]					;YES, START NEW LINE
	MOVEI	F,1			;RESET COUNTER
	PSOUT
HELP25:	HRRO	A,(E)			;GET STRING PTR
	PSOUT				;GIVE THIS COMMAND

HELP3:	PUSH	P,A			;SAVE CURRENT POINTER
	IBP	A			;MAKE SURE ROOM FOR AT LEAST 1 SPACE
	HRRZ	A,A			;STRIP ADDRESS ONLY
	HRRZ	B,0(E)			;GET STRING PTR AND SPACE OVER 1 GROUP
	ADDI	B,1			;OF 5 CHAR + THE 5 ABOVE
	CAMLE	A,B			;IS THIS ENOUGH TO INCLUDE CURRENT COMMAND?
	 JRST	[ADDI	B,2		;NO, SPACE OVER 1 WHOLE GROUP
		 POP	P,A		;GET PTR BACK OFF STACK
		 AOJ	F,		;BUMP LINE COUNTER
		 CAIGE	F,5		;AT LEAST 5 ?
		 JRST	HELP3		;NO, TRY TO SPACE OVER
		 JRST	HELP4]		;YES, DO A NEW LINE
	HRRM	B,-1(P)			;UPDATE STACK MASK
	POP	P,B			;PUT CURRENT POINTER IN AC B
	MOVEI	A," "			;DO SPACES
HELP35:	PBOUT				;WRITE A SPACE
	IBP	B
	CAME	B,0(P)			;IS IT AS MUCH AS WE WANT?
	JRST	HELP35			;NO - DO SOME MORE

HELP4:	ADDI	E,2			;GO TO NEXT COMMAND
	JRST	HELP2			;LOOP ON
HELPEX:	POP	P,B			;CLEAR ENDING PTR MASK
	POP	P,B			;RESTORE AC B
	SETZ	D,			;CLEAR COUNT

	TLNN	ZZ,(SUBLST)		;IF NOT A SUBCOMMAND
	JRST	HELP5			;GO TELL ABOUT TTY CONTROLS
	PPRINT	<

>					;OTHERWISE JUST CRLF AND LEAVE
	POPJ	P,			;DON'T PUT OUT THIS JUNK

HELP5:
IFE	SUMEX+IMSSS,<
	HRROI	A,[ASCIZ /

^A DEL CHAR, ^R RETYPE LINE, ^X OR <DEL> TO ABORT COMMAND,
<ESC> FOR RECOGNITION, ^O TO STOP OUTPUT OR PROMPT

/]
	>
IFN	SUMEX+IMSSS,<
	HRROI	A,[ASCIZ /

^A OR <DEL> TO DELETE A CHAR, ^R RETYPE LINE, ^X TO ABORT COMMAND,
<ESC> FOR RECOGNITION, ^O TO STOP OUTPUT OR PROMPT

/]
	PSOUT
	POPJ	P,			;RETYPE LINE AND CONTINUE

;STRING MATCHER.
;CALL: A AND B HAVE STRING POINTERS IN THEM.
;	PUSHJ	P,STRMA
;	+1	NO MATCH. (NO REGISTERS CHANGED)
;	+2	MATCH. STRINGS MATCHED (UNTIL B ENDED).
;		LENGTH OF B IS .LT. LENGTH OF A SO ONLY
;		THE FIRST LEN(B) CHARS WILL HAVE BEEN
;		CHECKED.  IF A ENDED FIRST, A NO-MATCH IS DONE.
;	+3	PERFECT MATCH - LENGTH OF A AND B SAME AND ALL
;		CHARACTERS MATCH.
;
;		WHEN THE SUCCESS RETURN IS TAKEN, A IS INCREMENTED
;		OVER MATCHED CHARACTERS.
;		B IS LEFT AS IN CALL ALWAYS.
;
;	STRING POINTERS MAY HAVE -1 IN LH TO IMPLY 440700
STRMA:	PUSH	P,D			;SAVE ACS
	PUSH	P,C
	PUSH	P,B
	PUSH	P,A

	HLRZ	C,A			;CHECK LH FOR -1
	CAIN	C,-1			;WAS IT -1?
	HRLI	A,440700		;IF SO, SET IT
	HLRZ	C,B			;CHECK LH FOR -1
	CAIN	C,-1			;WAS IT -1?
	HRLI	B,440700		;IF SO, SET IT

STRMA1:	ILDB	D,B			;GET ONE FROM TEST STRING
	JUMPE	D,STRMA2		;NULL MEANS END MEANS MATCH
	ILDB	C,A			;GET ONE FROM MAIN STRING
	CAMN	C,D			;MATCH?
	JRST	STRMA1			;YES, CONTINUE
	JRST	STRMA3			;NO, FAIL

;SUCCESSFUL MATCH - CHECK TO SEE IF PERFECT
STRMA2:	PUSH	P,A			;SAVE CURRENT A PTR
	ILDB	C,A			;GET NEXT CHAR OF A
	CAIN	C,0			;IS IT THE END
	AOS	-5(P)			;YES - RETURN +3
	POP	P,A			;RECOVER CURRENT A PTR
	POP	P,B			;THROW AWAY OLD VAL OF A
	AOSA	-3(P)			;SET SKIP RETURN, AND
					;SKIP INTO EXIT ROUTINE
;MATCH FAILURE EXIT.
STRMA3:	POP	P,A			;BACK UP POINTER TO MAIN
	POP	P,B			;RESTORE OTHER ACS
	POP	P,C
	POP	P,D
	POPJ	P,			;RETURN
;LUUO ROUTINES

;MAIN LUUO HANDLER.
LUUOI:	PUSH	P,A			;SAVE A FOR A WORK AREA
	MOVE	A,40			;GET TRAP INSTRUCTION
	ROT	A,^D9			;GET ITS OPCODE
	ANDI	A,777			;ISOLATE OPCODE
	JUMPLE	A,.+2			;BEWARE .LE. 0
	CAILE	A,NLUUOS		;CHECK AGAINST UPPER LIMIT
	BUG	(<ILLEGAL LUUO TRAP>)	;OOPS
	MOVE	A,LUUOV-1(A)		;GET ADDR OF LUUO ROUTINE
	EXCH	A,(P)			;RESTORE A, SAVE ROUTINE ADDR
	POPJ	P,			;CLEAR STACK, GO TO ROUTINE

;NOW THE LUUO VECTOR
LUUOV:	ERRORX				;PRIMARY ERROR FUNCTION
	ERR10X				;REPORT TENEX ERROR
	NOISEX				;DO NOISE WORD FUNCTION
	CONF				;CONFIRM FUNCTION
NLUUOS==.-LUUOV				;GET # OF DEFINED LUUOS

IFG	NLUUOS-37,<			;CHECK FOR WITHIN LIMIT
	PRINTX	TOO MANY LUUOS DEFINED!!
	>				;END IFG NLUUOS-37

;PRIMARY ERROR INSTRUCTION.
;USE:
;	ERR1	[JUMP-ADDR,,[ASCIZ /MSG-STRING/]]
;IF JUMP-ADDR IS 0, THEN NO JUMP WILL OCCUR, THE NEXT INSTRUCION
;WILL BE EXECUTED IN SEQUENCE.
;NORMALLY USED WITH THE ERROR MACRO
;	ERROR	<MSG>
;OR	ERROR	<MSG>,JUMP-ADDR
ERRORX:	PUSH	P,A			;SAVE ACS
	PUSH	P,B
	PUSHJ	P,CCRLF			;NEW LINE IF NEEDED
	MOVEI	A,"?"			;ERROR LEADER
	PBOUT				;PUT IT OUT
	HRRO	A,@40			;GET STRING POINTER FOR ERROR
	PSOUT				;AND TYPE MESSAGE
	PUSHJ	P,CRLF			;GIVE CRLF
	HLRZ	A,@40			;GET RETURN ADDRESS
	JUMPE	A,.+2			;IF 0 GIVEN, DON'T CHANGE
	MOVEM	A,-2(P)			;SET NEW RETURN ADDR
	POP	P,B			;RESTORE ACS
	POP	P,A
	POPJ	P,			;RETURN TO MAINLINE PROGRAM

;ERR10X IS THE TENEX ERROR REPORTER
;USE IS VIA THE TENXER INSTRUCTION
;	TENXER	JUMP-ADDR
;IF JUMP-ADDR IS 0 (OR OMITTED, GIVING 0) THEN THE INSTRUCTION
;DOES NOT JUMP.
ERR10X:	PUSH	P,A			;SAVE ACS
	PUSH	P,B
	PUSH	P,C
	PUSHJ	P,CCRLF			;GIVE ANY NEEDED CRLF
	PPRINT	<? >
	HRRO	A,@40			;PTR TO ERROR MESSAGE
	PSOUT
	PPRINT	<
   >

	MOVEI	A,101			;PRIMARY OUTPUT JFN
	HRLOI	B,400000		;LAST ERROR, THIS FORK
	SETZ	C,			;NOTHING SPECIAL
	ERSTR				;PRINT ERROR MESSAGE
	JFCL
	JFCL
	PPRINT	<
>

	HLRZ	A,@40			;GET RETURN ADDRESS
	SKIPE	A			;IF SPECIFIED,
	MOVEM	A,-3(P)			;SET IT AS RETURN ADR

	POP	P,C			;RESTORE ACS
	POP	P,B
	POP	P,A

	OKCTLC				;RESTORE ^C

	POPJ	P,			;RETURN TO MAINLINE PROGRAM.

;NOISE WORD PROCESSOR
;CALLED FROM NOISE MACRO WITH NOISE INSTRUCTION
;	NOISE1	[ASCIZ /STR/]
;DOES THE NOISE PROCESSING
NOISEX:	PUSH	P,A			;SAVE ACS
	PUSH	P,B

	MOVE	A,EOCCH
	CAIN	A,33			;ESC?
	JRST	NOISEW			;YES, GO WRITE IT

NOISER:	POP	P,B			;RESTORE ACS AND RETURN
	POP	P,A
	POPJ	P,			;RETURN

NOISEW:	SKIPN	@40			;IS IT A NULL STRING?
	JRST	NOISER			;YES, THEN DON'T BOTHER
	MOVEI	A,"("			;BEGIN WITH (
	PBOUT
	HRRO	A,40			;GET STRING POINTER
	PSOUT				;TYPE IT
	HRROI	A,[ASCIZ /) /]		;END OF NOISE CHARACTERS
	PSOUT
	JRST	NOISER			;RETURN



;CONFIRM ROUTINE
CONF:	PUSH	P,A			;SAVE A
	HRROI	A,[ASCIZ / [Confirm] /]
	PSOUT
CONF1:	
	PBIN				;READ CONFIRMATION
	CAIN	A,"?"			;DOES HE WANT HELP?
	JRST	CONF3			;YES
	CAIN	A,37			;DID HE HIT EOL?
	JRST	CONF2			;YES
	CAIN	A,15			;DID HE HIT RETURN?
	JRST	[PBIN			;EAT FOLLOWING LF
		 JRST	CONF2]		;ACKNOWLEDGE YES
	CAIN	A,"Y"			;DID HE HIT Y
	JRST	CONF2			;YES
	CAIN	A,"y"			;DID HE HIT y
	JRST	CONF2			;YES
	MOVEI	A,PROMPT			;WHERE WE RETURN TO
	MOVEM	A,-1(P)			;SET IT
CONF2:	POP	P,A			;RESTORE A
	POPJ	P,			;RETURN
CONF3:	HRROI	A,[ASCIZ /
[Confirm with carriage return.]/]
	PSOUT
	JRST	CONF1			;TRY AGAIN
;WRITE BUG MESSAGE
BUGMSG:	EXCH	A,(P)			;GET POINTER TO STRING
	HRLI	A,440700		;MAKE BYTE POINTER
	PUSH	P,A			;SAVE IT
	HRROI	A,[ASCIZ /
? PROGRAM BUG - /]
	PSOUT
	POP	P,A			;GET POINTER TO OUR MSG.
	PSOUT				;REPORT IT
	JRST	START			;GO RESET AND START ALL OVER AGAIN


;CONDITIONAL CRLF
CCRLF:	MOVEI	A,101			;OUTPUT JFN
	RFPOS				;FIND WHERE WE ARE
;	TRNN	B,377B25		;AT START?
	TRNN	B,-1			;AT START?
	POPJ	P,			;YES

;SEND A CRLF TO USER.  CALLED INDEPENDENTLY OR FALLEN INTO FROM CCRLF
CRLF:	HRROI	A,[BYTE (7)15,12,0]	;CR,LF SEQ
	PSOUT
	POPJ	P,			;RETURN



;ROUTINE FOR TRYING TO OPEN A BUSY FILE 20 TIMES
.OPENF:	OPENM



;ROUTINE TO HANDLE ^O - RESTARTS JOB
CTLO:	MOVEI	A,PROMPT		;SET RETURN TO PROMPT
	MOVEM	A,LEV3PC
	MOVEI	A,101			;RESET TERMINAL CHAR
	MOVE	B,COC1
	MOVE	C,COC2
	CAIE	B,0			;IF IT HAS BEEN CHANGED
	SFCOC
	CFOBF				;CLEAN UP OUTPUT BUFFER
	MOVEI	A,37
	PBOUT
	PBOUT
	DEBRK

;ROUTINE TO HANDLE ^C - PREVENTS LEAVING FILES LOCKED
CTLC:	AOS	CTLCSW			;INCREMENT FLAG THAT ^C HIT
	DEBRK


;THESE ARE THE ACCOUNTING ROUTINES USED IN SUBMIT - NEXT 4 PAGES


IFN	SBMTSW,<
IFN	STRACT,<
IFN	TNX131,<

;THESE ROUTINES ONLY FOR 131 TENEX

;ROUTINES TO EMULATE VACCT AND GDACC JSYS'S	
;
;$VACCT CALLED W/ PUSHJ P,$VACCT
;	1/USER #, -1 MEANS SELF (CONN DIR)
;	2/ACCT DESIGNATOR, 5B2+NUMBER OR DSP
;
;RETURNS	+1	FAIL TO MATCH
;		+2	USER ACCT PAIR MATCH
;			OR UACHK UNRUNNABLE
;			OR WHEEL /OPERATOR
;
;$GDACC CALLED W/ PUSHJ P,$GDACC
;	1/ E FOR STRING ACCT (DSP)
;	2/ USER ACCT #, -1 FOR SELF (CONN DIR)
;
;RETURNS	+1	FAILURE DOESN'T RETURN CODES
;		+2	SUCCESS ACCOUNT STRING POINTER IN AC1
;


$VACCT:	PUSH	P,1		;USER NUMBER
	PUSH	P,2		;ACCOUNT DESIGNATOR
	PUSH	P,3
	MOVEI	1,400000	;THIS FORK
	RPCAP
	TRNE	3,1B18+1B19	;WHEEL OR OP?
	JRST [	POP	P,3	
		JRST $VACC2]	;SKIP RETURN
	POP	P,3
	MOVE	2,-1(P)		;GET USER NUMBER
	SETZM	UACBLK
	MOVE	1,[UACBLK,,UACBLK+1]
	BLT	UACBLK+17	;CLEAR AC ARG BLOCK
	CAME	2,[-1]		;SELF?
	JRST $VACC1		;NO
	PUSH	P,3
	PUSH	P,4
	GJINF			;GET JOB INFO CONN DIR IN 2
	POP	P,4
	POP	P,3
$VACC1:	HRROI	1,UACBLK	;FIRST 8 AC'S CONTAIN DIRST
	DIRST
	JRST $VAFXT		;DO FAIL RETURN
	MOVE	1,0(P)		;GET ACCT DESG
	CAML	1,[500000,,0]
	CAMLE	1,[577777,,-1]	;IS IT NUMERIC?
	JRST $VASTR		;NO STRING
	MOVEM	1,UACBLK+10	;NUMERIC DESIG IN AC10
	MOVEI	1,UACBLK	;POINT TO ARG BLOCK
	MOVEI	2,1		;START AT NUMERIC ENTRY POINT
	PUSHJ	P,RUNUAC
	JRST $VACC2		;FORK FAILED TO RUN
	JRST $VACC3		;FORK RAN, CHECK RESULT
;
$VASTR:	MOVEI	2,[POINT 7,UACBLK+10] ;POINT TO AC10-17 FOR ACCT STRING
	TLC	1,-1		;DSP?
	TLCN	1,-1		;SKIP IF NOT DSP
	HRLI	1,440700	;CONVERT TO STRING POINTER
	PUSH	P,3
	PUSH	P,4
	MOVNI	4,^D39		;WE ONLY TAKE 39 CHARS
$VALUP:	ILDB	3,1
	IDPB	3,2
	CAIE	3,0		;SKIP IF NULL BYTE
	AOJL	4,$VALUP	;GET 39 CHARS MAX
	POP	P,4
	POP	P,3
	MOVEI	1,UACBLK	;POINT TO AC BLOCK
	MOVEI	2,2		;ENTRY POINT FOR STRING
	PUSHJ	P,RUNUAC
$VACC2:	AOSA	-2(P)		;RUN FAILED SAY OK
$VACC3:	CAIE	1,0		;FIND A MATCH?
$VAFXT:	JRST [	POP	P,2	
		POP	P,1
		POPJ	P,]
	JRST $VACC2		;FOUND MATCH, DO SKIP RETURN
$GDACC:	PUSH	P,1		;DSP FOR ACCT
	PUSH	P,2		;USER NUMBER
	SETZM	UACBLK
	MOVE	1,[UACBLK,,UACBLK+1]
	BLT	1,UACBLK+17	;CLEAR AC ARG BLOCK
	CAME	2,[-1]		;SELF?
	JRST $GDAC1		;NO
	PUSH	P,3
	PUSH	P,4
	GJINF			;GET CONN DIR NUM IN 2
	POP	P,4
	POP	P,3
$GDAC1:	HRROI	1,UACBLK	;POINT TO AC0-7	FOR DIRST
	DIRST
	JRST $GDFXT		;DO FAIL RETURN
	MOVEI	1,UACBLK	;POINT TO AC BLOCK
	SETZ	2,		;0 ENTRY POINT FOR DEFAULT
	PUSHJ	P,RUNUAC
	CAIA			;NON-SKIP IF FORK FAILED
	CAIE	1,0		;DID WE FIND DEFAULT?
	JRST $GDFXT		;NO, NON-SKIP
	PUSH	P,3
	PUSH	P,4
	MOVNI	3,^D39		;39 CHARS MAX
	HRRZ	2,UACBLK+2	;GET POINTER REL TO AC BLOCK
	ADD	2,[POINT 7,UACBLK] ;MAKE IT A USEFULL POINTER
	MOVE	4,-3(P)		;GET USERS POINTER
	HRLI	4,440700	;MAKE E A POINTER
$GDACL:	ILDB	1,2
	IDPB	1,4
	CAIE	1,0		;SKIP IF  A NULL
	AOJL	3,$GDACL
	POP	P,4
	POP	P,3
	AOS	-2(P)		;DO SKIP RETURN
$GDFXT:	POP	P,2
	POP	P,1
	POPJ	P,


;RUNS UACHK PROGRAM DOES NON-SKIP RETURN ON PROGRAM FAILURE
;	1/ POINTER TO AC ARG BLOCK
;	2/ ENTRY VECTOR OFFSET
;	   0=DEFAULT, 1=NUMERIC CHECK, 2=STRING CHECK

RUNUAC:	PUSH	P,1		;ARG POINTER
	PUSH	P,2		;ENTRY VECTOR
	MOVSI	1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI	2,[ASCIZ /<SYSTEM>UACHK.SAV/]
	GTJFN
	JRST [	POP	P,2
		POP	P,1
		POPJ	P, ]	;DO FAIL RETURN IF CANT FIND FILE
	PUSH	P,1		;JFN
RUNUA1:	MOVSI	1,(1B1)		;SET CAP DONT START
	CFORK
	JRST [	MOVEI	1,^D1000
		DISMS		;TRY AGAIN IN 1 SEC
		JRST RUNUA1]
	PUSH	P,1		;FORK HANDLE
	MOVSI	1,0(1)		;MOVE HANDLE TO LH
	HRR	1,-1(P)		;AND PUT JFN IN RH
	GET
	MOVE	1,(P)
	MOVE	2,-3(P)		;GET POINTER TO ARG BLOCK
	SFACS			;LOAD ACS
	MOVE	2,-2(P)		;GET VECTOR OFFSET
	SFRKV			;START IT
	WFORK			;WAIT FOR IT
	FFORK			;FREEZE IT
	MOVE	2,-3(P)		;POINT TO ARG BLOCK
	RFACS			;COPY BACK THE ACS
	RFSTS			;GET FORK STATUS
	TLZ	1,(1B0)		;KILL THE FREEZE BIT
	CAME	1,[2,,0]
	TLOA	2,-1		;INVOL TERMINATE
	TLZ	2,-1		;CLEAN HALT
	POP	P,1		;GET FORK HANDLE
	KFORK			;GET RID OF IT
	POP	P,1		;GET THE JFN
	RLJFN			;RELEASE IT
	JFCL			;SHOULDNT HAPPEN!!??
	MOVE	1,-1(P)		;POINT TO BLOCK
	MOVE	1,1(1)		;WE WANT THE AC1
	CAIL	2,0		;INVOL TERMINATE?
	CAILE	1,0		;OR PROGRAM ERROR?
	SOS	-2(P)		;DO NON-SKIP
	POP	P,2
	SUB	P,[1,,1]	;POP STACK AGAIN
	AOS	(P)
	POPJ	P,

	>
	>			;END OF TNX131 STRING ACCOUNTING CONDITIONAL
	>		;END OF SBMTSW CONDITIONAL - SUBMIT ONLY

;PURE DATA STORAGE

IFN	SBMTSW,<
;MAIN COMMAND LIST FOR SUBMIT PROGRAM
LIST1:	TE(.ACCOU,<ACCOUNT>)		;ACCOUNT NUMBER FOR SUBJOB LOGIN
	TE(.AFTER,<AFTER>)		;TIME JOB IS TO WAIT UNTIL
	TE(.JBMOD,<CHANGE>)		;CHANGE JOB PARAMETERS
;;;	TE(.CLEAR,<CLEAR>,ENASEE!ENADO) ;CLEAR QUEUE
	TE(.CTL,<CONTROL>)		;CONTROL FILE
	TE(.CPUT,<CPU>)			;CPU TIME MAX FOR JOB
	TE(.CTL,<CTL>)			;CONTROL FILE
	TE(.DESUB,<DESUBMIT>)		;DESUBMIT BATCH JOB
;;;	TE(.DIREC,<DIRECT>,ENASEE!ENADO)	;DIRECT SUBMIT TO QUEUE
	TE(.DSABL,<DISABLE>,WHLSEE!WHLDO)	;DISABLE CAPABILITIES
	TE(.ELTIM,<ELAPSED>)		;MAXIMUM ELAPSED TIME JOB CAN RUN
	TE(.ENABL,<ENABLE>,WHLSEE!WHLDO)	;ENABLE CAPABILITIES
	TE(.EXIT,<EXIT>)		;LEAVE SUBMIT
	TE(.GO,<GO>)			;GO DO THE SUBMIT
	TE(.RUNIN,<IN>)			;RUN JOB IN XXX HRS, MIN, OR SEC
	TE(.CTL,<INPUT>)		;SAME AS CTL
IFN IMSLOG,<
	TE(.LABEL,<LABEL>)		;SET LOG FILE LABELLING FORMAT
	>
	TE(.LENGTH,<LENGTH>)		;SET LENGTH OF LOG FILE
	TE(.LIST,<LIST>)		;LIST SUBMIT STATUS/PARAMETERS
	TE(.LOAD,<LOAD>)		;LOAD AVERAGE THRESHOLD
	TE(.LOG,<LOG>)			;SPECIFY LOG FILE
	TE(.MESS,<MESSAGE>)		;SEND MESSAGES TO SUBMITTER
	TE(.JBMOD,<MODIFY>)		;CHANGE JOB PARAMETERS
	TE(.NO,<NO>)			;START OF NEGATE COMMAND
	TE(.NOTFY,<NOTIFY>)		;NOTIFY USER AT BEGINING AND END OF JOB
	TE(.LOG,<OUTPUT>)		;SAME AS LOG
IFN	SKUSER<
	TE(.PRIO,<PRIORITY>)		;RUN WITH NORMAL SCHEDULING
>		;END OF IFN SKUSR
	TE(START,<RESET>)		;RESTART SUBMIT JOB
	TE(.RUNT,<RUNTIME>)		;CPU TIME MAX FOR JOB
	TE(.BSTAT,<STATUS>)		;STATUS OF BATCH SYSTEM
	TE(.TIME,<TIME>)		;MAXIMUM ELAPSED TIME JOB CAN RUN
	0				;END LIST


IFN IMSLOG,<
; Following are the subcommand lists for the IMSLOG LABEL command

LIST3:	TE(.LALWY,<ALWAYS>)		;LABEL ALL LINES - OLD FORMAT
	TE(.LEVRY,<EVERY>)		;EVERY # LOG LINES
					;      # SEC SINCE LAST LABEL
	TE(.LNEVR,<NEVER>)		;OMIT LABELS ENTIRELY
	TE(.LSUBS,<SUBSYSTEM>)		;LABEL SUBSYSTEM CHANGES ONLY
	0

LIST4:	TE(.LALIN,<LINES>)		;INPUT UNITS ARE LOG LINES
	TE(.LASEC,<SECONDS>)		;INPUT UNITS ARE SECONDS
	0
	>		;END OF IMSLOG CONDITIONAL

; SUBCOMMANDS FOR "NO" COMMAND
LIST5:
IFN	IMSLOG,<
	TE(.LNEVR,<LABELS>)
	>		;END IMSLOG CONDITIONAL
	TE(.NNTMG,<MESSAGE/NOTIFY>)
	TE(.NNTMG,<NOTIFY/MESSAGE>)
	0


; SUBCOMMANDS FOR SUBMIT STATUS
LIST6:	TE(.BSALL,<ALL>)
	TE(.STATU,<QUEUE>)
	0
	>		;END OF SBMTSW CONDITIONAL - SUBMIT COMMAND LIST



IFE	SBMTSW,<
	;MAIN COMMAND LIST FOR CONTROL PROGRAM - MACRO DEFINED IN PARAMS
	;AND USED ALSO BY BATCON

LIST1:	CTLLST				;PRIMARY COMMAND AND DISPATCH LIST

	PURGE	CTLLST

	>		;END OF SBMTSW CONDITIONAL 


;SUBCOMMAND LIST FOR "RUN IN" COMMAND UNITS
LIST2:	TE(.RIDYS,<DAYS>)		;UNITS = DAYS
	TE(.RIHRS,<HOURS>)		;UNITS = HOURS
	TE(.RIHRS,<HRS>)
	TE(.RIMIN,<MINUTES>)		;UNITS = MINUTES
	TE(.RISEC,<SECONDS>)		;UNITS = SECONDS
	0



IFE	SBMTSW,<
;THESE ARE THE SUBCOMMANDS FOR THE STATUS COMMAND

LIST3:	TE(.BSALL,<ALL>,WHLSEE!WHLDO)		;STATUS OF BATCON PROGRAM
	TE(.SBATC,<BATCON>,WHLSEE!WHLDO)	;STATUS OF BATCON PROGRAM
	TE(.STATU,<QUEUE>,WHLSEE!WHLDO)		;STATUS OF BATCH QUEUE
	TE(.BSTRH,<TRASH>,WHLSEE!WHLDO)		;STATUS OF TRASH QUEUE
	0

;THESE ARE THE SUBCOMMANDS FOR THE CLEAR COMMAND

LIST4:	TE(.CBATC,<BATCON>,WHLSEE!WHLDO)	;CLEAR BATCON
	TE(.CQUE,<QUEUE>,WHLSEE!WHLDO)		;CLEAR BATCH QUEUE
	0

	>		;END OF SBMTSW CONDITIONAL - CONTROL COMMAND LIST

	PURGE	CQQ,TE




;NAMES OF QUEUE FILE AND QUEUE WORK FILE
	IFE	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCH.QUEUE;P777740/
TQNAME:	ASCIZ	/<BATCH>BAD-ENTRY.QUEUE;P777700/
IFE FDBSEQ,<
SEQLOK:	ASCIZ	/<BATCH>JOB-SEQUENCE.LOCK;P777760/
	>
JOBFS:	XWD	440700,[ASCIZ /<BATCH>JOB.*;*/]
DJOBS:	XWD	440700,[ASCIZ /<BATCH>DJOB.*;*/]
CJOBS:	XWD	440700,[ASCIZ /<BATCH>CJOB.*;*/]
	>
	IFN	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCHTEST.QUEUE;P777740/
TQNAME:	ASCIZ	/<BATCH>TBAD-ENTRY.QUEUE;P777700/
IFE FDBSEQ,<
SEQLOK:	ASCIZ	/<BATCH>TJOB-SEQUENCE.LOCK;P777760/
	>
JOBFS:	XWD	440700,[ASCIZ /<BATCH>TESTJOB.*;*/]
DJOBS:	XWD	440700,[ASCIZ /<BATCH>TESTDJOB.*;*/]
CJOBS:	XWD	440700,[ASCIZ /<BATCH>TESTCJOB.*;*/]
	>


;INTERRUPT SERVICE STUFF
LEVTAB:	EXP	LEV1PC,LEV2PC,LEV3PC
CHNTAB:	3,,CTLO				;^O ON CHANNEL 0
	3,,CTLC				;^C ON CHANNEL 1
	REPEAT ^D34,<0>


;LITERAL POOL
	LIT
;IMPURE DATA AND WORK AREAS

;INTERRUPT RETURN PC'S
LEV1PC:	0
LEV2PC:	0
LEV3PC:	0


;LOCATIONS FOR CMDRDR.
DETSW:	0				;SWITCH SET IF JOB DETACHED
CTLCSW:	0				;SWITCH SET IF ^C HIT DURING BLACKOUT
ALIST:	BLOCK	1			;POINT TO LIST OF POSSIBLE CMDS
CAPS:	BLOCK	1			;POSSIBLE CAPABILITIES,,ENABLED.
SCHRNG:	0				;START OF LEGAL CHARACTER RANGE - CMDRDR
ECHRNG:	0				;END OF LEGAL CHARACTER RANGE -CMDRDR
MATCNT:	0				;MATCH COUNT IN COMMAND LIST SCAN
MATIND:	0				;INDEX OF LAST COMMAND MATCH
EOCCH:	BLOCK	1			;END COMMAND CHARACTER
EOCPTR:	BLOCK	1			;POINTER TO LAST CHAR IN COMMAND
					;MOVED TO PCMD2 FOR NEXT FIELD
PCMD:	BLOCK	1			;POINT TO FULL COMMAND STRING
					;USED BY ^R ROUTINE
PCMD2:	BLOCK	1			;POINTER TO STORE NEW FIELD WITH
HELPAD:	BLOCK	1			;ADDRESS OF HELP ROUTINE FOR CMDRDR
LSTJOB:	0				;NUMBER OF LAST JOB ENTERED BY THIS
					;RUN
LOGNAM:	BLOCK	^D8		;STRING BLOCK FOR LOGFILE NAME
DESUB:	BLOCK	1		;FLAG TO SPECIFY DE-SUBMITTING OF ENTRY
FOUND:	BLOCK	1		;NUMBER OF ENTRIES DELETED
;	VARIABLES USED IN DELETING ENTRIES FROM QUEUE
QCODE:	BLOCK	1
QJFN:	BLOCK	1

IFE FDBSEQ,<
SEQJFN:	BLOCK	1			;JFN OF JOB SEQUENCE FILE
					;JBSQLK
	>

OLDQ:	BLOCK	1
QPNTR:	BLOCK	1
LOGJFN:	BLOCK	1			;LOG FILE JFN
SIZE:	BLOCK	1			;SIZE OF QUEUE
FFLAG:	BLOCK	1			;PRINTOUT FLAG
TTYJNM:	BLOCK	1			;TTYJOB TABLE INDEX
COUNT:	BLOCK	1			;COUNT OF ACTIVE TTY'S
JBJFN:	BLOCK	1			;JFN FOR NAMES OF JOBS WAITING TO BE QUEUED
SUBACA:	BLOCK	1			;SAVE AC A TEMPORARILY
SUBLAD:	BLOCK	1			;SUBCOMMAND DISP LIST ADDRESS
MXLDAV:	BLOCK	1			;MAX OF 1, 5, & 15 MIN LA'S
NJOBTB:	BLOCK	1			;# JOBS IN JOBDIR TABLE
JBDRTB:	BLOCK	NJOBS			;STORAGE FOR JOBDIR TABLE

IFE	SBMTSW,<
RECOG:	BLOCK	1			;FLAG IF RECOGNITION WAS SPECIFIED
STRPTR:	BLOCK	1			;TEMP STORAGE OF STRING POINTER
	>		;END OF SBMTSW CONDITIONAL - EXTRA CTL STORAGE LOCS

IFE FDBSEQ,<
JBSQOK:	BLOCK	1			;FLAG THAT JOB SEQ FILE READ OK
JBBITS:	BLOCK	NJBWRD			;STORAGE FOR JOB BIT TABLE
	>		;END OF FDBSEQ CONDITIONAL


IFN	SBMTSW,<
IFN	STRACT,<
IFN	TNX131,<
;STORAGE REQUIRED FOR STRING ACCOUNTING
UACBLK:	BLOCK 20		;AC ARG BLOCK
	>
	>
	>		;END OF SBMTSW CONDITIONAL - SUBMIT ACCTING BUFFER


;THE COMMAND LINE
COMMAN:	BLOCK	20			;HOPE WON'T OVERFLOW THIS

;THE QUEUE ENTRY WE ARE BUILDING

;FILENAME FOR INDIRECT SUBMIT
JBNAME:	BLOCK	12			;STORAGE FOR IT


IFN	SBMTSW,<
JBBLK:	400000,,0			;BLOCK FOR LONG GTJFN
	377777,,377777			;FOR JOB REQUEST FILE
	0				;DSP DEVICE
	POINT	7,[ASCIZ /BATCH/]	;DSP DIRECTORY
	IFN	DBGFIL,<
	POINT	7,[ASCIZ /TESTJOB/]
	>
	IFE	DBGFIL,<
	POINT	7,[ASCIZ /JOB/]		;DSP NAME
	>
	POINT	7,JBNAME		;DSP EXT
	500000,,777760			;DSP PROTECTION
	0				;DSP ACCOUNT
	0				;DESIRED JFN (NOT SPECIFIED)

DJBBLK:	400000,,0			;BLOCK FOR LONG GTJFN
	377777,,377777			;FOR JOB REQUEST FILE
	0				;DSP DEVICE
	POINT	7,[ASCIZ /BATCH/]	;DSP DIRECTORY
	IFN	DBGFIL,<
	POINT	7,[ASCIZ /TESTDJOB/]
	>
	IFE	DBGFIL,<
	POINT	7,[ASCIZ /DJOB/]	;DSP NAME
	>
	POINT	7,JBNAME		;DSP EXT
	500000,,777760			;DSP PROTECTION
	0				;DSP ACCOUNT
	0				;DESIRED JFN (NOT SPECIFIED)

	>		;END OF SBMTSW CONDITIONAL - SUBMIT LNG GTJFN TBLES


IFE	SBMTSW,<
CJBBLK:	400000,,0			;BLOCK FOR LONG GTJFN
	377777,,377777			;FOR JOB REQUEST FILE
	0				;DSP DEVICE
	POINT	7,[ASCIZ /BATCH/]	;DSP DIRECTORY
	IFN	DBGFIL,<
	POINT	7,[ASCIZ /TESTCJOB/]
	>
	IFE	DBGFIL,<
	POINT	7,[ASCIZ /CJOB/]	;DSP NAME
	>
	POINT	7,JBNAME		;DSP EXT
	500000,,777700			;DSP PROTECTION
	0				;DSP ACCOUNT
	0				;DESIRED JFN (NOT SPECIFIED)

	>		;END OF SBMTSW CONDITIONAL - CTL LONG GTJFN TABLE


; Buffer for building Q entry
QENT:	BLOCK	QESIZE		;Q ENTRY


PSEUD1:	PTYRNG				 ;=-# PTYS,,1ST PTY #

;OUR PUSH DOWN LIST
PDL:	BLOCK	PDLL+1			;STACK
JOBSTR:	BLOCK	10			;BUFFER FOR BUILDING JOB NAME

;GENERATED VARIABLES
	VAR

	LIT

HICOR==<<<.+777>/1000>*1000>		;PAGE ABOVE TOP OF PROGRAM

IFE FDBSEQ,<
; Following is a control page to set a lock between various shared users
; of SUBMIT.  Locate it high enough above the symbol table.

CTLLOC==HICOR+5000
JBSQLK==CTLLOC				;LOCK ON THIS PAGE, -1 IF FREE
FMXJBN==CTLLOC+1			;STORAGE FOR NEXT AVAILABLE JOB #
FJBBIT==CTLLOC+2			;ARRAY (NJBWRD LONG) FLAGGING JOBS
					; ASSIGNED IN Q BY BIT POSITION
CTLPAG==CTLLOC/1000			;CONTROL PAGE NUMBER
TMPLOK==CTLLOC+1000			;USE NEXT PAGE FOR TEMP BUFFER
	>	;END OF FDBSEQ CONDITIONAL


;	ENTIRE QUEUE IS READ INTO THIS BUFFER WHEN DISPLAYING STATUS
;	DON'T PUT ANYTHING VALUABLE AFTER IT
FENT==HICOR+10000

	END	START
