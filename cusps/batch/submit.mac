;<BATCH>SUBMIT.MAC	3/5/76 16:29:27		EDIT BY RINDFLEISCH
;<BATCH>SUBMIT.MAC;102    15-AUG-75 11:38:17    EDIT BY MOUTON
;ADDED LENGTH AND TIME PARAMETERS
;<BATCH>SUBMIT.MAC;97     4-AUG-75 17:38:29    EDIT BY UNTULIS
;MOVED QLPEND LABEL,CORRECTED NNOT CODE AND DELETED REMNANT CODE
;<BATCH>SUBMIT.MAC;96     1-AUG-75 23:52:34    EDIT BY UNTULIS
;FIXED ILLEGAL VERSION PROBLEM FOR JOB AND DJOB
;<BATCH>SUBMIT.MAC;84    14-JUL-75 15:15:08    EDIT BY UNTULIS
;ADD LOAD AVERAGE THRESHOLD CODE
;ADD DEFAULT LOG AND SMART TIME CODE FROM LIEB@SUMEX
;<BATCH>SUBMIT.MAC;55     4-JUL-75 13:43:43    EDIT BY UNTULIS
;ADDED DESUBMIT COMMAND AND CODE
;ADDED CLEAR QUEUE AND EXIT COMMANDS
;<BATCH>SUBMIT.MAC;37    24-JUN-75 12:14:41    EDIT BY UNTULIS
;<BATCH>SUBMIT.MAC;36    17-JUN-75 10:49:13    EDIT BY UNTULIS
;<BATCH>SUBMIT.MAC;32    31-MAY-75 16:23:03    EDIT BY UNTULIS
; ADD JOBSTT SLOT IN QENTRY (JOB START TIME)
;<BATCH>SUBMIT.MAC;18     9-APR-75 11:21:06    EDIT BY UNTULIS
;ADDED CODE TO TOUCH LOG FILE TO DEFINE VERSION
;<BATCH>SUBMIT.MAC;5    10-FEB-75 14:03:51    EDIT BY LYNCH
;MAKE ACOUNT STRING CODE CONDITIONAL
;<BATCH>SUBMIT.MAC;3    10-FEB-75 10:07:12    EDIT BY UNTULIS
;EXPAND QENT ONE WORD FOR ACCOUNT STRINGS
;CHANGE .ACCOU FOR ACCOUNT STRINGS
;<LARSON>SUBMIT.MAC;64    31-DEC-74 14:16:12	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;63    31-DEC-74 13:51:36	EDIT BY LARSON
;REMOVED CHFDB TO LOWER ACCESS TO NEW JOB FILE BECAUSE
;CAN'T DO IT WITHOUT OWNERSHIP RIGHTS
;<LARSON>SUBMIT.MAC;62    31-DEC-74 13:10:41	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;61    31-DEC-74 13:02:17	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;60    31-DEC-74 12:29:01	EDIT BY LARSON
;<LARSON>XSUBMIT.MAC;2    31-DEC-74 12:10:31	EDIT BY LARSON
;PUT IN JFNS ON FAILING JOB ENTRY FILE NAME
;<LARSON>SUBMIT.MAC;59    31-DEC-74 11:08:06	EDIT BY LARSON
;PUT IN PROTECTION STUFF FOR INDIRECT SUBMIT JOB FILES.
;<LARSON>SUBMIT.MAC;58    30-DEC-74 13:59:17	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;57    30-DEC-74 09:42:32	EDIT BY LARSON
;PUT IN DIRECT SUB COMMAND AND INDIRECT SUBMIT DEFAULT
;<LARSON>SUBMIT.MAC;56    26-DEC-74 14:07:13	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;55    26-DEC-74 13:58:12	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;54    26-DEC-74 12:35:18	EDIT BY LARSON
;FIXED AMBIG TO GIVE THE ? ERROR
;<LARSON>SUBMIT.MAC;53    26-DEC-74 11:57:10	EDIT BY LARSON
;PUT IN HANDLING OF DEL ON INPUT, MOVED CTL CHAR CHECK OUT OF
;MAIN LOOP IN CMDRDR
;<LARSON>SUBMIT.MAC;52    26-DEC-74 11:49:14	EDIT BY LARSON
;PUT IN 'LEGAL DELIMITERS' AT EOC ROUTINE.
;PUT IN CONFRM
;PUT IN AFTER COMMAND
;PUT IN ACCOUNT COMMAND
;<LARSON>SUBMIT.MAC;49    23-DEC-74 12:12:34	EDIT BY LARSON
;PUT PROTECTION IN QNAME
;<LARSON>SUBMIT.MAC;48    23-DEC-74 11:28:01	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;47    23-DEC-74 11:21:54	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;46    23-DEC-74 10:45:28	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;45    23-DEC-74 10:13:58	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;44    23-DEC-74 10:04:44	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;43    23-DEC-74 08:44:23	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;42    20-DEC-74 22:16:16	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;41    20-DEC-74 21:35:27	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;40    20-DEC-74 15:17:05	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;39    20-DEC-74 15:11:18	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;38    20-DEC-74 15:04:14	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;37    20-DEC-74 13:02:33	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;36    17-DEC-74 15:36:35	EDIT BY LARSON
;<LARSON>SUBMIT.MAC;35    10-DEC-74 09:43:36	EDIT BY LARSON
	TITLE	SUBMIT	BATCH JOB SUBMITTER
	SUBTTL	SUBTTL	BATCH SUBMISSION ROUTINE
	XALL

	SEARCH	STENEX

;;;;;;;;;;;;;;;;;;;
;;REPEAL OHMS LAW;;
;;    455-1127   ;;
;;;;;;;;;;;;;;;;;;;

;GENERAL PROGRAM EQUATES
PDLL==^D47				;SIZE OF PUSH DOWN LIST
IFNDEF	LPTLOG,<LPTLOG==1>	;DEFAULT LOG FILE IS LPT
IFNDEF TNX131,<TNX131==0>	;DEFAULT TO 133 AND ABOVE
SBMTSW==0			;SBMTSW = 0  => PRODUCE SUBMIT
				;	= 1  => PRODUCE BATCH CONTROL PGM


;OPDEFS
OPDEF	CALL	[PUSHJ P,0]
OPDEF	RET	[POPJ  P,0]
OPDEF	ERR1	[1B8]			;MAIN USER ERROR UUO
OPDEF	TENXER	[2B8]			;PRINT LAST TENEX ERROR
OPDEF	NOISE	[3B8]			;NOISE WORD PROCESSOR
OPDEF	CONFRM	[4B8]			;CONFIRM FUNCTION
OPDEF	WAIT10	[CALL	[PUSH P,A
			MOVEI	A,^D10K	;TEN SECONDS
				DISMS
				POP  P,A
				RET]]

;MACRO DEFINITIONS
	DEFINE	BUG(STR)<
	XLIST
	JRST	[PUSHJ P,BUGMSG
		ASCIZ /STR/]
	LIST
	>				;END BUG MACRO
	DEFINE	ERROR(STR,ADR<0>)<
	XLIST
	ERR1	[ADR,,[ASCIZ /STR/]]
	LIST
	>
	DEFINE	NOISEM(STR)<
	XLIST
	NOISE	[ASCIZ /STR/]
	LIST
	>
 DEFINE		.SAVE(NUM)<
	XLIST
	QQ==1
	REPEAT	NUM,<
	PUSH	P,QQ
	QQ==QQ+1
	>LIST>

   DEFINE	RSTR(NUM)<
	XLIST
	QQ==NUM
	REPEAT	NUM,<
	POP	P,QQ
	QQ==QQ-1
	>LIST>

;
;	.JSYSR	JSYS ERROR PRINT ROUTINE
;
DEFINE	.JSYSR<
JSYSER:
	.SAVE	3
	  HRRZ	2,1
	  MOVEI	1,101
	  HRLOI	2,400000
	  MOVE	3,[XWD -40,400000]
	  ERSTR
	  JFCL
	  JFCL
	  PPRINT	< AT >
	  HRRZ	B,-4(P)
	  SUBI	2,1
	  MOVEI	C,10
	  MOVEI	A,101
	  NOUT
	  JFCL
	  RSTR	3
	  RET>
;
;	FSOUT	STRING TO FILE
;		STRING - STRING ADDRESS (STRING CANNOT CONTAIN ","'S)
;		JFN - FILE JFN (IF NOT SPECIFIED , ASSUMED IN AC1)
;			 (ASSUME "0" TERMINATOR)
;
DEFINE	FSOUT	(STRING,JFN)<
	  IFNB	<JFN>,<MOVE 1,JFN>
	  HRROI	2,[ASCIZ /'STRING'/]
	  SETZ	C,
	  SOUT	>
DEFINE	PPRINT (A)<
	XLIST
	HRROI	1,[ASCIZ "A"]
	PSOUT
	LIST>
;INITALIZATION
START:	RESET				;CLEAN UP THE WORLD
	MOVE	P,[IOWD PDLL,PDL]	;SET UP STACK

;INITALIZE LUUO TRAP
	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

;GET CAPABILITIES
	MOVEI	A,400000		;THIS PROCESS
	RPCAP				;READ OUR CAPABILITIES
	MOVEM	C,CAPS			;SAVE ENABLED IN RH
	HRLM	B,CAPS			;SAVE POSSIBLE IN LH

IFE	SBMTSW,<
	TRNN	B,1B18+1B19		;IS HE A WHEEL OR OPER?
	ERROR	(<SORRY, WHEELS ONLY>,.EXIT)	;TOUGH LUCK
	>


;SET UP INTERRUPT SYSTEM TO RESTART WITH ^O
	MOVEI	A,400000
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR

	HRLZI	A,"O"-100		;SET UP ^O ON CHANNEL 0
	ATI

	MOVEI	A,400000
	MOVSI	B,(1B0)			;ACTIVATE CHANNEL 0
	AIC

	EIR				;ENABLE INTERRUPTS

;SET UP DEFAULTS
STRT1:	SETZM	QENT			;CLEAR Q ENTRY
	MOVE	A,[QENT,,QENT+1]
	BLT	A,QENT+QESIZE-1		;QUICKLY

;FIND OUT DIRECTORY NUMBER FOR BATCH JOB, SHOULD BE PROTECTED FROM
;MEDDLING ONCE SET.
	GJINF				;GET INFO ABOUT OURSELVES
	MOVEM	A,QENT+USRDIR		;SAVE OUR DIRECTORY NUMBER

	MOVE	B,A			;WANT IN STRING FORM TOO
	HRROI	A,JBNAME
	DIRST
	BUG(<DIRST FAILED ON LOGGED IN DIRECTORY>)

IFE	SBMTSW,<
	SETOM	QENT+COMCOD	      	;ZERO COMMAND CODE
	SETOM	QENT+COMPAR	      	;ZERO COMMAND VALUE
	>		;END OF CONDITIONAL TO INIT BATCH CONTROL

IFN	SBMTSW,<
; SET UP DEFAULT LOAD AVERAGE
	MOVE	A,[MAXLA]
	MOVEM	A,QENT+LOADAV

;SET UP DEFAULT LOGLNS(# OF LINES/LOG FILE)
	MOVE	A,[DEFLLN]
	MOVEM	A,QENT+LOGLNS

;INITALIZE SWITCHES
	IFN	SRINOT,<
	SETOM	QENT+NOTFY		;SET DEFAULT TO NOTIFY
	>
	SETZM	DIRECT#			;INDIRECT SUBMIT TO QUEUE
	SETZM	DESUB			;ASSUME SUBMIT
	SETOM	QENT+PRIOR			;BATCH PRIORITY

	IFN STRACT,<
	PUSHJ	P,DEFACT		;GET DEFAULT ACCOUNT STRING
	>
	IFN	LPTLOG,<
	MOVE	A,[ASCII /LPT:/]	;DEFAULT LOG FILE
	MOVEM	A,QENT+LOGFIL		;SET IT
	>

	MOVE	A,[DEFETM]		;MAX ELAPSED DEFAULT (12 HRS)
	MOVEM	A,QENT+ETIME		;SET IT
	MOVE	A,[DEFRTM]		;MAX CPU TIME JOB CAN RUN
	MOVEM	A,QENT+RTIME		;SET IT
	SETZM	QENT+CTLFIL		;SAY WE HAVE NO CTL FILE
	>		;END OF CONDITIONAL TO INIT SUBMIT

	IFN	SRIPTY,<
;FIGURE OUT WHERE THE PSEUDOTTYS ARE AT SRI
	MOVE	A,['LOGDES']
	SYSGT
	MOVE	A,B		;ENTRY 1 IS 'JOB0TT'
	HRLI	A,1
	GETAB
	JRST	NOPTYE		;FUNNY
	AOS	A		;JOB0TT+1 IS FIRST PTY
	TRZ	A,400000	;JUST THE INDEX
	MOVE	C,A		;SAVE IT
	MOVE	A,['LHOSTN']
	SYSGT
	MOVE	A,B
	HRLI	A,110		;ENTRY 1 IS 1ST NETWORK TTY
	GETAB
	JRST	NOPTYE		;STRANGE
	TRZ	A,400000	;INDEX ONLY
	SUBM	C,A		;GET -#PTY'S IN C
	HRL	C,A		;GET -#PTYS,,1ST-PTY IN C
	MOVEM	C,PSEUD1	;SAVE IN PSEUD1
NOPTYE:	;USE WHATS IN PSEUD1 NOW IF CANT FIND PTYS ECL STYLE
	>			;END OF IFN SRIPTY
;READ THE MAIN COMMAND IN

SPRMPT:	SETZM	COMPRG			;FLAG NO COMMAND IN PROGRESS
PROMPT:	MOVE	P,[IOWD PDLL,PDL]	;BE SURE OF STACK, ERROR EXITS
					;COULD HAVE LEFT IT MESSED UP.
	PUSHJ	P,CCRLF			;CRLF IF NEEDED
	MOVEI	A,"*"			;PROMPT CHAR
	MOVE	B,[POINT 7,COMMAN]	;POINT TO COMMAND
	MOVEM	B,PCMD			;STORE FOR ^R ROUTINE
	IDPB	A,B			;STORE THE * FOR ^R
	MOVEM	B,PCMD2			;POINT TO THIS COMMAND
	PBOUT				;GIVE IT TO USER
PROMP2:	MOVEI	A,LIST1			;POINT TO MAIN COMMAND LIST
	MOVEM	A,ALIST			;SAVE FOR SCAN ROUTINE

	PUSHJ	P,CMDRDR		;READ THE COMMAND, RECOGNIZE IT
	JRST	SPRMPT			;HE DID ^X
	JRST	[MOVEI	A,7		;HE DID ^A OFF RANGE
		 PBOUT			;RING BELLS
		 JRST	PROMP2]
	JRST	SPRMPT			;HE ENTERED UNRECOGNIZABLE COMMAND
	BUG(<HELP RETURN FROM CMDRDR>)	;OOPS
	JRST	.GO			;HE JUST HIT RETURN
	JRST	GOTONE			;GOOD COMMAND - GO DO IT

IFE	SBMTSW,<
;HERE WE HAVE A SUBCOMMAND

SUBPRM:	MOVEI	A,101			;DO WE NEED A NEW LINE PROMPT
	MOVE	B,EOCCH			;WAS LAST CHAR AN EOL?
	CAIN	B,37
	JRST	[HRROI	A,[ASCIZ /**/]
		 PSOUT
		 JRST	.+1]

	SETZ	A,			;SET UP FOR COMMAND PROCESSOR
	SETZM	COMMAN			;AS BEFORE
	MOVE	B,[POINT 7,COMMAN]
	MOVEM	B,PCMD
	MOVEM	B,PCMD2

PROMP3:	MOVE	A,SUBLAD		;NEW COMMAND LIST FROM STACK
	MOVEM	A,ALIST
	PUSHJ	P,CMDRDR
	JRST	SPRMPT			;^X - RESET TO 0
	JRST	[MOVEI	A,7		;^A - OFF END OF RANGE, BELLS
		 PBOUT
		 JRST	PROMP3]
	JRST	SPRMPT			;UNRECOGNIZED COMMAND
	BUG	(<HELP RETURN FROM CMDRDR>)
	ERROR	(<SUBCOMMAND REQUIRED>,SPRMPT)
	JRST	GOTSUB
	>		;END OF SBMTSW CONDITIONAL FOR SUBCOMMANDS



;WE COME HERE IF WE GOT A GOOD COMMAND.
;LAST CHAR IS IN CMDTRM.
;POINTER TO LIST ENTRY IS IN A
GOTONE:	
GOTSUB:	MOVE	B,1(A)			;GET FLAGS,,ADR
	JRST	(B)			;GO TO ROUTINE



IFE	SBMTSW,<
;ROUTINE TO FILL IN COMMAND CODE AND TEXT INTO FILE RECORD

FILLIT:	PUSH	P,A			;SAVE TABLE ADDRESS
	PUSH	P,B			;SAVE WORKING AC'S
	PUSH	P,C

	SUBI	A,LIST1			;COMPUTE COMMAND INDEX
	LSH	A,-1
	MOVEM	A,QENT+COMCOD		;STORE IT

	SETZM	QENT+COMNAM		;CLEAR FIELD FOR COMMAND TEXT
	MOVE	A,[XWD QENT+COMNAM,QENT+COMNAM+1]
	BLT	A,QENT+COMCOD-1

	HRROI	A,QENT+COMNAM		;OUTPUT COMMAND STRING
	MOVE	B,-2(P)			;RECOVER LIST ADDRESS
	HRRO	B,0(B)			;MAKE STRING POINTER
	SETZ	C,
	SOUT
	SETOM	COMPRG			;SHOW COMMAND ENTERED

	POP	P,C			;RESTORE WORKING AC'S
	POP	P,B
	POP	P,A			;RECOVER LIST ADDRESS

	POPJ	P,			;RETURN
	>		;END OF SBMTSW CONDITIONAL FOR CONTROL COMMAND CODE



IFE	SBMTSW,<
;ROUTINE TO FILL IN A POSITIVE JOB NUMBER IN THE COMMAND PARAMETER
GETJBN:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C

	MOVEI	A,101			;IF AT START OF LINE, PROMPT
	MOVE	B,EOCCH
	CAIN	B,37
	JRST	[HRROI	A,[ASCIZ /** JOB # /]
		 PSOUT
		 JRST	.+1]
	MOVEI	C,^D10			;GET A DECIMAL NUMBER
	NIN
GETJB0:	ERROR	(<INVALID JOB NUMBER>,SPRMPT)	;BAD INPUT
	SKIPG	B			;MAKE SURE IT IS POSITIVE
	JRST	GETJB0			;NOPE, TOO BAD
	MOVEM	B,QENT+COMPAR		;GOOD ONE, STORE IT

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN
	>		;END OF SBMTSW CONDITIONAL FOR CONTROL JOB NUMBER




;COMMAND ERROR - GENERAL COMMAND ABORT ROUTINE
CMDERR:	HRROI	A,[ASCIZ /  <?>/]	;COMPLAIN
	PSOUT				;SEND MSG TO USER
	JRST	SPRMPT			;TRY AGAIN
;COMMAND EXECUTION ROUTINES.
;EVERYTHING ON THIS PAGE IS FOR BATCON CONTROL PROGRAM


IFE	SBMTSW,<
;COMMAND FOR SNAPSHOT DUMP
.BDUMP:	NOISEM	<OF BATCON AND INFERIOR FORKS>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO HALT BATCON TEMPORARILY
.BHALT:	NOISEM	<BATCON TEMPORARILY>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO RESUME BATCON AFTER HALT
.BRESM:	NOISEM	<BATCON RUNNING>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO FORCE BATCON RESTART
.BRSTR:	NOISEM	<BATCON IN CURRENT CORE IMAGE>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO FORCE BATCON RELOAD
.BRLOD:	NOISEM	<FRESH BATCON IMAGE AND RESTART>
	SETZM	QENT+COMPAR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO PRINT STATUS OF BATCON OR THE BATCH QUEUE
.BSTAT:	NOISEM	<OF>
	MOVEM	A,SUBACA		;SAVE INDEX
	MOVEI	A,LIST2			;ADDRESS OF SUBCOMMAND LIST
	MOVEM	A,SUBLAD
	JRST	SUBPRM			;GET NEXT PART


;SETUP COMMAND FOR BATCON STATUS OR BATCON CLEAR
.CBATC:
.SBATC:	SETZM	QENT+COMPAR
	MOVE	A,SUBACA		;RESTORE LIST POINTER
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMAND TO GO TO A GIVEN ADDRESS
.GOTO:	NOISEM	<BATCON ADDRESS>
	MOVEM	A,SUBACA		;SAVE COMMAND PTR
	MOVEI	A,101			;GET OCTAL ADDRESS
	MOVEI	C,10
	NIN
	ERROR	(<INVALID ADDRESS>,SPRMPT)
	SKIPG	B			;IS IT POS DEF
	ERROR	(<ADDRESS MUST BE POSITIVE>,SPRMPT)
	MOVEM	B,QENT+COMPAR		;OK

	MOVE	A,SUBACA		;RESTORE COMMAND PTR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT


;COMMANDS TO:
;	DEFER JOB EXECUTION INDEFINITELY - DEFER
;	RESET QUEUE STATUS DATA - RESET
;	FREEZE A RUNNING JOB - FREEZE
;	MELT A FROZEN RUNNING JOB - MELT
;	PURGE A JOB - PURGE
;	FORCE START A JOB - START
;
;ALL HAVE THE FORM:	COMMAND + JOB NUMBER

.DEFER:
.RESET:
.FREEZ:
.MELT:
.PURGE:
.START:	NOISEM	<JOB #>
	PUSHJ	P,GETJBN		;GET JOB NUMBER
	PUSHJ	P,FILLIT		;OK, FILL IN DATA
	JRST	PROMPT			;GO FOR MORE INPUT


;COMMAND TO CHANGE BATCON ENTFLG SETTING
.ENTFG:
	NOISEM	<SETTING:
   -1          ANY USER (DEFAULT)
    0          NO USERS
  DIR NUM (8)  SINGLE USER
  USER NAME    SINGLE USER         =>

	MOVEM	A,SUBACA		;SAVE LIST PTR
	MOVEI	A,101			;DO WE NEED A NEW LINE PROMPT
	MOVE	B,EOCCH			;WAS LAST CHAR AN EOL?
	CAIN	B,37
	JRST	[HRROI	A,[ASCIZ /** ENTFLG VALUE /]
		 PSOUT
		 JRST	.+1]

	SETZM	FENT			;NOW GET ARGUMENT
	HRROI	A,FENT
.ENTF0:	SETZM	RECOG			;START WITH NO NAME RECOGNITION
	MOVEI	B,100			;PRIMARY INPUT
	SETZ	C,
	PSTIN

	LDB	B,A			;GET TERMINATOR
	DPB	C,A			;SET IT TO NULL
	BKJFN
	BUG	(<.ENTFG: BKJFN ERROR>)
	MOVEM	A,STRPTR		;SAVE THE END OF INPUT
	CAIN	B,33			;WAS END <ESC>
	JRST	[SETOM	RECOG		;YES
		 JRST	.ENTF1]
	CAIE	B,15			;WAS IT <CR>
	JRST	[MOVEI	A,37		;NO - DO ONE
		 PBOUT
		 JRST	.+1]

;FIRST SEE IF INPUT CAN BE INTERPRETED AS A NUMBER

	MOVE	B,[POINT 7,FENT]
	ILDB	A,B			;GET FIRST CHAR
	SKIPN	A			;WAS IT NULL
	JRST	[SETO	B,		;YES, USE DEFAULT
		 JRST	.ENTF2]
	HRROI	A,FENT
	MOVEI	C,10
	NIN
	JRST	.ENTF1			;ERROR - GO TRY AS NAME STRING
	SKIPG	B			;NUMBER, IS IT > 0
	JRST	[SKIPE	B		;NO, < 0
		 SETO	B		;YES, MAKE IT -1
		 JRST	.ENTF2]
	HRROI	A,FENT			;>0 - SEE IF REAL DIRECTORY
	DIRST
	ERROR	(<INVALID DIRECTORY NUMBER>,SPRMPT)
	JRST	.ENTF2			;GO STORE IT

.ENTF1:	MOVE	A,RECOG			;HERE WE HAVE TO TRY INPUT AS STRING
	HRROI	B,FENT
	SETZ	C,
	STDIR
	ERROR	(<INVALID DIRECTORY NAME>,SPRMPT)
	JRST	[MOVEI	A,7		;NAME AMBIGUOUS - BELLS
		 PBOUT
		 MOVE	A,STRPTR	;RESTORE INPUT POINTER FOR MORE
		 JRST	.ENTF0]

	HRRZ	B,A			;SET UP TO STORE DIRECTORY NUMBER
	MOVE	A,STRPTR		;FINISH NAME IF ANY MORE
	SKIPE	RECOG
	JRST	[PSOUT
		 MOVEI	A,37
		 PBOUT
		 JRST	.ENTF2]
	JRST	.ENTF2

.ENTF2:	MOVEM	B,QENT+COMPAR		;STORE DIRECTORY NUMBER

	MOVE	A,SUBACA		;RESTORE LIST PTR
	PUSHJ	P,FILLIT		;FILL IN COMMAND CODE
	JRST	PROMPT			;GO FOR MORE
	>		;END OF SBMTSW CONDITIONAL FOR CONTROL COMMANDS



;EVERYTHING ON THIS PAGE IS FOR THE SUBMIT PROGRAM


IFN	SBMTSW,<
;ENABLE/DISABLE

.ENABL:	MOVEI	A,400000		;GET OUR CAPS
	RPCAP
	MOVE	C,B			;ALL POSSIBLE
	EPCAP				;TURN THEM ON
	HRL	C,B			;REBUILD CAPS WORD
	MOVEM	C,CAPS			;SAVE IT
	JRST	PROMPT

.DSABL:	MOVEI	A,400000		;US
	RPCAP				;GET OURS
	TRZ	C,-1			;TURN OFF USER CAPS
	HRRM	C,CAPS			;TELL THEY ARE OFF
	EPCAP				;TURN THEM OFF
	JRST	PROMPT



REPEAT	0,<;SPECIFY DIRECT SUBMISSION
.DIREC:		NOISEM	<SUBMISSION TO MASTER QUEUE>
	SETOM	DIRECT			;SET FLAG
	JRST	PROMPT			;GO FOR NEXT COMMAND
	>


;
.PRIO:	MOVE	A,CAPS			;GET CAPABILITIES
	TRNN	A,600000		;IS HE A ENABLED
	ERROR	(<MUST BE WHEEL TO SET PRIORITY - 1% USED>,PROMPT)
	SETZM	QENT+PRIOR		;SET TO RUN WITH NORMAL SCHEDULING
	JRST	PROMPT



;SPECIFY USER ACCOUNT TO USE FOR RUN
	IFE STRACT,<
.ACCOU:	NOISEM	<NUMBER TO RUN BATCH JOB UNDER>
	MOVEI	A,100			;GET FROM PRIMARY INPUT FILE
	MOVEI	C,12			;DECIMAL
	NIN				;READ THE NUMBER
	ERROR	<ILLEGAL FORMAT FOR NUMBER>,PROMPT
	MOVEM	B,QENT+USRACT		;SAVE ACCOUNT NUMBER
	JRST	PROMPT			;GO FOR MORE
	>
	IFN	STRACT,<
.ACCOU:	NOISEM	<STRING TO RUN BATCH JOB UNDER>
	SETZM	QENT+USRACT
	MOVE	A,[XWD QENT+USRACT,QENT+USRACT+1]
	BLT	A,QENT+USRACT+7		;CLEAR DEFAULT ACCOUNT STRING
	MOVE	B,[XWD 440700,QENT+USRACT]   ;ACCOUNT STRING STORAGE POINTER
	MOVEM	B,STRFLG		;SET UP POINTER FOR CMDRDR
	PUSHJ	P,CMDRDR			;GET ACCOUNT STRING
	JRST	.ACCRT			;^X FOUND - RETURN
	JRST	.ACCRT			;^A OFF LEFT OF LINE
	ERROR	<ILLEGAL FORMAT FOR ACCOUNT STRING>,ACCDE1
	JFCL				;? TYPED
	JFCL				;NULL STRING
.ACCRT:
	MOVE	A,QENT+USRDIR		;DIRECTORY NUMBER
	MOVE	B,STRFLG		;ACCOUNT STRING POINTER
IFE TNX131,<
	VACCT				;VERIFY ACCOUNT STRING
>
IFN TNX131,<
	PUSHJ	P,$VACCT
>
	ERROR	<ILLEGAL ACCOUNT STRING - DEFAULT ASSUMED>,ACCDEF
	SKIPE	QENT+USRACT		;IS THERE AN ACCOUNT STRING?
	JRST	ACCDE1			;YES
ACCDEF:	MOVE	A,[XWD QENT+USRACT,QENT+USRACT+1]
	BLT	A,QENT+USRACT+7		;CLEAR DEFAULT ACCOUNT STRING
	PUSHJ	P,DEFACT		;GET DEFAULT ACCOUNT STRING
ACCDE1:	SETZM	STRFLG			;CLEAR FLAG (AND STRING POINTER)
	JRST	PROMPT			;GO FOR MORE
DEFACT:		;GET DEFAULT ACCOUNT STRING FOR USER
	MOVEI	A,QENT+STRACT		;USER ACCOUNT STRING STORAGE
	MOVE	B,QENT+USRDIR		;GET USER DIRECTORY NUMBER
IFE TNX131,<
	GDACC				;OBTAIN DEFAULT ACCOUNT STRING (133-TENEX)
>
IFN TNX131,<
	PUSHJ	P,$GDACC
>
	BUG	(<CANNOT GET DEFAULT ACCOUNT STRING>)
	POPJ	P,
	>



;	SET FLAG TO SIGNAL THAT USER WISHES TO BE NOTIFIED BY MESSAGES
;	AT THE BEGINING AND END OF A BATCH JOB
.MESS:	NOISEM	<START AND TERMINATION MESSAGE>
	SETOM	QENT+MESAG
	SETZM	QENT+NOTFY		;CLEAR NOTIFY FLAG
	JRST	PROMPT



;	SET FLAG THAT USER WISHES TO BE NOTIFIED BY NOTIFY MESSAGES
;	AT BEGINIG AND END OF JOB
;
.NOTFY:	NOISEM	<START AND TERMINATION NOTIFY>
	SETOM	QENT+NOTFY
	SETZM	QENT+MESAG		;CLEAR MESSAGE FLAG
	JRST	PROMPT



;INPUT LOAD AVERAGE BELOW WHICH JOB SHOULD BE RUN
.LOAD:	NOISEM	<LOAD AVERAGE BELOW WHICH TO START>
	MOVEI	A,100			;PRIMARY INPUT
	FLIN				;GET FLOATING POINT THRESHOLD VALUE
	ERROR	(<ILLEGAL LOAD AVERAGE>,PROMPT)
	MOVE	A,CAPS			;GET CAPABILITIES
	TLNN	A,600000		;IS HE A WHEEL
	ERROR	(<MUST BE WHEEL TO SET LA - DEFAULT USED>,PROMPT)	;NO
	MOVEM	B,QENT+LOADAV		;SAVE THRESHOLD
	JRST	PROMPT



;SET FLAG THAT GIVES A MAXIMUM TIME JOB CAN RUN IN MINUTES
;
;
.TIME:	NOISEM	<MAXIMUM TIME JOB CAN RUN IN MINUTES>
	MOVEI	A,100
	MOVEI	C,^D10
	NIN
	ERROR	(<TIME NIN FAILURE>,PROMPT)
	IMULI	B,^D60000
	MOVEM	B,QENT+ETIME
	JRST PROMPT



;SET FLAG THAT GIVES A MAXIMUM TIME JOB CAN RUN IN MINUTES
;
;
.RUNT:	NOISEM	<Maximum CPU time job can run in Seconds>
	MOVEI	A,100
	MOVEI	C,^D10
	NIN
	ERROR	(<CPU time NIN failure>,PROMPT)
	IMULI	B,^D1000		;CONVERT TO MILLISECS
	MOVEM	B,QENT+RTIME
	JRST PROMPT



;SET UP A MAXIMUM LENGTH FOR THE LOG FILE
;
.LENGTH:NOISEM	<OF LOG FILE>
	MOVEI	A,100
	MOVEI	C,^D10
	NIN
	ERROR	(<LENGTH NIN FAILURE>,PROMPT)
	MOVEM	B,QENT+LOGLNS
	JRST	PROMPT


;
;	SET DE-SUBMIT FLAG JOB
;
.DESUB:	NOISEM<BATCH JOB NUMBER>
	MOVEI	A,100
	MOVEI	C,^D10
	NIN
	ERROR<ILLEGAL FORMAT FOR NUMBER>,PROMPT
	HRRM	B,DJBBLK
	HRRM	B,BJOBNO+QENT
	MOVEI	A,DJBBLK
	SETZ	B,
	GTJFN
	ERROR	<CANNOT GTJFN FOR DESUBMIT FILE>,PROMPT
	MOVEM	A,TJFN
	MOVE	B,[^D36B5+1B20]		;WRITE 36 BITS
	QOPENF
	ERROR	<CANNOT OPEN DESUBMIT FILE FOR THAT JOB>,PROMPT
	ERROR	<CANNOT OPEN DESUBMIT FILE FOR THAT JOB>,PROMPT
	SETOM	DESUB
	JRST	GO3
	>		;END OF SBMTSW CONDITIONAL FOR SUBMIT PROGRAM

;EVERYTHING ON THIS PAGE IS FOR THE SUBMIT PROGRAM

IFN	SBMTSW,<
;GET CTL FILE FILENAME
.CTL:	NOISEM	<FILE NAME>
	MOVEI	A,CTLTBL		;LONG CALL
	SETZ	B,			;NO MAIN STRING
	GTJFN
	TENXER	CMDERR			;TYPE CAUSE OF ERROR AND RESTART
	MOVE	B,[70000,,200000]	;7BIT,INPUT
	QOPENF
	TENXER	CMDERR			;TYPE ERROR CAUSE AND RESTART
	TENXER	CMDERR			;TYPE ERROR CAUSE AND RESTART
	MOVEM	A,CTLJFN#		;SAVE CTL FILE

	MOVE	B,A			;JFN TO MAKE NAME FROM
	HRROI	A,QENT+CTLFIL		;POINT TO CTL FILE LOC
	MOVE	C,[011110,,1]		;<DIR>NAME.EXT;VER
	JFNS

IFE LPTLOG, <				;DEFAULT LOG TO SAME-NAME.LOG
	SETZM	LOGNAM
	MOVE	A,[LOGNAM,,LOGNAM]
	BLT	A,LOGNAM+7		;CLEAR FIELD
	HRROI	A,LOGNAM		;POINT TO IT
	MOVSI	C,(1B8)			;NAME ONLY, NO PUNCT
	JFNS
>

	HRRZ	A,CTLJFN		;GET JFN BACK
	CLOSF				;DONE WITH IT
	BUG(<CANNOT CLOSE CTL FILE>)	;OUCH--THIS SHOULDN'T HAPPEN

	JRST	PROMPT
CTLTBL:	160000,,0		;OLD FILE, SAY [OLD FILE], TTY
	100,,101		;IN/OUT
	0			;DEV
	0			;DIR
	0			;NAME
	-1,,[ASCIZ /CTL/]	;EXT
	0			;PROT
	0			;ACCT
	0			;DESIRED JFN




;SPECIFY LOG FILE

.LOG:	NOISEM	<FILE NAME>
	MOVE	A,[200000,,0]		;NEW FILE ONLY BIT
	SKIPL	DESUB			;IS THIS DESUBMIT ?
	IORM	A,LOGTBL		;NO, SET NEW FILE ONLY BIT
	MOVEI	A,LOGTBL		;LONG CALL
	SETZ	B,			;NO MAIN STRING
	GTJFN				;GET FILE NAME
	TENXER	CMDERR			;OOPS-NOGO
	MOVEM	A,LOGJFN		;SAVE LOG FILE JFN

	MOVE	B,A			;SET UP FOR JFNS
	HRROI	A,QENT+LOGFIL		;POINT TO IT'S PLACE
	MOVE	C,[111110,,1]		;FORMAT CONTROL
	JFNS
	HRRZ	A,B			;GET THE JFN
	MOVE	C,QENT+LOGFIL		;FIRST WORD OF LOG FILE NAME
	TRZ	C,377			;MASK OFF BYTE 5
	CAMN	C,[ASCIZ /LPT:/]	;IS IT LPT: ?
	JRST	.LOG1			;YES, THEN DON'T HAVE TO TOUCH
	MOVE	B,[XWD 70000,100000]	;7 BIT, WRITE
	OPENF
	JRST	[CAIE	A,OPNX9		;FILE BUSY
		 BUG	(<OPEN DISK LOG FILE FAILED>)
		 MOVE	A,LOGJFN
		 RLJFN
		 JFCL			;IGNORE ERROR MESSAGE
		 JRST	PROMPT]		;ASSUME THAT BATCON IS USING AND THAT
					;THIS IS A DESUBMIT REQUEST
	MOVE	B," "
	BOUT				;TOUCH FILE TO DEFINE VERSION
	HRRZ	A,LOGJFN		;RETREIVE LOG FILE JFN
	CLOSF				;CLOSE AND RELEASE JFN
	BUG	(<CLOSE LOG FILE FAILED>)
	JRST	PROMPT
.LOG1:
	RLJFN				;RELEASE IT
	BUG(<LOG FILE RLJFN FAILED>)

	JRST	PROMPT
LOGTBL:	460000,,0		;OUTPUT,SAY [----], REQ CONFIRM
	100,,101		;IN,,OUT
	0			;DEV
	0			;DIR
	-1,,LOGNAM		;NAME
	-1,,[ASCIZ /LOG/]	;EXT
	0			;PROT
	0			;ACCT
	0			;JFN


IFE LPTLOG, <
;MAKES DEFAULT LOGFILE

LOGDEF:	HRROI	A,[ASCIZ /
DEFAULT LOG FILE IS: /]
	PSOUT
	MOVEI	A,DEFTBL	;LOONG CALL
	SETZ	B,		;NO MAIN STRING
	GTJFN
	BUG(<GTJFN FOR DEFAULT LOG FAILED>)
	MOVE	B,A		;JFN
	HRROI	A,QENT+LOGFIL
	MOVE	C,[111110,,1]	;GET EVERYTHING
	JFNS
	HRRZ	A,B		;GET THE JFN
	MOVE	B,[XWD 70000,100000] ;7 BIT WRITE
	QOPENF			;POKE IT TO MAKE IT REAL
	BUG(<OPEN DEFAULT LOG FILE FAILED>)
	BUG(<OPEN DEFAULT LOG FILE FAILED>)
	MOVEI	B," "
	BOUT			;MAKE IT EXIST
	CLOSF			;CLOSE AND RELEASE
	BUG(<CLOSE-RELEASE OF DEFAULT LOGFILE FAILED>)
	HRROI	A,[ASCIZ /
/]
	PSOUT
	POPJ	P,

DEFTBL:	444000,,0		;SAME AS LOG W/ RETYPE AND NO CONFIRM
	377777,,101		;NIL:,,OUT
	0			;DEV
	0			;DIR
	-1,,LOGNAM		;NAME
	-1,,[ASCIZ /LOG/]	;EXT
	0			;PROT
	0			;ACCT
	0			;JFN
	>
	>		;END OF SBMTSW CONDITIONAL FOR SUBMIT PROGRAM


;ROUTINES COMMON TO SUBMIT AND BATCH CONTROL

.AFTER:	NOISEM	<TIME OR DATE & TIME>
	MOVE	B,[POINT 7,COMMAN]	;POINT TO BEGINNING OF BUFFER
	MOVEM	B,TIMSTR		;AND FLAG WE WANT TIME INPUT
	PUSHJ	P,CMDRDR		;GET IT
	JFCL				;^X,DEL
	JRST .AFTXT			;^A OFF LEFT
	ERROR <ILLEGAL DATE-TIME FORMAT>,.AFTXT
	JFCL				;HELP
	JRST .AFTXT			;NULL ENTRY
	MOVE	A,[POINT 7,COMMAN]	;POINT TO BEGINNING
	SETZ	B,			;TAKE ANYTHING THAT LOOKS RIGHT
	IDTIM				;GET THE DATE/TIME INFO
	CAIA				;OOPS WE HAVE TO FAKE IT UP
	JRST .AFTFN			;HE GAVE US THE WHOLE THING-QUIT
	CAIE	B,DILFX1		;SKIP IF ONLY DATE FORMAT ERROR
	TENXER	.AFTXT			;OOPS-BAD INPUT
	GTAD				;WHAT TIME IS IT?
	PUSH	P,A			;SAVE INTERNAL TIME
	IBP	EOCPTR			;STEP OVER NULL
	MOVE	A,EOCPTR		;THIS POINTS PAST NULL
	MOVE	B,0(P)			;GET THE TIME
	MOVSI	C,(1B8+1B9+1B17)	;JUST DATE AS SMALL AS WE CAN GET IT
	ODTIM				;MOVE IT IN BEHIND TIME
	MOVEI	B," "			;GET A SPACE
	IDPB	B,A			;AND PUT IT ON THE NULL
	MOVE	C,[POINT 7,COMMAN]	;POINT TO THE INPUT STRING
.AFTRL:	ILDB	B,C			;ROLL TIME IN
	IDPB	B,A			;AFTER DATE
	CAIE	B,0			;AND QUIT AFTER PUTTING DOWN NULL
	JRST .AFTRL
	MOVE	A,EOCPTR		;POINT TO THE BEGINNING AGAIN
	IDTIM				;CONVERT TIME ANY WAY THAT WORKS
	JRST [	SUB P,[1,,1]		;RESET STACK
		TENXER .AFTXT]		;AND LOSE AFTER ALL THAT WORK
	POP	P,A			;GET BACK TIME-O-DAY
	CAMGE	B,A			;AFTER GT NOW?
	ADD	B,[1,,0]		;NO, THE SAY TOMORROW
.AFTFN:	MOVEM	B,QENT+AFTER		;SAVE TIME TO RUN
.AFTXT:	SETZM	TIMSTR			;CLEAR FLAG 
	JRST PROMPT




IFN	SBMTSW,<
;GO - DO THE SUBMIT
.GO:	SKIPN	DESUB		;IF DESUBMIT REQUEST MAY NOT NEED CTL FILE
	SKIPE	QENT+CTLFIL		;DID HE GIVE CTL FILE?
	CAIA
	ERROR	<YOU MUST GIVE A CTL FILE>,PROMPT

	CONFRM				;HAVE HIM CONFIRM THIS

	IFE	LPTLOG,<
	SKIPN	QENT+LOGFIL		;SKIP IF ALREADY SPECIFIED
	PUSHJ	P,LOGDEF		;GENERATE A DEFAULT FILE NAME
	>
	GTAD				;GET CURRENT TIME AND DATE
	MOVEM	A,QENT+ENTERD		;PUT IN Q ENTRY

;CHECK FOR DIRECT SUBMIT REQUEST
	SKIPN	DESUB			;NO DIRECT FOR DESUBMIT REQUEST
	SKIPN	DIRECT			;DIRECT?
	CAIA
	JRST	DSUB			;YES

;INDIRECT SUBMIT ACTION
GO1:
	MOVSI	A,(1B2+1B17)		;OLD AND SHORT
	HRROI	B,QNAME
	GTJFN
	JRST	[WAIT10		;ILLEGAL VERSION NUMBER
		JRST	GO1]		;TRY AGAIN
	MOVE	B,[1,,FDBUSW]		;USER SETTABLE WORD
	MOVEI	C,C			;PUT IN C
	GTFDB
	RLJFN				;GIVE BACK JFN
	JFCL
GO2:
	MOVEM	C,BJOBNO+QENT		;SAVE AS JOBNUMBER
	HRRM	C,JBBLK
	MOVEI	A,JBBLK
	SETZ	B,
	GTJFN
	AOJA	C,GO2			;TRY AGAIN WITH NEXT VERSION
	MOVEM	A,TJFN#			;SAVE JFN IN CASE OF ERROR
	MOVE	B,[^D36B5+1B20]		;WRITE 36 BITS
	OPENF
	JRST	[MOVE	A,TJFN		;NEED TO RELEASE IT
		RLJFN
		JFCL
		AOJA	C,GO2]		;TRY AGAIN WITH NEW NUMBER
	MOVE	B,[1,,FDBVER]		;FIND OUT WHAT VERSION WE HAVE
	MOVEI	C,C			;INTO C
	GTFDB
	HLRZM	C,QENT+BJOBNO
	JRST	GO3

REPEAT	0,<	;DOESN'T WORK--DON'T HAVE OWNERSHIP RIGHTS
	PUSH	P,A			;SAVE THE JFN
	HRLI	A,4			;DISP IN FDB
	MOVEI	B,77			;MASK OF BITS TO CHANGE
	SETZ	C,			;SET THEM TO 0
	CHFDB				;CHANGE THEM
	POP	P,A			;RESTORE JFN AS IT WAS
	>			;END THE BAD PART


;;;;; DIRECT SUBMIT ;;;;;

;THE FOLLOWING CODE SHOULD BE RUN WITH ^C DISABLED, SO THAT
;THE USER CANNOT ^C HALFWAY THOUGH AND LEAVE THE QUEUE FILE
;OPEN.
;*****FOR NOW, WE WILL TRUST THE USER (ME)*****
DSUB:				
	TIME
	TRZ	A,400000			;NOT NEGATIVE
	TRO	A,100000		;SO BATCH KNOWS IT IS FUNNY
	HRRM	A,BJOBNO+QENT		;FUNNY JOB NUMBER
	MOVSI	A,1			;FLAGS FOR GTJFN
	HRROI	B,QNAME			;NAME OF BATCH QUEUE
	GTJFN
	BUG(<CANNOT GTJFN BATCH QUEUE>)
	MOVEM	A,TJFN
	MOVE	B,[440000,,20000]	;OPEN FOR APPEND
DSUB1:	QOPENF				;OPEN QUEUE FILE
	BUG(<CANNOT OPEN Q FILE FOR APPEND>)
	BUG(<CANNOT OPEN Q FILE FOR APPEND>)
	MOVE	B,[POINT 36,QENT]	;STRING POINTER TO DATA
	MOVNI	C,QESIZE		;LENGTH TO SEND (36 BIT BYTES)
	SOUT				;SEND IT

	TLZ	A,-1			;TO BE SURE WE RELEASE JFN
	CLOSF				;CLOSE Q FILE
	BUG(<UNABLE TO CLOSE Q FILE>)

GO3:
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;IT'S LENGTH
	SOUT				;WRITE REQUEST

	CLOSF				;CLOSE JOB ENTRY
	BUG(<Cannnot CLOSF new job>)

SUBBED:	HRROI	A,[ASCIZ /JOB /]
	PSOUT
	MOVEI	A,101
	MOVE	B,BJOBNO+QENT
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	A,[ASCIZ / SUBMITTED./]
	SKIPGE	DESUB			;DESUBMIT REQUEST
	HRROI	A,[ASCIZ / DESUBMISSION REQUEST /]  ;YES
	PSOUT				;REPORT IT
	JRST	.EXIT			;THAT'S IT


.EXIT:	HALTF
	JRST	START			;IF HE TYPES CONTINUE


;GO - DO THE SUBMIT
.GO:	SKIPL	COMPRG			;HAS A COMMAND BEEN ENTERED
	JRST	[FSOUT<  BYE>,[101]			;NO
		 JRST	.EXIT]

	CONFRM				;HAVE HIM CONFIRM THIS

	GTAD				;GET CURRENT TIME AND DATE
	MOVEM	A,QENT+ENTERD		;PUT IN Q ENTRY

GO2:
	MOVEI	A,CJBBLK		;LONG FROM CJBBLK
	SETZ	B,
	GTJFN
	JRST	[WAIT10			;TRY AGAIN IN A BIT
		 JRST	GO2]
	MOVEM	A,TJFN#			;SAVE JFN IN CASE OF ERROR
	MOVE	B,[^D36B5+1B20]		;WRITE 36 BITS
	OPENF
	JRST	[MOVE	A,TJFN		;NEED TO RELEASE IT
		RLJFN
		JFCL
		WAIT10			;TRY AGAIN IN A BIT
		JRST	GO2]
	MOVE	B,[1,,FDBVER]		;FIND OUT WHAT VERSION WE HAVE
	MOVEI	C,C			;INTO C
	GTFDB
	HLRZM	C,QENT+BJOBNO
GO3:
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;IT'S LENGTH
	SOUT				;WRITE REQUEST

	CLOSF				;CLOSE JOB ENTRY
	BUG(<Cannnot CLOSF new job>)

SUBBED:	HRROI	A,[ASCIZ /CONTROL TASK /]
	PSOUT
	MOVEI	A,101
	MOVE	B,BJOBNO+QENT
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	A,[ASCIZ / SUBMITTED./]
	PSOUT				;REPORT IT

	JRST	START
;
;CLEAR BATCH PROCESSOR QUEUE (WHEEL ONLY)
;
.CLEAR:	NOISEM	<BATCON OR QUEUE>
	MOVEM	A,SUBACA		;SAVE COMMAND INDEX
	MOVEI	A,LIST3			;ADDRESS OF SUBCOMMAND LIST
	MOVEM	A,SUBLAD
	JRST	SUBPRM			;GET NEXT PART OF COMMAND

;THIS SECTION CLEARS THE BATCH QUEUE
.CQUE:	CONFRM			;BETTER CONFIRM THIS!

	MOVSI	A,2001		;NO ACCESS BY OTHER FORKS
	HRROI	B,QNAME		;QUEUE NAME STRING
	GTJFN
	BUG	(<CLEAR: CANNOT GTJFN BATCH QUEUE>)
	MOVE	B,[440000,,100000]	;WRITE ACCESS
CLEAR1:	QOPENF
	BUG	(<CLEAR: CANNOT OPEN BATCH QUEUE>) 
	BUG	(<CLEAR: CANNOT OPEN BATCH QUEUE>) 
	HRLI	1,12		;OFFSET INTO FDB OF BYTE COUNT
	HRROI	2,-1		;BIT CHANGE MASK
	SETZ	3,		;NEW VALUE
	CHFDB			;CLEAR BYTE COUNT OF FDB
	HRRZS	1
	CLOSF
	BUG	(<CLEAR: CLOSE FAILURE>)
	JRST	SPRMPT

;
;	STATUS OF BATCH SYSTEM
;
.STATUS:MOVE	A,[SIXBIT /JOBACT/]
	SYSGT			;GET INDEX FOR JOBACT TABLE (LAST CPU USED)
	JUMPE	B,NOTWHL	;NO SUCH TABLE
	HRR	A,B		;ISOLATE INDEX
	HRLI	A,2		;BATCH PROCESSOR JOB NUMBER
	GETAB			;GET LAST ACTIVITY
	JRST	NOTWHL		;PROBLEM
	MOVE	C,A		;SAVE LAST ACTIVITY
	TIME			;GET ELAPSED TIME SINCE SYSTEM START UP
	SUB	C,A		;GET DIFFERENCE FORM LAST ACTIVITY
	CAIG	C,1500		;.GT. THAN 1.5 MINUTES
	JRST	NOTWHL		;NO
	HLRZ	A,CAPS		;GET CAPABILITIES
	TRNN	A,600000
	JRST	NOTWHL		;NOT WHEEL
	FSOUT	<*** BATCH PROCESSOR STOPPED ***>  ;YES
NOTWHL:
	MOVSI	A,1			;FLAGS FOR GTJFN
	HRROI	B,QNAME			;NAME OF BATCH QUEUE
	GTJFN
	BUG(<CANNOT GTJFN BATCH QUEUE>)
	MOVEM	A,QJFN			;SAVE QJFN
	HRRZS	A
	MOVE	B,[1,,12]		;FDBSIZ
	MOVEI	C,SIZE
	GTFDB				;GET FILE LENGTH IN BYTES (36)
NTWHL1:	HRRZ	A,QJFN			;QUEUE JFN
	MOVE	B,[44B5!1B19!1B26]	;36 BIT, READ, WAIT
	QOPENF				;OPEN QUEUE FILE
	BUG(<CANNOT OPEN Q FILE FOR READ>)  
	BUG(<CANNOT OPEN Q FILE FOR READ>)  
	MOVE	A,QJFN
	MOVE	B,[POINT 36,FENT]
	MOVN	C,SIZE
	SIN			;INPUT DATA FROM QUEUE
	HRRZ	A,QJFN			;QUEUE JFN
	CLOSF				;CLOSE QUEUE JFN
	BUG	(<NTWHL: CAN'T CLOSE QUEUE JFN>)
	MOVE	6,SIZE
	JUMPE	6,FILES
	IDIVI	6,QESIZE
	MOVEI	E,FENT
	IFN	STRACT,<
	FSOUT	<
JOB,USER,CTL FILE,LOG FILE,MESSAGE,NOTIFY,ACCOUNT STRING
>,[101]
	>
	IFE	STRACT,<
	FSOUT	<
JOB,USER,CTL FILE,LOG FILE,MESSAGE,NOTIFY,ACCOUNT NUMBER
>,[101]
	>
	MOVE	B,CAPS		;GET ENABLED CAPABILITIES
	TLNN	B,600000
	JRST	QLOOP		;NOT WHEEL
	FSOUT	<   BATJB(FRK),RESTART,PRIORITY,LOAD AV,LINES,ELAPSE LIM,CPU LIM,ENTERED,AFTER
>,[101]
	HRRZ	B,CAPS		;GET ENABLED CAPABILITIES
	TRNN	B,600000
	JRST	QLOOP		;NOT WHEEL
	FSOUT	<   BATJB(FRK),RESTART,PRIORITY,LOAD AV,LINES,ELP TIME LIM,MAX TIME LIM,ENTERED,AFTER
>,[101]
QLOOP:	FSOUT	<
>,[101]

	SETOM	FFLAG
	MOVEI	A,101
	MOVE	B,BJOBNO(E)
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	MOVEI	B,","
	BOUT
	MOVEI	A,101
	SKIPLE	B,USRDIR(E)		;VALID DIRECTORY NUMBER
	JRST	OUTDIR			;YES, GO OUTPUT DIRECTORY NAME
	HRROI	B,[ASCIZ /DESUBMITED/]
	SETZ	C,
	SOUT				;OUTPUT DESUBMITTED INSTEAD OF NAME
	JRST	DSBDIR			;CONTINUE
OUTDIR:	DIRST
	JFCL
DSBDIR:	MOVEI	B,","
	BOUT
	MOVEI	B,CTLFIL(E)
	HRLI	B,440700
	SETZ	C,
	SOUT
	MOVEI	B,","
	BOUT
	MOVEI	B,LOGFIL(E)
	HRLI	B,440700
	SETZ	C,
	SOUT
	SKIPN	MESAG(E)
	JRST	NMES
	HRROI	B,[ASCIZ /,MESSAGE/]
	SOUT
NMES:	SKIPN	NOTFY(E)
	JRST	NNOT
	HRROI	B,[ASCIZ /,NOTIFY/]
	SOUT
NNOT:	MOVEI	B,","
	BOUT
	IFN	STRACT,<
	HRLZI	2,440700
	HRRI	2,USRACT(E)
	SETZ	3,
	SOUT
	>
	IFE	STRACT,<
	MOVE	2,USRACT(E)
	MOVE	3,[6,,^D10]	;WIDTH,DECIMAL
	NOUT
	JFCL
	>
	FSOUT	<
>,[101]
	HRRZ	A,CAPS		;GET ENABLED CAPABILITIES
	TRNN	A,600000
	JRST	QLPEND		;NOT WHEEL
	FSOUT	<   >,[101]

	HRRZ	B,STRTED(E)
	MOVEI	C,^D10			;DECIMAL OUTPUT
	NOUT
	JRST	JSYSER			;ERROR ROUTINE

	SKIPE	B,STRTED(E)		;IF JOB/FORK NEQ 0, ADD FORK INDEX
	JRST	[MOVEI	B,"("
		 BOUT
		 HLRZ	B,STRTED(E)
		 TRZ	B,1B18			;LEAVE ONLY THE INDEX
		 MOVEI	C,10			;OCTAL OUTPUT
		 NOUT
		 JRST	JSYSER
		 MOVEI	B,")"
		 BOUT
		 JRST	.+1]
	MOVEI	B,","
	BOUT
	MOVE	B,RESTRT(E)
	MOVEI	C,10			;OCTAL OUTPUT
	NOUT
	JRST	JSYSER			;ERROR ROUTINE
	MOVEI	B,","
	BOUT
	MOVE	B,PRIOR(E)		;OUTPUT PRIORITY VALUE
	MOVEI	C,^D10			;AS DECIMAL
	NOUT
	JRST	JSYSER			;ERROR
	MOVEI	B,","
	BOUT
	MOVE	B,LOADAV(E)		;LOAD AVERAGE THRESHOLD
	SETZ	C,
	FLOUT
	JRST	JSYSER
	MOVEI	B,","
	BOUT
	MOVE	B,LOGLNS(E)
	MOVEI	C,10			;OCTAL OUTPUT
	NOUT
	JRST	JSYSER			;ERROR ROUTINE
	MOVEI	B,","
	BOUT
	MOVE	B,ETIME(E)
	MOVEI	C,^D10			;DECIMAL OUTPUT
	NOUT
	JRST	JSYSER
	MOVEI	B,","
	BOUT
	MOVE	B,RTIME(E)
	MOVEI	C,^D10			;DECIMAL OUTPUT
	NOUT
	JRST	JSYSER
	MOVEI	B,","
	BOUT
	MOVE	B,ENTERD(E)
	MOVE	C,[XWD 45241,0]
	ODTIM
	MOVEI	B,","
	BOUT
	MOVE	C,[XWD 45241,0]
	SKIPE	B,AFTER(E)
	ODTIM
	FSOUT	<
>,[101]
QLPEND:	MOVE	B,[XWD 377777,777777]
	CAME	B,JOBSTT(E)		;IS THE JOB DEFERRED?
	JRST	QLPND0			;NO, LOOK AT NEXT ONE
	FSOUT	<  (EXECUTION DEFERRED INDEFINITELY)
>,[101]
QLPND0:	ADDI	E,QESIZE
	SOJG	6,QLOOP
;
;	OUTPUT LIST OF JOBS TO BE QUEUED
;
FILES:	SKIPE	FFLAG
	JRST	FILES1
	FSOUT	<
NO FILES IN QUEUE >,[101]
FILES1:	SETZM	FFLAG
	MOVSI	A,100120		;OLD, ACCEPT INPUT, RETURN FLAGS
	MOVE	B,JOBFS			;JOB.*;* DESCRIPTOR
	GTJFN
	JRST	QDSB			;NONE FOUND
	MOVEM	A,JBJFN			;SAVE JFN
FILES2:
	FSOUT	<
QUEUED JOB FILES:>,[101]
FILES3:	FSOUT	<
      >,[101]
	HRRZ	B,JBJFN
	SETOM	FFLAG
	MOVE	C,[XWD 001110,1]
	JFNS

	MOVE	A,JBJFN
	GNJFN
	JRST	QDSB
	JRST	FILES3
QDSB:
	SKIPE	FFLAG
	JRST	FILES4
	FSOUT	<
NO QUEUED JOB FILES >,[101]
;
;	OUTPUT LIST OF DESUBMIT REQUESTS
;
FILES4:	SETZM	FFLAG
	MOVSI	A,100120		;OLD, ACCEPT INPUT, RETURN FLAGS
	MOVE	B,DJOBS			;DJOB.*;* DESCRIPTOR
	GTJFN
	JRST	JOBER			;NONE FOUND
	MOVEM	A,JBJFN			;SAVE JFN
FILES5:
	FSOUT	<
QUEUED DESUBMIT FILES:>,[101]
FILES6:	FSOUT	<
      >,[101]
	HRRZ	B,JBJFN
	SETOM	FFLAG
	MOVE	C,[XWD 001110,1]
	JFNS

	MOVE	A,JBJFN
	GNJFN
	JRST	JOBER
	JRST	FILES6
JOBER:
	SKIPE	FFLAG
	JRST	RUNING
	FSOUT	<
NO DESUBMIT FILES >,[101]

;	OUTPUT LIST OF CONTROL TASKS PENDING
;
CJOBO:	SETZM	FFLAG
	MOVSI	A,(1B2+1B11+1B17)	;OLD, *, SHORT
	MOVE	B,CJOBS			;CJOB.*;* DESCRIPTOR
	GTJFN
	JRST	NOCJOB			;NONE FOUND
	MOVEM	A,JBJFN			;SAVE JFN
	SETOM	FFLAG

	SETO	D,			;FIRST READ IN ALL CONTROL FILES
	MOVE	B,[POINT 36,FENT]	;INTO FENT WITH COUNT IN D
	MOVEM	B,STRPTR
CJBLP:	HRRZ	A,JBJFN			;OPEN THE FILE AND GET THE ENTRY
	MOVE	B,[44B5+1B19]		;36 BIT, READ
	OPENF
	ERROR	(<  CAN'T OPEN FILE>,CJBLP1)
	MOVE	B,STRPTR		;READ THE RECORD
	MOVNI	C,QESIZE
	SIN
	MOVEM	B,STRPTR
	AOJ	D,			;COUNT IT
	TLO	A,(1B0)			;CLOSE FILE BUT DON'T RELEASE JFN
	CLOSF
	ERROR	(<ERROR CLOSING CONTROL FILE>,CJBLP1)

CJBLP1:	MOVE	A,JBJFN
	GNJFN
	JRST	CJOBO1
	JRST	CJBLP			;MORE - GO GET IT

CJOBO1:	IMULI	D,QESIZE		;COMPUTE ADDRESS OF LAST ENTRY (OLDEST)
	FSOUT	<
QUEUED CONTROL TASKS:>,[101]

CJOBO2:	FSOUT	<
   >,[101]
	MOVE	B,FENT+BJOBNO(D)	;GET JOB NUMBER
	MOVEI	C,^D10			;PRINT IT DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ /)  </]
	SETZ	C,
	SOUT
	MOVE	B,FENT+USRDIR(D)	;OUTPUT DIRECTORY NAME OF AUTHOR
	DIRST
	JFCL

	HRROI	B,[ASCIZ />	/]
	SOUT
	MOVE	B,FENT+COMCOD(D)	;PRINT COMMAND CODE
	MOVEI	C,10				;OCTAL
	NOUT
	JFCL
	MOVEI	B,"-"
	BOUT
	HRROI	B,FENT+COMNAM(D)	;PUT OUT COMMAND NAME STRING
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /  (/]			;AND THE PARAMETER VALUE
	SOUT
	MOVE	B,FENT+COMPAR(D)
	MOVEI	C,10				;OCTAL
	NOUT
	JFCL
	MOVEI	B,")"
	BOUT
	SKIPE	FENT+AFTER(D)			;IF DELAYED, PRINT TIME
	JRST	[HRROI	B,[ASCIZ /	AFTER /]
		 SETZ	C,
		 SOUT
		 MOVE	B,FENT+AFTER(D)
		 MOVSI	C,245201
		 ODTIM
		 JRST	.+1]

	SUBI	D,QESIZE			;INDEX NEXT COMMAND RECORD
	JUMPGE	D,CJOBO2			;GO PRINT IT IF ANY LEFT

NOCJOB:
	SKIPE	FFLAG
	JRST	RUNING
	FSOUT	<
NO CONTROL TASKS PENDING >,[101]
RUNING:
	SETZM	COUNT			;CLEAR ACTIVE PTY COUNT
	FSOUT	<
PTY(S) ACTIVE :>,[101]
;
;	OUTPUT JOB(S) RUNNING
;
	MOVE	A,[SIXBIT /TTYJOB/]
	SYSGT
	HRRZM	B,TTYJNM	;SAVE TTYJOB TABLE INDEX
	MOVE	D,PSEUD1  ;FIRST PSEUDO TTY
RUNLP:	HRL	A,D		;GET TABLE OFFSET
	HRR	A,TTYJNM	;GET TABLE NUMBER
	GETAB
	JRST	RUNEND
	JUMPLE	1,RUNEND		;JUMP IF NO JOB RUNNING
	AOS	COUNT			;ACTIVE PTY COUNT
	HLRZ	E,A		;SAVE JOB NUMBER
	MOVE	A,[SIXBIT /JOBDIR/]
	SYSGT
	HRRZ	A,B		;GET INDEX
	HRL	A,E		;RETREIVE JOB NUM
	GETAB
	JRST	RUNEND
	HRRZ	B,A		;ISOLATE DIR NUM
	MOVE	A,[XWD 440700,JOBSTR]
	DIRST
	JRST	RUNEND

	MOVEI	1,101
	MOVEI	B,37
	BOUT
	HRRZ	B,D		;GET TTY NUMBER
	MOVEI	C,10		;OCTAL OUTPUT
	NOUT
	JFCL
	MOVEI	B," "
	BOUT
	MOVE	B,[XWD 440700,JOBSTR]
	MOVEI	1,101
	SETZ	C,
	SOUT
;NOW TELL WHAT SUBSYS THE PTY JOB IN IN
	MOVEI	B," "
	BOUT
	MOVE	A,[SIXBIT 'JOBNAM']
	SYSGT
	SKIPN	A,B		;TABLE INDEX
	JRST	RUNEND		;FAILED
	HRL	A,E
	GETAB	
	JRST	RUNEND			;FAILED
	HRRZ	C,A			;SAVE INDEX INTO SNAMES
	MOVE	A,[SIXBIT 'SNAMES']
	SYSGT
	SKIPN	A,B		;TABLE INDEX
	JRST	RUNEND		;FAILED
	HRL	A,C		;INDEX BY # FROM JOBNAM
	GETAB
	JRST	RUNEND		;FAILED
;GOT SIXBIT OF SUBSYS NAME IN NOW
	MOVEI	C,6
	MOVE	B,A
NAMLP:	SETZ	A,
	LSHC	A,6		;ISOLATE 1 SIXBIT CHAR
	ADDI	A,40		;MAKE IT ASCII
	PBOUT			;OUTPUT IT
	SOJG	C,NAMLP		;MORE

RUNEND:	AOBJN	D,RUNLP
	SKIPE	COUNT
	JRST	PROMPT
	FSOUT	< NONE>,[101]
	JRST	PROMPT

	.JSYSR
;COMMAND RECOGNIZER AND SCANNER
;USE:
;BEFORE CALL THE FOLLOWING LOCS MUST BE SET
;PCMD - MUST CONTAIN BYTE POINTER TO BEGINNING OF COMMAND STRING
;		FOR ^R TO RETYPE WHOLE LINE
;PCMD2 - MUST CONTAIN BYTE POINTER FOR WHERE THIS COMMAND WORD
;		IS TO BE ENTERED STARTING AT.
;EOCCH - HOLDS TERMINATOR FOR COMMAND.
;
;EOCPTR - POINTS TO LAST CHAR STORED (NOT THE NULL)
;ALIST - MUST POINT TO HEAD OF LIST OF ENTRYS
;		AS FOLLOWS
;		DEFINE	TE(ADR,STR,FLAGS<0>)<
;		[ASCIZ /STR/]
;		FLAGS,,ADR
;		>
;		A ZERO WORD ENDS THE LIST OF ENTRYS
;
;FLAGS---
;	B0 - INVISIBLE (EXCEPT TO ENABLED WHEELS)
;	B1 - MUST BE ENABLED WHEEL TO EXECUTE THIS COMMAND
;	B2 - INVISIBLE (EXCEPT TO WHEELS (DON'T NEED ENA))
;	B3 - MUST BE WHEEL TO DO. (DON'T NEED ENA)
;
;A MULTI SKIP RETURN WILL GIVE DIFFERENT MEANINGS
;	+1	HE DID ^X, IT ALREADY HAS DONE ___
;	+2	HE DID ^A OFF OF LEFT END OF FIELD
;	+3	HE ENTERED TOTALLY UNRECOGNIZEABLE COMMAND
;	+4	HE ENTERED A "?" AS THE FIRST CHARACTER
;	+5	HE ENTERED A NULL LINE ENDED WITH EOL
;		(HE JUST HIT RETURN)
;	+6	HE ENTERED SOMETHING RECOGNIZEABLE.
;
;IF THE RETURN IS +3,+4,+5,+6, THE LAST CHAR IS IN EOCCH.
;
;MAIN ENTRY TO SCANNER

CMDRDR:	MOVEI	A,101			;PRIM OUTPUT
	RFCOC				;GET CONTROL CHARS
	MOVEM	B,COC1#			;SAVE THEM
	MOVEM	C,COC2#
	TLZ	B,(3B3)			;^A
	TDZ	C,[3B1!3B13!3B19]	;^R,^X,AND ESC
	SFCOC

	SKIPE	B,TIMSTR		;FOR TAKING TIME INPUT
	JRST	CMDRD1			;IGNORE STRING POINTER

	IFN	STRACT,<
	SKIPN	B,STRFLG		;GET STRING POINTER FOR ACCOUNT
	>
	MOVE	B,PCMD2			;POINT TO WHERE TO PUT IT
CMDRD1:	SETZ	D,			;CLEAR CHAR COUNT READ.

GCCH:	PBIN				;GET A CHARACTER
	CAIL	A,"A"+40		;CHECK FOR LOWERCASE
	CAILE	A,"Z"+40		;CONTINUE CHECK
	JRST	.+2			;NOT LOWERCASE
	SUBI	A,40			;MAKE UPPERCASE

	SKIPE	TIMSTR			;ALLOW MORE LEGAL CHARACTERS IF
	CAIGE	A," "			;IF TAKING IN TIME
	CAIL	A,"A"			;CHECK FOR LETTER.
	CAILE	A,"Z"
	JRST	EOC			;NOT A LETTER

	IDPB	A,B			;STORE CHARACTER
	AOJA	D,GCCH			;COUNT IT AND CONTINUE

CTLA:	JUMPLE	D,RETN2			;RETURN +2
	MOVEI	A,"\"			;GET A \
	PBOUT				;INDICATE DELETE
	LDB	A,B			;GET LAST CHARACTER
	PBOUT				;SHOW IT
	SETZ	A,			;DESTROY IT WITH NULL
	DPB	A,B			;ZOT!!
	SOS	B			;BACK UP BY 5 CHARS
REPEAT	4,<IBP B>			;FOWARD 4 AGAIN
	SOJA	D,GCCH			;DELETE IT FROM COUNT AND GO ON

CTLR:	PUSH	P,B			;SAVE B
	PUSHJ	P,CCRLF			;SEND CRLF IF NEEDED
	POP	P,B			;RESTORE B
	MOVE	C,PCMD			;POINT TO TOTAL COMMAND
CTLR1:	CAMN	B,C			;ARE WE AT END?
	JRST	GCCH			;YES, GO FOR INPUT
	ILDB	A,C			;GET A CHARACTER
	PBOUT				;PUT IT OUT
	JRST	CTLR1			;LOOP IT OUT

DELDEL:	HRROI	A,[ASCIZ /XXX/]		;MARK ACTION
	TRNA				;REST IS LIKE CTL X
CTLX:	HRROI	A,[ASCIZ /___/]		;REPORT DELETION
	PSOUT
	JRST	RETN1			;RETURN +1

EOC:	CAIN	A,"A"-100		;^A?
	JRST	CTLA			;YES
	CAIN	A,"X"-100		;^X?
	JRST	CTLX			;YES
	CAIN	A,"R"-100		;^R?
	JRST	CTLR			;YES
	CAIN	A,177			;DEL?
	JRST	DELDEL			;YES

;COMMAND IS NOW COMPLETE--CHAR READ WAS NOT A CTL CHAR OR SPECIAL
	MOVEM	A,EOCCH			;SAVE CHARACTER
	CAIN	A,37			;EOL?
	JUMPE	D,RETN5			;AS FIRST CHAR?
					;RETURN +5 IF SO.

	CAIN	A,"?"			;DOES HE WANT HELP?
;;;	JUMPE	D,RETN4			;RETURN +4 IF SO
	JUMPE	D,HELPER		;GIVE IT TO HIM

;CHECK FOR A LEGAL DELIMITER
	CAIE	A,37			;EOL IS OK
	CAIN	A," "			;SO IS SPACE
	JRST	EOCOK			;GOOD
	CAIE	A,33			;ESC IS GOOD
	JRST	EOCNO			;OTHERWISE NO-GO

EOCOK:	SETZ	A,			;ENSURE COMMAND ENDS WITH NULL
	MOVEM	B,EOCPTR		;SAVE END COMMAND POINTER
	IDPB	A,B			;STORE NULL TO END COMMAND

	SKIPE	TIMSTR			;IF WE ARE RECOGNIZING TIME
	JRST	RETN6			;WE DON'T WANT TO RECOGNIZE HERE

	IFN	STRACT,<
	SKIPE	STRFLG			;WERE WE SEARCHING FOR ACCOUNT STRING?
	JRST	RETN6			;YES, FOUND ONE
	>
	MOVE	E,ALIST			;GET POINTER TO LIST

EOCLP:	SKIPN	(E)			;AN ENTRY HERE?
	JRST	EOCNO			;NO-NO MATCH-OOPS
	PUSHJ	P,CKM			;CHECK FOR MATCH
	JFCL				;BOTH FAILURES EQUIVALENT HERE
	JRST	.+2			;NO MATCH
	JRST	EOCMAT			;CHECK FOR AMBIGUITY
	ADDI	E,2			;GO TO NEXT
	JRST	EOCLP			;AND LOOP

;CHECK FOR AMBIGUITY
EOCMAT:	PUSH	P,E			;SAVE ONE THAT MATCHED
EOCMA2:	ADDI	E,2			;GET TO NEXT
	SKIPN	(E)			;ARE WE AT END OF LIST?
	JRST	EOCMM			;MATCHED LAST ONE THEN.
	PUSHJ	P,CKM			;CHECK FOR MATCH
	JRST	EOCMA2			;HE CAN'T DO THIS IN THIS MODE
	JRST	.+2			;NOT MATCH-SO NOT AMBIGUOUS
	JRST	AMBIG			;AMBIGUOUS

EOCMM:	POP	P,E			;RESTORE POINTER
	PUSHJ	P,CKM			;SEE WHAT DID MATCH
	BUG(<SECOND CKM RETURN +1>)
	BUG(<SECOND CKM RETURNED +2>)
	MOVE	B,EOCCH			;GET DELIM
	CAIE	B,33			;WAS IT ESC?
	JRST	NOESC			;NO

	MOVE	B,A			;GET PTR TO FULL NAME
ESCL:	ILDB	A,B			;GET NEXT CHAR
	JUMPE	A,ESCE			;CHECK IF DONE
	PBOUT				;SEND TO TERMINAL
	IDPB	A,EOCPTR		;INCLUDE IN LINE
	JRST	ESCL

ESCE:	MOVEI	A,40			;AND A BLANK
	PBOUT				;TYPE IT
	IDPB	A,EOCPTR		;SAVE IT
	SETZ	A,			;A NULL
	MOVE	B,EOCPTR		;GET EOCPTR
	IDPB	A,B			;TERMINATE LINE

NOESC:	MOVE	A,E			;GET PTR

RETN6:	AOS	(P)			;RETURN +6
RETN5:	AOS	(P)			;RETURN +5
RETN4:	AOS	(P)
RETN3:	AOS	(P)
RETN2:	AOS	(P)
RETN1:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	MOVEI	A,101			;PRIM OUTPUT
	MOVE	B,COC1			;RESET SFCOC WORDS
	MOVE	C,COC2
	SFCOC

	POP	P,C			;RESTORE THESE
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN +1

;AMBIGUOUS
AMBIG:	POP	P,E			;RESTORE E
	MOVEI	A,7			;RINGS BELL
	PBOUT
	MOVE	B,EOCPTR		;REUP WHERE TO PUT CHARACTER
	JRST	GCCH			;GO BACK FOR MORE


;UNRECOGNIZEABLE
EOCNO:	HRROI	A,[ASCIZ /  ?/]		;ERROR MESSAGE
	PSOUT
	JRST	RETN3			;RETURN +3

;CHECK FOR LEGALITY AND CHECK FOR MATCH IF LEGAL
;RETURN +1 IF NOT LEGAL
;	+2 IF LEGAL BUT NO MATCH
;	+3 LEGAL, MATCH
CKM:	MOVE	B,CAPS			;GET CAPABILITIES
					;POSSIBLE,,ENABLED
	TRNE	B,600000		;ENABLED WHEEL OR OPER?
	JRST	CKM2			;ALL IS LEGAL
	MOVE	A,1(E)			;GET FLAGS AND ADR
	TLNE	A,(1B1)			;NEED HE BE WHEEL TO DO THIS?
	POPJ	P,			;YES-SO HE CAN'T

	TLNE	B,600000		;CHECK POSSIBLE CAPS
	JRST	CKM2			;HE IS NON-ENABLED WHEEL
	TLNE	A,(1B3)			;SHOULD HE HAVE BEEN?
	POPJ	P,			;YES-SO CANNOT DO

CKM2:	AOS	(P)			;AT LEASE THIS IS LEGAL FOR HIM
	HRRO	A,0(E)			;GET POINTER TO STRING IN LIST
	MOVE	B,PCMD2			;GET COMMAND POINTER
	PUSHJ	P,STRMA			;MATCH?
	POPJ	P,			;NO
	AOS	(P)			;MAKE +3 BECAUSE IT MATCHED
	POPJ	P,			;RETURN

;HELP ROUTINE
HELPER:	MOVE	E,ALIST			;POINT TO POSSIBLE COMMANDS
	HRROI	A,[ASCIZ /
COMMANDS ARE:
 /]
	PSOUT
	MOVE	D,CAPS			;GET CAPS (POSSIBLE,,ENABLED)
	PUSH	P,B			;SAVE AC B
	HRLZI	B,010700		;SET UP ENDING STRING POINTER MASK
					;ALLOW 10 CHARS FOR NAME
	PUSH	P,B			;SAVE IT
	SETZ	F,			;NUMBER OF COMMANDS PER LINE
HELP2:	MOVE	A,(E)			;GET POINTER TO STRING
	JUMPE	A,HELPEX		;EXIT TO ^R ROUTINE TO RETYPE LINE
	MOVE	A,1(E)			;GET FLAGS,,ADR
	TLNN	A,(1B0)			;NEED HE BE ENABLED TO SEE IT?
	JRST	.+3			;NO
	TRNN	D,600000		;CHECK IF HE IS ENABLED
	JRST	HELP4			;NO SEE THIS

	TLNN	A,(1B2)			;NEED HE BE WHEEL?
	JRST	.+3			;NO
	TLNN	D,600000		;CHECK IF A WHEEL POSSIBLE
	JRST	HELP4			;NO- CANNOT SEE THIS

	HRRO	A,(E)			;GET STRING PTR
	PSOUT				;GIVE THIS COMMAND
	AOJ	F,			;BUMP COUNTER
	CAIE	F,5			;HAVE WE DONE 5?
	JRST	HELP3			;NO, SPACE OVER
	HRROI	A,[ASCIZ /
 /]					;YES, START NEW LINE
	SETZ	F,			;CLEAR COUNTER
	PSOUT
	JRST	HELP4

HELP3:	HRRZ	B,0(E)			;GET STRING PTR AND SPACE OVER 1 GROUP
	ADDI	B,1			;OF 5 CHAR + THE 5 ABOVE
	HRRM	B,0(P)			;UPDATE STACK MASK
	MOVE	B,A
	MOVEI	A," "			;DO SPACES
HELP35:	PBOUT				;WRITE A SPACE
	IBP	B
	CAME	B,0(P)			;IS IT AS MUCH AS WE WANT?
	JRST	HELP35			;NO - DO SOME MORE

HELP4:	ADDI	E,2			;GO TO NEXT COMMAND
	JRST	HELP2			;LOOP ON
HELPEX:	POP	P,B			;CLEAR ENDING PTR MASK
	POP	P,B			;RESTORE AC B
	SETZ	D,			;CLEAR COUNT
	HRROI	A,[ASCIZ /

^A DEL CHAR, ^R RETYPE LINE, ^X OR <DEL> TO ABORT COMMAND,
<ESC> FOR RECOGNITION, ^O TO STOP OUTPUT
/]
	PSOUT
	JRST	CTLR			;RETYPE LINE AND CONTINUE

;STRING MATCHER.
;CALL: A AND B HAVE STRING POINTERS IN THEM.
;	PUSHJ	P,STRMA
;	+1	NO MATCH. (NO REGISTERS CHANGED)
;	+2	MATCH. STRINGS MATCHED (AT LEAST UNTIL B ENDED)
;		IF LENGTH OF B IS .LT. LENGTH OF A THEN ONLY
;		THE FIRST LEN(B) CHARS WILL HAVE BEEN
;		CHECKED.  IF A ENDS FIRST, A NO-MATCH IS DONE.
;		WHEN THE SUCCESS RETURN IS TAKEN, A IS INCREMENTED
;		OVER MATCHED CHARACTERS.
;		B IS LEFT AS IN CALL ALWAYS.
;
;	STRING POINTERS MAY HAVE -1 IN LH TO IMPLY 440700
STRMA:	PUSH	P,D			;SAVE ACS
	PUSH	P,C
	PUSH	P,B
	PUSH	P,A

	HLRZ	C,A			;CHECK LH FOR -1
	CAIN	C,-1			;WAS IT -1?
	HRLI	A,440700		;IF SO, SET IT
	HLRZ	C,B			;CHECK LH FOR -1
	CAIN	C,-1			;WAS IT -1?
	HRLI	B,440700		;IF SO, SET IT

STRMA1:	ILDB	D,B			;GET ONE FROM TEST STRING
	JUMPE	D,STRMA2		;NULL MEANS END MEANS MATCH
	ILDB	C,A			;GET ONE FROM MAIN STRING
	CAMN	C,D			;MATCH?
	JRST	STRMA1			;YES, CONTINUE
	JRST	STRMA3			;NO, FAIL

;SUCCESSFUL MATCH EXIT.
STRMA2:	POP	P,B			;THROW AWAY OLD VAL OF A
	AOSA	-3(P)			;SET SKIP RETURN, AND
					;SKIP INTO EXIT ROUTINE
;MATCH FAILURE EXIT.
STRMA3:	POP	P,A			;BACK UP POINTER TO MAIN
	POP	P,B			;RESTORE OTHER ACS
	POP	P,C
	POP	P,D
	POPJ	P,			;RETURN
;LUUO ROUTINES

;MAIN LUUO HANDLER.
LUUOI:	PUSH	P,A			;SAVE A FOR A WORK AREA
	MOVE	A,40			;GET TRAP INSTRUCTION
	ROT	A,^D9			;GET ITS OPCODE
	ANDI	A,777			;ISOLATE OPCODE
	JUMPLE	A,.+2			;BEWARE .LE. 0
	CAILE	A,NLUUOS		;CHECK AGAINST UPPER LIMIT
	BUG(<ILLEGAL LUUO TRAP>)	;OOPS
	MOVE	A,LUUOV-1(A)		;GET ADDR OF LUUO ROUTINE
	EXCH	A,(P)			;RESTORE A, SAVE ROUTINE ADDR
	POPJ	P,			;CLEAR STACK, GO TO ROUTINE

;NOW THE LUUO VECTOR
LUUOV:	ERRORX				;PRIMARY ERROR FUNCTION
	ERR2X				;REPORT TENEX ERROR
	NOISEX				;DO NOISE WORD FUNCTION
	CONF				;CONFIRM FUNCTION
NLUUOS==.-LUUOV				;GET # OF DEFINED LUUOS

IFG	NLUUOS-37,<			;CHECK FOR WITHIN LIMIT
	PRINTX	TOO MANY LUUOS DEFINED!!
	>				;END IFG NLUUOS-37

;PRIMARY ERROR INSTRUCTION.
;USE:
;	ERR1	[JUMP-ADDR,,[ASCIZ /MSG-STRING/]]
;IF JUMP-ADDR IS 0, THEN NO JUMP WILL OCCUR, THE NEXT INSTRUCION
;WILL BE EXECUTED IN SEQUENCE.
;NORMALLY USED WITH THE ERROR MACRO
;	ERROR	<MSG>
;OR	ERROR	<MSG>,JUMP-ADDR
ERRORX:	PUSH	P,A			;SAVE ACS
	PUSH	P,B
	PUSHJ	P,CCRLF			;NEW LINE IF NEEDED
	MOVEI	A,"?"			;ERROR LEADER
	PBOUT				;PUT IT OUT
	HRRO	A,@40			;GET STRING POINTER FOR ERROR
	PSOUT				;AND TYPE MESSAGE
	PUSHJ	P,CRLF			;GIVE CRLF
	HLRZ	A,@40			;GET RETURN ADDRESS
	JUMPE	A,.+2			;IF 0 GIVEN, DON'T CHANGE
	MOVEM	A,-2(P)			;SET NEW RETURN ADDR
	POP	P,B			;RESTORE ACS
	POP	P,A
	POPJ	P,			;RETURN TO MAINLINE PROGRAM

;ERR2X IS THE TENEX ERROR REPORTER
;USE IS VIA THE TENXER INSTRUCTION
;	TENXER	JUMP-ADDR
;IF JUMP-ADDR IS 0 (OR OMITTED, GIVING 0) THEN THE INSTRUCTION
;DOES NOT JUMP.
ERR2X:	PUSH	P,A			;SAVE ACS
	PUSH	P,B
	PUSH	P,C
	PUSHJ	P,CCRLF			;GIVE ANY NEEDED CRLF
	MOVEI	A,"?"			;ERROR CHARACTER
	PBOUT				;PUT IT OUT
	MOVEI	A,101			;PRIMARY OUTPUT JFN
	HRLOI	B,400000		;LAST ERROR, THIS FORK
	SETZ	C,			;NOTHING SPECIAL
	ERSTR				;PRINT ERROR MESSAGE
	BUG(<UNDEFINED ERROR NUMBER RETURN FROM ERSTR>)
	BUG(<ERSTR RETURNED +2>)
	HRRZ	A,40			;GET INSTRUCTIONS EFFECTIVE ADR
	JUMPE	A,.+2			;DO NOTHING IF 0
	MOVEM	A,-3(P)			;OTHERWISE, SET IT AS RETURN ADR
	POP	P,C			;RESTORE ACS
	POP	P,B
	POP	P,A
	POPJ	P,			;RETURN TO MAINLINE PROGRAM.

;NOISE WORD PROCESSOR
;CALLED FROM NOISE MACRO WITH NOISE INSTRUCTION
;	NOISE1	[ASCIZ /STR/]
;DOES THE NOISE PROCESSING
NOISEX:	PUSH	P,A			;SAVE ACS
	PUSH	P,B
	MOVEI	A,100			;PRIMARY INPUT FILE
	BKJFN				;GET LAST CHAR TYPED
	BUG(<NOISE BKJFN #1 FAILED>)	;OOPS
	PBIN				;READ THE CHAR IN
	CAIN	A,33			;ESC?
	JRST	NOISEW			;YES, GO WRITE IT
	CAIN	A," "			;A SPACE?
	JRST	NOISES			;YES- TAKE CARE OF IT
NOISER:	POP	P,B			;RESTORE ACS AND RETURN
	POP	P,A
	POPJ	P,			;RETURN

NOISEW:	MOVEI	A,"("			;BEGIN WITH (
	PBOUT
	HRRO	A,40			;GET STRING POINTER
	PSOUT				;TYPE IT
	HRROI	A,[ASCIZ /) /]		;END OF NOISE CHARACTERS
	PSOUT
	JRST	NOISER			;RETURN

NOISES:	PBIN				;GET NEXT CHAR
	CAIN	A,"("			;WAS IT ( THAT HE TYPED NEXT?
	JRST	NOISEE			;LET HIM ENTER IF SO
	MOVEI	A,100			;PRIM INPUT
	BKJFN				;BACK IT UP FOR LATER
	BUG(<ERROR RETURN FROM NOISE BKJFN # 2>)
	JRST	NOISER			;RETURN
NOISEE:	PBIN				;READ UNTIL ) FOUND
	CAIN	A,")"			;END OF NOISE?
	JRST	NOISEZ			;GO TO GET NEXT SPACE FROM HIM
	CAIGE	A," "			;MUST BE AT LEAST BLANK
	JRST	CMDERR			;NOT LEGAL CHAR
	JRST	NOISEE			;GO EAT ANOTHER
NOISEZ:	PBIN				;GET CHAR AFTER )
	CAIE	A,11			;ONLY <TAB> AND <SPACE> LEGAL
	CAIN	A," "			;CHECK FOR SPACE
	JRST	NOISER			;RETURN
	JRST	CMDERR			;ERROR


;CONFIRM ROUTINE
CONF:	PUSH	P,A			;SAVE A
	HRROI	A,[ASCIZ / [Confirm] /]
	PSOUT
CONF1:	PBIN				;READ CONFIRMATION
	CAIN	A,"?"			;DOES HE WANT HELP?
	JRST	CONF3			;YES
	CAIN	A,37			;DID HE HIT RETURN?
	JRST	CONF2			;YES
	MOVEI	A,CMDERR		;WHERRE WE RETURN TO
	MOVEM	A,-1(P)			;SET IT
CONF2:	POP	P,A			;RESTORE A
	POPJ	P,			;RETURN
CONF3:	HRROI	A,[ASCIZ /
[Confirm with carriage return.]/]
	PSOUT
	JRST	CONF1			;TRY AGAIN
;WRITE BUG MESSAGE
BUGMSG:	EXCH	A,(P)			;GET POINTER TO STRING
	HRLI	A,440700		;MAKE BYTE POINTER
	PUSH	P,A			;SAVE IT
	HRROI	A,[ASCIZ /
?PROGRAM BUG - /]
	PSOUT
	POP	P,A			;GET POINTER TO OUR MSG.
	PSOUT				;REPORT IT
	RESET				;GET AWAY FROM ANY FILES
	TENXER				;REPORT LAST TENEX ERROR
	HALTF				;AND STOP
	JRST	.-2			;IF HE TYPES CONTINUE

;CONDITIONAL CRLF
CCRLF:	MOVEI	A,101			;OUTPUT JFN
	RFPOS				;FIND WHERE WE ARE
;	TRNN	B,377B25		;AT START?
	TRNN	B,-1			;AT START?
	POPJ	P,			;YES
;SEND A CRLF TO USER.  CALLED INDEPENDENTLY OR FALLEN INTO FROM CCRLF
CRLF:	HRROI	A,[BYTE (7)15,12,0]	;CR,LF SEQ
	PSOUT
	POPJ	P,			;RETURN


;ROUTINE FOR TRYING TO OPEN A BUSY FILE 20 TIMES
.OPENF:	OPENM




;ROUTINE TO HANDLE ^O - RESTARTS JOB
CTLO:	MOVEI	A,STRT1			;SEND RETURN TO RESTART
	MOVEM	A,LEV3PC
	DEBRK


IFN	STRACT,<
IFN	TNX131,<

;THESE ROUTINES ONLY FOR 131 TENEX

;ROUTINES TO EMULATE VACCT AND GDACC JSYS'S	
;
;$VACCT CALLED W/ PUSHJ P,$VACCT
;	1/USER #, -1 MEANS SELF (CONN DIR)
;	2/ACCT DESIGNATOR, 5B2+NUMBER OR DSP
;
;RETURNS	+1	FAIL TO MATCH
;		+2	USER ACCT PAIR MATCH
;			OR UACHK UNRUNNABLE
;			OR WHEEL /OPERATOR
;
;$GDACC CALLED W/ PUSHJ P,$GDACC
;	1/ E FOR STRING ACCT (DSP)
;	2/ USER ACCT #, -1 FOR SELF (CONN DIR)
;
;RETURNS	+1	FAILURE DOESN'T RETURN CODES
;		+2	SUCCESS ACCOUNT STRING POINTER IN AC1
;


$VACCT:	PUSH	P,1		;USER NUMBER
	PUSH	P,2		;ACCOUNT DESIGNATOR
	PUSH	P,3
	MOVEI	1,400000	;THIS FORK
	RPCAP
	TRNE	3,1B18+1B19	;WHEEL OR OP?
	JRST [	POP	P,3	
		JRST $VACC2]	;SKIP RETURN
	POP	P,3
	MOVE	2,-1(P)		;GET USER NUMBER
	SETZM	UACBLK
	MOVE	1,[UACBLK,,UACBLK+1]
	BLT	UACBLK+17	;CLEAR AC ARG BLOCK
	CAME	2,[-1]		;SELF?
	JRST $VACC1		;NO
	PUSH	P,3
	PUSH	P,4
	GJINF			;GET JOB INFO CONN DIR IN 2
	POP	P,4
	POP	P,3
$VACC1:	HRROI	1,UACBLK	;FIRST 8 AC'S CONTAIN DIRST
	DIRST
	JRST $VAFXT		;DO FAIL RETURN
	MOVE	1,0(P)		;GET ACCT DESG
	CAML	1,[500000,,0]
	CAMLE	1,[577777,,-1]	;IS IT NUMERIC?
	JRST $VASTR		;NO STRING
	MOVEM	1,UACBLK+10	;NUMERIC DESIG IN AC10
	MOVEI	1,UACBLK	;POINT TO ARG BLOCK
	MOVEI	2,1		;START AT NUMERIC ENTRY POINT
	PUSHJ	P,RUNUAC
	JRST $VACC2		;FORK FAILED TO RUN
	JRST $VACC3		;FORK RAN, CHECK RESULT
;
$VASTR:	MOVEI	2,[POINT 7,UACBLK+10] ;POINT TO AC10-17 FOR ACCT STRING
	TLC	1,-1		;DSP?
	TLCN	1,-1		;SKIP IF NOT DSP
	HRLI	1,440700	;CONVERT TO STRING POINTER
	PUSH	P,3
	PUSH	P,4
	MOVNI	4,^D39		;WE ONLY TAKE 39 CHARS
$VALUP:	ILDB	3,1
	IDPB	3,2
	CAIE	3,0		;SKIP IF NULL BYTE
	AOJL	4,$VALUP	;GET 39 CHARS MAX
	POP	P,4
	POP	P,3
	MOVEI	1,UACBLK	;POINT TO AC BLOCK
	MOVEI	2,2		;ENTRY POINT FOR STRING
	PUSHJ	P,RUNUAC
$VACC2:	AOSA	-2(P)		;RUN FAILED SAY OK
$VACC3:	CAIE	1,0		;FIND A MATCH?
$VAFXT:	JRST [	POP	P,2	
		POP	P,1
		POPJ	P,]
	JRST $VACC2		;FOUND MATCH, DO SKIP RETURN
$GDACC:	PUSH	P,1		;DSP FOR ACCT
	PUSH	P,2		;USER NUMBER
	SETZM	UACBLK
	MOVE	1,[UACBLK,,UACBLK+1]
	BLT	1,UACBLK+17	;CLEAR AC ARG BLOCK
	CAME	2,[-1]		;SELF?
	JRST $GDAC1		;NO
	PUSH	P,3
	PUSH	P,4
	GJINF			;GET CONN DIR NUM IN 2
	POP	P,4
	POP	P,3
$GDAC1:	HRROI	1,UACBLK	;POINT TO AC0-7	FOR DIRST
	DIRST
	JRST $GDFXT		;DO FAIL RETURN
	MOVEI	1,UACBLK	;POINT TO AC BLOCK
	SETZ	2,		;0 ENTRY POINT FOR DEFAULT
	PUSHJ	P,RUNUAC
	CAIA			;NON-SKIP IF FORK FAILED
	CAIE	1,0		;DID WE FIND DEFAULT?
	JRST $GDFXT		;NO, NON-SKIP
	PUSH	P,3
	PUSH	P,4
	MOVNI	3,^D39		;39 CHARS MAX
	HRRZ	2,UACBLK+2	;GET POINTER REL TO AC BLOCK
	ADD	2,[POINT 7,UACBLK] ;MAKE IT A USEFULL POINTER
	MOVE	4,-3(P)		;GET USERS POINTER
	HRLI	4,440700	;MAKE E A POINTER
$GDACL:	ILDB	1,2
	IDPB	1,4
	CAIE	1,0		;SKIP IF  A NULL
	AOJL	3,$GDACL
	POP	P,4
	POP	P,3
	AOS	-2(P)		;DO SKIP RETURN
$GDFXT:	POP	P,2
	POP	P,1
	POPJ	P,


;RUNS UACHK PROGRAM DOES NON-SKIP RETURN ON PROGRAM FAILURE
;	1/ POINTER TO AC ARG BLOCK
;	2/ ENTRY VECTOR OFFSET
;	   0=DEFAULT, 1=NUMERIC CHECK, 2=STRING CHECK

RUNUAC:	PUSH	P,1		;ARG POINTER
	PUSH	P,2		;ENTRY VECTOR
	MOVSI	1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI	2,[ASCIZ /<SYSTEM>UACHK.SAV/]
	GTJFN
	JRST [	POP	P,2
		POP	P,1
		POPJ	P, ]	;DO FAIL RETURN IF CANT FIND FILE
	PUSH	P,1		;JFN
RUNUA1:	MOVSI	1,(1B1)		;SET CAP DONT START
	CFORK
	JRST [	MOVEI	1,^D1000
		DISMS		;TRY AGAIN IN 1 SEC
		JRST RUNUA1]
	PUSH	P,1		;FORK HANDLE
	MOVSI	1,0(1)		;MOVE HANDLE TO LH
	HRR	1,-1(P)		;AND PUT JFN IN RH
	GET
	MOVE	1,(P)
	MOVE	2,-3(P)		;GET POINTER TO ARG BLOCK
	SFACS			;LOAD ACS
	MOVE	2,-2(P)		;GET VECTOR OFFSET
	SFRKV			;START IT
	WFORK			;WAIT FOR IT
	FFORK			;FREEZE IT
	MOVE	2,-3(P)		;POINT TO ARG BLOCK
	RFACS			;COPY BACK THE ACS
	RFSTS			;GET FORK STATUS
	TLZ	1,(1B0)		;KILL THE FREEZE BIT
	CAME	1,[2,,0]
	TLOA	2,-1		;INVOL TERMINATE
	TLZ	2,-1		;CLEAN HALT
	POP	P,1		;GET FORK HANDLE
	KFORK			;GET RID OF IT
	POP	P,1		;GET THE JFN
	RLJFN			;RELEASE IT
	JFCL			;SHOULDNT HAPPEN!!??
	MOVE	1,-1(P)		;POINT TO BLOCK
	MOVE	1,1(1)		;WE WANT THE AC1
	CAIL	2,0		;INVOL TERMINATE?
	CAILE	1,0		;OR PROGRAM ERROR?
	SOS	-2(P)		;DO NON-SKIP
	POP	P,2
	SUB	P,[1,,1]	;POP STACK AGAIN
	AOS	(P)
	POPJ	P,

	>
	>			;END OF TNX131 STRING ACCOUNTING CONDITIONAL
;PURE DATA STORAGE

;MAIN COMMAND LIST
LIST1:	TE(.ACCOU,<ACCOUNT>)		;ACCOUNT NUMBER FOR SUBJOB LOGIN
	TE(.AFTER,<AFTER>)		;TIME JOB IS TO WAIT UNTIL
;;;	TE(.CLEAR,<CLEAR>,ENASEE!ENADO) ;CLEAR QUEUE
	TE(.CTL,<CTL>)			;CONTROL FILE
	TE(.DESUB,<DESUBMIT>)		;DESUBMIT BATCH JOB
;;;	TE(.DIREC,<DIRECT>,ENASEE!ENADO)	;DIRECT SUBMIT TO QUEUE
	TE(.DSABL,<DISABLE>,ENASEE!ENADO)	;DISABLE CAPABILITIES
	TE(.ENABL,<ENABLE>,WHLSEE!WHLDO)	;ENABLE CAPABILITIES
	TE(.EXIT,<EXIT>)		;LEAVE SUBMIT
	TE(.GO,<GO>)			;GO DO THE SUBMIT
	TE(.CTL,<INPUT>)		;SAME AS CTL
	TE(.LENGTH,<LENGTH>)		;SET LENGTH OF LOG FILE
	TE(.LOAD,<LOAD>)		;LOAD AVERAGE THRESHOLD
	TE(.LOG,<LOG>)			;SPECIFY LOG FILE
	TE(.MESS,<MESSAGE>)		;SEND MESSAGES TO SUBMITTER
	TE(.NOTFY,<NOTIFY>)		;NOTIFY USER AT BEGINING AND END OF JOB
	TE(.LOG,<OUTPUT>)		;SAME AS LOG
IFN	SKUSER<
	TE(.PRIO,<PRIORITY>)		;RUN WITH NORMAL SCHEDULING
>		;END OF IFN SKUSR
	TE(.RUNT,<RUNTIME>)		;CPU TIME MAX FOR JOB
	TE(.STATUS,<STATUS>)		;STATUS OF BATCH SYSTEM
	TE(.TIME,<TIME>)		;MAXIMUM TIME JOB CAN RUN
	0				;END LIST



;FOLLOWING IS THE SUBCOMMAND AND DISPATCH LIST FOR STATUS COMMAND USED IN
;BATCON AND BATCTL

DEFINE	STASUB<
CQQ==0
	TE(.SBATC,<BATCON>,WHLSEE!WHLDO)	;STATUS OF BATCON PROGRAM
	TE(.STATU,<QUEUE>,WHLSEE!WHLDO)		;STATUS OF BATCH QUEUE
	0

MSTASB==CQQ-1
>

;FOLLOWING IS THE SUBCOMMAND AND DISPATCH LIST FOR CLEAR COMMAND USED IN
;BATCON AND BATCTL

DEFINE	CLRSUB<
CQQ==0
	TE(.CBATC,<BATCON>,WHLSEE!WHLDO)	;CLEAR BATCON
	TE(.CQUE,<QUEUE>,WHLSEE!WHLDO)		;CLEAR BATCH QUEUE
	0

MCLRSB==CQQ-1
>

;NAMES OF QUEUE FILE AND QUEUE WORK FILE
	IFE	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCH.QUEUE;P777740;1/
JOBFS:	XWD	440700,[ASCIZ /<BATCH>JOB.*;*/]
DJOBS:	XWD	440700,[ASCIZ /<BATCH>DJOB.*;*/]
	>
	IFN	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCHTEST.QUEUE;P777740;1/
JOBFS:	XWD	440700,[ASCIZ /<BATCH>TESTJOB.*;*/]
DJOBS:	XWD	440700,[ASCIZ /<BATCH>TESTDJOB.*;*/]
	>

;LITERAL POOL
	LIT
;PURE DATA STORAGE

;MAIN COMMAND LIST
LIST1:	CTLLST				;COMMAND LIST AND DISPATCH - PRIMARY

LIST2:	STASUB				;SUBCOMMAND LIST AND DISP FOR STATUS

LIST3:	CLRSUB				;SUBCOMMAND LIST AND DISP FOR CLEAR

	PURGE	CQQ,TE,CTLLST,STASUB,CLRSUB

;NAMES OF QUEUE FILE AND QUEUE WORK FILE
	IFE	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCH.QUEUE;P777740;1/
JOBFS:	XWD	440700,[ASCIZ /<BATCH>JOB.*;*/]
DJOBS:	XWD	440700,[ASCIZ /<BATCH>DJOB.*;*/]
CJOBS:	XWD	440700,[ASCIZ /<BATCH>CJOB.*;*/]
	>
	IFN	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCHTEST.QUEUE;P777740;1/
JOBFS:	XWD	440700,[ASCIZ /<BATCH>TESTJOB.*;*/]
DJOBS:	XWD	440700,[ASCIZ /<BATCH>TESTDJOB.*;*/]
CJOBS:	XWD	440700,[ASCIZ /<BATCH>TESTCJOB.*;*/]
	>


;INTERRUPT SERVICE STUFF
LEVTAB:	EXP	LEV1PC,LEV2PC,LEV3PC
CHNTAB:	3,,CTLO				;^O ON CHANNEL 0
	REPEAT ^D35,<0>


;LITERAL POOL
	LIT
;IMPURE DATA AND WORK AREAS

;LOCATIONS FOR CMDRDR.
ALIST:	BLOCK	1			;POINT TO LIST OF POSSIBLE CMDS
CAPS:	BLOCK	1			;POSSIBLE CAPABILITIES,,ENABLED.
EOCCH:	BLOCK	1			;END COMMAND CHARACTER
EOCPTR:	BLOCK	1			;POINTER TO LAST CHAR IN COMMAND
					;MOVED TO PCMD2 FOR NEXT FIELD
PCMD:	BLOCK	1			;POINT TO FULL COMMAND STRING
					;USED BY ^R ROUTINE
PCMD2:	BLOCK	1			;POINTER TO STORE NEW FIELD WITH
LOGNAM:	BLOCK	^D8		;STRING BLOCK FOR LOGFILE NAME
TIMSTR:	BLOCK	1			;POINTER AND FLAG FOR TIME INPUT
	IFN	STRACT,<
STRFLG:	BLOCK	1			;FLAG FOR USE IN CMDRDR WHEN
					;SEARCHING FOR ACCOUNT STRING
	>
DESUB:	BLOCK	1		;FLAG TO SPECIFY DE-SUBMITTING OF ENTRY
FOUND:	BLOCK	1		;NUMBER OF ENTRIES DELETED
;	VARIABLES USED IN DELETING ENTRIES FROM QUEUE
QJFN:	BLOCK	1
OLDQ:	BLOCK	1
QPNTR:	BLOCK	1
LOGJFN:	BLOCK	1			;LOG FILE JFN
SIZE:	BLOCK	1			;SIZE OF QUEUE
FFLAG:	BLOCK	1			;PRINTOUT FLAG
TTYJNM:	BLOCK	1			;TTYJOB TABLE INDEX
COUNT:	BLOCK	1			;COUNT OF ACTIVE TTY'S
JBJFN:	BLOCK	1			;JFN FOR NAMES OF JOBS WAITING TO BE QUEUED
COMPRG:	BLOCK	1			;COMMAND INPUT
SUBACA:	BLOCK	1			;SAVE AC A TEMPORARILY
SUBLAD:	BLOCK	1			;SUBCOMMAND DISP LIST ADDRESS
RECOG:	BLOCK	1			;FLAG IF RECOGNITION WAS SPECIFIED
STRPTR:	BLOCK	1			;TEMP STORAGE OF STRING POINTER


IFN	STRACT,<
IFN	TNX131,<
;STORAGE REQUIRED FOR STRING ACCOUNTING
UACBLK:	BLOCK 20		;AC ARG BLOCK
	>
	>

;THE COMMAND LINE
COMMAN:	BLOCK	20			;HOPE WON'T OVERFLOW THIS

;THE QUEUE ENTRY WE ARE BUILDING

;FILENAME FOR INDIRECT SUBMIT
JBNAME:	BLOCK	12			;STORAGE FOR IT
JBBLK:	600001,,0			;BLOCK FOR LONG GTJFN
	377777,,377777			;FOR JOB REQUEST FILE
	0				;DSP DEVICE
	POINT	7,[ASCIZ /BATCH/]	;DSP DIRECTORY
	IFN	DBGFIL,<
	POINT	7,[ASCIZ /TESTJOB/]
	>
	IFE	DBGFIL,<
	POINT	7,[ASCIZ /JOB/]		;DSP NAME
	>
	POINT	7,JBNAME		;DSP EXT
	500000,,777720			;DSP PROTECTION
	0				;DSP ACCOUNT
	0				;DESIRED JFN (NOT SPECIFIED)

DJBBLK:	600001,,0			;BLOCK FOR LONG GTJFN
	377777,,377777			;FOR JOB REQUEST FILE
	0				;DSP DEVICE
	POINT	7,[ASCIZ /BATCH/]	;DSP DIRECTORY
	IFN	DBGFIL,<
	POINT	7,[ASCIZ /TESTDJOB/]
	>
	IFE	DBGFIL,<
	POINT	7,[ASCIZ /DJOB/]	;DSP NAME
	>
	POINT	7,JBNAME		;DSP EXT
	500000,,777720			;DSP PROTECTION
	0				;DSP ACCOUNT
	0				;DESIRED JFN (NOT SPECIFIED)

CJBBLK:	600001,,0			;BLOCK FOR LONG GTJFN
	377777,,377777			;FOR JOB REQUEST FILE
	0				;DSP DEVICE
	POINT	7,[ASCIZ /BATCH/]	;DSP DIRECTORY
	IFN	DBGFIL,<
	POINT	7,[ASCIZ /TESTCJOB/]
	>
	IFE	DBGFIL,<
	POINT	7,[ASCIZ /CJOB/]	;DSP NAME
	>
	POINT	7,JBNAME		;DSP EXT
	500000,,777700			;DSP PROTECTION
	0				;DSP ACCOUNT
	0				;DESIRED JFN (NOT SPECIFIED)

PSEUD1:	PTYRNG				 ;=-# PTYS,,1ST PTY #

;OUR PUSH DOWN LIST
PDL:	BLOCK	PDLL+1			;STACK
JOBSTR:	BLOCK	10			;BUFFER FOR BUILDING JOB NAME

;GENERATED VARIABLES
	VAR

	LIT
QENT:	BLOCK	QESIZE		;Q ENTRY

;	ENTIRE QUEUE IS READ INTO THIS BUFFER WHEN DISPLAYING STATUS
;	DON'T PUT ANYTHING VALUABLE AFTER IT
FENT:	BLOCK	QESIZE			;Q ENTRY
	END	START
