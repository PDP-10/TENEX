;<BATCH>BATCON.MAC;16  12/3/76 08:00		EDIT BY RINDFLEISCH
;  Fixed SNDMSG code for dual processor operation so temp msg file
;	doesn't get expunged by superior while message being setup
;  Added code for MODIFYing jobs already in queue
;<BATCH>BATCON.MAC;15  10/3/76 12:40		EDIT BY RINDFLEISCH
;  Added checks to avoid duplicate job numbers in queue
;  Added checks for system ENTFLG, DBUGSW, and HALT TIME to clear out
;	running jobs and not submit others
;  Made SNDMSG available from all forks to inform users better
;  Put CLOSF in for LOG file when starting to force it to be real for
;	other GTJFN's
;  Put limit on number of bug-caused restarts in one day
;  Handler for involuntary terminations of lower forks
;  Hack for bug in PSTO system call - generates illegal instr sometimes
;  Added code so DAYFILE, ABNORMAL-TERMINATION.LOG, and CRASH.MSG start
;	with most recent entries at beginning
;  Included Ron Roberts (@IMSSS) log file line labelling options under
;	IMSLOG switch.  Also put in IMSSS switch and specific code.
;<BATCH>BATCON.MAC;14   4/28/76 14:45		EDIT BY RINDFLEISCH
;  Added code to reset login date after user logged in (avoids
;  missing system messages)
;<BATCH>BATCON.MAC;13   4/2/76 11:00		EDIT BY RINDFLEISCH
;  Added JBSTAT and FKSTAT tables for current status
;  Added control functions for BATCON and job/queue management
;<BATCH>BATCON.MAC;12	3-MAR-76 16:45		EDIT BY RINDFLEISCH
;  Release job PTY's at startup
;  Fixed 131 Load Average calculation to use maximum value
;  Added to priority calc that each user can't have more than MAXJBS
;	at once during prime time
;  Fixed test for start of inferior fork to be sure its private data
;	page is copied before looking for other jobs
;  Fixed ^S status report on inferior forks to work
;<BATCH>BATCON.MAC;11    31-OCT-75 10:59:50    EDIT BY LIEB
;ADDED PATCHS FROM SRI-AI TO CURE RACE CONDITIONS
;<BATCH>BATCON.MAC;10    10-SEP-75 15:08:10    EDIT BY LIEB
;USE RECURSIVE ROUTINE TO GET A PTY THAT INSURES NO JOB AT OTHER END
;GET ALL THE OUTPUT FROM PTY AT EOJ TIME. REWORK TERMINATION LOGIC
;ADD CONTROLS OVER ELAPSED TIME,CPU TIME, AND LOG LENGTH
;REWORK RUN LOOP AND GET RID OF PUSHJ'S THAT NEVER RETURN ETC
;REWORK DEBUGGING STUFF AND REARRANGE FORK STARTING
;TO PREVENT MYSTERIOUS FORK DISAPPEARANCES
;<BATCH>BATCON.MAC;7     4-SEP-75 10:14:37    EDIT BY LIEB
;added tnx131 switchs and got rid of BUG STOPs (made sense of them)
;<BATCH>BATCON.MAC;143    15-AUG-75 09:28:33    EDIT BY MOUTON
;ADDED IMPROVEMENTS BY DENNIS SMITH AT ECL
;<BATCH>BATCON.MAC;137     8-AUG-75 13:39:24    EDIT BY UNTULIS
;ADDED ^S INFERIOR FORK STATUS CODE
;<BATCH>BATCON.MAC;133     7-AUG-75 15:26:11    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;132     7-AUG-75 15:13:33    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;131     7-AUG-75 13:30:40    EDIT BY MOUTON
;ADDED LENGTH AND TIME OPTIONS
;<BATCH>BATCON.MAC;129     5-AUG-75 10:01:20    EDIT BY UNTULIS
;CORRECTED EOJ31 ERROR OF FILE BUSY CHECK
;<BATCH>BATCON.MAC;128     2-AUG-75 12:18:02    EDIT BY UNTULIS
;FIXED Q COPY LOOPING PROBLEM
;<BATCH>BATCON.MAC;127     1-AUG-75 23:10:50    EDIT BY UNTULIS
;FIXED LOG FILE GTJFN FAILURES (ILLEGAL VERSION)
;<BATCH>BATCON.MAC;103    22-JUL-75 15:45:26    EDIT BY MOUTON
;ADD CODE TO KEEP TRACK OF BATCH JOBS IN DAYFILE
;<BATCH>BATCON.MAC;96    22-JUL-75 10:53:30    EDIT BY UNTULIS
;ADD CODE TO OUTPUT BUG MESSAGES TO FILE INSTEAD OF LOGGING TTY
;<BATCH>BATCON.MAC;95    22-JUL-75 10:23:49    EDIT BY UNTULIS
;ADDED CRASH NOTIFICATION CODE ON BUG MESSAGES
;<BATCH>BATCON.MAC;81    14-JUL-75 15:07:25    EDIT BY UNTULIS
;ADD LOAD AVERAGE THRESHOLD CODE
;<BATCH>BATCON.MAC;76     4-JUL-75 13:36:48    EDIT BY UNTULIS
;ADDED CODE TO PROCESS DESUBMIT REQUEST
;<BATCH>BATCON.MAC;49    13-JUN-75 14:12:41    EDIT BY UNTULIS
;<BATCH>MFORK.MAC;45    13-JUN-75 14:11:58    EDIT BY UNTULIS
;INTRODUCED MULTIPLE FORKS TO RUN BATCH JOBS
;ADDED PRIORITY COMMAND
;<BATCH>BATCON.MAC;48    19-MAY-75 13:57:38    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;47    30-APR-75 09:54:57    EDIT BY LYNCH
;ADD SYSTEM ACTIVITY FLAG SETTING
;<BATCH>BATCON.MAC;36    11-APR-75 14:11:33    EDIT BY UNTULIS
;CHANGED LPT OUTPUT FILE NAME TO LPT FROM LOG
;<BATCH>BATCON.MAC;33    28-MAR-75 10:10:21    EDIT BY UNTULIS
;ADD LARSON CHANGES
;<BATCH>BATCON.MAC;13     4-MAR-75 15:28:57    EDIT BY UNTULIS
;ADD SKUSR CODE FOR FORCING BATCH JOBS TO QUEUE 2
;<BATCH>BATCON.MAC;11     4-MAR-75 15:13:26    EDIT BY UNTULIS
;ADD SND MESSAGE CODE
;ADD CODE FOR EVOKING DDT
;<BATCH>BATCON.MAC;8    18-FEB-75 23:54:15    EDIT BY UNTULIS
;ADD LOCAL DIRECTORY NUMBER CHECK
;<BATCH>BATCON.MAC;2    10-FEB-75 10:24:51    EDIT BY UNTULIS
;EXPANDED QENT FOR STRING ACCOUNTS
;<LARSON>BATCON.MAC;110    31-DEC-74 11:19:57	EDIT BY LARSON
;FIXED INSERTION OF ESC IN LOGIN LINE
;<LARSON>BATCON.MAC;109    31-DEC-74 10:19:40	EDIT BY LARSON
;FIXED DOLOGI BUG BY MOVING THE LOAD OF DIRNUMB TO B AT END OF CKCTLS.
;<LARSON>BATCON.MAC;108    31-DEC-74 09:52:47	EDIT BY LARSON
;FIXED CKLOG0 BY ADDING THE RESTORE OF JFN
;<LARSON>BATCON.MAC;107    31-DEC-74 08:47:04	EDIT BY LARSON
;<LARSON>BATCON.MAC;106    31-DEC-74 08:43:45	EDIT BY LARSON
;PUT IN SPECIAL HANDLING FOR LOG FILES ON DEVICES:
;DSK: (NORMAL), NIL: (ALLOW), LPT: (CREATE NAME <PRINTER>LOG.USERNAME)
;<LARSON>BATCON.MAC;105    31-DEC-74 08:19:53	EDIT BY LARSON
;<LARSON>BATCON.MAC;104    31-DEC-74 08:14:27	EDIT BY LARSON
;PUT IN CHKACC
;<LARSON>BATCON.MAC;103    31-DEC-74 07:25:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;102    30-DEC-74 16:38:11	EDIT BY LARSON
;PUT IN CLOSF BEFORE DELF AT GETJB1 BECAUSE TENEX DOESN'T
;CLOSE IT AS JSYS MANUAL SEEMS TO SAY IT SHOULD.
;<LARSON>BATCON.MAC;101    30-DEC-74 15:31:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;100    30-DEC-74 14:18:12	EDIT BY LARSON
;<LARSON>BATCON.MAC;99    30-DEC-74 09:08:01	EDIT BY LARSON
;<LARSON>BATCON.MAC;98    30-DEC-74 08:27:26	EDIT BY LARSON
;<LARSON>BATCON.MAC;97    26-DEC-74 09:56:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;96    23-DEC-74 12:10:41	EDIT BY LARSON
;FIXED Q PROT TO 777700 FROM 770000
;<LARSON>BATCON.MAC;95    23-DEC-74 11:37:18	EDIT BY LARSON
;CHANGED THE QUEUE TO LIVE IN <BATCH>
;PUT IN SETNM FOR SYSTEM BATCH
;<LARSON>BATCON.MAC;92    21-DEC-74 16:29:35	EDIT BY LARSON
;PUT IN CODE TO SUPPORT THE USRACT FIELD OF QUEUE AND
;TO SUPPORT DUMB ACCOUNTING SYSTEM THAT WON'T TAKE ACCT # 1
;<LARSON>BATCON.MAC;91    20-DEC-74 12:37:16	EDIT BY LARSON
;<LARSON>BATCON.MAC;90    20-DEC-74 11:23:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;89    20-DEC-74 10:42:22	EDIT BY LARSON
;<LARSON>BATCON.MAC;88    20-DEC-74 10:29:24	EDIT BY LARSON
;<LARSON>BATCON.MAC;87    20-DEC-74 09:55:38	EDIT BY LARSON
;<LARSON>BATCON.MAC;86    20-DEC-74 09:13:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;85    20-DEC-74 08:26:20	EDIT BY LARSON
;<LARSON>BATCON.MAC;84    19-DEC-74 11:53:40	EDIT BY LARSON
;<LARSON>BATCON.MAC;83    19-DEC-74 11:49:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;82    19-DEC-74 10:51:38	EDIT BY LARSON
;<LARSON>BATCON.MAC;81    19-DEC-74 09:05:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;80    19-DEC-74 08:24:30	EDIT BY LARSON
;<LARSON>BATCON.MAC;79    18-DEC-74 17:00:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;78    18-DEC-74 15:26:44	EDIT BY LARSON
;<LARSON>BATCON.MAC;77    18-DEC-74 08:41:02	EDIT BY LARSON
;<LARSON>BATCON.MAC;76    18-DEC-74 08:29:26	EDIT BY LARSON
;<LARSON>BATCON.MAC;75    17-DEC-74 16:00:36	EDIT BY LARSON
;<LARSON>BATCON.MAC;74    17-DEC-74 09:40:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;73    17-DEC-74 09:21:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;72    17-DEC-74 09:15:18	EDIT BY LARSON
;<LARSON>BATCON.MAC;71    17-DEC-74 08:35:40	EDIT BY LARSON
;<LARSON>BATCON.MAC;70    16-DEC-74 16:50:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;69    16-DEC-74 16:07:50	EDIT BY LARSON
;<LARSON>BATCON.MAC;67    16-DEC-74 11:32:16	EDIT BY LARSON
;<LARSON>BATCON.MAC;66    10-DEC-74 11:58:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;65    10-DEC-74 11:48:59	EDIT BY LARSON
;<LARSON>BATCON.MAC;64    10-DEC-74 11:31:59	EDIT BY LARSON
;<LARSON>BATCON.MAC;63    10-DEC-74 11:07:56	EDIT BY LARSON
;<LARSON>BATCON.MAC;62    10-DEC-74 10:56:41	EDIT BY LARSON
;<LARSON>BATCON.MAC;61    10-DEC-74 10:33:29	EDIT BY LARSON
;<LARSON>BATCON.MAC;60    10-DEC-74 10:19:02	EDIT BY LARSON
;<LARSON>BATCON.MAC;54    16-NOV-74 13:24:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;53    15-NOV-74 08:59:00	EDIT BY LARSON
;<LARSON>BATCON.MAC;52    14-NOV-74 15:37:47	EDIT BY LARSON
;<LARSON>BATCON.MAC;51     4-NOV-74 15:17:24	EDIT BY LARSON
;<LARSON>BATCON.MAC;50    30-OCT-74 23:11:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;44    21-OCT-74 16:44:40	EDIT BY LARSON
;PUT IN PSI STUFF FOR EOF AND FILE ERRORS
;<LARSON>BATCON.MAC;40    14-OCT-74 17:27:19	EDIT BY LARSON
;FIXED ERR1 OPERATION
;<LARSON>BATCON.MAC;39    14-OCT-74 14:31:46	EDIT BY LARSON
;USED CONNECTED DIR, ACCT 1
;<LARSON>BATCON.MAC;31     3-OCT-74 09:22:27	EDIT BY LARSON
;<LARSON>BATCON.MAC;29     2-OCT-74 13:48:10	EDIT BY LARSON
;<LARSON>BATCON.MAC;28     1-OCT-74 13:43:48	EDIT BY LARSON
;ADDED END: AND FIXED SOME BUGS.
;<LARSON>BATCON.MAC;27    30-SEP-74 09:47:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;25    29-SEP-74 18:20:05	EDIT BY LARSON
;<LARSON>BATCON.MAC;21    26-SEP-74 16:16:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;18    20-SEP-74 09:08:46	EDIT BY LARSON
;<LARSON>BATCON.MAC;16    19-SEP-74 17:34:49	EDIT BY LARSON
;<LARSON>BATCON.MAC;14    13-SEP-74 18:38:22	EDIT BY LARSON
	TITLE	BATCON	BATCH CONTROLLER FOR TENEX
	SUBTTL	SUBTTL  BATCH PROCESSOR

	SEARCH	STENEX


;*********************************************************************

;The memory organization of BATCON is as follows:

;   Starting page		Program section
;	0		Superior BATCON fork
;	SHRLOC		Shared bug handling code
;	INFLOC		Inferior (per job) fork code
;	PRILOC		Private page containing per job data
;	40		Buffer for control commands
;	60		Buffer for inputting DAYFILE data
;	100		Buffer for message building
;	120		Job sequence file page (IFE FDBSEQ)

;*********************************************************************


;PTY OPDEFS
OPDEF	ASPTY	[JSYS 360]
OPDEF	REPTY	[JSYS 361]
OPDEF	PSTI	[JSYS 362]
OPDEF	PSTO	[JSYS 363]
OPDEF	SIBF	[JSYS 364]
IFN IMSSS,<
OPDEF	STNAM	[JSYS 676]		;IMSSS VERSION OF SETNM
	>

;LUUO OPDEFS
NUMUUO==0
DEFINE	ASSUUO(UUONAM)<
NUMUUO==NUMUUO+1
OPDEF	UUONAM	[<NUMUUO>B8]
	>

	ASSUUO	(<ERR1>)

;ASSEMBLY SWITCHES
IFNDEF	FSUSER,<FSUSER==0>		;USER/SINGLE JOB VERSION
IFNDEF	FSTCPY,<FSTCPY==1>		;TRIM Q VIA COPY AND RENAME
					;INSTEAD OF RESET POINTER.

;VARIABLE DEFINITIONS
NAPMIN==^D250				;MINIMUM NAP TIME
NAPMAX==^D15000				;MAXIMUM NAP TIME - SUPERSEDED BY
					;NAPMIN IF "NAPMIN>NAPMAX"
CHKTIM==^D20000				;DELAY BETWEEN RESOURCE CHECKS

MAXFK==16				;MAXIMUM NUMBER OF ACTIVE INFERIOR FORKS

CTLL==<^D100/5>+1			;MAX LENGTH OF CTL LINE
LOGL==<^D132/5>+1			;MAX LENGTH OF LOG LINE TO WRITE
PDLL==47				;SIZE OF PUSH DOWN LIST

;DEVICE DESIGNATORS.
DEVDSK==600000				;DSK:
DEVLPT==600007				;LPT:
DEVNIL==600015				;NIL:

CCODE==0				;INDEXES TO COMMAND QUEUE SUBFIELDS
CPARAM==1
CTIME==2
COPER==3

; Indexes to message text describing job status.  Used to communicate
; to DAYFILE or users via NOTIFY and SEND.
JSTART==0
JFINIS==1
JDESUB==2
JDETCH==3
JABORT==4
JDEFER==5
JSHALT==6
JWARN==7

;JOB STATUS BIT DEFINITIONS
FEXIST==1B0		;FORK EXISTS MANAGING THIS JOB
FHLTED==1B1		;MANAGING FORK HALTED
FFREEZ==1B2		;MANAGING FORK FROZEN
FPURGE==1B3		;PURGE THIS JOB FROM QUEUE
FRESET==1B4		;RESET BATCON FLAGS FOR THIS JOB IN QUEUE
FDEFER==1B5		;DEFER EXECUTION OF THIS JOB INDEFINITELY
FFSTRT==1B6		;FORCE START THIS JOB
FINQUE==1B7		;THIS JOB EXISTS IN THE QUEUE
FREQUE==1B8		;REQUEUE THIS JOB TO BE RUN AGAIN
FALLST==FPURGE+FRESET+FDEFER+FFSTRT+FREQUE


;FLAGS IN F
R.SEOL==1				;INTERNAL FLAG FOR RDCTL TO TELL ITSELF
					;THAT IT MUST SUPPRESS THE END OF THE
					;LINE (TRALING SPACES AND TERMINATOR)

R.SEMI==R.SEOL*2			;RDCTL RETURNS THIS FLAG TO TELL
					;THAT THIS LINE IS A COMMENT, AND THAT
					;IT SHOULD JUST BE COPIED TO THE
					;LOG FILE--DO NOT PASS IT TO THE
					;USER.  (IT IS NOT GUARANTEED TO
					;START WITH A ;).

R.MONC==R.SEMI*2			;THIS LINE IS TO GO TO THE MONITOR
					;(OR EXEC) LEVEL COMMAND INTERPETER

R.INTR==R.MONC*2			;THIS LINE CAN GO TO EITHER MONITOR
					;OR USER LEVEL, IT IS NOT SPECIFIED

R.USER==R.INTR*2			;THIS LINE GOES TO A USER LEVEL
					;PROGRAM AS DATA OR A COMMAND

R.BLNK==R.USER*2			;THIS PUT A BLANK LINE ON THE LOG
					;FILE, DO NOT PASS THIS LINE TO
					;THE USER JOB, DO NOT COPY THIS
					;LINE TO THE LOG FILE.

R.PCTF==R.BLNK*2			;THIS IS A FLAG INDICATING THAT
					;RESOURCE CONTROL INSTRUCTIONS
					;PRECEEDED THIS LINE.  DISPOSITION
					;DEPENDS ON WHETHER ENTERING EXEC
					;MODE OR CONTINUING IS PRESENT MODE.

R.RCTL==R.SEOL!R.SEMI!R.MONC!R.INTR!R.USER!R.BLNK	;ALL THE FLAGS SET BY
					;RDCTL, DEFINED FOR WHERE WE ZERO THEM
					;ALL AT ONCE.


L.NOEL==1				;FLAG TO TELL SNDLOG TO SUPPRESS THE CRLF


;MACRO DEFINITIONS
	DEFINE	ERROR(MSG,TO<0>)<
	XLIST
	ERR1	[TO,,[ASCIZ \MSG\]]
	LIST
	>


	DEFINE	BUG(STR,ADR<0>)<
;BUG MESSAGE AND HANDLING ROUTINE
;
;IF RETURN ADDRESS  = 0, GET MESSAGE, DUMP, AND RESTART/RELOAD
;		   GT 0, GET MESSAGE TO TTY0, CRASH FILE, AND SYSTEM
;			 PEOPLE, THEN CONTINUE AT RETURN ADDRESS

	XLIST
	JSR	[0
		 JSR	BUGSTP		;SET UP BUG PARAMS
		 [ASCIZ /STR/]
		 ADR]
	LIST
	>				;END BUG MACRO


;MACRO TO TURN OFF INTERRUPT SYSTEM
	DEFINE	NOINT<
	PUSH	P,A
	MOVEI	A,400000
	SKPIR
	SKIPA
	DIR
	POP	P,A>

;MACRO TO TURN ON INTERRUPT SYSTEM
	DEFINE	OKINT<
	PUSH	P,A
	MOVEI	A,400000
	SKPIR
	EIR
	POP	P,A>


	SUBTTL	PRIMARY FORK CODE

;INITIALIZATION
START:	JRST	START0			;NORMAL START

START0:	MOVEM	0,BRSTCT		;SAVE LATEST RESTART COUNT
	RESET				;CLEAN ALL THINGS UP

	SETZ	0,			;CLEAR REGISTERS
	MOVEI	P,1
	BLT	P,16

	SETO	A,			;RELEASE ALL PTY'S
	REPTY
	BUG	(<START: Error releasing PTY's>)
	MOVE	P,[IOWD PDLL,PDL]	;INITIALIZE THE STACK
	MOVE	A,116			;GET THE SYMBOL TABLE POINTER
	MOVEM	A,SYMPTR		;AND PUT IT WHERE THE INFERIORS 
					;CAN GET IT

	MOVE	A,[SIXBIT /TTYJOB/]	;GET SYSTEM TABLE NUMBERS
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND TTYJOB TABLE>)
	HRRZM	B,TTYJOB

	MOVE	A,[SIXBIT /JOBTTY/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND JOBTTY TABLE>)
	HRRZM	B,JOBTTY

	MOVE	A,[SIXBIT /JOBRT/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND JOBRT TABLE>)
	HRRZM	B,JOBRT

	MOVE	A,[SIXBIT /JOBNAM/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND JOBNAM TABLE>)
	HRRZM	B,JOBNAM

	MOVE	A,[SIXBIT /SNAMES/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND SNAMES TABLE>)
	HRRZM	B,SNAMES

	MOVE	A,[SIXBIT /JOBDIR/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND JOBDIR TABLE>)
	MOVEM	B,JOBDIR
	HLRE	B,B			;CHECK TABLE SIZE
	MOVM	B,B
	CAILE	B,NJOBS			;WILL IT FIT THE TABLE?
	BUG	(<START: TOO MANY JOBS TO FIT JOBDIR TABLE>)
	MOVEM	B,NJOBTB		;OK, STORE THE NUMBER OF ENTRIES

IFE IMSSS+SUMEX,<
	MOVE	A,[SIXBIT /ENTFLG/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND ENTFLG TABLE>)
	MOVEM	B,SYSENT
	>	;END SUMEX CONDITIONAL

	MOVE	A,[SIXBIT /DBUGSW/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND DBUGSW TABLE>)
	MOVEM	B,SYSDBG

	MOVE	A,[SIXBIT /SYSTAT/]
	SYSGT
	CAIN	B,0			;SKIP IF TABLE FOUND
	BUG	(<START: COULD NOT FIND SYSTAT TABLE>)
	MOVEM	B,SYSTAT

;DETERMINE OUR STATUS (AND ENABLE OURSELF)
	SETZM	WHEEL			;ASSUME NON-WHEEL
	MOVEI	A,400000		;US
	RPCAP				;SEE WHAT WE HAVE
	MOVE	C,B			;ALL POSSIBLE
	EPCAP				;TURN THEM ON
	TRNE	C,600000		;WHEEL OR OPER?
	SETOM	WHEEL			;YES

;ARE WE DETACHED?
	GJINF				;FIND OUT ABOUT OURSELVES.
	MOVEM	D,DETSW			;SAVE STATUS
	MOVEM	C,JOBNO			;SAVE OUR JOB #
	SETOM	MYNAME			;SAY I'M THE TOP GUY IN THE PRIV PAGE
	JRST	WAITS

WAIT60:	MOVEI	A,^D60000	;WAIT ONE MINUTE
	DISMS			;ZZZZ
	JRST WAITS

;CHECK IF WE HAVE TIME YET, ENTFLG = -1, DBUGSW NE 2, AND HALT NOT TOO
;CLOSE

WAITS:	PUSHJ	P,PROCED	;CHECK WHETHER OK TO PROCEED
	JFCL			;NO - HERE IF TIME, ENTFLG, OR DBUGSW
	JRST	WAIT60		;NO - HERE FOR IMPENDING HALT

	GTAD			;OK - GET CURRENT TIME AND SAVE AS
	MOVEM	A,BATSTT	;BATCH PROCESSOR START TIME

;INITIALIZE LUUO TRAP

UUOINI:	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

	MOVEI	A,400000		;PRESENT FORK
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	MOVE	A,[XWD ^D19,2]
	ATI				;SET ^S FOR INFERIOR FORK STATUS
	MOVEI	A,400000
	MOVE	B,[1B2+1B19]		;ACTIVATE PSEUDO INTERRUPTS
					;  CH  2:  ^S STATUS COMMAND
					;  CH 19:  INFERIOR HALTED
	AIC
	OKINT

;INITIALIZE FLAGS
	SETZ	ZZ,			;CLEAR FLAG WORD
	SETZM	STRTFK			;CLEAR INFERIOR STARTING FLAGS
	SETZM	HLTDFK			;CLEAR INFERIOR HALTED FLAGS
	SETOM	ENTFLG			;SET ENTRY FLAG TO ALLOW EVERYONE
	SETZM	JOBHLT			;SET BATCON TO RUN
	SETOM	SNDLCK			;CLEAR ROUTINE LOCKS
	SETOM	BUGLCK
	SETOM	DAYLCK
	SETOM	WHOSND			;CLEAR USER INFORMATION
	SETOM	WHOBUG
	SETOM	WHODAY
	SETZM	QJFN
	SETZM	SEQJFN
	SETZM	FORK			;SNDMSG FREE
	SETZM	RELFRK
	SETZM	FORCST
	SETZM	CTLTSK			;FRESH CONTROL TASK COUNTER

	MOVE	A,[XWD FKSTAT,FKSTAT+1]	;CLEAR FORK STATUS ARRAY
	SETOM	FKSTAT
	BLT	A,FKSTAT+MAXFK

	MOVE	A,[XWD JBSTAT,JBSTAT+1]	;CLEAR JOB STATUS TABLE
	SETZM	JBSTAT
	BLT	A,JBSTAT+NQJBS

	IFN	GDDT,<
	PUSHJ	P,SETDDT	;SET UP DDT
	>

IFE	FSUSER,<			;STUFF IF SYSTEM BATCH
;DO A SETNM SO WE HAVE A NAME
	MOVE	A,[SIXBIT /BATCON/]	;OUR NAME IS 'BATCON'
IFE	DBGFIL,<
IFN	SUMEX,<
	SETNM				;SET IT
	>	;END SUMEX
IFN	IMSSS,<
	STNAM				;SET IT ALA IMSSS
	>	;END IMSSS
	>	;END DBGFIL

;NOW GET CONNECTED TO THE BATCH Q DIRECTORY
	MOVEI	A,1			;TRY EXACT MATCH
	HRROI	B,BATDIR		;DIRECTORY NAME
	STDIR				;GET DIR #
	BUG	(<Error return from STDIR for Q directory--no match>)
	BUG	(<Error return from STDIR for Q directory--ambiguous>)
	TLZ	A,-1			;CLEAR LH
	MOVEM	A,BATDN			;SAVE SO WE CAN EXPUNGE DIR LATER
	SETZ	B,			;NO PASSWORD STRING
	CNDIR				;CONNECT TO IT
	BUG	(<CNDIR to Q directory failed>)

	SKIPL	DETSW			;ARE WE DETACHED?
	JRST CRSHJ1			;NO,DON'T BOTHER SETTING TTY
	MOVEI	A,400000		;DETACHED - SET UP TTY0 AS PRIMARY
	MOVE	B,[XWD -1,400000]	;INPUT = CTL TTY, OUTPUT = TTY0
	SPJFN
	JRST	CRSHJ1

;	THIS ROUTINE UNDOES THE PREVIOUS SETTING OF PRIMARY JFNS FOR
;	DDT
DDT:	MOVEI	A,400000		;DETACHED - SET UP TTY0 AS PRIMARY
	MOVE	B,[XWD -1,-1]		;INPUT/OUTPUT = CONTROLLING TTY
	SPJFN
	JRST	770000			;GO TO THE START OF DDT
	>				;END IFE FSUSER

CRSHJ1:	PUSHJ	P,QUECOP		;GO SCAN THROUGH QUEUE TO SET UP
					;JOB STATUS INFORMATION

	SETZM	FLNMSW			;SEND STARTUP MSG TO DAYFILE
	MOVE	A,BATDN
	MOVEM	A,QENT+USRDIR
	SETZM	QENT+BJOBNO
	HRROI	B,DAYOOP
	HRROI	C,[ASCIZ / RESTARTING ON /]
	HRROI	D,[ASCIZ /]

/]
	PUSHJ	P,DAY

IFE	FSUSER,<			;GENERATE SYSTEM BATCON STUFF
;  The following sections of the superior fork
;	1)  Look for new jobs to add to the queue (or modify)
;	2)  Look for jobs to be desubmitted from the queue
;	3)  Look for control tasks to perform (submitted by system staff)
;	4)  If system status allows jobs to run, scan the queue for the
;		next highest priority job to run and set up the run
;		parameters.
;	5)  If there is a job to run, start up the controlling inferior

;FIRST, SEE IF SYSTEM STATUS ALLOWS US TO PROCEED
GETJOB:	PUSHJ	P,PROCED		;CHECK STATUS
	JRST	[MOVSI	A,(1B3)		;SYSTEM DOWN - STOP JOBS VIA CH 3
		 JRST	NOGTJB]
	JRST	[MOVSI	A,(1B5)		;HALT COMING - STOP JOBS VIA CH 5
		 JRST	NOGTJB]
	JRST	OKGTJB			;EVERYTHING RUNNING - GET JOBS

NOGTJB:	MOVEI	B,1			;FAKE COMMAND FROM <SYSTEM>
	MOVEM	B,QENT+USRDIR
	SETZM	QENT+BJOBNO		;SAY JOB 0
	PUSHJ	P,CLRBAT		;CLEAR BATCON IF NECESSARY
	MOVE	0,BRSTCT		;SET TO STORE RESTART COUNT
	JRST	START			;REALLY RESET EVERYTHING

;CHECK FOR ANY WORK TO ADD TO THE QUEUE - FOUND IN CJOB FILES
;   IF JOB # > 0 => NEW JOB TO ENTER
;	     < 0 => REPLACES EXISTING JOB
OKGTJB:	MOVSI	A,(1B2!1B7!1B11!1B17)	;OLD,NO OTHER ACCESS,INPUT,*,SHORT
	HRROI	B,JBNAMS		;GET FORMAT OF JOB NAMES
	GTJFN				;GET THE JFN
	JRST	GETDSB			;NONE, CHECK FOR DESUBMISSIONS
	PUSH	P,A			;SAVE GROUP JFN

;OK, OPEN THE BATCH QUEUE
	MOVSI	A,(1B7!1B17)		;GET Q, NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG	(<GETJOB: Gtjfn failure for Q>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

	MOVE	B,[1,,FDBUSW]		;GET THE USER SETTABLE WORD
	MOVEI	C,MXJBNO#		;WHERE TO PUT IT
	GTFDB
	MOVE	A,QJFN			;GET JFN OF Q
	MOVE	B,[44B5+1B22]		;OPEN FOR 36 BIT, APPEND
	QOPENF				;OPEN THE Q
	BUG	(<GETJOB: CANNOT OPEN Q FOR APPEND>)
	SKIPA				;TIME OUT ERROR
	JRST	GETJB0			;GET AROUND ERROR STUFF

	POP	P,A			;CLEAR GROUP JFN
	BUG	(<GETJOB: TIME OUT OPENING Q>,QOPTMO)

GETJB0:	MOVE	A,[POINT 36,QENT]	;BUFFER FOR JOB FILE ENTRY
	PUSHJ	P,CHKFIL		;OPEN JOB FILE, GET FDB, GET
					;ENTRY, AND CHECK VALIDITY
	JRST	[SETZ	A,		;NOT REAL FILE, DON'T DELETE IT
		 JRST	GETJB1+1]	;TRY AGAIN LATER
	JRST	[PUSHJ	P,PTRASH	;BAD ENTRY, TRASH IT
		 JRST	GETJB1]
	JFCL				;GOOD ONE - USER NOT WHEEL
	JFCL				;GOOD ONE - WHEEL, CHECK JOB #

	MOVM	A,QENT+BJOBNO		;GET MAGNITUDE OF JOB #
	CAIE	A,0			;MAKE SURE JOB # IS IN RANGE
	CAILE	A,NQJBS
	MOVEI	A,1			;OOPS, RESET TO 1
	PUSH	P,A			;SAVE STARTING JOB #
	IDIVI	A,^D36			;COMPUTE FIRST BIT TABLE ADDRESS
	MOVSI	C,(1B0)			;AND SET UP BIT MASK
	MOVN	B,B
	LSH	C,0(B)
	MOVE	B,0(P)			;RESTORE STARTING JOB #
GETJB2:	TDNN	C,JBBITS(A)		;IS THIS SLOT IN USE?
	JRST	GTJB20			;NOPE, GO GRAB IT

	SKIPG	QENT+BJOBNO		;SLOT IN USE - CHG JOB REQUEST?
	JRST	GTJB25			;YES, PROCESS IT
	AOJ	B,			;NO, TRY THE NEXT ONE
	ROT	C,-1			;SLIP THE BIT MASK
	TLNE	C,(1B0)			;IF IT HAS WRAPPED AROUND,
	AOJ	A,			;BUMP THE BIT TABLE WORD AS WELL
	CAILE	B,NQJBS			;IF THE JOB NUMBER WRAPPED AROUND
	JRST	[SETZ	A,		;ZERO BIT TABLE WORD INDEX
		 MOVEI	B,1		;START OVER AT JOB 1
		 MOVSI	C,(1B1)		;SET BIT MASK (NO JOB 0)
		 SETZM	MXJBNO		;RESET MAX JOB NUMBER AS WELL
		 JRST	.+1]
	CAME	B,0(P)			;HAVE WE GONE FULL CIRCUIT?
	JRST	GETJB2			;NO, GO TEST THIS ONE

	POP	P,B			;CLEAR STARTING JOB #
	SETZ	A,			;HERE ALL SLOTS ARE FULL SO
	JRST	GETJB1+1		;DON'T DELETE FILE - TRY LATER

;  HERE WE HAVE A FREE SLOT.  CHECK TO SEE IF CHANGE REQUEST (BAD NEWS
;  SINCE CAN'T CHANGE NONEXISTENT JOB) OR NEW JOB.  IF JOB NUMBER HAD
;  TO BE CHANGED TO FIND FREE SLOT, DO IT EVERYWHERE
GTJB20:	POP	P,D			;CLEAR STARTING JOB #
	SKIPG	QENT+BJOBNO		;NEW JOB REQUEST?
	JRST	GTJB26			;NO, IGNORE CHANGE REQUEST
	IORM	C,JBBITS(A)		;GOOD NUMBER, SET IN-USE BIT
	CAML	B,MXJBNO		;DO WE HAVE A NEW MAXIMUM?
	JRST	[MOVE	D,B		;YES, BUMP IT ONE MORE
		 AOJ	D,
		 CAILE	D,NQJBS		;DID IT GO OVER?
		 MOVEI	D,1		;YES, THEN RESET IT
		 MOVEM	D,MXJBNO	;NOW UPDATE THE CORE VALUE
		 JRST	.+1]		;AND CARRY ON
	CAMN	B,QENT+BJOBNO		;HAVE WE CHANGED THE USER'S #?
	JRST	GETJB3			;NO, ENTER HIM IN THE Q

	MOVE	D,B			;YES, SAVE THE NEW NUMBER
	MOVE	A,JBNCHG		;DO WE HAVE ROOM IN THE CHANGE TABLE?
	CAIL	A,MXCHG
	JRST	[SETZ	A,		;NO, SO LET THE FILE BE FOR NOW
		 JRST	GETJB1+1]	;AND GET THE NEXT ONE
	AOS	A,JBNCHG		;YES, BUMP THE COUNT
	HRRM	D,JBNCHG(A)		;PUT NEW # IN RH OF TABLE ENTRY
	MOVE	B,QENT+BJOBNO		;AND THE OLD ONE IN LH
	HRLM	B,JBNCHG(A)
	MOVE	B,QENT+ENTERD		;ALSO RECORD WHEN JOB WAS ENTERED
	MOVEM	B,JOBENT(A)		;TO RECONCILE OTHER LATER JOB PARAMS
	SETOM	RUNQCP			;AND SET TO RUN THE Q COPY

	HRROI	A,STRBUF		;MAKE MESSAGE TO NOTIFY WORLD
	HRROI	B,[ASCIZ / RENUMBERED TO /]
	SETZ	C,
	SOUT
	MOVE	B,D			;GET NEW JOB NUMBER
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ / ON /]
	SETZ	C,
	SOUT

	HRROI	B,STRBUF		;NOW GO TELL THE WORLD
	SETZ	C,			;NO APPENDIX
	PUSHJ	P,WINFRM

	MOVEM	D,QENT+BJOBNO		;INSTALL NEW JOB NUMBER
	JRST	GETJB3			;AND ENTER JOB IN Q

;  HERE WE HAVE A CHANGE REQUEST FOR AN EXISTING JOB.  CHECK VALIDITY,
;  STOP JOB IF ALREADY RUNNING, AND UPDATE THE QUEUE.
GTJB25:	POP	P,A			;CLEAR STARTING JOB # FROM STACK
	MOVN	B,A
	CAMN	B,QENT+BJOBNO		;JOB #'S AGREE?
	SKIPN	B,JBSTAT(A)		;AND JOB IN Q?
	JRST	GTJB26			;NO, IGNORE REQUEST
	HLRZ	C,B			;OK, STRIP USER DIR FOR THIS JOB
	ANDI	C,777
	CAME	C,QENT+USRDIR		;DOES THIS GUY OWN IT?
	JRST	[HRROI	A,STRBUF	;NOPE!
		 HRROI	B,[ASCIZ /
    </]
		 SETZ	C,
		 SOUT
		 MOVE	B,QENT+USRDIR
		 DIRST
		 JFCL
		 HRROI	B,[ASCIZ /> CANNOT MODIFY THIS JOB/]
		 SOUT

		 MOVMS	A,QENT+BJOBNO	;MAKE JOB # POSITIVE FOR MSG
		 HRROI	B,[ASCIZ / UNCHANGED ON /]	;NOW TELL THE WORLD
		 HRROI	C,STRBUF
		 PUSHJ	P,WINFRM
		 JRST	GETJB1]		;DO THE NEXT ENTRY

	NOINT				;USER OK, CHECK JOB STATUS
	PUSHJ	P,JOBSIT
	JRST	GTJB26			;NO SUCH JOB
	JRST	GTJB27			;JOB IN Q, NOT RUNNING
	JRST	GTJB26			;JOB ALREADY FINISHED - IGNORE
	JRST	GTJB28			;JOB RUNNING BUT FROZEN, STOP IT
	JRST	GTJB29			;JOB RUNNING MELTED, STOP IT

;JOB DOESN'T EXIST HERE OR HAS ALREADY HALTED
GTJB26:	OKINT
	MOVMS	A,QENT+BJOBNO		;MAKE JOB # POSITIVE FOR MSG
	HRROI	B,[ASCIZ / UNCHANGED ON /]
	HRROI	C,[ASCIZ /
    JOB NON-EXISTENT, CHANGE REQUEST IGNORED/]
	PUSHJ	P,WINFRM		;ANNOUNCE IT
	JRST	GETJB1			;DO THE NEXT ONE

;JOB EXISTS HERE BUT ISN'T RUNNING - FLAG IT FOR PURGING AND ADD NEW
;VERSION OF JOB ENTRY TO QUEUE
GTJB27:	OKINT
	TLO	B,(FPURGE)		;UPDATE JBSTAT FOR PURGE
	MOVEM	B,JBSTAT(A)
	SETOM	RUNQCP			;MAKE SURE QUEUE IS EXAMINED
	JRST	GETJB3			;ADD NEW JOB TO QUEUE

;JOB RUNNING FROZEN HERE, THAW IT
GTJB28:	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE OF JOB
	RFORK				;AND RESUME IT

;JOB RUNNING MELTED HERE, KILL IT AND TACK NEW VERSION TO QUEUE
GTJB29:	SETZM	FLNMSW			;POST DAYFILE MESSAGE
	MOVMS	A,QENT+BJOBNO		;POS JOB # FOR MSG
	HRROI	B,JOBDAY
	HRROI	C,[ASCIZ / ABORT REQ FOR MODIFY ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	MOVSI	B,(1B3)			;USE CHAN 3 (IMMEDIATE)
	PUSHJ	P,FRCHLT		;HALT THE FORK
	MOVNS	A,QENT+BJOBNO		;RESTORE NEG JOB #
	JRST	GETJB3			;NOW ADD JOB TO Q
	
;APPEND JOB TO MASTER QUEUE - IT WAS LEGAL
GETJB3:	MOVE	A,QJFN			;GET Q'S JFN
	MOVE	B,[POINT 36,QENT]
	MOVNI	C,QESIZE		;IT'S LENGTH
	SOUT				;WRITE IT

	SKIPG	A,QENT+BJOBNO		;SET UP JOB STATUS ENTRY
	JRST	GETJB1			;IF NEW JOB ENTRY
	MOVSI	B,(FINQUE)		;TO SHOW JOB IS IN QUEUE
	HRLZ	C,QENT+USRDIR		;ADD ON USER DIRECTORY NUMBER
	ADD	B,C
	MOVEM	B,JBSTAT(A)		;SAVE THE INFO IN JOB STATUS TABLE


;DELETE IT
GETJB1:	SETO	A,			;DELETE CURRENT FILE AND SEE IF
	PUSHJ	P,NXTFIL		;THERE IS MORE
	SKIPA				;NO MORE
	JRST	GETJB0			;ANOTHER ONE THERE - GO BACK

	POP	P,A			;GET JFN WE USED

	MOVE	A,QJFN			;NOW UPDATE MXJBNO IN Q FDB
	HRLI	A,FDBUSW		;WORD TO CHANGE
	MOVEI	B,-1			;CHANGE THE RIGHT HALF
	MOVE	C,MXJBNO		;NEW VALUE
	CHFDB

	MOVE	A,QJFN			;CLOSE Q FOR NOW AND RELEASE JFN
	CLOSF
	BUG	(<CANNOT CLOSE Q JFN>)

IFE FDBSEQ,<
	PUSHJ	P,WRSQLK		;GO UPDATE THE JOB SEQ LOCK FILE
	>

	JRST	GETDSB			;NOW GO CHECK DESUBMITS

;NOW CHECK FOR ANY WORK TO DELETE FROM THE QUEUE

GETDSB:	MOVSI	A,(1B2!1B7!1B11!1B17)	;OLD,NO OTHER ACCESS,INPUT *,SHORT
	HRROI	B,DJBNMS		;GET FORMAT OF JOB NAMES
	GTJFN				;GET THE JFN
	JRST	GETCTL			;NONE - GO LOOK FOR CONTROL TASKS
	PUSH	P,A			;SAVE GROUP JFN

OPDREQ:	MOVE	A,[POINT 36,QENT]	;BUFFER FOR DESUBMIT REQUESTS
	PUSHJ	P,CHKFIL		;GO OPEN FILE, GET FDB, READ
					;REQUEST, AND CHECK VALIDITY
	JRST	[SETZ	A,		;NOT REAL FILE, DON'T DELETE IT
		 JRST	GETDB1]		;TRY AGAIN LATER
	JRST	DELDRQ			;NO GOOD - GO DELETE IT
	JFCL				;GOOD - NOT WHEEL

	SKIPLE	A,QENT+BJOBNO		;GET JOB NUMBER AND STATUS INFORMATION
	CAILE	A,NQJBS			;IS IT IN RANGE?
	JRST	DELDRQ			;NO, DELETE REQUEST
	MOVE	B,JBSTAT(A)		;JOB # OK, HOW ABOUT USRDIR?
	HLRZ	C,B			;ISOLATE USRDIR FOR THIS JOB
	ANDI	C,777
	CAME	C,QENT+USRDIR		;IS THIS REQUEST LIGIT?
	JRST	[HRROI	A,STRBUF	;NOPE!
		 HRROI	B,[ASCIZ /
    </]
		 SETZ	C,
		 SOUT
		 MOVE	B,QENT+USRDIR
		 DIRST
		 JFCL
		 HRROI	B,[ASCIZ /> CANNOT DESUBMIT THIS JOB/]
		 SOUT

		 HRROI	B,[ASCIZ / UNCHANGED ON /]	;NOW TELL THE WORLD
		 HRROI	C,STRBUF
		 PUSHJ	P,WINFRM
		 JRST	DELDRQ]		;DELETE THE REQUEST

	NOINT				;TURN OFF INTERRUPTS
	PUSHJ	P,JOBSIT		;CHECK JOB SITUATION
	JRST	DELDRQ			;NO SUCH JOB - DELETE REQUEST
	JRST	SETDEL			;NOT RUNNING - POST PURGE BIT
	JRST	DELDRQ			;ALREADY HALTED - GO ON
	JRST	STOPRN			;RUNNING FROZEN - MELT AND STOP
	JRST	INTINF			;RUNNING MELTED - STOP IT

SETDEL:	TLO	B,(FPURGE)		;SET PURGE BIT
	MOVEM	B,JBSTAT(A)
	SETOM	RUNQCP			;SET TO RUN Q COPY
	JRST	DELDRQ			;NEXT REQUEST

;	MELT FROZEN FORK
STOPRN:	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;MELT IT

;	STOP INFERIOR WITH DESUBMIT INTERRUPT - CAUSES GRACEFUL CLEANUP
INTINF:	SETZM	FLNMSW			;HAVE TO STOP A RUNNING JOB
	HRROI	B,JOBDAY		;SO POST A DAY FILE MSG
	HRROI	C,[ASCIZ / ABORT REQ FOR DESUBMIT ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY			;GO SEND IT

	MOVE	A,QENT+BJOBNO		;GET FORK HANDLE
	HRRZ	A,JBSTAT(A)
	MOVSI	B,(1B1)			;PSEUDO INTERRUPT ON CHANNEL 1
	IIC				;THIS WILL SET HALTED AND PURGE BITS
	JRST	DELDRQ			;THIS REQUEST TAKEN CARE OF -
					;GO TRY ANOTHER

;	DELETE DESUBMIT JOB REQUEST
DELDRQ:	OKINT				;REENABLE INTERRUPTS
	SETO	A,			;DELETE THIS ONE AND CHECK FOR MORE
GETDB1:	PUSHJ	P,NXTFIL
	SKIPA				;NO MORE
	JRST	OPDREQ			;GOT ANOTHER ONE - GO BACK

	POP	P,A			;GET JFN WE USED


;NOW SEE IF THERE ARE ANY CONTROL TASK REQUESTS - CJOB.*;*

GETCTL:	MOVSI	A,(1B2!1B7!1B11!1B17)	;OLD, NO ACCESS, *, SHORT
	HRROI	B,CJBNMS		;CJOB FILES
	GTJFN
	JRST	GETJBR			;NONE - GO EXPUNGE AND CHECK FOR
					;JOBS TO RUN
	PUSH	P,A			;YES, SAVE GROUP JFN ON STACK
	MOVEI	D,COMBUF		;POINT TO COMMAND BUFFER
	GTAD				;GET CURRENT TIME AND DATE
	MOVEM	A,NOWTIM		;SAVE IT FOR LATER

;NOW READ ALL EXECUTABLE COMMANDS INTO THE BUFFER AND SCAN THEM FROM THE
;OLDEST TO THE MOST RECENT FOR EXECUTION

PRCCTL:	MOVE	A,[POINT 36,QENT]	;BUFFER FOR CONTROL REQUEST -
					;MUST BE QENT BECAUSE FOLLOWING
					;USES "PRINT"
	PUSHJ	P,CHKFIL		;OPEN FILE, GET FDB, GET ENTRY,
					;AND CHECK VALIDITY
	JRST	[SETZ	A,		;NOT REAL FILE, DON'T DELETE IT
		 JRST	NXTCTL]		;TRY AGAIN LATER
	JRST	DELCTL			;NO GOOD - DELETE IT
	JRST	NOTWHL			;NO GOOD - NOT A WHEEL
	MOVE	A,QENT+COMCOD		;GET CONTROL CODE
	CAIL	A,0			;IS IT IN RANGE?
	CAILE	A,MCTLCD
	JRST	.ERRNG			;CODE IN ERROR - SEND MSG

	LSH	A,1			;CODE OK, INDEX DISPATCH ENTRY
	PUSH	P,A			;SAVE IT

	HRR	B,CTLDSP(A)		;MAKE STRING PTR FOR OUR DESCRIPTOR
	HRLI	B,440700
	MOVE	A,[POINT 7,QENT+COMNAM]	;GET STRING PTR FOR INPUT COMMAND
	PUSHJ	P,STRCMP		;GO COMPARE STRINGS
	JFCL				;DON'T MATCH
	JRST	.ERCMP			;NOT SAME LENGTH - GO LOG ERROR

					;OK, COMMAND IS GOOD.  DOES IT HAVE
					;A TIME TRIGGER READY TO FIRE?
	MOVE	A,QENT+AFTER		;CHECK FOR "AFTER JOB" REQUEST
	TLNE	A,-1			;LEFT HALF EMPTY?
	JRST	PRCCT1			;NO - MUST BE A DATE
	ANDI	A,777			;YES - EITHER NULL OR JOB REQUEST
	SKIPE	JBSTAT(A)		;IF JOB SPECIFIED AND IT'S STILL AROUND,
PRCCT0:	JRST	[POP	P,A		;DON'T RUN THIS ONE UNTIL IT IS GONE
		 SETZ	A,
		 JRST	NXTCTL]
	MOVE	A,NOWTIM		;OK JOB IS DONE - SET CURRENT
	MOVEM	A,QENT+AFTER		;DATE AND TIME AS EXECUTION TIME

PRCCT1:	MOVE	A,NOWTIM		;GET CURRENT TIME
	CAMN	A,[-1]			;WAS IT -1?
	JRST	PRCCT0			;REFUSE ALL TASKS IF TIME NOT SET
	CAMGE	A,QENT+AFTER		;CHECK IF IT CAN BE RUN YET.
	JRST	PRCCT0			;IT WANTS TO WAIT SOME MORE.
		 
	POP	P,A			;OK TO GO, RECOVER INDEX TO DISPATCH
	MOVEM	A,CCODE(D)		;ENTRY AND PUT IT IN THE COMM QUEUE
	MOVE	A,QENT+COMPAR		;SAVE THE COMMAND PARAMETER
	MOVEM	A,CPARAM(D)
	MOVE	A,QENT+AFTER		;WAS THIS A DELAYED COMMAND?
	TLNN	A,-1			;IF SO, USE ACTIVATION DATE
	MOVE	A,QENT+ENTERD		;ELSE USE TIME COMMAND ISSUED
	MOVEM	A,CTIME(D)
	MOVE	A,QENT+USRDIR		;SAVE THE ORIGINATOR
	MOVEM	A,COPER(D)

	ADDI	D,4			;BUMP QUEUE PTR, DELETE THIS FILE,
	JRST	DELCTL			;AND SEE IF THERE ARE MORE



;ERROR HERE - USER IS NOT A WHEEL AND HAS ISSUED A CONTROL COMMAND
NOTWHL:	HRROI	A,STRBUF		;NON-WHEEL TRYING - LOG IT
	HRROI	B,[ASCIZ /
** NON-WHEEL </]
	SETZ	C,
	SOUT
	HLRZ	B,FDBBLK+6		;GET AUTHOR
	DIRST
	JFCL				;IGNORE ERROR
	HRROI	B,[ASCIZ /> BATCH CTL REQUEST /]
	SOUT
	MOVEI	A,101			;DO PRIMARY TTY FIRST
	HRROI	B,STRBUF
	SETZ	C,
	SOUT
	HRROI	B,CRLF			;DO CRLF'S
	SOUT
	HRROI	B,CRLF
	SOUT

	MOVE	A,0(P)			;GET FILE JFN
	HRROI	B,STRBUF		;NOW ENTER IN CRASH FILE
	HRROI	C,[ASCIZ / - FILE DELETED
/]
	PUSHJ	P,BUGFIL		;ADD FILE NAME & PUT IN CRASH FILE

	JRST	DELCTL


;ERROR HERE - COMMAND CODE IS NOT IN THE RANGE OF OUR DISPATCH TABLE
.ERRNG:	HRROI	A,STRBUF		;COMPOSE MESSAGE
	HRROI	B,[ASCIZ / OUT OF RANGE - FILE DELETED
    BAD CODE = /]
	SETZ	C,
	SOUT
	MOVE	B,QENT+COMCOD		;ADD COMMAND CODE
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / (OCTAL)
/]
	SETZ	C,
	SOUT

	MOVE	A,0(P)			;GET FILE JFN
	HRROI	B,[ASCIZ /
CJOB CONTROL CODE ON /]
	HRROI	C,STRBUF
	PUSHJ	P,BUGFIL		;OUTPUT ERROR ON CRASH FILE

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAYFILE
	HRROI	B,JOBCTL		;POST DETAILS IN DAY FILE
	HRROI	C,[ASCIZ / CONTROL CODE OUT OF RANGE ON /]
	PUSH	P,D
	HRROI	D,DAYTRM
	PUSHJ	P,DAY
	POP	P,D

        JRST	DELCTL			;GO DELETE REQUEST


;ERROR HERE - COMMAND DESCRIPTOR MISMATCH BETWEEN INPUT COMMAND AND OUR
;DISPATCH TABLE
.ERCMP:	HRROI	A,STRBUF		;COMPOSE MESSAGE
	HRROI	B,[ASCIZ / DOESN'T MATCH - FILE DELETED
    INPUT CODE = /]
	SETZ	C,
	SOUT
	MOVE	B,QENT+COMCOD		;ADD COMMAND CODE
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / (OCTAL)
    INPUT DESCRIPTOR = </]
	SETZ	C,
	SOUT
	MOVE	B,[POINT 7,QENT+COMNAM]	;GET STRING PTR FOR INPUT COMMAND
	SOUT
	HRROI	B,[ASCIZ />
    OUR DESCRIPTOR = </]
	SOUT
	EXCH	A,0(P)			;FETCH CODE INDEX TEMPORARILY
	HRR	B,CTLDSP(A)		;MAKE STRING PTR FOR OUR DESCRIPTOR
	HRLI	B,440700
	POP	P,A			;GET BACK STRING POINTER
	SOUT
	HRROI	B,[ASCIZ />
/]
	SOUT

	MOVE	A,0(P)			;GET FILE JFN
	HRROI	B,[ASCIZ /
CJOB CONTROL DESCRIPTOR ON /]
	HRROI	C,STRBUF
	PUSHJ	P,BUGFIL		;OUTPUT ERROR ON CRASH FILE

	SETZM	FLNMSW			;ZERO FILE NAME SWITCH
	HRROI	B,JOBCTL		;POST DETAILS IN DAY FILE
	HRROI	C,[ASCIZ / CONTROL CODE MISMATCH ON /]
	PUSH	P,D
	HRROI	D,DAYTRM
	PUSHJ	P,DAY
	POP	P,D
	
        JRST	DELCTL			;GO DELETE REQUEST



;HERE WE CLEAN UP A REQUEST FILE AND CYCLE IF THERE ARE MORE

DELCTL:	SETO	A,			;DELETE THIS FILE AND GET THE NEXT
NXTCTL:	PUSHJ	P,NXTFIL
	SKIPA				;NO MORE FILES
	JRST	PRCCTL			;HAVE ANOTHER ONE - GO DO IT

	POP	P,A			;RECOVER GROUP JFN


;OK, AT THIS POINT WE HAVE ALL OF THE CURRENT COMMANDS IN THE QUEUE.  SEE IF
;THERE REALLY ARE ANY AND PROCEED TO EXECUTE THEM, STARTING WITH THE OLDEST.

	SUBI	D,COMBUF		;COMPUTE COMMAND COUNT
	LSH	D,-2
	JUMPLE	D,GETJBR		;NONE TO WORRY ABOUT.  GO LOOK AT
					;JOBS TO BE RUN

	PUSH	P,D			;GOT SOME, SAVE THE COUNT
SCNCOM:	SETOM	QPNTR			;SET UP POINTERS TO SCAN THE Q
	MOVE	A,[XWD 377777,777777]	;GREAT BIG DATE
	MOVEM	A,BESTPR
	MOVN	D,0(P)			;SET LOOP COUNTER
	MOVEI	C,COMBUF		;BUFFER ADDRESS

BSTCOM:	SKIPG	B,CTIME(C)		;STILL WAITING
	JRST	TRYNXT			;NO, LOOK SOME MORE
	CAMLE	B,BESTPR		;AGE AS GOOD OR BETTER THAN BEST?
	JRST	TRYNXT			;NO, LOOK SOME MORE
	MOVEM	B,BESTPR		;YES, SAVE THIS COMMAND TIME AND
	MOVEM	C,QPNTR			;ADDRESS

TRYNXT:	ADDI	C,4			;BUMP Q ADDRESS
	AOJN	D,BSTCOM		;SCAN THEM ALL

	SKIPG	B,QPNTR			;ARE THEY ALL EXECUTED?
	JRST	COMCLN			;YES, GO CLEAN UP

	SETZM	CTIME(B)		;NO, FLAG THIS ONE AS BEING DONE
	AOS	CTLTSK			;BUMP CONTROL TASK NUMBER
	MOVE	A,CTLTSK		;AND LABEL THIS COMMAND
	MOVEM	A,QENT+BJOBNO
	MOVE	A,COPER(B)		;IDENTIFY THE ORIGINATOR
	MOVEM	A,QENT+USRDIR
	MOVE	A,CCODE(B)		;PUT COMMAND INDEX IN A
	MOVE	B,CPARAM(B)		;AND THE PARAMETER IN B

	JRST	@CTLDSP+1(A)		;DISPATCH TO EXECUTE THE COMMAND

;HERE WE HAVE DONE ALL THE COMMANDS.  UNMAP THE QUEUE PAGE(S) AND GO LOOK
;FOR JOBS TO RUN
COMCLN:	SETO	A,			;SET TO REMOVE PAGES
	HRRI	B,COMBUF/1000		;FIRST PAGE
	HRLI	B,400000		;OUR FORK
	SETZ	C,			;ZERO ACCESS
	POP	P,D			;RESTORE STACK AND GET ENTRY COUNT
	IMULI	D,4			;NUMBER OF WORDS
	ADDI	D,777			;ROUND UPWARD
	IDIVI	D,1000			;NUMBER PAGES
COMUMP:	PMAP				;RELEASE PAGE 1 OF BUFFER
	AOS	B
	SOJG	D,COMUMP		;DO THEM ALL

	JRST	GETJBR			;GO GET ANY JOBS TO RUN



;FOLLOWING ARE THE ROUTINES TO IMPLEMENT THE CONTROL FUNCTIONS:
; .BSTAT	PRINTS BATCON AND LOWER FORK STATUS ON PRIM TTY
; .BDUMP	OUTPUTS BATCON AND LOWER FORK STATUS TO CRASH FILE,
;		TEMPORARILY FREEZES LOWER FORKS, PRINTS AC CONTENTS TO
;		CRASH FILE, AND CREATES A DUMP FILE FOR EACH FORK XX
;		<BATCH>BATCON-DUMP.XX-MO/DAY/YR-HRMIN.  INFERIORS ARE
;		THEN RESUMED.
; .BHALT	FREEZES INFERIOR FORKS AND SETS JOBHLT SO NO MORE JOBS
;		ARE RUN
; .BRESM	RESUMES INFERIOR FORKS AND RESETS JOBHLT IF HALTED
; .BRSTR	KILLS INFERIORS, AND RESTARTS CURRENT BATCON IMAGE
; .BRLOD	KILLS INFERIORS, LOADS A NEW BATCON, AND RESTARTS
; .ENTFG	SETS ENTRY CONTROL FLAG
;		= -1  => RUN ANY JOB WHICH IS VALID
;		=  0  => DON'T RUN ANY JOB
;		>  0  => RUN ONLY JOBS WITH USRDIR = ENTFLG
; .AFTER	INVALID CODE - IGNORE FILE
; .EXIT		INVALID CODE - IGNORE FILE
; .LIST		INVALID CODE - IGNORE FILE
; .CLEAR	INVALID CODE - IGNORE FILE
; .GOTO(ADR)	DOES A PUSHJ TO ADR, THEN CONTINUES
; .FREEZ(JOB #) FREEZE FORK RUNNING JOB(PARAM) IF RUNNING MELTED
; .MELT(JOB #)	MELT FORK RUNNING JOB(PARAM) IF RUNNING FROZEN
; .DEFER(JOB #)	IF RUNNING, KILL JOB(PARAM) AND SET QUEUE (JOBSTT) SO IT
;		WILL NOT BE RESTARTED INDEFINITELY
; .RESET(JOB #)	IF RUNNING, KILL JOB(PARAM) AND RESET QUEUE DATA SO NORMAL
;		SCHEDULING OF THE JOB RESUMES
; .START(JOB #)	IF JOB(PARAM) IS RUNNING, IGNORE REQUEST.  OTHERWISE START
;		THE JOB ON THE NEXT BATCON CYCLE(S) IRRESPECTIVE OF SCHED
;		PROTOCOL
; .PURGE(JOB #)	IF RUNNING, KILL JOB(PARAM) AND REMOVE IT FROM QUEUE


;OUTPUT BATCON STATUS
.BSTAT:	MOVEI	A,101			;PRIMARY OUTPUT
	SETZ	B,			;DON'T BOTHER THE FORKS
	PUSHJ	P,INFSTO		;OUTPUT STATUS

	SOS	CTLTSK			;RESTORE CONTROL TASK COUNTER

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK

;DUMP SNAP SHOT OF BATCON AND LOWER FORKS
.BDUMP:	NOINT				;DISABLE INTERRUPTS WHILE WE
					;MESS WITH CURRENT FORKS

	MOVEM	P,CSHACS+P		;SAVE OUR AC CONTENTS AT ENTRY
	MOVEI	P,CSHACS
	BLT	P,CSHACS+16
	MOVEI	P,.BDUMP		;SAVE CURRENT PC
	MOVEM	P,CSHPC			;SAVE IT
	MOVE	P,CSHACS+P		;RESTORE STACK

	GTAD				;GET DATE/TIME STAMP
	PUSH	P,A			;SAVE IT
	HRROI	A,CRASH			;OUTPUT STATUS TO CRASH FILE
	SETO	B,			;FREEZE THE LOWER FORKS
	PUSHJ	P,INFSTO

	MOVE	B,0(P)			;RECOVER DATE/TIME STAMP
	MOVEI	C,400000		;OUR HANDLE
	PUSHJ	P,FRKDMP		;NOW DUMP OUR IMAGE

	MOVE	E,[IOWD MAXFK,2]	;DO THE SAME FOR OTHERS
DMPLOP:	SETO	B,			;IS THIS FORK HERE?
	CAMN	B,FKSTAT(E)
	JRST	NOFRK			;NO, THEN GO ON
	HRROI	A,CRASH			;OUTPUT FILE NAME
	MOVE	B,0(P)			;GET DATE/TIME STAMP
	MOVEI	C,400000(E)		;FORK HANDLE
	PUSHJ	P,FRKDMP		;DUMP IT

NOFRK:	AOBJN	E,DMPLOP		;LOOK AT ALL FORKS

	POP	P,A			;CLEAR DATE/TIME STAMP

	MOVE	C,[IOWD MAXFK,2]	;NOW, SCAN ALL FORKS AND THAW
	MOVSI	B,(FFREEZ)		;IF NECESSARY
.BDMP0:	SETO	A,			;IS THIS FORK ACTIVE?
	CAMN	A,FKSTAT(C)
	JRST	.BDMP1			;NO - LOOK AT THE NEXT ONE
	HRRZ	A,FKSTAT(C)		;YES, GET JOB NUMBER
	TDNE	B,JBSTAT(A)		;SHOULD IT STAY FROZEN?
	JRST	.BDMP1			;YES
	MOVEI	A,400000(C)		;NO - RESUME IT
	RFORK
.BDMP1:	AOBJN	C,.BDMP0		;SCAN THEM ALL

.BDMP2:	OKINT				;REENABLE INTERRUPTS
	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;ENTER IN DAY FILE
	HRROI	C,[ASCIZ / SNAPSHOT DUMP ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;HALT BATCON - FREEZE ALL INFERIORS
.BHALT:	SETOM	JOBHLT			;SET HALTED FLAG

	NOINT				;DISABLE INTERRUPTS
	MOVE	C,[IOWD MAXFK,2]	;SHOW EXISTING FORKS AS FROZEN
	MOVSI	B,(FFREEZ)
.BHAL0:	SETO	A,			;DOES THIS FORK EXIST
	CAMN	A,FKSTAT(C)
	JRST	.BHAL1			;NO - CHECK NEXT ONE
	MOVEI	A,400000(C)		;YES, GET FORK HANDLE
	FFORK				;AND MAKE SURE IT IS FROZEN
	HRRZ	A,FKSTAT(C)		;GET JOB NUMBER
	IORM	B,JBSTAT(A)		;SET FROZEN BIT
.BHAL1:	AOBJN	C,.BHAL0

	OKINT				;REENABLE INTERRUPTS
	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;ENTER IN DAY FILE
	HRROI	C,[ASCIZ / BATCON HALTED ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;RESUME BATCON IF HALTED
.BRESM:	SETZM	JOBHLT			;REMOVE FLAG

	NOINT
	MOVE	C,[IOWD MAXFK,2]	;SHOW EXISTING FORKS AS MELTED
	MOVSI	B,(FFREEZ)
.BRES0:	SETO	A,			;DOES THIS FORK EXIST
	CAMN	A,FKSTAT(C)
	JRST	.BRES1			;NO - CHECK NEXT ONE
	MOVEI	A,400000(C)		;YES, GET THE FORK HANDLE
	RFORK				;AND MAKE SURE IT IS MELTED
	HRRZ	A,FKSTAT(C)		;GET JOB NUMBER
	ANDCAM	B,JBSTAT(A)		;TURN OFF FROZEN BIT
.BRES1:	AOBJN	C,.BRES0

	OKINT
	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;DAY FILE ENTRY
	HRROI	C,[ASCIZ / BATCON RESUMED ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;RESTART CURRENT CORE IMAGE
.BRSTR:	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;MAKE DAY FILE ENTRY BEFORE WE GO
	HRROI	C,[ASCIZ / BATCON RESTART ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	SETZM	DBUGSW			;SET TO RESTART
	SETZM	BRSTCT			;ZERO RESTART COUNT
	SETZM	RSTORG			;SET RESTART ORIGIN AS COMMAND
	JRST	BATRST			;PULL THE CHAIN


;RELOAD A NEW CORE IMAGE
.BRLOD:	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;MAKE DAY FILE ENTRY BEFORE WE GO
	HRROI	C,[ASCIZ / BATCON RELOAD ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	MOVEI	A,DBUGFG		;GET DBUG FLAG (FROM PARAMS)
	MOVEM	A,DBUGSW		;SET TO RELOAD
	SETZM	BRSTCT			;ZERO RESTART COUNT
	SETZM	RSTORG			;SET RELOAD ORIGIN AS COMMAND
	JRST	BATRST			;GO PULL THE CHAIN


;SET ENTFLG TO CONTROL JOB LOADING:
;	-1  => RUN ANYONE QUALIFYING
;	 0  => DON'T RUN ANYONE
;	>0  => RUN JOBS WITH DIRECTORY NUMBER - ENTFLG

.ENTFG:	SKIPGE	B			;IS PARAMETER POS DEF
	SETO	B,			;NO - SET TO -1
	MOVEM	B,ENTFLG		;SET NEW VALUE

	HRROI	A,BUGSTR		;MAKE DAYFILE ENTRY
	HRROI	B,[ASCIZ / ENTRY FLAG(8) = /]
	SETZ	C,
	SOUT
	MOVE	B,ENTFLG		;TACK ON VALUE
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL
	HRROI	C,BUGSTR
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;HANDLE GOTO COMMAND <ADR> IS IN STRTED

.GOTO:	PUSH	P,B			;SAVE THE GOTO ADDRESS
	HRROI	A,STRBUF		;COMPOSE MESSAGE
	HRROI	B,[ASCIZ / GOTO (/]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;ADD ADDRESS
	MOVEI	C,10			;OCTAL
	NOUT
	JRST	[MOVEI	B,"*"
		 BOUT
		 BOUT
		 BOUT
		 JRST	.+1]
	HRROI	B,[ASCIZ /) COMMAND ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE BEFORE
	HRROI	C,STRBUF		;WE DO SOMETHING DUMB
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	POP	P,B			;GET ADDRESS BACK
	PUSHJ	P,0(B)			;GO TO IT

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK


;FREEZE THE JOB SPECIFIED IN PARAM
.FREEZ:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JFCL				;NOT IN Q
	JFCL				;FORK HASN'T BEEN STARTED
	JRST	.FREZ2			;FORK HALTED - IGNORE REQUEST
	JFCL				;FORK SEEMS TO BE FROZEN - MAKE SURE

	PUSH	P,A			;FORK RUNNING - SAVE JOB NUMBER
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	FFORK				;AND FREEZE THE FORK
	MOVE	A,0(P)			;SET FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	IORM	B,JBSTAT(A)

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	POP	P,B			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / FROZEN ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

.FREZ2:	OKINT
	JRST	SCNCOM			;NEXT COMMAND



;MELT JOB SPECIFIED IN PARAM
.MELT:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JFCL				;NOT IN Q
	JFCL				;FORK HASN'T BEEN STARTED
	JRST	.MELT2			;FORK ALREADY HALTED
	JFCL				;FORK FROZEN - GO THAW IT
	JFCL				;FORK ALREADY MELTED - MAKE SURE

	PUSH	P,A			;SAVE JOB NUMBER
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND MELT THE FORK
	MOVE	A,0(P)			;REMOVE FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	POP	P,B			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / MELTED ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

.MELT2:	OKINT
	JRST	SCNCOM			;NEXT COMMAND



;DEFER THE EXECUTION OF THE JOB IN PARAM - STOP IT IF RUNNING NOW
.DEFER:	NOINT				;NO INTERRUPTS
	PUSH	P,B			;SAVE JOB #
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.DEFR3			;NOT IN Q - IGNORE REQUEST
	JRST	.DEFR2			;FORK HASN'T BEEN STARTED - SET BIT
	JRST	.DEFR3			;FORK ALREADY HALTED - IGNORE REQUEST
	JRST	.DEFR0			;FORK FROZEN - GO THAW IT AND KILL IT
	JRST	.DEFR1			;FORK ALREADY MELTED - GO KILL IT

.DEFR0: HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND MELT THE FORK
	MOVE	A,0(P)			;REMOVE FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.DEFR1:	MOVSI	B,(1B3)			;INTERRUPT THROUGH CHAN 3
	PUSHJ	P,FRCHLT		;GO FOR THE FORK TO HALT

.DEFR2:	MOVE	A,0(P)			;SET DEFER BIT IN JOB STATUS
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FDEFER)		;SET FLAG TO DEFER JOB
	IORM	B,JBSTAT(A)

	SETOM	RUNQCP			;SET TO RUN Q COPY

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / EXECUTION DEFERRED ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

.DEFR3:	OKINT
	POP	P,B
	JRST	SCNCOM			;NEXT COMMAND



;RESET QUEUE STATUS OF JOB IN PARAM SO NORMAL RESCHEDULING OCCURS
.RESET:	NOINT				;NO INTERRUPTS
	PUSH	P,B			;SAVE JOB #
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.REST3			;NOT IN Q - IGNORE REQUEST
	JRST	.REST2			;FORK HASN'T BEEN STARTED - SET BIT
	JRST	.REST3			;FORK ALREADY HALTED - IGNORE REQUEST
	JRST	.REST0			;FORK FROZEN - GO THAW IT AND KILL IT
	JRST	.REST1			;FORK ALREADY MELTED - GO KILL IT

.REST0: HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND MELT THE FORK
	MOVE	A,0(P)			;REMOVE FROZEN BIT IN JOB STATUS
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.REST1:	MOVSI	B,(1B3)			;INTERRUPT ON CHAN 3
	PUSHJ	P,FRCHLT		;GO FOR THE FORK TO HALT

.REST2:	MOVE	A,0(P)			;SET RESET BIT IN JOB STATUS
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FRESET)		;SET FLAG TO RESET JOB
	IORM	B,JBSTAT(A)

	SETOM	RUNQCP			;SET TO RUN Q COPY

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / STATUS RESET ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

.REST3:	OKINT
	POP	P,B
	JRST	SCNCOM			;NEXT COMMAND



;FORCE START THE JOB SPECIFIED BY PARAM
.START:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.STRT4			;NOT IN Q - IGNORE REQUEST
	JRST	.STRT1			;FORK HASN'T BEEN STARTED - FLAG IT
	JRST	.STRT4			;FORK ALREADY HALTED - IGNORE REQUEST
	JRST	.STRT2			;FORK FROZEN - GO THAW IT
	JRST	.STRT4			;FORK ALREADY MELTED - IGNORE REQUEST

.STRT1:	PUSH	P,A			;FORK RUNNING - SAVE JOB NUMBER
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FFSTRT)		;SET FORCE START BIT
	IORM	B,JBSTAT(A)
	AOS	FORCST			;BUMP FORCE START COUNT
	JRST	.STRT3			;GO POST MESSAGE

.STRT2:	PUSH	P,A			;FORK FROZEN - SAVE JOB NUMBER
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND RESUME IT
	MOVE	A,0(P)			;RECOVER JOB NUMBER
	MOVSI	B,(FFREEZ)		;AND REMOVE FROZEN FLAG
	ANDCAM	B,JBSTAT(A)

.STRT3:	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	POP	P,B			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / FORCE START SET ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

.STRT4:	OKINT
	JRST	SCNCOM			;NEXT COMMAND



;PURGE THE JOB SPECIFIED BY PARAM - KILL IT IF RUNNING
.PURGE:	NOINT				;NO INTERRUPTS
	MOVE	A,B
	PUSH	P,B			;SAVE JOB #
	PUSHJ	P,JOBSIT		;GET JOB SITUATION
	JRST	.PURG3			;NOT IN Q - IGNORE REQUEST
	JRST	.PURG2			;FORK HASN'T BEEN STARTED - FLAG IT
	JRST	.PURG3			;FORK ALREADY HALTED - IGNORE REQUEST
	JFCL	.PURG0			;FORK FROZEN - GO THAW IT
	JRST	.PURG1			;FORK ALREADY MELTED - GO ZAP IT

.PURG0:	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	RFORK				;AND THAW IT
	MOVE	A,0(P)			;GET JOB # AND REMOVE FROZEN BIT
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.PURG1:	MOVSI	B,(1B3)			;INTERRUPT ON CHAN 3
	PUSHJ	P,FRCHLT		;NOW GO FORCE IT TO STOP

.PURG2:	MOVE	A,0(P)			;GET JOB #
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FPURGE)		;SET PURGE BIT
	IORM	B,JBSTAT(A)
	SETOM	RUNQCP			;SET TO RUN Q COPY

	HRROI	A,STRBUF		;MESSAGE FOR DAY FILE
	HRROI	B,[ASCIZ / JOB /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RETRIEVE JOB #
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / PURGE SET ON /]
	SETZ	C,
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;POST COMMAND IN DAY FILE
	HRROI	C,STRBUF
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

.PURG3:	OKINT
	POP	P,B
	JRST	SCNCOM			;NEXT COMMAND


;COMMAND TO CLEAR OUT ANY RUNNING JOBS AND SET ENTFLG = 0 SO NO NEW ONES
;ARE STARTED
.CLEAR:	MOVSI	A,(1B3)			;INTERRUPT ON CHANNEL 3
	PUSHJ	P,CLRBAT
	OKINT				;INTERRUPTS AGAIN
	JRST	SCNCOM



;CALL TO TEST BUGNOTE ROUTINE HERE - TO BE CALLED WITH GOTO
BUGNTE:	BUG	(<*** TESTING BUG NOTE ***>,.+1)
	POPJ	P,


;CALL TO TEST FULL BUG HANDLING - TO BE CALLED WITH GOTO
BUGFUL:	BUG	(<*** TESTING FULL BUG HALT ***>)
	HALTF				;IN CASE WE COME BACK HERE, WE HAVE
					;TROUBLE
	

;ERROR CONTROL CODE HANDLING
.AFTER:	
.LIST:
.RUNIN:	
.EXIT:	HRROI	A,STRBUF
	HRROI	B,[ASCIZ / INVALID </]
	SETZ	C,
	SOUT
	HRROI	B,QENT+COMNAM		;ADD ON COMMAND STRING
	SOUT
	HRROI	B,[ASCIZ /> COMMAND ON /]
	SOUT

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;NOTE ERROR IN DAY FILE
	HRROI	C,STRBUF
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	JRST	SCNCOM			;GO LOOK FOR ANOTHER TASK



;'EXPUNGE' THE BATCH DIRECTORY

GETJBR:	MOVE	A,BATDN			;GET DIRECTORY NUMBER
	DELDF				;EXPUNGE IT


;IF ANYTHING HAS HAPPENED TO ALTER STATUS OF Q ENTRIES, GO CLEAN IT UP

	SKIPE	ACTFRK			;ANY FORKS ACTIVE?
	JRST	[MOVEI	A,400000	;YES, GO CHECK THEIR STATUS
		 MOVEI	B,1B19		;BY INTERRUPTING ON CHANNEL 19
		 IIC
		 JRST	.+1]

	SKIPE	RUNQCP
	PUSHJ	P,QUECOP


;NOW REACQUIRE JOB QUEUE AND OPEN Q FOR READ TO SCAN FOR JOBS (ALSO WRITE SO WE
;CAN RECORD THAT WE SELECTED A JOB).
GETJBQ:	MOVSI	A,(1B7!1B17)		;GET Q, NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG(<GETJBQ: GTJFN FAILURE FOR Q>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

	MOVE	B,[1,,FDBUSW]		;GET THE USER SETTABLE WORD
	MOVEI	C,MXJBNO#		;WHERE TO PUT IT
	GTFDB

	MOVE	A,QJFN			;JFN FOR THE BATCH Q
	MOVE	B,[44B5!1B19!1B20]	;36 BIT,READ,WRITE
	QOPENF
	BUG	(<GETJBQ: ERROR OPENING Q>)
	BUG	(<GETJBQ: TIME OUT OPENING Q>,NOJOBS)

;SCAN THROUGH THE QUEUE FOR A JOB TO RUN
	SETOM	BESTPR			;BEST PRIORITY IS -1 (NOT USEABLE)
	SETZM	QPNTR			;INIT POINTER FOR Q SCAN

	SKIPE	FORCST			;ANY FORCE STARTS?
	JRST	SCANQ			;YES, GO FIND THEM
	SKIPN	ENTFLG			;DON'T DO ANYTHING IF ENTFLG=0
	JRST	NOJOBS
	SKIPE	JOBHLT			;OR IF JOBHLT=-1
	JRST	NOJOBS

;CHECK TO SEE THAT Q IS NOT SCREWED UP, ALSO GET THE
;SIZE OF THE Q SO WE CAN COMPUTE NUMBER OF ENTRYS.
SCANQ:	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,[2,,11]		;2 WDS, STARTING AT WD 11
	MOVEI	C,D			;WHERE TO STORE IT
	GTFDB				;READ FROM FDB
	JUMPE	E,NOJOBS		;CHECK FOR NULL QUEUE
	LDB	B,[POINT 6,D,11]	;GET BYTE SIZE
	CAIE	B,^D36			;MUST BE 36 BIT
	BUG(<BYTE SIZE OF Q IS NOT 36>)
	MOVE	B,E			;GET # WDS
	IDIVI	B,QESIZE		;DIVIDE BY ENTRY SIZE
	CAIE	C,0			;MUST GO EVENLY
	BUG(<QUEUE DOES NOT CONTAIN EVEN NUMBER OF ENTRIES>)
	MOVEM	B,NQENT			;SAVE NUMBER OF ENTRIES

	SKIPE	FORCST
	JRST	RDQ

;FETCH THE JOBDIR TABLE TO COUNT ACTIVE JOBS FOR EACH USER
	HRRO	A,JOBDIR		;NOW SET UP FOR GTBLT OF TABLE
	HRLZ	B,NJOBTB		;GET NUMBER OF ENTRIES
	HRRI	B,JBDRTB		;TACK ON DESTINATION
	GTBLT				;FETCH ALL TABLE ENTRIES
	BUG(<SCANQ: Error on JOBDIR GTBLT>)

;NOW READ IN A QUEUE ENTRY SO WE CAN EXAMINE IT.
RDQ:	MOVE	A,QJFN			;GET JFN FOR Q
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;GET AMT TO READ
	SIN

;CHECK TO SEE IF THIS IS A REAL QUEUE ENTRY -
;IGNORE NULL ENTRIES.
	SKIPG	QENT+USRDIR		;DOES IT HAVE A DIR TO LOGIN?
	JRST	NOTTHS			;NO--CANNOT RUN HIM

	SKIPG	FORCST			;IS THIS A FORCED START
	JRST	RDQ1			;NO, GO THROUGH NORMAL PRIORITIES
	MOVE	A,QENT+BJOBNO		;YES, GET JOB #
	MOVE	B,JBSTAT(A)		;GET STATUS
	TLZN	B,(FFSTRT)		;IS THIS ONE FLAGGED?
	JRST	NOTTHS			;NO, TRY NEXT ONE

	PUSHJ	P,JOBSIT		;VERIFY JOB STATUS
	BUG	(<RDQ: FORCED START ON NON-EXISTENT JOB>)
	JRST	RDQ0			;JOB THERE BUT NOT STARTED YET
	BUG	(<RDQ: FORCED START ON JOB ALREADY RUN>)
	JFCL
	BUG	(<RDQ: FORCED START ON JOB ALREADY RUNNING>)

RDQ0:	MOVEI	A,1			;FAKE VALID PRIORITY
	MOVEM	A,BESTPR
	MOVE	A,QPNTR			;SAVE Q POINTER
	MOVEM	A,BESTPT		;SAVE IT
	SOSL	FORCST			;GOT ONE TO START - DECREMENT COUNTER
	JRST	STRTIT			;GO START IT
	BUG	(<RDQ:  FORCST COUNT OVER DECREMENTED>)

RDQ1:	MOVE	A,[XWD 377777,777777]	;IS THIS JOB DEFERRED
	CAMN	A,QENT+JOBSTT
	JRST	NOTTHS			;YES, LOOK AT THE NEXT ONE

;CHECK ENTFLG FOR THIS JOB AND IF LOAD AVERAGE IS LOW ENOUGH TO RUN IT
	MOVE	A,ENTFLG		;GET ENTRY FLAG
	CAME	A,QENT+USRDIR		;ENTFLG MUST BE = USRDIR OR -1
	JUMPGE	A,NOTTHS		;NO - DON'T CONSIDER THIS JOB

IFE	SRISYS,<
	MOVE	A,[SIXBIT /LOADTB/]	;SYSTEM LOAD TABLE
	SYSGT				;GET TABLE NUMBER
	MOVE	A,B			;SET UP TABLE NUMBER
	HRLI	A,3			;OFFSET TO LOAD AVERAGE
>
IFN	SRISYS,<
	MOVE	A,SYSTAT		;FIND THE MAXIMUM OF THE 1, 5,
	HRLI	A,14			;ENTRY 14 IS 1 MIN LOAD AV
	GETAB
	BUG	(<RDQ1: Error fetching 1 min LA>)
	MOVE	C,A
	MOVE	A,SYSTAT
	HRLI	A,15			;5 MIN LOAD AV
	GETAB
	BUG	(<RDQ: Error fetching 5 min LA>)
	CAMLE	A,C			;IF THIS ONE BIGGER, SAVE IT
	MOVE	C,A
	MOVE	A,SYSTAT
	HRLI	A,16			;15 MIN LOAD AV
	GETAB
	BUG	(<RDQ: Error fetching 15 min LA>)
	CAMG	A,C			;NOW PUT MAX VALUE IN A
	MOVE	A,C
>
	CAML	A,QENT+LOADAV		;COMPARE WITH REQUEST
	JRST	NOTTHS			;SYSTEM TOO BUSY

;CHECK TO SEE IF IT HAS ALREADY BEEN STARTED.
;BY ANOTHER BATCON, OR IF IT IS ONE WE DIED ON.
	HRRZ	A,QENT+STRTED		;GET WHO STARTED IT
	JUMPE	A,RDQ3			;DID ANYBODY-JUMP IF NOT
	CAME	A,JOBNO			;WAS IT US?
	JRST	NOTTHS			;NO-CAN'T CONSIDER IT
	MOVE	A,QENT+JOBSTT		;TIME BATCH JOB STARTED
	CAML	A,BATSTT		;TIME BATCH PROCESSOR STARTED
	JRST	NOTTHS			;HE IS PROBABLY ALREADY RUNNING
	SETZM	QENT+STRTED		;YES, CLEAR START WORD
	MOVE	A,QJFN			;GET SET TO WRITE IT BACK OUT
	MOVE	B,QPNTR			;WHERE IT GOES
	SFPTR				;RESET POINTER IN FILE
	BUG	(<RDQ1: Failed to reset Q file pointer>)
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;AMOUNT TO WRITE
	SOUT				;WRITE IT BACK

;SEE IF RESTART COUNT EXCEEDED. IF SO, MARK ENTRY FOR DELETION.
RDQ3:	MOVNI	A,MAXRST		;GET MAXIMUM RESTARTS
	CAMGE	A,QENT+RESTRT		;LIMIT EXCEEDED
	JRST	RDQ4			;NO

	MOVE	A,QENT+BJOBNO		;YES, TOO MANY RESTARTS, GET JOB NUMBER
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FDEFER)		;SET DEFER BIT
	IORM	B,JBSTAT(A)
	SETOM	RUNQCP			;SET TO RUN Q COPY

	MOVEI	B,JDEFER		;TERMINATION MSG = DEFER
	HRROI	C,[ASCIZ /.
    TOO MANY RESTARTS - CONTACT SYSTEM STAFF/]
	PUSHJ	P,WINFRM		;GO TELL THE BAD NEWS
	
RDQCOV:	JRST	NOTTHS			;IGNORE ENTRY


;NOW EVALUATE IT'S PRIORITY TO SEE IF WE WANT TO RUN IT
RDQ4:	PUSHJ	P,EVPRIO		;GO COMPUTE PRIORITY
	CAMG	A,BESTPR		;IS THIS ONE BETTER?
	JRST	NOTTHS			;NO

;GOT A BETTER ONE, SO COPY INFO TO ACTIVE ENTRY
	MOVEM	A,BESTPR		;IS NOW THE BEST PRIORITY
	MOVE	A,QPNTR			;GET WHERE WE ARE IN Q
	MOVEM	A,BESTPT		;SAVE IT

;NOW GO ON TO NEXT ONE (IF IT EXISTS) AND LOOP THROUGH Q
NOTTHS:	MOVEI	A,QESIZE		;GET ENTRY SIZE
	ADDM	A,QPNTR			;UPDATE POINTER

	SOSLE	NQENT			;COUNT ENTRY,
	JRST	RDQ			;READ NEXT IF MORE

;HERE WE HAVE RUN OUT OF QUEUE - THERE HAD BETTER NOT BEEN ANY FORCED
;STARTS REQUESTED

	SKIPE	FORCST
	BUG	(<NOTTHS: NO JOB FOUND WITH FORCED START SET>)


;DETERMINE IF THERE WAS AN ENTRY WORTH USING.
;GO IDLE IF NOT.  READ IT IN IF SO.
STRTIT:	SKIPG	BESTPR			;ONE WORTH DOING?
	JRST	NOJOBS			;NO

	MOVE	A,ACTFRK		;GET NUMBER OF ACTIVE FORKS
	CAIL	A,MAXFK			;COMPARE WITH MAXIMUM ALLOWABLE INFERIORS
	JRST	NOJOBS			;ALL FORKS BUSY

	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,BESTPT		;WHERE TO POINT TO
	SFPTR				;POINT TO ENTRY
	BUG	(<NOTTHS: Failed to set Q file pointer>)

	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY BUFFER
	MOVNI	C,QESIZE		;GET ENTRY SIZE
	SIN				;GET ENTRY

;GET INFORMATION ABOUT THE USER WE ARE STARTING.
	MOVE	A,QENT+USRDIR		;GET HIS DIR NUMBER
	MOVEI	B,USRBLK		;POINT TO PLACE FOR DIR INFO
	SETZ	C,			;WE DON'T WANT HIS PASSWORD
	GTDIR				;FIND OUT ABOUT HIM

;GET THE LOG FILE
	SETZM	LOGJFN			;NULL LOG FILE JFN
	MOVSI	A,(1B17)	; SHORT
	HRROI	B,QENT+LOGFIL		;GET PTR TO NAME
	GTJFN
	JRST CKLOGF+1			;CAN'T GET LOG, FLUSH JOB

;CHECK ACCESS TO LOG FILE
	PUSH	P,A			;SAVE JFN FOR LOG FILE
	MOVEM	A,LOGJFN

;FIRST CHECK IF ON DSK: OR LPT:, IF NOT BOMBOUT.
	DVCHR				;GET DEVICE CHARACTERISTICS
	HLRZ	A,A			;GET DEVICE DESIGNATOR
	CAIN	A,DEVDSK		;IS DEVICE DSK?
	JRST	CKLOG0			;YES
	CAIN	A,DEVNIL		;IS DEVICE NIL:?
	JRST	CKLOGS			;YES-ALLOW IT
	CAIE	A,DEVLPT		;IS IT LPT?
	JRST	CKLOGF			;NO - FAIL

;NOW WE KNOW IT IS LPT:, MAKE A REAL FILE NAME FOR IT
	POP	P,A			;FIRST RELEASE THE OLD JFN
	CAIGE	A,2		;LEGAL JFN ?
	JRST	.+3		;NO -- DON'T RELEASE IT
	RLJFN				;RELEASE IT NOW
	BUG	(<RLJFN failed in release of LPT:>)
	HRROI	A,FDBBLK		;WHERE TO PUT USER NAME
	MOVE	B,QENT+USRDIR		;HIS DIR NUMBER
	DIRST				;MAKE A STRING OF IT
	BUG	(<DIRST failed in LPT file creater>)
	TIME				;GET TIME AS FILE EXTENSION RANDOMIZER
	TRZ	A,400000		;VERSION NUMBERS MUST BE .LE. 400000
	HRRM	A,LOGBLK		;STORE IN LOG JFN BLOCK
	MOVEI	A,LOGBLK		;LOG JFN BLOCK
	SETZ	B,			;NO MAIN STRING POINTER
	GTJFN				;GET A JFN
	BUG	(<Can't GTJFN file in <PRINTER>.>)
	PUSH	P,A			;SAVE THE JFN
	MOVEM	A,LOGJFN

;	INSURE UNIQUE TIME GENERATED VERSION BY DELAAYING 2 SECOND
	MOVEI	A,^D2000
	DISMS
	JRST	CKLOGS			;AND ALLOW ACCESS

;IT IS KNOWN TO BE ON DSK: IF WE GET HERE.
CKLOG0:	MOVE	A,(P)			;GET JFN BACK
	MOVSI	B,(1B1)			;WE WILL NEED WRITE ACCESS.
	PUSHJ	P,CHKACC		;CAN HE USE IT?
	JRST	CKLOGF			;NO-CLEAN UP
	MOVE	B,DIRNMF		;GET DIR # FILE IS IN (SAVED
					;BY CHKACC).
	CAILE	B,1			;SYSTEM DIRECTORY??  ***SRI-AIC***
	CAMN	B,BATDN			;IS IT <BATCH>?
	JRST	CKLOGF			;NOT A LEGAL DIRECTORY

	MOVE	A,0(P)			;NOW OPEN AND CLOSE THE LOG FILE
	MOVE	B,[7B5+1B20]		;SO IT WILL BE REAL
	QOPENF
	JFCL				;OPEN ERROR
	JRST	CKLOGF			;TIME-OUT ERROR
	CLOSF
	JRST	CKLOGF
	MOVSI	A,(1B17)		;NOW GET A NEW JFN FOR IT
	HRROI	B,QENT+LOGFIL
	GTJFN
	JRST	CKLOGF
	MOVEM	A,0(P)			;RECORD THE NEW JFN
	
	JRST	CKLOGS			;ALL SEEMS LEGAL

CKLOGF:	POP	P,A			;ILLEGAL ACCESS ATTEMPT IF HERE
	HRROI	A,BUGSTR		;SET UP MESSAGE
	HRROI	B,[ASCIZ /.
    NO WRITE ACCESS TO LOG FILE: /]
	SETZ	C,
	SOUT
	HRROI	B,QENT+LOGFIL
	SOUT

	MOVEI	B,JABORT		;INDEX FOR ABORT TERMINATION MSG
	HRROI	C,BUGSTR		;ADD APPENDIX
	PUSHJ	P,WINFRM		;GO TELL THE WORLD

	MOVE	A,LOGJFN
	RLJFN				;RELEASE THE JFN USED
	JFCL
CKLGF1:	MOVE	A,QENT+BJOBNO		;GET JOB NUMBER
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FPURGE)		;MARK IT FOR PURGING
	IORM	B,JBSTAT(A)
	SETOM	RUNQCP
	SETZM	CTLJFN

	JRST NOJOBS			;FORGET ABOUT THIS JOB

CKLOGS:	POP	P,A			;RESTORE JFN-LEGAL ACCESS

;OPEN THE LOG FILE.
	MOVE	B,[7B5!1B20]		;7BIT,WRITE
	QOPENF
	JRST	CKLOGF+1		;GO ABORT - OPEN ERROR
	JRST	CKLOGF+1		;GO ABORT - OPEN TIME OUT
	MOVEM	A,LOGJFN		;SAVE LOGJFN

;GET THE CTL FILE
	SETZM	CTLJFN			;NULL CONTROL FILE JFN
	MOVSI	A,(1B2!1B17)		;OLD FILE, SHORT
	HRROI	B,QENT+CTLFIL		;GET CTL FILE NAME
	GTJFN
	JRST   CKCTLF

;CHECK ACCESS TO CTL FILE
	MOVEM	A,CTLJFN		;SAVE THE JFN
	MOVSI	B,(1B0)			;READ ACCESS
	PUSHJ	P,CHKACC		;CHECK ACCESS
	JRST	CKCTLF			;FAILURE
	JRST	CKCTLS			;SUCCESS

CKCTLF:	ERROR	(<ERROR TRYING TO GET READ ACCESS TO CTL FILE>)
	SKIPE	CTLJFN			;DID WE GET THE JFN?
	JRST	CKCTF1			;YES, THEN GO ON

	MOVE	A,LOGJFN		;NO, WRITE TENEX REASON WHY
	HRLOI	B,400000		;ON LOG FILE WITH
	SETZ	C,			;THE ERSTR JSYS
	ERSTR
	BUG	(<ERSTR +1 in CKCTLF>)
	BUG	(<ERSTR +2 in CKCTLF>)
	PUSHJ	P,SCRLF			;SEND A CRLF TO LOG FILE
	JRST	CLLOG

CKCTF1:	MOVE	A,CTLJFN		;RESTORE JFN
	RLJFN				;RELEASE IT
	BUG	(<RLJFN failure in CKCTLF>)
	SETZM	CTLJFN

CLLOG:	HRRZ	A,LOGJFN
	CLOSF				;CLOSE LOG FILE
	JFCL
	SETZM	LOGJFN

	HRROI	A,BUGSTR		;SET UP MESSAGE FOR BAD NEWS
	HRROI	B,[ASCIZ /.
    NO READ ACCESS TO CTL FILE: /]
	SETZ	C,
	SOUT
	HRROI	B,QENT+CTLFIL
	SOUT

	MOVEI	B,JABORT		;INDEX FOR ABORT TERMINATION MSG
	HRROI	C,BUGSTR		;ADD <appendix>
	PUSHJ	P,WINFRM		;GO SPREAD THE WORD

	MOVE	A,QENT+BJOBNO		;GET JOB NUMBER
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FPURGE)		;MARK IT FOR PURGING
	IORM	B,JBSTAT(A)
	SETOM	RUNQCP

	JRST NOJOBS			;FORGET ABOUT THIS JOB

;EVERYTHING CHECKS OUT HERE, MARK ENTRY AS STARTED
CKCTLS:	MOVE	A,QJFN			;LOOK AT THE Q NOW
	MOVE	B,QENT+RESTRT		;GET RESTART COUNT
	SUBI	B,1			;BACK IT UP BY 1
	MOVE	C,BESTPT		;GET POINTER TO THIS ENTRY
	ADDI	C,RESTRT		;DISP TO RESTRT COUNTER
	ROUT

	GTAD				;GET TIME
	MOVE	B,A
	MOVE	A,QJFN			;QUEUE JFN
	MOVE	C,BESTPT		;GET POINTER TO THIS ENTRY
	ADDI	C,JOBSTT		;DISP TO JOB START TIME
	ROUT				;PUT IN FILE
	PUSH	P,A			;SAVE QUEUE JFN
;NOW GET A FORK AND START IT UP
; WE DISABLE THE INTERRUPT SYSTEM TO PREVENT THE INTERRUPT SIDE
; FROM KILLING A FORK BEFORE WE HAVE A CHANCE TO MARK IT NOT STARTED

GINFK:	NOINT				;DISABLE INTERRUPTS
	HRLZI	A,200000		;SAME CAPABILITIES ONLY
	CFORK
	JRST [	OKINT			;REENABLE INTERRUPTS
		MOVEI	A,^D1000
		DISMS			;AND GO AWAY FOR A WHILE
		JRST GINFK]		;TRY AGAIN
	AOS	ACTFRK			;INCREMENT NUMBER OF ACTIVE FORKS
	MOVEM	A,RELFRK		;SAVE RELATIVE FORK HANDLE
	ANDI	A,777			;KEEP ONLY RELATIVE FORK INDEX
	HRRZI	B,-1			;SET FORK STARTING FLAG
	MOVEM	B,FKSTAT(A)
	HRL	B,CTLJFN		;SET CTLJFN
	HRR	B,LOGJFN		;AND LOGJFN
	MOVEM	B,FRKJFN(A)		;IN FORK JFN TABLE
	MOVE	A,QENT+BJOBNO
	MOVSI	B,(FEXIST+FHLTED+FINQUE)	;SET JOB STATUS
	HRR	B,RELFRK		;TACK ON FORK HANDLE
	HRLZ	C,QENT+USRDIR		;PATCH IN USER DIRECTORY NUMBER
	ADD	B,C
	MOVEM	B,JBSTAT(A)

	OKINT				;SPRING THE INTERRUPT SYS

;COPY DATA FROM QUEUE ENTRY.
	MOVE	A,QENT+ETIME		;GET MAX ELAPSED TIME
	MOVEM	A,MAXETM		;SAVE IT

	MOVE	A,QENT+RTIME		;GET MAX CPU TIME
	MOVEM	A,MAXCPU		;SAVE IT

	MOVE	A,QENT+LOGLNS		;GET LIMIT OF LINES TO WRITE ON LOG
	MOVEM	A,MAXLOG		;SAVE IT


;START MAPPING THE LOWER FORKS ADDRESS SPACE
;FIRST THE PAGES COMMON TO ALL LOWER FORKS
	MOVE	A,[XWD 400000,INFFK/1000]  ;SUPERIOR FORK PAGE
	HRRZ	B,A			;PAGE NUMBER OF INFERIOR
	HRL	B,RELFRK		;INFERIOR FORK HANDLE
	HRLZI	C,160000		;READ,EXECUTE, WRITE
	MOVEI	D,NINF			;NUMBER OF INFERIOR COMMON PAGES
MPLP:	PMAP
	AOJ	A,			;INCREMENT SOURCE PAGE
	AOJ	B,			;INCREMENT DESTINATION PAGE
	SOJG	D,MPLP

;THEN THE PAGES SHARED BETWEEN THE INFERIORS AND THE SUPERIOR
	MOVE	A,[XWD 400000,SHARE/1000]   ;SHARED PAGES
	HRRZ	B,A
	HRL	B,RELFRK
	HRLZI	C,160000		;READ,WRITE AND EXECUTE
	MOVEI	D,NSHAR			;NUMBER OF INFERIOR SHARED PAGES
MPLPS:	PMAP				;MAP PAGE TO INFERIOR
	AOJ	A,
	AOJ	B,
	SOJG	D,MPLPS

;FINALLY THE INFERIOR PRIVATE PAGES.  ONLY REALLY BELONG TO INFERIOR
;AFTER INFERIOR HAS TOUCHED THEM.
	MOVE	A,[XWD 400000,PRIV/1000]  ;SOURCE HANDLE FOR PMAP
	HRRZ	B,A
	HRL	B,RELFRK		;DESTINATION HANDLE FOR PMAP
	HRLZI	C,120400		;READ,COPY WRITE,EXECUTE ACCESS
	MOVEI	D,NPRIV			;NUMBER OF PRIVATE INFERIOR PAGES
MAPP:	PMAP				;MAP TO INFERIOR
	AOJ	A,
	AOJ	B,
	SOJG	D,MAPP

;MAP SYMBOL TABLE PAGES TO INFERIOR. MAP SAME AS PRIV TO KEEP OVERLAPPED
;PAGES FROM CHANGING PROTECTION.
	SKIPN	A,SYMPTR		;GET SYMBOL TABLE POINTER
	JRST INFSRT			;GO START THE INFERIOR IF NO TABLE
	ASH	A,-^D9			;MAKE WORDS INTO PAGES
	HLLZ	D,A			;PACK AWAY THE COUNT AS AN AOBJN PTR
	SUB	D,[1,,0]		;TO GET THE LAST PAGE
	TRZ	A,777000		;GET RID OF THE SHIFTED LH BITS
	HRLI	A,400000		;SUPERIOR IS SOURCE
	HRRZ	B,A
	HRL	B,RELFRK		;DESTINATION HANDLE FOR PMAP
MAPSYM:	PMAP				;MAP TO INFERIOR
	AOJ	A,
	AOJ	B,
	AOBJN	D,MAPSYM


; START IT UP AND WAIT FOR IT. TURN ON THE INTERRUPT SYSTEM
; WHEN WE KNOW IT IS OFF AND RUNNING

INFSRT:	NOINT				;FIRST TURN OFF THE INTERRUPTS
	MOVE	A,RELFRK		;RELATIVE FORK HANDLE
	MOVEI	B,INFFK			;STARTING ADDRESS
	SFORK				;START INFERIOR

;	MAKE SURE INFERIOR HAS STARTED BEFORE ATTEMPTING TO START ANOTHER
;	TO AVOID POSSIBLE RACE CONDITION AS FAR AS VARIOUS INFERIOR FORKS
;	TOUCHING THEIR RESPECTIVE DATA AREAS.
WATST:	MOVEI	A,^D5000		;WAIT 5 SECONDS FOR THINGS TO START
	DISMS
	MOVEI	A,PRIV			;CHECK THE STATUS OF THE PRIVATE PAGE
	LSH	A,-^D9
	HRL	A,RELFRK		;TACK ON FORK HANDLE OF INFERIOR
	RPACS				;GET PAGE STATUS
	TLNE	B,004000		;IS THE PAGE SHARED (INDIR PTR)
	JRST	WATST			;YES, WAIT A BIT MORE

;CLEAN UP THE Q BEFORE GOING FOR ANOTHER

WATCMP:	POP	P,A			;GET BACK QUEUE JFN
	MOVE	B,JOBNO			;GET OUR ID
	HRL	B,RELFRK		;ADD FORK HANDLE FOR RUNNING FORK
	MOVE	C,BESTPT		;ORIGIN OF BLOCK ON DISK
	ADDI	C,STRTED		;+DISPLACEMENT INTO IT
	ROUT				;PUT WORD IN BLOCK

	MOVE	A,QENT+BJOBNO		;FINISH SETTING JOB STATUS AS RUNNING
	MOVSI	B,(FHLTED)
	ANDCAM	B,JBSTAT(A)

	MOVE	B,RELFRK		;SET JOB RUNNING IN FORK STATUS
	ANDI	B,777			;FORK INDEX
	HRRM	A,FKSTAT(B)
	OKINT				;REENABLE INTERRUPTS

;SET POINTER TO EOF, THEN CLOSE FILE
WATNXT:	MOVE	A,QJFN
	SETO	B,			;-1 IMPLIES EOF
	SFPTR				;SET POINTER
	BUG	(<INFSRT: ERROR SETTING Q FILE POINTER FOR EOF>)

	CLOSF				;DONE WITH Q FILE
	BUG	(<INFSRT: CLOSF ON Q FILE FAILED>)
	SETZM	QJFN			;DONE WITH JFN
	SETZM	RELFRK			;ZERO OUT FORK HANDLE

	SKIPE	FORCST			;ANY MORE FORCED STARTS
	JRST	GETJBQ			;YES - GO FIND THEM

	MOVEI	A,^D60000		;WAIT FOR 1 MIN TO LET THE NEW
	DISMS				;JOB SETTLE IN AND THE LA STABILIZE
	JRST GETJOB			;GO START THE NEXT GUY

;PSI SERVICE FOR INFERIOR FORK HALTED

HLTNFK:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E

	SETZM	ONFRK#			;ZERO WORKING FORK COUNT
	MOVE	C,[-MAXFK,,1]		;SCAN ALL INFERIOR FORKS
INFLP:	MOVEI	A,400000(C)		;FORK HANDLE
	RFSTS				;GET FORK STATUS
	HLLM	A,FKSTAT(C)		;SAVE THE STATUS
	PUSH	P,A			;SAVE TOTAL FORK STATUS
	HLRZ	A,A			;GET LEFT HALF
	CAIN	A,-1			;UNASSIGNED ?
	JRST	UNAS			;YES
	MOVEM	B,FRKPCS(C)		;NO, SAVE THE FORK PC
	AOS	ONFRK			;AND BUMP THE TEMP COUNTER
	HRRZ	B,FKSTAT(C)		;GET THE JOB NUMBER
	CAIN	B,-1			;IS THE FORK BEING STARTED?
	JRST	UNAS			;YES - IGNORE IT

	HRRZ	B,JBSTAT(B)		;GET FRK HANDLE FOR THIS JOB
	CAIE	B,400000(C)		;IT BETTER AGREE WITH OURS
	BUG	(<HLTNFK: JBSTAT AND FKSTAT FORK HANDLES DISAGREE>)
	TRZ	A,(1B0)			;IGNORE FROZEN STATUS
	CAIN	A,2			;VOLUNTARY TERMINATION?
	JRST	HLTVOL			;YES, JUST CLEAN THINGS UP
	CAIN	A,3			;FORCED TERMINATION?
	JRST	HLTFRC			;YES, OOPS - LOG CIRCUMSTANCES
	JRST	UNAS			;MUST STILL BE RUNNING

HLTFRC:	PUSH	P,C			;SAVE FORK INDEX AND COUNTER
	MOVEI	A,400000(C)		;BAD NEWS, GET THE FORK AC'S
	MOVEI	B,ACS
	RFACS

	GTAD				;GET TIME STAMP
	PUSH	P,A			;SAVE IT
	HRROI	A,TRMNAM		;GET A DUMP
	MOVE	B,0(P)			;GET TIME STAMP
	HRRZ	C,-1(P)			;GET FORK INDEX
	MOVEI	C,400000(C)
	PUSHJ	P,FRKDMP

	HRROI	A,DAYBUF		;BUILD OUTPUT MESSAGE
	POP	P,B			;GET DATE STAMP
	MOVSI	C,045000
	ODTIM

	HRROI	B,[ASCIZ /  FORK /]
	SETZ	C,
	SOUT
	HRRZ	B,0(P)			;RECOVER FORK INDEX
	MOVEI	C,10			;WRITE IT IN OCTAL
	NOUT
	JFCL

	HRROI	B,[ASCIZ /, JOB /]
	SETZ	C,
	SOUT
	HRRZ	B,0(P)			;GET JOB NUMBER
	HRRZ	B,FKSTAT(B)
	MOVEI	C,^D10			;WRITE IT IN DECIMAL
	NOUT
	JFCL

	HRROI	B,[ASCIZ /, STATUS = /]
	SETZ	C,
	SOUT
	MOVE	B,-1(P)			;RECOVER COMPLETE STATUS
	MOVE	C,[560014,,10]		;WRITE IT IN OCTAL
	NOUT
	JFCL

	HRROI	B,[ASCIZ /, PC = /]
	SETZ	C,
	SOUT
	HRRZ	B,0(P)			;RECOVER FORK INDEX
	MOVE	B,FRKPCS(B)		;AND PRINT FORK PC
	MOVE	C,[560014,,10]
	NOUT
	JFCL

	HRROI	B,[ASCIZ /
  /]
	SETZ	C,
	SOUT
	HRRZ	B,0(P)			;TACK ON LATEST TENEX ERROR FOR
	HRLOI	B,400000(B)		;THIS FORK
	SETZ	C,
	ERSTR
	JFCL
	JFCL

	HRROI	B,[ASCIZ /
  AC'S:/]
	SETZ	C,
	SOUT				;NOW PRINT OUT THE AC CONTENTS
	MOVSI	E,-4			;DO 4 LINES EACH CONTAINING
	SETZ	D,			;4 AC'S IN OCTAL
	JRST	ACLOP1-2
ACLOP0:	HRROI	B,[ASCIZ /
       /]
	SETZ	C,
	SOUT				;PREPARE FOR THE NEXT LINE
	MOVE	C,[560014,,10]
	HRLI	D,-4
ACLOP1:	MOVEI	B," "			;PRINT LOOP FOR ACS
	BOUT
	BOUT
	MOVE	B,ACS(D)		;PRINT OUT ACS
	NOUT
	JFCL
	AOBJN	D,ACLOP1		;DO ALL 4 ON THIS LINE
	AOBJN	E,ACLOP0		;THEN REPEAT FOR ALL LINES

	HRROI	B,[ASCIZ /
/]
	SETZ	C,
	SOUT
	HRROI	A,TRMNAM		;NOW ENTER THIS IN ABNORMAL-TERMI-
	HRROI	B,DAYBUF		;NATION FILE
	PUSHJ	P,FILPRF

	HRRZ	A,0(P)			;SET REQUEUE FLAG IN JOB STATUS
	HRRZ	A,FKSTAT(A)		;GET JOB #
	MOVSI	B,(FALLST)		;CLEAR CURRENT ACTION REQUESTS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FHLTED+FREQUE)	;SET FLAG TO REQUEUE JOB
	IORM	B,JBSTAT(A)

	POP	P,C			;RESTORE FORK INDEX

HLTVOL:	SKIPE	A,FRKPTY(C)		;CHECK TO SEE IF PTY STILL THERE
	REPTY				;YES, TRY RELEASING IT
	JFCL				;TOO BAD
	MOVEI	A,400000(C)
	CLZFF				;CLOSE INFERIOR'S FILES
	HRRZ	A,FKSTAT(C)		;SEE IF THIS IS JOB 0 - SNDMSG
	CAIE	A,0
	JRST	HLTVL0			;NO, THEN HANDLE AS JOB INFERIOR
	SKIPLE	A,MSGJFN		;YES, RELEASE SNDMSG JFN'S IF > 0
	RLJFN
	JFCL
	SKIPLE	A,TMPJFN
	DELF				;DELETE TEMPORARY MSG FILE
	JFCL
	JRST	HLTVL1			;GO KILL OFF THE FORK

HLTVL0:	SKIPN	B,FRKJFN(C)		;JOB INFERIOR HERE - ANY CTL OR LOG JFN'S AROUND?
	JRST	HLTVL1			;NO, GO KILL OFF THE FORK
	HLRZ	A,B			;YES, CHECK CTL JFN
	SKIPE	A
	CLOSF				;CTL STILL AROUND - CLOSE IT
	JFCL				;IGNORE PROBLEMS AT THIS POINT
	HRRZ	A,B			;NOW ANY LOG FILE?
	SKIPE	A
	CLOSF				;YES, CLOSE IT
	JFCL
	SETZM	FRKJFN(C)		;CLEAR THE DEBRIS

HLTVL1:	MOVEI	A,400000(C)		;OK, NOW GET RID OF THE BODY
	KFORK

	SETZM	FRKPTY(C)		;CLEAR FORK PTY NUMBER
	SETOM	RUNQCP			;YES, THIS ONE STOPPED
	HRRZ	A,FKSTAT(C)		;GET JOB NUMBER
	SETOM	FKSTAT(C)		;CLEAR FORK STATUS
	SETZM	FRKPCS(C)		;CLEAR FORK PC
	SETZ	B,			;CLEAR FORK HANDLE FROM JOB STATUS
	HRRM	B,JBSTAT(A)
	MOVSI	B,(FEXIST+FFREEZ)	;CLEAR EXIST AND FROZEN BITS
	ANDCAM	B,JBSTAT(A)
	MOVSI	B,(FREQUE)		;IS THIS A REQUEUE REQUEST?
	TDNE	B,JBSTAT(A)
	JRST	HLTVL2			;YES, NO FURTHER MODS NEEDED
	MOVSI	B,(FHLTED+FPURGE)	;NO, SET HALTED AND PURGE BITS
	IORM	B,JBSTAT(A)

HLTVL2:	SKIPE	A			;IF THIS IS JOB 0, IT'S SNDMSG
	JRST	HLTVL3			;NO, CARRY ON
	SETZM	JBSTAT			;YES, CLEAR STATUS
	SETZM	FORK			;AND CLEAR SNDMSG LOCKS AND USER ID
	SETOM	SNDLCK
	SETOM	WHOSND

HLTVL3:	SOS	ACTFRK			;DECREMENT NUMBER OF ACTIVE FORKS
	SOS	ONFRK			;AND IN THE TEMPORARY COUNT

UNAS:	POP	P,A			;CLEAR FORK STATUS
	AOBJN	C,INFLP			;FINISH LOOKING AT ALL FORKS

	MOVE	A,ONFRK			;NOW COMPARE THE CURRENT COUNT
	CAME	A,ACTFRK		;WITH THE RUNNING COUNT
	BUG	(<HLTNFK: ACTIVE FORK COUNT OFF>,.+1)
	MOVEM	A,ACTFRK		;RESET IT IF NECESSARY

	POP	P,E			;RESTORE AC'S
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	DEBRK
	BUG	(<HLTNFK: DEBRK FAILED>)




;THE FOLLOWING PRINTS OUT THE STATUS OF THE INFERIOR FORKS IN RESPONSE
;TO A ^S
INFSTS:	PUSH	P,A
	PUSH	P,B
	MOVEI	A,101			;SET OUTPUT AS PRIMARY JFN
	SETZ	B,			;FLAG NOT TO FREEZE FORKS
	PUSHJ	P,INFSTO		;GO OUTPUT STATUS
	POP	P,B			;RECOVER AC'S AND RETURN
	POP	P,A
	DEBRK
	BUG	(<INFSTS: DEBRK FAILED>)


;THIS ROUTINE PURGES COMPLETED AND CANCELLED JOBS FROM THE QUEUE
QUECOP:
	IFE	FSUSER,<
IFE	FSTCPY,<			;DO WE WANT PMAP TRIMMER?
;TRIM QUEUE WITH FANCY END POINTER AND PMAP TRIMMER.

EOJ10:	MOVEM	B,EOJFK		;SAVE FORK TO SEARCH QUEUE FOR
	MOVN	B,B			;NEGATIVE FORK INDEX
	MOVSI	A,400000		;STARTING BIT
	LSH	A,0(B)			;POSITION BIT
	ANDCAM	A,HLTDFK		;SHOW WE ARE TAKING CARE OF IT
EOJ3:	MOVSI	A,(1B7!1B17)		;NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG	(<EOJ3: Gtjfn failed for Q file>)

	MOVE	B,[44B5!1B19!1B20]	;36 BIT,READ,WRITE
	QOPENF
	BUG	(<EOJ3: ERROR OPENING QUEUE>)
	BUG	(<EOJ3: TIME OUT OPENING QUEUE>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

;CHECK TO SEE THAT Q IS NOT SCREWED UP, ALSO GET THE
;SIZE OF THE Q SO WE CAN COMPUTE NUMBER OF ENTRYS.
	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,[2,,11]		;2 WDS, STARTING AT WD 11
	MOVEI	C,D			;WHERE TO STORE IT
	GTFDB				;READ FROM FDB
	JUMPG	D,.+2			;IF Q NON NULL
	BUG	(<NULL QUEUE BUT WE RAN A JOB IN IT>)
	LDB	B,[POINT 6,D,11]	;GET BYTE SIZE
	CAIE	B,^D36			;MUST BE 36 BIT
	HALTF
	MOVE	B,E			;GET # WDS
	IDIVI	B,QESIZE		;DIVIDE BY ENTRY SIZE
	CAIE	C,0			;MUST GO EVENLY
	HALTF

;ZERO OUT THE Q ENTRY WE JUST DID
	SETZM	QENT			;ZERO OUT CORE AREA
	MOVE	A,[QENT,,QENT+1]	;BLT WORD
	BLT	A,QENT+QESIZE-1		;DO IT ALL

	MOVE	A,QJFN			;GET JFN FOR Q
	MOVE	B,BESTPT		;GET POINTER TO THIS ENTRY
	SFPTR				;POINT TO IT IN FILE
	BUG	(<EOJ3: Sfptr failed on Q file>)
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;AND GET LENGTH
	SOUT				;WRITE ZEROS ON IT

;FIND POSITION OF LAST REAL QUEUE ENTRY.
	MOVE	C,E			;GET EOF POINTER
TRMSLP:	SUBI	C,QESIZE		;FIND POINTER TO LAST ENTRY
	JUMPL	C,TRMSLE		;IF WE WENT NEGATIVE,TRIM IT ALL
	RIN				;GET A BYTE (DIRNUM TO USE)
	JUMPE	B,TRMSLP		;IF 0,NOT A JOB,SO TRY ANOTHER
	MOVE	B,C			;YES,POINT PAST END AND CLEAN UP
	ADDI	B,QESIZE		;SKIP AROUND GOOD ONE
	JRST	.+2			;SKIP NEXT INSTRUCTION
TRMSLE:	SETZ	B,			;HERE IF WE TRIM IT ALL
	SFPTR				;SET FILE POINTER
	BUG	(<TRMSLP: Sfptr failed on Q file>)

;FIND AND DELETE ANY PAGES OF Q BEYOND END
	SUBI	B,1			;GET LAST WORD ADDRESS
	JUMPL	B,TRMALL		;WE ARE TRIMMING IT ALL
	LSH	B,-^D9			;GET PAGE # LAST WORD ON
	MOVE	D,B			;PUT IT IN D
	ADDI	D,1			;GET FIRST FREE PAGE
	JRST	TRMQ			;SKIP NEXT INSTRUCTION
TRMALL:	SETZ	D,			;WE TRIM IT ALL
TRMQ:	HRLZ	A,QJFN			;GET Q JFN
	HRR	A,D			;GET PAGE #
	FFUFP				;FIND ANY PAGES
	JRST	NOTRMQ			;PERHAPS NO MORE
	MOVE	B,A			;PAGE TO KILL
	SETO	A,			;SAY KILL IT
	SETZ	C,			;NO ACCESS 
	PMAP				;KILL PAGE
	JRST	TRMQ			;GO FOR ANOTHER

NOTRMQ:	CAIE	A,FFUFX3		;REALLY NO MORE?
	BUG	(<NOTRMQ: We thought there weren't more pages but..>)

;CLOSE THE QUEUE FILE
	HRRZ	A,QJFN			;BE SURE TO RELEASE JFN HERE
	CLOSF				;THE LH 0 PROVIDES THAT
	BUG	(<NOTRMQ: Tried to close-release Q file after trim and lost>)
	SETZM	QJFN			;Q NOT OPEN

	JRST	GETJOB			;MORE WORK
	>				;END IFE FSTCPY-TRIM W/O COPY
;TRIM THE QUEUE WITH THE COPY OPERATION
IFN	FSTCPY,<			;ARE WE TRIMMING WITH A COPY?

;BEWARE--THESE ROUTINES DO NOT YET PROVIDE EXCLUSION OF OTHER
;ACCESS TO THE BATCH QUEUE DURING THESE OPERATIONS.  THUS IF
;THERE IS ANOTHER BATCON RUNNING, HE MAY ACCESS THE QUEUE
;AT THE SAME TIME, CAUSING BAD RESULTS.  ALSO A SUBMIT
;MAY HAVE ACCESS TO THE QUEUE WHICH WOULD CAUSE TROUBLE.

EOJ10:
EOJ3:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B
	PUSH	P,C
	MOVSI	A,(1B7!1B17)		;NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG	(<QUECOP: GTJFN FAILURE ON Q>)
	MOVEM	A,QJFN			;STORE THIS ONE TEMPORARILY

;OPEN THE OLD QUEUE FOR READ AND WRITE.
	MOVE	B,[44B5!1B19!1B20]	;36 BIT, READ, WRITE
EOJ31:	QOPENF
	BUG	(<QUECOP: ERROR OPENING OLD QUEUE>)		;NO OTHER PROBLEM
	SKIPA				;TIME-OUT DURING OPEN
	JRST	EOJ32			;OPEN OK, GET AROUND ERROR STUFF

	POP	P,A			;CLEAR RETURN POPJ ADDRESS
	BUG	(<QUECOP: TIME OUT OPENING OLD QUEUE>,QOPTMO)

EOJ32:	MOVEM	A,OLDQ#			;SAVE JFN FOR OLD Q
	MOVE	B,[XWD 1,FDBUSW]	;GET USER SETTABLE WORD
	MOVEI	C,MXJBNO		;OR CURRENT MAX JOB NUMBER
	GTFDB

	MOVSI	A,(1B0+1B7+1B17)	;GET JFN FOR NAME OF TEMP QUEUE
	HRROI	B,TMPNAM		;NAME OF THE TEMPORARY.
	GTJFN
	BUG	(<QUECOP: GTJFN FAILED ON TEMPORARY Q>)
	MOVEM	A,TMPQJF#		;SAVE IT
	MOVEI	B,1			;DELETE ALL BUT THIS VERSION
	DELNF
	BUG	(<QUECOP: DELNF ERROR ON TEMPORARY Q>)
	MOVE	B,[44B5!1B20]		;OPEN FOR 36 BIT WRITE
	QOPENF
	BUG	(<QUECOP: ERROR OPENING NEW QUEUE>)
	JRST	[HRRZ	A,TMPQJF	;RELEASE JFN
		 RLJFN
		 BUG	(<QUECOP: ERROR RELEASING TEMP Q JFN>)
		 POP	P,A		;CLEAR POPJ RETURN ADDRESS
		 BUG	(<QUECOP: TIME OUT OPENING NEW QUEUE>,QOPTMO)]

	MOVEM	A,QJFN			;SAVE THE JFN FOR THE Q

	SETZM	JBBITS			;CLEAR JOB ENTRY BIT TABLE
	MOVE	A,[JBBITS,,JBBITS+1]
	MOVEI	B,NJBWRD		;MORE THAN 1 WORD?
	CAILE	B,1
	BLT	A,JBBITS+NJBWRD-1	;YES, CLEAR THEM

;COPY LOOP FOR THE QUEUE
	SETZM	QPNTR			;STARTING AT START OF Q
	HRRZ	A,OLDQ			;CHECK FOR 0 LENGTH FILE
	MOVE	B,[1,,12]		;DISPLACEMENT FOR BYTE SIZE
	MOVEI	C,C
	GTFDB
	MOVE	A,C			;FIRST CHECK SIZE LEGALITY
	IDIVI	A,QESIZE		;REMAINDER BETTER BE 0
	SKIPE	B
	BUG	(<QCOPY: Q ENTRIES WRONG LENGTH>)	;OOPS
	JUMPG	C,QCPYST
	SETZM	HLTDFK
	JRST	QCOPYE

QCPYST:	NOINT				;TURN OFF INTERRUPTS

QCOPY:	MOVE	A,OLDQ			;GET OLD Q JFN
	MOVE	B,[POINT 36,QENT]	;WHERE TO PUT IT
	MOVNI	C,QESIZE		;AMOUNT TO READ
	SIN

	GTSTS				;READ STATUS BITS
	TLNE	B,1000			;WAS EOF READ?
	JRST	QCOPYE			;YES-END OPERATION

	SKIPG	QENT+USRDIR		;IS THIS ENTRY A VALID USER?
	BUG	(<QCOPY: INVALID USER ID>,QCOPYT)

;;;	HRRZ	A,QENT+STRTED		;GET STARTING JOB NUMBER
;;;	JUMPE	A,QANAL			;NOBODY STARTED IT - SEE WHAT TO DO
;;;	CAME	A,JOBNO			;SOMEONE DID - WAS IT US
;;;	JRST	QCOPYB			;NO, COPY IT AND LOOK AT THE NEXT ENTRY

QANAL:	MOVM	A,QENT+BJOBNO		;GET JOB NUMBER (REG OR CHG REQ)
	CAILE	A,0			;IS IT IN THE RIGHT RANGE?
	CAILE	A,NQJBS
	BUG	(<QCOPY: Q ENTRY HAS JOB # OUT OF RANGE>,QCOPYT)

	SKIPN	JBSTAT(A)		;WAS IT ENTERED IN THE Q BEFORE?
	JRST	QANAL1			;NO, THEN GO ON
	HLRZ	B,JBSTAT(A)		;YES, GET THE USER DIRECTORY
	ANDI	B,777			;STORED THERE
	CAME	B,QENT+USRDIR		;IT BETTER MATCH THE ONE JUST READ
	BUG	(<QCOPY: USER DIR #'S DO NOT MATCH>,QCOPYT)

QANAL1:	IDIVI	A,^D36			;COMPUTE BIT TABLE LOCATION
	MOVSI	C,(1B0)			;START WITH BIT AT 0
	MOVN	B,B			;NEG OF REMAINDER
	LSH	C,0(B)			;MOVE BIT TO RIGHT SLOT
	TDNE	C,JBBITS(A)		;IS IT ALREADY THERE?
	BUG	(<QCOPY: DUPLICATE JOB # ENTRIES IN Q>,QCOPYT)
	IORM	C,JBBITS(A)		;NO, THEN SET IT
IFE	FDBSEQ,<
	SKIPG	QENT+BJOBNO		;CHANGE REQUEST?
	SKIPG	SEQJFN			;FILE OPEN NOW?
	CAIA				;NO, LEAVE SEQ FILE ALONE
	IORM	C,FJBBIT(A)		;YES, (RE)SET THE BIT
	>	;END FDBSEQ CONDITIONAL

	SKIPG	A,QENT+BJOBNO		;REGULAR JOB?
	JRST	[MOVMS	A,QENT+BJOBNO	;NO, CHANGE.  MAKE # POSITIVE
		 HRROI	B,[ASCIZ \ CHANGED/RESUBMITTED ON \]
		 SETZ	C,		;NO APPENDIX
		 PUSHJ	P,WINFRM	;ANNOUNCE IT
		 JRST	.+1]
	PUSHJ	P,JOBSIT		;FIND JOB STATUS
	JRST	JSTSET			;WE DON'T KNOW ABOUT THIS JOB - SET IT
	JFCL				;OK IT'S HERE - SEE WHAT TO DO
	JRST	QDISPO			;JOB DONE - SEE WHAT TO DO
	JFCL				;JOB STILL RUNNING - JUST COPY IT
	JRST	QCOPY1			;JOB STILL RUNNING - JUST COPY IT

JSTSET:	SETZ	B,			;INITIALIZE JOB STATUS
	SETZM	QENT+STRTED		;CLEAR STARTED FLAGS
	JRST	QCOPY1

QDISPO:	TLNE	B,(FREQUE)		;REQUEUE REQUEST?
	JRST	JBREQ			;YES, GO DO IT
	TLNE	B,(FPURGE)		;PURGE REQUEST?
	JRST	QPRG			;YES, GO DO IT
	TLNE	B,(FRESET)		;RESET REQUEST?
	JRST	QRSET			;YES, GO DO IT
	TLNE	B,(FDEFER)		;DEFER REQUEST?
	JRST	QDFER			;YES, GO DO IT
	TLNE	B,(FHLTED)		;WAS IT HALTED?
	BUG	(<QANAL: JOB HALTED WITH NO DISPOSITION>)  ;YES - ERROR
	TLNN	B,(FFSTRT)		;FORCED START?
	JRST	JSTSET			;NO - JUST COPY IT. NOTHING GOING ON

	MOVSI	B,(FFSTRT)		;SET STATUS ENTRY FOR FORCED START
	JRST	QCOPY1

JBREQ:	HRROI	B,[ASCIZ \ ABORTED/REQUEUED ON \]
	HRROI	C,[ASCIZ /
   BATCH FORK INVOLUNTARY TERMINATION, JOB WILL BE RERUN/]
	PUSHJ	P,WINFRM		;GO GIVE THE BAD NEWS.

	SETZM	QENT+JOBSTT		;CLEAR STARTING TIME
	JRST	JSTSET			;GO RESET IT

QPRG:	SETZM	JBSTAT(A)		;CLEAR JOB STATUS
	MOVE	A,QENT+BJOBNO		;GET JOB NUMBER AND CLEAR BIT
	IDIVI	A,^D36			;TABLE ENTRY
	MOVSI	C,(1B0)			;START WITH BIT AT 0
	MOVN	B,B			;NEG OF REMAINDER
	LSH	C,0(B)			;MOVE BIT TO RIGHT SLOT
	ANDCAM	C,JBBITS(A)		;ZAP BIT TABLE ENTRY
IFE FDBSEQ,<
	SKIPE	SEQJFN			;IF WE HAVE THE JOB SEQ FILE
	ANDCAM	C,FJBBIT(A)		;CLEAR THE BIT THERE AS WELL
	>
	JRST	QCOPY2			;SKIP OVER Q ENTRY

QRSET:	SETZM	QENT+RESTRT		;OK - RESET QUEUE ENTRY
	SETZM	QENT+JOBSTT
	JRST	JSTSET			;NOW RESET STATUS ALSO AND COPY

QDFER:	MOVE	C,[XWD 377777,777777]	;SET LARGE DATE FOR JOB START
	MOVEM	C,QENT+JOBSTT
	JRST	JSTSET			;RESET STATUS

QCOPY1:	TLO	B,(FINQUE)		;SHOW JOB IN QUEUE
	TLZ	B,777			;RESET USER DIRECTORY NUMBER
	HRLZ	C,QENT+USRDIR
	ADD	B,C
	MOVEM	B,JBSTAT(A)

	SKIPG	C,JBNCHG		;HAVE ANY JOB #'S CHANGED?
	JRST	QCOPYB			;NO, JUST WRITE IT
	SKIPN	A,QENT+AFTER		;YES, THIS JOB RUNS AFTER SOMETHING?
	JRST	QCOPYB			;NOPE, STILL WRITE IT
	CAILE	A,NQJBS			;YES, WAS IT ANOTHER JOB #?
	JRST	QCOPYB			;NOPE, EVEN WRITE IT
QCPCHG:	HLRZ	B,JBNCHG(C)		;YES, GET OLD # FOR THIS ENTRY
	CAME	A,B			;DOES IT APPLY?
	JRST	NXTCHG			;NOPE, TRY ANOTHER
	MOVE	B,JOBENT(C)		;WAS IT ENTERED AFTER THE SWITCH?
	CAML	B,QENT+ENTERD
	JRST	QCOPYB
	PUSH	P,C			;YES, SAVE THE CHANGE INDEX
	HRROI	A,BUGSTR		;AND MAKE A WARNING MESSAGE
	HRROI	B,[ASCIZ /
   THIS JOB WAS TO RUN AFTER JOB /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RECOVER THE INDEX
	HLRZ	B,JBNCHG(B)		;GET OLD NUMBER
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ /.  TWO JOBS NUMBERED /]
	SETZ	C,
	SOUT
	MOVE	B,0(P)			;RECOVER THE INDEX
	HLRZ	B,JBNCHG(B)		;GET OLD NUMBER
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ / WERE
   ENTERED - ONE CHANGED TO /]
	SETZ	C,
	SOUT
	POP	P,B			;AND ONE LAST TIME
	HRRZ	B,JBNCHG(B)		;NOW GET THE NEW NUMBER
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ /.  PLEASE RECHECK PROPER DEPENDENCY/]
	SETZ	C,
	SOUT

	MOVEI	B,JWARN			;ISSUE A WARNING MESSAGE
	HRROI	C,BUGSTR		;AND THIS APPENDIX
	PUSHJ	P,WINFRM
	JRST	QCOPYB			;AND FINALLY GO WRITE IT

NXTCHG:	SOJG	C,QCPCHG		;LOOK AT THE NEXT LOWER ENTRY
	JRST	QCOPYB			;NO HITS, AFTER ALL OF THIS ...
	
QCOPYB:	MOVE	A,QJFN			;YES
	MOVE	B,[POINT 36,QENT]	;POINT TO IT
	MOVNI	C,QESIZE		;SIZE OF IT
	SOUT				;PUT IT OUT
	JRST	QCOPY2

QCOPYT:	PUSHJ	P,PTRASH		;BAD Q ENTRY HERE, TRASH IT
	JRST	QCOPY2


QCOPY2:	MOVEI	A,QESIZE		;AMOUNT WE DID
	ADDM	A,QPNTR			;COUNT IT

	JRST	QCOPY			;AND GO FOR MORE

QCOPYE:	OKINT				;RESTART INTERRUPTS SYSTEM

	HRRZ	A,QJFN			;CLOSE THE NEW QUEUE
	TLO	A,(1B0)			;BUT DON'T RELEASE JFN
	CLOSF
	BUG	(<QCOPYE: ERROR CLOSING NEW QUEUE>)

	HRRZ	A,OLDQ			;NOW CLOSE THE OLD ONE
	TLO	A,(1B0)			;ALSO KEEP THE JFN
	CLOSF
	BUG	(<QCOPYE: ERROR CLOSING OLD QUEUE>)

	MOVE	A,QJFN		;CHANGE USER SETTABLE WORD
	HRLI	A,FDBUSW		;WHAT TO CHANGE TO
	MOVE	C,MXJBNO		;CHANGE ALL BITS
	SETO	B,
	CHFDB
	MOVE	A,QJFN			;THE REAL Q NOW
	MOVE	B,OLDQ			;THE NAME WE GIVE IT
	RNAMF				;DO RENAME TO NORMAL NAME
	BUG	(<RNAMF FAILED IN Q RENAME>)

	MOVE	A,OLDQ			;RELEASE THE QUEUE JFN
	RLJFN
	BUG	(<CANNOT RELEASE Q JFN AFTER REWRITE>)

IFE FDBSEQ,<
	PUSHJ	P,WRSQLK		;REWRITE THE JOB SEQ LOCK FILE
	>

	SETZM	JBNCHG			;CLEAR THE JOB # CHANGE TABLE
	MOVE	A,[JBNCHG,,JBNCHG+1]
	BLT	A,JBNCHG+MXCHG

	SETZM	RUNQCP			;CLEAR RUN QCOPY FLAG

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN

;	*** STILL IN  IFE FSUSER  CONDITIONAL ***

;WAIT FOR WORK TO COME
NOJOBS:	HRRZ	A,QJFN			;BATCH QUEUE JFN
	GTSTS				;GET ITS STATUS
	TLNE	B,(1B0)			;IF OPEN CLOSE IT
	JRST	[CLOSF
		 BUG	(<NOJOBS: ERROR	CLOSING QUEUE>)
		 JRST	NOJB0]

	HRRZ	A,QJFN			;NOW RELEASE IT IF NEEDED
	TLNE	B,(1B10)
	JRST	[RLJFN
		 BUG	(<NOJOBS: ERROR RELEASING Q JFN>)
		 JRST	NOJB0]

NOJB0:	SETZM	QJFN			;ZERO QUEUE JFN

NOJB1:	SKIPGE	RUNQCP			;ENTRIES TO DELETE FROM BATCH QUEUE ?
	JRST	GETJOB			;AS LONG AS WE HAVE TO GO DO IT, WE
					;MIGHT AS WELL CHECK NEW ORDERS AS WELL

	MOVEI	A,^D60000		;ONE MINUTE
	DISMS				;WAIT
	JRST	GETJOB			;TRY FOR ANOTHER JOB
	>
	>				;END IFE FSUSER
;CALL:	A/ JFN OF DESIRED FILE
;	B/ BIT FOR ACCESS DESIRED (IN BITS 0-5)
;RETURNS	+1 IF ILLEGAL ACCESS
;		+2 IF ACCESS OK

;VALUES USED HERE
ACCBWR==200000,,0
ACCBAP==040000,,0

CHKACC:	PUSH	P,A			;STASH THE ARGUMENTS
	PUSH	P,B			; ..
	HRROI	A,DIRBLK		;TEMP FOR THE DIRECTORY NAME
	HRRZ	B,-1(P)			;THE JFN
	MOVSI	C,(1B5)			;JFNS TO OUTPUT JUST DIRECTORY
	JFNS
	MOVEI	A,0			;FLAG TO NOT RECOGNIZE
	HRROI	B,DIRBLK		;WHERE NAME STRING IS
	STDIR				;GET THE NAME
	BUG	(<STDIR failure in CHKACC returned +1>)
	BUG	(<STDIR failure in CHKACC returned +2>)
	HRRZM	A,DIRNMF		;STASH DIRECTORY NUMBER OF FILE
	MOVEI	A,(A)			;JUST NUMBER
	MOVEI	B,DIRBLK		;PLACE FOR GTDIR DATA
	MOVEI	C,0			;NO NEED FOR PASSWORD
	GTDIR				;FIND OUT ABOUT THAT DIR
	HRRZ	A,-1(P)			;THE JFN AGAIN
	MOVSI	B,25			;ARG TO GTFDB FOR ALL DATA
	MOVEI	C,FDBBLK		;PLACE TO STORE IT
	GTFDB				;READ SAME
	MOVEI	C,0			;ROTATE COUNTER
	HRLZ	D,FDBBLK+4		;FILE PROTECTION BITS
	MOVE	A,DIRBLK+6		;DIRECTORY NUMBER OF FILE
	CAMN	A,USRBLK+6		;DIRECTORY NUMBER OF USER
	JRST	CHK1			;SAME. DON'T ROTATE
	MOVE	A,USRBLK+13		;GROUPS USER HAS ACCESS TO
	TDNE	A,DIRBLK+14		;FILE IN ONE OF THOSE GROUPS?
	SUBI	C,6			;YES. WILL MOVE TO GROUP BITS
	ADDI	C,14			;FOR UNIVERS OR GROUP BITS
CHK1:	ROT	D,0(C)			;ROTATE THE FILE'S BITS
	MOVE	A,FDBBLK+1		;GET STATUS BITS FOR FILE
	TLNN	A,(1B4)			;THIS FILE EXIST?
	JRST	CHK2			;YES.
	MOVE	A,0(P)			;NO. NEW FILE. GET ACCESS REQUEST.
	TLNN	A,(ACCBWR!ACCBAP)	;WRITE OR APPEND?
	JRST	CHK2			;NO.
	HRLZ	A,DIRBLK+10		;YES. LEGAL TO CREATE NEW FILE?
	ROT	A,(C)			;CHECK DIRECTORY PROTECTION FIELD
	TLNN	A,(ACCBAP)		;APPEND TO DIRECTORY OK? (NEW FILES)
	JRST	CHK3			;NO. THIS REQUEST ILLEGAL.
CHK2:	TLC	D,(77B5)		;COMPLEMENT OPERATIVE PROT FIELD
	TDNN	D,0(P)			;IS THE ACCESS ALLOWED?
	AOS	-2(P)			;YES. SKIP RETURN
CHK3:	POP	P,B			;RESTORE REGS
	POP	P,A
	POPJ	P,			;RETURN
;ROUTINE TO RELEASE QJFN IF THERE AND TO RECYCLE TO GETJOB
;USED AS ADDRESS FOR TIME OUT BUG RETURN AFTER QOPENF

QOPTMO:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B

	HRRZ	A,QJFN			;BATCH QUEUE JFN
	GTSTS				;JFN STATUS
	TLNE	B,(1B0)			;IF OPEN, CLOSE IT
	JRST	[TLO	A,(1B0)		;DON'T RELEASE JFN
		 CLOSF
		 BUG	(<QOPTMO: ERROR CLOSING QUEUE>)
		 HRRZ	A,A		;RESTORE JUST QJFN
		 JRST	.+1]

	TLNE	B,(1B10)		;IF JFN VALID RELEASE IT
	RLJFN

	SETZM	QJFN			;CLEAR QUEUE JFN

	POP	P,B			;RESTORE AC'S
	POP	P,A

	JRST	GETJOB			;AND TRY AGAIN



;ROUTINE TO CHECK THE STATUS OF A JOB
;ON ENTRY:	A  = JOB #
;RETURNS	+1  NEVER HEARD OF THE JOB
;		+2  JOB IN Q ONLY - NOT RUNNING OR RUN
;		+3  JOB IN Q, HAS RUN AND HALTED
;		+4  JOB IN Q, IS RUNNING FROZEN
;		+5  JOB IN Q, IS RUNNING MELTED
;	B =  JOB STATUS BITS

JOBSIT:	SKIPN	B,JBSTAT(A)		;HAVE WE HEARD OF IT?
	JRST	JBSRET			;NO - RETURN +1
	AOS	0(P)			;YES, AT LEAST +2
	TRNE	B,-1			;DOES A FORK EXIST NOW?
	JRST	JOBSI1			;YES - CHECK STATE
	TLNN	B,(FHLTED)		;NO - HAS ONE HALTED?
	JRST	JBSRET			;NO - RETURN +2
	AOS	0(P)			;YES - RETURN +3
	JRST	JBSRET

JOBSI1:	TLNE	B,(FHLTED)		;FORK RUNNING - HALTED BIT ON?
	BUG	(<JOBSIT: RUNNING FORK SHOWN AS HALTED>)
	AOS	0(P)			;NO - RETURB AT LEAST +4
	AOS	0(P)
	TLNE	B,(FFREEZ)		;IS IT FROZEN?
	JRST	JBSRET			;YES - RETURN +4
	AOS	0(P)			;NO, RETURN +5
	JRST	JBSRET

JBSRET:	POPJ	P,			;RETURN WITH STATUS IN B



;ROUTINE TO FORCE HALT A LOWER FORK.  AN INTERRUPT IS SENT ON A
;SPECIFIED CHANNEL.
;
;ON ENTRY:	A  = JOB #
;		B  = CHANNEL TO USE FOR INTERRUPT (BIT POSITION)
;
;IF IT DOESN'T DIE IN 1 MINUTE, IT IS KILLED.  THIS MAY LEAVE ITS PTY STILL
;ASSIGNED.  IT ALWAYS RETURNS WITH THE INTERRUPT SYSTEM ACTIVATED.

FRCHLT:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B
	PUSH	P,C

	NOINT				;DISABLE INTERRUPT SYSTEM - SO FORK
					;DOESN'T DISAPPEAR UNDER US
	HRRZ	A,JBSTAT(A)		;GET FORK HANDLE
	SKIPN	A			;IS IT REAL?
	JRST	FRCHL2			;NO - RETURN
	MOVE	B,-1(P)			;USE CHANNEL SPECIFIED
	IIC				;REQUEST SUICIDE
	ANDI	A,777			;KEEP ONLY FORK INDEX PART
	PUSH	P,A			;SAVE IT
	SETO	B,
	MOVEI	C,^D20			;20 5 SEC WAITS MAX
	OKINT				;RESTART INTERRUPTS

FRCHL0:	MOVE	A,0(P)			;GET FORK INDEX
	CAMN	B,FKSTAT(A)		;IS THE FORK GONE?
	JRST	FRCHL1			;YES, WIND IT UP

	SOJE	C,FRCKIL		;TOO LONG A WAIT - GO KILL IT
	MOVEI	A,^D5000		;OK, WAIT 5 SEC MORE
	DISMS
	JRST	FRCHL0			;TRY AGAIN

FRCKIL:	NOINT				;NO INTERRUPTS
	MOVE	A,0(P)			;FORK INDEX
	CAMN	B,FKSTAT(A)		;ONE LAST CHANCE
	JRST	FRCHL1
	MOVEI	A,400000(A)		;MAKE IT A FORK HANDLE AGAIN
	FFORK				;FREEZE IT
	RFSTS				;GET THE STATUS
	HLRZ	A,A			;ONLY STATUS
	CAIN	A,-1			;DOES IT EXIST?
	BUG	(<FRCHLT: NONEXISTENT FORK IN TABLES>)
	TRZ	A,(1B0)			;TURN OFF FROZEN BIT
	CAIE	A,2			;NORMAL HALT?
	CAIN	A,3			;OR ABNORMAL HALT?
	JRST	[MOVEI	A,400000	;YES, FAKE AN INTERRUPT
		 MOVEI	B,1B19		;ON INFERIOR TERM CHANNEL
		 IIC
		 BUG (<FRCHLT: NO INTERRUPT RECEIVED FOR HALTED FORK>)]
	MOVE	A,0(P)			;RESTORE FORK HANDLE
	MOVEI	A,400000(A)
	HFORK				;HALT IT
	OKINT
	BUG	(<FRCHLT: LOWER FORK DID NOT RESPOND TO HALT INTERRUPT>,FRCHL1)

FRCHL1:	POP	P,A			;CLEAR FORK INDEX FROM STACK

FRCHL2:	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	OKINT
	POPJ	P,			;RETURN




;EVALUATE PRIORITY OF A JOB FOR EXECUTION
;EXPECTED TO USE REGS A,B,C,D,E (AND PERHAPS MORE)
;RETURNS +1 WITH THE PRIO IN A, IF .LT. 0 THEN
;THE JOB IS NOT TO BE RUN AT ALL AT THIS TIME.
;THE GREATER THE NUMBER IS, THE BETTER THE JOB IS TO RUN.

;COMPUTE HOW LONG (IN SECONDS) JOB HAS BEEN WAITING.
EVPRIO:	MOVE	A,QENT+AFTER		;CHECK FOR "AFTER JOB" REQUEST
	TLNE	A,-1			;LEFT HALF EMPTY?
	JRST	EVPRI1			;NO - MUST BE A DATE
	ANDI	A,777			;YES - EITHER NULL OR JOB REQUEST
	SKIPE	JBSTAT(A)		;IF JOB SPECIFIED IS THERE -
	JRST	NORUN			;DON'T RUN THIS ONE UNTIL IT IS GONE

EVPRI1:	GTAD				;GET CURRENT TIME
	CAMN	A,[-1]			;WAS IT -1?
	JRST	NORUN			;REFUSE ALL JOBS IF TIME NOT SET
	CAMG	A,QENT+AFTER		;CHECK IF HE CAN BE RUN YET.
	JRST	NORUN			;HE WANTS TO WAIT SOME MORE.

;IF THIS IS PRIME TIME, DON'T ALLOW MORE THAN MAXJBS JOBS FOR THIS USER
	MOVE	B,A
	SETZ	D,
	ODCNV				;GET LOCAL SECONDS PAST MIDNIGHT
	HRRZ	D,D
	CAIL	D,STPRM			;IS IT BEFORE PRIME START
	CAILE	D,ENDPRM		;NO, IS IT AFTER PRIME END
	JRST	NONPRM			;YES, THEN DON'T BOTHER

	MOVE	A,NJOBTB		;THIS IS PRIME TIME - HOW MANY JOBS
	SETZ	B,
JOBCNT:	SOJL	A,LSTENT
	HRRZ	C,JBDRTB(A)		;FETCH DIR NUM FOR THIS JOB
	CAMN	C,QENT+USRDIR		;IS IT THE SAME AS THE ONE WE WANT TO RUN
	AOJ	B,			;YES, THEN COUNT IT
	JRST	JOBCNT			;DO ALL OF THEM

LSTENT:	CAIL	B,MAXJBS		;ARE TOO MANY RUNNING
	JRST	NORUN			;YES, THEN IGNORE THIS ONE

NONPRM:	GTAD				;GET CURRENT DATE AND TIME
	HLRZ	B,A			;GET CURRENT DAY
	HLRZ	C,QENT+ENTERD		;GET TIME ENTERED
	MOVSI	D,-1			;ANY AFTER TIME SPECIFIED?
	TDNE	D,QENT+AFTER
	HLRZ	C,QENT+AFTER		;YES, USE IT FOR CALCULATION
	SUB	B,C			;FIND #DAYS WAITED
	IMULI	B,^D24*^D3600		;TIMES SECONDS/DAY
	HRRZ	C,QENT+ENTERD		;GET TIME ENTERED
	TDNE	D,QENT+AFTER		;IF AFTER GIVEN, US IT
	HRRZ	C,QENT+AFTER		;USE THIS INSTEAD IF GIVEN.
	HRRZ	A,A			;ISOLATE CURRENT TIME
	SUB	A,C			;GET SECONDS ELAPSED
	ADD	A,B			;ADD PART DUE TO DAYS
;A NOW HAS THE NUMBER OF SECONDS THE JOB HAS WAITED TO RUN.

	POPJ	P,			;RETURN PRIORITY IN A

NORUN:	SETO	A,			;-1 MEANS NO GO
	POPJ	P,			;RETURN
;ROUTINE TO COMPOSE A MESSAGE OF THE FORM:
;	HEADER <FILE NAME> TAIL
;MESSAGE IS PUT IN BUGSTR AND MADE ASCIZ
;ON ENTRY:	A = VALID FILE JFN
;		B = STRING POINTER TO HEADER
;		C = STRING POINTER TO TAIL

BUGFIL:	PUSH	P,A			;SAVE FILE JFN
	PUSH	P,B			;SAVE HEAD
	PUSH	P,C			;SAVE TAIL

	HRROI	A,BUGSTR		;OUTPUT TO BUGSTR
	SETZ	C,
	SOUT				;OUTPUT HEADER
	HRRZ	B,-2(P)			;GET JFN
	MOVE	C,[XWD 011110,1]
	JFNS				;DO FILE NAME
	MOVE	B,0(P)			;GET TAIL POINTER
	SETZ	C,
	SOUT
	HRROI	B,ASTRSK		;FINALLY, PUT ON A SEPARATOR
	SOUT

	HRROI	B,BUGSTR		;AND SEND IT TO THE CRASH FILE
	PUSHJ	P,SNDCSH

	POP	P,C			;RECOVER AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN



;ROUTINE TO OPEN CRASH FILE AND SEND A MESSAGE OF THE FORM:
;	<DATE/TIME>  MESSAGE
;CRASH FILE IS CLOSED WITHOUT RELEASING JFN AT END
;ON ENTRY:	B = STRING POINTER TO MESSAGE

SNDCSH:	PUSH	P,A			;SAVE WORKING AC'S AND PTR (B)
	PUSH	P,B
	PUSH	P,C

	HRROI	A,DAYBUF		;CONSTRUCT MESSAGE IN DAYBUF
	HRROI	B,CRLF			;DO CRLF
	SETZ	C,
	SOUT
	SETO	B,			;GET CURRENT DATE/TIME
	MOVSI	C,045000
	ODTIM
	MOVEI	B," "			;SPACE OVER
	BOUT
	BOUT
	MOVE	B,-1(P)			;GET MESSAGE POINTER
	SETZ	C,
	SOUT				;WRITE IT

	HRROI	A,CRASH			;SEND IT TO THE HEAD OF THE
	HRROI	B,DAYBUF		;CRASH FILE NOW
	PUSHJ	P,FILPRF

SNDCRT:	POP	P,C			;RECOVER AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN


;ROUTINE TO INITIALIZE A USER-GENERATED QUEUE MANAGEMENT FILE INPUT
;FOR JOB.*;*, DJOB.*;*, AND CJOB.*;*.  THE FILE IS OPENED FOR READ,
;ITS BYTE COUNT CHECKED AGAINST QESIZE, ITS FDB AUTHOR CHECKED AGAINST
;THE USRDIR AUTHOR, AND THE CONTENTS READ INTO A BUFFER.  THE FILE FDB
;IS ALSO PUT IN FDBBLK.
;ON ENTRY:	STACK -1 (AFTER PUSHJ) CONTAINS FILE GROUP JFN
;		A = STRING POINTER TO BUFFER AREA
;
;RETURNS	+1  FILE ONLY HALF BAKED (1ST WRITE NOT COMPLETE)
;		+2  FAILURE IN ONE OR MORE CHECKS
;		+3  OK, BUT THE USER IS NOT A WHEEL
;		+4  OK, AND THE USER IS A WHEEL

CHKFIL:	PUSH	P,A			;SAVE BUFFER PTR AND WKG AC'S
	PUSH	P,B
	PUSH	P,C

	SETZM	QENT			;CLEAR BUFFER AREA
	MOVE	A,[QENT,,QENT+1]
	BLT	A,QENT+QESIZE-1

	HRRZ	A,-4(P)			;GET THE FILE JFN
	MOVSI	B,25			;GET WHOLE FDB
	MOVEI	C,FDBBLK		;IN FDBBLK
	GTFDB
	MOVE	B,FDBBLK+1		;EXAMINE FILE STATUS
	TLNE	B,(1B4)			;1ST WRITE DONE?
	JRST	CHKFRT			;NO, RETURN +1
	AOS	-3(P)			;YES, RETURN +2 AT LEAST
	LDB	B,[POINT 6,FDBBLK+11,11]	;GET BYTE SIZE
	CAIE	B,^D36			;36 BIT?
	JRST	[HRROI	B,[ASCIZ /BYTE SIZE ERROR ON /]
		 JRST	BUGCSH]
	MOVE	B,FDBBLK+12		;GET BYTE COUNT
	CAIE	B,QESIZE		;IS IT QESIZE
	JRST	[HRROI	B,[ASCIZ /SIZE ERROR ON /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG TO CRASH FILE

	MOVE	B,[44B5!1B19]		;OPEN 36 BIT, READ
	QOPENF
	JRST	[HRROI	B,[ASCIZ /ERROR OPENING /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG ON CRASH FILE

	JRST	[HRROI	B,[ASCIZ /TIME OUT OPENING /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG ON CRASH FILE

	MOVE	B,-2(P)			;OK, QUICK GET BUFFER POINTER
	MOVNI	C,QESIZE		;AND READ QESIZE WORDS
	SIN

	HLRZ	A,FDBBLK+6		;GET LAST WRITER
	HRRZ	B,-2(P)			;GET BUFFER ADDRESS
	CAME	A,USRDIR(B)		;ARE DIRECTORIES THE SAME?
	JRST	[HRROI	B,[ASCIZ /AUTHOR INCONSISTENCY ON /]
		 JRST	BUGCSH]		;OUTPUT BUG MSG ON CRASH FILE

	AOS	-3(P)			;EVERYTHING CHECKS - RETURN +3
					;AT LEAST
	MOVEI	B,DIRBLK		;FETCH DIRECTORY PRIVILEGES
	MOVEI	C,0			;NO NEED FOR PASSWORD
	GTDIR
	HRRZ	A,DIRBLK+3		;STRIP PRIVILEGES
	TRNE	A,1B18!1B19		;IS HE WHEEL OR OPERATOR?
	AOS	-3(P)			;YES, RETURN +4

CHKFRT:	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN

;TACK ON TAIL OF MESSAGE AND SEND TO CRASH FILE
BUGCSH:	MOVE	A,-4(P)			;GET FILE JFN
	HRROI	C,[ASCIZ / - FILE DELETED
/]
	PUSHJ	P,BUGFIL		;ENTER ERROR IN CRASH FILE

	JRST	CHKFRT			;RETURN +1




;ROUTINE TO CLOSE A JOB, DJOB, OR CJOB FILE IF OPEN, DELETE IT, AND
;GET THE NEXT JFN OF THE GROUP IF ANY.
;ON ENTRY:	STACK-1 = GROUP JFN (AFTER PUSHJ)
;		A =  0  => DON'T DELETE FILE
;		    -1  => DELETE IT
;
;RETURNS	+1 IF NO MORE FILES (JFN RELEASED)
;		+2 FOUND ANOTHER FILE

NXTFIL:	PUSH	P,A			;SAVE DELETE SWITCH, WORKING AC'S
	PUSH	P,B

	HRRZ	A,-3(P)			;GET FILE JFN
	GTSTS				;AND ITS STATUS
	TLO	A,(1B0)			;FLAG SO DON'T RELEASE JFN LATER
	TLNN	B,(1B0)			;SKIP IF OPEN
	JRST	FLCLSD			;NOT OPEN - JUST DELETE IT
	CLOSF				;CLOSE FILE
	BUG	(<NXTFIL: ERROR CLOSING FILE>)

FLCLSD:	MOVE	B,-1(P)			;GET DELETE SWITCH
	JUMPE	B,DNTDEL		;IF 0, DON'T DELETE IT
	DELF				;-1, DELETE FILE
	BUG	(<NXTFIL: ERROR DELETING FILE>)

DNTDEL:	MOVE	A,-3(P)			;GET GROUP JFN
	GNJFN
	JRST	NXTRLJ			;NO MORE FILES - RELEASE JFN
	AOS	-2(P)			;ANOTHER FOUND - RETURN +2

NXTRET:	POP	P,B			;RECOVER AC'S
	POP	P,A

	POPJ	P,			;RETURN

NXTRLJ:	HRRZ	A,-3(P)			;GET JFN
	GTSTS				;AND ITS STATUS
	TLNN	B,(1B10)		;IS JFN ASSIGNED
	JRST	NXTRET			;NO - RETURN +1
	RLJFN				;YES, RELEASE IT
	BUG	(<NXTFIL: ERROR RELEASING JFN>)
	JRST	NXTRET			;RETURN +1


; The following routine puts a potential queue entry in the trash file
; because it has some defect (wrong size, author disagreement, job number
; out of range, etc.  It also attempts to message the owner as well as make
; a DAYFILE entry.  Expect QENT to be set up upon entry.

PTRASH:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C

	MOVSI	A,(1B17)		;SET UP TRASH Q FOR BAD ENTRIES
	HRROI	B,TQNAME
	GTJFN
	JRST	TRASHE			;ERROR - GO LOOK AT IT
	MOVEM	A,TRASHQ#
	MOVE	B,[44B5+1B22]		;OPEN 36 BIT AND APPEND
	QOPENF
	BUG	(<PTRASH: ERROR OPENING TRASH Q>)
	BUG	(<PTRASH: TIME-OUT ERROR OPENING TRASH Q>)

	MOVE	A,TRASHQ		;MAKE TRASH Q ENTRY
	MOVE	B,[POINT 36,QENT]	;POINT TO IT
	MOVNI	C,QESIZE		;SIZE OF IT
	SOUT				;PUT IT OUT

	MOVE	A,TRASHQ		;CLOSE OUT TRASH Q
	CLOSF
	BUG	(<PTRASH: ERROR CLOSING TRASH Q>)

	MOVE	A,[-QESIZE,,QENT]	;CHECK IF WHOLE ENTRY 0
PTRSH0:	SKIPE	0(A)
	JRST	PTRSH1			;OOPS, SEND MESSAGES
	AOBJN	A,PTRSH0
	JRST	PTRSH2			;ALL 0, JUST GO AWAY

PTRSH1:	HRROI	B,[ASCIZ / REJECTED AS INVALID ON /]
	HRROI	C,[ASCIZ /
   JOB REJECTED BECAUSE OF SUBMIT SUBFIELD ERROR, SEE SYSTEMS STAFF/]
	PUSHJ	P,WINFRM		;GIVE THE BAD NEWS

PTRSH2:	POP	P,C			;OK, RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;AND RETURN TO CALLER


; Here we got a GTJFN error on the trash Q.  See if we can create a
; new one.
TRASHE:	CAIL	A,GJFX18		;IF ERROR BETWEEN NO SUCH NAME
	CAILE	A,GJFX21		;AND JUST EXPUNGED, TRY A NEW ONE
	BUG	(<PTRASH: GTJFN ERROR ON TRASH Q>)
	MOVSI	A,(1B0+1B17)
	JRST	PTRASH+1


;ROUTINE TO OUTPUT STATUS OF EXISTING INFERIOR FORKS
;ON ENTRY:	AC 1  = JFN OF OUTPUT FILE OR FILE NAME POINTER
;		   2  =  0 => DO NOT FREEZE FORKS
;			-1 => FREEZE FORKS AND FORCE THEM TO SAVE THEIR
;				AC'S IN PRIVATE CSHACS.  IN THIS MODE,
;				INFSTO RETURNS NOINT.

INFSTO:	PUSH	P,C			;SAVE AC'S TO BE USED
	PUSH	P,D
	PUSH	P,E
	PUSH	P,F

	PUSH	P,A			;SAVE OUTPUT JFN
	PUSH	P,B			;SAVE FREEZE FLAG

	HRROI	A,DAYBUF		;FIRST PUT OUT HEADER TO DAYBUF
	HRROI	B,[ASCIZ /
**BATCON STATUS:  /]
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /RUNNING    /]
	SKIPE	JOBHLT
	HRROI	B,[ASCIZ /HALTED    /]
	SOUT
	SETO	B,			;ADD DATE/TIME STAMP
	MOVSI	C,045000
	ODTIM

	HRROI	B,[ASCIZ /
  ENTRY SET FOR /]
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /ALL USERS
/]
	SKIPL	ENTFLG
	HRROI	B,[ASCIZ /NO USERS
/]
	SKIPLE	ENTFLG
	JRST	[MOVEI	B,"<"
		 BOUT
		 MOVE	B,ENTFLG
		 DIRST			;PRINT DIRECTORY NAME
		 JFCL			;IGNORE ERROR
		 HRROI	B,[ASCIZ />
/]
		 JRST	.+1]
	SOUT
	PUSH	P,A			;SAVE DAYBUF POINTER

	NOINT				;MAKE SURE NOTHING DISAPPEARS WHILE
					;WE ARE PLAYING
	MOVE	E,[IOWD MAXFK,2]	;SCAN ALL INFERIOR FORKS
	SETZ	F,			;COUNT FORKS OUTPUT
INFSTL:	MOVEI	A,400000(E)		;FORK HANDLE
	RFSTS				;GET FORK STATUS
	HLRE	A,A			;SET UP ACTUAL STATUS TO CHECK FKSTAT
	SETO	B,			;AND JBSTAT CONSISTENCY WITH STATUS
	CAME	A,B			;SYSTEM THINKS FORK THERE?
	JRST	INFST2			;YES - CHECK FKSTAT
	CAME	B,FKSTAT(E)		;NO - DOES FKSTAT
	BUG	(<INFSTO: FKSTAT THINKS NONEXISTENT FORK EXISTS>)	;YES
	JRST	UNASS			;OK - NOT THERE SO CHECK NEXT ONE

INFST2:	CAMN	B,FKSTAT(E)		;SYSTEM THINKS ITS THERE, DO WE?
	BUG	(<INFSTO: FKSTAT THINKS RUNNING FORK DOESN'T EXIST>)	;NO
	PUSH	P,A			;OK, THEY AGREE.  SAVE REAL STATUS
	HRRZ	A,FKSTAT(E)		;GET THE JOB NUMBER
	HRRZ	B,JBSTAT(A)		;AND THE RECORDED FORK HANDLE
	CAIE	B,400000(E)		;IS IT THIS ONE?
	BUG	(<INFSTO: JBSTAT FRK HANDLE INCONSISTENT WITH FKSTAT JOB #>)	;NOPE
	PUSHJ	P,JOBSIT		;NOW CHECK REST OF STATUS BITS
	JFCL				;OOPS, NOT EVEN IN JBSTAT
	BUG	(<INFSTO: JBSTAT DOESN'T KNOW ABOUT RUNNING JOB>)
	BUG	(<INFSTO: JBSTAT THINKS RUNNING JOB IS HALTED>)
	JRST	INFST3			;JBSTAT SAYS FROZEN - IS IT?
	JFCL				;JBSTAT SAYS MELTED - IS IT?

	POP	P,A			;RECOVER ACTUAL STATUS
	TRNN	A,1B18			;SYSTEM SAYS MELTED?
	JRST	INFST4			;YES - GO ON
	BUG	(<INFSTO: JBSTAT THINKS FROZEN FORK IS MELTED>)

INFST3:	POP	P,A			;RECOVER ACTUAL STATUS
	TRNE	A,1B18			;SYSTEM SAYS FROZEN?
	JRST	INFST4			;YES - GO ON
	BUG	(<INFSTO: JBSTAT THINKS MELTED FORK IS FROZEN>)

INFST4:	MOVEI	A,400000(E)		;NOW ITS FOR REAL - GET FORK HANDLE
	SKIPE	-1(P)			;SHOULD WE FREEZE IT?
	FFORK				;YES
	RFSTS				;IN ANY CASE GET STATUS
	MOVE	D,B			;SAVE PC
	HLRZ	A,A			;GET LEFT HALF OF STATUS
	CAIN	A,-1			;UNASSIGNED ?
	BUG	(<INFSTO: FORK DISAPPEARED FROM UNDER US>)

	HRRZ	C,FKSTAT(E)		;GET JOB STATUS AND SET FORK STATUS TO
	MOVE	C,JBSTAT(C)		;TO SHOW PRIOR FROZEN/MELTED STATE
	TRZ	A,1B18			;CLEAR FROZEN BIT IN SYSTEM STATUS
	TLNE	C,(FFREEZ)		;WAS IT REALLY BE FROZEN?
	TRO	A,1B18			;YES - SET IT
	HRLM	A,FKSTAT(E)		;SAVE CURRENT STATUS IN FORK TABLE
	MOVEM	D,FRKPCS(E)		;AND PC IN PC TABLE.
					;NOTE - IF INPUT REQUEST SAID FREEZE
					;THE FORK, IT IS NOW FROZEN - TEMPORARILLY.
					;THE FORK STATUS BITS SHOW IT AS IT WAS
					;THOUGH SO THAT IT CAN BE RESUMED LATER
					;IF APPROPRIATE.

	SKIPL	-1(P)			;SHOULD WE FORCE AC'S TO BE SAVED?
	JRST	NOFRZ2			;NO - JUST PRINT RESULTS

	TRZ	A,1B18			;FORGET FROZEN BIT
	CAIE	A,2			;WAS THE FORK TERMINATED?
	CAIN	A,3
	JRST	NOFRZ2			;YES, DON'T TRY TO GET AC'S
	MOVEI	A,400000(E)		;NO, THEN GET THEM
	MOVSI	B,(1B4)			;INTERRUPT CHANNEL 4
	IIC
	AOSG	ACSDON			;SET FLAG SO KNOW WHEN AC'S SAVED:
					; ACSDON > 0 => SAVE AC'S REQ PENDING
					;	 = 0 => IDLE STATE
					;	 < 0 => REQUEST SATISFIED
	BUG	(<INFSTO: TRYING TO SAVE AC'S BEFORE PREVIOUS REQUEST DONE>)
	RFORK				;RESUME THE FORK TO GET THE INTERRUPT
					;NOTE, THE FORK WILL SET ACSDON = -1
					;WHEN THE AC'S ARE SAVED AND WILL
					;WAIT UNTIL ACSDON GEQ 0 BEFORE
					;RESUMING.

NOFRZ0:	SKIPG	ACSDON			;ARE THE AC'S SAVED YET?
	JRST	NOFRZ1			;YES - GO ON
	MOVEI	A,400000(E)		;NO - HAS THE FORK HALTED?
	RFSTS
	HLRZ	A,A			;STATUS IN RIGHT HALF
	TRZ	A,1B18			;CLEAR FROZEN BIT
	CAIE	A,2
	CAIN	A,3
	JRST	UNASS			;MISSED IT - GO ON
	MOVEI	A,^D5000		;WAIT A BIT
	DISMS
	JRST	NOFRZ0			;GO LOOK AGAIN

NOFRZ1:	MOVEI	A,400000(E)		;FORK HANDLE
	FFORK				;REFREEZE IT
	AOSE	ACSDON			;CLEAR FLAG AND PRINT RESULTS
	BUG	(<INFSTO: INVALID ACSDON FLAG AFTER AC'S SAVED>)

NOFRZ2:	POP	P,A			;GET OUTPUT BUFFER POINTER
	SKIPG	F			;IS THIS THE FIRST PRINTABLE ONE
	JRST	[HRROI	B,[ASCIZ /
  FORK/]
		 SETZ	C,
		 SOUT
		 MOVE	C,[XWD 120002,10]
		 JRST	.+2]
	MOVE	C,[XWD 120010,10]
	HRRZ	B,E			;OUTPUT FORK NUMBER
	NOUT
	JFCL
	MOVEI	B," "			;SPACE OVER
	BOUT
	BOUT

	HLRZ	C,FKSTAT(E)		;RECOVER FORK STATUS BITS
	TRZ	C,1B18			;IGNORE FROZEN BIT FOR NOW
	MOVE	B,FST(C)		;POINTER TO DESCRIPTOR STRING
	SETZ	C,
	SOUT				;OUTPUT FORK RUN STATUS
	HRROI	B,[ASCIZ /(FROZEN) /]
	SKIPL	FKSTAT(E)		;SKIP IF FROZEN
	HRROI	B,[ASCIZ /(MELTED) /]
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /AT /]
	SOUT
	HRRZ	B,D			;RETRIEVE PC (ADDRESS PART ONLY)
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,CRLF			;DO A CRLF
	SETZ	C,
	SOUT
	PUSH	P,A			;SAVE BUFFER POINTER AGAIN
	AOJ	F,			;BUMP OUTPUT COUNT
UNASS:	AOBJN	E,INFSTL
	JUMPG	F,INFRET		;IF ANY FORKS DESCRIBED, RETURN NOW

	MOVE	A,0(P)			;NONE - SPECIAL MESSAGE.
	HRROI	B,[ASCIZ /
  NO ACTIVE FORKS
/]
	SETZ	C,
	SOUT
	MOVEM	A,0(P)			;UPDATE STRING PTR ALSO

INFRET:	POP	P,A
	HRROI	B,CRLF			;AND FINAL CRLF
	SETZ	C,
	SOUT				;FINAL CRLF
	HRROI	B,DAYBUF		;SET UP TO REALLY OUTPUT IT
	SKIPG	A,-1(P)			;GET OUT SPEC AND TEST IF PTR
	JRST	[PUSHJ	P,FILPRF	;YES - STICK IN FRONT OF FILE
		 JRST	INFRT0]
	SETZ	C,
	SOUT				;NO - JUST SEND IT TO THE JFN
	SETO	A,			;AND UNMAP THE BUFFER PAGE
	MOVE	B,[400000,,DAYBUF/1000]
	PMAP

INFRT0:	POP	P,B			;RECOVER JFN AND FLAG
	POP	P,A

	POP	P,F			;RESTORE AC'S
	POP	P,E
	POP	P,D
	POP	P,C

	JUMPL	B,INFRT1		;IF WE HAVE FROZEN THE FORKS, RETURN
					;NOINT
	OKINT				;OTHERWISE, TURN THE INTERRUPT
					;SYSTEM BACK ON

INFRT1:	POPJ	P,			;RETURN

;	ROUTINE TO TEST WHETHER BATCON CAN PROCEED SCHEDULING JOBS
;	IT CHECKS TO BE SURE TIME IS SET, ENTFLG = -1, DBUGSW NE 2, AND
;	THAT AN IMPENDING HALT IS NOT SET
;
;	RETURNS	+1   IF TIME, ENTFLG, OR DBUGSW SAYS NO
;		+2   IF HALT PREVENTS PROCEEDING
;		+3   IF OK TO GO

PROCED:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D

	GTAD				;CHECK TO SEE IF TIME IS SET
	CAMN	A,[-1]
	JRST	PRORT1			;NOPE, RETURN +1

IFE IMSSS+SUMEX,<
	HRRZ	A,SYSENT		;CHECK ENTFLG
	GETAB
	BUG	(<PROCED: GETAB ERROR ON ENTFLG TABLE>)
	SKIPL	A
	JRST	PRORT1			;NOPE, USERS RESTRICTED
	>	;END SUMEX CONDITIONAL

	HRRZ	A,SYSDBG		;CHECK DBUGSW
	GETAB
	BUG	(<PROCED: GETAB ERROR ON DBUGSW TABLE>)
	CAIN	A,2
	JRST	PRORT1			;NOPE, DEBUGGING GOING ON

	HRRZ	A,SYSTAT		;NOW CHECK FOR IMPENDING HALT
	HRLI	A,27			;ENTRY 27
	GETAB
	BUG	(<PROCED: GETAB ERROR ON SYSTAT TABLE>)
	HLRZ	C,A			;HALT DATE IN AC C
	HRRZ	D,A			;HALT TIME IN AC D
	GTAD
	HRRZ	B,A			;CURRENT TIME IN AC B
	HLRZ	A,A			;CURRENT DATE IN AC A
	SUB	C,A			;COMPUTE DIFFERENCE IN TIMES
	SUB	D,B
	IMULI	C,^D24*^D3600
	ADD	C,D
	MOVM	C,C			;AND TAKE MAGNITUDE

	CAIGE	C,IMPHLT		;LESS THAN THRESHOLD?
	JRST	PRORT0			;YES, RETURN +2

	AOS	-4(P)			;DO SKIPS FOR RETURNS
PRORT0:	AOS	-4(P)
PRORT1:	POP	P,D			;RESTORE AC'S
	POP	P,C
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER

;THIS ROUTINE CLEARS OUT ANY RUNNING JOBS FROM BATCON AND SETS THE
;ENTRY FLAG TO 0 (NO USERS).  ON ENTRY AC 1 CONTAINS A BIT LOCATED AT
;THE CHANNEL TO INTERRUPT LOWER FORK RUNNING.  CURRENTLY
;	CH 3	SYSTEM INDUCED SUICIDE
;	CH 5	IMPENDING HALT IN SYSTEM

CLRBAT:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C

	SETZM	ENTFLG			;ZERO ENTRY FLAG
	MOVE	C,[IOWD MAXFK,2]	;NOW LOOK AT ALL FORKS - STOP ANY RUNNING
.CLER0:	NOINT				;NO INTERRUPTS WHILE WORKING ON THEM
	SETO	A,
	CAMN	A,FKSTAT(C)		;IS THIS ONE THERE?
	JRST	.CLER3			;NO - LOOK AT THE NEXT ONE

	HRRZ	A,FKSTAT(C)		;YES, GET THE JOB NUMBER
	PUSHJ	P,JOBSIT		;AND DECODE STATUS
	BUG	(<.CLEAR: NO APPARENT Q ENTRY FOR FORK IN PROGRESS>)
	BUG	(<.CLEAR: FORK EXISTS FOR JOB NOT STARTED>)
	BUG	(<.CLEAR: FORK STILL EXISTS FOR HALTED JOB>)
	JRST	.CLER1			;FORK IS FROZEN - THAW IT
	JRST	.CLER2			;FORK MELTED - GO KILL IT

.CLER1:	MOVEI	A,400000(C)		;GET FORK HANDLE
	RFORK				;AND THAW IT
	HRRZ	A,FKSTAT(C)		;CLEAR FROZEN BIT FOR THIS JOB NUMBER
	MOVSI	B,(FFREEZ)
	ANDCAM	B,JBSTAT(A)

.CLER2:	HRRZ	A,FKSTAT(C)		;GET JOB # FOR THIS GUY AND
	MOVE	B,-2(P)			;SET UP INTERRUPT CHANNEL AND
	PUSHJ	P,FRCHLT		;GO FORCE HALT THIS FORK
	MOVSI	B,(FRESET+FINQUE)	;REQUEST RESET FOR JOB SO IT WILL
	MOVEM	B,JBSTAT(A)		;RUN AGAIN LATER
	SETOM	RUNQCP			;AND MAKE SURE QCOPY RUNS

.CLER3:	AOBJN	C,.CLER0		;LOOK AT THEM ALL

	SETZM	FLNMSW			;ZERO FILE NAME SW FOR DAY ENTRY
	HRROI	B,JOBCTL		;NOW POST DAY FILE MESSAGE
	HRROI	C,[ASCIZ / BATCON CLEARED AND ENTFLG=0 ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER



IFE FDBSEQ,<

; The following routine uses the job sequence lock file thawed and updates
; the current maximum job number and the bit table of jobs in use.
WRSQLK:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D

	SKIPLE	SEQJFN			;HAVE WE ALREADY GOT A FILE?
	JRST	GETLOK			;YES, GO TRY FOR THE LOCK
	SKIPE	SEQJFN			;BETTER BE JUST STARTING
	BUG	(<WRSQLK: JOB SEQ JFN ERROR STATE ON ENTRY>,TRYNGT)

	MOVSI	A,(1B17)		;NO, TRY FOR LATEST VERSION OF
GETSEQ:	HRROI	B,SEQLOK		;THE JOB-SEQUENCE FILE
	GTJFN
	BUG	(<WRSQKL: GTJFN ERROR ON JOB SEQ FILE>,TRYNGT)
	PUSH	P,A			;SAVE THE JFN
	MOVE	B,[44B5+1B19+1B20]	;OPEN IT 36 BIT, READ, WRITE
	SKIPL	SEQJFN			;AND IF NO ERROR,
	TRO	B,1B25			;MAKE IT THAWED
	OPENF
	BUG	(<WRSQLK: ERROR OPENING JOB SEQ FILE>,SQOPER)

	SKIPL	SEQJFN			;OK GOOD OPEN, IF JUST STARTING,
	JRST	SQMAPG			;JUST MAP THE PAGE
	SETOM	JBSQLK			;OTHERWISE, SET UP A NEW JOB SEQ FILE
	SKIPLE	A,MXJBNO		;USE THE BEST GUESS FOR MAX JOB
	CAILE	A,NQJBS			;NO, IF IN RANGE
	MOVEI	A,1			;OTHERWISE, RESET IT
	MOVEM	A,FMXJBN
	MOVE	A,[JBBITS,,FJBBIT]	;COPY THE CURRENT BIT TABLE
	BLT	A,FJBBIT+NJBWRD-1
	MOVE	A,0(P)			;RECOVER THE JFN
	MOVE	B,[POINT 36,JBSQLK]
	MOVNI	C,NJBWRD+2
	SOUT				;AND WRITE A GOOD FILE
	CLOSF				;CLOSE IT TO MAKE IT REAL
	BUG	(<WRSQLK: CLOSF ERROR INITIALIZING JOB SEQ FILE>,SQOPER)
	POP	P,A			;CLEAR JFN FROM STACK
	SETZM	SEQJFN			;MAKE BELIEVE JUST STARTING
	MOVSI	A,(1B17)		;LATEST FILE AND ALL
	JRST	GETSEQ			;AND TRY TO GET IT ALL OVER AGAIN

SQMAPG:	HRLZ	A,0(P)			;SET UP TO MAP PAGE 0
	MOVE	B,[400000,,SEQPAG]	;INTO SEQPAG OF THIS FILE
	MOVSI	C,(1B2+1B3)		;READ AND WRITE ACCESS
	PMAP

	POP	P,A			;GET THE JFN BACK
	MOVEM	A,SEQJFN		;OK, SO FAR SO GOOD - TRY FOR LOCK

GETLOK:	MOVEI	C,^D20			;WAIT 20 SECONDS
TRYAGN:	AOSN	JBSQLK			;CAN WE HAVE IT?
	JRST	GOTLOK			;YUP, SO CARRY ON
	MOVEI	A,^D1000		;NOT NOW, WAIT A SEC
	DISMS
	SOJGE	C,TRYAGN		;NOW TRY IT AGAIN

	BUG	(<WRSQLK: TIME-OUT TRYING FOR JOB SEQ LOCK>,FALLOK)
FALLOK:	SETO	A,			;UNMAP THAT PAGE THEN
	MOVE	B,[400000,,SEQPAG]
	SETZ	C,
	PMAP
	MOVE	A,SEQJFN		;CLOSE THE FILE
	CLOSF
	BUG	(<WRSQLK: CLOSF ERROR ON JOB SEQ FILE>,TRYNGT)

TRYNGT:	SETOM	SEQJFN			;FLAG JFN AS TROUBLE
	MOVSI	A,(1B0+1B17)		;TRY FOR NEW VERSION
	JRST	GETSEQ

; OPENF failure - probably someone opened it frozen ... make a new one
SQOPER:	POP	P,A			;RELEASE OLD JFN
	RLJFN
	BUG	(<WRSQLK: RLJFN ERROR ON JOB LOCK FILE>,.+1)
	JRST	TRYNGT			;AND TRY ANOTHER ONE

; Here we got the lock, check the file parameters and check out the
; JOB SEQ file version of the world against our bit table and correct
; any differences - we are right of course.

GOTLOK:	MOVE	A,SEQJFN		;MAKE SURE THE BYTE SIZE IS RIGHT
	MOVE	B,[1,,11]		;ADDRESS BYTE SIZE WORD
	MOVEI	C,C			;STICK IT IN AC C
	GTFDB
	LDB	B,[POINT 6,C,11]	;STRIP BYTE SIZE BITS
	CAIE	B,^D36			;BETTER BE 36 BIT
	BUG	(<WRSQLK: WRONG BYTE SIZE IN JOB SEQ FILE>,FALLOK)

	MOVE	A,SEQJFN		;JFN AGAIN
	MOVE	B,[1,,12]		;ADDRESS BYTE COUNT WORD
	MOVEI	C,C			;INTO AC C
	GTFDB
	CAIE	C,2+NJBWRD		;BETTER INCLUDE LOCK, MXJBNO, AND JBBITS
	BUG	(<WRSQLK: WRONG BYTE COUNT IN JOB SEQ FILE>,FALLOK)

; Now compare the core bit table (JBBITS) against the file bit table (FJBBIT)
; noting any jobs in our table but not theirs and jobs which were in theirs
; last time but not ours (MISBIT) and still haven't shown up in ours.

	MOVSI	C,-NJBWRD		;FIRST SCAN FOR Q JOBS NOT IN THE FILE
	SETZ	B,
	PUSH	P,B			;COUNT ON STACK - IN Q BUT NOT FILE
	PUSH	P,B			;COUNT ON STACK - IN FILE AND STILL NOT IN Q
SQBCHK:	MOVE	A,FJBBIT(C)		;GET BITS IN FILE WORD
	ANDCA	A,JBBITS(C)		;LEAVE ONLY THOSE NOT IN JBBITS
	IORM	A,FJBBIT(C)		;FIX THEM UP
SQBCH0:	JFFO	A,SQBCH1		;AND COUNT THEM
	JRST	SQBCH2			;NO MORE, MOVE ON
SQBCH1:	AOS	-1(P)			;BUMP COUNT
	LSH	A,1(B)			;CLIP THE BIT JUST COUNTED
	JRST	SQBCH0			;AND LOOK FOR ANY MORE

; NOW CHECK THIS WORD FOR BITS IN FJBBIT AND NOT IN JBBITS

SQBCH2:	MOVE	A,FJBBIT(C)		;GET THE FILE VERSION OF THIS WORD
	ANDCM	A,JBBITS(C)		;LEAVE THOSE EXTRA IN THE FILE
	MOVE	B,A			;COPY THIS PATTERN
	AND	A,MISBIT(C)		;NOW STRIP ONLY THOSE HERE LAST TIME AS WELL
	ANDCAM	A,FJBBIT(C)		;CLEAR THESE - THEY'LL NEVER SHOW UP?
	ANDCM	B,MISBIT(C)		;ALSO GET THE CURRENT EXTRAS THAT WEREN'T
	MOVEM	B,MISBIT(C)		;THERE LAST TIME AND REMEMBER THEM

SQBCH3:	JFFO	A,SQBCH4		;COUNT THE CLINKERS
	JRST	SQBCH5			;NONE LEFT
SQBCH4:	AOS	0(P)			;BUMP THE SECOND COUNTER
	LSH	A,1(B)			;CLEAR THIS BIT AND
	JRST	SQBCH3			;CHECK FOR ANY MORE

SQBCH5:	AOBJN	C,SQBCHK		;AND FINALLY DO THIS TO ALL WORDS IN 
					;THE BIT TABLE

; Now make sure that the MXJBNO in the JOB SEQ file points to an empty slot.
	MOVE	A,FMXJBN		;GET CURRENT VALUE
	CAILE	A,0			;MAKE SURE IT IS IN RANGE
	CAILE	A,NQJBS
	MOVEI	A,1			;NOPE, RESET IT
	IDIVI	A,^D36			;COMPUTE BIT TABLE INDEXES
	MOVN	B,B			;AND SET UP THE BIT MASK
	MOVSI	C,(1B0)
	LSH	C,0(B)
	MOVE	B,FMXJBN		;AND THE CURRENT JOB COUNT AGAIN

SQBCH6:	TDNN	C,FJBBIT(A)		;IS THIS ONE FREE?
	JRST	SQBCH7			;YES, JUST MOVE ON
	AOJ	B,			;NO, BUMP TO NEXT JOB SLOT
	ROT	C,-1			;NEW BIT MASK
	TLNE	C,(1B0)			;IF IT WRAPPED AROUND,
	AOJ	A,			;UPDATE WORD ADDRESS
	CAILE	B,NQJBS			;DID THE JOB NUMBERS WRAP AS WELL?
	JRST	[SETZ	A,		;YES, SET UP AS START OF TABLE TO
		 MOVEI	B,1		;CONTINUE - NO JOB 0
		 MOVSI	C,(1B1)
		 JRST	.+1]
	CAME	B,FMXJBN		;HAVE WE GONE AROUND ONCE?
	JRST	SQBCH6			;NO, TRY NEXT SLOT

SQBCH7:	MOVEM	B,FMXJBN		;THIS IS OUR BEST NEXT SLOT
	SETOM	JBSQLK			;FREE UP THE TABLE WHICH SHOULD BE
					;UP TO DATE


; OK now any discrepancies are noted and fixed.  Make up any error messages
; needed.

	HRROI	A,BUGSTR		;SET UP A PLACE TO PUT THEM
	PUSH	P,A
	SKIPN	-1(P)			;ANYTHING IN THIS COUNTER?
	JRST	SQBCH8			;NO, TRY THE NEXT ONE
	MOVE	A,0(P)			;RECOVER BUFFER POINTER
	HRROI	B,[ASCIZ /
    /]
	SETZ	C,
	SOUT				;AND OUTPUT THE MESSAGE
	MOVE	B,-1(P)			;ADD ON COUNT
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ / JOB(S) IN JOB SEQ FILE WHICH NEVER SHOWED UP IN Q/]
	SETZ	C,
	SOUT
	MOVEM	A,0(P)			;UPDATE THE BUFFER POINTER

SQBCH8:	SKIPN	-2(P)			;HOW ABOUT THE OTHER COUNTER
	JRST	SQBCH9			;NOTHING, MOVE ON
	MOVE	A,0(P)			;GOT SOMETHING, PUT IT OUT
	HRROI	B,[ASCIZ /
    /]
	SETZ	C,
	SOUT
	MOVE	B,-2(P)
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ / JOB(S) IN Q BUT NOT FLAGGED IN JOB SEQ FILE/]
	SETZ	C,
	SOUT
	MOVEM	A,0(P)			;SAVE THE LATEST BUFFER PTR

SQBCH9:	POP	P,A			;CLEAR BUFFER ADDRESS
	POP	P,B			;GET ERROR COUNTS
	POP	P,C
	ADD	B,C			;IF NOTHING AT ALL
	SKIPG	B
	JRST	SQBCI0			;RETURN
	HRROI	B,DAYTRM		;ELSE FINISH THE MESSAGE
	SETZ	C,
	SOUT
	SETZM	FLNMSW			;AND WRITE A WARNING TO DAYFILE
	MOVE	A,BATDN			;FROM BATCH
	MOVEM	A,QENT+USRDIR
	SETZM	QENT+BJOBNO
	HRROI	B,DAYBRP		;DAY BURP MESSAGE
	HRROI	C,[ASCIZ / JOB SEQ FILE ERROR ON /]
	HRROI	D,BUGSTR
	PUSHJ	P,DAY

SQBCI0:	POP	P,D			;RESTORE AC'S
	POP	P,C
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER


	>		;END OF FDBSEQ CONDITIONAL

; Batcon restart code. Restarts from old or new image depending upon DBUGSW
;
; DBUGSW/	0 = Restart from the current image
;		1 = Start a new one from <SYSTEM>BATCON.SAV
;		2 = Start a new one from <BATCH>TBATCON.SAV
;

BATRST:	GTAD				;GET CURRENT DAY TO SEE IF WE
	HLRZ	A,A			;HAVE RESTARTED TOO MANY TIMES
	SKIPN	B,BRSTCT		;DO WE HAVE ANY YET?
	HRLZ	B,A			;NO, THEN SET UP TODAY'S DATE
	ADDI	B,1			;BUMP RESTART COUNT
	HRRZ	C,B			;STRIP COUNT INTO AC C
	HLRZ	B,B			;AND DAY INTO RH OF AC B
	CAME	A,B			;IS TODAY THE SAME AS THE LAST RESTART?
	JRST	[HRRZ	B,A		;NO, UPDATE CURRENT DATE/COUNTER
		 MOVEI	C,1		;TO WIPE SLATE CLEAN
		 JRST	.+1]
	CAILE	C,MBTRST		;TOO MANY RESTARTS TODAY?
	JRST	[SETOM	BRSTCT		;YES, SET BAD FLAG
		 JRST	BATRS0]		;NOW MOVE ON
	HRLM	B,BRSTCT		;NO, REASSEMBLE RESTART DATE/COUNT
	HRRM	C,BRSTCT

BATRS0:	HRROI	A,BUGSTR		;SET UP RESTART MESSAGE
	HRROI	B,[ASCIZ /
**BATCON RELOADING ON /]
	SKIPG	DBUGSW
	HRROI	B,[ASCIZ /
**BATCON RESTARTING ON /]
	SKIPG	BRSTCT
	HRROI	B,[ASCIZ /
**BATCON HALTING ON /]
	SETZ	C,
	SOUT
	SETO	B,			;ADD DATE STAMP
	MOVSI	C,045000
	ODTIM
	HRROI	B,CRLF			;ADD <CRLF>'S
	SETZ	C,
	SOUT
	HRROI	B,CRLF
	SOUT
	PUSH	P,A			;SAVE BUFFER POINTER FOR LATER

	MOVEI	A,101			;SEND MESSAGE TO TTY
	HRROI	B,BUGSTR
	SETZ	C,
	SOUT

	POP	P,A			;RECOVER LAST BUFFER POINTER
	SKIPL	RSTORG			;WAS THIS RESTART FROM A CRASH?
	JRST	BATRS1			;NO, THEN DON'T LOG IT IN CRASH FILE
	HRROI	A,CRASH			;REAL CRASH - PUT MESSAGE IN
	HRROI	B,BUGSTR		;CRASH FILE
	PUSHJ	P,FILPRF

BATRS1:	SKIPL	BRSTCT			;TOO MANY RESTARTS?
	JRST	BATCLN			;NO, TRY RELOAD/RESTART
	SETZM	FLNMSW			;YES, ZERO FILE NAME SW
	MOVE	A,BATDN			;FAKE BATCH SOURCE AND 0 JOB
	MOVEM	A,QENT+USRDIR
	SETZM	QENT+BJOBNO
	HRROI	B,DAYOOP		;PUT OUT OOPS HEADER
	HRROI	C,[ASCIZ / HALTING - TOO MANY RESTARTS ON /]
	HRROI	D,DAYTRM
	PUSHJ	P,DAY			;PUT NOTE IN DAYFILE
	HALTF				;THEN STOP DEAD
	JRST	.-1			;NO CONTINUES FROM HERE

BATCLN:	RESET				;SET THE WORLD RIGHT
	SETO	A,			;RELEASE ALL PTY'S IN USE
	REPTY
	HALTF				;BAD NEWS - NOT MUCH WE CAN DO
					;ABOUT THIS ERROR!
	SKIPG	DBUGSW			;GET THE SWITCH, DO WE RELOAD?
	JRST 	START			;NO, JUST GO BACK AND PASS GO
	MOVSI	1,(1B17)		;YES, FIND BATCON.SAV
	HRROI	B,BATSAV
	GTJFN
	HALTF				;SHIT, CAN'T FIND IT
	HRRM	1,BATJFN		;SAVE IT FOR LATER
	MOVE	A,BRSTCT		;SAVE CURRENT RESTART DATE/COUNT
	MOVEM	A,REGCDE		;IN AC 0 TO TRANSFER IT

	MOVSI	17,REGCDE		;MOVE THE RELOAD CODE
	BLT	17,17			;TO THE REGISTERS
	JRST REGSRT-REGCDE		;AND DO IT

REGCDE:
	0				;0--BATCH RESTART COUNT
	-1				;1--FLAG TO UNMAP PAGES
	XWD 400000,0			;2--THIS FORK & PAGE NUMBER
	0				;3--
	IOWD ^D512,1			;4--COUNTER FOR ALL PAGES
REGSRT:	HRR	B,D			;5--PUT PAGE NUMBER IN RH OF B
	PMAP				;6--UNMAP IT
	AOBJN	D,REGSRT-REGCDE		;7--DO THEM ALL
	MOVE	A,BATJFN-REGCDE		;10--GET NEW BATCON JFN
	GET				;11--GET THE FILE CONTENTS
	JFCL				;12--
	JFCL				;13--
	MOVEI	A,400000		;14--GET ENTRY VECTOR
	GEVEC				;15--
	JRST	0(B)			;16--GO START PROGRAM
BATJFN:	XWD 400000,0			;17--THIS FORK,,JFN OF SAVE FILE


;CONSTANT DATA AND STUFF
;BLANK LINE FOR OUTPUT TO LOG FILE
BLANKL:	EXP	5,2			;MAX LENGTH, ACTUAL LENGTH
	BYTE	(7)15,12		;CR,LF


;NAMES OF QUEUE FILE AND QUEUE WORK FILE
	IFE	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCH.QUEUE;P777740/
TMPNAM:	ASCIZ	/<BATCH>TEMP-TO-RENAM.TO-BE-QUEUE;P770000;1/
JBNAMS:	ASCIZ	/<BATCH>JOB.*;*/	;MASK TO LOOK FOR JOBS WITH
DJBNMS:	ASCIZ	/<BATCH>DJOB.*;*/	;MASK TO LOOK FOR DESUBMIT REQUESTS
CJBNMS:	ASCIZ	/<BATCH>CJOB.*;*/	;MASK FOR CONTROL COMMANDS
BATSAV:	ASCIZ	/<SYSTEM>BATCON.SAV/	;BATCON RELOAD FILE
TQNAME:	ASCIZ	/<BATCH>BAD-ENTRY.QUEUE;P777700/
TRMNAM:	ASCIZ	/<BATCH>ABNORMAL-TERMINATION.LOG;P777700/
IFE FDBSEQ,<
SEQLOK:	ASCIZ	/<BATCH>JOB-SEQUENCE.LOCK;P777760/
	>
	>
	IFN	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCHTEST.QUEUE;P777740/
TMPNAM: ASCIZ	/<BATCH>TEST-TO-RENAM.TO-BE-TESTQUEUE;P770000;1/
JBNAMS:	ASCIZ	/<BATCH>TESTJOB.*;*/
DJBNMS:	ASCIZ	/<BATCH>TESTDJOB.*;*/
CJBNMS:	ASCIZ	/<BATCH>TESTCJOB.*;*/
BATSAV:	ASCIZ	/<BATCH>TBATCON.SAV/
TQNAME:	ASCIZ	/<BATCH>TBAD-ENTRY.QUEUE;P777700/
TRMNAM:	ASCIZ	/<BATCH>TABNORMAL-TERMINATION.LOG;P777700/
IFE FDBSEQ,<
SEQLOK:	ASCIZ	/<BATCH>TJOB-SEQUENCE.LOCK;P777760/
	>
	>

BATDIR:	ASCIZ	/BATCH/			;DIRECTORY FOR BATCH STUFF

	LIT				;GET LITERAL POOL
;DATA AND STUFF


BESTPR:	BLOCK	1			;PRIORITY OF BEST JOB TO RUN
BESTPT:	BLOCK	1			;POINT TO Q ENTRY OF BEST TO RUN
NQENT:	BLOCK	1			;NUMBER OF QUEUE ENTRYS FOUND (COUNTED)
QPNTR:	BLOCK	1			;POINTER TO CURRENT Q ENTRY IN SCAN
EOJFK:	BLOCK	1			;NUMBER OF FORK TO SEARCH QUEUE FOR
STRTFK:	BLOCK	1			;BIT SET FOR EACH FORK BEING STARTED
					;BIT IS CLEARED AFTER FORK UNDERWAY
HLTDFK:	BLOCK	1			;BIT SET FOR EACH FORK HALTED
ACTFRK:	BLOCK	1			;NUMBER OF ACTIVE INFERIOR FORKS
BATSTT:	BLOCK	1			;BATCH PROCESSOR START TIME
BRSTCT:	BLOCK	1			;BATCH RESTART DATE/COUNTER
					;  LH = DAY OF FIRST COUNT
					;  RH = # RESTARTS ON THIS DAY
NOWTIM:	BLOCK	1			;CURRENT DATE AND TIME (CMMD PROC)
RUNQCP:	BLOCK	1			;RUN QCOPY FLAG TO DELETE DESUBMITTED
					;ENTRIES FROM QUEUE
CTLTSK:	0				;CONTROL TASK COUNTER
ENTFLG:	-1				;ENTRY CONTROL: -1 (ANYONE),
					;0 (NOONE), AND >0 (DIR NUM)
JOBHLT:	0				;HALT FLAG, 0 (PROCEED) AND
					;-1 FREEZE JOBS AND DON'T ENTER MORE
FORCST:	0				;NUMBER OF REQUESTED FORCE STARTS


;FOLLOWING IS A TABLE WITH A ONE WORD ENTRY FOR EACH INFERIOR FORK.  IT IS
;INDEXED BY FORK INDEX AND CONTAINS:
;	-1		FORK DOES NOT EXIST
;	0,,-1		FORK BEING ESTABLISHED - CREATED NOW BUT NOT STARTED
;	STATUS,,JOB #	FORK RUNNING.  STATUS UPDATED WHENEVER RFSTS PERFOMED
;			JOB # IS THE JOB BEING MANAGED BY THIS FORK
;THE SUCCEEDING TABLE CONTAINS THE FORK PC FROM RFSTS

FKSTAT:	BLOCK	MAXFK+1			;TABLE OF FORK STATUS INFORMATION
					;INDEXED BY FORK INDEX.
FRKPCS:	BLOCK	MAXFK+1			;PC'S OF FORKS AT STATUS AND CRASH

;FOLLOWING IS A JOB STATUS TABLE WITH A ONE WORD ENTRY FOR EACH OF A POSSIBLE
;NQJBS JOBS.  EACH ENTRY CONTAINS:
;	0			JOB NEVER HEARD OF (NOT IN Q OR NOT INITIALIZED)
;	STATUS,,0		JOB IN QUEUE BUT NOT RUNNING WITH LOWER FORK
;	STATUS,,FORK HANDLE	JOB RUNNING UNDER LOWER FORK

;STATUS BIT	0  ON  => JOB BEING RUN (FORK HANDLE IN RIGHT SIDE)
;		   OFF => NO EXISTING FORK CONNECTED WITH THIS JOB
;		1  ON  => THERE WAS A FORK HERE - IT IS NOW HALTED
;		   OFF => IF FORK EXISTS, IT IS RUNNING
;		2  ON  => FORK EXISTS AND RUNNING FROZEN
;		   OFF => IF FORK EXISTS AND RUNNING MELTED
;		3  ON  => PURGE THIS JOB FROM QUEUE (SET AUTOMATICALLY ON
;			  INFERIOR FORK HALT)
;		4  ON  => RESET QUEUE PARAMETERS FOR THIS JOB
;		5  ON  => SET QUEUE TO DEFER EXECUTION OF THE JOB INDEFINITELY
;		6  ON  => START THIS JOB IMMEDIATELY - NO SCHEDULING
;		7  ON  => THIS JOB HAS AN ENTRY IN THE QUEUE
;		8  ON  => THIS JOB IS TO BE RESET AND REQUEUED
;
;	        9-17   => THE DIRECTORY NUMBER OF SUBMITTER

JBSTAT:	BLOCK	NQJBS+1

; Following is storage for a bit table to record the processing of
; job numbers from the Q.  A bit is set when the corresponding job
; number is encountered in the Q.  The table MISBIT records all bits
; which indicate jobs in the JOB SEQ file but which were not in the Q
; as of the last QUECOP pass.

JBBITS:	BLOCK	NJBWRD
MISBIT:	BLOCK	NJBWRD

JBNCHG:	BLOCK	MXCHG+1		;QUEUE FOR CHANGED JOB NUMBERS SO THAT JOB
JOBENT:	BLOCK	MXCHG+1		;SEQUENCE SPECS (QENT+AFTER) REFERRING TO
				;OTHER JOBS CAN BE FLAGGED FOR USER ACTION
				;   (OLD #,,NEW #) AND ENTRY TIME

;HERE IS THE DISPATCH TABLE FOR THE CONTROL CODES.  SEE PARAMS FOR
;DEFINITION OF THE MACRO

CTLDSP:	CTLLST

	PURGE	CTLLST


;	LPT: LOG FILE JFN BLOCK
LOGBLK:	600000,,0		;SET UP A LONG GTJFN
	377777,,377777		;INJFN,,OUTJFN
	0			;NO DEFAULT DEVICE
	POINT 7,[ASCIZ /PRINTER/] ;DIRECTORY
	POINT 7,[ASCIZ /LPT/]	;FILENAME
	POINT 7,FDBBLK		;EXTENSION IS HIS NAME
	EXP 0,0,0		;PROTECTION,ACCOUNT,JFN




;STORAGE BLOCKS FOR FDBS, DIRECTORY INFO, ETC.
;PRIMARALY STUFF RELATED WITH CHKACC
DIRNMF:	BLOCK	1			;DIR NUMBER FILE WE CHECK IS IN
FDBBLK:	BLOCK	25			;STORAGE FOR FDB OF FILE WE CHECK
DIRBLK:	BLOCK	20			;WE GTDIR THE DIRECTORY INFO OF
					;THE DIRECTORY THE FILE IS IN INTO
					;HERE TO CHECK ACCESS (GROUP, ETC.)

ACS:	BLOCK	20			;INFERIOR AC'S AREA
;GENERATED VARIABLES
	VAR				;GET THIS BEFORE PDL

PDL:	BLOCK	PDLL+1			;PUSH DOWN LIST

	LIT				;LITERAL POOL

ENDSUP:
SHRLOC==<<<ENDSUP-1>/1000>+2>*1000

	SUBTTL	SHARED CODE BETWEEN SUPERIOR AND INFERIORS
	LOC	SHRLOC
SHARE:
;BUG ROUTINES FOR BATCH
;BUGMSG - WRITE A BUG MESSAGE, CALLED VIA TWO PUSHJS
;USING THE BUG MACRO

BUGMSG:
BUGAGN:	AOSN	BUGLCK			;ONE BUG AT A TIME!
	JRST	BUGGO			;OK, GO TO IT
	MOVEI	A,^D15000		;WAIT 15 SEC
	DISMS
	JRST	BUGAGN			;NOW, TRY AGAIN

BUGGO:	MOVE	A,RELFRK		;IDENTIFY BUGGY FORK
	MOVEM	A,WHOBUG
	SETOM	PISYON			;GET STATUS OF PI SYSTEM
	MOVEI	A,400000
	SKPIR				;IS IT ON?
	SETZM	PISYON			;NO, CLEAR FLAG
	RCM				;GET CHANNEL ACTIVATED MASK
	MOVEM	A,PIACT
	MOVEI	A,400000
	RWM				;GET PI WAITING DATA
	MOVEM	A,PIWAIT
	MOVEM	B,PIPROG

	MOVEI	A,400000		;DISABLE INTERRUPTS
	DIR

	DMOVE	A,TMPACS		;RESTORE ACS AS THEY WERE

	MOVEM	P,CSHACS+P		;SAVE ALL AC'S
	MOVEI	P,CSHACS
	BLT	P,CSHACS+16
	MOVE	P,[IOWD PDLL,CSHPDL]	;AND SET UP CRASH PDL

	MOVE	A,BUGLOC		;SAVE PC OF CRASH POINT IN CSHPC
	SUBI	A,1
	MOVEM	A,CSHPC

	SKIPE	BUGRET			;IS IT A BAD BUG?
	JRST	BUGGO1			;NO - CARRY ON
	MOVEI	A,400000		;YES, DEACTIVATE ALL INTERRUPT
	SETO	B,			;CHANNELS EXCEPT 19
	XORI	B,1B19
	DIC

;IF THIS IS THE MAIN BATCON FORK, SAVE THE STATUS OF ANY INFERIORS

BUGGO1:	SKIPL	MYNAME			;IF MAIN BATCON, SAVE LOWER
	JRST	NOSTAT			;FORK STATUS AND FREEZE THEM
	MOVE	C,[-MAXFK,,1]		;LOOK AT ALL THE FORKS
STATLP:	SETO	A,
	CAMN	A,FKSTAT(C)		;IS THIS FORK ACTIVE?
	JRST	STTLP1			;NO - LOOK AT THE NEXT ONE
	MOVEI	A,400000(C)		;FORK HANDLE AND
	RFSTS				;GET CURRENT FROZEN/MELT STATUS
	PUSH	P,A			;SAVE IT FOR NOW
	MOVEI	A,400000(C)		;FORK HANDLE AND
	FFORK				;FREEZE IT AND
	RFSTS				;FIXED STATUS
	MOVEM	B,FRKPCS(C)		;STORE THE CURRENT FORK PC
	POP	P,B			;RECOVER REAL STATUS
	TLNN	B,(1B0)			;WAS IT REALLY FROZEN?
	TLZ	A,(1B0)			;NO - CLEAR THE BIT IN THE STATUS
	HLLM	A,FKSTAT(C)		;STORE STATUS OF THE FORK
STTLP1:	AOBJN	C,STATLP		;DO THEM ALL

; Check and see if we are to dump the image.  If this is a BUGNOTE (a
; return address is specified), don't dump things.  If this is a full
; bug, then dump per the DUMPSW setting.
;
; DUMPSW/	0 = Don't dump the image
;		1 = Dump image to file and note in message
;  *note: Dump is of fork that crashed, not all forks.


NOSTAT:	GTAD				;FIRST SAVE A DATE/TIME STAMP
	PUSH	P,A			;NO MATTER WHAT
	SKIPE	BUGRET			;IS THIS A BUGNOTE?
	JRST	DONTSV			;YES, THEN DON'T TRY TO DUMP
	SKIPL	DUMPSW			;FULL BUG, IS A DUMP REQUESTED?
	JRST	DONTSV			;NO, CARRY ON

	SKIPN	16,SYMPTR		;YES, GET THE SYMBOL POINTER
	JRST .+7			;GO AROUND SINCE THERE IS NO TABLE
	HLRE	15,16			;THE LENGTH
	MOVM	15,15			;POSITIVE LENGTH
	ADD	15,16			;LAST ADDR
	MOVES	0(16)			;TOUCH THE PAGE TO MAKE IT OURS
	ADDI	16,1000			;NEXT PAGE
	CAMG	16,15			;THE END?
	JRST .-3			;LOOP TILL WE ARE

	HRROI	A,CRASH			;PUT DUMP NOTE ON CRASH FILE
	MOVE	B,0(P)			;RETRIEVE DATE/TIME STAMP
	MOVEI	C,400000		;DO THIS FORK
	PUSHJ	P,FRKDMP		;GO DUMP IT


; Now put out a message about what has happened to the LOG TTY and to
; the CRASH file.  Also notify systems people.

DONTSV:	HRROI	A,BUGSTR		;CONSTRUCT BUG MESSAGE
	SKIPL	MYNAME			;IS IT THE MAIN PROGRAM?
	JRST	LOWFRK			;NO-GO MAKE LOWER FORK MESSAGE
	HRROI	B,[ASCIZ /
**BATCON CRASH: PC = /]			;YES-MAKE MAIN PROGRAM MESSAGE
	SKIPE	BUGRET
	HRROI	B,[ASCIZ /
**BATCON BUGNOTE: PC = /]
	SETZ	C,
	SOUT
	JRST	CMPMSG			;GO FINISH MESSAGE

LOWFRK:	HRROI	B,[ASCIZ /
**BATCON SUBFORK /]			;MAKE LOWER FORK MESSAGE
	SETZ	C,
	SOUT
	HRRZ	B,RELFRK		;ADD FORK NUMBER
	ANDI	B,777
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ / CRASH: PC = /]	;ADD REST OF MESSAGE
	SKIPE	BUGRET
	HRROI	B,[ASCIZ / BUGNOTE: PC = /]
	SETZ	C,
	SOUT

CMPMSG:	HRRZ	B,CSHPC			;FETCH PC OF BUG
	MOVEI	C,10			;OUTPUT OCTAL VALUE
	NOUT
	JFCL
	MOVEI	B," "			;ADD SOME SPACES
	BOUT
	BOUT
	POP	P,B			;RECOVER DATE AND TIME STAMP
	MOVSI	C,045000
	ODTIM
	HRROI	B,CRLF			;GET A NEW LINE
	SETZ	C,
	SOUT

	HRRO	B,BUGMAD		;FETCH ERROR STRING ADDRESS
					;AND MAKE IT A BYTE POINTER
	SETZ	C,
	SOUT
	HRROI	B,CRLF			;ADD CRLF
	SOUT
	PUSH	P,A			;SAVE BUFFER POINTER FOR NOW

	MOVEI	A,101			;OUTPUT MESSAGE TO MAIN TTY
	HRROI	B,BUGSTR
	SOUT
	HRROI	B,CRLF			;AND ONE MORE CRLF
	SOUT

;TENXER - WRITE THE TENEX ERROR STRING FOR LAST ERROR THIS FORK

TENXER:	POP	P,A			;RECOVER MESSAGE BUFFER PTR
	HRROI	B,[ASCIZ /
  TENEX ERROR: /]
	SETZ	C,
	SOUT
	HRLOI	B,400000		;LAST ERROR, THIS FORK
	ERSTR				;WRITE ERROR MESSAGE
	JFCL				;IGNORE THESE
	JFCL				;TOO LATE TO WORRY ABOUT THEM.
	HRROI	B,CRLF			;DO CRLF
	SETZ	C,
	SOUT

	SKIPE	BUGRET			;IF BUGNOTE, END OF OUTPUT
	JRST	[HRROI	B,ASTRSK
		 SETZ	C,
		 SOUT
		 JRST	TNXER1]
	HRROI	B,CRLF
	SOUT				;EXTRA CRLF

TNXER1:	HRROI	A,CRASH
	HRROI	B,BUGSTR
	PUSHJ	P,FILPRF		;NOW SEND IT ALL TO CRASH FILE


;SEND MESSAGE TO INTERESTED PEOPLE THAT BATCH PROCESSOR CRASHED

CRSSET:	SKIPG	BUGRET			;IF A FULL BUG, RIP UP ANY
	JRST	FULBUG			;SNDMSG.  IF NOT, WAIT PATIENTLY

	SKIPE	A,FORK			;IF THERE IS A SNDMSG
	RFORK				;RESUME IT
	OKINT				;REENABLE INTERRRUPTS

HAFBUG:	SKIPN	FORK			;SNDMSG THROUGH
	JRST	CRSNOT			;YES, GET ON WITH IT
	MOVEI	A,^D10000		;NO, WAIT 10 SEC
	DISMS
	SKIPL	MYNAME			;SUPERIOR FORK?
	JRST	HAFBUG			;NO, GO TRY AGAIN
	MOVEI	A,400000		;YES, CHECK FORK STATUS
	MOVEI	B,1B19
	IIC
	JRST	HAFBUG			;TRY AGAIN

FULBUG:	SKIPE	A,FORK			;IS SNDMSG RUNNING NOW
	KFORK				;YES - KILL IT
	SETOM	SNDLCK			;ALLOW SNDMSG
	SETZM	FORK

	MOVEI	A,400000		;SET UP INTERRUPT SYSTEM TO
					;BE ABLE TO DETECT SNDMSG STOP
	CIS				;CLEAR INTERRUPTS
	OKINT				;ENABLE 

CRSNOT:	SETZM	FLNMSW			;ZERO FILE NAME SWITCH

	HRROI	A,STRBUF		;COMPOSE MESSAGE
	SKIPG	BUGRET
	JRST	CRSNRT			;FULL BUG - MSG FOR NO RETURN
	HRROI	B,[ASCIZ /- CONTINUING WITH PC = /]
	SETZ	C,
	SOUT
	MOVE	B,BUGRET		;PRINT ADDRESS
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ / ON /]
	JRST	CRDOIT			;GO SEND THEM

CRSNRT:	SKIPE	MYNAME			;ARE WE THE BIG ONE
	JRST	[HRROI	B,[ASCIZ /- ATTEMPTING RELOAD ON /]	;YES
		 SKIPG	DBUGSW
		 HRROI	B,[ASCIZ /- ATTEMPTING RESTART ON /]
		 JRST	CRDOIT]

	JRST	[HRROI	B,[ASCIZ /- FORK HALTING ON /]		;NO
		 JRST	CRDOIT]

CRDOIT:	SETZ	C,
	SOUT

	HRROI	A,BUGSTR		;SET UP MSG <APPENDIX>
	HRROI	B,CRLF
	SOUT
	HRRO	B,BUGMAD		;FETCH ERROR STRING ADDRESS
					;AND MAKE IT A BYTE POINTER
	SOUT
	HRROI	B,CRLF
	SOUT
	
	MOVSI	E,-NNOT			;NUMBER OF PEOPLE TO NOTIFY
	MOVE	A,QENT+USRDIR		;SAVE REAL USER NAME FOR LATER
	PUSH	P,A

CRSLOP:	MOVE	B,CRSHLS(E)		;DIR NAME POINTER FOR SEND
	MOVEI	A,1			;POSITIVE FOR NO COMPLETION
	STDIR				;GET HIS NUMBER
	JFCL				;WRONG SYSTEM OR SOMETHING?
	MOVE	A,BATDN			;SEND TO SELF THEN
	HRRZM	A,QENT+USRDIR

	SKIPL	MYNAME			;SUPERIOR FORK?
	JRST	CRSLP0			;NO, GO DO SUBFORK MSG
	HRROI	B,[ASCIZ /BATCH PROCESSOR CRASHED /]  ;MESSAGE
	SKIPE	BUGRET			;OR IS IT A BUGNOTE?
	HRROI	B,[ASCIZ /BATCH PROCESSOR BUGNOTE /]  ;MESSAGE
	JRST	CRSLP1

CRSLP0:	HRROI	B,[ASCIZ /BATCH SUBFORK CRASHED /]  ;OK, INFERIOR MSG
	SKIPE	BUGRET			;OR IS IT A BUGNOTE?
	HRROI	B,[ASCIZ /BATCH SUBFORK BUGNOTE /]  ;OK, INFERIOR BUGNOTE

CRSLP1:	HRROI	C,STRBUF		;TAIL MESSAGE
	HRROI	D,BUGSTR		;AND THE APPENDIX
	PUSHJ	P,SEND			;SEND MESSAGE
WTMSG:	MOVEI	A,^D5000		;5 SECOND DELAY
	DISMS
	SKIPE	FORK			;MESSAGE SENT ?
	JRST	[SKIPL	MYNAME		;NOT YET, ARE WE THE SUPERIOR?
		 JRST	WTMSG		;NO, GO TRY AGAIN
		 MOVEI	A,400000	;YES, CHECK THE LOWER FORKS
		 MOVEI	B,1B19
		 IIC
		 JRST	WTMSG]
	AOBJN	E,CRSLOP		;DO THEM ALL

	POP	P,A			;RECOVER REAL USER DIRECTORY #
	MOVEM	A,QENT+USRDIR		;AND RESTORE IT

	NOINT				;DISABLE INTERRUPTS
	SKIPG	BUGRET			;IF BUG NOTE, RESTORE WORLD AND
	JRST	BFLUSH			;CARRY ON, ELSE FLUSH IT.

;HERE WE HAD ONLY A MINOR BUG, SO CLEAN UP, RESTORE THINGS, AND CARRY ON

	SKIPL	MYNAME			;IF WE ARE NOT MAIN BATCON
	JRST	BRETN2			;JUST GO BACK
	MOVE	C,[IOWD MAXFK,2]	;OTHERWISE, RESTART LOWER FORKS
BRETN0:	SETO	B,			;IS THIS ONE ACTIVE?
	CAMN	B,FKSTAT(C)
	JRST	BRETN1			;NO - LOOK AT THE NEXT ONE
	HRRZ	A,FKSTAT(C)		;YES, GET THE JOB NUMBER
	MOVSI	B,(FFREEZ)
	TDNE	B,JBSTAT(A)		;SHOULD IT STAY FROZEN?
	JRST	BRETN1			;YES, TRY THE NEXT ONE
	MOVEI	A,400000(C)		;NO, THAW IT
	RFORK
BRETN1:	AOBJN	C,BRETN0		;DO THEM ALL

BRETN2:	MOVSI	P,CSHACS		;RESTORE ALL THE AC'S
	BLT	P,P
	SETOM	WHOBUG			;OPEN LOCK
	SETOM	BUGLCK

	OKINT				;REENABLE INTERRUPTS
	JRST	@BUGRET			;AND WE ARE OFF AGAIN



BFLUSH:	SETOM	RSTORG			;SET FLAG AS COMING FROM REAL CRASH
	SKIPE	MYNAME
	JRST BATRST			;RESTART BATCON FOR TOP GUY, ELSE
	RESET				;LOWER FORK, HANG IT UP (CLEANLY)
	MOVE	A,RELFRK		;GET FORK INDEX
	ANDI	A,777
	SKIPE	A,FRKPTY(A)		;RELEASE PTY IF STILL THERE
	REPTY
	JFCL				;SOME DAYS NOTHING WORKS RIGHT

	HALTF				;STOP
	JRST	.-1			;DON'T CONTINUE

;	HANDLE UNEXPECTED INTERRUPTS

UNEX:	DEBRK


;THIS ROUTINE TRYS TO OPEN A FILE AND RETURNS +1 ON ANY FAILURE BUT BUSY.
;IF FILE IS BUSY, IT TRYS AGAIN IN 1/2 MINUTE, GIVES UP AFTER 20 TRIES.
;EVOKED BY THE 'QOPENF'MACRO (OPDEF).

.OPENF:	OPENM


DBUGSW:	DBUGFG				;see BATRST for definitions of
DUMPSW:	DUMPFG				;DBUGSW and DUMPSW

TTYJOB:	BLOCK	1			;TABLE NUMBERS FOR NAMED TABLES
JOBTTY:	BLOCK	1			;TABLE NUMBER
JOBRT:	BLOCK	1			;TABLE NUMBER
JOBNAM:	BLOCK	1			;TABLE NUMBER
SNAMES:	BLOCK	1			;TABLE NUMBER
JOBDIR:	BLOCK	1			;TABLE NUMBER
SYSENT:	BLOCK	1			;TABLE NUMBER - ENTFLG
SYSDBG:	BLOCK	1			;TABLE NUMBER - DBUGSW
SYSTAT:	BLOCK	1			;TABLE NUMBER
NJOBTB:	BLOCK	1			;NUMBER OF ENTRIES IN JOBDIR TABLE
JBDRTB:	BLOCK	NJOBS			;ARRAY FOR JOBDIR TABLE ENTRIES

WHEEL:	BLOCK	1			;NON-ZERO IF WE ARE A WHEEL
DETSW:	BLOCK	1			;NEGATIVE IF DETACHED
BATDN:	BLOCK	1			;DIRECTORY NUMBER FOR (BATCH)
JOBNO:	BLOCK	1			;JOB NUMBER OF THIS BATCON
					;SHOULD IDENTIFY WHICH BATCON
					;STARTED JOB, SO IF MULTIPLE IN
					;ONE JOB-WE MUST USE SOMETHING
					;HERE. IT IS NOT IMPORTANT THAT
					;IT BE THE JOB NUMBER
RSTORG:	BLOCK	1			;FLAG INDICATING RESTART ORIGIN
					;  0 => OPERATOR COMMAND
					; -1 => REAL BUG

QJFN:	BLOCK	1			;JFN OF THE BATCH QUEUE
CRSHJF:	BLOCK	1	       		;JFN FOR CRASH MESSAGE FILE
IFE FDBSEQ,<
SEQJFN:	BLOCK	1			;JFN FOR JOB SEQ FILE
	>

SNDLCK:	-1				;SEND MESSAGE LOCK(ONE COPY 
WHOSND:	-1				;FORK ID OF GUY SENDING MSG
BUGLCK:	-1				;BUGMSG LOCK - ONE AT A TIME
WHOBUG:	-1				;WHO IS BUGGY
DAYLCK:	-1				;DAY FILE LOCK - ONE AT A TIME
WHODAY:	-1				;WHO IS WRITING IN DAY FILE
ACSDON:	0				;SIGNAL INDICATING LOWER FORK AC'S
					;ARE SAVED AND THE FORK IS REFROZEN

ERSTRB:	BLOCK	60			;BUFFER FOR ERSTR MSG'S

CSHPDL:	BLOCK PDLL+1			;STACK FOR BUG PROCESSING

; These tables contain the PTY handles and CTL,,LOG JFN's for any active
; inferior fork.  They are indexed by fork number.

FRKPTY:	BLOCK	MAXFK+1
FRKJFN:	BLOCK	MAXFK+1

;DIRECTORY NUMBERS OF PEOPLE TO NOTIFY IF BATCH PROCESSOR CRASHES
CRSHLS:	
	CRSHUS
NNOT==.-CRSHLS				;NUMBER TO NOTIFY

;IMAGE DUMP FILE NAMES

IFE DBGFIL,<
DAYNAM:	ASCIZ	/<BATCH>DAYFILE.ENTRIES;P777700/
CRASH:	ASCIZ	/<BATCH>CRASH.MSG;P777700/	;PLACE FOR CRASH DATA
CSHBAT:	ASCIZ	/<BATCH>BATCON-DUMP./	;NAME PART OF DUMP FILES
>
IFN DBGFIL,<
DAYNAM:	ASCIZ	/<BATCH>TDAYFILE.ENTRIES;P777700/
CRASH:	ASCIZ	/<BATCH>TCRASH.MSG;P777700/
CSHBAT:	ASCIZ	/<BATCH>TBATCON-DUMP./
>

;GENERATED VARIABLES
	VAR

	LIT

ENDSHR:
NSHAR==<<<ENDSHR-SHARE>+777>/1000>	;NUMBER OF INFERIOR FORK SHARED PAGES
INFLOC==<<<ENDSHR-1>/1000>+2>*1000

	SUBTTL	INFERIOR FORK CODE
	LOC	INFLOC
;OPEN CTL FILE NOW

	IFE	FSUSER,<
INFFK:	SETZM	PTY			;TOUCH PAGE TO GET COPY
	SETZM	MYNAME			;AND SAY I'M A LITTLE GUY
IFN	MXILIN,<
	SETZM	ILINCT			;CLEAR ILLEGAL INSTRUCTION COUNT
	>	;END MXILIN CONDITIONAL
	MOVE	A,SYMPTR		;GET THE SYMBOL TABLE POINTER
	MOVEM	A,116			;AND SET IT UP FOR DDT ON A CRASH
	MOVE	P,[IOWD PDLL,IPDL]  ;SET UP STACK

	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

;SET UP INTERRUPT SYSTEM
	MOVEI	A,HMSGFK		;SET ADR OF SNDMSG HALT HANDLER
	HRRM	A,CHNTAB+^D19
	MOVEI	A,400000
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	MOVE	B,[1B1+1B3+1B4+1B5+1B10+1B11+1B15+1B19]
						;ACTIVATE CHANNELS 1,3,4,5,
						;10,11,15, AND 19:
						;  1 - FORK DESUBMITTED
						;  3 - EMERGENCY ABORT
						;  4 - SAVE AC'S AND FREEZE
						;  5 - SYSTEM HALT COMING
						; 10 - FILE EOF
						; 11 - FILE DATA ERROR
						; 15 - ILLEGAL INSTRUCTION
						; 19 - INFER FORK TERM
	AIC
	OKINT			;ENABLE INTERRUPT SYSTEM FOR THIS FORK

	MOVE	A,CTLJFN		;JFN OF CONTROL FILE
	MOVE	B,[7B5!1B19]		;7 BIT, READ
	QOPENF
	ERROR	(<ERROR OPENING CTL FILE>,ABEND)
	ERROR	(<TIME OUT OPENING CTL FILE>,ABEND)

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Tenex Batch System.  Version /]
	SETZ	C,
	SOUT

	MOVEI	B,MAJORV
	MOVE	C,[1B2+2B17+^D10]	;LEADING FILLER, 2 COL, DECIMAL
	NOUT
	JFCL
	MOVEI	B,"."
	BOUT
	MOVEI	B,MINORV
	MOVE	C,[1B3+2B17+^D10]	;LEADING ZEROS, 2 COL, DECIMAL
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - BATCH SYSTEM VERSION

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Batch job number /]
	SETZ	C,
	SOUT

	MOVE	B,QENT+BJOBNO		;JOB NUMBER
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ/ Started /]
	SETZ	C,
	SOUT
	SETOB	B,C			;CURRENT DATE AND TIME, THE WORKS
	ODTIM

	PUSHJ	P,INTMSG		;OUTPUT - JOB NUMBER AND TIME MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum log length (lines):  /]
	SETZ	C,
	SOUT
	MOVE	B,MAXLOG
	MOVEI	C,^D10
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - LOG LENGTH MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum elapsed time (minutes): /]
	SETZ	C,
	SOUT
	MOVE	B,MAXETM
	IDIVI	B,^D60000		;CONVERT MILLISECONDS TO MINUTES
	MOVEI	C,^D10
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum CPU time (seconds): /]
	SETZ	C,
	SOUT
	MOVE	B,MAXCPU
	IDIVI	B,^D1000		;CONVERT MILLISECONDS TO SECONDS
	MOVEI	C,^D10
	NOUT
	JFCL
	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Input file : /]
	SETZ	C,
	SOUT

	HRRZ	B,CTLJFN		;CTL FILE JFN
	MOVE	C,[XWD 011110,110011]
	JFNS

	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Output file : /]
	SETZ	C,
	SOUT

	HRRZ	B,LOGJFN		;LOG FILE JFN
	MOVE	C,[XWD 011110,110011]
	JFNS

	PUSHJ	P,INTMSG		;OUTPUT - OUTPUT FILE MESSAGE

	MOVE	B,QENT+USRDIR		;GET DIR TO LOGIN WITH
	>				;END NORMAL JOB STARTUP
;GET A LOGIN LINE IN CTLLIN.
DOLOGI:	MOVE	C,[ASCII /LOG /]	;COMMAND
	MOVEM	C,CTLLIN+2		;SAVE IT
;	USE CONNECTED DIR FROM B
	HRROI	A,CTLLIN+3		;POINT TO DEST
	DIRST				;GET DESTINATIN
	BUG	(<DOLOGI: Dirst failed for login line>)
	MOVEI	C," "			;BLANK FOR AFTER NAME
	IDPB	C,A			;STORE IT
	MOVE	C,A			;WHERE TO PUT PW
	MOVE	A,B			;DIR#
	MOVEI	B,USRBLK		;REST OF DIRECTORY INFORMATION
	GTDIR				;HOPE IT WORKS, OR WE DIE
	MOVE	A,C			;GET BYTE POINTER
	MOVEI	B," "			;SPACE BEFORE ACCT#
	IDPB	B,A			;STORE IT

IFE	FSUSER,<			;IN SYSTEM BATCH WE WANT THIS
	MOVE	B,QENT+USRACT		;GET ACCOUNT REQUESTED
	JUMPN	B,DOLOG2		;HE KNOWS HIS ACCOUNT STRING ***SRI-IC***
	>				;END IFN FSUSER

	IFE	STRACT,<
;THE FOLLOWING IS BECAUSE WE HAVE A DUMB ACCOUNTING
;SYSTEM THAT REQUIRES THAT A VALID ACCOUNT NUMBER BE
;GIVEN--AND REFUSES TO ACCEPT ACCOUNT NUMBER 1
IFE	IMSSS,<
	MOVEI	B,33			;ESCAPE
	IDPB	B,A			;STORE IT IN ACCOUNT FIELD
	JRST	DOLOG3			;SKIP OVER THE NOUT
	>

	MOVEI	B,^D1			;USE THIS GOOD ACCT #
DOLOG2:	MOVEI	C,^D10			;DECIMAL
	NOUT
	BUG	(<DOLOG2: Nout failed>)
	>
	IFN	STRACT,<
	ERROR	(<NO ACCOUNT STRING>,ABEND)
DOLOG2:
	HRROI	B,QENT+USRACT	;USER ACCOUNT STRING POINTER
	SETZ	C,		;ZERO BYTE TERMINATION
	SOUT			;OUTPUT ACCOUNT STRING
	>

DOLOG3:	MOVEI	B,15			;CR
	IDPB	B,A			;SAVE IT IN LINE

;KLUDGE THE LENGTH OF STRING COMPUTATION.
	MOVE	B,[POINT 7,CTLLIN+2]	;POINT TO FIRST BYTE OF STRING
	MOVEM	B,CTLLIN-1		;STORE LOC OF LINE
	SETZ	C,			;INIT VALUE
	CAMN	B,A			;THERE YET?
	JRST	.+3			;YES
	IBP	B			;NO--GET NEXT
	AOJA	C,.-3			;COUNT AND LOOP
	MOVEM	C,CTLLIN+1		;SAVE LENGTH
;START THE JOB
RUNJOB:	MOVE	A,MAXCPU		;COMPUTE 10% CPU TIME USED TRIGGER
	ADDI	A,^D5
	IDIVI	A,^D10
	CAIG	A,^D15000		;TRIGGER AT LEAST 15 CPU SEC
	MOVEI	A,^D15000
	MOVEM	A,CPUTRG

	MOVE	A,MAXLOG		;COMPUTE 10% OUTPUT USED TRIGGER
	ADDI	A,^D5
	IDIVI	A,^D10
	CAIG	A,^D50			;TRIGGER AT LEAST 50 PRINT LINES
	MOVEI	A,^D50
	MOVEM	A,LOGTRG

	PUSHJ	P,.ASPTY		;FIRST WE GET A PTY
	JRST	[MOVEI A,^D60000	;NO PTY'S OR NO LOGINS
		 DISMS			;WAIT ONE MINUTE
		 JRST RUNJOB]		;RETRY ASPTY

	MOVEI	B,JSTART
	MOVEM	B,ENDTYP		;INITIALIZE TERMINATION CAUSE
	SETZ	C,
	PUSHJ	P,WINFRM		;GO TELL THE WORLD ABOUT THE START

WAITJ:	TIME				;GET TODCLK
	MOVE	C,A			;SAVE IT
	ADDI	C,^D120000		;THIS IS WHEN WE WANT TO RETRY
	MOVE	A,PTY			;GET PTY NUMBER
	TRO	A,400000		;BE SURE TTY DESIGNATOR
	CFIBF				;CLEAR HIS INPUT
	CFOBF				;AND OUTPUT BUFFERS

;SEND A CONTROL C TO WAKE UP JOB.
	MOVE	A,PTY			;GET PTY NUMBER
	MOVEI	B,3			;GET A ^C
	PSTI
	ERROR	(<CAN'T SEND ^C TO START SUBJOB>,ABEND)	;OOPS-DIE

;WAIT FOR JOB TO START
WAITJ1:	MOVEI	A,^D1000		;WAIT 1 SECOND BEFORE CHECKING
	DISMS
	PUSHJ	P,TTYJ			;FIND LINE STATUS
	JRST	NOTASS			;TTY NOT ASSIGNED
	JRST	NOTASS			;TTY NOT ASSIGNED
	JRST WAITTM			;YES, AND JOB RUNNING - GO ON
	JRST WAITTM			;YES, AND JOB IN TTY WAIT - GO ON
NOTASS:	TIME				;GET TODCLK NOW
	CAMGE	A,C			;HAS TIME EXPIRED?
	JRST WAITJ1			;NO,GO BACK AND WAIT,TTY NOT ASSIGNED
	MOVE	A,PTY			;TOO LONG HERE, RELEASE PTY AND
	CFIBF				;START OVER
	CFOBF
	REPTY
	BUG	(<RUNJOB: Can't release PTY to retry ^C>)
GETONE:	PUSHJ	P,.ASPTY		;GO GET A NEW PTY
	JRST	[MOVEI	A,^D60000	;NO PTY'S
		 DISMS			;WAIT 1 MIN
		 JRST	GETONE]		;TRY AGAIN
	JRST WAITJ			;TRY LOGGING IN AGAIN

WAITTM:	TIME				;SET UP TIME OUT FOR GETTING
	MOVE	C,A			;@ PROMPT BACK FOR LOGIN
	ADDI	C,^D120000

;WAIT FOR THE @ FROM EXEC BEFORE LOGIN.
WAITL:	MOVE	A,PTY			;GET A CHAR
	SETZ	B,			;DON'T BLOCK FOR CHAR
	PSTO				;GET IT
	JRST	WAITL2			;DIDN'T GET ONE
	PUSH	P,B			;SAVE B
IFN IMSLOG,<
	MOVE	A,QENT+LINLAB		;SAVE THE REAL LABEL TYPE
	PUSH	P,A
	SKIPE	A			;THEN IF NOT THE OLD TYPE,
	SETOM	QENT+LINLAB		;FAKE NONE AT ALL FOR NOW
	>	;END OF IMSLOG CONDITIONAL

	PUSHJ	P,ADDLOG		;PUT ON LOG FILE

IFN IMSLOG,<
	POP	P,A			;RESTORE REAL LABEL TYPE
	MOVEM	A,QENT+LINLAB
	>	;END OF IMSLOG CONDITIONAL
	POP	P,B			;RESTORE B
	CAIE	B,"@"			;WAS IT AN @?
	JRST	WAITL			;NO-CONTINUE WAIT
	JRST	RUN			;YES-GO START RUNNING

WAITL2:	TIME				;CHECK FOR TIME OUT
	CAMLE	A,C			;HAS TIME EXPIRED
	ERROR	(<NO @ PROMPT TO LOGIN SUBJOB>,ABEND)	;YES, GO DIE
	MOVEI	A,^D1000		;NO, WAIT ONE SECOND MORE
	DISMS
	JRST	WAITL			;AND TRY AGAIN
;RUN THE JOB

RUN:	TIME
	MOVEM	A,TJOBIN		;SAVE AS TIME JOB STARTED
IFN IMSLOG,<
	MOVEM	A,LABTOD		;MAKE LIKE LABEL JUST SENT
	HRRZ	B,QENT+LINLAB		;LINES TOO
	TRZ	B,1B18
	SKIPN	B			;IF NOTHING SPECIFIED
	HRLOI	B,377777		;MAKE IT HUGE
	MOVEM	B,LABCNT
	MOVE	B,[SIXBIT /EXEC  /]	;WE ALWAYS START AS BATCON
	MOVEM	B,LABSUB
	SETZM	EXECHG			;CLEAR ENTERING EXEC FLAG
	>	;END OF IMSLOG CONDITIONAL
	ADD	A,MAXETM		;THIS IS THE TIME TO PULL THE CHAIN
	MOVEM	A,RUNTIM		;SAVE IT FOR DURING THE RUN
	MOVE	A,MAXETM		;COMPUTE 10% ELPSED TIME USED TRIGGER
	ADDI	A,^D5
	IDIVI	A,^D10
	CAIG	A,^D60000		;TRIGGER AT LEAST 60 ELAPSED SEC
	MOVEI	A,^D60000
	MOVEM	A,RUNTRG

	MOVE	A,QENT+USRDIR		;FETCH MOST RECENT LOGIN TIME
	MOVEI	B,USRBLK		;INTO USRBLK
	SETZ	C,
	GTDIR

	SETZB	D,JOBN			;ZERO JOB NUMBER AND CTL SAVED CHAR
RUN0:	PUSHJ	P,CHKOUT		;GO CHECK FOR PTY OUTPUT
	JFCL				;NO OUTPUT, KEEP GOING
	CAIN	D,15			;IS INPUT CHAR A (CR)-SKIPS FIRST TIME
	JRST RUN02			;YES,END OF LOGIN, NO MORE FOR NOW
	PUSHJ	P,RCCTL			;GET CHAR OF LOGIN SEQUENCE
	BUG	(<RUN0: Non skip return from RCCTL>) ;NO,JOB CHECK WITH LOG LINE!?
	MOVE	D,B			;SAVE IT TO KNOW WHEN TO QUIT
RUN01:	MOVE	A,PTY			;GET OUR PTY
	PSTI				;STUFF IT
	JRST [	MOVEI	A,^D100		;BUFFER FULL
		DISMS			;COME BACK IN 100MS
		JRST RUN01]		;AND TRY AGAIN
	CAIE	D,15			;JUST SEND CR?
	JRST	RUN0			;NO, GO BACK AND DO NEXT CHAR
	TIME				;YES, SET TIME OUT TRIGGER
	ADDI	A,^D240000		;TIME OUT IN 4 MINUTES
	PUSH	P,A			;STASH IT

RUN02:	MOVEI	A,^D1000		;WAIT A SEC BEFORE CHECKING
	DISMS
	TIME				;HAS TIME OUT PASSED?
	CAMLE	A,0(P)
	ERROR	(<TIME OUT WAITING FOR JOB TO LOGIN>,ABEND)	;OOPS!
	PUSHJ	P,TTYJ			;GET JOB NUMBER
	JRST	RUN0			;NONE YET
	JRST	RUN0			;NONE YET
	JFCL				;JOB SEEMS TO BE HERE
	JFCL
	TLNE	A,400000		;BE SURE REAL JOB NUMBER
	JRST	RUN0			;NOT QUITE YET
	HLRZM	A,JOBN			;ISOLATE JOB NUMBER AND PARK IT
	HRR	A,JOBDIR		;SEE IF LOGGED IN YET
	GETAB
	BUG	(<RUN02: Getab on JOBDIR failed>)
	TRNN	A,-1			;LOGGED IN?
	JRST 	RUN0			;NO, go back till we are

	POP	P,A			;OK LOGGED IN - CLEAR TIME OUT
	HRROI	A,STRBUF		;GET DIRECTORY NAME
	MOVE	B,QENT+USRDIR
	DIRST
	BUG	(<RUN: DIRST FAILED ON RESETTING LOGIN DATE>)
	HRROI	A,STRBUF		;NOW SET LAST LOGIN DATE TO
	MOVSI	B,(1B10)		;PREVIOUS VALUE
	HRRI	B,USRBLK
	SETZ	C,
	CRDIR

IFN	SKUSER,<
	TIME				;SET UP TIME-OUT FOR WAITING FOR EXEC
	ADDI	A,^D240000		;4 MIN OUGHT TO BE LONG ENOUGH
	PUSH	P,A			;SAVE IT

RUN03:	TIME				;TIMED OUT YET?
	CAMLE	A,0(P)
	ERROR	(<TIME OUT WAITING FOR JOB TO ENTER EXEC AFTER LOGIN>,ABEND)
	MOVEI	A,^D1000
	DISMS				;WAIT TILL THE EXEC SETTLES DOWN
	PUSHJ	P,CHKOUT		;GET ANY OUTPUT SO HE DOESN'T 
	JFCL				;CHOKE ON HIS OUTPUT BUFFER
	MOVE	A,PTY
	PUSHJ	P,TTYJ			;ARE WE IN TTY WAIT?
	JFCL				;NO - TTY NOT THERE NOW
	ERROR	(<TTY DISAPPEARED DURING STARTUP>,ABEND)
	JRST	RUN03			;STILL RUNNING - WAIT SOME MORE
	POP	P,A			;OK, IN TTY WAIT - CLEAR TIME OUT
	MOVE	A,JOBN			;GET BACK JOB NUMBER
IFE TNX131, <
	SKIPGE	B,QENT+PRIOR		;GET PRIORITY ,DON'T BOTHER IF NORMAL
	SKUSR				;SET IF BATCH PRIOR
	>
IFN TNX131, <
	SKIPL	QENT+PRIOR		;STD BATCH PRIORITY?
IFE	IMSSS,<
	JRST	RUN1			;NO - DON'T REDUCE IT
	>
IFN	IMSSS,<
	SKIPA	B,[^D10,,5]		;HIGH PRIORITY AT 5%
	>
	MOVE	B,[1,,1]		;SET MAX AND WORKING TO 1%
	SJPCT
	ERROR	(<INVALID JOB PRIORITY PERCENTAGE>,ABEND)
>
	>		;END OF IFN SKUSER
; Main run loop for feeding job
; Some terminating conditions jump in here because
; They have no place else to go !?

RUN1:	PUSHJ	P,CHKOUT		;CHECK FOR OUTPUT
	SKIPA				;NONE EXISTED
	SETZM	NAPTIM			;CLEAR WAIT TIME CAUSE WE GOT CHAR

	TIME				;NOW SEE IF WE NEED A RESOURCE
					;CHECK - COMPUTE THE ELAPSED TIME
					;SINCE THE LAST CHECK
	EXCH	A,LSTTIM
	SUB	A,LSTTIM
	ADDB	A,LSTCHK		;DECREMENT TIME BETWEEN CHECKS
	CAIL	A,0			;LIMIT ELAPSED?
	SKIPG	MAXLOG			;OR LOG FILE LIMIT OVERFLOW?
	SKIPA				;YES
	JRST	RUN2			;NO, GO SEE ABOUT MORE INPUT
	MOVE	A,JOBTTY		;YES, MAKE SURE JOB/TTY OK
	HRL	A,JOBN
	GETAB
	BUG	(<RUN1: Getab on JOBTTY failed>)
	CAIG	A,0
	JRST	DETJOB			;JOB DETACHED ITSELF - WRAP IT UP
	SKIPGE	FRCTRM			;IF NOT LOGGING OUT,
	PUSHJ	P,CHKLIM		;GO CHECK RESOURCE CONSUMPTION
					;AGAINST LIMITS
	MOVEI	A,CHKTIM		;NOW RESET CHECK TIME INTERVAL
	MOVEM	A,LSTCHK

RUN2:	SKIPL	FRCTRM			;FORCED TERMINATION IN EFFECT?
	JRST	RUN4			;YES, FORGET CHECKS OR INPUT CHARS

	PUSHJ	P,TTYJ			;GET TTY STATE INFO
	JRST	RUNNOJ			;THERE'S NO JOB HERE ANYMORE
	BUG	(<RUN2:  PTY BEING ASSIGNED IN MIDDLE OF JOB>)
	JRST	[SKIPE	CEXCSW		;STILL RUNNING, WERE WE IN EXEC?
		 SKIPG	QENT+LINLAB	;YES, DO WE LABEL SUBSYS CHANGES?
		 JRST	RUN3		;ALREADY OUT OF EXEC OR NO LABELS
		 PUSHJ	P,JBST		;MAY HAVE TO LABEL - CHECK JOB STATUS
		 JRST	RUNNOJ		;OOPS, JOB GONE
		 CAMN	A,LABSUB	;NOT EXEC, HAS IT BEEN LABELED?
		 JRST	RUN3		;EXEC OR LABEL OUTPUT ALREADY
		 SETOM	LSTCHK		;SUBSYS CHANGE NOT NOTED-FORCE IT
		 JRST	RUN1]
	PUSHJ	P,RCCTL			;JOB IN TTY WAIT - GET NEXT CHAR
	JRST RUNNOJ			;NO JOB, CLEAN UP
RUN21:	CAIE	B,3			;IS THE CHARACTER ^C
	JRST	RUN24			;NO - GO TREAT AS REGULAR CHAR

;HERE WE HAVE TO SEND A ^C - MAKE SURE JOB IS STABLE IN TTY WAIT MODE
;AND THEN DO IT

	PUSH	P,[-1]			;SET DUMMY INPUT BUFFER SIZE
RUN22:	PUSHJ	P,CHKOUT		;CHECK OUTPUT
	SKIPA				;NONE SO LOOK AT INPUT BUFFER
	JRST	[MOVEI	A,^D1000	;HAD OUTPUT - WAIT 1 SEC
		 DISMS
		 PUSHJ	P,CHKLIM	;RESOURCES OUT
		 JRST	RUN22]		;NO, GO TRY AGAIN
	MOVE	A,PTY			;CHECK INPUT BUFFER
	SIBE
	JRST	[EXCH	B,0(P)		;SOME STUFF IN THE BUFFER
		 SUB	B,0(P)		;ANY CHANGE FROM LAST TIME
		 JUMPE	B,RUN23		;NO, GO CHECK TTY STATE
		 MOVEI	A,^D15000	;YES, WAIT A WHILE - BE SURE HE
		 DISMS			;WON'T TAKE IT BEFORE FLUSHING IT
		 JRST	RUN22]		;CHECK STATUS AGAIN

RUN23:	PUSHJ	P,TTYJ			;CHECK TTY STATE
	JRST	RUNNOJ			;NO JOB - GO CLEAN UP
	BUG	(<RUN23: PTY REASSIGNED IN MIDDLE OF JOB>)
	JRST	[PUSHJ	P,CHKLIM	;RUNNING - CHECK RESOURCES
		 MOVEI	A,^D5000	;OK - WAIT 5 SEC
		 DISMS
		 JRST	RUN22]		;GO TRY IT AGAIN
	POP	P,A			;OK STABLE NOW - STICK ^C
	PUSHJ	P,CTLCO
	JRST	RUN25			;PROCEED

RUN24:	MOVE	A,PTY			;GET PTY#
	PSTI				;GIVE JOB THE CHAR
	JRST [	MOVEI	A,^D100		;GO AWAY FOR A WHILE
		DISMS			;BUT COME BACK HERE
		JRST RUN24]		;SO WE DON'T LOSE THE CHAR 

RUN25:	SETZM	NAPTIM			;CLEAR WAIT CAUSE HE TOOK CHAR.
	JRST RUN1			;GO BACK FOR OUTPUT (PROBABLY ECHO)

RUN3:	MOVE	A,NAPTIM		;GET WAIT TIME
	CAILE	A,NAPMAX		;TOO LONG
	MOVEI	A,NAPMAX		;SET TO MAX
	MOVEM	A,NAPTIM		;RESET TIME (IF CHANGED)
	CAIGE	A,NAPMIN		;TOO SHORT?
	MOVEI	A,NAPMIN		;IF SO, RESET TO MIN
	DISMS				;TAKE NAP, ZZZZZZ...

;INCREASE WAIT TIME SO THAT WE WILL LOOK LESS FREQUENTLY
;AT A JOB THAT IS NOT DOING TERMINAL IO.
;THIS ROUTINE IS A SOMEWHAT ARBITRARY HEURISTIC.
;IT SHOULD ALSO BE NOTED THAT THE LOWERING OF THE WAIT TIME
;BY THE SETZM IN RUN1 AND RUN2 ARE A PART OF THIS WAIT TIME
;CALCULATION.  IT MAY NOT ALWAYS BE DESIRED TO RESET TO 0
;THE WAIT TIME ON ACTIVITY, BUT IT SEEMS VERY LIKELY, SINCE
;IF A JOB TYPES A CHAR OR READS ONE, HE IS LIKELY TO DO
;ONE OF THOSE OPERATIONS AGAIN IN A VERY SHORT TIME (EACH
;GROUP OF CHARS IN AN IO STREAM HAS ONLY ONE LAST CHAR.)
;THUS IF GROUPS ARE N CHARS IN LENGTH, THERE IS
;A PROBABILITY OF (N-1)/N THAT ANOTHER FOLLOWS.
	MOVEI	A,^D1000		;ADD ONE SECOND
	ADDM	A,NAPTIM		;TO WAIT TIME
	JRST	RUN1			;AND CHECK FOR OUTPUT

;IF A CTL FILE IS NOT TERMINATED BY A .LOGO OR .K STATEMENT,
;THEN FORCE FEED THE JOB A LOGO TO LOG IT OUT
RUN4:	SKIPE	FRCTRM			;IN LOGOUT PROCESS
	JRST	RUN5			;NO, GO WAIT FOR JOB TO TERMINATE
	ILDB	B,LOGSTR		;GET NEXT CHARACTER OF LOGO
	SKIPE	B			;END OF LOGO REACHED ?
	JRST	RUN21			;NO, FEED CHARCTER TO JOB
	AOS	FRCTRM			;YES, NOW WAIT FOR TERMINATION
;;;	MOVEI	1,NAPMAX		;TAKE A NAP BEFORE CHECKING FOR
;;;	MOVEM	1,NAPTIM		;SUCCESSFUL LOGOUT
	JRST	RUN1

;	WAIT UNTIL OUTPUT BUFFER EMPTY AND THEN WAIT FOR JOB TO
;	GO AWAY. INSURES ALL OUTPUT IS MOVED TO LOG FILE.
RUN5:	MOVE	A,PTY			;PSEUDO-TTY NUMBER
	SOBE				;SKIP IF OUTPUT BUFFER EMPTY
	JRST RUN3			;DATA IN BUFFER, TRY LATER
	PUSHJ	P,JBST			;CHECK JOB STATUS
	JRST RUNNOJ			;JOB IS LOGGED OUT
	JFCL				;DON'T CARE IF IN EXEC
	JRST RUN3			;JOB STILL RUNNING, TRY LATER


;BATCH JOB DETACHED ITSELF.  FINISH THINGS OFF.
DETJOB:	MOVEI	A,JDETCH		;SET ENDTYP FLAG
	MOVEM	A,ENDTYP
	ERROR (<BATCH JOB HAS DETACHED ITSELF - TERMINATING CONTROL>,IFEOJ)


; KILLIT routine
; Forces a ^C down the job's throat to get the attention of the EXEC
; And then sets the FRCTRM flag so we can put a LOGOUT on it

KILLIT:	SETZM	FRCTRM			;SAY WE WANT A LOGOUT ON HIM
	PUSHJ	P,CTLCO			;SEND HIM A ^C
	JRST RUN1			;IN EXEC TTY WAIT - GO DO OUR
					;OWN LOGOUT


;NO JOB FOUND THERE, CHECK WHAT HAPPENED
RUNNOJ:	PUSHJ	P,TTYJ			;GET TTY INFORMATION AGAIN
	JRST	RUNNO1			;NO JOB ON TTY, VERIFY WHAT HAPPENED
	ERROR	(<RUNNOJ:  TTY BEING REASSIGNED>,ABEND)
	ERROR	(<RUNNOJ:  ACTIVE JOB REAPPEARED>,ABEND)
	ERROR	(<RUNNOJ:  ACTIVE JOB REAPPEARED>,ABEND)

RUNNO1:	MOVE	A,JOBDIR		;FIRST SEE IF ANYONE LOGGED IN ON THIS JOB
	HRL	A,JOBN
	GETAB
	BUG	(<RUNNOJ: GETAB ERROR ON JOBDIR>)
	HRRZ	A,A			;ISOLATE LOGIN DIRECTORY
	CAME	A,QENT+USRDIR		;IS IT US?
	JRST	RUNNO3			;NO, ASSUME OUR JOB GONE NORMALLY
	MOVE	A,JOBTTY		;YES, WE'RE STILL AROUND
	HRL	A,JOBN			;SEE WHO IS HOOKED UP TO IT
	GETAB
	BUG	(<RUNNOJ: GETAB ERROR ON JOBTTY>)
	HLRE	A,A			;STRIP TTY CONTROLLING JOB
	JUMPL	A,DETJOB		;JOB IS DETACHED - INDICATE IT
	JUMPE	A,RUNNO3		;TTY 0 - ASSUME LOGGING OUT NORMALLY
	PUSH	P,A			;SOME OTHER TTY, WRITE ERROR MESSAGE
	HRROI	A,BUGSTR
	HRROI	B,[ASCIZ /JOB ATTACHED AWAY FROM BATCH CONTROL BY TTY /]
	SETZ	C,
	SOUT
	POP	P,B			;ADD OCTAL TTY NUMBER
	MOVEI	C,10
	NOUT
	JFCL
RUNNO2:	ERR1	[ABEND,,BUGSTR]		;FAKED ERROR CALL FOR ABOVE MESSAGE

RUNNO3:	MOVE	A,ENDTYP		;NORMAL LOGOUT - IF ENDTYP ALREADY SET
	CAIN	A,JSTART		;LEAVE IT AS IS, OTHERWISE
	MOVEI	A,JFINIS		;SHOW A NORMAL FINISH
	MOVEM	A,ENDTYP
	JRST	IFEOJ



;ABEND ROUTINE--KILL WITH MESSAGE
ABEND:	MOVEI	A,JABORT		;SET ENDTYP FLAG
	MOVEM	A,ENDTYP
	ERROR	(<ABORTING BATCH JOB>,IFEOJ)


; This page contains the various pseudo interrupt handler routines
;	Channel 1   - Superior requests job desubmitted gracefully
;	Channel 3   - Superior commands immediate halt
;	Channel 4   - Superior requests store AC's, PC and INTERRUPT STATE
;	Channel 5   - Superior commands halt now - SYSTEM GOING DOWN
;	Channel 10  - EOF encountered in file
;	Channel 11  - Data error on file I/O
;	Channel 15  - Illegal instruction trap
;	Channel 19  - Inferior fork terminated

; PSEUDO INTERRUPT CODE TO SET FORK DESUBMISSION FLAG
; INTERRUPT FROM CHANNEL 1
DESUBF:	PUSH	P,A
	MOVEI	A,JDESUB		;SET ENDTYP FLAG
	MOVEM	A,ENDTYP
	SETOM	INFDSB			;SET DESUBMIT FLAG
	POP	P,A
	DEBRK


;PSEUDO INTERRUPT HANDLER FOR SUICIDE CALL
; INTERRUPT FROM CHANNEL 3
SUICID:	PUSH	P,A			;CHANGE INTERRUPT RETURN TO
	MOVEI	A,KILLME		;SUICIDE ROUTINE
	MOVEM	A,LEV3PC
	MOVEI	A,JABORT		;SET ENDTYP FLAG
	MOVEM	A,ENDTYP
	POP	P,A
	DEBRK


;ROUTINE FOR IMMEDIATE SUICIDE
KILLME:	ERROR	(<IMMEDIATE JOB ABORT REQUESTED>,IFEOJ)




;PSEUDO INTERRUPT ROUTINE TO SAVE FORK AC'S IN CSHACS, PC IN CSHPC,
;AND INTERRUPT SYSTEM STATUS
; INTERRUPT FROM CHANNEL 4
SAVACS:	MOVEM	P,CSHACS+P		;SAVE STACK POINTER
	MOVEI	P,CSHACS		;DO THE REST
	BLT	P,CSHACS+16
	MOVE	P,CSHACS+P		;RESTORE THE STACK POINTER

	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B

	MOVE	A,LEV3PC		;SAVE PC IN RIGHT PLACE
	MOVEM	A,CSHPC
	SETOM	PISYON			;GET STATUS OF PI SYSTEM
	MOVEI	A,400000
	SKPIR				;IS IT ON?
	SETZM	PISYON			;NO, CLEAR FLAG
	RCM				;GET CHANNEL ACTIVATED MASK
	MOVEM	A,PIACT
	MOVEI	A,400000
	RWM				;GET PI WAITING DATA
	MOVEM	A,PIWAIT
	MOVEM	B,PIPROG

	SETOM	ACSDON			;SIGNAL WE HAVE THE AC'S

SAVAC0:	SKIPL	ACSDON			;FLAG RESET YET?
	JRST	SAVAC1			;YES, CARRY ON
	MOVEI	A,^D1000		;NO, THEN WAIT A SECOND
	DISMS
	JRST	SAVAC0			;AND TRY AGAIN

SAVAC1:	POP	P,B			;RESTORE AC'S
	POP	P,A
	DEBRK				;AND TAKE OFF AGAIN


;INTERRUPT HANDLER FOR HALT REQUEST BECAUSE OF IMPENDING SYSTEM HALT
; INTERRUPT ON CHANNEL 5
SYSHLT:	PUSH	P,A
	MOVEI	A,KILHLT		;SET RETURN ROUTINE
	HRRM	A,LEV3PC
	MOVEI	A,JSHALT		;END TYPE 5
	MOVEM	A,ENDTYP
	POP	P,A
	DEBRK

KILHLT:	ERROR	(<ABORTING JOB - IMPENDING SYSTEM HALT>)
	ERROR	(<JOB WILL BE REQUEUED>,IFEOJ)



;PSEUDO INTERRUPT ROUTINE FOR FILE EOF
; INTERRUPT ON CHANNEL 10
PSIEOF:	PUSH 	P,A			;SAVE A
	CAME	A,CTLJFN		;WAS IT ON CTL FILE?
	ERROR	(<PSIEOF: EOF ON FILE OTHER THAN CTL FILE>,EOFNCT)
	MOVEI	A,KILLIT		;ADDRESS TO START TERMINATION PROCESS
	MOVEM	A,LEV2PC		;SET UP DEBRK PC VALUE
	CAME	D,CTLLIN		;WAS THERE ANY INPUT?
	ERROR	(<PSIEOF: EOF ON CTL FILE BUT CHARACTERS IN BUFFER>,EOFNCT)
	POP	P,A
	DEBRK				;CONTINUE

EOFNCT:	MOVEI	A,ABEND			;GO END JOB
	MOVEM	A,LEV2PC		;PUT IN RETURN PC
	POP	P,A
	DEBRK				;RETURN TO TOP LEVEL



;PSEUDO INTERRUPT ROUTINE FOR FILE DATA ERROR
; INTERRUPT ON CHANNEL 11
PSIERR:	CAME	A,CTLJFN		;WAS IT CTL FILE
	ERROR	(<DATA ERROR ON FILE OTHER THAN CTL FILE>,PSIER0)
	ERROR	(<DATA ERROR ON CTL FILE>)
PSIER0:	MOVEI	A,ABEND
	MOVEM	A,LEV2PC
	DEBRK				;RETURN TO PROG



;PSEUDO INTERRUPT ROUTINE FOR ILLEGAL INSTRUCTION TRAP THIS FORK
; INTERRUPT ON CHANNEL 15
ILINST:	MOVEM	P,CSHACS+P		;SAVE FORK AC'S FOR POSTERITY
	MOVEI	P,CSHACS
	BLT	P,CSHACS+16
	MOVE	P,[IOWD PDLL,CSHSTK]	;SET UP DUMMY STACK

	MOVE	A,LEV2PC		;SAVE INTERRUPT PC AS WELL
	MOVEM	A,CSHPC

	ERROR	(<WARNING: ILLEGAL INSTRUCTION TRAP IN BATCH MONITOR.>)

	SETOM	FLNMSW			;SET FILE NAME SW
	HRROI	A,STRBUF		;MAKE OUTPUT MESSAGE
	HRROI	B,[ASCIZ /
   FORK /]
	SETZ	C,
	SOUT
	MOVE	B,RELFRK		;ADD FORK NUMBER
	ANDI	B,777
	MOVEI	C,10			;OCTAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ /, INSTR /]
	SETZ	C,
	SOUT
	MOVE	B,LEV2PC		;GET WHERE TRAP HAPPENED
	MOVE	B,-1(B)			;AND THE INSTRUCTION ITSELF
	MOVE	C,[560014,,10]
	NOUT
	JFCL
	HRROI	B,[ASCIZ / AT /]
	SETZ	C,
	SOUT
	MOVE	B,LEV2PC		;ADD ON LOCATION OF TRAP + 1
	MOVE	C,[560014,,10]
	NOUT
	JFCL
	HRROI	B,[ASCIZ /, AC'S:/]
	SETZ	C,
	SOUT
	MOVE	D,[-2,,1]		;PRINT OUT AC'S 1 AND 2
	MOVE	C,[560014,,10]
ILILOP:	MOVEI	B," "			;SPACE FIRST
	BOUT
	MOVE	B,CSHACS(D)		;GET AC CONTENTS
	NOUT
	JFCL
	AOBJN	D,ILILOP		;DO ALL REQUESTED

	HRROI	B,[ASCIZ /
   TENEX ERROR: /]
	SETZ	C,
	SOUT				;AND TACK ON TENEX REASON WHY
	HRLOI	B,400000
	ERSTR
	JFCL
	JFCL

	HRROI	B,DAYTRM		;AND THE FINAL TERMINATOR
	SETZ	C,
	SOUT

	HRROI	B,JOBDAY		;SEND NOTICE TO DAYFILE
	HRROI	C,[ASCIZ / ILLEG INSTR TRAP ON /]
	HRROI	D,STRBUF
	PUSHJ	P,DAY

IFN MXILIN,<
	HRRZ	A,LEV2PC		;SET RESUME PC AT PC-1
	SUBI	A,1
	HLRZ	B,0(A)			;GET THE INSTR CODE
	CAIE	B,(JSYS)		;WAS IT A JSYS?
	>	;END MXILIN CONDITIONAL
	JRST	[ERROR	(<         ABORTING JOB.  SEE SYSTEMS PROGRAMMER>)
		 MOVSI	P,CSHACS	;RESTORE THE AC'S
		 BLT	P,P		;INCLUDING THE STACK
		 BUG	(<ILINST: SUBFORK ILLEGAL INSTRUCTION TRAP>)]
IFN MXILIN,<
	HRRM	A,LEV2PC
	AOS	A,ILINCT		;BUMP NUMBER OF HITS
	CAILE	A,MXILIN		;TOO MANY?
	JRST	[ERROR	(<         ABORTING JOB.  SEE SYSTEMS PROGRAMMER>)
		 MOVSI	P,CSHACS	;RESTORE THE AC'S
		 BLT	P,P		;INCLUDING THE STACK
		 BUG	(<ILINST: TOO MANY ILLEGAL INSTR RETRIES>)]

	ERROR	(<         ATTEMPTING TO CONTINUE.  SEE SYSTEMS PROGRAMMER>)
	MOVEI	A,^D30000		;WAIT 30 SEC TO LET GREMLINS
	DISMS				;GO AWAY

ILIOUT:	MOVSI	P,CSHACS		;RESTORE AC'S
	BLT	P,P

	DEBRK
	>	;END MXILIN CONDITIONAL
	BUG	(<ILINST: DEBRK FAILED>)



;PSEUDO INTERRUPT ROUTINE FOR INFERIOR FORK TERMINATION - SNDMSG
; INTERRUPT ON CHANNEL 19
HMSGFK:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E

	MOVEI	E,^D30			;TIME OUT LIMIT - 30 SEC
HMSGF0:	MOVE	A,FORK			;RECORD SNDMSG FORK CONDITIONS
	RFSTS
	MOVEM	A,FKSTS
	MOVEM	B,FKPC
	CAIE	A,0			;STILL RUNNING (DUAL PROCESSOR POSSIBILITY)
	JRST	HMSGF1			;SOME OTHER STATE - GO CHECK IT
	MOVEI	A,^D1000		;WAIT A SEC
	DISMS
	SOJG	E,HMSGF0		;NOW GO TRY AGAIN IF NOT TIMED OUT
	HRROI	B,[ASCIZ /
   TERMINATION TIME-OUT:  STATUS = /]	;TIMED OUT - SEND DAYFILE MESSAGE
	PUSHJ	P,HMSGER
	JRST	HMSGF3

HMSGF1:	HLRZ	A,A			;ISOLATE STATUS
	CAIN	A,2			;REGULAR TERMINATION?
	JRST	HMSGF2			;YES, FINISH THINGS OFF
	HRROI	B,[ASCIZ /
   NON-HALTED SNDMSG TERMINATION:  STATUS = /]	;NO, RECORD PROBLEM
	PUSHJ	P,HMSGER
	JRST	HMSGF3

HMSGF2:	MOVE	A,FORK
	MOVEI	B,FKACS
	RFACS

HMSGF3:	SKIPLE	A,MSGJFN		;MESSAGE.TXT JFN
	RLJFN
	JFCL
	SKIPLE	A,TMPJFN
	DELF				;DELETE TEMP MSG FILE
	JFCL

	MOVE	A,FORK			;GET FORK HANDLE
	KFORK				;KILL IT TO GET RID OF SNDMSG

	SETZM	FORK			;CLEAR FORK ACTIVE FLAG
	SETOM	SNDLCK			;CLEAR MESSAGE LOCK
	SETOM	WHOSND			;CLEAR SENDER

	POP	P,E
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	DEBRK
	BUG	(<HMSGFK: DEBRK FAILED>)


;  Here there is something wrong with the SNDMSG termination.  Either a
; time-out or a non-simple halt.

HMSGER:	SETOM	FLNMSW			;SET UP TO GIVE FULL INFO TO DAY FILE
	HRROI	A,STRBUF		;NOW CONSTRUCT THE MESSAGE
	SETZ	C,
	SOUT
	MOVE	B,FKSTS			;ADD STATUS BITS
	MOVEI	C,10
	NOUT
	JFCL
	HRROI	B,[ASCIZ /,  PC = /]
	SETZ	C,
	SOUT
	MOVE	B,FKPC			;AND THE PC
	MOVEI	C,10
	NOUT
	JFCL
	HRROI	B,DAYTRM
	SETZ	C,
	SOUT				;AND THE TERMINATOR

	HRROI	B,JOBDAY		;NOW SEND IT
	HRROI	C,[ASCIZ / SNDMSG ERROR ON /]
	HRROI	D,STRBUF
	PUSHJ	P,DAY

	MOVE	A,MSGJFN		;TRY CLEANING UP JFNS
	TLO	A,(1B0)			;DON'T RELEASE JFN
	GTSTS
	TLNE	B,(1B0)			;OPEN?
	CLOSF				;YES, CLOSE IT
	JFCL
	MOVE	A,TMPJFN
	TLO	A,(1B0)			;DON'T RELEASE JFN
	GTSTS
	TLNE	B,(1B0)			;OPEN?
	CLOSF				;YES, CLOSE IT

	POPJ	P,			;RETURN


;ROUTINE TO SEND ^C TO PTY AND TO ENSURE JOB IS IN EXEC TTY WAIT

CTLCO:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	MOVEI	C,4			;MAX # OF ^C'S TO SEND

SENDC:	MOVE	A,PTY
	MOVEI	B,3			;LETS HAVE A ^C
	PSTI				;AND STICK IT TO HIM
	JRST	[MOVE	A,PTY		;BUFFER IS FULL SO CLEAR IT
		 CFIBF
		 MOVEI	A,^D1000	;WAIT A BIT
		 DISMS			;TRY AGAIN LATER
		 JRST	SENDC]
	SOSGE	C			;HAVE WE SENT ENOUGH?
	ERROR	(<JOB NOT RESPONDING TO ^C>,ABEND)	;YES, FLUSH HIM
	MOVEI	D,^D15			;WAIT 15 CHECK CYCLES FOR ^C TO BE READ
	SETZ	F,			;FLAG INDICATING SOME OUTPUT RECEIVED

EXECWT:	MOVEI	A,^D1000		;WAIT A BIT TO LET THINGS HAPPEN
	DISMS
	SOSGE	D			;HAVE WE HAD ENOUGH CYCLES FOR THIS ^C?
	JRST	SENDC			;YES, GIVE HIM ANOTHER ONE
	PUSHJ	P,CHKOUT		;SEE IF ANY OUTPUT
	JRST	[SKIPE	F		;MAKE SURE WE HAVE GOTTEN SOMETHING
		 JRST	EXCWT0		;OK - MOVE ON
		 PUSHJ	P,JBST		;NOTHING YET - JOB STILL THERE?
		 JRST	RUNNOJ		;NO - FINISH THINGS OFF
		 JFCL
		 JRST	EXECWT]		;STILL THERE - WAIT SOME MORE
	AOS	F			;GOT SOMETHING NOW - SET FLAG

EXCWT0:	MOVE	A,PTY			;INPUT BUFFER EMPTY?
	SIBE
	JRST	EXECWT			;YES, WAIT A BIT AND CHECK AGAIN

	PUSHJ	P,JBST			;FIND OUT IF HE IS IN EXEC YET
	JRST RUNNOJ			;JOB NOT THERE ANYMORE - END IT
	JRST 	EXECWT			;NOT IN EXEC - WAIT OUT 15 SEC

					;HERE HE IS IN THE EXEC BUT WE
	PUSHJ	P,TTYJ			;ALSO NEED HIM IN TTY WAIT
	JRST	RUNNOJ			;LINE UNASSIGNED - JOB GONE
	BUG	(<CTLCO: PTY BEING ASSIGNED IN MIDDLE OF JOB>)
	JRST	EXECWT			;STILL RUNNING - WAIT SOME MORE
					;TO SEE WHAT HAPPENS, COULD BE
					;LOGO

EXFIN0:	PUSHJ	P,CHKOUT		;OK, SEEMS TO BE READY - FINAL CHECK
	SKIPA				;NO NEW OUTPUT - CARRY ON
	JRST	EXECWT			;OOPS, GOT SOME MORE - GO BACK
	MOVE	A,PTY			;SEND ";^G" AND DEMAND RIGHT RESPONSE
	PUSH	P,C			;SAVE ^C LEFT COUNT
	MOVEI	C,^D3			;COUNT OF CHARS TO BE SENT
	MOVE	D,[POINT 7,[BYTE (7) ";",7,15,0,0]]	;STRING ";^G<CR><LF>"
EXFIN1:	ILDB	B,D			;GET FIRST BYTE
	PSTI
	JRST	EXFERR			;BAD NEWS
	SOJG	C,EXFIN1		;DO THEM ALL

	MOVEI	C,^D5			;PREPARE TO GET THE OUTPUT
	MOVE	D,[POINT 7,[BYTE (7) ";",7,15,12,"@"]]
EXFIN2:	MOVEI	E,^D15			;WAIT MAX 15 SEC FOR EACH ECHO
EXFIN3:	SETZ	B,			;DON'T WAIT IF NO OUTPUT
	PSTO				;GET A RESPONSE
	JRST	[MOVEI	A,^D1000	;BAD NEWS, WAIT A BIT AND TRY AGAIN
		 DISMS
		 MOVE	A,PTY
		 SOJGE	E,EXFIN3
		 JRST	EXFERR]		;OUT OF LUCK
	ANDI	B,177			;MAKE SURE NO MORE THAN 7 BITS
	CAIN	B,0			;IS IT A NULL PAD?
	JRST	EXFIN2			;YES - IGNORE IT
	ILDB	E,D			;GET WHAT CHARACTER IS SUPPOSED TO BE
	CAME	B,E			;IS IT WHAT WE SENT?
	JRST	[CAIE	E,"@"		;DID WE JUST TRY "@"?
		 JRST	EXFERR		;NO - THEN WE HAVE TROUBLE
		 CAIE	B,"!"		;YES - THEN TRY "!", HE MAY BE ENABLED
		 JRST	EXFERR		;NOT THAT EITHER - BAD NEWS
		 JRST	EXECOK]		;WHEW, MADE IT!
	SOJG	C,EXFIN2		;ANY MORE LEFT?

EXECOK:	SETOM	LSTCHK			;OK, IN EXEC.  FORCE RESOURCE CHECKING
	POP	P,C			;RECOVER REMAINING ^C COUNT

	POP	P,D			;ALL SET NOW SO RETURN
	POP	P,C
	POP	P,B
	POP	P,A

	POPJ	P,


EXFERR:	POP	P,C			;RECOVER REMAINING ^C COUNT
	MOVE	A,PTY			;CLEAR BUFFERS
	CFIBF				;INPUT FIRST
	CFOBF				;THEN OUTPUT
	JRST	SENDC			;HIT HIM AGAIN.



;ROUTINE TO CHECK RESOURCE LIMIT USAGE.  IF ANY IS EXCEEDED, IT IS AUGMENTED
;BY 10% AND A CONTROL SIGNAL SENT IF REQUESTED.  THE JOB IS TERMINATED IF THE
;AUGMENTED LIMITED IS AGAIN EXCEEDED.  IF AN INTERRUPT IS ARMED, THE
;APPROPRIATE CONTROL CHARACTER IS SENT TO THE JOB (ONCE).  UPON ENTERING
;THE EXEC, CONTROL CHARACTERS ARE RESET TO NULL.
;CLOBBERS AC 1

CHKLIM:	PUSH	P,B			;SAVE AC
	PUSHJ	P,JBST			;JOB STATUS
	JRST	CHKLM2			;NO JOB, RETURN
	JRST	CHKLM0			;RUNNING, BUT NOT EXEC - SET FLAG

	SKIPE	CEXCSW			;IN EXEC NOW, HAVE WE BEEN?
	JRST	CHKLM1			;YES, DON'T RESET CONTROLS
	SETOM	CEXCSW			;NO, SET SWITCH AND CLEAR CONTROLS
	SETZM	CPUCHR
	SETZM	RUNCHR
	SETZM	LINCHR
	JRST	CHKLM1			;NOW GO CHECK LIMITS

IFE IMSLOG,<
CHKLM0:	SETZM	CEXCSW			;NON-EXEC FLAG
	>	;END IMSLOG CONDITIONAL

IFN IMSLOG,<
CHKLM0:	SKIPL	CEXCSW			;WERE WE IN EXEC BEFORE NOW?
	JRST	CHKLM1			;NO, GO CHECK OTHER LIMITS
	SETZM	CEXCSW			;YES, FLIP THE SWITCH NOW
	SKIPG	QENT+LINLAB		;AND CHECK TO SEE IF WE NEED A
					;SUBSYS CHANGE LABEL
	JRST	CHKLM1			;WRONG LABEL TYPE, MOVE ON
	CAMN	A,LABSUB		;SUBSYS CHANGE ALREADY NOTED?
	JRST	CHKLM1			;YES, ASSUME LABEL AS WELL
	PUSH	P,C			;NO, OUTPUT JUST A LABEL
	PUSH	P,D
	MOVE	C,A			;CURRENT SUBSYS IN C
	SETZ	D,			;NO OTHER LOG LINE OUTPUT
	PUSHJ	P,SNDLG0		;GO SEND IT - DON'T COUNT
	POP	P,D
	POP	P,C
	>	;END IMSLOG CONDITIONAL

CHKLM1:	MOVE	A,JOBRT
	HRL	A,JOBN
	GETAB
	BUG	(<RUN2: Getab on JOBRT failed>)
	CAMG	A,MAXCPU		;LIMIT EXCEEDED?
	JRST	CPLIM0			;NO - SEE IF SIGNAL NEEDED
	MOVEM	A,MAXCPU		;STORE CURRENT VALUE
	SKIPN	A,CPUTRG		;YES, KILL IT IF AUGMENT GONE
	ERROR	(<Job exceeded max CPU time>,CHKERR) 	;KILL HIS ASS
	SETZM	CPUTRG
	ADDM	A,MAXCPU		;AUGMENT LIMIT ONCE
CPLIM0:	MOVEI	B,CPUCHR		;NOT OVER YET - NEEDS WARNING?
	SKIPN	CPUTRG
	PUSHJ	P,LIMTKL		;YES - TICKLE HIM

	TIME				;GET TODCLK
	CAMG	A,RUNTIM		;IS HE RUNNING BEYOND HIS LIMIT
	JRST	RNLIM0			;NO - SEE IF SIGNAL NEEDED
	MOVEM	A,RUNTIM		;STORE CURRENT VALUE
	SKIPN	A,RUNTRG		;YES, KILL IT IF AUGMENT GONE
	ERROR	(<Job exceeded max elapsed time>,CHKERR) 	;KILL HIS ASS
	SETZM	RUNTRG
	ADDM	A,RUNTIM		;AUGMENT LIMIT ONCE
RNLIM0:	MOVEI	B,RUNCHR		;NOT OVER YET - NEEDS WARNING?
	SKIPN	RUNTRG
	PUSHJ	P,LIMTKL		;YES - TICKLE HIM

	SKIPGE	INFDSB			;THIS JOB DESUBMITTED
	ERROR	(<Job Desubmitted>,CHKERR)	;YES

	SKIPL	MAXLOG			;HAS LOG GONE OVER THE LIMIT?
	JRST	LGLIM0			;NO - SEE IF SIGNAL NEEDED
	SKIPN	A,LOGTRG		;YES, KILL IT IF AUGMENT GONE
	ERROR	(<Log file size exceeded limit>,CHKERR) 	;KILL THE JOB
	SETZM	LOGTRG
	MOVEM	A,MAXLOG		;AUGMENT LIMIT ONCE
LGLIM0:	MOVEI	B,LINCHR		;NOT OVER YET - NEEDS WARNING?
	SKIPN	LOGTRG
	PUSHJ	P,LIMTKL		;YES - TICKLE HIM

CHKLM2:	POP	P,B			;RESTORE AC
	POPJ	P,			;ALL OK - RETURN

CHKERR:	MOVEI	B,KILLIT		;CHECK LIMIT EXCEEDED, KILL JOB
	HRRM	B,-1(P)			;SET RETURN ADDRESS
	POP	P,B			;RESTORE AC B
	ERROR	(<Aborting batch job>)
	MOVE	A,ENDTYP		;SET PROPER END CONDITION
	CAIN	A,JSTART		;IF ALREADY SET, LEAVE IT, OTHERWISE
	MOVEI	A,JABORT		;SHOW AS ABORTED JOB
	MOVEM	A,ENDTYP

	POPJ	P,			;GO ZAP HIM


;ROUTINE TO GIVE RESOURCE LIMIT WARNING TO USER IF APPROPRIATE CONTROL
;CHARACTER IS NON-ZERO AND IF IT HASN'T BEEN SENT YET.
;ON ENTRY:	B CONTAINS ADDRESS OF CONTROL CHARACTER

LIMTKL:	SKIPE	CEXCSW			;ARE WE IN THE EXEC?
	POPJ	P,			;YES, THEN NO INTERRUPTS

	PUSH	P,B			;SAVE CHARACTER ADDRESS
	SKIPG	B,0(B)			;IS THERE ONE THAT HASN'T BEEN SENT?
	JRST	LIMTK0			;NO RETURN
	MOVE	A,PTY			;SEND CHARACTER TO PTY
	PSTI
	JRST	LIMTK0			;BUFFER FULL - WAIT UNTIL NEXT TIME
	SETZM	@0(P)			;NULL OUT CHARACTER

LIMTK0:	POP	P,B			;RESTORE AC
	POPJ	P,			;RETURN


;END OF JOB REACHED.  CLEAN UP NOW.

IFEOJ:	PUSHJ	P,CHKOUT		;GET THE LAST OF THE OUTPUT(IF ANY)
	JFCL				;NONE, FINE

	MOVE	B,ENDTYP		;SET PROPER ENDING STRING
	SETZ	C,			;NO <appendix>
	PUSHJ	P,WINFRM		;ANNOUNCE THE END

IFEOJ1:	SKIPE	FORK			;IS SNDMSG FORK STILL ACTIVE
	JRST	[MOVEI	A,^D10000	;YES, TRY AGAIN LATER
		 DISMS
		 JRST	IFEOJ1]		;GO CHECK AGAIN

	MOVE	A,PTY			;RELEASE PTY
	JUMPLE	A,IFEOJ2		;JUMP IF NULL PTY NUMBER
	REPTY				;GIVE IT UP
	ERROR	(<REPTY FAILED--BAD NEWS>,IFEOJ2)
	MOVE	B,RELFRK		;OK IT'S GONE, CLEAR TABLE ENTRY
	ANDI	B,777
	SETZM	FRKPTY(B)

IFEOJ2:	HRRZ	A,CTLJFN		;CLOSE INPUT FILE
	CLOSF
	ERROR	(<ERROR CLOSING CTL FILE>,IFEOJ3)
	SETZM	CTLJFN			;SAY NONE AROUND
	HRRZS	FRKJFN(B)		;AND FORK JFN TABLE TOO

IFEOJ3:	HRRZ	A,LOGJFN		;CLOSE LOG FILE
	CLOSF
	JRST	IFEOJ4			;CAN'T TELL ANYONE, JUST MOVE ON
	SETZM	LOGJFN			;NO MORE LOG FILE
	HLLZS	FRKJFN(B)		;AND CLEAR FORK JFN TABLE TOO

IFEOJ4:	NOINT				;KILL INTERRUPTS
	HALTF				;NO, EXIT
	JRST	.-1


;PUTS IT IN LOGLIN IF THERE IS ANY
;SKIPS IN RETURN IF THERE WAS OUTPUT.
CHKOUT:	MOVE	A,PTY			;GET PTY ID
	SETZ	B,			;DON'T WAIT IF NONE READY
	PSTO				;TRY FOR OUTPUT
	POPJ	P,			;NO OUTPUT
	AOS	(P)			;OUTPUT, SO SKIP
CHKOU2:	ANDI	B,177			;ONLY 7 BITS
	PUSHJ	P,ADDLOG		;ADD THE CHAR TO THE LOG
	MOVE	A,PTY			;GET PTY ID AGAIN
	SETZ	B,			;DON'T BLOCK FOR OUTPUT
	PSTO				;TRY FOR ANOTHER CHAR
	POPJ	P,			;RETURN
	JRST	CHKOU2			;WE GOT IT, SO TAKE CARE OF IT.

;APPEND A CHAR TO LOGLIN, OUTPUT BUFFER IF NEEDED.

ADDLOG:	MOVE	A,LOGLIN+1		;GET COUNTER
	CAML	A,LOGLIN		;IS IT IN RANGE?
	PUSHJ	P,ADLOG2		;NO-WRITE FULL BUFFER
	IDPB	B,LOGLIN-1		;SAVE CHARACTER

;CHECK IF FIRST CHARACTER OF LINE, IF SO GET THE SUBSYS NAME
	SKIPE	LOGLIN+1		;FIRST?
	JRST	ADLOG1			;NO

;IF FORCED TERMINATION, OUTPUT CHARCTERS UNTIL PTY OUTPUT BUFFER IS EMPTY
	SKIPL	FRCTRM			;FORCED TERMINATION ?
	JRST	ADLOG1			;YES, CONTINUE TO OUTPUT CHARACTERS

	PUSHJ	P,JBST			;GET HIS STATUS
	MOVE	A,[SIXBIT /BATCON/]	;NO JOB SO SAY JUST US
	JFCL				;A SUBSYSTEM
	MOVEM	A,SBJBNM		;EXEC, SAVE NAME

ADLOG1:	AOS	LOGLIN+1		;COUNT IT
	CAIE	B,15			;IGNORE EOL'S THAT ARE CR
	PUSHJ	P,SKEOL			;WAS IT AN EOL OF SOME SORT?
	POPJ	P,			;NO--RETURN
	TLO	ZZ,L.NOEL		;SEND NO EOL BY SNDLOG, WE ALREADY HAD ONE

ADLOG2:	PUSH	P,B			;SAVE REGISTERS SO WE CAN WRITE LINE
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E

	MOVE	C,SBJBNM		;GET NAME OF SUBSYS SUBJOB IS IN

	MOVEI	D,LOGLIN		;POINT TO LINE TO SEND
	PUSHJ	P,SNDLOG		;SEND THE LINE
	MOVE	A,[POINT 7,LOGLIN+2]	;RESTORE THE POINTERS
	MOVEM	A,LOGLIN-1		;GET BYTE POINTER AGAIN
	SETZM	LOGLIN+1		;AND CLEAR COUNT
	POP	P,E			;RESTORE REGISTERS SAVED
	POP	P,D
	POP	P,C
	POP	P,B
	POPJ	P,			;RETURN
;	SET UP FOR SENDING INTERNAL MESSAGE TO USER LOG FILE
INTMSG:	MOVE	C,[SIXBIT /BATCON/]		;SUBSYSTEM NAME
	MOVEI	D,MSGLIN			;MESSAGE ADDRESS
	SETOM	MSGLIN+1			;TERMINATE ON ZERO BYTE RATHER
						;THAN BYTE COUNT
IFN IMSLOG,<
	MOVE	A,QENT+LINLAB			;SAVE THE REAL LABEL TYPE
	PUSH	P,A
	SKIPE	A				;THEN IF NOT THE OLD TYPE,
	SETOM	QENT+LINLAB			;FAKE NONE AT ALL FOR NOW
	>	;END OF IMSLOG CONDITIONAL

	PUSHJ	P,SNDLG0			;SEND MESSAGE TO FILE
	SETZM	MSGLIN+1			;CLEAR CHARACTER COUNT

IFN IMSLOG,<
	POP	P,A				;RESTORE REAL LABEL TYPE
	MOVEM	A,QENT+LINLAB
	>	;END OF IMSLOG CONDITIONAL

	POPJ	P,0

;SEND LOG LINE TO LOG, CALL
;	IN C SIXBIT, MSG TYPE
;	IN D ADDRESS OF LINE BUFFER
;	LINE BUFFER: FIRST WORD MAX # CHARS 
;	2ND WD, # CHARS DATA
;	3RD WD ON, THE DATA
;	DESTROYS REGISTERS A,B,C,D,E

SNDLOG:	SOS	MAXLOG			;COUNT THE USER LOG LINE (CHK IN MAIN)
SNDLG0:	MOVE	A,LOGJFN		;GET THE LOG JFN
	CAIGE	A,2			;LEGAL JFN ?
	BUG	(<Output jfn illegal in SNDLOG>)
	PUSH	P, C			;SAVE SUBSYS NAME

IFN IMSLOG,<
; The following code adds options for LOG file line labelling:
;
;   If QENT+LINLAB =  0	     Preceed line with   <date> <subsys> <tab>
;		     -1	     No labels at all on line
;		     T(log labels), C(log lines)
;
;   In the latter case the labels are interspersed with the LOG file
;   output (labels on separate lines) and are of the form:
;	-------  [<date> <subsys>  Used HH:MM:SS in HH:MM:SS]  ------- <crlf>
;   A label is output before writing the current LOG file entry if
;   either of the following conditions is true:
;
;    	Time since writing last log label .GT. T(log labels)
;    OR	at least C(log lines) log lines have been written since the
;	   last label

	SKIPGE	B, QENT+LINLAB		;IF NEG, THEN NO LABELS AT ALL
	 JRST	NOLAB			;JUST PUT OUT LINE
	JUMPE	B, OLDLAB		;IF 0, THEN OLD LABEL STYLE
	TIME				;GET TOD NOW, INTO 1
	SKIPE	EXECHG			;ARE WE ENTERING EXEC?
	JRST	NEWLAB			;YES, GO DO LABEL
	CAMN	C,[SIXBIT /USER/]	;NO, IS THIS SUBSYS "USER"
	JRST	NWLCKL			;YES, DON'T BOTHER WITH SUBSYS
	CAME	C,LABSUB		;VALID SUBSYS, IS IT THE SAME?
	JRST	[CAMN	C,[SIXBIT /EXEC/]	;NO, ENTERING EXEC?
		 SETOM	EXECHG			;YES, SET FLAG
		 JRST	NEWLAB]		;AND DO A NEW LABEL

NWLCKL:	SOSG	LABCNT			;LINE/LABEL COUNT OVERFLOW?
	 JRST	NEWLAB			;YES, FORCE OUT NEW LABEL
	MOVE	B, A			;GET CURRENT TOD
	SUB	B, LABTOD		;TIME SINCE LAST LABEL OUTPUT
	IDIVI	B, ^D1000		;IN SECONDS
	HLRZ	C,QENT+LINLAB		;GET T(log labels)
	CAML	B, C			;.GT. THRESHOLD?
	 JUMPN	C, NEWLAB		;YES, IF T(log labels) .GT. 0, DO
					;A NEW LABEL

NOLAB:	POP	P, C			;OK, NO NEW LABEL, CLEAN THE STACK
	MOVE	A, LOGJFN		;RESTORE LOG FILE JFN
	JRST	PUTLOG			;AND JUST GO WRITE THE LINE
	
NEWLAB:	MOVE	C,0(P)			;GET THE SUBSYS NAME BACK
	CAME	C,[SIXBIT /USER/]	;IF SUBSYS "USER", DON'T STORE IT
	MOVEM	C, LABSUB		;SAVE IT AS THE CURRENT ONE
	MOVEM	A, LABTOD		;SAVE THIS TOD AS TIME OF LAST LABEL
	HRRZ	B, QENT+LINLAB		;STRIP OUT MAX # LINES BETWEEN LABELS
	TRZ	B, 1B18			;REMOVE SUBSYS LABEL BIT
	CAIN	B,0			;IF 0 SPECIFIED, THEN
	 HRLOI	B, 377777		;ALLOW AN "INFINITE" COUNT
	MOVEM	B, LABCNT		;RESET COUNTER AS OF THIS LABEL

	CAIE	D,0			;LABEL ONLY?
	SKIPN	EXECHG			;ARE WE ENTERING EXEC?
	JRST	NEWLB0			;NO EXEC, THEN JUST DO THE LABEL
	MOVEI	A,2(D)			;YES, THEN LABEL ONLY IF THIS
	HRLI	A,440700		;LINE STARTS WITH "@" OR "!"
	ILDB	B,A
	CAIE	B,"@"
	CAIN	B,"!"
	JRST	[SETZM	EXECHG		;RIGHT ON - CLEAR EXEC FLAG
		 JRST	NEWLB0]		;AND DO THE LABEL
	JRST	NOLAB			;NO GO, DON'T DO THE LABEL UNTIL
					;WE GET THE EXEC LINE

NEWLB0:	MOVE	A, LOGJFN		;RESTORE LOG FILE JFN
	HRROI	B, [ASCIZ /   *******  [  /]	;WRITE LABEL START
	SETZ	C,
	SOUT
		>	;END IMSLOG

OLDLAB:	SETO	B,			;USE CURRENT TIME
	MOVSI	C,(1B0)			;DON'T PRINT DATE
	ODTIM				;GIVE HH:MM:SS TO LOG FILE
	MOVEI	B," "			;SPACE AFTER TIME
	BOUT
	POP	P,C			;RESTORE SUBSYS NAME (SIXBIT)

	MOVEI	E,6			;LENGTH OF TYPE
SNDLG1:	SETZ	B,			;CLEAR WORD TO BUILD TYPE
	LSHC	B,6			;GET CHAR IN SIXBIT
	ADDI	B,40			;MAKE 7 BIT AND WRITE IT
	BOUT
	SOJG	E,SNDLG1		;LOOP UNTIL DONE

IFE IMSLOG,<
	MOVEI	B,11			;TAB
	BOUT				;BEFORE LINE
	>

IFN IMSLOG,<		;IF NEW STYLE LABELS, THEN NEED TO END AND CR/LF
	SKIPG	QENT+LINLAB		;IS IT THE OLD STYLE?
	 JRST	[MOVEI	B,11		;YES, ADD A TAB AND WRITE LINE
		 BOUT
		 JRST	PUTLOG]

	HRROI	B,[ASCIZ /   USED /]
	SETZ	C,
	SOUT				;ADD USED HH:MM:SS IN HH:MM:SS
	MOVE	A,JOBRT			;GET CURRENT RUN TIME
	HRL	A,JOBN			;FOR THIS JOB
	GETAB
	BUG	(<NEWLAB: GETAB ERROR ON JOBRT TABLE>)
	PUSHJ	P,TCNVRT		;GO CONVERT THIS TO HH:MM:SS
	MOVE	A,LOGJFN
	HRROI	B,[ASCIZ / IN /]
	SETZ	C,
	SOUT
	MOVE	A,LABTOD		;NOW, TOTAL ELAPSED TIME
	SUB	A,TJOBIN
	PUSHJ	P,TCNVRT		;CONVERT IT
	MOVE	A,LOGJFN
	HRROI	B, [ASCIZ /  ]  *******
/]
	SETZ	C,			;NO, FINISH NEW TYPE LABEL AND THEN
	SOUT				;WRITE THE LOG FILE LINE
		>		;END OF IMSLOG

PUTLOG:	CAIG	D,0			;ANYTHING FOR THE LOG FILE?
	POPJ	P,			;NO, JUST RETURN
	MOVE	E,1(D)			;NOW WRITE LOG FILE LINE - GET LENGTH
	MOVEI	D,2(D)			;POINT TO LINE
	HRLI	D,440700		;MAKE BYTE POINTER TO IT

	JUMPL	E,SNDLG5		;JUMP FOR ZERO BYTE TERMINATION

SNDLG2:	ILDB	B,D			;GET A CHARACTER
	JUMPE	B,.+2			;DON'T OUTPUT NULLS
	BOUT				;PUT IT OUT
	SOJG	E,SNDLG2		;LOOP UNTIL DONE

SNDLG4:	TLZE	ZZ,L.NOEL		;DOES HE WANT US TO APPEND EOL SEQ?
	POPJ	P,			;NO--SO RETURN


;SCRLF - ROUTINE TO SEND CRLF TO DESIRED FILE (JFN IN A)
;FALLEN INTO BY SNDLOG.
SCRLF:	MOVEI	B,15			;CR
	BOUT
	MOVEI	B,12			;LF
	BOUT

	POPJ	P,			;RETURN

SNDLG5:	MOVE	E,0(D)			;MAXIMUM NUMBER OF CHARACTERS IN BUFFER
SNDLG6:	ILDB	B,D
	JUMPE	B,SNDLG4		;END OF OUTPUT IF ZERO
	BOUT				;OUTPUT CHARACTER
	SOJG	E,SNDLG6
	JRST	SNDLG4			;FINISH OUTPUT


; Following is a routine to convert time in msec to HH:MM:SS and tack the
; string onto the LOG file.  Time to convert is in AC A.

TCNVRT:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C

	ADDI	A,^D500			;FIRST ROUND OFF MSEC
	IDIVI	A,^D1000
	IDIVI	A,^D60			;CONVERT TO MIN WITH REMAINDER OF SEC
	PUSH	P,B			;SAVE SECONDS
	IDIVI	A,^D60			;CONVERT TO HRS WITH REMAINDER OF MIN
	PUSH	P,B			;SAVE MINUTES
	MOVE	B,A			;FIRST OUTPUT HRS
	MOVE	A,LOGJFN
	MOVEI	C,^D10
	NOUT
	JFCL
	MOVEI	B,":"			;AND A SEPARATOR
	BOUT
	POP	P,B			;RECOVER MINUTES
	MOVE	C,[160002,,^D10]
	NOUT
	JFCL
	MOVEI	B,":"			;AND ANOTHER SEPARATOR
	BOUT
	POP	P,B			;FINALLY GET THE SECONDS
	MOVE	C,[160002,,^D10]
	NOUT
	JFCL

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER

;FIND SUBJOB STATUS - AC 1 CONTAINS PTY HANDLE ON ENTRY
;	RETURN +1 - NO JOB
;	       +2 - JOB THERE AND NOT IN EXEC
;	       +3 - JOB THERE AND IN EXEC
;
; ON RETURN, AC 1 CONTAINS SIXBIT NAME OF SUBSYS IF JOB THERE

JBST:	PUSHJ	P,TTYJ			;FIND THE JOB #
	POPJ	P,			;NO JOB HERE
	POPJ	P,			;NO JOB HERE
	JFCL				;THERE IS A JOB
	AOS	0(P)			;SKIP AT LEAST ONCE
	TLZ	A,400000		;ISOLATE JUST JOB NUMBER
	HRR	A,JOBNAM		;GET TABLE NUMBER
	GETAB				;GET TABLE ENTRY
	BUG	(<JBST: Couldn't get JOBNAM table>)
	HRLZ	A,A			;GET INDEX TO USE FOR DETERMINING STATE
	HRR	A,SNAMES		;GET TABLE #
	GETAB				;GET WHAT HE IS IN
	BUG	(<JBST: Couldn't get SNAMES table>)
	CAMN	A,[SIXBIT /EXEC/]	;ARE WE IN EXEC
	AOS	(P)			;YES, MAKE SKIP (+2)
	POPJ	P,			;RETURN

;INDEX TABLE TTYJOB TO FIND JOB# FOR THIS LINE
;AND JOB STATUS (WHETHER OR NOT IT IS IN STATE TI IN ANY FORK).
;RETURN WITH LH A 	>0 JOB #
;			OR 400000+JOB#
;			OR -1 IF UNASSIGNED LINE
;			OR -2 IF LINE IN PROCESS OF BEING ASSIGNED
;		RH A	-1 IF NO FORK WAITING FOR INPUT
;			NOT -1 SOME FORK IS WAITING FOR INPUT FROM THIS LINE
;SKIP RETURN:	+1 => UNASSIGNED LINE
;		+2 => LINE BEING ASSIGNED
;		+3 => LINE ASSIGNED AND JOB RUNNING
;		+4 => LINE ASSIGNED AND JOB IN TTY WAIT

TTYJ:	PUSH	P,B			;SAVE WORKING AC'S
	MOVE	A,TTYJOB		;GET TABLE NUMBER
	HRL	A,PTY			;GET PTY LINE # (AS INDEX)
	TLZ	A,400000		;TURN OFF THIS BIT
	GETAB				;GET JOB NUMBER AND STUFF
	BUG	(<TTYJ: Couldn't find job number>)
	HLRZ	B,A			;GET LEFT HALF INFO
	CAIN	B,-1			;IS IT -1
	JRST	TTYDON			;YES - GO CLEAN UP
	AOS	-1(P)			;NO - BUMP SKIP BY 1
	CAIN	B,-2			;IS IT -2
	JRST	TTYDON			;YES - GO CLEAN UP
	AOS	-1(P)			;NO - BUMP SKIP BY 1
	HRRZ	B,A			;GET RIGHT HALF INFO
	TRC	B,-1			;COMPLEMENT JOB STATE BITS
					;NOW A = 0 => RUNNING
	TRNN	B,-1			;IS JOB IN TTY WAIT
	JRST	TTYDON			;NO - GO CLEAN UP
	AOS	-1(P)			;YES - BUMP SKIP BY 1

TTYDON:	POP	P,B			;RESTORE AC'S

	POPJ	P,			;RETURN



;GET A PTY, RECURSIVELY CHECK FOR A JOB AT THE OTHER END
;AND GO GET ANOTHER TILL WE FIND ONE WITHOUT..
;RETURNS +1	NO PTY AVAILABLE
;	 +2	GOT A PTY DESIG IN 1

.ASPTY:	SETZ	A,			;DO SYSTEM CHECK
	ASPTY				;GO GET ONE
	POPJ	P,			;NOTHING TO GET FAIL
	MOVEM	A,PTY			;PUT IT HERE FOR TTYJ
	PUSHJ	P,JBST			;JOB AT OTHER END?
	JRST [	MOVE	A,PTY		;NO JOB, GOOD GET THE DESIGNATOR
		PUSH	P,B		;SET VALUE IN FRKPTY TABLE TOO
		MOVE	B,RELFRK
		ANDI	B,777
		MOVEM	A,FRKPTY(B)
		POP	P,B
		AOS	0(P)		;DO SKIP RETURN
		POPJ	P,]
	JFCL				;DON'T CARE WHAT STATE JOB IS IN
	MOVE	A,PTY			;GET THE DESIGNATOR
	SETZM	PTY			;CLEAR CORE VALUE
	PUSH	P,A			;AND SAVE IT TO RELEASE LATER
	PUSHJ	P,.ASPTY		;GO GET ANOTHER ONE
	JRST [	POP	P,A		;NO MORE LEFT,GET THE OLD ONE
		REPTY			;GET RID OF IT
		BUG	(<.ASPTY: REPTY (1) failed>) ;SHOULDN'T HAPPEN RIGHT?!
		POPJ	P,]		;FAIL 'CUZ THER AIN'T ANY
	EXCH	A,(P)			;GOT A GOOD ONE, RETRIEVE THE OLD 1
	REPTY				;AND GET RID OF IT
	BUG	(<.ASPTY REPTY (2) failed>)	;THIS SHOULDN'T HAPPEN EITHER--RIGHT?
	POP	P,A			;GET THE GOOD ONE
	AOS	(P)			;SKIP SAYS WE GOT A GOOD ONE
	POPJ	P,


;SUBROUTINE TO READ ONE CHARACTER FROM THE CTL FILE
;SKIPS IF THE JOB IS STILL THERE, NON-SKIP IF NO

RCCTL:	SKIPE	MODEI			;DOES HE NEED MODE CHANGE?
	JRST	RCCTL5			;YES, GO DO IT
	SOSGE	CTLLIN+1		;COUNT THE CHARACTER
	JRST	RCCTL2			;NEED TO GO READ IN A LINE
	ILDB	B,CTLLIN-1		;GET BYTE
	JUMPE	B,RCCTL			;GET RID OF NULLS
	AOS	(P)			;SKIP RETURN EVEN IF AT THIS LEVEL
	POPJ	P,			;WE DON'T REALLY KNOW

RCCTL2:	PUSHJ	P,RDCTL			;GO DO ACTUAL READ
	TRNN	ZZ,R.SEMI		;WAS LINE A COMMENT
	JRST	RCCTL3			;NO
	SOS	CTLLIN+1		;DROP OFF END OF LINE CHAR
	MOVEI	D,CTLLIN		;POINT TO INPUT BUFFER
	MOVE	C,[SIXBIT /USER/]	;GIVE LINE TYPE
	PUSHJ	P,SNDLOG		;SEND LINE TO LOG FILE
	JRST	RCCTL2			;GO READ ANOTHER LINE FROM CTL FILE

RCCTL3:	TRNN	ZZ,R.BLNK		;DOES HE WANT BLANK LINE ON LOG FILE?
	JRST	RCCTL4			;NO
	MOVE	C,[SIXBIT /USER/]	;GIVE RECORD TYPE
	MOVEI	D,BLANKL		;A BLANK LINE
	TLO	ZZ,L.NOEL		;DON'T APPEND CRLF
	PUSHJ	P,SNDLOG		;SEND IT TO LOG FILE
	JRST	RCCTL2			;GET ANOTHER LINE

RCCTL4:	TRZE	ZZ,R.PCTF		;DID WE GET ANY RESOURCE CONTROL STUFF
	PUSHJ	P,SETPCT		;YES, GO SET IT
	MOVEM	ZZ,MODEI		;SAVE CURRENT MODE

RCCTL5:	MOVE	ZZ,MODEI		;GET CURRENT MODE
	TRNE	ZZ,R.INTR		;INTERMEDIATE MODE WILL
					;GO WITH ANY JOB MODE
	JRST	RCCTL6			;IS AT INTERMEDIATE LEVEL.

	PUSHJ	P,JBST			;GET JOB STATUS
	POPJ	P,			;NO JOB, NON-SKIP RETURN
	JRST	RCCTL7			;HE IS USER LEVEL
	JRST	RCCTL8			;HE IS AT EXEC LEVEL

RCCTL6:	SETZM	MODEI			;CLEAR MODE REQUIREMENTS
	JRST	RCCTL			;GO GET THE INPUT

;AT USER LEVEL, DID CTL FILE WANT EXEC (MONITOR) LEVEL?
RCCTL7:	TRNN	ZZ,R.MONC		;DO WE WANT MONITOR?
	JRST	RCCTL6			;NO, BE HAPPY WITH THIS

;CHANGE LEVEL TO EXEC FROM USER BY GIVING A ^C
	MOVEI	B,"C"-100		;SET CHAR TO ^C
	AOS	(P)			;JOB STILL HERE, SKIP RETURN
	POPJ	P,			;RETURN

;AT MONITOR (EXEC) LEVEL, WHAT DID CTL FILE WANT?
RCCTL8:	TRNE	ZZ,R.USER		;DO WE WANT USER LEVEL?
	JRST	RCCTL9			;YES, TOO BAD.  FLUSH TO NEXT EXEC COMMAND
	SKIPL	CEXCSW			;EXEC IS FINE - OTHERS KNOW YET?
	SETOM	LSTCHK			;NO, MAKE SURE THEY CHECK
	JRST	RCCTL6

;HERE WE MUST FLUSH FOR A MONITOR LEVEL LINE.
;AS WE HAVE FOUND SUBJOB AT EXEC, INPUT IN USER MODE
RCCTL9:	PUSHJ	P,RDCTL			;GET A LINE
	TRNN	ZZ,R.MONC		;IS IT MONITOR LEVEL?
	JRST	RCCTL9			;NO
	JRST	RCCTL2+1		;YES-GO INTERPET IT.
;SUBROUTINE TO READ AND CLASSIFY A LINE FROM CTL FILE
RDCTL:	TRZ	ZZ,R.RCTL		;TURN OFF THE FLAGS WE WILL USE
	SETZM	CTLLIN+1		;ZERO COUNT OF CHARS READ
	MOVE	A,[POINT 7,CTLLIN+2]	;RESET POINTER TO LINE START
	MOVEM	A,CTLLIN-1		;WHERE WE USE IT

;READ A LINE FROM CTL FILE
	MOVE	A,CTLJFN		;GET THE JFN FOR INPUT FILE
	MOVE	C,[POINT 7,CTLLIN+2]	;POINT TO THE LINE
	MOVE	D,CTLLIN		;GET THE NUMBER OF CHARACTERS
					;THAT WE HAVE ROOM FOR.
RDLP:	BIN				;GET A CHARACTER
	IDPB	B,C			;STORE CHARACTER
	PUSHJ	P,SKEOL			;WAS IT EOL
	JRST	.+2			;NOT EOL
	SOJA	D,RDLPEL		;COUNT CHARACTER AND CONTINUE
	SOJG	D,RDLP			;COUNT CHARACTER AND LOOP

;ERROR HERE--INPUT LINE IS TOO LONG FOR OUR BUFFER
	ERROR	(<INPUT LINE TOO LONG FOR BUFFER>,ABEND)


;WE HAVE READ AN END OF LINE
RDLPEL:	SUB	D,CTLLIN		;COMPUTE HOW MUCH WAS IN LINE
	MOVMM	D,CTLLIN+1		;SAVE # CHARS WE HAVE STORED
	CAIE	B,15			;WAS IT A CR?
	JRST	RDEX1			;NO--GO EXAMINE LINE
	BIN				;READ THE LF
	CAIN	B,12			;WAS IT REALLY A LF?
	JRST RDEX1			;YES
	BKJFN				;NO--PUT IT BACK
					;THIS MAKES IT IMPOSSIBLE TO HAVE
					;CR NOT FOLLOWED BY LF IF THE CTL
					;FILE IS FROM DECTAPE OR SOMETHING
					;ELSE THAT WON'T ALLOW BKJFN
	ERROR	(<RDLPEL: BKJFN failed.>,ABEND)		;DROP THE JOB
RDEX1:	MOVE	A,[POINT 7,CTLLIN+2]	;POINT TO LINE AGAIN
	MOVE	C,CTLLIN+1		;GET NUMBER OF CHARACTERS WE HAVE
RDEX2:	ILDB	B,A			;GET A CHAR
	CAIE	B,40			;SPACE OR
	CAIN	B,11			;TAB?
	JRST	.+2			;YES--SKIP OVER IT
	JRST	RDEX3			;NO--GOT SIGNIFIGANT CHARACTER
	SOJG	C,RDEX2			;EXAMINE NEXT CHARACTER IF MORE
	JRST	RDDUN			;GOTTA FILL IN ADDR--SEND LINE
					;IT HAS NO NON SPACE OR TAB CHARACTERS
RDEX3:	CAIN	B,"."			;DOES LINE START WITH A . ?
	JRST	EXPT			;YES
	CAIN	B,"@"			;DOES LINE START WITH A @ ?
	JRST	EXAT			;YES
	CAIN	B,"*"			;DOES LINE START WITH A * ?
	JRST	EXSTAR			;YES
	CAIN	B,";"			;DOES LINE START WITH A ; ?
	JRST	EXSEMI			;YES
	CAIN	B,"!"			;DOES LINE START WITH A ! ?
	JRST	EXSEMI			;YES (SAME AS ;)
	CAIN	B,"="			;DOES LINE START WITH A = ?
	JRST	EXEQ			;YES
	CAIN	B,"$"			;DOES LINE START WITH A $ ?
	JRST	EXDOLR			;YES
	CAIN	B,"%"			;DOES LINE START WITH A % ?
;	ERROR	(<% IS RESERVED FOR BATCH SYSTEM LABELS--CONTINUING>)
	JRST	EXPCT			;YES

;FALL THROUGH TO FLAG AS NOT SPECIAL
RDEX4:	TRO	ZZ,R.INTR		;SAY THAT LINE IS NEITHER SPECIFICALLY
					;DESTINED FOR MONITOR OR USER LEVEL
	JRST	RDTR2			;GO TAKE CARE OF ^'S, STARTING WITH
					;THIS CHARACTER IN B

EXPCT:	MOVE	D,[POINT 7,STRBUF]	;% MEANS SET RESOURCE LIMIT CONTROLS
					;FIRST ISOLATE COMMAND AFTER BLANKS
					;AND TABS
PCTSBL:	SOJLE	C,PCTERR		;ERROR - NOTHING BUT BLANKS
	ILDB	B,A			;NEXT CHAR
	PUSHJ	P,SKEOL			;EOL CHAR?
	SKIPA				;NO
	JRST	PCTERR			;YES - EMPTY LINE
	CAIN	B," "			;BLANK?
	JRST	PCTSBL			;YES, SKIP IT
	CAIN	B,11			;TAB?
	JRST	PCTSBL			;YES, SKIP IT

PCTCOM:	CAIL	B,"a"			;GOOD COMMAND CHAR - CONVERT TO
	CAILE	B,"z"			;UPPER CASE AND SAVE IT
	SKIPA
	SUBI	B,"a"-"A"
	IDPB	B,D
	SOJLE	C,PCTCPR		;END - RECOGNIZE COMMAND?
	ILDB	B,A			;NEXT CHAR
	PUSHJ	P,SKEOL			;EOL?
	SKIPA				;NO
	JRST	PCTCPR			;YES - RECOGNIZE COMMAND?
	CAIN	B," "			;BLANK?
	JRST	PCTCPR			;YES - RECOGNIZE COMMAND?
	CAIN	B,11			;TAB?
	JRST	PCTCPR			;YES - RECOGNIZE COMMAND?
	JRST	PCTCOM			;MORE CHARACTERS IN COMMAND

PCTCPR:	PUSH	P,A			;SAVE PTR INTO INPUT STRING
	PUSH	P,C			;SAVE REMAINING CHAR COUNT
	SETZ	B,			;MAKE COMMAND STRING ASCIZ
	IDPB	B,D
	MOVSI	C,-NLMTSW		;NUMBER OF POSSIBLE COMMANDS
	SETZ	D,			;NUMBER OF HITS
	SETZ	E,			;INDEX OF LAST HIT
PCTCP0:	MOVE	A,[POINT 7,STRBUF]	;INPUT "COMMAND" STRING
	HRRZ	B,C			;PTR TO COMMAND LIST
	LSH	B,1
	HRRZ	B,LMTSGL(B)
	HRLI	B,440700
	PUSHJ	P,STRCMP		;COMPARE THEM
	JRST	PCTCP1			;NO MATCH - TRY NEXT ONE
	JFCL
	AOJ	D,			;BUMP HIT COUNT
	HRRZ	E,C			;SAVE INDEX
PCTCP1:	AOBJN	C,PCTCP0		;TRY THEM ALL

	CAIE	D,1			;UNIQUE MATCH?
	JRST	PCTERR			;NO - POST ERROR
	POP	P,C			;RECOVER CHAR COUNT
	POP	P,A			;AND INPUT STRING POINTER
PCTLET:	SOJLE	C,PCTLT0		;NOW FIND THE CONTROL CHARACTER
	ILDB	B,A			;NEXT CHAR
	PUSHJ	P,SKEOL			;EOL
	SKIPA				;NO
	JRST	PCTLT0			;YES - SET NULL
	CAIN	B," "			;BLANK?
	JRST	PCTLET			;YES - GET NEXT ONE
	CAIN	B,11			;TAB?
	JRST	PCTLET			;YES - GET NEXT ONE
	SKIPA				;NON-SEPARATOR LETTER, TEST IT

PCTLT0:	MOVEI	B,"@"			;NO CHAR SPECIFIED - DEFAULT NULL
	TRNN	B,100			;IN RIGHT ALPHA RANGE?
	JRST	PCTERR			;NO - FLAG ERROR
	TRZ	B,140			;YES, MAKE IT A CONTROL CHARACTER

	TRNE	ZZ,R.PCTF		;IS THIS A NEW RESOURCE CTL SETTING?
	JRST	PCTLT1			;NO, DON'T CLEAR THINGS OUT
	SETO	C,			;YES, CLEAR OUT TEMP STORAGE FOR 
	HRLM	C,CPUCHR		;NEW CHARS 
	HRLM	C,RUNCHR
	HRLM	C,LINCHR
	TRO	ZZ,R.PCTF		;SET FLAG FOR RESOURCE SETTINGS

PCTLT1:	LSH	E,1			;GO STORE IT
	JRST	@LMTSGL+1(E)

DEFSET:	SKIPGE	CPUCHR			;SET ANY CHARACTERS NOT YET SET
	HRLM	B,CPUCHR
	SKIPGE	RUNCHR
	HRLM	B,RUNCHR
	SKIPGE	LINCHR
	HRLM	B,LINCHR
	JRST	RDCTL			;GET ANOTHER LINE

CPUSET:	HRLM	B,CPUCHR		;SET CPU OVERRUN CHARACTER
	JRST	RDCTL			;GET ANOTHER LINE

RUNSET:	HRLM	B,RUNCHR		;SET ELAPSED TIME CHARACTER
	JRST	RDCTL			;GET ANOTHER LINE

LINSET:	HRLM	B,LINCHR		;SET LOG OVERRUN CHARACTER
	JRST	RDCTL			;GET ANOTHER LINE

PCTERR:	HRROI	A,STRBUF		;SOMETHING WRONG - OUTPUT ERROR MSG
	HRROI	B,[ASCIZ / *** INVALID RESOURCE LIMIT SIGNAL - IGNORED:  /]
	SETZ	C,
	SOUT
	MOVE	C,[POINT 7,CTLLIN+2]	;PTR TO INPUT LINE
	MOVE	D,CTLLIN+1		;NUMBER OF CHARACTERS
PCTER0:	ILDB	B,C			;TRANSFER ONE
	IDPB	B,A			;TO ERROR STRING
	SOJG	D,PCTER0		;DO THEM ALL
	SETZ	B,			;MAKE RESULT ASCIZ
	IDPB	B,A

	ERR1	[0,,STRBUF]		;SEND ERROR MESSAGE TO LOG FILE
	JRST	RDCTL			;GET ANOTHER INPUT LINE


EXSEMI:	TRO	ZZ,R.SEMI		;SAY IT IS A COMMENT
;	JRST	RDTR			;GO TRANSILATE ^'S, STARTING WITH NEXT
	JRST	RDDUN			;CHARACTER.  WOULD GO TO RDDUN IF WE
					;DON'T WANT TO TRANSILATE COMMENT LINES

EXDOLR:	MOVE	D,A			;SAVE LOCATION OF $
	ILDB	B,D			;GET NEXT CHARACTER
	PUSHJ	P,SKALPH		;SKIP IF ALPHA CHAR IN B
	JRST	.+2			;NOT ALPHA
	JRST	EXSEMI			;TREAT THIS LINE AS A COMMENT
	CAIN	B,"$"			;IS NEXT CHAR ANOTHER $ ?
	JRST	EXSTAR			;YES, DELETE FIRST CHAR, THEN
					;CONTINUE WITH THIS AT USER LEVEL
	CAIE	B,12			;IS CHAR AFTER $ A LF?
	CAIN	B,13			;IS CHAR AFTER $ A VT?
	JRST	EXBLNK			;YES--GO SET R.BLNK
	CAIN	B,14			;IS CHAR AFTER $ A FF?
	JRST	EXBLNK			;YES--GO SET R.BLNK

;HERE WHEN WE HAVE A DATA LINE TO LEAVE AS IT IS.
EXDATA:	TRO	ZZ,R.USER		;SAY IT IS USER LEVEL
	JRST	RDTR2			;GO TRANSILATE--INCLUDE THIS CHAR IN B

EXBLNK:	TRO	ZZ,R.BLNK		;SAY BLANK LINE
	JRST	RDDUN			;JUST RETURN--THIS IS REALLY SIMPLE

EXPT:	MOVE	D,A			;GET POINTER TO CURRENT CHARACTER
	ILDB	B,D			;GET NEXT CHARACTER
	CAIL	B,"0"			;IS THE NEXT CHAR A DIGIT
	CAILE	B,"9"
	JRST	EXAT			;NO - TREAT AS "@"
	JRST	EXDATA			;YES - TREAT IT AS USER DATA
;;;	PUSHJ	P,SKALPH		;SKIP IF ALPHA CHAR
;;;	JRST	EXDATA			;IF NOT, TREAT AS DATA AS IS
					;IF SO, FALL THROUGH TO EXAT
					;WHICH WILL STRIP THE FIRST CHAR
					;AND MAKE US MONITOR MODE

EXAT:	TRO	ZZ,R.MONC		;SAY A MONITOR (EXEC) LEVEL COMMAND
	JRST	EXDELC			;GO DELETE THE FIRST CHARACTER

EXSTAR:	TRO	ZZ,R.USER		;USER COMMAND
	JRST	EXDELC			;GO DELETE FIRST CHARACTER

EXEQ:	TRO	ZZ,R.USER!R.SEOL	;USER DATA, MUST SUPPRESS END OF LINE

EXDELC:	SETZ	D,			;COMMON ROUTINE TO NULL OUT THE
	DPB	D,A			;FIRST CHARACTER TO DESTROY IT
;TRANSLATE THE ^'S INTO THE APPROPRIATE CODES
RDTR:	SOJLE	C,RDTREX		;ARE WE DONE?
	ILDB	B,A			;NO--GET ANOTHER CHAR
RDTR2:	CAIE	B,"^"			;IS THIS CHAR AN ^ ?
	JRST	RDTR			;CONTINUE IF NOT
	MOVE	D,A			;SAVE WHERE IT WAS.
RDTR3:	SOJLE	C,RDTREX		;ARE WE DONE NOW?
	ILDB	B,A			;IF NOT, CONTINUE BY GETTING NEXT CHAR
	CAIN	B,"^"			;ANOTHER ^ ?
	JRST	RDTRUP			;YES.
;	PUSHJ	P,SKALPH		;CHECK IF IT IS ALPHA
	TRNN	B,100			;TEST IF ALPHA OR SUCH
	JRST	RDTR			;NO, SO LEAVE IT AS IS
	TRZ	B,140			;FORCE IT TO A CONTROL CHARACTER
	DPB	B,A			;STORE IT BACK WHERE WE GOT IT
	SETZ	B,			;AND DESTROY THE ^ THAT PRECEEDED IT
	DPB	B,D			;BY DUMPING A NULL ON TOP OF IT
	JRST	RDTR			;CONTINUE TO TRANSILATE

RDTRUP:	SETZ	B,			;DESTROY THE FIRST ^ BY DROPPING
	DPB	B,D			;A NULL ON TOP OF IT
;	JRST	RDTR3			;GO BACK IF ^^^^ MEANS ^^^ (DEC'S WAY)
	JRST	RDTR			;GO BACK IF ^^^^ MEANS ^^ (FORTRAN WAY)

RDTREX:	TRNN	ZZ,R.SEOL		;DO WE WANT TO SUPPRESS EOL STUFF?
	JRST	RDDUN			;NO--GO TO DONE ROUTINE
	SOS	CTLLIN+1		;DELETE THE TERMINATOR CHARACTER
	MOVE	A,[POINT 7,CTLLIN+2]	;POINT TO LINE
	MOVE	C,CTLLIN+1		;GET # CHARS TO DO
RDSCL:	ILDB	B,A			;GET CHARACTER
	JUMPE	B,RDSCLE		;IGNORE NULLS FOUND IN LINE
	CAIN	B," "			;IS IT BLANK?
	JRST	.+2			;SKIP IF EITHER
	MOVN	D,C			;GET COUNT HERE
RDSCLE:	SOJG	C,RDSCL			;COUNT CHARS AND LOOP
	AOJ	D,			;FUDGE SO THE ADDM GIVES RIGHT RESULT
	ADDM	D,CTLLIN+1		;COMPUTE NEW LENGTH FOR LINE

RDDUN:	POPJ	P,			;RETURN TO CALLER
;ROUTINE TO UPDATE RESOURCE CONTROL SETTINGS
SETPCT:	PUSH	P,A			;SAVE AC
	TRNE	ZZ,R.MONC		;IS THE NEXT INPUT AN EXEC COMMAND?
	JRST	SETPC1			;YES, GO DO IT
SETPC0:	SKIPL	A,CPUCHR		;NO NEW EXEC COMMAND - UPDATE CTLS
	HLRZ	A,A			;NEW CHAR HERE - STORE IT
	HRRZM	A,CPUCHR
	SKIPL	A,RUNCHR
	HLRZ	A,A			;NEW CHAR HERE - STORE IT
	HRRZM	A,RUNCHR
	SKIPL	A,LINCHR
	HLRZ	A,A			;NEW CHAR HERE - STORE IT
	HRRZM	A,LINCHR
	JRST	SETPC2

SETPC1:	SKIPE	CEXCSW			;HAVE WE BEEN IN EXEC?
	JRST	SETPC0			;YES, ONLY DO UPDATE
	SKIPGE	A,CPUCHR		;NO, UPDATE EVERYTHING.  CLEAR IT IF
	SETZ	A,			;NO NEW SPECIFICATION
	HLRZM	A,CPUCHR
	SKIPGE	A,RUNCHR
	SETZ	A,			;NO NEW SPECIFICATION
	HLRZM	A,RUNCHR
	SKIPGE	A,LINCHR
	SETZ	A,			;NO NEW SPECIFICATION
	HLRZM	A,LINCHR

SETPC2:	POP	P,A			;RESTORE AC

	POPJ	P,			;RETURN




;SKIP IF END OF LINE CHARACTER IN B
SKEOL:	CAIE	B,15			;CR
	CAIN	B,12			;LF
	JRST	SKEOLS			;YES-GOT AN EOL

	CAIE	B,13			;VT
	CAIN	B,14			;FF
	JRST	SKEOLS			;YES-GOT SOME EOL

	CAIN	B,37			;EOL
SKEOLS:	AOS	(P)			;SET SKIP
	POPJ	P,			;RETURN

;SKIP IF AN ALPHA CHAR IN B
SKALPH:	CAIGE	B,"A"			;COULD IT BE UPPER CASE?
	POPJ	P,			;FAIL, CODE IS TOO LOW
	CAIG	B,"Z"			;IS IT IN RANGE FOR UPPER CASE?
	JRST	SSALPH			;YES-SUCCEED
	CAIGE	B,"A"+40		;IS IT LOWER CASE?
	POPJ	P,			;NO-TOO LOW TO BE LC.
	CAIG	B,"Z"+40		;IS IT IN LC RANGE?
SSALPH:	AOS	(P)			;SUCCESS-SET SKIP
	POPJ	P,			;RETURN




;ROUTINE TO COMPARE TWO ASCIZ STRINGS.
;ON ENTRY	A = STRING PTR FOR 1ST
;		B = STRING PTR FOR 2ND
;
;RETURNS	+1 IF THERE IS A NON-MATCHING CHARACTER
;		+2 IF THEY MATCH, BUT NOT THE SAME LENGTH
;		+3 PERFECT MATCH
;
;UPDATED PTRS IN A AND B

STRCMP:	PUSH	P,C			;SAVE WORKING AC'S
	PUSH	P,D

STRLOP:	ILDB	C,A			;GET NEXT CHAR OF 1ST
	ILDB	D,B			;GET NEXT CHAR OF 2ND
	CAME	C,D			;ARE THEY EQUAL
	JRST	STREND			;NO - CHECK IF ONE ENDED
	SKIPE	C			;WAS THAT THE END
	JRST	STRLOP			;NO GET THE NEXT ONE

	JRST	STRRT3			;WE HAVE A PERFECT MATCH, RETURN +3

STREND:	SKIPE	C			;IS ONE OF THEM AT AN END?
	SKIPN	D			;NOT FIRST, TRY SECOND
	JRST	STRRT2			;YES, RETURN +2
	JRST	STRRT1			;NO, RETURN +1

STRRT3:	AOS	-2(P)			;RETURN +3
STRRT2:	AOS	-2(P)			;RETURN +2
STRRT1:	POP	P,D			;RESTORE AC'S
	POP	P,C

	POPJ	P,			;RETURN



;LUUO ROUTINES
LUUOI:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E
	MOVE	A,40			;GET TRAP CAUSE
	ROT	A,^D9			;GET IT'S OPCODE
	ANDI	A,777			;ISOLATE OP CODE
	CAILE	A,NUMUUO		;IS IT ONE WE SPECIFIED?
	JRST	BADUUO			;NO, BUG HALT

	JRST	@UUODSP-1(A)		;TRANSFER TO ROUTINE
UUODSP:	ERRLOG				;ROUTINE TO HANDLE ERR1 UUO
	REPEAT	<NUMUUO-<.-UUODSP>>,<
	JRST	BADUUO
	>		;END REPEAT PSEUDO-OP
BADUUO:	BUG	(<LUUOI: NO DISPATCH ENTRY FOR UUO>)

ERRLOG:	MOVE	A,@40			;GET WORD WITH ADDRESSES
	HRLI	A,440700		;MAKE BYTE POINTER
	MOVE	B,[POINT 7,MSGLIN+2]	;DESTINATION STRING
	SETZM	MSGLIN+1		;INIT COUNT
	ILDB	C,A			;GET CHAR
	JUMPE	C,.+4			;OUT IF DONE
	IDPB	C,B			;STORE CHAR
	AOS	MSGLIN+1		;COUNT CHAR
	JRST	.-4			;GO AGAIN
	MOVE	C,[SIXBIT /BAERR/]	;ERROR
	MOVEI	D,MSGLIN		;POINT TO LINE
	PUSHJ	P,SNDLOG		;WRITE IT ON LOG FILE

	HLRZ	A,@40			;GET RETURN ADDR
	JUMPE	A,LUUORE		;GO RETURN IF NONE SPECIAL
	HRRM	A,-5(P)			;RESET REUTURN ADDR IF ONE GIVEN

LUUORE:	POP	P,E			;RESTORE THE REGISTERS
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,			;RETURN



	IFN	GDDT,<
;	SET UP^D EVOCATION OF DDT
SETDDT:	MOVEI	A,400000	;FORK HANDLE
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	MOVE	A,[XWD 4,0]	;;^D
	ATI
	MOVEI	A,400000
	MOVE	B,[XWD 400000,0]	;ACTIVATE CHANNEL 0
	AIC
	OKINT
	IIC
	POPJ	P,
STDDT:	HRROI	A,[ASCIZ /GOING INTO DDT - TYPE RESM$G TO RESUME
/]
	PSOUT
	JRST	DDT##
RESM:	DEBRK
	>



; THE FOLLOWING ROUTINE SETS UP TO HANDLE A BUG CALL.  THE JSR HERE
; STORES THE ADDRESS OF AN ENTRY IN THE BUG PARAMETER LIST AT BUGSTP
; AS MARKED BY => IN THE FOLLOWING LAYOUT OF THE BUG MACRO:
;
;	JSR	[<address of BUG call + 1>
;		 JSR	BUGSTP
;		 <address of BUG message string>
;		 <0 or return address from BUG>]

BUGSTP:	0
	DMOVEM	A,TMPACS		;SAVE WORKING AC'S
	MOVE	B,BUGSTP		;SAVE THE BUG LOCATION
	MOVE	A,-2(B)
	MOVEM	A,BUGLOC
	DMOVE	A,0(B)			;AND THE MSG AND RETURN ADDRESSES
	DMOVEM	A,BUGMAD		;AS WELL.

	JRST	BUGMSG			;NOW GO PROCESS BUG CALL


; This is a routine to put entries in DAYFILE.ENTRIES and to
; notify/message users of happenings related to their jobs.  The
; text formats output are as described in the routines DAY, NOTIFY,
; and SEND.  On entry:
;
;	AC  B	= String pointer to <tail> or an index into the
;		  FINMSG, FINNOT, and FINDAY tables for the
;		  appropriate <tail>
;
;	    C	= String pointer to <appendix> or 0 if none
;		  (In addition, DAYTRM, NOTTRM, and MSGTRM are
;		   appended to the string in C before output)
;
;  FLNMSW is set to -1 to give all ctl file information.  Thus the
; routine assumes that QENT contains valid information for USRDIR,
; BJOBNO, CTLFIL, NOTFY, and MESAG.
;
; MSGBUF is used to assemble the <appendix> part of the message and
; the page is unmapped at the end of the call.

WINFRM:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D

	SETOM	FLNMSW
	HRROI	A,MSGBUF		;FIRST SEND DAYFILE MESSAGE
	SETZ	C,
	SKIPE	B,-1(P)			;IF ANY <appendix>, ADD IT
	SOUT
	HRROI	B,DAYTRM		;ADD DAY TERMINATOR STRING
	SOUT
	HRROI	B,JOBDAY		;NOW DO DAYFILE ENTRY
	MOVE	C,-2(P)
	TLNN	C,-1			;IS <tail> A STR POINTER?
	HRROI	C,@CNDDAY(C)		;NO, THEN INDEX FINDAY
	HRROI	D,MSGBUF
	PUSHJ	P,DAY

	SKIPN	QENT+NOTFY		;DOES HE WANT TO BE NOTIFIED?
	JRST	WINCHK			;NO, SEE ABOUT A MESSAGE
	HRROI	A,MSGBUF		;OK, MAKE NOTIFY <appendix>
	SETZ	C,
	SKIPE	B,-1(P)			;IF ANY <appendix>, ADD IT
	SOUT
	HRROI	B,NOTTRM		;ADD NOTIFY TERMINATOR STRING
	SOUT
	HRROI	B,JOBNOT		;NOW TRY TO NOTIFY THE USER
	MOVE	C,-2(P)
	TLNN	C,-1			;IS <tail> A STR POINTER?
	HRROI	C,@CNDNOT(C)		;NO, THEN INDEX FINNOT
	HRROI	D,MSGBUF
	PUSHJ	P,NOTIFY
	JRST	WINSND			;NO ONE THERE, SO SEND A MESSAGE

WINCHK:	SKIPN	QENT+MESAG		;WANT A MESSAGE TOO?
	JRST	WINMAP			;NO, GO UNMAP THE BUFFER
WINSND:	HRROI	A,MSGBUF		;OK, MAKE SNDMSG <appendix>
	SETZ	C,
	SKIPE	B,-1(P)			;IF ANY <appendix>, ADD IT
	SOUT
	HRROI	B,MSGTRM		;ADD SEND TERMINATOR STRING
	SOUT
	HRROI	B,JOBMSG		;NOW SEND HIM THE MESSAGE
	MOVE	C,-2(P)
	TLNN	C,-1			;IS <tail> A STR POINTER?
	HRROI	C,@CNDMSG(C)		;NO, THEN INDEX FINMSG
	HRROI	D,MSGBUF
	PUSHJ	P,SEND

WINMAP:	SETO	A,			;NOW UNMAP THE BUFFER PAGE
	MOVE	B,[400000,,MSGBUF/1000]
	SETZ	C,
	PMAP

	POP	P,D			;RESTORE AC'S
	POP	P,C
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER


;NOTIFY USER WITH MESSAGE OF THE FORM:
;  (header) (job #), (ctl file) (tail) (time stamp) (appendix)
;		     (dir name)
;  ON ENTRY AC	2 = STRING PTR TO (header)
;		3 = STRING PTR TO (tail)
;		4 = STRING PTR TO (appendix)
;
;  FOR FLNMSW = -1,  OUTPUT (ctl file)
;		 0,	    (dir name)
;
;  RETURNS  +1  IF NO ONE FOUND TO NOTIFY
;	    +2  IF NOTIFICATION SENT
;
NOTIFY:	PUSH	P,A		;SAVE AC'S
	PUSH	P,E
	PUSH	P,F
	PUSH	P,D
	PUSH	P,C		;SAVE MESSAGE PTRS: B = JOBNOT AND
	PUSH	P,B		;C = STRNOT OR FINNOT

	SETZ	E,		;COUNT OF TTY'S NOTIFIED
	HLLZ	F,JOBDIR	;AOBJN POINTER FOR FETCHING JOBDIR ENTRIES
NOTLOP:	MOVE	A,JOBDIR	;GET JOBDIR TABLE NUMBER
	HRL	A,F		;TACK IN JOB INDEX
	GETAB			;GET DIRECTORY INFO FOR THIS JOB
	BUG	(<NOTIFY: GETAB ERROR ON JOBDIR>)
	HRRZ	A,A		;ISOLATE LOGIN DIRECTORY NUMBER
	CAME	A,QENT+USRDIR	;IS THIS JOB OURS ?
	JRST	NOTND1		;NO, EXAMINE NEXT

	MOVE	A,JOBTTY	;YES, FIND TTY CONTROLLING JOB
	HRL	A,F		;TACK IN JOB INDEX
	GETAB
	BUG	(<NOTIFY: GETAB ERROR ON JOBTTY>)
	HLRE	A,A		;ISOLATE TTY NUMBER
	JUMPLE	A,NOTND1	;IGNORE IF DETACHED OR TTY0

	MOVE	B,[PTYRNG]	;GET PTY RANGE DATA (-#, STARTING LINE)
	HLRE	C,B		;STRIP NEG COUNT
	HRRZ	B,B		;STRIP FIRST TTY#
	MOVM	C,C
	ADD	C,B		;LAST PTY # + 1
	CAML	A,B		;BELOW BOTTOM OF RANGE?
	CAML	A,C		;NO, BELOW TOP?
	SKIPA			;NO, THEN SEND TO THIS GUY
	JRST	NOTND1		;THIS IS A PTY, IGNORE IT

	TRO	A,1B18		;MAKE INTO TTY DESIGNATOR
	RFMOD			;SEE IF HE IS TAKING LINKS
	TRNN	B,1B26
	JRST	NOTND1		;NOT ON THIS LINE
	RFCOC			;OK, MAKE CRLF'S COME OUT RIGHT
	PUSH	P,B		;SAVE THE CURRENT ONES
	PUSH	P,C
	TRNE	B,3B21+3B27	;IF HE DOES ANYTHING WITH CR AND LF
	JRST	NOTOUT		;GO NOTIFY HIM LIKE HE IS
	IORI	B,2B21+2B27	;OTHERWISE, SEND THEM LIKE THEY ARE
	SFCOC

NOTOUT:	MOVE	B,-2(P)		;SET UP MESSAGE PARTS
	MOVE	C,-3(P)
	MOVE	D,-4(P)
	PUSHJ	P,PRINT		;PRINT NOTIFY MESSAGE

	POP	P,C		;NOW RECOVER THE TTY COC'S
	POP	P,B
	TRNN	B,3B21+3B27	;AND IF CRLF WAS OFF
	SFCOC			;TURN THEM OFF AGAIN
	AOJ	E,		;BUMP TTY'S NOTIFIED COUNT

NOTND1:	AOBJN	F,NOTLOP	;LOOK AT ALL ACTIVE JOBS

	CAIE	E,0		;ANYONE FOUND?
	AOS	-6(P)		;YES, RETURN +2

	POP	P,B		;RESTORE AC'S
	POP	P,C
	POP	P,D
	POP	P,F
	POP	P,E
	POP	P,A

	POPJ	P,		;RETURN

;MESSAGE PRINTOUT FOR NOTIFY AND DAYFILE OF THE FORM
;
;  (header) (job #), (ctl file) (tail) (time stamp) (appendix)
;		     (dir name)
;  ON ENTRY AC	1 = JFN OF OUTPUT FILE
;		2 = STRING PTR TO (header)
;		3 = STRING PTR TO (tail)
;		4 = STRING PTR TO (appendix)
;
;  FOR FLNMSW = -1,  OUTPUT (ctl file)
;		 0,	    (dir name)

PRINT:	PUSH	P,A		;SAVE AC'S
	PUSH	P,B
	PUSH	P,C

	SETZ	C,		;WRITE HEADER PART
	SOUT

	MOVE	B,QENT+BJOBNO	;WRITE JOB NUMBER
	MOVEI	C,^D10		;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ /, /]
	SETZ	C,
	SOUT

	SKIPL	FLNMSW			;IF FLNMSW = -1, DO CTL FILE
	JRST	PRINT0			;ELSE, DO DIRECTORY NAME

	HRROI	B,QENT+CTLFIL		;CTL FILE NAME PTR
	SETZ	C,
	SOUT
	JRST	PRINT1

PRINT0:	MOVEI	B,"<"			;OUTPUT DIRECTORY NAME
	BOUT
	HRRZ	B,QENT+USRDIR
	DIRST
	JFCL				;ERROR - IGNORE IT
	HRROI	B,[ASCIZ />,/]
	SETZ	C,
	SOUT

PRINT1:	MOVE	B,0(P)			;NOW WRITE TAIL OF MESSAGE
	SETZ	C,
	SOUT
	HRROI	B,-1			;TACK ON CURRENT DATE/TIME
	MOVSI	C,245201
	ODTIM

	MOVE	B,D			;AND FINALLY THE APPENDIX
	SETZ	C,
	SOUT

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER




;ROUTINE TO MAKE DAYFILE, RECORD OF ENTRIES STARTED, COMPLETED, AND
;PARTICULAR TROUBLES, BATCH RESTARTS, CONTROL COMMANDS, ETC.  EACH
;ENTRY IS PUT AT THE START OF DAYFILE.ENTRIES AND HAS THE FORM:
;
;  (header) (job #), (ctl file) (tail) (time stamp) (appendix)
;		     (dir name)
;  ON ENTRY AC	1 = anything
;		2 = STRING PTR TO (header)
;		3 = STRING PTR TO (tail)
;		4 = STRING PTR TO (appendix)
;
;  FOR FLNMSW = -1,  OUTPUT (ctl file)
;		 0,	    (dir name)

DAY:	AOSN	DAYLCK			;ANYONE ELSE HERE - AVOID FILE CONFLICT
	JRST	DAY0			;NO - GO AHEAD
	PUSH	P,A
	MOVEI	A,^D10000		;WAIT 10 SEC
	DISMS
	POP	P,A
	JRST	DAY			;TRY AGAIN

DAY0:	PUSH	P,A			;SAVE WORKING AC'S
	PUSH	P,B

	MOVE	A,RELFRK		;SAY WHO WE ARE
	MOVEM	A,WHODAY

	HRROI	A,DAYBUF		;WRITE MESSAGE IN DAYBUF
	PUSHJ	P,PRINT

	HRROI	A,DAYNAM		;THEN STICK IT IN THE DAYFILE
	HRROI	B,DAYBUF
	PUSHJ	P,FILPRF

DAYEND:	POP	P,B			;RESTORE AC'S
	POP	P,A

	SETOM	WHODAY			;RELEASE ROUTINE
	SETOM	DAYLCK

	POPJ	P,			;RETURN

;SRI MESSAGE SENDING CODE TO INFORM SUBMITTER OF JOB STATUS.  MESSAGE
;HAS THE FORM:
;
;   TO: directory in QENT+USRDIR
;   FROM: SYSTEM
;   SUBJECT: (header) (job #) (first word of tail)   FLNMSW = -1
;	     (header)				     FLNMSW = 0
;    NOTE - SUBJECT must be leq 39 characters long
;
;   MESSAGE:
;      (header) (job #), (ctl file) (tail) (time stamp) (appendix)
;		\                 /
;		 -----------------
;		      (null)
;
;  FOR FLNMSW = -1,  OUTPUT (job #), (ctl file)
;		 0,	    (null)
;
;  ON ENTRY AC	1 = anything
;		2 = STRING PTR TO (header)
;		3 = STRING PTR TO (tail)
;		4 = STRING PTR TO (appendix)
;
SEND:	AOSN	SNDLCK			;CHECK IF WE CAN SEND A MESSAGE
	JRST	SEND0			;YES
	PUSH	P,A
	MOVEI	A,^D5000		;TRY AGAIN IN 5 SECS.
	DISMS
	SKIPE	MYNAME			;SUPERIOR FORK?
	JRST	[PUSH	P,B
		 MOVEI	A,400000	;YES, CHECK FORK STATUS
		 MOVEI	B,1B19
		 IIC
		 POP	P,B
		 JRST	.+1]
	POP	P,A
	JRST	SEND

SEND0:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C

SEND2:	MOVE	A,[XWD 340000,0]	;SET UP MESSAGE FLAGS
	MOVEM	A,SNDMSF

	HRROI	A,SUBJCT	;PUT SUBJECT OF MESSAGE IN INFERIOR
	SETZ	C,		;FORK AC'S.  MUST BE LEQ 39 CHAR.
	SOUT
	SKIPN	FLNMSW		;MORE FOR THE SUBJECT?
	JRST	SEND23		;NO, DO MAIN BODY
	MOVE	B,QENT+BJOBNO	;OUTPUT JOB NUMBER
	MOVEI	C,^D10		;DECIMAL
	NOUT
	JFCL			;IGNORE ERRORS
	MOVE	C,0(P)		;FETCH PTR TO (TAIL) OF MESSAGE
	HRLI	C,440700	;MAKE IT A PROPER STRING PTR
	ILDB	B,C		;OUTPUT FIRST CHARACTER NO MATTER WHAT
	IDPB	B,A
SEND21:	ILDB	B,C		;GET NEXT CHARACTER
	CAIN	B," "		;IS IT A BLANK?
	JRST	SEND22		;YES - GO FINISH THINGS
	IDPB	B,A		;NO - STICK IT IN OUTPUT
	JRST	SEND21		;DO THE NEXT ONE
SEND22:	SETZ	B,		;MAKE IT ASCIZ
	IDPB	B,A

SEND23:	HRROI	A,MSG			;NOW MAKE UP MESSAGE.TXT FILE NAME
	MOVEI	B,"<"
	BOUT
	MOVE	B,QENT+USRDIR
	DIRST				;DIRECTORY NUMBER TO STRING
	JRST	[HRROI	B,[ASCIZ /BATCH/]	;NO ADRESSEE, USE BATCH
		 SETZ	C,
		 SOUT
		 JRST	.+1]
	MOVEI	B,">"
	BOUT
	HRROI	B,MSGTXT
	SETZ	C,
	SOUT
	MOVSI	A,(1B8+1B17)		;OLD, IGN DEL, SHORT
SNDAGN:	HRROI	B,MSG
	GTJFN
	JRST	[CAIL	A,GJFX18	;NO SUCH NAME
		 CAILE	A,GJFX20	;NO SUCH EXTENSION
		 JRST	ABMSG2
		 MOVSI	A,(1B1+1B17)	;TRY TO CREATE MESSAGE.TXT
		 JRST	SNDAGN]		;IF IT DIDN'T EXIST
	HRRZM	A,MSGJFN	;MESSAGE.TXT JFN
	HRLI	A,1			;MAKE SURE FILE IS NOT DELETED
	MOVSI	B,(1B3)
	SETZ	C,
	CHFDB

					;HERE AC C IS CLEAR TO START
					;CONTAINS SUCCESS/FAILURE FLAGS
					;FOR SETTING UP TEMP MSG FILE
					; AC C = OPEN FLG,,GTJFN FLG
					;        0 = SUCCESS
					;       -1 = FAILURE ONCE
SNDTMP:	MOVSI	A,(1B0+1B17)		;OUTPUT, SHORT
	HRROI	B,TEMP
	GTJFN
	JRST	[TROE	C,-1		;ALREADY FAILED?
		 JRST	ABMSG1		;YES, WRAP IT UP
		 MOVE	A,BATDN		;NO, BITS SET AND TRY EXPUNGING
		 DELDF
		 JRST	SNDTMP]		;TRY ONE MORE TIME

	HRRZM	A,TMPJFN
	MOVE	B,[7B5!1B20]		;WRITE, 7 BIT
	QOPENF
	JFCL
	JRST	[TLON	C,-1		;CAN'T OPEN IT - FAILED ALREADY?
		 CAIE	A,OPNX2		;NO, FILE DOESN'T EXIST?
		 JRST	ABMSG		;2ND TIME OR BAD ERROR - QUIT
		 MOVE	A,TMPJFN	;OK, TRY IT AGAIN
		 RLJFN			;RELEASE JFN TO CLEAN UP
		 JFCL			;IGNORE ERRORS
		 JRST	SNDTMP]

	MOVE	B,-1(P)			;WRITE (header) TO MESSAGE
	SETZ	C,
	SOUT
	SKIPL	FLNMSW			;WANT JOB # AND CTL NAME?
	JRST	SEND5			;NO, PUT OUT REST
	MOVE	B,QENT+BJOBNO
	MOVEI	C,^D10
	NOUT
	JFCL
	HRROI	B,[ASCIZ /, /]
	SETZ	C,
	SOUT
	HRROI	B,QENT+CTLFIL		;CTL FILE NAME
	SOUT

SEND5:	MOVE	B,0(P)			;TACK ON (TAIL)
	SOUT
	SETO	B,			;CURRENT TIME AND DATE
	MOVSI	C,245201
	ODTIM

	MOVE	B,D			;NOW FINISH WITH (APPENDIX)
	SETZ	C,
	SOUT

	MOVE	A,TMPJFN
	TLO	A,(1B0)			;DON'T RELEASE JFN
	CLOSF
	JRST	ABMSG			;BAD NEWS - ABORT IT

	MOVEI	B,INFACS		;INFERIOR FORK ACS
CFAGN:	HRLZI	A,240000		;SAME CAPABILITIES
	CFORK
	JRST	[MOVEI A,^D1000  	;NO FORKS, TRY AGAIN IN 1 SEC
		 DISMS
		 JRST CFAGN]
	MOVEM	A,FORK			;FORK HANDLE

	SKIPL	MYNAME			;ARE WE THE BATCON SUPERIOR?
	JRST	GETSND			;NO, JUST LOAD SNDMSG
	AOS	ACTFRK			;YES, THEN SET UP TABLE ENTRY
	ANDI	A,777			;AS JOB 0 FOR THIS FORK
	MOVEI	B,-1			;SET FORK STARTING
	MOVEM	B,FKSTAT(A)
	MOVSI	B,(FEXIST+FHLTED+FINQUE)
	HRR	B,FORK
	MOVEM	B,JBSTAT		;JOB 0

GETSND:	MOVSI	A,(1B2+1B17)		;GET OLD SNDMSG.SAV
	HRROI	B,SNDMSG
	GTJFN
	JRST	[MOVE	A,FORK		;MUST NOT BE A SNDMSG.SAV
		 KFORK			;SO KILL THE INFERIOR
		 SKIPL	MYNAME		;SUPERIOR BATCON?
		 JRST	ABMSG
		 ANDI	A,777		;ONLY FORK INDEX
		 SETOM	FKSTAT(A)	;CLEAR EVIDENCE OF EXISTENCE
		 SETZM	JBSTAT
		 SOS	ACTFRK
		 JRST	ABMSG]

	HRRZM	A,SNDJFN		;SNDMSG JFN
	HRL	A,FORK
	GET				;GET SNDMSG
	MOVE	A,FORK
	MOVEI	B,4			;FOURTH ENTRY IN ENTRY VECTOR
	SFRKV				;START FORK

	MOVE	A,RELFRK		;RECORD WHO IS DOING THIS
	MOVEM	A,WHOSND

	SKIPL	MYNAME			;BATCON SUPERIOR?
	JRST	SNDRTN			;NO, WRAP IT UP
	MOVSI	B,(FHLTED)		;CLEAR HALTED BIT
	ANDCAM	B,JBSTAT
	MOVE	A,FORK			;SET JOB 0 IN FKSTAT
	ANDI	A,777
	SETZ	B,
	HRRM	B,FKSTAT(A)

SNDRTN:	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER

ABMSG:	MOVE	A,TMPJFN
	RLJFN
	JFCL

ABMSG1:	MOVE	A,MSGJFN
	RLJFN
	JFCL

ABMSG2:	PUSH	P,D			;SAVE ANOTHER AC FOR POSTING MSG
	PUSH	P,FLNMSW		;SAVE CURRENT NAME SETTING
	SETZM	FLNMSW			;JUST PRINT USER DIRECTORY NAME
	HRROI	A,ERSTRB		;SET UP ERSTR PART OF MSG
	HRROI	B,[ASCIZ /
    TENEX Error:  /]
	SETZ	C,
	SOUT
	HRLOI	B,400000		;LATEST ONE IN THIS FORK
	ERSTR
	HRROI	B,DAYTRM		;STANDARD DAY FILE ENDING
	SOUT
	HRROI	B,JOBDAY		;NOW ACTUALLY POST DAY FILE MSG
	HRROI	C,[ASCIZ / SNDMSG ERROR ON /]
	HRROI	D,ERSTRB
	PUSHJ	P,DAY
	POP	P,FLNMSW		;RECOVER VARIABLES
	POP	P,D

	SETOM	SNDLCK			;CLEAR MESSAGE LOCK
	SETZM	FORK			;CLEAR FORK ID
	JRST	SNDRTN			;RETURN

;ROUTINE TO DUMP THE IMAGE OF A FORK AND ENTER A NOTE IN SOME LOG FILE
;ON ENTRY:	AC 1  = STRING PTR TO LOG FILE NAME
;		   2  = DATE STAMP FOR DUMP FILE (INTERNAL FORMAT)
;		   3  = RELATIVE FORK HANDLE FOR DUMP (THIS MAY NOT BE
;			THE ACTUAL FORK NUMBER IN THE HIERARCHY IF A
;			LOWER FORK IS DUMPING ITSELF)

;THE ROUTINE USES BUGSTR TO BUILD THE OUTPUT FILE NAME
;  BATCON-DUMP.XX-MO/DAY/YR-HRMIN
;WHERE XX IS THE OCTAL FORK NUMBER RELATIVE TO THE MAIN PROGRAM (FORK 0)

FRKDMP:	PUSH	P,A			;SAVE LOG JFN
	PUSH	P,B			;SAVE DATE/TIME STAMP
	PUSH	P,C			;SAVE FORK HANDLE

	HRROI	A,BUGSTR		;CONSTRUCT NAME IN BUGSTR
	HRROI	B,CSHBAT		;GET FIRST PART
	SETZ	C,
	SOUT
	HRRZ	B,0(P)			;RECOVER FORK HANDLE
	SKIPL	MYNAME			;USE IT IF WE ARE TOP FORK
	HRRZ	B,RELFRK		;ELSE, USE REAL ONE STORED FOR US
	ANDI	B,777			;ONLY THE INDEX PART
	PUSH	P,B			;SAVE THIS INDEX
	MOVEI	C,10			;OCTAL OUTPUT
	NOUT
	JFCL
	MOVEI	B,"-"
	BOUT
	MOVE	B,-2(P)			;RECOVER DATE/TIME STAMP
	MOVSI	C,045401
	ODTIM				;TACK ON DATE PART
	MOVEI	B,"-"
	BOUT
	MOVE	B,-2(P)			;GET DATE/TIME AGAIN
	MOVSI	C,400241
	ODTIM				;DO TIME PART NOW

	HRROI	A,DAYBUF		;BUILD LOG FILE MSG IN DAYBUF
	HRROI	B,[ASCIZ /
  DUMPING BATCON FORK /]
	SETZ	C,
	SOUT
	POP	P,B			;RECOVER REAL FORK INDEX
	MOVEI	C,10			;OCTAL OUTPUT
	NOUT
	JFCL
	HRROI	B,[ASCIZ / ON FILE:  /]
	SETZ	C,
	SOUT
	PUSH	P,A			;SAVE CURRENT BUFFER POINTER

	MOVSI	A,402001		;TRY TO GTJFN THE DUMP FILE
	HRROI	B,BUGSTR
	GTJFN
	JRST	[POP	P,A		;TACK FAILURE MSG TO OUTPUT BUF
		 HRROI	B,[ASCIZ /XXX
   GTJFN ERROR ON /]
		 SETZ	C,
		 SOUT
		 HRROI	B,BUGSTR
		 SOUT
		 HRROI	B,[ASCIZ /
   IMAGE NOT DUMPED
   TENEX ERROR:  /]
		 SOUT
		 HRLOI	B,400000
		 ERSTR
		 JFCL
		 JFCL
		 PUSH	P,A		;SAVE NEW BUFFER POINTER
		 SETO	A,		;DUMMY JFN = -1
		 PUSH	P,A
		 JRST	ASTLIN]

	PUSH	P,A			;SUCCESSFUL - SAVE REAL JFN
	MOVE	B,A			;SET UP FOR JFNS
	MOVE	A,-1(P)			;GET BUFFER POINTER
	MOVE	C,[XWD 011110,1]
	JFNS
	HRROI	B,CRLF			;AND NEW LINE
	SETZ	C,
	SOUT
	MOVEM	A,-1(P)			;SAVE UPDATED BUFFER PTR

ASTLIN:	MOVE	A,-1(P)			;RETRIEVE BUFFER POINTER
	HRROI	B,ASTRSK		;FINISH ENTRY WITH SEPARATOR LINE
	SETZ	C,
	SOUT

	POP	P,A			;RECOVER DUMP FILE JFN
	JUMPL	A,NOSAVE		;IF BAD, DON'T TRY TO SAVE
	HRL	A,-1(P)			;TACK FORK HANDLE ON LEFT HALF
IFN FDBSEQ,<
	MOVE	B,[<MSGBUF+1000>,,20]	;SAVE WHOLE MESS
	>
IFE FDBSEQ,<
	MOVE	B,[<SEQLOC+1000>,,20]	;SAVE WHOLE MESS
	>
	SAVE

NOSAVE:	POP	P,A			;CLEAR BUFFER POINTER
	MOVE	A,-2(P)			;GET LOG FILE NAME
	HRROI	B,DAYBUF		;MESSAGE BUFFER PTR
	PUSHJ	P,FILPRF		;WRITE IT OUT

	POP	P,C			;RESTORE AC'S
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN

; Following is a routine to add a message to the head of a specified
; file.  On entry:
;	AC  1  =  Ptr to file name
;	    2  =  Ptr to message string
;
; The routine copies the new message to the start of DAYBUF and adds
; the current contents of the file behind it.  It then writes out
; the new file containing DAYSIZ words and unmaps the DAYBUF pages used.

FILPRF:	PUSH	P,A			;SAVE AC'S
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D

	HRROI	A,DAYBUF		;FIRST MOVE MESSAGE TO DAYBUF
	MOVE	B,-2(P)
	SETZ	C,
	SOUT
	HRRI	A,1(A)			;SET POINTER TO NEXT WORD
	HRLI	A,444400		;AS 36 BIT STR POINTER
	PUSH	P,A			;SAVE IT

	MOVSI	A,(1B17)		;GTJFN ON OUTPUT FILE
FILPRR:	MOVE	B,-4(P)			;FILE NAME STRING
	GTJFN
	JRST	FILGJE			;OOPS, ERROR - GO CHECK IT OUT
	PUSH	P,A			;SAVE THE JFN
	MOVE	B,[44B5+1B19+1B20]	;OPEN THE FILE 36 BIT, READ, WRITE
	QOPENF
	JFCL
	JRST	[MOVE	B,-5(P)		;OOPS, GO PRINT ERROR
		 PUSHJ	P,FILPRE
		 POP	P,A		;RELEASE FILE JFN
		 RLJFN
		 JFCL			;TOUGH LUCK HERE
		 JRST	FILPR1]

	MOVE	B,[XWD 1,12]		;GET FILE SIZE (FDB WORD 12)
	MOVEI	C,C			;PUT IT IN AC C
	GTFDB

	MOVE	A,0(P)			;GET JFN FROM STACK
	MOVE	B,-1(P)			;RETRIEVE BUFFER POINTER
	MOVN	C,C			;READ CURRENT FILE CONTENTS IN
	SKIPE	C			;BACK OF HEADER UNLESS SIZE = 0
	SIN
	HRRZI	D,1(B)			;SAVE ADDRESS OF BUFFER END FOR
					;LATER UNMAPPING OF PAGES
	SETZ	B,
	SFPTR				;RESET FILE POINTER TO BEGINNING
	JRST	[MOVE	B,-5(P)		;OOPS, GO PRINT ERROR
		 PUSHJ	P,FILPRE
		 MOVE	A,0(P)		;CLOSE THE FILE IF POSSIBLE
		 CLOSF
		 JFCL			;TOUGH LUCK
		 POP	P,A		;RECOVER JFN AND TRY RELEASING IT
		 RLJFN
		 JFCL			;TOUGH LUCK HERE
		 JRST	FILPR1]

	MOVE	B,[POINT 36,DAYBUF]	;SET UP TO WRITE NEW FILE CONTENTS
	MOVNI	C,DAYSIZ
	SOUT

	CLOSF
	JRST	[MOVE	B,-5(P)		;OOPS, GO PRINT ERROR
		 PUSHJ	P,FILPRE
		 POP	P,A		;RECOVER JFN AND TRY RELEASING IT
		 RLJFN
		 JFCL			;TOUGH LUCK HERE
		 JRST	FILPR1]

	POP	P,A			;CLEAR JFN FROM STACK

	SETO	A,			;NOW UNMAP BUFFER PAGES
	MOVE	B,[XWD 400000,DAYBUF/1000]
	SETZ	C,
	SUBI	D,DAYBUF-777		;COMPUTE # OF PAGES TO RELEASE
	LSH	D,-^D9
FILPR0:	PMAP				;UNMAP THIS PAGE
	AOS	B			;POINT TO THE NEXT ONE
	SOJG	D,FILPR0		;DO THEM ALL

FILPR1:	POP	P,A			;CLEAR BUFFER PTR FROM STACK

	POP	P,D			;RESTORE AC'S
	POP	P,C
	POP	P,B
	POP	P,A

	POPJ	P,			;RETURN TO CALLER


;GTJFN error here.  See if because of no such file in which case try
;creating a new one.  Otherwise, hang it up.
FILGJE:	CAIL	A,GJFX18		;IF ERROR BETWEEN NO SUCH NAME
	CAILE	A,GJFX21		;AND JUST EXPUNGED, TRY NEW FILE
	JRST	FILGJ0			;OTHERWISE, TOO BAD
	MOVSI	A,(1B0+1B17)
	JRST	FILPRR

FILGJ0:	MOVE	B,-4(P)			;BAD ERROR, GO PRINT ERROR
	PUSHJ	P,FILPRE
	JRST	FILPR1			;AND FORGET IT


; The following prints an error message for any of the above error
; conditions on the LOG TTY of the form:
;
;	*** BATCON ERROR ACCESSING (file name)
;           (TENEX ERSTR message)
;
;  String pointer to file name should be in AC B.

FILPRE:	PUSH	P,B			;SAVE FILE NAME POINTER
	MOVEI	A,101
	HRROI	B,[ASCIZ /
*** BATCON ERROR ACCESSING /]
	SETZ	C,
	SOUT
	POP	P,B			;ADD FILE NAME
	SOUT
	HRROI	B,[ASCIZ /
      /]
	SOUT
	HRLOI	B,400000		;ADD TENEX ERROR MESSAGE
	ERSTR
	JFCL
	JFCL
	HRROI	B,CRLF			;ADD CRLF'S
	SETZ	C,
	SOUT
	HRROI	B,CRLF
	SOUT

	POPJ	P,			;RETURN


; Following are the file names for sending user messages
MSGTXT:	ASCIZ	/MESSAGE.TXT;1/
SNDMSG:	ASCIZ	/<SUBSYS>SNDMSG.SAV/
TEMP:	ASCIZ	/BATCH.MSG/

; Following are fixed string formats for SNDMSG contents
JOBMSG:	ASCIZ	/ BATCH JOB /
CNDMSG:	[ASCIZ	/ STARTED ON /]
	[ASCIZ	/ FINISHED ON /]
	[ASCIZ	/ DESUBMITTED ON /]
	[ASCIZ	/ DETACHED ON /]
	[ASCIZ	/ ABORTED ON /]
	[ASCIZ	/ DEFERRED ON /]
	[ASCIZ	/ ABORTED - IMPENDING SYSTEM HALT
   ON /]
	[ASCIZ	/ WARNING ON /]
MSGTRM:	ASCIZ	/.
/

; Following are fixed string formats for NOTIFY messages
JOBNOT:	ASCIZ	/
  [BATCH JOB /
CNDNOT:	[ASCIZ	/ STARTED ON /]
	[ASCIZ	/ FINISHED ON /]
	[ASCIZ	/ DESUBMITTED ON /]
	[ASCIZ	/ DETACHED ON /]
	[ASCIZ	/ ABORTED ON /]
	[ASCIZ	/ DEFERRED ON /]
	[ASCIZ	/ ABORTED - IMPENDING SYSTEM HALT
   ON /]
	[ASCIZ	/ WARNING ON /]
NOTTRM:	ASCIZ	/]
/

; Following are fixed string formats for DAYFILE messages
JOBDAY:	ASCIZ	/  [BATCH JOB /
CNDDAY:	[ASCIZ	/ STARTED ON /]
	[ASCIZ	/ FINISHED ON /]
	[ASCIZ	/ DESUBMITTED ON /]
	[ASCIZ	/ DETACHED ON /]
	[ASCIZ	/ ABORTED ON /]
	[ASCIZ	/ DEFERRED ON /]
	[ASCIZ	/ ABORTED - IMPENDING SYSTEM HALT ON /]
	[ASCIZ	/ WARNING ON /]
DAYTRM:	ASCIZ	/]
/
JOBCTL:	ASCIZ	/--[CONTROL TASK /
DAYBRP:	ASCIZ	/**[BATCON NOTE /
DAYOOP:	ASCIZ /
*****[BATCON /

ASTRSK:	ASCIZ	/
************************************************************************

/
NULL:	ASCIZ	/     /
CRLF:	ASCIZ	/
/

; Formats for listing fork state information
FST:	POINT	7,[ASCIZ /RUNNING /]		;0
	POINT	7,[ASCIZ /IO WAIT /]		;1
	POINT	7,[ASCIZ /VOL TERM /]		;2
	POINT	7,[ASCIZ /INVL TERM /]		;3
	POINT	7,[ASCIZ /FORK WT /]		;4
	POINT	7,[ASCIZ /DISMISSED /]		;5
	POINT	7,[ASCIZ /AT BKPNT /]		;6


;FOLLOWING ARE THE VALID COMMANDS FOR SETTING RESOURCE LIMIT CONTROL SIGNALS
;WHEN THE RESOURCE IS 90% DEPLETED.
CQQ==0
LMTSGL:	TE	(DEFSET,<DEFAULT>)
	TE	(CPUSET,<CPUTIME>)
	TE	(RUNSET,<RUNTIME>)
	TE	(LINSET,<LOGLINES>)
	0
NLMTSW==CQQ

	PURGE	TE,CQQ

	LIT				;LITERAL POOL

PATCH:	BLOCK	100			;PATCH AREA - COMMON PAGES

ENDINF:
NINF==<<<ENDINF-INFFK>+777>/1000>
PRILOC==<<<ENDINF-1>/1000>+2>*1000

	SUBTTL	INFERIOR FORK PRIVATE PAGE
	LOC	PRILOC
PRIV:					;LABEL FOR MAPPING
;	SEND MESSAGE STORAGE
MYNAME:	BLOCK	1			; -1 FOR SCHED LEVEL, 0 FOR INFR FORK
					;USED TO TELL WHO GOT BUG AND HOW TO
					;RESTART 
SBJBNM:	BLOCK	1			;NAME OF SUBSYS SUBJOB IS IN
SYMPTR:	BLOCK	1			;COPY OF SYMTAB WORD FOR CRASH COPY
JOBN:	BLOCK	1			;JOB NUMBER OF ACTIVE PROCESS
FORK:	BLOCK	1			;FORK HANDLE OF SNDMSG FORK (PRIVATE)
FRCTRM:	-1				;FORCE TERMINATION FLAG
CTLJFN:	BLOCK	1			;JFN FOR CTL FILE
LOGJFN:	BLOCK	1			;JFN FOR LOG FILE
FLNMSW:	BLOCK	1			;SWITCH TO CONTROL FILE NAME
					;PRINTING IN NOTIFY, PRINT, DAY, AND SEND
PTY:	BLOCK	1			;PTY DESIGNATOR
MODEI:	BLOCK	1			;FLAGS FROM RDCTL TO DESC. INP.
RELFRK:	BLOCK	1			;RELATIVE FORK HANDLE
PISYON:	BLOCK	1			;PI'S OFF (0), ON (-1)
PIACT:	BLOCK	1			;BIT MAP OF PI CHANNELS ACTIVATED
PIWAIT:	BLOCK	1			;BIT MAP OF PI'S WAITING
PIPROG:	BLOCK	1			;BIT MAP OF PI LEVELS IN PROGRESS
IFN MXILIN,<
ILINCT:	BLOCK	1			;NUMBER OF ILLEG INSTR ENCOUNTERED
	>	;END MXILIN CONDITIONAL
TJOBIN:	BLOCK	1			;TOD CLOCK WHEN JOB ENTERED
MAXETM:	BLOCK	1			;MAX ELAPSED TIME ALLOWED
RUNTIM:	BLOCK 	1			;TIME JOB ELAPSED TIME OVER(TODCLK FORMAT)
RUNTRG:	BLOCK	1			;90% OF ALLOWED RUN TIME
RUNCHR:	BLOCK	1			;CTL CHAR TO BE SENT WHEN AT RUNTRG
MAXCPU:	BLOCK	1			;MAX CPU TIME JOB CAN USE
CPUTRG:	BLOCK	1			;90% OF ALLOWED CPU TIME
CPUCHR:	BLOCK	1			;CTL CHAR TO BE SENT WHEN AT CPUTRG
MAXLOG:	BLOCK	1			;MAX LINES JOB CAN WRITE ON LOG FILE
LOGTRG:	BLOCK	1			;90% OF ALLOWED LOG LINES
LINCHR:	BLOCK	1			;CTL CHAR TO BE SENT WHEN AT LOGTRG
CEXCSW:	-1				;SWITCH SHOWING TRANSITION BETWEEN
					;EXEC AND USER PGM (-1 => IN EXEC)

NAPTIM:	BLOCK	1			;HOW LONG TO DISMS BETWEEN CHECKS
LSTTIM:	BLOCK	1			;TIME LAST LOOKED AT NEED FOR
					;RESOURCE CHECKS
LSTCHK:	BLOCK	1			;TIME OUT BETWEEN RESOURCE CHECKS
INFDSB:	BLOCK	1			;INFERIOR DESUBMIT FLAG
ENDTYP:	BLOCK	1			;FLAG FOR TERMINATION MESSAGE TYPE

IFN IMSLOG,<
; The following storage is for LOG FILE labelling ala the IMSSS narrow
; paper style:
EXECHG:	BLOCK	1			;FLAG INDICATING ENTERING EXEC FOR LABEL
					;SYNCHRONIZING
LABCNT:	BLOCK	1			;COUNT OF LINES UNTIL LABEL PRINT
LABSUB:	BLOCK	1			;MOST CURRENT SUBSYS
LABTOD:	BLOCK	1			;TOD WHEN LAST LINE LABEL PRINTED
	>	;END OF IMSLOG

QENT:	BLOCK	QESIZE			;QUEUE ENTRY

USRBLK:	BLOCK	20			;SPACE TO GTDIR INTO FOR USER WE
					;ARE RUNNING-WE READ HIS ACCESS FROM
					;HERE
CSHACS:	BLOCK	20			;AC SAVE BLOCK FOR CRASH DUMP
CSHPC:	BLOCK	1			;PC FOR THIS FORK AT CRASH OR STATUS
CSHSTK:	BLOCK PDLL+1			;STACK FOR ERROR HANDLING
TMPACS:	BLOCK 2				;TEMPORARY AREA FOR AC'S
BUGLOC:	BLOCK 1				;ADDRESS FROM WHICH BUG CALLED
BUGMAD:	BLOCK 1				;ADDRESS OF BUG STRING
BUGRET:	BLOCK 1				;RETURN ADDRESS AFTER BUG CALL

BUGSTR:	BLOCK	60			;AREA FOR BUILDING BUG MESSAGE
STRBUF:	BLOCK	60			;AREA FOR BUILDING MESSAGES

IPDL:	BLOCK	PDLL+1

;PSEUDO-INTERRUPT SYSTEM STORAGE
LEVTAB:	EXP	LEV1PC,LEV2PC,LEV3PC	;PC STORAGE ADDRESSES FOR INTERRUPTS
LEV1PC:	0				;STORAGE FOR PC AT TIME OF INTERRUPT
LEV2PC:	0
LEV3PC:	0
CHNTAB:	
	IFN	GDDT,<
	3,,STDDT			;DDT FOR DEBUGGING (CHAN 0)
	>
	IFE	GDDT,<
	3,,UNEX				;UNEXPECTED INTERRUPT (CHAN 0)
	>
	3,,DESUBF			;DESUBMIT FORK (CHAN 1)
	3,,INFSTS			;INFERIOR FORK STATUS (CHAN 2)
	3,,SUICID			;INFERIOR FORK SUICIDE (CHAN 3)
	3,,SAVACS			;SAVE AC'S AND FREEZE (CHAN 4)
	3,,SYSHLT			;IMPEND SYSTEM HALT (CHAN 5)
	REPEAT	^D4,<3,,UNEX>		;UNEXPECTED INTERRUPT (CHAN 6-9)
	2,,PSIEOF			;FILE COND 1, EOF (CHAN 10)
	2,,PSIERR			;FILE COND 2, DATA ERROR (CHAN 11)
	REPEAT	^D3,<3,,UNEX>		;UNEXPECT INTERRUPT (CHAN 12-14)
	2,,ILINST			;ILLEGAL INSTR TRAP (CHAN 15)
	REPEAT	^D3,<3,,UNEX>		;UNEXPECT INTERRUPT (CHAN 16-18)
	3,,HLTNFK			;HALTED FORK (CHAN 19)
	REPEAT	^D17,<3,,UNEX>		;UNEXPECTED INTERRUPT (CHAN 20-36)


;	STRING TO FORCE LOGOUT WHEN NO LOGO APPEARS IN CTL FILE
LOGSTR:	POINT 7,[ASCIZ /LOGOUT
/]
;LINE FOR MESSAGES FROM BATCH, COMMENTS COPIED OVER, ETC.
	POINT	7,MSGLIN+2		;POINTER TO STORE IN MSGLIN
MSGLIN:	LOGL*5				;MAX LENGTH MSG LINE
	BLOCK	LOGL+1			;ACTUAL LENGTH AND THE TEXT
;LINE FOR INPUT TO SUBJOB
	POINT	7,CTLLIN+2		;POINTER TO DATA IN LINE
CTLLIN:	CTLL*5				;MAX LENGTH INPUT LINE CTL FILE
	BLOCK	CTLL+1			;LENGTH OF ACTUAL DATA AND LINE

;LINE FOR OUTPUT FROM SUBJOB
	POINT	7,LOGLIN+2		;POINTER TO STORE IN LOGLIN
LOGLIN:	LOGL*5				;MAX LENGTH LOG LINE
	BLOCK	LOGL+1			;LENGTH ACTUALLY THERE, AND LINE

INFACS:			;INFERIOR FORK ACS
	BLOCK	1	;0
MSGJFN:	BLOCK	1	;1, MESSAGE.TXT JFN
SNDMSF:	BLOCK	1	;2, SEND MESSAGE FLAGS
TMPJFN:	BLOCK	4	;3-6
SUBJCT:	BLOCK	8	;7-16, SUBJECT OF MESSAGE
	BLOCK	1	;17
MSG:	BLOCK	10
SNDJFN:	BLOCK	1

FKSTS: BLOCK 1
FKPC:	BLOCK 1
FKACS:	BLOCK	20

	VAR
	LIT			;FORCE ALL LITERALS BEFORE NEW PAGE

ENDPRV:
NPRIV==<<<ENDPRV-PRIV>+777>/1000>	;NUMBER OF INFERIOR FORK PRIVATE PAGES
SYMLOC==<<<ENDPRV-1>/1000>+2>*1000

	LOC	SYMLOC
DMYSYM:	-1


; The following are special buffer areas allocated above the symbol
; table area of the loader.  They have potential large allocations
; depending on the pages accessed:

;SPACE FOR THE COMMAND QUEUE
COMBUF==40*1000			;PAGE 40

;SPACE FOR DAYFILE, CRASH, AND ABNORMAL-TERMINATION FILE MANIPULATION
DAYBUF==60*1000			;PAGE 60

;SPACE FOR LARGE MESSAGE BUILDING
MSGBUF==100*1000		;PAGE 100

IFE FDBSEQ,<
; THE PAGE SHARED WITH THE JOB SEQUENCE FILE COMMUNICATING CURRENT Q STATUS
SEQLOC==120*1000		;PAGE 120
SEQPAG==SEQLOC/1000
JBSQLK==SEQLOC
FMXJBN==SEQLOC+1
FJBBIT==SEQLOC+2
	>		;END OF FDBSEQ CONDITIONAL


	END	START
