;<BATCH>BATCON.MAC;11    31-OCT-75 10:59:50    EDIT BY LIEB
;ADDED PATCHS FROM SRI-AI TO CURE RACE CONDITIONS
;<BATCH>BATCON.MAC;10    10-SEP-75 15:08:10    EDIT BY LIEB
;USE RECURSIVE ROUTINE TO GET A PTY THAT INSURES NO JOB AT OTHER END
;GET ALL THE OUTPUT FROM PTY AT EOJ TIME. REWORK TERMINATION LOGIC
;ADD CONTROLS OVER ELAPSED TIME,CPU TIME, AND LOG LENGTH
;REWORK RUN LOOP AND GET RID OF PUSHJ'S THAT NEVER RETURN ETC
;REWORK DEBUGGING STUFF AND REARRANGE FORK STARTING
;TO PREVENT MYSTERIOUS FORK DISAPPEARANCES
;<BATCH>BATCON.MAC;7     4-SEP-75 10:14:37    EDIT BY LIEB
;added tnx131 switchs and got rid of BUG STOPs (made sense of them)
;<BATCH>BATCON.MAC;143    15-AUG-75 09:28:33    EDIT BY MOUTON
;ADDED IMPROVEMENTS BY DENNIS SMITH AT ECL
;<BATCH>BATCON.MAC;137     8-AUG-75 13:39:24    EDIT BY UNTULIS
;ADDED ^S INFERIOR FORK STATUS CODE
;<BATCH>BATCON.MAC;133     7-AUG-75 15:26:11    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;132     7-AUG-75 15:13:33    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;131     7-AUG-75 13:30:40    EDIT BY MOUTON
;ADDED LENGTH AND TIME OPTIONS
;<BATCH>BATCON.MAC;129     5-AUG-75 10:01:20    EDIT BY UNTULIS
;CORRECTED EOJ31 ERROR OF FILE BUSY CHECK
;<BATCH>BATCON.MAC;128     2-AUG-75 12:18:02    EDIT BY UNTULIS
;FIXED Q COPY LOOPING PROBLEM
;<BATCH>BATCON.MAC;127     1-AUG-75 23:10:50    EDIT BY UNTULIS
;FIXED LOG FILE GTJFN FAILURES (ILLEGAL VERSION)
;<BATCH>BATCON.MAC;103    22-JUL-75 15:45:26    EDIT BY MOUTON
;ADD CODE TO KEEP TRACK OF BATCH JOBS IN DAYFILE
;<BATCH>BATCON.MAC;96    22-JUL-75 10:53:30    EDIT BY UNTULIS
;ADD CODE TO OUTPUT BUG MESSAGES TO FILE INSTEAD OF LOGGING TTY
;<BATCH>BATCON.MAC;95    22-JUL-75 10:23:49    EDIT BY UNTULIS
;ADDED CRASH NOTIFICATION CODE ON BUG MESSAGES
;<BATCH>BATCON.MAC;81    14-JUL-75 15:07:25    EDIT BY UNTULIS
;ADD LOAD AVERAGE THRESHOLD CODE
;<BATCH>BATCON.MAC;76     4-JUL-75 13:36:48    EDIT BY UNTULIS
;ADDED CODE TO PROCESS DESUBMIT REQUEST
;<BATCH>BATCON.MAC;49    13-JUN-75 14:12:41    EDIT BY UNTULIS
;<BATCH>MFORK.MAC;45    13-JUN-75 14:11:58    EDIT BY UNTULIS
;INTRODUCED MULTIPLE FORKS TO RUN BATCH JOBS
;ADDED PRIORITY COMMAND
;<BATCH>BATCON.MAC;48    19-MAY-75 13:57:38    EDIT BY UNTULIS
;<BATCH>BATCON.MAC;47    30-APR-75 09:54:57    EDIT BY LYNCH
;ADD SYSTEM ACTIVITY FLAG SETTING
;<BATCH>BATCON.MAC;36    11-APR-75 14:11:33    EDIT BY UNTULIS
;CHANGED LPT OUTPUT FILE NAME TO LPT FROM LOG
;<BATCH>BATCON.MAC;33    28-MAR-75 10:10:21    EDIT BY UNTULIS
;ADD LARSON CHANGES
;<BATCH>BATCON.MAC;13     4-MAR-75 15:28:57    EDIT BY UNTULIS
;ADD SKUSR CODE FOR FORCING BATCH JOBS TO QUEUE 2
;<BATCH>BATCON.MAC;11     4-MAR-75 15:13:26    EDIT BY UNTULIS
;ADD SND MESSAGE CODE
;ADD CODE FOR EVOKING DDT
;<BATCH>BATCON.MAC;8    18-FEB-75 23:54:15    EDIT BY UNTULIS
;ADD LOCAL DIRECTORY NUMBER CHECK
;<BATCH>BATCON.MAC;2    10-FEB-75 10:24:51    EDIT BY UNTULIS
;EXPANDED QENT FOR STRING ACCOUNTS
;<LARSON>BATCON.MAC;110    31-DEC-74 11:19:57	EDIT BY LARSON
;FIXED INSERTION OF ESC IN LOGIN LINE
;<LARSON>BATCON.MAC;109    31-DEC-74 10:19:40	EDIT BY LARSON
;FIXED DOLOGI BUG BY MOVING THE LOAD OF DIRNUMB TO B AT END OF CKCTLS.
;<LARSON>BATCON.MAC;108    31-DEC-74 09:52:47	EDIT BY LARSON
;FIXED CKLOG0 BY ADDING THE RESTORE OF JFN
;<LARSON>BATCON.MAC;107    31-DEC-74 08:47:04	EDIT BY LARSON
;<LARSON>BATCON.MAC;106    31-DEC-74 08:43:45	EDIT BY LARSON
;PUT IN SPECIAL HANDLING FOR LOG FILES ON DEVICES:
;DSK: (NORMAL), NIL: (ALLOW), LPT: (CREATE NAME <PRINTER>LOG.USERNAME)
;<LARSON>BATCON.MAC;105    31-DEC-74 08:19:53	EDIT BY LARSON
;<LARSON>BATCON.MAC;104    31-DEC-74 08:14:27	EDIT BY LARSON
;PUT IN CHKACC
;<LARSON>BATCON.MAC;103    31-DEC-74 07:25:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;102    30-DEC-74 16:38:11	EDIT BY LARSON
;PUT IN CLOSF BEFORE DELF AT GETJB1 BECAUSE TENEX DOESN'T
;CLOSE IT AS JSYS MANUAL SEEMS TO SAY IT SHOULD.
;<LARSON>BATCON.MAC;101    30-DEC-74 15:31:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;100    30-DEC-74 14:18:12	EDIT BY LARSON
;<LARSON>BATCON.MAC;99    30-DEC-74 09:08:01	EDIT BY LARSON
;<LARSON>BATCON.MAC;98    30-DEC-74 08:27:26	EDIT BY LARSON
;<LARSON>BATCON.MAC;97    26-DEC-74 09:56:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;96    23-DEC-74 12:10:41	EDIT BY LARSON
;FIXED Q PROT TO 777700 FROM 770000
;<LARSON>BATCON.MAC;95    23-DEC-74 11:37:18	EDIT BY LARSON
;CHANGED THE QUEUE TO LIVE IN <BATCH>
;PUT IN SETNM FOR SYSTEM BATCH
;<LARSON>BATCON.MAC;92    21-DEC-74 16:29:35	EDIT BY LARSON
;PUT IN CODE TO SUPPORT THE USRACT FIELD OF QUEUE AND
;TO SUPPORT DUMB ACCOUNTING SYSTEM THAT WON'T TAKE ACCT # 1
;<LARSON>BATCON.MAC;91    20-DEC-74 12:37:16	EDIT BY LARSON
;<LARSON>BATCON.MAC;90    20-DEC-74 11:23:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;89    20-DEC-74 10:42:22	EDIT BY LARSON
;<LARSON>BATCON.MAC;88    20-DEC-74 10:29:24	EDIT BY LARSON
;<LARSON>BATCON.MAC;87    20-DEC-74 09:55:38	EDIT BY LARSON
;<LARSON>BATCON.MAC;86    20-DEC-74 09:13:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;85    20-DEC-74 08:26:20	EDIT BY LARSON
;<LARSON>BATCON.MAC;84    19-DEC-74 11:53:40	EDIT BY LARSON
;<LARSON>BATCON.MAC;83    19-DEC-74 11:49:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;82    19-DEC-74 10:51:38	EDIT BY LARSON
;<LARSON>BATCON.MAC;81    19-DEC-74 09:05:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;80    19-DEC-74 08:24:30	EDIT BY LARSON
;<LARSON>BATCON.MAC;79    18-DEC-74 17:00:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;78    18-DEC-74 15:26:44	EDIT BY LARSON
;<LARSON>BATCON.MAC;77    18-DEC-74 08:41:02	EDIT BY LARSON
;<LARSON>BATCON.MAC;76    18-DEC-74 08:29:26	EDIT BY LARSON
;<LARSON>BATCON.MAC;75    17-DEC-74 16:00:36	EDIT BY LARSON
;<LARSON>BATCON.MAC;74    17-DEC-74 09:40:14	EDIT BY LARSON
;<LARSON>BATCON.MAC;73    17-DEC-74 09:21:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;72    17-DEC-74 09:15:18	EDIT BY LARSON
;<LARSON>BATCON.MAC;71    17-DEC-74 08:35:40	EDIT BY LARSON
;<LARSON>BATCON.MAC;70    16-DEC-74 16:50:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;69    16-DEC-74 16:07:50	EDIT BY LARSON
;<LARSON>BATCON.MAC;67    16-DEC-74 11:32:16	EDIT BY LARSON
;<LARSON>BATCON.MAC;66    10-DEC-74 11:58:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;65    10-DEC-74 11:48:59	EDIT BY LARSON
;<LARSON>BATCON.MAC;64    10-DEC-74 11:31:59	EDIT BY LARSON
;<LARSON>BATCON.MAC;63    10-DEC-74 11:07:56	EDIT BY LARSON
;<LARSON>BATCON.MAC;62    10-DEC-74 10:56:41	EDIT BY LARSON
;<LARSON>BATCON.MAC;61    10-DEC-74 10:33:29	EDIT BY LARSON
;<LARSON>BATCON.MAC;60    10-DEC-74 10:19:02	EDIT BY LARSON
;<LARSON>BATCON.MAC;54    16-NOV-74 13:24:23	EDIT BY LARSON
;<LARSON>BATCON.MAC;53    15-NOV-74 08:59:00	EDIT BY LARSON
;<LARSON>BATCON.MAC;52    14-NOV-74 15:37:47	EDIT BY LARSON
;<LARSON>BATCON.MAC;51     4-NOV-74 15:17:24	EDIT BY LARSON
;<LARSON>BATCON.MAC;50    30-OCT-74 23:11:35	EDIT BY LARSON
;<LARSON>BATCON.MAC;44    21-OCT-74 16:44:40	EDIT BY LARSON
;PUT IN PSI STUFF FOR EOF AND FILE ERRORS
;<LARSON>BATCON.MAC;40    14-OCT-74 17:27:19	EDIT BY LARSON
;FIXED ERR1 OPERATION
;<LARSON>BATCON.MAC;39    14-OCT-74 14:31:46	EDIT BY LARSON
;USED CONNECTED DIR, ACCT 1
;<LARSON>BATCON.MAC;31     3-OCT-74 09:22:27	EDIT BY LARSON
;<LARSON>BATCON.MAC;29     2-OCT-74 13:48:10	EDIT BY LARSON
;<LARSON>BATCON.MAC;28     1-OCT-74 13:43:48	EDIT BY LARSON
;ADDED END: AND FIXED SOME BUGS.
;<LARSON>BATCON.MAC;27    30-SEP-74 09:47:06	EDIT BY LARSON
;<LARSON>BATCON.MAC;25    29-SEP-74 18:20:05	EDIT BY LARSON
;<LARSON>BATCON.MAC;21    26-SEP-74 16:16:55	EDIT BY LARSON
;<LARSON>BATCON.MAC;18    20-SEP-74 09:08:46	EDIT BY LARSON
;<LARSON>BATCON.MAC;16    19-SEP-74 17:34:49	EDIT BY LARSON
;<LARSON>BATCON.MAC;14    13-SEP-74 18:38:22	EDIT BY LARSON
	TITLE	BATCON	BATCH CONTROLLER FOR TENEX
	SUBTTL	SUBTTL  BATCH PROCESSOR

	SEARCH	STENEX

;PTY OPDEFS
OPDEF	ASPTY	[JSYS 360]
OPDEF	REPTY	[JSYS 361]
OPDEF	PSTI	[JSYS 362]
OPDEF	PSTO	[JSYS 363]
OPDEF	SIBF	[JSYS 364]

;LUUO OPDEFS
OPDEF	ERR1	[1B8]

;ASSEMBLY SWITCHES
IFNDEF	FSUSER,<FSUSER==0>		;USER/SINGLE JOB VERSION
IFNDEF	FSTCPY,<FSTCPY==1>		;TRIM Q VIA COPY AND RENAME
					;INSTEAD OF RESET POINTER.

;VARIABLE DEFINITIONS
NAPMIN==^D250				;MINIMUM NAP TIME
NAPMAX==^D15000				;MAXIMUM NAP TIME
MAXFK==16				;MAXIMUM NUMBER OF ACTIVE INFERIOR FORKS
					;SUPERSEDED BY NAPMIN IF
					;"NAPMIN>NAPMAX"

CTLL==<^D100/5>+1			;MAX LENGTH OF CTL LINE
LOGL==<^D132/5>+1			;MAX LENGTH OF LOG LINE TO WRITE
PDLL==47				;SIZE OF PUSH DOWN LIST

;DEVICE DESIGNATORS.
DEVDSK==600000				;DSK:
DEVLPT==600007				;LPT:
DEVNIL==600015				;NIL:



;FLAGS IN F
R.SEOL==1				;INTERNAL FLAG FOR RDCTL TO TELL ITSELF
					;THAT IT MUST SUPPRESS THE END OF THE
					;LINE (TRALING SPACES AND TERMINATOR)

R.SEMI==R.SEOL*2			;RDCTL RETURNS THIS FLAG TO TELL
					;THAT THIS LINE IS A COMMENT, AND THAT
					;IT SHOULD JUST BE COPIED TO THE
					;LOG FILE--DO NOT PASS IT TO THE
					;USER.  (IT IS NOT GUARANTEED TO
					;START WITH A ;).

R.MONC==R.SEMI*2			;THIS LINE IS TO GO TO THE MONITOR
					;(OR EXEC) LEVEL COMMAND INTERPETER

R.INTR==R.MONC*2			;THIS LINE CAN GO TO EITHER MONITOR
					;OR USER LEVEL, IT IS NOT SPECIFIED

R.USER==R.INTR*2			;THIS LINE GOES TO A USER LEVEL
					;PROGRAM AS DATA OR A COMMAND

R.BLNK==R.USER*2			;THIS PUT A BLANK LINE ON THE LOG
					;FILE, DO NOT PASS THIS LINE TO
					;THE USER JOB, DO NOT COPY THIS
					;LINE TO THE LOG FILE.

R.RCTL==R.SEOL!R.SEMI!R.MONC!R.INTR!R.USER!R.BLNK	;ALL THE FLAGS SET BY
					;RDCTL, DEFINED FOR WHERE WE ZERO THEM
					;ALL AT ONCE.


L.NOEL==1				;FLAG TO TELL SNDLOG TO SUPPRESS THE CRLF


;MACRO DEFINITIONS
	DEFINE	ERROR(MSG,TO<0>)<
	XLIST
	ERR1	[TO,,[ASCIZ \MSG\]]
	LIST
	>
	DEFINE	BUG(STR)<
	XLIST
	PUSHJ	P,[PUSHJ P,BUGMSG
		ASCIZ /STR/]
	LIST
	>				;END BUG MACRO
	SUBTTL	PRIMARY FORK CODE
;INITALIZATION
START:	JRST	START0			;NORMAL START

START0:	RESET				;CLEAN ALL THINGS UP
	MOVE	P,[IOWD PDLL,PDL]	;INITALIZE THE STACK
	MOVE	A,116			;GET THE SYMBOL TABLE POINTER
	MOVEM	A,SYMPTR		;AND PUT IT WHERE THE INFERIORS 
					;CAN GET IT

	MOVE	A,[SIXBIT /TTYJOB/]	;GET SYSTEM TABLE NUMBERS
	SYSGT
	HRRZM	B,TTYJOB
	MOVE	A,[SIXBIT /JOBTTY/]
	SYSGT
	HRRZM	B,JOBTTY
	MOVE	A,[SIXBIT /JOBRT/]
	SYSGT
	HRRZM	B,JOBRT
	MOVE	A,[SIXBIT /JOBNAM/]
	SYSGT
	HRRZM	B,JOBNAM
	MOVE	A,[SIXBIT /SNAMES/]
	SYSGT
	HRRZM	B,SNAMES
	MOVE	A,['JOBDIR']
	SYSGT
	MOVEM	B,JOBDIR

;DETERMINE OUR STATUS (AND ENABLE OURSELF)
	SETZM	WHEEL			;ASSUME NON-WHEEL
	MOVEI	A,400000		;US
	RPCAP				;SEE WHAT WE HAVE
	MOVE	C,B			;ALL POSSIBLE
	EPCAP				;TURN THEM ON
	TRNE	C,600000		;WHEEL OR OPER?
	SETOM	WHEEL			;YES

;ARE WE DETACHED?
	GJINF				;FIND OUT ABOUT OURSELVES.
	MOVEM	D,DETSW			;SAVE STATUS
	MOVEM	C,JOBNO			;SAVE OUR JOB #
	SETOM	MYNAME			;SAY I'M THE TOP GUY IN THE PRIV PAGE
	MOVEI	A,101			;PRIMARY OUTPUT IS CRASH FILE
	MOVEM	A,CRSHJF		;FOR NOW

;CHECK IF WE HAVE TIME YET
WAITS:	GTAD			;GET WHAT WE HAVE
	CAME	A,[-1]		;GOT IT ?
	JRST	UUOINI		;YES, GO ON
	MOVEI	A,^D60000	;WAIT ONE MINUTE
	DISMS			;ZZZZ
	JRST WAITS		;DON'T GO ON TILL WE HAVE IT!!!!!
UUOINI:	MOVEM	A,BATSTT	;BATCH PROCESSOR START TIME

;INITALIZE LUUO TRAP

	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

	MOVEI	A,400000		;PRESENT FORK
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	MOVE	A,[XWD ^D19,2]
	ATI			;SET ^S FOR INFERIOR FORK STATUS
	MOVEI	A,400000
	HRLZI	B,100000	;INFERIOR HALTED AND ^S STATUS CHANNELS
	HRRI	B,200000
	AIC
	EIR
;INITALIZE FLAGS
	SETZ	F,			;CLEAR FLAG WORD
	IFN	GDDT,<
	PUSHJ	P,SETDDT	;SET UP DDT
	>

IFE	FSUSER,<			;STUFF IF SYSTEM BATCH
;DO A SETNM SO WE HAVE A NAME
	MOVE	A,[SIXBIT /BATCON/]	;OUR NAME IS 'BATCON'
	SETNM				;SET IT

;NOW GET CONNECTED TO THE BATCH Q DIRECTORY
	MOVEI	A,1			;TRY EXACT MATCH
	HRROI	B,BATDIR		;DIRECTORY NAME
	STDIR				;GET DIR #
	BUG(<Error return from STDIR for Q directory--no match>)
	BUG(<Error return from STDIR for Q directory--ambiguous>)
	TLZ	A,-1			;CLEAR LH
	MOVEM	A,BATDN			;SAVE SO WE CAN EXPUNGE DIR LATER
	SETZ	B,			;NO PASSWORD STRING
	CNDIR				;CONNECT TO IT
	BUG(<CNDIR to Q directory failed>)
;SETUP FILE TO GET BUG MESSAGES
	SKIPL	DETSW			;ARE WE DETACHED?
	JRST CRSHJ1			;NO,DON'T BOTHER WITH GETTING FILE
	MOVSI	A,1			;SHORT
	HRROI	B,CRASH			;CRASH MESSAGE FILE NAME
	GTJFN
	HALTF
	MOVEM	A,CRSHJF		;SAVE CRASH FILE MESSAGE JFN
	MOVE	B,[7B5!1B22!1B26]	;7 BIT,APPEND, WAIT
	QOPENF
	HALTF
CRSHJ1:
;[edit] messes up DDT and stuff on stand alone system
;;;	HRRZ	B,A			;OUTPUT JFN
;;;	MOVEI	A,400000		;THIS FORK
;;;	SPJFN				;MESSAGES TO FILE INSTEAD OF LOGGING TTY
	>				;END IFE FSUSER
IFE	FSUSER,<			;GENERATE SYSTEM BATCON STUFF
;SCAN THE QUEUES FOR A JOB TO RUN, THEN SET UP THE
;PARAMETERS FOR THE RUN.

;FIRST, OPEN THE BATCH QUEUE
GETJOB:	MOVE	A,HLTDFK		;BIT SET FOR EACH HALTED FORK
	JFFO	A,EOJ10			;HALTED FORK FOUND
	MOVSI	A,(1B7!1B17)		;NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE

	GTJFN
	BUG(<GETJOB: Gtjfn failure for Q>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

	MOVE	B,[1,,FDBUSW]		;GET THE USER SETTABLE WORD
	MOVEI	C,MXJBNO#		;WHERE TO PUT IT
	GTFDB

;NOW CHECK FOR ANY WORK TO ADD TO THE QUEUE
	MOVE	A,[1B2!1B7!1B11!1B17!1B26]	;OLD,NO OTHER ACCESS,INPUT,WAIT *,SHORT
	HRROI	B,JBNAMS		;GET FORMAT OF JOB NAMES
	GTJFN				;GET THE JFN
	JRST	GETDSB			;NONE, CHECK FOR DESUBMISSIONS
	PUSH	P,A			;SAVE GROUP JFN
	MOVE	A,QJFN			;GET JFN OF Q
	MOVE	B,[440000,,20000]	;OPEN FOR APPEND
	QOPENF				;OPEN THE Q
	BUG(<Cannot open Q for append>)
GETJB0:	HRRZ	A,(P)			;OPEN THE JOB FILE
	MOVE	B,[440000,,200000]	;FOR READ
	QOPENF				;OPEN IT
	BUG(<CANNOT OPEN JOB ENTRY>)
	HRRZ	A,(P)			;SAVED JOB JFN
	MOVE	B,[1,,FDBVER]		;VERSION NUMBER IS JOB NUMBER
	MOVEI	C,C			;WHERE TO PUT IT
	GTFDB
	HLRZ	C,C			;JUST VERSION NUMBER
	CAMGE	C,MXJBNO		;GREATER THAN GREATEST
	 JRST	GETJB3			;NO
	AOS	C			;1 GREATER
	MOVEM	C,MXJBNO		;NEW MAXIMUM
	MOVE	A,QJFN			;JFN FOR Q
	HRLI	A,FDBUSW		;WORD TO CHANGE
	MOVEI	B,777			;WRAP AROUND AT 512
	CHFDB				;NEW VALUE
	HRRZ	A,0(P)			;GET JFN AGAIN FOR JOB FILE
GETJB3:
	MOVE	B,[POINT 36,QENT]	;POINT TO WHERE WE PUT IT
	MOVNI	C,QESIZE		;IT'S LENGTH
	SIN				;READ IT

;NOW CHECK IT FOR LEGALITY
	MOVSI	B,25			;25 WORDS, STARTING WITH FIRST
	MOVEI	C,FDBBLK		;WHERE WE READ FDB INTO
	GTFDB				;READ THE FDB
	HLRZ	A,FDBBLK+6		;GET LAST WRITER (AUTHOR(?))
	CAME	A,QENT			;DID HE GIVE RIGHT NUMBER IN ENTRY?
	JRST	GETJB1			;NO-HE FIBS-SO WE FLUSH HIM

;	CHECK SIZE OF ENTRY
	MOVE	A,FDBBLK+12		;BYTE COUNT
	CAMN	A,QESIZE		;COMPARE WITH QUEUE SIZE
	JRST	GETJB1			;NO-HE FIBS-SO WE FLUSH HIM

;APPEND IT TO MASTER QUEUE IF IT WAS LEGAL
	MOVE	A,QJFN			;GET Q'S JFN
	MOVE	B,[POINT 36,QENT]
	MOVNI	C,QESIZE		;IT'S LENGTH
	SOUT				;WRITE IT

;DELETE IT
GETJB1:	HRRZ	A,(P)			;GET THE JFN
	TLO	A,(1B0)			;DON'T RELEASE THE JFN
	CLOSF				;CLOSE THE ENTRY FILE
	BUG(<Cannot CLOSF this job entry.>)
	DELF				;DELETE THE FILE
	BUG(<CAN'T DELETE THE JOB FILE>)

;GET NEXT ONE
	MOVE	A,(P)			;GET JFN AGAIN
	GNJFN				;GET NEXT
	TRNA				;NO MORE
	JRST	GETJB0			;AND GO BACK
	POP	P,A			;GET JFN WE USED
	RLJFN				;RELEASE IT
	BUG(<ERROR RELEASING JOBS JFN>)

	MOVE	A,QJFN			;CLOSE IN ORDER TO CHANGE ACCESS
	TLO	A,400000		;KEEP JFN
	CLOSF
	BUG	<(CANNOT CLOSE Q JFN>)

;NOW CHECK FOR ANY WORK TO DELETE FROM THE QUEUE

GETDSB:	MOVSI	A,(1B2!1B7!1B11!1B17)	;OLD,NO OTHER ACCESS,INPUT *,SHORT
	HRROI	B,DJBNMS		;GET FORMAT OF JOB NAMES
	GTJFN				;GET THE JFN
	JRST	GETJB2			;NONE
	PUSH	P,A			;SAVE GROUP JFN
	MOVE	A,QJFN			;GET JFN OF Q
	MOVE	B,[440000,,300000]	;OPEN FOR READ AND WRITE
	QOPENF				;OPEN THE Q
	BUG(<Cannot open Q for append>)

	MOVE	A,QJFN
	MOVE	B,[1,,12]		;NUMBER OF BYTES DATA FROM FILE
	MOVEI	3,D			;REGISTER TO PUT BYTE COUNT INTO
	GTFDB
	IDIVI	D,QESIZE		;CALCULATE NUMBER OF ENTRIES
	MOVNM	D,NUMENT		;SAVE NEGATIVE OF NUMBER OF ENTRIES

OPDREQ:	HRRZ	A,(P)			;OPEN THE DESUBMIT REQUEST FILE
	MOVE	B,[440000,,200000]	;FOR READ
	QOPENF				;OPEN IT
	BUG(<CANNOT OPEN DESUBMIT JOB ENTRY>)
	MOVE	B,[POINT 36,DQENT]	;POINT TO WHERE WE PUT IT
	MOVNI	C,QESIZE		;IT'S LENGTH
	SIN				;READ IT

;NOW CHECK IT FOR LEGALITY
	MOVSI	B,25			;25 WORDS, STARTING WITH FIRST
	MOVEI	C,FDBBLK		;WHERE WE READ FDB INTO
	GTFDB				;READ THE FDB
	HLRZ	A,FDBBLK+6		;GET LAST WRITER (AUTHOR(?))
	CAME	A,DQENT			;DID HE GIVE RIGHT NUMBER IN ENTRY?
	JRST	DELDRQ			;NO-HE FIBS-SO WE FLUSH HIM

;	CYCLE THROUGH QUEUE, LOOKING FOR ENTRY TO BE DEQUEUED
	HRLZ	E,NUMENT
CHKENT:	MOVE	A,QJFN
	MOVE	B,[POINT 36,QENT]
	MOVNI	C,QESIZE
	SIN				;INPUT ENTRY FROM QUEUE

	HRROI	A,-1
	CAMN	A,QENT+STRTED		;JOB MARKED FOR DESUBMISSION ?
	JRST	CHKNXT			;YES, LOOK FOR NEXT

;	SEE IF THIS ENTRY IS TO BE DESUBMITTED
	MOVE	A,QENT+USRDIR		;USER DIRECTORY FROM QUEUE ENTRY
	CAME	A,DQENT+USRDIR		;USER DIRECTORY FROM DEQUEUE REQUEST
	JRST	CHKNXT			;DIFFERENT SO GO CHECK NEXT

	MOVE	B,QENT+BJOBNO		;JOBNO OF ENTRY
	CAME	B,DQENT+BJOBNO		;IS IT SAME?
	 JRST	CHKNXT			;NO

;	FOUND ENTRY TO DESUBMIT
	SKIPE	QENT+STRTED		;HAS JOB BEEN STARTED
	JRST	STOPRN			;YES, GO STOP RUNNING FORK

	PUSHJ	P,MARK			;GO MARK ENTRY FOR DESUBMISSION
					;BY QCOPY

	JRST	CHKNXT			;CHECK NEXT ENTRY

;	STOP RUNNING FORK
STOPRN:	HLRZ	A,QENT+STRTED		;GET FORK HANDLE
	RFSTS				;GET FORK STATUS

	JUMPL	A,CHKNXT		;JUMP IF NON-EXISTANT
	HLRZS	A			;ISOLATE INFERIOR FORK STATE
	CAIGE	A,2			;IS FORK HALTED
	JRST	INTINF			;RUNNING, SO INTERRUPT
	CAILE	A,3			;FORK TERMINATED ?
	JRST	INTINF			;NO, SO ISSUE INTERRUPT
	JRST	CHKNXT			;YES, GO CHECK NEXT

;	INTERRUPT INFERIOR
INTINF:	HLRZ	A,QENT+STRTED
	HRLZI	B,200000		;PSEUDO INTERRUPT ON CHANNEL 1
	IIC

CHKNXT:	AOBJN	E,CHKENT

;	DELETE DESUBMIT JOB REQUEST
DELDRQ:	HRRZ	A,(P)			;GET THE JFN
	TLO	A,(1B0)			;DON'T RELEASE THE JFN
	CLOSF				;CLOSE THE ENTRY FILE
	BUG(<Cannot CLOSF this job entry.>)
	DELF				;DELETE THE FILE
	BUG(<CAN'T DELETE THE JOB FILE>)

;GET NEXT ONE
	MOVE	A,(P)			;GET JFN AGAIN
	GNJFN				;GET NEXT
	TRNA				;NO MORE
	JRST	OPDREQ			;AND GO BACK
	POP	P,A			;GET JFN WE USED
	RLJFN				;RELEASE IT
	BUG(<ERROR RELEASING JOBS JFN>)

;'EXPUNGE' THE BATCH DIRECTORY
	MOVE	A,BATDN			;GET DIRECTORY NUMBER
	DELDF				;EXPUNGE IT

;CLOSE MASTER Q FILE
	HRRZ	A,QJFN			;GET JFN
	TLO	A,(1B0)			;SAVE JFN
	CLOSF				;AND CLOSE FILE
	BUG(<CAN'T CLOSE Q AFTER APPEND>)

;NOW OPEN IT FOR READ TO SCAN FOR JOBS (ALSO WRITE SO WE
;CAN RECORD THAT WE SELECTED A JOB).
GETJB2:	MOVE	A,QJFN			;JFN FOR THE BATCH Q
	MOVE	B,[44B5!1B19!1B20]	;36 BIT,READ,WRITE
	QOPENF
	JRST	QOPENE			;CHECK THE ERROR OUT

;SCAN THROUGH THE QUEUE FOR A JOB TO RUN
	SETOM	BESTPR			;BEST PRIORITY IS -1 (NOT USEABLE)
	SETZM	QPNTR			;INIT POINTER FOR Q SCAN

;CHECK TO SEE THAT Q IS NOT SCREWED UP, ALSO GET THE
;SIZE OF THE Q SO WE CAN COMPUTE NUMBER OF ENTRYS.
	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,[2,,11]		;2 WDS, STARTING AT WD 11
	MOVEI	C,D			;WHERE TO STORE IT
	GTFDB				;READ FROM FDB
	JUMPE	E,NOJOBS		;CHECK FOR NULL QUEUE
	LDB	B,[POINT 6,D,11]	;GET BYTE SIZE
	CAIE	B,^D36			;MUST BE 36 BIT
	BUG(<BYTE SIZE OF Q IS NOT 36>)
	MOVE	B,E			;GET # WDS
	IDIVI	B,QESIZE		;DIVIDE BY ENTRY SIZE
	CAIE	C,0			;MUST GO EVENLY
	BUG(<QUEUE DOES NOT CONTAIN EVEN NUMBER OF ENTRIES>)
	MOVEM	B,NQENT			;SAVE NUMBER OF ENTRIES

;NOW READ IN A QUEUE ENTRY SO WE CAN EXAMINE IT.
RDQ:	MOVE	A,QJFN			;GET JFN FOR Q
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;GET AMT TO READ
	SIN

;CHECK TO SEE IF THIS IS A REAL QUEUE ENTRY OR DESUBMISSION REQUEST.
;IGNORE DESUBMITTED OR NULL ENTRIES.
	SKIPG	QENT			;DOES IT HAVE A DIR TO LOGIN?
	JRST	NOTTHS			;NO--CANNOT RUN HIM
					;HE WILL BE PURGED BY QCOPY

	HRROI	A,-1
	CAMN	A,QENT+STRTED		;IS IT MARKED FOR DESUBMISSION ?
	JRST	NOTTHS			;YES, IGNORE IT. QCOPY WILL DELETE IT

;SEE IF RESTART COUNT EXCEEDED. IF SO, MARK ENTRY FOR DELETION.
	HRROI	A,-2
	CAMGE	A,QENT+RESTRT		;LIMIT EXCEEDED
	JRST	RDQ1			;NO

	PUSHJ	P,MARK			;MARK ENTRY FOR DELETION

	JRST	NOTTHS			;IGNORE ENTRY

;CHECK IF LOAD AVERAGE IS LOW ENOUGH TO RUN THIS JOB
RDQ1:
IFE	SRISYS,<
	MOVE	A,[SIXBIT /LOADTB/]	;SYSTEM LOAD TABLE
	SYSGT				;GET TABLE NUMBER
	MOVE	A,B			;SET UP TABLE NUMBER
	HRLI	A,3			;OFFSET TO LOAD AVERAGE
>
IFN	SRISYS,<
	MOVE	A,['SYSTAT']
	SYSGT
	SKIPN	A,B
	BUG	(<RDQ1: Sysgt for SYSTAT failed>)
	HRLI	A,14			;ENTRY 14 IS 1 MIN LOAD AV
	GETAB
	SETZ	A,
	MOVE	C,A
	MOVE	A,B
	HRLI	A,15			;5 MIN LOAD AV
	GETAB
	SETZ	A,
	CAMGE	A,C
	MOVE	C,A
	MOVE	A,B
	HRLI	A,16			;15 MIN LOAD AV
	GETAB
	CAML	A,C
	MOVE	A,C
>
	CAML	A,QENT+LOADAV		;COMPARE WITH REQUEST
	JRST	NOTTHS			;SYSTEM TOO BUSY
;CHECK TO SEE IF IT HAS ALREADY BEEN STARTED.
;BY ANOTHER BATCON, OR IF IT IS ONE WE DIED ON.
	HRRZ	A,QENT+STRTED		;GET WHO STARTED IT
	JUMPE	A,RDQ2			;DID ANYBODY-JUMP IF NOT
	CAME	A,JOBNO			;WAS IT US?
	JRST	NOTTHS			;NO-CAN'T CONSIDER IT
	MOVE	A,QENT+JOBSTT		;TIME BATCH JOB STARTED
	CAML	A,BATSTT		;TIME BATCH PROCESSOR STARTED
	JRST	NOTTHS			;HE IS PROBABLY ALREADY RUNNING
	SETZM	QENT+STRTED		;YES, CLEAR RESTART WORD
	MOVE	A,QJFN			;GET SET TO WRITE IT BACK OUT
	MOVE	B,QPNTR			;WHERE IT GOES
	SFPTR				;RESET POINTER IN FILE
	BUG(<RDQ1: Failed to reset Q file pointer>)
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;AMOUNT TO WRITE
	SOUT				;WRITE IT BACK


;NOW EVALUATE IT'S PRIORITY TO SEE IF WE WANT TO RUN IT
RDQ2:	PUSHJ	P,EVPRIO		;GO COMPUTE PRIORITY
	CAMG	A,BESTPR		;IS THIS ONE BETTER?
	JRST	NOTTHS			;NO

;GOT A BETTER ONE, SO COPY INFO TO ACTIVE ENTRY
	MOVEM	A,BESTPR		;IS NOW THE BEST PRIORITY
	MOVE	A,QPNTR			;GET WHERE WE ARE IN Q
	MOVEM	A,BESTPT		;SAVE IT

;NOW GO ON TO NEXT ONE (IF IT EXISTS) AND LOOP THROUGH Q
NOTTHS:	MOVEI	A,QESIZE		;GET ENTRY SIZE
	ADDM	A,QPNTR			;UPDATE POINTER

	SOSLE	NQENT			;COUNT ENTRY,
	JRST	RDQ			;READ NEXT IF MORE

;DETERMINE IF THERE WAS AN ENTRY WORTH USING.
;GO IDLE IF NOT.  READ IT IN IF SO.
	SKIPG	BESTPR			;ONE WORTH DOING?
	JRST	NOJOBS			;NO

	MOVE	A,ACTFRK		;GET NUMBER OF ACTIVE FORKS
	CAIL	A,MAXFK			;COMPARE WITH MAXIMUM ALLOWABLE INFERIORS
	JRST	NOJOBS			;ALL FORKS BUSY

	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,BESTPT		;WHERE TO POINT TO
	SFPTR				;POINT TO ENTRY
	BUG(<NOTTHS: Failed to set Q file pointer>)

	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY BUFFER
	MOVNI	C,QESIZE		;GET ENTRY SIZE
	SIN				;GET ENTRY

;GET INFORMATION ABOUT THE USER WE ARE STARTING.
	MOVE	A,QENT+USRDIR		;GET HIS DIR NUMBER
	MOVEI	B,USRBLK		;POINT TO PLACE FOR DIR INFO
	SETZ	C,			;WE DON'T WANT HIS PASSWORD
	GTDIR				;FIND OUT ABOUT HIM

;GET THE LOG FILE
	MOVSI	A,(1B17)	; SHORT
	HRROI	B,QENT+LOGFIL		;GET PTR TO NAME
	GTJFN
	JRST CKLGF1			;CAN'T GET LOG, FLUSH JOB

;CHECK ACCESS TO LOG FILE
	PUSH	P,A			;SAVE JFN FOR LOG FILE

;FIRST CHECK IF ON DSK: OR LPT:, IF NOT BOMBOUT.
	DVCHR				;GET DEVICE CHARACTERISTICS
	HLRZ	A,A			;GET DEVICE DESIGNATOR
	CAIN	A,DEVDSK		;IS DEVICE DSK?
	JRST	CKLOG0			;YES
	CAIN	A,DEVNIL		;IS DEVICE NIL:?
	JRST	CKLOGS			;YES-ALLOW IT
	CAIE	A,DEVLPT		;IS IT LPT?
	JRST	CKLOGF			;NO - FAIL

;NOW WE KNOW IT IS LPT:, MAKE A REAL FILE NAME FOR IT
	POP	P,A			;FIRST RELEASE THE OLD JFN
	CAIGE	A,2		;LEGAL JFN ?
	JRST	.+3		;NO -- DON'T RELEASE IT
	RLJFN				;RELEASE IT NOW
	BUG(<RLJFN failed in release of LPT:>)
	HRROI	A,FDBBLK		;WHERE TO PUT USER NAME
	MOVE	B,QENT+USRDIR		;HIS DIR NUMBER
	DIRST				;MAKE A STRING OF IT
	BUG(<DIRST failed in LPT file creater>)
	TIME				;GET TIME AS FILE EXTENSION RANDOMIZER
	TRZ	A,400000		;VERSION NUMBERS MUST BE .LE. 400000
	HRRM	A,LOGBLK		;STORE IN LOG JFN BLOCK
	MOVEI	A,LOGBLK		;LOG JFN BLOCK
	SETZ	B,			;NO MAIN STRING POINTER
	GTJFN				;GET A JFN
	BUG(<Can't GTJFN file in <PRINTER>.>)
	PUSH	P,A			;SAVE THE JFN

;	INSURE UNIQUE TIME GENERATED VERSION BY DELAAYING 2 SECOND
	MOVEI	A,^D2000
	DISMS
	JRST	CKLOGS			;AND ALLOW ACCESS

;IT IS KNOWN TO BE ON DSK: IF WE GET HERE.
CKLOG0:	MOVE	A,(P)			;GET JFN BACK
	MOVSI	B,(1B1)			;WE WILL NEED WRITE ACCESS.
	PUSHJ	P,CHKACC		;CAN HE USE IT?
	JRST	CKLOGF			;NO-CLEAN UP
	MOVE	B,DIRNMF		;GET DIR # FILE IS IN (SAVED
					;BY CHKACC).
	CAILE	B,1			;SYSTEM DIRECTORY??  ***SRI-AIC***
	CAMN	B,BATDN			;IS IT <BATCH>?
	JRST	CKLOGF			;NOT A LEGAL DIRECTORY
	JRST	CKLOGS			;ALL SEEMS LEGAL
CKLOGF:	POP	P,A			;ILLEGAL ACCESS ATTEMPT IF HERE
	RLJFN				;RELEASE THE JFN USED
	BUG(<CKLOGF RLJFN failure>)
CKLGF1:	MOVE	A,QJFN			;FOR THE Q
	SETZ	B,			;MARK ENTRY AS NULL FOR FLUSH
	MOVE	C,BESTPT		;START OF ENTRY
	ADDI	C,USRDIR		;THIS WORD INTO IT
	ROUT				;DO IT
	JRST NOJOBS			;FORGET ABOUT THIS JOB

CKLOGS:	POP	P,A			;RESTORE JFN-LEGAL ACCESS

;OPEN THE LOG FILE.
	MOVE	B,[7B5!1B20]		;7BIT,WRITE
	QOPENF
	BUG	(<CAN'T OPEN LOG FILE AFTER CKLOGS>)
	MOVEM	A,LOGJFN		;SAVE LOGJFN
;CHECK IF RESTART LIMIT EXCEEDED
	SETO	B,
	CAMLE	B,QENT+RESTRT
	ERROR	<RESTART LIMIT EXCEEDED>,CLLOG ;JUST PRINT AND CLOSE

;GET THE CTL FILE
	MOVSI	A,(1B2!1B17)		;OLD FILE, SHORT
	HRROI	B,QENT+CTLFIL		;GET CTL FILE NAME
	GTJFN
	JRST	[PUSH	P,[-1]
		 JRST   CKCTLF]

;CHECK ACCESS TO CTL FILE
	PUSH	P,A			;SAVE THE JFN
	MOVSI	B,(1B0)			;READ ACCESS
	PUSHJ	P,CHKACC		;CHECK ACCESS
	JRST	CKCTLF			;FAILURE
	JRST	CKCTLS			;SUCCESS
CKCTLF:	ERROR	<ILLEGAL TO ACCESS CTL FILE>
	MOVE	A,LOGJFN		;WRITE TENEX REASON WHY
	HRLOI	B,400000		;ON LOG FILE WITH
	SETZ	C,			;THE ERSTR JSYS
	ERSTR
	BUG(<ERSTR +1 in CKCTLF>)
	BUG(<ERSTR +2 in CKCTLF>)
	PUSHJ	P,SCRLF			;SEND A CRLF TO LOG FILE
	POP	P,A			;RESTORE JFN
	RLJFN				;RELEASE IT
	BUG(<RLJFN failure in CKCTLF>)
CLLOG:	SETZM	CTLJFN
	HRRZ	A,LOGJFN
	CLOSF
	JFCL
	SETZM	LOGJFN
	JRST CKLGF1			;AFTER CLOSING LOG MARK ENTRY AS NULL

CKCTLS:	POP	P,A			;LEGAL ACCESS-RESTORE JFN
	MOVEM	A,CTLJFN		;SAVE CTL FILE JFN

;	MARK ENTRY AS STARTED

	MOVE	A,QJFN			;LOOK AT THE Q NOW
	MOVE	B,QENT+RESTRT		;GET RESTART COUNT
	SUBI	B,1			;BACK IT UP BY 1
	MOVE	C,BESTPT		;GET POINTER TO THIS ENTRY
	ADDI	C,RESTRT		;DISP TO RESTRT COUNTER
	ROUT

	GTAD				;GET TIME
	MOVE	B,A
	MOVE	A,QJFN			;QUEUE JFN
	MOVE	C,BESTPT		;GET POINTER TO THIS ENTRY
	ADDI	C,JOBSTT		;DISP TO JOB START TIME
	ROUT				;PUT IN FILE
	PUSH	P,A			;SAVE QUEUE JFN
;NOW GET A FORK AND START IT UP
; WE DISABLE THE INTERRUPT SYSTEM TO PREVENT THE INTERRUPT SIDE
; FROM KILLING A FORK BEFORE WE HAVE A CHANCE TO MARK IT NOT STARTED

GINFK:	MOVEI	A,400000		;THIS FORK
	DIR				;DISABLE INTERRUPTS
	HRLZI	A,200000		;SAME CAPABILITIES ONLY
	CFORK
	JRST [	MOVEI	A,400000	;NO FORK AVAILABLE
		EIR			;REENABLE INTERRUPTS
		MOVEI	A,^D1000
		DISMS			;AND GO AWAY FOR A WHILE
		JRST GINFK]		;TRY AGAIN
	AOS	ACTFRK			;INCREMENT NUMBER OF ACTIVE FORKS
	MOVEM	A,RELFRK		;SAVE RELATIVE FORK HANDLE
	ANDI	A,77			;KEEP ONLY RELATIVE INDEX
	MOVN	A,A			;NEG FOR RIGHT SHIFT
	MOVSI	B,400000		;A BIT TO SHIFT RIGHT
	LSH	B,0(A)			;FOR MARKING THIS FORK HANDSOFF
	IORM	B,STRTFK		;TO THE INTERRUPT SIDE
	MOVEI	A,400000
	EIR				;SPRING THE INTERRUPT SYS

;COPY DATA FROM QUEUE ENTRY.
	MOVE	A,QENT+ETIME		;GET MAX ELAPSED TIME
	MOVEM	A,MAXETM		;SAVE IT

	MOVE	A,QENT+RTIME		;GET MAX CPU TIME
	MOVEM	A,MAXCPU		;SAVE IT

	MOVE	A,QENT+LOGLNS		;GET LIMIT OF LINES TO WRITE ON LOG
	MOVEM	A,MAXLOG		;SAVE IT
;START MAPPING THE LOWER FORKS ADDRESS SPACE

	HRLZI	D,-NINF			;NUMBER OF INFERIOR FORK PAGES
	MOVE	A,[XWD 400000,INFFK/1000]  ;SUPERIOR FORK PAGE
	HRRZ	B,A			;PAGE NUMBER OF INFERIOR
	HRL	B,RELFRK		;INFERIOR FORK HANDLE
	HRLZI	C,160000		;READ,EXECUTE, WRITE
MPLP:	PMAP
	AOS	A			;INCREMENT SOURCE PAGE
	AOS	B			;INCREMENT DESTINATION PAGE
	AOBJN	D,MPLP

	HRLZI	D,-NSHAR		;NUMBER OF INFERIOR SHARED PAGES
MPLPS:	MOVE	A,[XWD 400000,SHARE/1000]   ;SHARED PAGES
	HRRZ	B,A
	HRL	B,RELFRK
	HRLZI	C,160000		;READ,WRITE AND EXECUTE
	PMAP				;MAP PAGE TO INFERIOR
	AOS	A
	AOS	B
	AOBJN	D,MPLPS

;MAP PRIVATE INFERIOR PAGES TO INFERIOR. ONLY REALLY BELONG TO INFERIOR
;AFTER INFERIOR HAS TOUCHED THEM.
	MOVE	A,[XWD 400000,PRIV/1000]  ;SOURCE HANDLE FOR PMAP
	MOVE	B,A
	HRL	B,RELFRK		;DESTINATION HANDLE FOR PMAP
	HRLZI	C,120400		;READ,COPY WRITE,EXECUTE ACCESS
	HRLZI	D,-NPRIV			;NUMBER OF PRIVATE INFERIOR PAGES
MAPP:	PMAP				;MAP TO INFERIOR
	AOS	A
	AOS	B
	AOBJN	D,MAPP

;MAP SYMBOL TABLE PAGES TO INFERIOR. MAP SAME AS PRIV TO KEEP OVERLAPPED
;PAGES FROM CHANGING PROTECTION.

	SKIPN	A,SYMPTR		;GET SYMBOL TABLE POINTER
	JRST INFSRT			;GO START THE INFERIOR IF NO TABLE
	ASH	A,-^D9			;MAKE WORDS INTO PAGES
	HLLZ	D,A			;PACK AWAY THE COUNT AS AN AOBJN PTR
	SUB	D,[1,,0]		;TO GET THE LAST PAGE
	TRZ	A,777000		;GET RID OF THE SHIFTED LH BITS
	HRLI	A,400000		;SUPERIOR IS SOURCE
	MOVE	B,A
	HRL	B,RELFRK		;DESTINATION HANDLE FOR PMAP
MAPSYM:	PMAP				;MAP TO INFERIOR
	AOS	A
	AOS	B
	AOBJN	D,MAPSYM

; START IT UP AND WAIT FOR IT. TURN ON THE INTERRUPT SYSTEM
; WHEN WE KNOW IT IS OFF AND RUNNING

INFSRT:	MOVE	A,RELFRK		;RELATIVE FORK HANDLE
	MOVEI	B,INFFK			;STARTING ADDRESS
	SFORK				;START INFERIOR

;	MAKE SURE INFERIOR HAS STARTED BEFORE ATTEMPTING TO START ANOTHER
;	TO AVOID POSSIBLE RACE CONDITION AS FAR AS VARIOUS INFERIOR FORKS
;	TOUCHING THEIR RESPECTIVE DATA AREAS.
WATST:	MOVE	A,RELFRK		;GET FORK HANDLE
	RFSTS				;GET FORK STATUS
	CAIGE	A,0			;DO WE HAVE A FORK?
	BUG (<WATST: Fork does not exist!>)
	HRRZS	B			;GET INFERIOR PC
	CAILE	B,BUGMSG		;ARE WE RUNNING IN REAK CODE?
	JRST WATCMP			;SAFE TO CONTINUE
	MOVEI	A,^D5000		;5 SECOND DELAY
	DISMS
	JRST WATST

;CLEAN UP THE Q BEFORE GOING FOR ANOTHER

WATCMP:	POP	P,A			;GET BACK QUEUE JFN
	MOVE	B,JOBNO			;GET OUR ID
	HRL	B,RELFRK		;ADD FORK HANDLE FOR RUNNING FORK
	MOVE	C,BESTPT		;ORIGIN OF BLOCK ON DISK
	ADDI	C,STRTED		;+DISPLACEMENT INTO IT
	ROUT				;PUT WORD IN BLOCK
	MOVS	B,B			;FORK HANDLE INTO RH
	ANDI	B,77			;KEEP ONLY THE RELATIVE INDEX PART
	MOVN	B,B			;2'S COMP
	MOVSI	C,400000		;A BIT TO SHIFT
	LSH	C,0(B)
	ANDCAM	C,STRTFK		;CLEAR THE BIT (SAY IT IS ON ITS OWN)

;SET POINTER TO EOF, THEN CLOSE FILE
	SETO	B,			;-1 IMPLIES EOF
	SFPTR				;SET POINTER
	BUG(<NOTTHS: Tried to set Q file pointer for EOF and failed>)

	CLOSF				;DONE WITH Q FILE
	BUG(<NOTTHS: Closf on Q file failed>)
	SETZM	QJFN			;DONE WITH JFN
	JRST GETJOB			;GO START THE NEXT GUY
;PSI SERVICE FOR INFERIOR FORK HALTED

HLTNFK:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	MOVE	C,[IOWD MAXFK,2]	;START WITH INFERIOR FORKS
INFLP:	MOVEI	A,400000(C)		;FORK HANDLE
	RFSTS				;GET FORK STATUS
	HLRZS	A			;GET LEFT HALF
	CAIN	A,-1			;UNASSIGNED ?
	JRST	UNAS			;YES
	CAIE	A,2			;VOLUNTARY TERMINATION
	CAIN	A,3			;FORCED TERMINATION
	CAIA
	JRST	UNAS			;NOT TERMINATED
	HRRZ	B,C			;GET FORK NUMBER
	MOVNS	B			;NEGATIVE OF FORK INDEX
	HRLZI	A,400000		;BIT FOR SHIFTING
	LSH	A,0(B)			;POSITION BIT TO BIT NUMBER FOR 
					;HALTED FORK
	TDNE	A,STRTFK		;IS THIS FORK STILL BEING INITIALIZED?
	JRST UNAS			;YES, DON'T TOUCH IT
	IORM	A,HLTDFK		;MARK FORK AS HALTED
	HRRZI	A,400000(C)		;FORK HANDLE
	KFORK				;KILL HALTED FORK
	SOS	ACTFRK			;DECREMENT NUMBER OF ACTIVE FORKS
UNAS:	AOBJN	C,INFLP
	POP	P,C
	POP	P,B
	POP	P,A
	DEBRK
INFSTS:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	MOVE	C,[IOWD MAXFK,2]		;START WITH INFERIOR FORKS
;
;	OUTPUT STATUS OF INFERIOR FORKS
;
INFSTL:	MOVEI	A,400000(C)		;FORK HANDLE
	RFSTS				;GET FORK STATUS
	HRRZ	D,A			;SAVE PC
	HLRZS	A			;GET LEFT HALF
	CAIN	A,-1			;UNASSIGNED ?
	JRST	UNASS			;YES
	MOVEI	A,101			;PRIMARY OUTPUT
	MOVEI	B,37
	BOUT
	MOVEI	B,FST(A)		;POINTER TO DESCRIPTOR STRING
	SETZ	C,
	SOUT
	HRROI	B,[ASCIZ /AT /]
	SETZ	C,
	SOUT
	MOVE	B,D			;RETEIVE PC
	MOVEI	C,10			;OCTAL
	NOUT
UNASS:	AOBJN	C,INFSTL
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	DEBRK


EOJ10:	MOVEM	B,EOJFK		;SAVE FORK TO SEARCH QUEUE FOR
	MOVN	B,B			;NEGATIVE FORK INDEX
	MOVSI	A,400000		;STARTING BIT
	LSH	A,0(B)			;POSITION BIT
	ANDCAM	A,HLTDFK		;SHOW WE ARE TAKING CARE OF IT
;NOW WE MUST PURGE THE JOB FROM THE QUEUE

	IFE	FSUSER,<
IFE	FSTCPY,<			;DO WE WANT PMAP TRIMMER?
;TRIM QUEUE WITH FANCY END POINTER AND PMAP TRIMMER.

EOJ3:	MOVSI	A,(1B7!1B17)		;NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG(<EOJ3: Gtjfn failed for Q file>)

	MOVE	B,[44B5!1B19!1B20]	;36 BIT,READ,WRITE
	QOPENF
	BUG(<EOJ3: Qopenf failed>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE BATCH Q

;CHECK TO SEE THAT Q IS NOT SCREWED UP, ALSO GET THE
;SIZE OF THE Q SO WE CAN COMPUTE NUMBER OF ENTRYS.
	MOVE	A,QJFN			;GET Q JFN
	MOVE	B,[2,,11]		;2 WDS, STARTING AT WD 11
	MOVEI	C,D			;WHERE TO STORE IT
	GTFDB				;READ FROM FDB
	JUMPG	D,.+2			;IF Q NON NULL
	BUG(<NULL QUEUE BUT WE RAN A JOB IN IT>)
	LDB	B,[POINT 6,D,11]	;GET BYTE SIZE
	CAIE	B,^D36			;MUST BE 36 BIT
	HALTF
	MOVE	B,E			;GET # WDS
	IDIVI	B,QESIZE		;DIVIDE BY ENTRY SIZE
	CAIE	C,0			;MUST GO EVENLY
	HALTF

;ZERO OUT THE Q ENTRY WE JUST DID
	SETZM	QENT			;ZERO OUT CORE AREA
	MOVE	A,[QENT,,QENT+1]	;BLT WORD
	BLT	A,QENT+QESIZE-1		;DO IT ALL

	MOVE	A,QJFN			;GET JFN FOR Q
	MOVE	B,BESTPT		;GET POINTER TO THIS ENTRY
	SFPTR				;POINT TO IT IN FILE
	BUG(<EOJ3: Sfptr failed on Q file>)
	MOVE	B,[POINT 36,QENT]	;POINT TO ENTRY
	MOVNI	C,QESIZE		;AND GET LENGTH
	SOUT				;WRITE ZEROS ON IT

;FIND POSITION OF LAST REAL QUEUE ENTRY.
	MOVE	C,E			;GET EOF POINTER
TRMSLP:	SUBI	C,QESIZE		;FIND POINTER TO LAST ENTRY
	JUMPL	C,TRMSLE		;IF WE WENT NEGATIVE,TRIM IT ALL
	RIN				;GET A BYTE (DIRNUM TO USE)
	JUMPE	B,TRMSLP		;IF 0,NOT A JOB,SO TRY ANOTHER
	MOVE	B,C			;YES,POINT PAST END AND CLEAN UP
	ADDI	B,QESIZE		;SKIP AROUND GOOD ONE
	JRST	.+2			;SKIP NEXT INSTRUCTION
TRMSLE:	SETZ	B,			;HERE IF WE TRIM IT ALL
	SFPTR				;SET FILE POINTER
	BUG(<TRMSLP: Sfptr failed on Q file>)

;FIND AND DELETE ANY PAGES OF Q BEYOND END
	SUBI	B,1			;GET LAST WORD ADDRESS
	JUMPL	B,TRMALL		;WE ARE TRIMMING IT ALL
	LSH	B,-^D9			;GET PAGE # LAST WORD ON
	MOVE	D,B			;PUT IT IN D
	ADDI	D,1			;GET FIRST FREE PAGE
	JRST	TRMQ			;SKIP NEXT INSTRUCTION
TRMALL:	SETZ	D,			;WE TRIM IT ALL
TRMQ:	HRLZ	A,QJFN			;GET Q JFN
	HRR	A,D			;GET PAGE #
	FFUFP				;FIND ANY PAGES
	JRST	NOTRMQ			;PERHAPS NO MORE
	MOVE	B,A			;PAGE TO KILL
	SETO	A,			;SAY KILL IT
	SETZ	C,			;NO ACCESS 
	PMAP				;KILL PAGE
	JRST	TRMQ			;GO FOR ANOTHER

NOTRMQ:	CAIE	A,FFUFX3		;REALLY NO MORE?
	BUG(<NOTRMQ: We thought there weren't more pages but..>)

;CLOSE THE QUEUE FILE
	HRRZ	A,QJFN			;BE SURE TO RELEASE JFN HERE
	CLOSF				;THE LH 0 PROVIDES THAT
	BUG(<NOTRMQ: Tried to close-release Q file after trim and lost>)
	SETZM	QJFN			;Q NOT OPEN

	JRST	GETJOB			;MORE WORK
	>				;END IFE FSTCPY-TRIM W/O COPY
;TRIM THE QUEUE WITH THE COPY OPERATION
IFN	FSTCPY,<			;ARE WE TRIMMING WITH A COPY?

;BEWARE--THESE ROUTINES DO NOT YET PROVIDE EXCLUSION OF OTHER
;ACCESS TO THE BATCH QUEUE DURING THESE OPERATIONS.  THUS IF
;THERE IS ANOTHER BATCON RUNNING, HE MAY ACCESS THE QUEUE
;AT THE SAME TIME, CAUSING BAD RESULTS.  ALSO A SUBMIT
;MAY HAVE ACCESS TO THE QUEUE WHICH WOULD CAUSE TROUBLE.

EOJ3:	MOVSI	A,(1B7!1B17)		;NO ACCESS BY OTHER FORKS, SHORT
	HRROI	B,QNAME			;GET NAME OF THE QUEUE
	GTJFN
	BUG(<FSTCPY EOJ3: Gtjfn failure on Q>)
;OPEN THE OLD QUEUE FOR READ AND WRITE.
	MOVE	B,[440000,,300000]	;36 BIT, READ AND WRITE
EOJ31:	QOPENF
	BUG(<ERROR OPENING OLD QUEUE>)	;NO OTHER PROBLEM

	MOVEM	A,OLDQ#			;SAVE JFN FOR OLD Q

	MOVSI	A,600001		;GET JFN FOR NEW NAME OF QUEUE
	HRROI	B,TMPNAM		;NAME OF THE TEMPORARY.
	GTJFN
	BUG(<GTJFN FAILED FOR NEWNAME FOR Q>)
	MOVE	B,[440000,,100000]	;OPEN FOR 36 BIT WRITE
	QOPENF
	BUG(<FSTCPY EOJ31: Qopenf failure>)
	MOVEM	A,QJFN			;SAVE THE JFN FOR THE Q

;COPY LOOP FOR THE QUEUE
	SETZM	QPNTR			;STARTING AT START OF Q
QCOPY:	HRRZ	A,OLDQ			;CHECK FOR 0 LENGTH FILE
	MOVE	B,[1,,12]		;DISPLACEMENT FOR BYTE SIZE
	MOVEI	C,C
	GTFDB
	JUMPG	A,.+3
	SETZM	HLTDFK
	JRST	QCOPYE
	MOVE	A,OLDQ			;GET OLD Q JFN
	MOVE	B,[POINT 36,QENT]	;WHERE TO PUT IT
	MOVNI	C,QESIZE		;AMOUNT TO READ
	SIN

	GTSTS				;READ STATUS BITS
	TLNE	B,1000			;WAS EOF READ?
	JRST	QCOPYE			;YES-END OPERATION

	MOVE	B,EOJFK			;GET FORK INDEX
	HRRZI	B,400000(B)		;CONSTRUCT FORK HANDLE
	MOVE	A,JOBNO			;GET OUR JOB #
	HRL	A,B			;CONSTRUCT IDENTIFIER OF INTEREST
	CAME	A,QENT+STRTED		;IS IT THE ONE WE STARTED?
	JRST	QCOPY1			;NO
	MOVN	B,EOJFK			;YES-DELETE IT.
	HRLZI	A,400000		;INITIAL BIT MASK
	LSH	A,0(B)			;POSITION BIT
	ANDCAM	A,HLTDFK		;CLEAR BIT
	SETZM	EOJFK			;CLEAR END OF JOB FORK INDEX
	JRST	QCOPY2			;DELETE THE ENTRY FROM QUEUE
QCOPY1:	SKIPG	A,QENT+USRDIR		;IS THIS ENTRY MARKED FOR 
					;DESUBMISSION OR A NULL ENTRY ?
	JRST	QCOPY2			;YES-DELETE IT

	MOVE	A,QJFN			;YES
	MOVE	B,[POINT 36,QENT]	;POINT TO IT
	MOVNI	C,QESIZE		;SIZE OF IT
	SOUT				;PUT IT OUT

QCOPY2:	MOVEI	A,QESIZE		;AMOUNT WE DID
	ADDM	A,QPNTR			;COUNT IT

	JRST	QCOPY			;AND GO FOR MORE

QCOPYE:	HRRZ	A,QJFN			;CLOSE THE OLD QUEUE
	TLO	A,(1B0)			;BUT DON'T RELEASE JFN
	CLOSF
	BUG(<ERROR CLOSING NEW QUEUE>)
	HRRZ	A,OLDQ			;NOW CLOSE THE OLD ONE
	TLO	A,(1B0)			;ALSO KEEP THE JFN
	CLOSF
	BUG(<ERROR CLOSING OLD QUEUE>)

	MOVE	A,QJFN		;CHANGE USER SETTABLE WORD
	HRLI	A,FDBUSW		;WHAT TO CHANGE TO
	MOVE	C,MXJBNO		;CHANGE ALL BITS
	SETO	B,
	CHFDB
	MOVE	A,QJFN			;THE REAL Q NOW
	MOVE	B,OLDQ			;THE NAME WE GIVE IT
	RNAMF				;DO RENAME TO NORMAL NAME
	BUG(<RNAMF FAILED IN Q RENAME>)

	MOVE	A,OLDQ			;RELEASE THE QUEUE JFN
	RLJFN
	BUG(<CANNOT RELEASE Q JFN AFTER REWRITE>)

	SETZM	RUNQCP			;CLEAR RUN QCOPY FLAG

	JRST	GETJOB			;GO FOR MORE WORK
;	*** STILL IN  IFE FSUSER  CONDITIONAL ***

;WAIT FOR WORK TO COME
NOJOBS:	HRRZ	A,QJFN			;BATCH QUEUE JFN
	CLOSF				;CLOSE AND RELEASE JFN
	ERROR	<NOJOBS: CAN'T CLOSE QUEUE JFN>,ABEND
NOJB1:	SKIPGE	RUNQCP			;ENTRIES TO DELETE FROM BATCH QUEUE ?
	JRST	EOJ3			;YES, GO CLEAN UP QUEUE

	MOVEI	A,^D60000		;ONE MINUTE
	DISMS				;WAIT
	JRST	GETJOB			;TRY FOR ANOTHER JOB
	>
	>				;END IFE FSUSER
;CALL:	A/ JFN OF DESIRED FILE
;	B/ BIT FOR ACCESS DESIRED (IN BITS 0-5)
;RETURNS	+1 IF ILLEGAL ACCESS
;		+2 IF ACCESS OK

;VALUES USED HERE
ACCBWR==200000,,0
ACCBAP==040000,,0

CHKACC:	PUSH	P,A			;STASH THE ARGUMENTS
	PUSH	P,B			; ..
	HRROI	A,DIRBLK		;TEMP FOR THE DIRECTORY NAME
	HRRZ	B,-1(P)			;THE JFN
	MOVSI	C,(1B5)			;JFNS TO OUTPUT JUST DIRECTORY
	JFNS
	MOVEI	A,0			;FLAG TO NOT RECOGNIZE
	HRROI	B,DIRBLK		;WHERE NAME STRING IS
	STDIR				;GET THE NAME
	BUG(<STDIR failure in CHKACC returned +1>)
	BUG(<STDIR failure in CHKACC returned +2>)
	HRRZM	A,DIRNMF		;STASH DIRECTORY NUMBER OF FILE
	MOVEI	A,(A)			;JUST NUMBER
	MOVEI	B,DIRBLK		;PLACE FOR GTDIR DATA
	MOVEI	C,0			;NO NEED FOR PASSWORD
	GTDIR				;FIND OUT ABOUT THAT DIR
	HRRZ	A,-1(P)			;THE JFN AGAIN
	MOVSI	B,25			;ARG TO GTFDB FOR ALL DATA
	MOVEI	C,FDBBLK		;PLACE TO STORE IT
	GTFDB				;READ SAME
	MOVEI	C,0			;ROTATE COUNTER
	HRLZ	D,FDBBLK+4		;FILE PROTECTION BITS
	MOVE	A,DIRBLK+6		;DIRECTORY NUMBER OF FILE
	CAMN	A,USRBLK+6		;DIRECTORY NUMBER OF USER
	JRST	CHK1			;SAME. DON'T ROTATE
	MOVE	A,USRBLK+13		;GROUPS USER HAS ACCESS TO
	TDNE	A,DIRBLK+14		;FILE IN ONE OF THOSE GROUPS?
	SUBI	C,6			;YES. WILL MOVE TO GROUP BITS
	ADDI	C,14			;FOR UNIVERS OR GROUP BITS
CHK1:	ROT	D,0(C)			;ROTATE THE FILE'S BITS
	MOVE	A,FDBBLK+1		;GET STATUS BITS FOR FILE
	TLNN	A,(1B4)			;THIS FILE EXIST?
	JRST	CHK2			;YES.
	MOVE	A,0(P)			;NO. NEW FILE. GET ACCESS REQUEST.
	TLNN	A,(ACCBWR!ACCBAP)	;WRITE OR APPEND?
	JRST	CHK2			;NO.
	HRLZ	A,DIRBLK+10		;YES. LEGAL TO CREATE NEW FILE?
	ROT	A,(C)			;CHECK DIRECTORY PROTECTION FIELD
	TLNN	A,(ACCBAP)		;APPEND TO DIRECTORY OK? (NEW FILES)
	JRST	CHK3			;NO. THIS REQUEST ILLEGAL.
CHK2:	TDNE	D,0(P)			;IS THE ACCESS ALLOWED?
	AOS	-2(P)			;YES. SKIP RETURN
CHK3:	POP	P,B			;RESTORE REGS
	POP	P,A
	POPJ	P,			;RETURN


;OPEN ERROR ON QUEUE, CHECK IT OUT
QOPENE:	HRRZ	A,QJFN			;BATCH QUEUE JFN
	CLOSF				;CLOSE IT
	BUG	(<STOP>)
	SETZM	QJFN			;CLEAR QUEUE JFN

	MOVEI	A,^D10000		;WAIT 10 SECONDS
	DISMS
	JRST	GETJOB			;AND TRY AGAIN


;
;	MARK ENTRY IN QUEUE TO BE DELETED BY QCOPY
;
MARK:	MOVE	A,QJFN
	RFPTR				;GET QUEUE FILE POSITION
	BUG	<(CANNOT GET QUEUE POSITION)>
	SUBI	B,QESIZE		;BACK UP FILE
	SFPTR
	BUG	(<QUEUE BACK UP FAILURE>)
	SETOM	QENT			;SET DESUBMIT VALUE IN QUEUE ENTRY

	MOVE	B,[POINT 36,QENT]
	MOVNI	C,QESIZE
	SOUT				;REWRITE UPDATED ENTRY
					;POSITIONING FILE AFTER ENTRY

	SETOM	RUNQCP			;SET FLAG TO RUN QCOPY TO DELETE ENTRY
	POPJ	P,0			;RETURN

;EVALUATE PRIORITY OF A JOB FOR EXECUTION
;EXPECTED TO USE REGS A,B,C,D,E (AND PERHAPS MORE)
;RETURNS +1 WITH THE PRIO IN A, IF .LT. 0 THEN
;THE JOB IS NOT TO BE RUN AT ALL AT THIS TIME.
;THE GREATER THE NUMBER IS, THE BETTER THE JOB IS TO RUN.

;COMPUTE HOW LONG (IN SECONDS) JOB HAS BEEN WAITING.
EVPRIO:	GTAD				;GET CURRENT TIME
	CAMN	A,[-1]			;WAS IT -1?
	JRST	NORUN			;REFUSE ALL JOBS IF TIME NOT SET
	CAMG	A,QENT+AFTER		;CHECK IF HE CAN BE RUN YET.
	JRST	NORUN			;HE WANTS TO WAIT SOME MORE.

	HLRZ	B,A			;GET CURRENT DAY
	HLRZ	C,QENT+ENTERD		;GET TIME ENTERED
	SKIPE	QENT+AFTER		;USE IF NO /AFTER: TIME
	HLRZ	C,QENT+AFTER			;USE /AFTER: IF GIVEN.
	SUB	B,C			;FIND #DAYS WAITED
	IMULI	B,^D24*^D3600		;TIMES SECONDS/DAY
	HRRZ	C,QENT+ENTERD		;GET TIME ENTERED
	SKIPE	QENT+AFTER		;USE IF NO /AFTER: TIME
	HRRZ	C,QENT+AFTER		;USE THIS INSTEAD IF GIVEN.
	HRRZ	A,A			;ISOLATE CURRENT TIME
	SUB	A,C			;GET SECONDS ELAPSED
	ADD	A,B			;ADD PART DUE TO DAYS
;A NOW HAS THE NUMBER OF SECONDS THE JOB HAS WAITED TO RUN.

	POPJ	P,			;RETURN PRIORITY IN A

NORUN:	SETO	A,			;-1 MEANS NO GO
	POPJ	P,			;RETURN
; Batcon restart code. Restarts from old or new image depending upon DBUGSW
;
; DBUGSW/	0 = Restart from the current image
;		1 = Start a new one from <SYSTEM>BATCON.SAV
;		2 = Start a new one from <BATCH>TBATCON.SAV
;

BATRST:	RESET				;SET THE WORLD RIGHT
	SKIPG	16,DBUGSW		;GET THE SWITCH, DO WE RELOAD?
	JRST [	MOVEI	16,1		;NO, BUT MAKE SURE WE DO NEXT TIME
		MOVEM	16,DBUGSW	;JUST IN CASE...
		JRST START0 ]
	MOVSI	1,1			;SHORT
	HRRO	2,SAVNAM-1(16)		;OF THIS FILE
	GTJFN				;GET IT
	HALTF				;SHIT, CAN'T FIND IT
	HRRM	1,BATJFN		;SAVE IT FOR LATER
	HRL	16,DUMPSW		;DON'T FORGET THE DUMPSW
	MOVEM	16,REGCDE		;PUT IT WHERE WE CAN MOVE IT
	MOVSI	17,REGCDE		;MOVE THE FOLLOWING CODE
	BLT	17,17			;TO THE REGISTERS
	JRST REGSRT-REGCDE		;AND DO IT

REGCDE:
	0				;0--DUMPSW,,DBUGSW 
BATJFN:	XWD 400000,0			;1--THIS FORK,,JFN OF SAVE
REGSRT:	GET				;2--BRING THE FILE IN
	HRRZM	0,DBUGSW		;3--SET UP THE SWITCHES
	HLRE	0,DUMPSW		;4--
	HLRZ	1,1			;5--JUST THE FORK HANDLE
	GEVEC				;6--GET THE VECTOR
	JUMPE	2,15			;7--JUMP IF NO VECTOR
	TLNE	2,777000		;10-DEC 10/50 STYLE?
	HRR 	2,120			;11-YES, GET ADDR FROM JOBSA
	HRR	17,2			;12-DEPOSIT IT FOR TRANSFER
	JFCL				;13-
	JFCL				;14-
	MOVEI	0,0			;15-CLEAR THE AC'S
	BLT	15,16			;16- 
	JRST START0			;17-AND START BATCON


SAVNAM:	[ASCIZ /<SYSTEM>BATCON.SAV/]	;REGULAR SYSTEM
	[ASCIZ /<BATCH>TBATCON.SAV/]	;TEST SYSTEM

;CONSTANT DATA AND STUFF
;BLANK LINE FOR OUTPUT TO LOG FILE
BLANKL:	EXP	5,2			;MAX LENGTH, ACTUAL LENGTH
	BYTE	(7)15,12		;CR,LF


;NAMES OF QUEUE FILE AND QUEUE WORK FILE
	IFE	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCH.QUEUE;P777740/
TMPNAM:	ASCIZ	/<BATCH>TEMP-TO-RENAM.TO-BE-QUEUE;P770000;1/
JBNAMS:	ASCIZ	/<BATCH>JOB.*;*/	;MASK TO LOOK FOR JOBS WITH
DJBNMS:	ASCIZ	/<BATCH>DJOB.*;*/	;MASK TO LOOK FOR DESUBMIT REQUESTS
CRASH:	ASCIZ	/<BATCH>CRASH.MSG/
	>
	IFN	DBGFIL,<
QNAME:	ASCIZ	/<BATCH>BATCHTEST.QUEUE;P777740/
TMPNAM: ASCIZ /<BATCH>TEST-TO-RENAM.TO-BE-TESTQUEUE;P770000;1/
JBNAMS:	ASCIZ /<BATCH>TESTJOB.*;*/
DJBNMS:	ASCIZ	/<BATCH>TESTDJOB.*;*/
CRASH:	ASCIZ	/<BATCH>TCRASH.MSG/
	>
BATDIR:	ASCIZ	/BATCH/			;DIRECTORY FOR BATCH STUFF

	LIT				;GET LITERAL POOL
;DATA AND STUFF


BESTPR:	BLOCK	1			;PRIORITY OF BEST JOB TO RUN
BESTPT:	BLOCK	1			;POINT TO Q ENTRY OF BEST TO RUN
NQENT:	BLOCK	1			;NUMBER OF QUEUE ENTRYS FOUND (COUNTED)
QPNTR:	BLOCK	1			;POINTER TO CURRENT Q ENTRY IN SCAN
EOJFK:	BLOCK	1			;NUMBER OF FORK TO SEARCH QUEUE FOR
STRTFK:	BLOCK	1			;BIT SET FOR EACH FORK BEING STARTED
					;BIT IS CLEARED AFTER FORK UNDERWAY
HLTDFK:	BLOCK	1			;BIT SET FOR EACH FORK HALTED
ACTFRK:	BLOCK	1			;NUMBER OF ACTIVE INFERIOR FORKS
BATSTT:	BLOCK	1			;BATCH PROCESSOR START TIME
RUNQCP:	BLOCK	1			;RUN QCOPY FLAG TO DELETE DESUBMITTED
					;ENTRIES FROM QUEUE
;	LPT: LOG FILE JFN BLOCK
LOGBLK:	600000,,0		;SET UP A LONG GTJFN
	377777,,377777		;INJFN,,OUTJFN
	0			;NO DEFAULT DEVICE
	POINT 7,[ASCIZ /PRINTER/] ;DIRECTORY
	POINT 7,[ASCIZ /LPT/]	;FILENAME
	POINT 7,FDBBLK		;EXTENSION IS HIS NAME
	EXP 0,0,0		;PROTECTION,ACCOUNT,JFN




;STORAGE BLOCKS FOR FDBS, DIRECTORY INFO, ETC.
;PRIMARALY STUFF RELATED WITH CHKACC
DIRNMF:	BLOCK	1			;DIR NUMBER FILE WE CHECK IS IN
FDBBLK:	BLOCK	25			;STORAGE FOR FDB OF FILE WE CHECK
USRBLK:	BLOCK	20			;SPACE TO GTDIR INTO FOR USER WE
					;ARE RUNNING-WE READ HIS ACCESS FROM
					;HERE
DIRBLK:	BLOCK	20			;WE GTDIR THE DIRECTORY INFO OF
					;THE DIRECTORY THE FILE IS IN INTO
					;HERE TO CHECK ACCESS (GROUP, ETC.)

ACS:	BLOCK	20		;INFERIOR AC'S AREA
;GENERATED VARIABLES
	VAR				;GET THIS BEFORE PDL

PDL:	BLOCK	PDLL+1			;PUSH DOWN LIST
	SUBTTL	SHARED CODE BETWEEN SUPERIOR AND INFERIORS
	LOC	11000
SHARE:
;BUG ROUTINES FOR BATCH
;BUGMSG - WRITE A BUG MESSAGE, CALLED VIA TWO PUSHJS
;USING THE BUG MACRO

BUGMSG: MOVEM	P,CSHACS+P		;SAVE ALL AC'S
	MOVEI	P,CSHACS
	BLT	P,CSHACS+16
	MOVE	P,CSHACS+P		;AND RESTORE STACK POINTER
	MOVE	A,CRSHJF		;SEND TO TTY OR CRASH FILE IF DETACHED
	POP	P,B			;GET THE STRING
	HRLI	B,440700		;MAKE A POINTER
	SETZ	C,
	SOUT				;SHOW IT
	HRROI	B,[ASCIZ /
In main batcon--BATCON Restarted at /]
	SKIPN	MYNAME			;KEEP IF IN TOP FORK
	HRROI	B,[ASCIZ /
In inferior fork--halted, BATCON continuing at /]  ;ELSE WE ARE THE INFERIOR
	SETZ	C,			;NULL BYTE
	SOUT				;PUT IT OUT
	SETO	B,			;CURRENT TIME, SHORT FORM
	ODTIM				;GIVE THEM A TIME STAMP
	HRROI	B,[ASCIZ $
Pc/ $]					;MESSAGE
	SETZ	C,			;NULL TERMINATES
	SOUT				;SHOW IT
	POP	P,B			;GET ADDR LEFT BY PUSHJ
	MOVEI	B,-1(B)			;BACK IT UP BY 1, KEEP ADDR ONLY
	MOVEI	C,10			;OCTAL
	NOUT				;SHOW THE NUMBER
	JFCL				;WE DON'T EXPECT, BUT TOO LATE
					;TO DO ANYTHING ABOUT IT
	HRROI	B,[ASCIZ $
F/ $]					;NOW START DUMPING THE REGISTERS
	SOUT				;PUT IT OUT
	MOVE	B,CSHACS+F
	MOVE	C,[XWD 400000,10]	;PRINT MAGNITUDE, OCTAL
	NOUT
	JFCL
	SETZ	C,
	HRROI	B,[ASCIZ $
A/ $]
	SOUT				;PUT IT OUT
	MOVE	B,CSHACS+A		;THAT'S WHERE WE PARKED A
	MOVE	C,[XWD 400000,10]	;PRINT MAGNITUDE, OCTAL
	NOUT
	JFCL
	SETZ	C,
	HRROI	B,[ASCIZ $
B/ $]
	SOUT				;PUT IT OUT
	MOVE	B,CSHACS+B		;REMEMBER WE EXCH'ED IT A WHILE BACK?
	MOVE	C,[XWD 400000,10]	;PRINT MAGNITUDE, OCTAL
	NOUT
	JFCL
	SETZ	C,
	HRROI	B,[ASCIZ $
C/ $]
	SOUT				;PUT IT OUT
	MOVE	B,CSHACS+C
	MOVE	C,[XWD 400000,10]	;PRINT MAGNITUDE, OCTAL
	NOUT
	JFCL
	SETZ	C,
	HRROI	B,[ASCIZ $
D/ $]
	SOUT				;PUT IT OUT
	MOVE	B,CSHACS+D
	MOVE	C,[XWD 400000,10]	;PRINT MAGNITUDE, OCTAL
	NOUT
	JFCL
	SETZ	C,
	HRROI	B,[ASCIZ $
E/ $]
	SOUT				;PUT IT OUT
	MOVE	B,CSHACS+E
	MOVE	C,[XWD 400000,10]	;PRINT MAGNITUDE, OCTAL
	NOUT
	JFCL
	SETZ	C,
	HRROI	B,[ASCIZ $
P/ $]					;NOW THE STACK POINTER REGISTER
	SOUT				;PUT IT OUT
	HLRE	B,P
	MOVEI	C,10			;PRINT THE LEFT HALF WITH SIGN
	NOUT
	JFCL
	HRROI	B,[ASCIZ /,,/]		;A LITTLE PUNCTUATION
	SETZ	C,			;NULL BYTE TERMINATES
	SOUT
	MOVEI	B,0(P)			;NOW THE RIGHT HALF
	MOVE	C,[XWD 400000,10]	;PRINT MAGNITUDE, OCTAL
	NOUT
	JFCL

;TENXER - WRITE THE TENEX ERROR STRING FOR LAST ERROR THIS FORK
;CALLED VIA DIRECT JRST OR FALLEN INTO FROM BUGSTP
TENXER:	MOVE	A,CRSHJF		;CRASH OUTPUT FILE
	HRROI	B,[ASCIZ /
Tenex error: /]
	SETZ	C,
	SOUT
	HRLOI	B,400000		;LAST ERROR, THIS FORK
	ERSTR				;WRITE ERROR MESSAGE
	JFCL				;IGNORE THESE
	JFCL				;TOO LATE TO WORRY ABOUT THEM.

; Check and see if we are to dump the image first
; Then add a note about it to the file
; DUMPSW/	0 = Don't dump the image
;		1 = Dump image to file and note in message
;  *note: Dump is of fork that crashed, not all forks. Symbols in a separate
;	  file
	SKIPN	16,SYMPTR		;GET THE SYMBOL POINTER
	JRST .+7			;GO AROUND SINCE THERE IS NO TABLE
	HLRE	15,16			;THE LENGTH
	MOVM	15,15			;POSITIVE LENGTH
	ADD	15,16			;LAST ADDR
	MOVES	0(16)			;TOUCH THE PAGE TO MAKE IT OURS
	ADDI	16,1000			;NEXT PAGE
	CAMG	16,15			;THE END?
	JRST .-3			;LOOP TILL WE ARE
	SKIPE	DUMPSW
	JRST [	MOVSI	A,400001	;DUMP THE IMAGE ON A FILE AND REPORT
		MOVE	B,CSHBAT	;USE BATCH NAME
		SKIPN	MYNAME		;UNLESS INFERIOR
		HRROI	B,CSHINF	;THEN USE INFERIOR NAME
		GTJFN
		JRST [	MOVE A,CRSHJF
			HRROI B,[ASCIZ /
GTJFN failed on dump file

******
/]
			JRST TNXER1]	;SAY WE COULDN'T GET FILE
		EXCH	A,CRSHJF	;SAVE IT AND GET CRASH FILE
		HRROI	B,[ASCIZ /
Image dumped on file: /]
		SETZ	C,		;NULL BYTE
		SOUT			;HEADER TO CRASH FILE
		HRRZ	B,CRSHJF	;JFN OF DUMP FILE
		JFNS			;PUT IT'S NAME OUT SO WE CAN FIND IT
		EXCH	A,CRSHJF	;RESTORE EVERYBODY
		MOVE	B,[XWD 777760,20] ;ALL OF CORE
		SAVE			;TO GET ALL THE GORRY DETAILS
		HRROI	B,[ASCIZ /

******
/]
		MOVE	A,CRSHJF	;CRASH FILE JFN FOR SOUT
		JRST TNXER1]
	HRROI	B,[ASCIZ /
Image was not dumped

******
/]
TNXER1:	SETZ	C,
	SOUT				;PUT IT OUT

	MOVE	A,CRSHJF		;CRASH FILE JFN
	CLOSF				;CLOSE AND RELEASE JFN

;SEND MESSAGE TO INTERESTED PEOPLE THAT BATCH PROCESSOR CRASHED
	MOVSI	D,-NNOT			;NUMBER OF PEOPLE TO NOTIFY
CRSNOT:	MOVE	B,CRSHLS(D)		;DIR NAME POINTER FOR SEND
	MOVEI	A,1			;POSITIVE FOR NO COMPETION
	STDIR				;GET HIS NUMBER
	JFCL				;WRONG SYSTEM OR SOMETHING?
	MOVE	A,BATDN			;SEND TO SELF THEN
	HRRZM	A,QENT+USRDIR
	SETZM	CTLJFN			;ZERO CTLJFN FOR SEND FLAG
	HRROI	B,[ASCIZ /BATCH PROCESSOR CRASHED /]  ;MESSAGE
	SKIPN	MYNAME			;WHO AM I?
	HRROI	B,[ASCIZ /BATCH SUBFORK CRASHED /]  ;MILD MSG FOR INFERIOR
	HRROI	C,[ASCIZ / /]		;NULL MESSAGE

	PUSH	P,D
	PUSHJ	P,SEND			;SEND MESSAGE
	POP	P,D
WTMSG:	MOVEI	A,^D5000		;5 SECOND DELAY
	DISMS
	SKIPE	FORK			;MESSAGE SENT ?
	JRST	WTMSG			;NOT YET
	AOBJN	D,CRSNOT
	SKIPE	MYNAME
	JRST BATRST			;RESTART BATCON FOR TOP GUY, ELSE
	HRRZ	A,CTLJFN		;CLOSE USERS FILES TO KEEP HIM FROM
	CLOSF				;HANGING TOO
	JFCL				;SOME DAYS NOTHING WORKS RIGHT
	HRRZ	A,LOGJFN		;DO IT TO THE LOG TOO
	CLOSF
	JFCL
	HALTF				;STOP
	JRST	.-1			;DON'T CONTINUE

;	HANDLE UNEXPECTED INTERRUPTS

UNEX:	DEBRK


;THIS ROUTINE TRYS TO OPEN A FILE AND RETURNS +1 ON ANY FAILURE BUT BUSY.
;IF FILE IS BUSY, IT TRYS AGAIN IN 1/2 MINUTE, GIVES UP AFTER 20 TRIES.
;EVOKED BY THE 'QOPENF'MACRO (OPDEF).

.OPENF:	OPENM


DBUGSW:	DBUGFG				;see BATRST for definitions of
DUMPSW:	DUMPFG				;DBUGSW and DUMPSW

TTYJOB:	BLOCK	1			;TABLE NUMBERS FOR NAMED TABLES
JOBTTY:	BLOCK	1			;TABLE NUMBER
JOBRT:	BLOCK	1			;TABLE NUMBER
JOBNAM:	BLOCK	1			;TABLE NUMBER
SNAMES:	BLOCK	1			;TABLE NUMBER
JOBDIR:	BLOCK	1			;TABLE NUMBER

WHEEL:	BLOCK	1			;NON-ZERO IF WE ARE A WHEEL
DETSW:	BLOCK	1			;NEGATIVE IF DETACHED
BATDN:	BLOCK	1			;DIRECTORY NUMBER FOR <BATCH>
JOBNO:	BLOCK	1			;JOB NUMBER OF THIS BATCON
					;SHOULD IDENTIFY WHICH BATCON
					;STARTED JOB, SO IF MULTIPLE IN
					;ONE JOB-WE MUST USE SOMETHING
					;HERE. IT IS NOT IMPORTANT THAT
					;IT BE THE JOB NUMBER

QJFN:	BLOCK	1			;JFN OF THE BATCH QUEUE
CRSHJF:	BLOCK	1	       		;JFN FOR CRASH MESSAGE FILE
SNDLCK:	-1				;SEND MESSAGE LOCK(ONE COPY 
;DIRECTORY NUMBERS OF PEOPLE TO NOTIFY IF BATCH PROCESSOR CRASHES
CRSHLS:	
	CRSHUS
NNOT==.-CRSHLS				;NUMBER TO NOTIFY
NSHAR==<<<.-SHARE>+1000>/1000>	;NUMBER OF INFERIOR FORK SHARED PAGES
					;AT A TIME)
;IMAGE DUMP FILE NAMES

CSHBAT:
IFE DBGFIL,<
	POINT 7,[ASCIZ /<BATCH>CRASH.BATCON/] 
>
IFN DBGFIL,<
	POINT 7,[ASCIZ /<BATCH>TCRASH.BATCON/] 
>

CSHINF:
IFE DBGFIL,<
	POINT 7,[ASCIZ /<BATCH>CRASH.INFERIOR/] 
>
IFN DBGFIL,<
	POINT 7,[ASCIZ /<BATCH>TCRASH.INFERIOR/] 
>
	LIT
	SUBTTL	INFERIOR FORK CODE
	LOC	12000
;OPEN CTL FILE NOW

	IFE	FSUSER,<
INFFK:	SETZM	PTY			;TOUCH PAGE TO GET COPY
	SETZM	MYNAME			;AND SAY I'M A LITTLE GUY
	MOVE	A,SYMPTR		;GET THE SYMBOL TABLE POINTER
	MOVEM	A,116			;AND SET IT UP FOR DDT ON A CRASH
	MOVE	P,[IOWD PDLL,IPDL]  ;SET UP STACK

	MOVE	A,[PUSHJ P,LUUOI]	;TRAP INSTRUCTION
	MOVEM	A,41			;SAVE IT

;SET UP INTERRUPT SYSTEM
	MOVEI	A,400000
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	HRLI	B,200300	;ACTIVATE CHANNELS 1,10,11 FOR FORK TERMINATION
				;EOF INTERRUPT AND DATA ERROR INTERRUPT
	AIC
	EIR			;ENABLE INTERRUPT SYSTEM FOR THIS FORK

	MOVE	A,CTLJFN		;JFN OF CONTROL FILE
	MOVE	B,[7B5!1B19!1B26]	;7 BIT, READ ,WAIT IF BUSY
	QOPENF
	ERROR	<CTL FILE OPENF FAILED>,ABEND

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Tenex Batch System.  Version /]
	SETZ	C,
	SOUT

	MOVEI	B,MAJORV
	MOVE	C,[1B2+2B17+^D10]	;LEADING FILLER, 2 COL, DECIMAL
	NOUT
	JFCL
	MOVEI	B,"."
	BOUT
	MOVEI	B,MINORV
	MOVE	C,[1B3+2B17+^D10]	;LEADING ZEROS, 2 COL, DECIMAL
	NOUT
	JFCL
	MOVEI	B,0			;STRING TERMINATOR
	BOUT
	PUSHJ	P,INTMSG		;OUTPUT - BATCH SYSTEM VERSION

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Batch job number /]
	SETZ	C,
	SOUT

	MOVE	B,QENT+BJOBNO		;JOB NUMBER
	MOVEI	C,^D10			;DECIMAL
	NOUT
	JFCL
	HRROI	B,[ASCIZ/ Started /]
	SETZ	C,
	SOUT
	SETOB	B,C			;CURRENT DATE AND TIME, THE WORKS
	ODTIM
	MOVEI	B,0			;STRING TERMINATOR
	BOUT

	PUSHJ	P,INTMSG		;OUTPUT - JOB NUMBER AND TIME MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum log length (lines):  /]
	SETZ	C,
	SOUT
	MOVE	B,MAXLOG
	MOVEI	C,^D10
	NOUT
	JFCL
	MOVEI	B,0			;STRING TERMINATOR
	BOUT
	PUSHJ	P,INTMSG		;OUTPUT - LOG LENGTH MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum elapsed time (minutes): /]
	SETZ	C,
	SOUT
	MOVE	B,MAXETM
	IDIVI	B,^D60000		;CONVERT MILLISECONDS TO MINUTES
	MOVEI	C,^D10
	NOUT
	JFCL
	MOVEI	B,0			;STRING TERMINATOR
	BOUT
	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Maximum CPU time (seconds): /]
	SETZ	C,
	SOUT
	MOVE	B,MAXCPU
	IDIVI	B,^D1000		;CONVERT MILLISECONDS TO SECONDS
	MOVEI	C,^D10
	NOUT
	JFCL
	MOVEI	B,0			;STRING TERMINATOR
	BOUT
	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Input file : /]
	SETZ	C,
	SOUT

	HRRZ	B,CTLJFN		;LOG FILE JFN
	MOVE	C,[XWD 011110,110011]
	JFNS

	MOVEI	B,0			;STRING TERMINATOR
	BOUT

	PUSHJ	P,INTMSG		;OUTPUT - INPUT FILE MESSAGE

	HRROI	A,MSGLIN+2		;BUILD MESSAGE IN MSGLIN BUFFER
	HRROI	B,[ASCIZ / Output file : /]
	SETZ	C,
	SOUT

	HRRZ	B,LOGJFN		;LOG FILE JFN
	MOVE	C,[XWD 011110,110011]
	JFNS

	MOVEI	B,0			;STRING TERMINATOR
	BOUT

	PUSHJ	P,INTMSG		;OUTPUT - OUTPUT FILE MESSAGE

	MOVE	B,QENT+USRDIR		;GET DIR TO LOGIN WITH
	>				;END NORMAL JOB STARTUP
;GET A LOGIN LINE IN CTLLIN.
DOLOGI:	MOVE	C,[ASCII /LOG /]	;COMMAND
	MOVEM	C,CTLLIN+2		;SAVE IT
;	USE CONNECTED DIR FROM B
	HRROI	A,CTLLIN+3		;POINT TO DEST
	DIRST				;GET DESTINATIN
	BUG(<DOLOGI: Dirst failed for login line>)
	MOVEI	C," "			;BLANK FOR AFTER NAME
	IDPB	C,A			;STORE IT
	MOVE	C,A			;WHERE TO PUT PW
	MOVE	A,B			;DIR#
	MOVEI	B,1(P)			;THROW THIS OUT ABOVE STACK
	GTDIR				;HOPE IT WORKS, OR WE DIE
	MOVE	A,C			;GET BYTE POINTER
	MOVEI	B," "			;SPACE BEFORE ACCT#
	IDPB	B,A			;STORE IT

IFE	FSUSER,<			;IN SYSTEM BATCH WE WANT THIS
	MOVE	B,QENT+USRACT		;GET ACCOUNT REQUESTED
	JUMPN	B,DOLOG2		;HE KNOWS HIS ACCOUNT STRING ***SRI-IC***
	>				;END IFN FSUSER

	IFE	STRACT,<
;THE FOLLOWING IS BECAUSE WE HAVE A DUMB ACCOUNTING
;SYSTEM THAT REQUIRES THAT A VALID ACCOUNT NUMBER BE
;GIVEN--AND REFUSES TO ACCEPT ACCOUNT NUMBER 1
	MOVEI	B,33			;ESCAPE
	IDPB	B,A			;STORE IT IN ACCOUNT FIELD
	JRST	DOLOG3			;SKIP OVER THE NOUT

	MOVEI	B,^D1			;USE THIS GOOD ACCT #
DOLOG2:	MOVEI	C,^D10			;DECIMAL
	NOUT
	BUG(<DOLOG2: Nout failed>)
	>
	IFN	STRACT,<
	ERROR	<NO ACCOUNT STRING>,ABEND
DOLOG2:
	HRROI	B,QENT+USRACT	;USER ACCOUNT STRING POINTER
	SETZ	C,		;ZERO BYTE TERMINATION
	SOUT			;OUTPUT ACCOUNT STRING
	>

DOLOG3:	MOVEI	B,15			;CR
	IDPB	B,A			;SAVE IT IN LINE

;KLUDGE THE LENGTH OF STRING COMPUTATION.
	MOVE	B,[POINT 7,CTLLIN+2]	;POINT TO FIRST BYTE OF STRING
	MOVEM	B,CTLLIN-1		;STORE LOC OF LINE
	SETZ	C,			;INIT VALUE
	CAMN	B,A			;THERE YET?
	JRST	.+3			;YES
	IBP	B			;NO--GET NEXT
	AOJA	C,.-3			;COUNT AND LOOP
	MOVEM	C,CTLLIN+1		;SAVE LENGTH
;START THE JOB
RUNJOB:	PUSHJ	P,.ASPTY		;FIRST WE GET A PTY
	JRST	[MOVEI A,^D60000	;NO PTY'S OR NO LOGINS
		 DISMS			;WAIT ONE MINUTE
		 JRST RUNJOB]		;RETRY ASPTY
	MOVEM	A,PTY

	HRROI	B,JOBMSG		;START MESSAGE
	HRROI   C,STRMSG		;END OF MESSAGE
	SKIPGE	QENT+MESAG		;MESSAGE WANTED?
	PUSHJ	P,SEND			;YES
	HRROI	B,JOBNOT
	HRROI	C,STRNOT		;NOTIFY STRINGS
	SKIPGE	QENT+NOTFY
	PUSHJ	P,NOTIFY
	PUSHJ	P,DAY			;ADD NOTICE TO DAYFILE

WAITJ:	TIME				;GET TODCLK
	MOVE	C,A			;SAVE IT
	ADDI	C,^D120000		;THIS IS WHEN WE WANT TO RETRY
	MOVE	A,PTY			;GET PTY NUMBER
	TRO	A,400000		;BE SURE TTY DESIGNATOR
	CFIBF				;CLEAR HIS INPUT
	CFOBF				;AND OUTPUT BUFFERS

;SEND A CONTROL C TO WAKE UP JOB.
	MOVE	A,PTY			;GET PTY NUMBER
	MOVEI	B,3			;GET A ^C
	PSTI
	ERROR	<CAN'T SEND ^C TO START SUBJOB>,ABEND	;OOPS-DIE
;WAIT FOR JOB TO START
WAITJ1:	MOVEI	A,^D1000		;WAIT 1 SECOND BEFORE CHECKING
	DISMS
	PUSHJ	P,TTYJ			;FIND LINE STATUS
	TLNN	A,300000		;IS TTY ASSIGNED?
	JRST WAITL			;YES, GO ON
	TIME				;GET TODCLK NOW
	CAMGE	A,C			;HAS TIME EXPIRED?
	JRST WAITJ1			;NO,GO BACK AND WAIT,TTY NOT ASSIGNED
	JRST WAITJ			;AUTOLOGOUT TIME EXPIRED, TRY AGAIN

;WAIT FOR THE @ FROM EXEC BEFORE LOGIN.
WAITL:	MOVE	A,PTY			;GET A CHAR
	SETO	B,			;BLOCK FOR CHAR
	PSTO				;GET IT
	JRST	WAITL2			;DIDN'T GET ONE
	PUSH	P,B			;SAVE B
	PUSHJ	P,ADDLOG		;PUT ON LOG FILE
	POP	P,B			;RESTORE B
	CAIE	B,"@"			;WAS IT AN @?
	JRST	WAITL			;NO-CONTINUE WAIT
	JRST	RUN			;YES-GO START RUNNING

WAITL2:	MOVEI	A,^D1000		;WAIT ONE SECOND
	DISMS
	JRST	WAITL			;AND TRY AGAIN
;RUN THE JOB

RUN:	TIME
	ADD	A,MAXETM		;THIS IS THE TIME TO PULL THE CHAIN
	MOVEM	A,RUNTIM		;SAVE IT FOR DURING THE RUN
	SETZB	D,JOBN			;ZERO JOB NUMBER AND CTL SAVED CHAR
RUN0:	PUSHJ	P,CHKOUT		;GO CHECK FOR PTY OUTPUT
	JFCL				;NO OUTPUT, KEEP GOING
	CAIN	D,15			;IS INPUT CHAR A (CR)-SKIPS FIRST TIME
	JRST RUN02			;YES,END OF LOGIN, NO MORE FOR NOW
	PUSHJ	P,RCCTL			;GET CHAR OF LOGIN SEQUENCE
	BUG(<RUN0: Non skip return from RCCTL>) ;NO,JOB CHECK WITH LOG LINE!?
	MOVE	D,B			;SAVE IT TO KNOW WHEN TO QUIT
RUN01:	MOVE	A,PTY			;GET OUR PTY
	PSTI				;STUFF IT
	JRST [	MOVEI	A,^D100		;BUFFER FULL
		DISMS			;COME BACK IN 100MS
		JRST RUN01]		;AND TRY AGAIN
RUN02:	PUSHJ	P,TTYJ			;GET JOB NUMBER
	TLNE	A,400000		;BE SURE REAL JOB NUMBER
	JRST	RUN0			;NOT YET
	HLRZM	A,JOBN			;ISOLATE JOB NUMBER AND PARK IT
	HRR	A,JOBDIR		;SEE IF LOGGED IN YET
	GETAB
	BUG(<RUN02: Getab on JOBDIR failed>)
	TRNN	A,-1			;LOGGED IN?
	JRST 	RUN0			;NO, go back till we are
IFN	SKUSER,<
	MOVEI	A,^D2000
	DISMS				;WAIT TILL THE EXEC SETTLES DOWN
	MOVE	A,JOBN			;GET BACK JOB NUMBER
	SKIPGE	B,QENT+PRIOR		;GET PRIORITY ,DON'T BOTHER IF NORMAL
IFE TNX131, <
	SKUSR				;SET IF BATCH PRIOR
>
IFN TNX131, <
	JRST [	MOVE	B,[XWD 1,1]	; SET MAX AND WORKING TO 1%
		SJPCT
		BUG(<RUN02: Can't set job percentage for subjob>)
		JRST .+1]
>
	>		;END OF IFN SKUSER
; Main run loop for feeding job
; Some terminating conditions jump in here because
; They have no place else to go !?

RUN1:	MOVE	A,JOBTTY
	HRL	A,JOBN
	GETAB
	BUG(<RUN1: Getab on JOBTTY failed>)
	CAIG	A,0
	ERROR <Batch job has detached itself>,ABEND
	PUSHJ	P,CHKOUT		;GET OUTPUT CHAR IF ONE EXISTS
	JRST RUN2			;NONE EXISTED
	SETZM	NAPTIM			;CLEAR WAIT TIME CAUSE WE GOT CHAR
RUN2:	SKIPL	FRCTRM			;FORCED TERMINATION IN EFFECT?
	JRST RUN4			;YES, FORGET CHECKS OR INPUT CHARS
	MOVE	A,JOBRT
	HRL	A,JOBN
	GETAB
	BUG(<RUN2: Getab on JOBRT failed>)
	CAMLE	A,MAXCPU
	ERROR <Job exceeded max CPU time>,KILLIT ;YES, KILL HIS ASS
	TIME				;GET TODCLK
	CAMLE	A,RUNTIM		;IS HE RUNNING BEYOND HIS LIMIT
	ERROR <Job exceeded max elapsed time>,KILLIT ;YES, KILL HIS ASS
	SKIPGE	INFDSB			;THIS JOB DESUBMITTED
	ERROR <Job Desubmitted>,KILLIT	;YES
	SKIPGE	MAXLOG			;HAS LOG GONE OVER THE LIMIT?
	ERROR <Log file size exceeded limit>,KILLIT ;YES
	PUSHJ	P,TTYJ			;GET TTY INFO
	TLNE	A,300000		;IS IT < 0 ? (BUT NOT 400000+N)
	JRST RUNNOJ			;IF SO, THERE IS NO JOB THERE.
	TRC	A,-1			;TURN RH -1 TO RH 0
	TRNN	A,-1			;DID WE GET 0?
	JRST RUN3			;YES--SO NOT IN TI STATE
	PUSHJ	P,RCCTL			;GET A CHAR FROM CONTROL FILE
	JRST RUNNOJ			;NO JOB, CLEAN UP
RUN21:	MOVE	A,PTY			;GET PTY#
	PSTI				;GIVE JOB THE CHAR
	JRST [	MOVEI	A,^D100		;GO AWAY FOR A WHILE
		DISMS			;BUT COME BACK HERE
		JRST RUN21]		;SO WE DON'T LOSE THE CHAR 
	SETZM	NAPTIM			;CLEAR WAIT CAUSE HE TOOK CHAR.
	JRST RUN1			;GO BACK FOR OUTPUT (PROBABLY ECHO)

RUN3:	MOVE	A,NAPTIM		;GET WAIT TIME
	CAILE	A,NAPMAX		;TOO LONG
	MOVEI	A,NAPMAX		;SET TO MAX
	MOVEM	A,NAPTIM		;RESET TIME (IF CHANGED)
	CAIGE	A,NAPMIN		;TOO SHORT?
	MOVEI	A,NAPMIN		;IF SO, RESET TO MIN
	DISMS				;TAKE NAP, ZZZZZZ...

;INCREASE WAIT TIME SO THAT WE WILL LOOK LESS FREQUENTLY
;AT A JOB THAT IS NOT DOING TERMINAL IO.
;THIS ROUTINE IS A SOMEWHAT ARBITRARY HEURISTIC.
;IT SHOULD ALSO BE NOTED THAT THE LOWERING OF THE WAIT TIME
;BY THE SETZM IN RUN1 AND RUN2 ARE A PART OF THIS WAIT TIME
;CALCULATION.  IT MAY NOT ALWAYS BE DESIRED TO RESET TO 0
;THE WAIT TIME ON ACTIVITY, BUT IT SEEMS VERY LIKELY, SINCE
;IF A JOB TYPES A CHAR OR READS ONE, HE IS LIKELY TO DO
;ONE OF THOSE OPERATIONS AGAIN IN A VERY SHORT TIME (EACH
;GROUP OF CHARS IN AN IO STREAM HAS ONLY ONE LAST CHAR.)
;THUS IF GROUPS ARE N CHARS IN LENGTH, THERE IS
;A PROBABILITY OF (N-1)/N THAT ANOTHER FOLLOWS.
	MOVEI	A,^D1000		;ADD ONE SECOND
	ADDM	A,NAPTIM		;TO WAIT TIME
	JRST	RUN1			;AND CHECK FOR OUTPUT

;IF A CTL FILE IS NOT TERMINATED BY A .LOGO OR .K STATEMENT,
;THEN FORCE FEED THE JOB A LOGO TO LOG IT OUT
RUN4:	SKIPE	FRCTRM			;IN LOGOUT PROCESS
	JRST	RUN5			;NO, GO WAIT FOR JOB TO TERMINATE
	ILDB	B,LOGSTR		;GET NEXT CHARACTER OF LOGO
	SKIPE	B			;END OF LOGO REACHED ?
	JRST	RUN21			;NO, FEED CHARCTER TO JOB
	AOS	FRCTRM			;YES, NOW WAIT FOR TERMINATION
	MOVEI	1,NAPMAX		;TAKE A NAP BEFORE CHECKING FOR
	MOVEM	1,NAPTIM		;SUCCESSFUL LOGOUT
	JRST	RUN3

;	WAIT UNTIL OUTPUT BUFFER EMPTY AND THEN WAIT FOR JOB TO
;	GO AWAY. INSURES ALL OUTPUT IS MOVED TO LOG FILE.
RUN5:	MOVE	A,PTY			;PSEUDO-TTY NUMBER
	SOBE				;SKIP IF OUTPUT BUFFER EMPTY
	JRST RUN3			;DATA IN BUFFER, TRY LATER
	PUSHJ	P,JBST			;CHECK JOB STATUS
	JRST RUNNOJ			;JOB IS LOGGED OUT
	JFCL				;DON'T CARE IF IN EXEC
	JRST RUN3			;JOB STILL RUNNING, TRY LATER


; KILLIT routine
; Forces a ^C down the job's throat to get the attention of the EXEC
; And then sets the FRCTRM flag so we can put a LOGOUT on it

KILLIT:	SETZM	FRCTRM			;SAY WE WANT A LOGOUT ON HIM
	MOVE	A,PTY
	MOVEI	B,3			;LETS HAVE A ^C
	PSTI				;AND STICK IT TO HIM
	JRST [	MOVEI	A,^D100		;BUFFER FULL
		DISMS			;TRY AGAIN LATER
		JRST KILLIT]
	MOVEI	A,^D2000		;WAIT TILL HE IS IN EXEC
	DISMS				;SINCE HE CLEARS HIS BUFFERS
	PUSHJ	P,JBST			;FIND OUT IF HE IS IN EXEC YET
	JRST RUNNOJ			;HE ISN'T THERE, END OF JOB
	JRST KILLIT			;NOT THERE YET POKE HIM AGAIN
	JRST RUN1			;IN THE EXEC, GIVE HIM THE LOGOUT

;	PSEUDO INTERRUPT CODE TO SET FORK DESUBMISSION FLAG
DESUBF:	SETOM	INFDSB			;SET DESUBMIT FLAG
	DEBRK

;NO JOB FOUND THERE, CHECK WHAT HAPPENED
RUNNOJ:	PUSHJ	P,TTYJ			;GET TTY INFORMATION AGAIN
	HLRZ	A,A			;GET INFO IN RH
	CAIN	A,-2			;IS IT BEING ASSIGNED?
	ERROR	<SUBJOB TTY WENT TO STATE -2>,ABEND
	CAIN	A,-1			;IS IT UNASSIGNED?
	JRST	EOJ			;YES, END RUN
	ERROR	<SUBJOB TTY WENT TO UNKNOWN STATE>,ABEND

;ABEND ROUTINE--KILL WITH MESSAGE
ABEND:	ERROR	<ABORTING JOB>,EOJ


;END OF JOB REACHED.  CLEAN UP NOW.

EOJ:	PUSHJ	P,CHKOUT		;GET THE LAST OF THE OUTPUT(IF ANY)
	JFCL				;NONE, FINE
	HRROI	B,JOBMSG		;JOB FINISHED MESSAGE
	HRROI	C,FINMSG
	SKIPGE	QENT+MESAG		;MESSAGE WANTED ?
	PUSHJ	P,SEND			;YES

	HRROI	B,JOBNOT
	HRROI	C,FINNOT
	SKIPGE	QENT+NOTFY
	PUSHJ	P,NOTIFY
	PUSHJ	P,DAY			;ADD NOTICE TO DAYFILE
	MOVE	A,PTY			;RELEASE PTY
	JUMPLE	A,EOJ2			;JUMP IF NULL PTY NUMBER
	REPTY				;GIVE IT UP
	ERROR	<REPTY FAILED--BAD NEWS>,EOJ2
EOJ2:	HRRZ	A,CTLJFN		;CLOSE INPUT FILE
	CLOSF
	ERROR	<ERROR CLOSING INPUT FILE>
	SETZM	CTLJFN			;SAY NONE AROUND
	HRRZ	A,LOGJFN		;CLOSE LOG FILE
	CLOSF
	JFCL				;WHO COULD WE TELL ABOUT IT?
	SETZM	LOGJFN			;NO MORE LOG FILE
EOJ4:	SKIPN	FORK			;IS SNDMSG FORK STILL ACTIVE
	HALTF				;NO, EXIT
	MOVE	A,^D10000		;YES, TRY AGAIN LATER
	DISMS
	JRST	EOJ4			;GO CHECK AGAIN

;PUTS IT IN LOGLIN IF THERE IS ANY
;SKIPS IN RETURN IF THERE WAS OUTPUT.
CHKOUT:	MOVE	A,PTY			;GET PTY ID
	SETZ	B,			;DON'T WAIT IF NONE READY
	PSTO				;TRY FOR OUTPUT
	POPJ	P,			;NO OUTPUT
	AOS	(P)			;OUTPUT, SO SKIP
CHKOU2:	ANDI	B,177			;ONLY 7 BITS
	PUSHJ	P,ADDLOG		;ADD THE CHAR TO THE LOG
	MOVE	A,PTY			;GET PTY ID AGAIN
	SETZ	B,			;DON'T BLOCK FOR OUTPUT
	PSTO				;TRY FOR ANOTHER CHAR
	POPJ	P,			;RETURN
	JRST	CHKOU2			;WE GOT IT, SO TAKE CARE OF IT.

;APPEND A CHAR TO LOGLIN, OUTPUT BUFFER IF NEEDED.

ADDLOG:	MOVE	A,LOGLIN+1		;GET COUNTER
	CAML	A,LOGLIN		;IS IT IN RANGE?
	PUSHJ	P,ADLOG2		;NO-WRITE FULL BUFFER
	IDPB	B,LOGLIN-1		;SAVE CHARACTER

;CHECK IF FIRST CHARACTER OF LINE, IF SO GET THE SUBSYS NAME
	SKIPE	LOGLIN+1		;FIRST?
	JRST	ADLOG1			;NO

;IF FORCED TERMINATION, OUTPUT CHARCTERS UNTIL PTY OUTPUT BUFFER IS EMPTY
	SKIPL	FRCTRM			;FORCED TERMINATION ?
	JRST	ADLOG1			;YES, CONTINUE TO OUTPUT CHARACTERS

	PUSHJ	P,JBST			;GET HIS STATUS
	MOVE	A,[SIXBIT /BATCON/]	;NO JOB SO SAY JUST US
	JFCL				;A SUBSYSTEM
	MOVEM	A,SBJBNM		;EXEC, SAVE NAME

ADLOG1:	AOS	LOGLIN+1		;COUNT IT
	CAIE	B,15			;IGNORE EOL'S THAT ARE CR
	PUSHJ	P,SKEOL			;WAS IT AN EOL OF SOME SORT?
	POPJ	P,			;NO--RETURN
	TLO	F,L.NOEL		;SEND NO EOL BY SNDLOG, WE ALREADY HAD ONE

ADLOG2:	PUSH	P,B			;SAVE REGISTERS SO WE CAN WRITE LINE
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E

	MOVE	C,SBJBNM		;GET NAME OF SUBSYS SUBJOB IS IN

	MOVEI	D,LOGLIN		;POINT TO LINE TO SEND
	PUSHJ	P,SNDLOG		;SEND THE LINE
	MOVE	A,[POINT 7,LOGLIN+2]	;RESTORE THE POINTERS
	MOVEM	A,LOGLIN-1		;GET BYTE POINTER AGAIN
	SETZM	LOGLIN+1		;AND CLEAR COUNT
	POP	P,E			;RESTORE REGISTERS SAVED
	POP	P,D
	POP	P,C
	POP	P,B
	POPJ	P,			;RETURN
;	SET UP FOR SENDING INTERNAL MESSAGE TO USER LOG FILE
INTMSG:	MOVE	C,[SIXBIT /BATCON/]		;SUBSYSTEM NAME
	MOVEI	D,MSGLIN			;MESSAGE ADDRESS
	SETOM	MSGLIN+1			;TERMINATE ON ZERO BYTE RATHER
						;THAN BYTE COUNT
	PUSHJ	P,SNDLG0			;SEND MESSAGE TO FILE
	SETZM	MSGLIN+1			;CLEAR CHARACTER COUNT
	POPJ	P,0

;SEND LOG LINE TO LOG, CALL
;	IN C SIXBIT, MSG TYPE
;	IN D ADDRESS OF LINE BUFFER
;	LINE BUFFER: FIRST WORD MAX # CHARS 
;	2ND WD, # CHARS DATA
;	3RD WD ON, THE DATA
;	DESTROYS REGISTERS A,B,C,D,E

SNDLOG:	SOS	MAXLOG			;COUNT THE USER LOG LINE (CHK IN MAIN)
SNDLG0:	MOVE	A,LOGJFN		;GET THE LOG JFN
	CAIGE	A,2			;LEGAL JFN ?
	BUG (<Output jfn illegal in SNDLOG>)

	PUSH	P,C			;SAVE C
	SETO	B,			;USE INTERNAL TIME
	MOVSI	C,(1B0)			;DON'T PRINT DATE
	ODTIM				;GIVE HH:MM:SS
	MOVEI	B," "			;SPACE AFTER TIME
	BOUT
	POP	P,C			;RESTORE C

	MOVEI	E,6			;LENGTH OF TYPE
SNDLG1:	SETZ	B,			;CLEAR WORD TO BUILD TYPE
	LSHC	B,6			;GET CHAR IN SIXBIT
	ADDI	B,40			;MAKE 7BIT
	BOUT
	SOJG	E,SNDLG1		;LOOP UNTIL DONE

	MOVEI	B,11			;TAB
	BOUT				;BEFORE LINE

	MOVE	E,1(D)			;GET LENGTH
	MOVEI	D,2(D)			;POINT TO LINE
	HRLI	D,440700		;MAKE BYTE POINTER TO IT

	JUMPL	E,SNDLG5		;JUMP FOR ZERO BYTE TERMINATION

SNDLG2:	ILDB	B,D			;GET A CHARACTER
	JUMPE	B,.+2			;DON'T OUTPUT NULLS
	BOUT				;PUT IT OUT
	SOJG	E,SNDLG2		;LOOP UNTIL DONE

SNDLG4:	TLZE	F,L.NOEL		;DOES HE WANT US TO APPEND EOL SEQ?
	POPJ	P,			;NO--SO RETURN

;SCRLF - ROUTINE TO SEND CRLF TO DESIRED FILE (JFN IN A)
;FALLEN INTO BY SNDLOG.
SCRLF:	MOVEI	B,15			;CR
	BOUT
	MOVEI	B,12			;LF
	BOUT

	POPJ	P,			;RETURN

SNDLG5:	MOVE	E,0(D)			;MAXIMUM NUMBER OF CHARACTERS IN BUFFER
SNDLG6:	ILDB	B,D
	JUMPE	B,SNDLG4		;END OF OUTPUT IF ZERO
	BOUT				;OUTPUT CHARACTER
	SOJG	E,SNDLG6
	JRST	SNDLG4			;FINISH OUTPUT

;FIND SUBJOB STATUS
;NON-SKIP RETURN IF NO JOB
;SKIP RETURN IF THERE IS AND
;DOUBLE SKIP RETURN IF THE SUBJOB IS IN EXEC

JBST:	PUSHJ	P,TTYJ			;FIND THE JOB #
	TLNE	A,300000		;COULD IT BE-1 OR -2?
	POPJ	P,			;YES, NO JOB
	AOS	(P)			;THERE IS A JOB, SKIP AT LEAST ONCE
	TLZ	A,400000		;FORCE JUST TTY NUMBER
	HRR	A,JOBNAM		;GET TABLE NUMBER
	GETAB				;GET TABLE ENTRY
	BUG(<JBST: Couldn't get JOBNAM table>)
	HRLZ	A,A			;GET INDEX TO USE FOR DETERMINING STATE
	HRR	A,SNAMES		;GET TABLE #
	GETAB				;GET WHAT HE IS IN
	BUG(<JBST: Couldn't get SNAMES table>)
	CAMN	A,[SIXBIT /EXEC/]	;ARE WE IN EXEC
	AOS	(P)			;YES, MAKE SKIP (+2)
	POPJ	P,			;RETURN

;INDEX TABLE TTYJOB TO FIND JOB# FOR THIS LINE
;AND JOB STATUS (WHETHER OR NOT IT IS IN STATE TI IN ANY FORK).
;RETURN +1 WITH LH A 	>0 JOB #
;			OR 400000+JOB#
;			OR -1 IF UNASSIGNED LINE
;			OR -2 IF LINE IN PROCESS OF BEING ASSIGNED
;		RH A	-1 IF NO FORK WAITING FOR INPUT
;			NOT -1 SOME FORK IS WAITING FOR INPUT FROM THIS LINE
TTYJ:	MOVE	A,TTYJOB		;GET TABLE NUMBER
	HRL	A,PTY			;GET PTY LINE # (AS INDEX)
	TLZ	A,400000		;TURN OFF THIS BIT
	GETAB				;GET JOB NUMBER AND STUFF
	BUG(<TTYJ: Couldn't find job number>)
	POPJ	P,			;RETURN

;GET A PTY, RECURSIVELY CHECK FOR A JOB AT THE OTHER END
;AND GO GET ANOTHER TILL WE FIND ONE WITHOUT..
;RETURNS +1	NO PTY AVAILABLE
;	 +2	GOT A PTY DESIG IN 1

.ASPTY:	SETZ	A,			;DO SYSTEM CHECK
	ASPTY				;GO GET ONE
	POPJ	P,			;NOTHING TO GET FAIL
	MOVEM	A,PTY			;PUT IT HERE FOR TTYJ
	PUSHJ	P,JBST			;JOB AT OTHER END?
	JRST [	MOVE	A,PTY		;NO JOB, GOOD GET THE DESIGNATOR
		AOS	(P)		;DO SKIP RETURN
		POPJ	P,]
	JFCL				;DON'T CARE WHAT STATE JOB IS IN
	MOVE	A,PTY			;GET THE DESIGNATOR
	PUSH	P,A			;AND SAVE IT TO RELEASE LATER
	PUSHJ	P,.ASPTY		;GO GET ANOTHER ONE
	JRST [	POP	P,A		;NO MORE LEFT,GET THE OLD ONE
		REPTY			;GET RID OF IT
		BUG(<.ASPTY: REPTY (1) failed>) ;SHOULDN'T HAPPEN RIGHT?!
		POPJ	P,]		;FAIL 'CUZ THER AIN'T ANY
	EXCH	A,(P)			;GOT A GOOD ONE, RETRIEVE THE OLD 1
	REPTY				;AND GET RID OF IT
	BUG(<.ASPTY REPTY (2) failed>)	;THIS SHOULDN'T HAPPEN EITHER--RIGHT?
	POP	P,A			;GET THE GOOD ONE
	AOS	(P)			;SKIP SAYS WE GOT A GOOD ONE
	POPJ	P,


;SUBROUTINE TO READ ONE CHARACTER FROM THE CTL FILE
;SKIPS IF THE JOB IS STILL THERE, NON-SKIP IF NO

RCCTL:	SKIPE	MODEI			;DOES HE NEED MODE CHANGE?
	JRST	RCCTL5			;YES, GO DO IT
	SOSGE	CTLLIN+1		;COUNT THE CHARACTER
	JRST	RCCTL2			;NEED TO GO READ IN A LINE
	ILDB	B,CTLLIN-1		;GET BYTE
	JUMPE	B,RCCTL			;GET RID OF NULLS
	AOS	(P)			;SKIP RETURN EVEN IF AT THIS LEVEL
	POPJ	P,			;WE DON'T REALLY KNOW

RCCTL2:	PUSHJ	P,RDCTL			;GO DO ACTUAL READ
	TRNN	F,R.SEMI		;WAS LINE A COMMENT
	JRST	RCCTL3			;NO
	SOS	CTLLIN+1		;DROP OFF END OF LINE CHAR
	MOVEI	D,CTLLIN		;POINT TO INPUT BUFFER
	MOVE	C,[SIXBIT /USER/]	;GIVE LINE TYPE
	PUSHJ	P,SNDLOG		;SEND LINE TO LOG FILE
	JRST	RCCTL2			;GO READ ANOTHER LINE FROM CTL FILE

RCCTL3:	TRNN	F,R.BLNK		;DOES HE WANT BLANK LINE ON LOG FILE?
	JRST	RCCTL4			;NO
	MOVE	C,[SIXBIT /USER/]	;GIVE RECORD TYPE
	MOVEI	D,BLANKL		;A BLANK LINE
	TLO	F,L.NOEL		;DON'T APPEND CRLF
	PUSHJ	P,SNDLOG		;SEND IT TO LOG FILE
	JRST	RCCTL2			;GET ANOTHER LINE

RCCTL4:	MOVEM	F,MODEI			;SAVE CURRENT MODE

RCCTL5:	MOVE	F,MODEI			;GET CURRENT MODE
	TRNE	F,R.INTR		;INTERMEDIATE MODE WILL
					;GO WITH ANY JOB MODE
	JRST	RCCTL6			;IS AT INTERMEDIATE LEVEL.

	PUSHJ	P,JBST			;GET JOB STATUS
	POPJ	P,			;NO JOB, NON-SKIP RETURN
	JRST	RCCTL7			;HE IS USER LEVEL
	JRST	RCCTL8			;HE IS AT EXEC LEVEL

RCCTL6:	SETZM	MODEI			;CLEAR MODE REQUIREMENTS
	JRST	RCCTL			;GO GET THE INPUT

;AT USER LEVEL, DID CTL FILE WANT EXEC (MONITOR) LEVEL?
RCCTL7:	TRNN	F,R.MONC		;DO WE WANT MONITOR?
	JRST	RCCTL6			;NO, BE HAPPY WITH THIS

;CHANGE LEVEL TO EXEC FROM USER BY GIVING A ^C
	MOVEI	B,"C"-100		;SET CHAR TO ^C
	AOS	(P)			;JOB STILL HERE, SKIP RETURN
	POPJ	P,			;RETURN

;AT MONITOR (EXEC) LEVEL, WHAT DID CTL FILE WANT?
RCCTL8:	TRNN	F,R.USER		;DO WE WANT USER LEVEL?
	JRST	RCCTL6			;NO,  SO ACCEPT WHAT WE HAVE.

;HERE WE MUST FLUSH FOR A MONITOR LEVEL LINE.
;AS WE HAVE FOUND SUBJOB AT EXEC, INPUT IN USER MODE
RCCTL9:	PUSHJ	P,RDCTL			;GET A LINE
	TRNN	F,R.MONC		;IS IT MONITOR LEVEL?
	JRST	RCCTL9			;NO
	JRST	RCCTL2+1		;YES-GO INTERPET IT.
;SUBROUTINE TO READ AND CLASSIFY A LINE FROM CTL FILE
RDCTL:	TRZ	F,R.RCTL		;TURN OFF THE FLAGS WE WILL USE
	SETZM	CTLLIN+1		;ZERO COUNT OF CHARS READ
	MOVE	A,[POINT 7,CTLLIN+2]	;RESET POINTER TO LINE START
	MOVEM	A,CTLLIN-1		;WHERE WE USE IT

;READ A LINE FROM CTL FILE
	MOVE	A,CTLJFN		;GET THE JFN FOR INPUT FILE
	MOVE	C,[POINT 7,CTLLIN+2]	;POINT TO THE LINE
	MOVE	D,CTLLIN		;GET THE NUMBER OF CHARACTERS
					;THAT WE HAVE ROOM FOR.
RDLP:	BIN				;GET A CHARACTER
	IDPB	B,C			;STORE CHARACTER
	PUSHJ	P,SKEOL			;WAS IT EOL
	JRST	.+2			;NOT EOL
	SOJA	D,RDLPEL		;COUNT CHARACTER AND CONTINUE
	SOJG	D,RDLP			;COUNT CHARACTER AND LOOP

;ERROR HERE--INPUT LINE IS TOO LONG FOR OUR BUFFER
	ERROR	<INPUT LINE TOO LONG FOR BUFFER>,ABEND
;WE HAVE READ AN END OF LINE
RDLPEL:	SUB	D,CTLLIN		;COMPUTE HOW MUCH WAS IN LINE
	MOVMM	D,CTLLIN+1		;SAVE # CHARS WE HAVE STORED
	CAIE	B,15			;WAS IT A CR?
	JRST	RDEX1			;NO--GO EXAMINE LINE
	BIN				;READ THE LF
	CAIN	B,12			;WAS IT REALLY A LF?
	JRST RDEX1			;YES
	BKJFN				;NO--PUT IT BACK
					;THIS MAKES IT IMPOSSIBLE TO HAVE
					;CR NOT FOLLOWED BY LF IF THE CTL
					;FILE IS FROM DECTAPE OR SOMETHING
					;ELSE THAT WON'T ALLOW BKJFN
	ERROR <RDLPEL: BKJFN failed.>,ABEND ;DROP THE JOB
RDEX1:	MOVE	A,[POINT 7,CTLLIN+2]	;POINT TO LINE AGAIN
	MOVE	C,CTLLIN+1		;GET NUMBER OF CHARACTERS WE HAVE
RDEX2:	ILDB	B,A			;GET A CHAR
	CAIE	B,40			;SPACE OR
	CAIN	B,11			;TAB?
	JRST	.+2			;YES--SKIP OVER IT
	JRST	RDEX3			;NO--GOT SIGNIFIGANT CHARACTER
	SOJG	C,RDEX2			;EXAMINE NEXT CHARACTER IF MORE
	JRST	RDDUN			;GOTTA FILL IN ADDR--SEND LINE
					;IT HAS NO NON SPACE OR TAB CHARACTERS
RDEX3:	CAIN	B,"."			;DOES LINE START WITH A . ?
	JRST	EXPT			;YES
	CAIN	B,"@"			;DOES LINE START WITH A @ ?
	JRST	EXAT			;YES
	CAIN	B,"*"			;DOES LINE START WITH A * ?
	JRST	EXSTAR			;YES
	CAIN	B,";"			;DOES LINE START WITH A ; ?
	JRST	EXSEMI			;YES
	CAIN	B,"="			;DOES LINE START WITH A = ?
	JRST	EXEQ			;YES
	CAIN	B,"$"			;DOES LINE START WITH A $ ?
	JRST	EXDOLR			;YES
	CAIN	B,"%"			;DOES LINE START WITH A % ?
	ERROR	<% IS RESERVED FOR BATCH SYSTEM LABELS--CONTINUING>
					;FALL THROUGH TO FLAG AS NOT SPECIAL

RDEX4:	TRO	F,R.INTR		;SAY THAT LINE IS NEITHER SPECIFICALLY
					;DESTINED FOR MONITOR OR USER LEVEL
	JRST	RDTR2			;GO TAKE CARE OF ^'S, STARTING WITH
					;THIS CHARACTER IN B
EXSEMI:	TRO	F,R.SEMI		;SAY IT IS A COMMENT
	JRST	RDTR			;GO TRANSILATE ^'S, STARTING WITH NEXT
					;CHARACTER.  WOULD GO TO RDDUN IF WE
					;DON'T WANT TO TRANSILATE COMMENT LINES

EXDOLR:	MOVE	D,A			;SAVE LOCATION OF $
	ILDB	B,D			;GET NEXT CHARACTER
	PUSHJ	P,SKALPH		;SKIP IF ALPHA CHAR IN B
	JRST	.+2			;NOT ALPHA
	JRST	EXSEMI			;TREAT THIS LINE AS A COMMENT
	CAIN	B,"$"			;IS NEXT CHAR ANOTHER $ ?
	JRST	EXSTAR			;YES, DELETE FIRST CHAR, THEN
					;CONTINUE WITH THIS AT USER LEVEL
	CAIE	B,12			;IS CHAR AFTER $ A LF?
	CAIN	B,13			;IS CHAR AFTER $ A VT?
	JRST	EXBLNK			;YES--GO SET R.BLNK
	CAIN	B,14			;IS CHAR AFTER $ A FF?
	JRST	EXBLNK			;YES--GO SET R.BLNK

;HERE WHEN WE HAVE A DATA LINE TO LEAVE AS IT IS.
EXDATA:	TRO	F,R.USER		;SAY IT IS USER LEVEL
	JRST	RDTR2			;GO TRANSILATE--INCLUDE THIS CHAR IN B

EXBLNK:	TRO	F,R.BLNK		;SAY BLANK LINE
	JRST	RDDUN			;JUST RETURN--THIS IS REALLY SIMPLE

EXPT:	MOVE	D,A			;GET POINTER TO CURRENT CHARACTER
	ILDB	B,D			;GET NEXT CHARACTER
	PUSHJ	P,SKALPH		;SKIP IF ALPHA CHAR
	JRST	EXDATA			;IF NOT, TREAT AS DATA AS IS
					;IF SO, FALL THROUGH TO EXAT
					;WHICH WILL STRIP THE FIRST CHAR
					;AND MAKE US MONITOR MODE

EXAT:	TRO	F,R.MONC		;SAY A MONITOR (EXEC) LEVEL COMMAND
	JRST	EXDELC			;GO DELETE THE FIRST CHARACTER

EXSTAR:	TRO	F,R.USER		;USER COMMAND
	JRST	EXDELC			;GO DELETE FIRST CHARACTER

EXEQ:	TRO	F,R.USER!R.SEOL		;USER DATA, MUST SUPPRESS END OF LINE

EXDELC:	SETZ	D,			;COMMON ROUTINE TO NULL OUT THE
	DPB	D,A			;FIRST CHARACTER TO DESTROY IT
;TRANSLATE THE ^'S INTO THE APPROPRIATE CODES
RDTR:	SOJLE	C,RDTREX		;ARE WE DONE?
	ILDB	B,A			;NO--GET ANOTHER CHAR
RDTR2:	CAIE	B,"^"			;IS THIS CHAR AN ^ ?
	JRST	RDTR			;CONTINUE IF NOT
	MOVE	D,A			;SAVE WHERE IT WAS.
RDTR3:	SOJLE	C,RDTREX		;ARE WE DONE NOW?
	ILDB	B,A			;IF NOT, CONTINUE BY GETTING NEXT CHAR
	CAIN	B,"^"			;ANOTHER ^ ?
	JRST	RDTRUP			;YES.
;	PUSHJ	P,SKALPH		;CHECK IF IT IS ALPHA
	TRNN	B,100			;TEST IF ALPHA OR SUCH
	JRST	RDTR			;NO, SO LEAVE IT AS IS
	TRZ	B,140			;FORCE IT TO A CONTROL CHARACTER
	DPB	B,A			;STORE IT BACK WHERE WE GOT IT
	SETZ	B,			;AND DESTROY THE ^ THAT PRECEEDED IT
	DPB	B,D			;BY DUMPING A NULL ON TOP OF IT
	JRST	RDTR			;CONTINUE TO TRANSILATE

RDTRUP:	SETZ	B,			;DESTROY THE FIRST ^ BY DROPPING
	DPB	B,D			;A NULL ON TOP OF IT
	JRST	RDTR3			;GO BACK IF ^^^^ MEANS ^^^ (DEC'S WAY)
;	JRST	RDTR			;GO BACK IF ^^^^ MEANS ^^ (FORTRAN WAY)

RDTREX:	TRNN	F,R.SEOL		;DO WE WANT TO SUPPRESS EOL STUFF?
	JRST	RDDUN			;NO--GO TO DONE ROUTINE
	SOS	CTLLIN+1		;DELETE THE TERMINATOR CHARACTER
	MOVE	A,[POINT 7,CTLLIN+2]	;POINT TO LINE
	MOVE	C,CTLLIN+1		;GET # CHARS TO DO
RDSCL:	ILDB	B,A			;GET CHARACTER
	JUMPE	B,RDSCLE		;IGNORE NULLS FOUND IN LINE
	CAIN	B," "			;IS IT BLANK?
	JRST	.+2			;SKIP IF EITHER
	MOVN	D,C			;GET COUNT HERE
RDSCLE:	SOJG	C,RDSCL			;COUNT CHARS AND LOOP
	AOJ	D,			;FUDGE SO THE ADDM GIVES RIGHT RESULT
	ADDM	D,CTLLIN+1		;COMPUTE NEW LENGTH FOR LINE

RDDUN:	POPJ	P,			;RETURN TO CALLER
;SKIP IF END OF LINE CHARACTER IN B
SKEOL:	CAIE	B,15			;CR
	CAIN	B,12			;LF
	JRST	SKEOLS			;YES-GOT AN EOL

	CAIE	B,13			;VT
	CAIN	B,14			;FF
	JRST	SKEOLS			;YES-GOT SOME EOL

	CAIN	B,37			;EOL
SKEOLS:	AOS	(P)			;SET SKIP
	POPJ	P,			;RETURN

;SKIP IF AN ALPHA CHAR IN B
SKALPH:	CAIGE	B,"A"			;COULD IT BE UPPER CASE?
	POPJ	P,			;FAIL, CODE IS TOO LOW
	CAIG	B,"Z"			;IS IT IN RANGE FOR UPPER CASE?
	JRST	SSALPH			;YES-SUCCEED
	CAIGE	B,"A"+40		;IS IT LOWER CASE?
	POPJ	P,			;NO-TOO LOW TO BE LC.
	CAIG	B,"Z"+40		;IS IT IN LC RANGE?
SSALPH:	AOS	(P)			;SUCCESS-SET SKIP
	POPJ	P,			;RETURN
;LUUO ROUTINES
LUUOI:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E
	MOVE	A,40			;GET TRAP CAUSE
	ROT	A,^D9			;GET IT'S OPCODE
	ANDI	A,37			;THESE BITS ARE ALL THAT CAN COUNT
	JRST	@.(A)			;TRANSFER TO ROUTINE
	EXP	ERRLOG			;TRANSFER VECTOR TO LUUO STUFF

ERRLOG:	MOVE	A,@40			;GET WORD WITH ADDRESSES
	HRLI	A,440700		;MAKE BYTE POINTER
	MOVE	B,[POINT 7,MSGLIN+2]	;DESTINATION STRING
	SETZM	MSGLIN+1		;INIT COUNT
	ILDB	C,A			;GET CHAR
	JUMPE	C,.+4			;OUT IF DONE
	IDPB	C,B			;STORE CHAR
	AOS	MSGLIN+1		;COUNT CHAR
	JRST	.-4			;GO AGAIN
	MOVE	C,[SIXBIT /BAERR/]	;ERROR
	MOVEI	D,MSGLIN		;POINT TO LINE
	PUSHJ	P,SNDLOG		;WRITE IT ON LOG FILE

	HLRZ	A,@40			;GET RETURN ADDR
	JUMPE	A,LUUORE		;GO RETURN IF NONE SPECIAL
	HRRM	A,-5(P)			;RESET REUTURN ADDR IF ONE GIVEN

LUUORE:	POP	P,E			;RESTORE THE REGISTERS
	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,			;RETURN
	IFN	GDDT,<
;	SET UP^D EVOCATION OF DDT
SETDDT:	MOVEI	A,400000	;FORK HANDLE
	MOVE	B,[XWD LEVTAB,CHNTAB]
	SIR
	MOVE	A,[XWD 4,0]	;;^D
	ATI
	MOVEI	A,400000
	MOVE	B,[XWD 400000,0]	;ACTIVATE CHANNEL 0
	AIC
	EIR
	IIC
	POPJ	P,
STDDT:	HRROI	A,[ASCIZ /GOING INTO DDT - TYPE RESM$G TO RESUME
/]
	PSOUT
	JRST	DDT##
RESM:	DEBRK
	>
	IFN	SRINOT,<
;	NOTIFY USER
;	AC2 = MESSAGE TO BE SENT TO USER
;
NOTIFY:	PUSH	P,6
	PUSH	P,E
	PUSH	P,D
	PUSH	P,C
	PUSH	P,B		;SAVE STRING MESSAGE POINTER
	MOVE	A,[SIXBIT /JOBTTY/]
	SYSGT
	HRRZ	6,B		;SAVE JOBPT TABLE NUMBER
;;;	MOVE	A,[SIXBIT /JOBDIR/]
;;;	SYSGT
	MOVE	B,JOBDIR
	HLLZ	D,B		;AOBJN POINTER FOR FETCHING JOBDIR ENTRIES
	HRRZ	E,B		;SAVE JOBDIR TABLE NUMBER
NOTLOP:	HRRZ	A,A		;ISOLATE DIRECTORY NUMBER
	CAME	A,QENT+USRDIR	;IS THIS JOB OURS ?
	JRST	NOTND1		;NO, EXAMINE NEXT
	HRLZ	A,D		;GET JOB NUMBER UNDER INVESTIGATION
	HRR	A,6		;GET JOBPT TABLE NUMBER
	GETAB
	ERROR	<NOTIFY:JOBPT FAILURE>,NOTRTN
	HLRZ	A,A		;ISOLATE TTY NUMBER
	CAME	A,0		;IGNORE IF TTY 0 (PROCESS OF LOGGING OUT)
	CAMN	A,[XWD 0,-1]	;IS JOB ATTACHED TO TTY ?
	JRST	NOTND1		;NO
	TRO	A,1B18		;MAKE INTO DESIGNATOR
	PUSHJ	P,PRINT		;PRINT NOTIFY MESSAGE
NOTND1:	AOBJP	D,NOTRTN
	HRLZ	A,D		;JOBDIR TABLE INDEX
	HRR	A,E		;JOBDIR TABLE NUMBER
	GETAB
	ERROR	<NOTIFY:JOBDIR FAILURE>,NOTRTN
	JRST	NOTLOP
NOTRTN:	POP	P,B
	POP	P,C
	POP	P,D
	POP	P,E
	POP	P,6
	POPJ	P,
>
;MESSAGE PRINTOUT FOR NOTIFY AND DAYFILE
PRINT:	MOVE	B,-1(P)		;RETRIEVE STRING POINTER
	SETZ	C,
	SOUT			;OUTPUT MESSAGE
;OUTPUT JOB NUMBER
	MOVE	B,QENT+BJOBNO	;GET JOB NUMBER
	MOVEI	C,^D10		;DECIMAL
	NOUT
	ERROR	<NOUT FAILED IN PRINT>,.+1
	MOVEI	B,","
	BOUT
	HRRZ	B,CTLJFN
	MOVE	C,[XWD 011110,000001]
	JFNS			;OUTPUT JOB NAME
	MOVE	B,-2(P)
	SETZ	C,
	SOUT			;OUTPUT MESSAGE END
	HRROI	B,-1
	MOVE	C,[XWD 216000,100000]
	ODTIM			;TIME OF MESSAGE
	HRROI	B,[ASCIZ /]
/]
	SETZ	C,
	SOUT
	POPJ	P,

;ROUTINE TO MAKE DAYFILE, RECORD OF ENTRIES STARTED AND COMPLETED.
;
;
DAY:	PUSH	P,A
	PUSH	P,C
	PUSH	P,B
	MOVE	A,[1B7!1B17!]	;SHORT, NO ACCESS BY OTHER FORKS
	HRROI	B,DAYNAM
	GTJFN
	ERROR	<GTJFN FAILED FOR DAYNAM>,DAYEND
	MOVEM	A,DAYJFN
	MOVE	B,[44B5!1B19!1B20!]	;OPENFILE
	QOPENF
	ERROR	<OPENF FAILED FOR DAYNAM>,DAYEND

	MOVE 	B,[XWD 1,12]		;FIND FILE LENGTH
	MOVEI	C,C			;PUT IN C
	GTFDB

	MOVE	A,[XWD DAYBUF,DAYBUF+1]	;NULL FIRST 100 CHARACTERS (20 WORDS)
	MOVE	B,NULL
	MOVEM	B,DAYBUF

	BLT	A,DAYBUF+^D19
	MOVE	A,DAYJFN
	MOVE 	B,[POINT 36,DAYBUF+^D20]
	MOVN	C,C
	SKIPE	C		;SKIP THE SIN IF NOTHING TO READ IN
	SIN			;MOVE FILE INTO BUFFER
	SETZ	B,
	SFPTR			;SET POINTER TO BEGINNING OF FILE
	ERROR	<DAY:SFPTR FAILED >,DAYEND

	HRROI	A,DAYBUF		;POINTER TO DAYBUF
	PUSHJ	P,PRINT

	MOVE	A,DAYJFN
	MOVE	B,[POINT 36,DAYBUF]	;36 BIT OUTPUT
	MOVNI	C,DAYSIZ
	SOUT				;OUTPUT BUFFER BACK TO FILE

	CLOSF
	ERROR	<CAN'T CLOSE DAYFILE>,DAYEND
	SETO	A,
	HRRI	B,DAYBUF/1000
	HRLI	B,400000
	MOVSI	D,<<<^D10000/5>/1000>+1>	;NUMBER OF PAGES TO UNMAP
DAYRLS:	PMAP				;RELEASE PAGE 1 OF BUFFER
	AOS	B
	AOBJN	D,DAYRLS
DAYEND:	POP	P,B
	POP	P,C
	POP	P,A
	POPJ	P,
;	SRI MESSAGE SENDING CODE
;	SEND MESSAGE TO SUBMITTER
;	AC2= STRING POINTER TO MESSAGE (LESS THAN EQUAL 39 CHARACTERS)
SEND:
	AOSN	SNDLCK			;CHECK IF WE CAN SEND A MESSAGE
	JRST	SEND0			;YES
	MOVEI	A,^D30000		;TRY AGAIN IN 30 SECS.
	DISMS
	JRST	SEND
SEND0:
	MOVEM	B,MSGPTR		;SAVE FOR MESSAGE PRINT OUT
	MOVEM	C,MSGPT1
	MOVEI	C,10
SEND1:	SKIPN	FORK		;FORK OCCUPIED
	JRST	SEND2		;NO
	MOVEI	A,^D1000	;YES, WAIT AWHILE AND TRY AGAIN
	DISMS
	SOJGE	C,SEND1		;TRIED 10 TIMES
	POPJ	P,0		;FORGET IT
SEND2:	MOVE	A,[XWD 340000,0]
	MOVEM	A,SNDMSF	;SEND MESSAGE FLAGS
	HRROI	A,SUBJCT	;SUBJECT OF MESSAGE
	SETZ	C,
	SOUT			;PUT MESSAGE IN INFERIOR FORKS ACS
	MOVE	A,[XWD 440700,MSG]
	MOVEI	B,"<"
	IDPB	B,A
	MOVE	B,QENT+USRDIR
	DIRST			;DIRECTORY NUMBER TO STRING
	ERROR	<SEND:DIRST FAILURE>,ABMSG
	MOVEI	B,">"
	IDPB	B,A
	HRROI	B,MSGTXT
	SETZ	C,
	SOUT
	MOVE	A,[400001,,1]		;SHORT FORM GTJFN,OUTPUT FILE,VERSION 1
SNDAGN:	HRROI	B,MSG
	GTJFN
	JRST	[CAIE A,GJFX18	;NO SUCH NAME
		 CAIN A,GJFX19	;NO SUCH EXTENSION
		 CAIA
		 ERROR	<SEND:FAILURE ON MESSAGE.TXT FILE FOR USER MESSAGE>,ABMSG
		 HRLZI A,400001  ;CREATE MESSAGE.TXT IF IT DOESN'T EXIST
		 JRST SNDAGN]
	HRRZM	A,MSGJFN	;MESSAGE.TXT JFN
	MOVE	A,[10001,,1]		;SHORT FORM, TEMPORARY FILE GTJFN
	HRROI	B,TEMP
	GTJFN
	ERROR	<SEND:CAN'T GET JFN FOR TEMP>,ABMSG
	HRRZM	A,TMPJFN
	MOVE	B,[XWD 70000,300000]	;READ, WRITE
	QOPENF
	ERROR	<OPENF FAILURE ON TEMP>,ABMSG
	MOVE	B,MSGPTR		;GET POINTER TO MESSAGE
	SETZ	C,
	SOUT			;OUTPUT TO FILE
	SKIPN	CTLJFN
	JRST	SEND5
	MOVE	B,QENT+BJOBNO
	MOVEI	C,^D10
	NOUT
	ERROR	<NOUT FAILED IN SEND>,ABMSG
	MOVEI	B,","
	BOUT
	MOVE	C,[XWD 011110,000001]
	SKIPE	B,CTLJFN		;SKIP IF CALLED FROM CRASH CODE
	JFNS			;OUTPUT JOB NAME
SEND5:
	MOVE	B,MSGPT1
	SETZ	C,
	SOUT
	HRROI	B,-1		;CURRENT TIME AND DATE
	MOVE	C,[XWD 216000,100000]
	ODTIM
	MOVEI	B,37			;CR,LF
	BOUT
	MOVE	A,TMPJFN
	HRLI	A,400000	;DON'T RELEASE JFN
	CLOSF
	ERROR	<CLOSF FAILURE FOR TEMP.>ABEND
	MOVEI	B,INFACS	;INFERIOR FORK ACS
CFAGN:	HRLZI	A,240000	;SAME CAPABILITIES
	CFORK
	JRST	[MOVEI A,^D60000  ;NO FORKS, TRY AGAIN IN 1 MINUTE
		 DISMS
		 JRST CFAGN]
	MOVEM	A,FORK		;FORK HANDLE
	HRLZI	A,1		;SHORT FORM GTJFN
	HRROI	B,SNDMSG
	GTJFN
	ERROR	<SEND:CAN'T GET JFN FOR SNDMSG>,ABMSG
	HRRZM	A,SNDJFN	;SNDMSG JFN
	HRL	A,FORK
	GET			;GET SNDMSG

	MOVEI	A,400000
	MOVE	B,[XWD 3,HMSGFK]
	MOVEM	B,CHNTAB+^D19	;SET UP CHANNEL TABLE
	HRRZI	B,1B19
	AIC
	MOVE	A,FORK
	MOVEI	B,4		;FOURTH ENTRY IN ENTRY VECTOR
	SFRKV			;START FORK
SNDRTN:	POPJ	P,

ABMSG:	SETOM	SNDLCK		;CLEAR MESSAGE LOCK
	POPJ	P,		;RETURN

HMSGFK:	PUSH	P,A
	PUSH	P,B
	MOVE	A,FORK
	RFSTS
	MOVEM	A,FKSTS
	MOVEM	B,FKPC
	MOVE	A,FORK
	MOVEI	B,FKACS
	RFACS
	MOVEI	A,400000
	MOVEI	B,1B19
	DIC			;DISABLE FORK TERMINATION CHANNEL
	MOVE	A,MSGJFN	;MESSAGE.TXT JFN
	RLJFN
	ERROR	<SEND:CAN'T RELEASE MESSAGE.TXT JFN>,.+1
	MOVE	A,FORK		;GET FORK HANDLE
	KFORK			;KILL IT TO GET RID OF SNDMSG
	SETZM	FORK		;CLEAR FORK ACTIVE FLAG
	MOVE	A,TMPJFN
	RLJFN
	ERROR	<SEND:CAN'T RELEASE TEMP JFN>,.+1
	SETOM	SNDLCK		;CLEAR MESSAGE LOCK
	POP	P,B
	POP	P,A
	DEBRK

;PSEUDO INTERRUPT ROUTINES
PSIEOF:	PUSH 	P,A			;SAVE A
	CAME	A,CTLJFN		;WAS IT ON CTL FILE?
	ERROR	<EOF ON FILE OTHER THAN CTL FILE>,EOFNCT
	MOVEI	A,KILLIT		;ADDRESS TO START TERMINATION PROCESS
	MOVEM	A,LEV2PC		;SET UP DEBRK PC VALUE
	CAME	D,CTLLIN		;WAS THERE ANY INPUT?
	ERROR	<END OF FILE ON CTL FILE>
	POP	P,A
	DEBRK				;CONTINUE
EOFNCT:	MOVEI	A,EOJ			;GO END JOB
	MOVEM	A,LEV2PC		;PUT IN RETURN PC
	POP	P,A
	DEBRK				;RETURN TO TOP LEVEL

;FILE DATA ERROR
PSIERR:	CAME	A,CTLJFN		;WAS IT CTL FILE
	ERROR	<DATA ERROR ON FILE OTHER THAN CTL FILE>,.+2
	ERROR	<DATA ERROR ON CTL FILE>
	MOVEI	A,ABEND
	MOVEM	A,LEV2PC
	DEBRK				;RETURN TO PROG
MSGTXT:	ASCIZ	/MESSAGE.TXT/
SNDMSG:	ASCIZ	/<SUBSYS>SNDMSG.SAV/
SNDJFN:	BLOCK	1
JOBMSG:	ASCIZ	/ BATCH JOB /
STRMSG:	ASCIZ	/ STARTED AT /
FINMSG:	ASCIZ	/ FINISHED AT /
TEMP:	ASCIZ	/BATCH.MSG/
JOBNOT:	ASCIZ	/
  [BATCH JOB /
STRNOT:	ASCIZ	/ STARTED AT /
FINNOT:	ASCIZ	/ FINISHED AT /
NULL:	ASCIZ	/     /
IFE	DBGFIL,<
DAYNAM:	ASCIZ	/<BATCH>DAYFILE.ENTRIES;P777740;1/
	>
IFN	DBGFIL,<
DAYNAM:	ASCIZ	/<BATCH>TDAYFILE.ENTRIES;P777740;1/
	>
FST:	POINT	7,[ASCIZ /RUNNING /]		;0
	POINT	7,[ASCIZ /IO WAIT /]		;1
	POINT	7,[ASCIZ /VOL TERM /]		;2
	POINT	7,[ASCIZ /INVL TERM /]		;3
	POINT	7,[ASCIZ /FORK WT /]		;4
	POINT	7,[ASCIZ /DISMISSED /]		;5
	POINT	7,[ASCIZ /AT BKPNT /]		;6
	LIT
NINF==<<<.+1000>-INFFK>/1000>
	LIT
	SUBTTL	INFERIOR FORK PRIVATE PAGE
	LOC	20000
PRIV:					;LABEL FOR MAPPING
;	SEND MESSAGE STORAGE
MYNAME:	BLOCK	1			; -1 FOR SCHED LEVEL, 0 FOR INFR FORK
					;USED TO TELL WHO GOT BUG AND HOW TO
					;RESTART 
SBJBNM:	BLOCK	1			;NAME OF SUBSYS SUBJOB IS IN
SYMPTR:	BLOCK	1			;COPY OF SYMTAB WORD FOR CRASH COPY
JOBN:	BLOCK	1			;JOB NUMBER OF ACTIVE PROCESS
FORK:	BLOCK	1			;FORK HANDLE OF SNDMSG FORK (PRIVATE)
FRCTRM:	-1				;FORCE TERMINATION FLAG
CTLJFN:	BLOCK	1			;JFN FOR CTL FILE
LOGJFN:	BLOCK	1			;JFN FOR LOG FILE
PTY:	BLOCK	1			;PTY DESIGNATOR
MODEI:	BLOCK	1			;FLAGS FROM RDCTL TO DESC. INP.
RELFRK:	BLOCK	1			;RELATIVE FORK HANDLE
RUNTIM:	BLOCK 1				;TIME JOB STARTED(TODCLK FORMAT)
MAXCPU:	BLOCK	1			;MAX CPU TIME JOB CAN USE
MAXETM:	BLOCK	1			;MAX ELAPSED TIME ALLOWED
NAPTIM:	BLOCK	1			;HOW LONG TO DISMS BETWEEN CHECKS
MAXLOG:	BLOCK	1			;MAX LINES JOB CAN WRITE ON LOG FILE
INFDSB:	BLOCK	1			;INFERIOR DESUBMIT FLAG
QENT:	BLOCK	QESIZE			;QUEUE ENTRY
DQENT:	BLOCK	QESIZE			;DESUBMIT REQUEST ENTRY
NUMENT:	BLOCK	1			;NUMBER OF ENTRIES IN QUEUE
CSHACS:	BLOCK	25			;AC SAVE BLOCK FOR CRASH DUMP+ A BIT
IPDL:	BLOCK	PDLL+1
LEVTAB:	EXP	LEV1PC,LEV2PC,LEV3PC	;PC STORAGE ADDRESSES FOR INTERRUPTS
CHNTAB:	
	IFN	GDDT,<
	3,,STDDT			;DDT FOR DEBUGGING
	>
	IFE	GDDT,<
	3,,UNEX				;UNEXPECTED INTERRUPT
	>
	3,,DESUBF			;DESUBMIT FORK
	3,,INFSTS			;INFERIOR FORK STATUS
	REPEAT	^D7,<	3,,UNEX				;UNEXPECTED INTERRUPT>
	2,,PSIEOF			;FILE COND 1, EOF
	2,,PSIERR			;FILE COND 2, DATA ERROR
	REPEAT	^D7,<	3,,UNEX				;UNEXPECTED INTERRUPT>
	3,,HLTNFK			;HALTED FORK
	REPEAT	^D17,<	3,,UNEX		;UNEXPECTED INTERRUPT>
;	STRING TO FORCE LOGOUT WHEN NO LOGO APPEARS IN CTL FILE
LOGSTR:	POINT 7,[ASCIZ /LOGOUT
/]
;LINE FOR MESSAGES FROM BATCH, COMMENTS COPIED OVER, ETC.
	POINT	7,MSGLIN+2		;POINTER TO STORE IN MSGLIN
MSGLIN:	LOGL*5				;MAX LENGTH MSG LINE
	BLOCK	LOGL+1			;ACTUAL LENGTH AND THE TEXT
;LINE FOR INPUT TO SUBJOB
	POINT	7,CTLLIN+2		;POINTER TO DATA IN LINE
CTLLIN:	CTLL*5				;MAX LENGTH INPUT LINE CTL FILE
	BLOCK	CTLL+1			;LENGTH OF ACTUAL DATA AND LINE

;LINE FOR OUTPUT FROM SUBJOB
	POINT	7,LOGLIN+2		;POINTER TO STORE IN LOGLIN
LOGLIN:	LOGL*5				;MAX LENGTH LOG LINE
	BLOCK	LOGL+1			;LENGTH ACTUALLY THERE, AND LINE
DAYJFN:	BLOCK 1
	LIT			;FORCE ALL LITERALS BEFORE NEW PAGE
	VAR
INFACS:			;INFERIOR FORK ACS
	BLOCK	1	;0
MSGJFN:	BLOCK	1	;1, MESSAGE.TXT JFN
SNDMSF:	BLOCK	1	;2, SEND MESSAGE FLAGS
TMPJFN:	BLOCK	4	;3-6
SUBJCT:	BLOCK	8	;7-16, SUBJECT OF MESSAGE
	BLOCK	1	;17
MSG:	BLOCK	10
MSGPTR:	BLOCK	1	;INPUT MESSAGE POINTER
MSGPT1:	BLOCK 1		;INPUT MESSAGE POINTER, PART 2
PATCH:	BLOCK	100
FKSTS: BLOCK 1
FKPC:	BLOCK 1
FKACS:	BLOCK	20
;PSEUDO-INTERRUPT SYSTEM STORAGE
LEV1PC:	0				;STORAGE FOR PC AT TIME OF INTERRUPT
LEV2PC:	0
LEV3PC:	0
NPRIV==<<<.-PRIV>+1000>/1000>	;NUMBER OF INFERIOR FORK PRIVATE PAGES


; MOVE DAYBUFFER UP HIGHER THAN SYMBOL TABLE BUT DON'T ASSIGN A LABLE
; BECAUSE LOADER WILL TRY TO PUT THE SYMBOLS ABOVE IT
DAYBUF==60*1000			;FIRST WORD ADDRESS OF DAYFILE BUFFER
DAYSIZ==<^D10000/5>		;NUMBER OF WORDS ASSIGNED TO DAYFILE BUFFER
	END	START
