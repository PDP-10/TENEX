;<SOURCES>PAT.MAC;4      8-JUL-74 09:45:00      EDIT BY STEVE
;      MAKE BBN CHANGES TO VERSION 127
;<SOURCES>PAT.MAC;3	30-MAY-74 11:45:00	EDIT BY STEVE (REISS)
;     HLP:, FIX BUGS FOR FORTRAN-10, LARGE FILES, RENAME
;     MAKE CORE UUO NOT ZERO NON-EXISTANT PAGES
;<COMPAT>PAT.MAC;39    21-AUG-73 18:12:10	EDIT BY CLEMENTS
; MOVED DEVICE SYS: ENTIRELY INTO SUBSYS
;<COMPAT>PAT.MAC;38    26-JUN-73 19:02:02	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;37    12-JUN-73 13:03:01	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;36    16-MAY-73 16:24:49	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;35    26-JAN-73 18:26:02	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;34     9-JAN-73 18:49:26	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;33    28-NOV-72 18:20:16	EDIT BY CLEMENTS
;FIX TO DSK DMP OUT SO NON-MULTIPLES OF 200 PADDED WITH 0, NOT CORE
;<COMPAT>PAT.MAC;32    22-NOV-72 12:12:32	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;31    15-NOV-72 21:10:01	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;30    14-NOV-72 16:30:46	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;29     3-SEP-72 20:49:23	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;28     3-SEP-72 18:50:07	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;27     9-AUG-72 19:13:48	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;26     8-AUG-72 14:27:52	EDIT BY CLEMENTS
;<COMPAT>PAT.MAC;25     5-JUL-72 19:16:05	EDIT BY CLEMENTS
TITLE PAT - 10/50 COMPATIBILITY FOR TENEX
PATVER==:127		;EDIT NUMBER STORED IN PVLOC
SUBTTL DEFINITIONS AND ALLOCATION
SEARCH STENEX

COMMENT \

THIS CODE RESIDES IN A HIGH AREA OF USER CORE (CURRENTLY 700000).
IT IS LOADED FROM THE SSAVE FILE <SUBSYS>PA1050.SAV BY THE
MONITOR WHENEVER A FORK EXECUTES ITS FIRST 10/50 UUO (40-77, BUT NOT 0).
THE FIRST TIME, ENTRY IS VIA THE SECOND LOCATION OF THE ENTRY VECTOR.
THEREAFTER, 10/50 UUO'S RESULT IN AN IMMEDIATE TRANSFER TO
THIS CODE VIA THE FIRST LOCATION OF THE ENTRY VECTOR.  WHEN
ANY 10/50 UUO IS EXECUTED, THE MONITOR MOVES LOCATION 40 TO
MONUUO (SPECIFIED BY FOURTH WORD OF ENTRY VECTOR), AND THE RETURN
 PC TO MONUPC (SPECIFIED BY FIFTH WORD OF ENTRY VECTOR).  THIS CODE
INTERPRETS THE UUO AND RETURNS DIRECTLY TO THE USER PROGRAM.

THIS CODE USES THREE OF THE RESERVED UUO'S (42-44) FOR INTERNAL
PURPOSES.

ASSEMBLY AND LOADING PROCEDURE:

@MACRO	;OR WHATEVER TO GET A MACRO WITH STENEX IN IT
*PAT_DSK:PAT
*LOADER!
/S/B/1H/700000H
*PAT$
@START
@

THE START AFTER LOADING CAUSES THE CODE TO BE MOVED FROM ITS LOAD
LOCATION TO ITS RUNNING LOCATION IN HIGH CORE.  THE SYMBOL
TABLE IS ALSO MOVED, AND THE POINTER ADJUSTED.  AN SSAVE FILE
OF PAGES 700-777 SHOULD BE MADE TO BE USED FOR DEBUGGING.

TO PRODUCE THE SYSTEM FILE, START AT MAKEPF (MAKEPF$G).  THIS WILL
WRITE A SSAVE FILE WITH WRITE PROTECTION INTO THE CONNECTED DIRECTORY.
RENAME IT INTO <SUBSYS> TO RUN IT.

FOR DEBUGGING COMPATIBILITY PACKAGE, FIRST RESET, AND GET
THE TEN-50 PROGRAM TO BE USED FOR TESTING, IF ANY.
THEN, MERGE AN SSAVE FILE (WITH DDT AND SYMBOLS) OF THE
DEBUG VERSION OF PAT, TYPE DDT, THEN DEBUG$G TO SET UP THE
COMPATIBILITY VECTOR, PSI SYSTEM, AND TEMPORARY STORAGE.

THE THIRD ENTRY OF THE ENTRY VECTOR IS A ROUTINE WHICH LOADS 10/50
.SHR FILES.  THESE HAVE A FORMAT DIFFERENT FROM .SAV AND SO
CANNOT BE LOADED BY THE EXEC.  TO RUN A 10/50 SHARE FILE UNDER TENEX,
 1. LOAD THE .SHR SEGMENT BY STARTING <SUBSYS>PA1050.SAV AT 700002
 2. MERGE THE .LOW SEGMENT IF ANY WITH THE EXEC MERGE COMMAND
 3. SSAVE THE RESULT

THE SIXTH ENTRY OF THE ENTRY VECTOR IS A ROUTINE WHICH CONVERTS A
LOADED HISEG SUBSYSTEM TO A 10/50 SHARABLE SAVE FILE,
SSAVING ONLY PAGES IN 400-677 RANGE WITH A CORRECTLY SETUP
VESTIGAL JOB DATA AREA. START <SUBSYS>PA1050.SAV AT 700005.
\

SAMFRK==1			;PAT IN SAME FORK WITH USER PROG
;THIS CODE AT PRESENT WILL NOT WORK FOR SAMFRK=0, BUT THERE ARE
;VESTIGES AND PARTIALLY IMPLEMENTED SECTIONS WHICH MAY BE MADE TO
;RUN THAT WAY SOME DAY. I.E., WITH PAT RUNNING THE 10/50 PROGRAM AS
;AN INFERIOR PROCESS.

;INTERNAL UUO'S

OPDEF UMOVE[42B8]	;NOTE - NOT COMPLETELY GENERAL.
OPDEF UMOVEM[43B8]	; E.G., CAN'T UMOVE TO EE,FF
OPDEF XCTUU[44B8]	;NOTE ALL XCT'S HAVE SAME OPCODE IF SAMFRK=1
OPDEF XCTUM[44B8]
OPDEF XCTMU[44B8]

	DEFINE TMSG (MSG)
<	PUSHJ P,TMSGQ
	XWD 440600,[SIXBIT @MSG/@]
>
IFNDEF FTSTAT,<FTSTAT==0>	;IF NONZERO KEEP STATISTICS OF PA1050 USAGE

	MLON

;ACCUMULATOR DEFINITIONS

PF=0		;PAT'S FLAG AC
A=1		;FIRST AC'S ARE TEMPS AND JSYS ARGS
B=2
C=3
D=4
E=5
F=6
G=7
AA=10		;CONTAINS DEVICE NUMBER DURING I/O UUO HANDLING
BB=11		;HOLDS BASE OF I/O CHANNEL DATA BLOCK DURING ...
CC=12		;HOLDS ADDRESS OF CURRENT RING BUFFER IN I/O
EE=13
FF=14
AC=15		;AC NUMBER IN TEN-FIFTY UUO
CAC=16		;CONTENTS OF THAT AC. LOADED ON ALL UUOS.
P=17

;FLAGS IN AC PF. LEFT HALF ARE PERMANENT (HOLD OVER USER PROG)
; RIGHT HALF ARE MEANINGFUL ONLY WITHIN A GIVEN UUO, CLEARED ON ENTRY

R.FAIL==1	;LOOKUP FAILURE COUNTER IN RUN UUO
R.DIRN==2	;DIRECTION OF TRANSFER IN MTA, USET
R.RUNU==4	;DISTINGUISH RUN UUO FROM GETSEG UUO
R.UEXT==10	;EXTENDED LOOKUP OR ENTER FLAG
R.EXIT==20	;ON FOR EXIT 1, ; OFF FOR EXIT 0, .
R.TMPX==40	;TMP EXTENSION IN LUKPAR
R.PAGX==R.TMPX	;PAGE IN HI SEG EXISTS (IN DOGTSG ROUTINE)
R.FERR==100	;FATAL ERROR. PREVENTS PMAPPING PAT OUT OF EXISTANCE
R.KJFN==200	;KEEP JFN IN CLOSE ROUTINE.
R.RHLT==400	;RUN OR GETSEG UUO FOLLOWED BY HALT (DON'T RETURN)
R.SYS==1000	;RUN UUO FROM SYS, SO DO SETNM

L.DBUG==1	;DEBUGGING PAT ITSELF
L.ONCE==2	;HAVE BEEN THRU ONCE CODE
L.INDF==4	;INDICATE FF BY ^L REQUESTED AT EXEC LEVEL, SO DO SO.

;CHARACTERS REFERENCED SYMBOLICALLY
C.BELL==7	;BELL CHARACTER
C.FF==14	;FORMFEED CHARACTER
EOL==37		;END OF LINE CHARACTER
STDALT==175	;10/50'S STANDARD ALTMODE CHARACTER
		; REPLACES 033 (ESC) AND 176 DURING SIMPLE TTY IO

;10/50 JOB AREA LOCATIONS

JOBERR=42		;ERROR COUNT DURING CCL SEQUENCE
JOBREL=44
JOBPD1=45		;PLACE USERS EXPECT TO SEE PC OF LAST UUO
JOBDDT=74
JOBHRL=115
JOBSA=120
JOBSYM=116
JOBFF=121
JOBS41=122
JOBREN=124
JOBAPR=125
JOBCNI=126
JOBTPC=127
JOBOPC=130	;OLD PC BEFORE ^C REENTER, ^C START OR ^C DDT SEQUENCE
JOBCOR=133
JOBVER=137
JOBDA==140		;START OF JOB. END OF JOB DATA AREA

;FLAGS IN LH OF FLAGWD IN CHANNEL DATA TABLES (CHTABS)

ASNDF==100
ENTERF==200
INBUFF==400
IOPENF==1000
LOOKPF==2000
OOPENF==4000
PADDF==10000	;NOT USED
OUTBFF==20000
INFIRF==40000
OUFIRF==100000
INITF==200000

;FLAGS FOR DEVICE CHARACTERISTICS

HASDIR==4			;DEVICE HAS DIRECTORY
MTADEV==20			;DEVICE IS MAGTAPE
DTADEV==100			;DEVICE IS DECTAPE
PTRDEV==200			;DEVICE IS PAPERTAPE READER
PTPDEV==400			;DEVICE IS PAPERTAPE PUNCH
TTYDEV==1B32
DSKDEV==200000			;DEVICE IS DISC

MY40=MONUUO			;UUO WORD FOR LOCAL UUO'S

IFE SAMFRK,<
LOC 41
	JSYS MYUU		;LOCAL UUO ROUTINE
	RELOC
>

MAXERR==10			;RETRIES WHEN READING MAGTAPE
DDTLOC=770000
.S=400000			;HANDY ABBREVIATION FOR SIGN BIT

MAXIOL==4000			;BIGGEST DUMP I/O LIST TENEX WILL BUY

WHEEL==1B18			;PROCESS CAPABILITY BIT
OPER==1B19			;PROCESS CAPABILITY BIT
MAINT==1B21			;PROCESS CAPABILITY BIT
PRIJFN==100			;PRIMARY INPUT JFN
PROJFN==101			;PRIMARY OUTPUT JFN

;GET THE 10/50 UUO'S INTO THE SYMBOL TABLE FOR DEBUGGING PAT

DEFINE REDEF(A)<IRP A,<A=:EXP <A>>>
REDEF <CALL,INIT,CALLI,OPEN,TTCALL,RENAME,IN,OUT,SETSTS,STATO>
REDEF <GETSTS,STATZ,INBUF,OUTBUF,INPUT,OUTPUT,CLOSE,RELEAS>
REDEF <MTAPE,UGETF,USETI,USETO,LOOKUP,ENTER>

;CORE ASSIGHMENTS
;FIRST FOR THE CODE.

PATLOC=:700000			;PLACE WHERE COMPATIBILITY ACTUALLY RUNS
PATPAG==:PATLOC_<-^D9>		;AND AS A PAGE NUMBER TO GET THRU LOADER
REVECL==4			;MUST BE .GE. EVECL-.JBHDA, TO
				;ALLOW SPACE TO PUT EVEC AT 700000EVEN
				; RATHER THAN 700010.
LODORG==400000		;WHERE THE LOADER WILL LEAVE "HI SEGMENT"
NPATPG==<<TSTOP>_-11>-PATPAG+1		;HOW MANY PAGES IN PAT AND TS

;STORAGE ALLOCATOR FOR TEMP STORAGE

	DEFINE ALC(NAM,SIZ)
	<	NAM=:LC
LC==LC+SIZ
>

;VARIABLE STORAGE FOR PAT

	PATSPG==716		;PAT SCRATCH PAGE, FOR PMAPS
	IOMPGS==720		;MAPPED I/O USES 16. PAGES STARTING HERE
IFN FTSTAT,<
	STATPG==715		;PAGE TO MAP IN STATISTICS FILE
	STATLC==STATPG_11
	SL.UUO=STATLC+200	;UUO OPCODE-40
	SL.CLI=STATLC+0		;CALLI NUMBER (PLUS ONLY, ROOM FOR 200)
	SL.TCL=STATLC+300	;AC OF TTCALL
	SL.UNI=STATLC+776	;UNIMPLEMENTED CALLS
	SL.ONC=STATLC+777	;CALL TO ONCE. I.E., COUNT MAPPING SELF
>

	LC==717000		;TEMP STORAGE PAGE
	TSLOC==LC

	ALC CHTABS,0
	ALC DEVNAM,1		;SIXBIT DEVICE NAME FROM USER
	ALC JFNTAB,1		;ONLY NEEDS 7 BITS
	ALC MAPTAB,1		;MAPPING INFO FOR DISK FILES
	ALC BYTCNT,1		;BYTE COUNT FOR INPUT FILE
	ALC BUFHTB,1		;OUTPUT AND INPUT BUFFER HEADERS
	ALC FLAGWD,1		;INTERNAL FLGS,,FILE STATUS
	ALC DEVNUM,1		;DEVICE DESIGNATOR OF THIS DEVICE,
				;  FILLED IN BY INIT
	ALC FILNAM,1		;SIXBIT FILE NAME FROM USER
	ALC EXT,1		;SIXBIT FILE EXT (3 CHARS) FROM USER
	ALC DIRNUM,1		;DIRECTORY NUMBER

	NTABS==LC-CHTABS
	ALC CHTABN,17*NTABS

	ALC SAVMOD,1		;SAVED TELETYPE MODE
ALC CHTEND,0			;ABOVE HERE CLEARED BY CALLI 0.

	ALC TTPNT,1		;POINTER,TTCALL INPUT BUFFER
	ALC TTCNT,1		;BYTE COUNT,TTCALL INPUT BUFFER
	ALC TTBUF,23		;TTCALL INPUT BUFFER
	ALC TTLINE,1		;LINE PRESENT FOR TTCALL
	ALC ERRCNT,1		;NUMBER OF MAGTAPE ERRORS
	ALC DEVNM7,2		;SEVEN BIT DEVICE NAME
	ALC FILNM7,3		;SEVEN BIT FILE NAME
	ALC EXT7,2		;SEVEN BIT EXTENSION
	ALC DIRNAM,10		;STRING SPACE FOR A DIRECTORY NAME
	ALC SEE,1		;SAVE EE AND FF DURING MYUUO'S
	ALC SFF,1
	ALC FDBB,22
	ALC BUFFER,2
	ALC JBLOCK,11		;(9) FOR JFN ARG LIST
	ALC IAC,20		;AC'S ON INTERRUPT

	ALC MYUUO,1		;LOCAL UUO RETURN

	ALC IOBPT,1		;BYTE POINTER FOR IN AND OUT
	ALC IOCNT,1		;COUNT FOR IN AND OUT

	ALC STRNG1,10		;TEMP STRING STORAGE
				;ALSO USED AS STACK IN CSTART ROUTINES

	ALC RETSAV,1		;RETURN SAVED BY PSEUDOINTERRUPT
	ALC CNIWRD,1		;SAVES OV EN AND FOV EN FOR APR CONI
	ALC MYPPN,1		;THIS JOB'S DIRECTORY NUMBER, SET BY ONCE
	ALC MYJOBN,1		;THIS JOB'S JOB NUMBER, " "

	ALC LOTOP,1		;TOP OF LOW SEGMENT
	ALC JBREL,1		;SAVED JOBREL
	ALC JBHRL,1		;SAVED JOBHRL
	ALC USRENB,1		;WHAT USER ASKED FOR ON LAST APRENB UUO
	ALC DMPLST,2		;MTA IO BY DUMP COMMANDS HERE
	ALC MTDUMP,1		;TEMP IN DUMP I/O
	ALC SPDELC,1		;TEMP IN DUMP I/O
	ALC TYSTAT,1		;TTY STATUS (CONTROLLING TTY).
				; SIGN IS ^O FLAG, RH IS INIT BITS
	ALC CSTFLG,1		;FLAG TO FORCE MRETN TO DO A START/REE
	ALC LEVTAB,3		;PSI LEVEL TABLE
	ALC CHNTAB,^D36		;PSI CHANNEL TABLE
CLRTOP==LC-1			;LAST LOCATION CLEARED ON FIRST ENTRY

	ALC FORTY,1		;PLACE TO STORE CONTENTS OF 40 AT TIME OF CALL
	ALC ACS,20		;USER'S AC'S AT TIME OF UUO.
	ALC PFLAGS,1		;STORAGE FOR PF AC WHILE USER RUNS.
	ALC INPAT,1		;IN PAT IF NON-0,IN USER PROG IF 0
	ALC FDBTMP,1		;ROOM TO MODIFY A WORD OF FDB
	ALC MONUUO,1		;COPY OF MONITOR 40
	ALC MONUPC,1		;USER PC SAVED BY MONITOR
	ALC CSTCOD,1		;^C START CODE: -1=ST,
				; -2=REE, -3=DDT, +N=GOTO N
	ALC CSTOPC,1		;OLD PC WHERE ^C CONT WOULD HAVE GONE
	ALC ITIME1,1		;SYSTEM UPTIME AT ONCE
	ALC ITIME2,1		;SYSTEM TOD IN MS AT ONCE
				;NEEDED FOR ACCURATE MSTIME CODE
	ALC EXITAD,1		;P SAVE FOR CONTINUE AFTER EXIT

PDLL==60
	ALC PDL,PDLL
IPDLL==20
	ALC IPDL,IPDLL		;STACK FOR INTERRUPT LEVEL

	TSTOP=LC		;END OF TEMP STORAGE. TRY TO KEEP
				; THIS IN ONE PAGE.

SUBTTL ENTRY VECTOR AND TOP-LEVEL OF UUO HANDLER
HISEG

EVEC=PATLOC		;COPY TO PUBLISHED LOCATION
BLOCK REVECL		;SPACE FOR EVEC TO BE PUT
;;;IF2,<IFG EVEC+EVECL-.,<PRINTX REVECL TOO SMALL>>
SJBSYM: BLOCK 1	;PLACE FOR LINIT TO STASH JOBSYM
PVLOC:	EXP PATVER		;EDIT NUMBER IN RH, PATCH IN LH.

KEVEC:	JRST COMPAT		;UUO'S NORMALLY ENTER VIA THIS
	JRST PATINI		;FIRST UUO ENTERS VIA THIS
	JRST GETSHR		;ENTRY TO GET SHR FILE
	MONUUO			;MON 40 DUMPED HERE ON MON UUO
	MONUPC			;USER PC DUMPED HERE ON MON UUO
	JRST MAKSHR		;MAKE SHR VERSION OF SUBSYSTEM
	EXP CCPSIN		;CHANNEL FOR EXEC TO PSI ON FOR ^C REE
	XWD CSTCOD,CSTOPC	;WHERE TO STORE DATA FOR ^C ST SEQ.
EVECL==.-KEVEC			;LENGTH OF ENTRY VECTOR
CSTMCD==3			;MAX VALUE OF CSTCOD KNOWN ABOUT

;10/50 TYPE UUO'S ARRIVE HERE

PATINI:	SETZM PFLAGS		;FIRST TIME ENTRY. CLEAR FLAG WORD.
COMPAT:	SKIPE INPAT		;NOW IN PAT?
	JRST MYUU		;YES, LOCAL UUO
COMPT2:	MOVEM 17,ACS+17
	MOVEI 17,ACS
	BLT 17,ACS+16
	MOVE P,PATSTK		;SETUP LOCAL STACK
	HLLZ PF,PFLAGS		;FLAGS TO AC FOR PAT'S FLAGS.
IFN SAMFRK,<
	SETOM INPAT
	MOVE A,MONUUO
	MOVEM A,FORTY		;PRESERVE 40 OVER MYUUO'S
	LDB AC,ACPTR		;GET AC FIELD OF UUO
	MOVE CAC,ACS(AC)	;CONTENTS OF USER AC (MAY BE IRRELEV.)
	MOVE A,MONUPC		;GET CALLING PC OF USER UUO
	MOVEM A,JOBPD1		;PUT IT IN 10/50'S STACK AREA
	PUSH P,A		;AND ON PAT'S STACK>
IFE SAMFRK,<
	LDB AC,ACPTR		;GET AC FIELD OF UUO
	UMOVE CAC,0(AC)		;CONTENTS OF USER AC (MAY BE IRRELEV.)
	PUSH P,MONUPC
>
	TLNN PF,L.ONCE		;FIRST TIME?
	PUSHJ P,ONCE		;YES. GO SET UP PSI AND TEMP STORAGE
;FALL THRU

COMPT3:	LDB A,[POINT 9,FORTY,8] ;GET UUO NUMBER
	CAIL A,40		;SMALL NUMBERS ARE ILLEGAL
	CAIL A,100		;IS IT A GOOD ONE?
	PUSHJ P,ITRAP		;NO GOOD.
IFN FTSTAT,<
	AOS SL.UUO(A)>		;COUNT USAGE OF THE UUO
	JRST @COMPTT-40(A)	;WE ONLY WANT TO DO 40-77

COMPTT:	EXP UCALL,UINIT,ITRAP,ITRAP,ITRAP,ITRAP,ITRAP,UCALLI
	EXP UOPEN,UTTCLL,ITRAP,ITRAP,ITRAP,URENME,UIN,UOUT
	EXP USETST,USTATO,UGETST,USTATZ,UINBUF,UOUTBF,UINPUT,UOUTPT
	EXP UCLOSE,URELEA,UMTAPE,UUGETF,UUSETI,UUSETO,ULOOKP,UENTER

ACPTR:	POINT 4,FORTY,12
PATSTK:	IOWD PDLL,PDL		;LOCAL STACK
PSISTK: IOWD PDLL,PDL		;STACK WHILE ON LEVEL 1

;RETURN FROM 10/50 UUO

MRETN2:
	AOS (P)		;SKIP RETURN
MRETN:	MOVEM PF,PFLAGS		;SAVE FLAG AC
	POP P,JOBPD1
IFN SAMFRK,<
	SETZM INPAT>
	SKIPE A,CSTFLG		;CONTROL-C, START DONE?
	JRST CSTMRT		;YES. GO PROCESS IT
MRETNA:	MOVSI 17,ACS
	BLT 17,17
	JRSTF @JOBPD1

CSTMRT:	HLL A,JOBPD1		;PRESERVE USER'S FLAGS
	EXCH A,JOBPD1		;PUT START ADR IN RETURN, GET UNUSED RET
	MOVEM A,JOBOPC	;PUT THE RETURN IN OPC FOR USER
	SETZM CSTFLG		;CLEAR FLAG THAT START DONE.
	JRST MRETNA		;AND RETURN TO HIM
CPOPJ1:
	AOS (P)		;SKIP RETURN
CPOPJ:	POPJ P,

;COMMON RETURNS FROM UUO'S

RETZR1:	TDZA A,A		;CLEAR AC A, THEN STOTC1 SKIP RET
RETZER:	TDZA A,A		;CLEAR AC A, AND SKIP TO STOTAC
STOTC1:	AOS 0(P)		;SET FOR SKIP RETURN
STOTAC:
IFN SAMFRK,< MOVEM A,ACS(AC)>	;STORE THE AC FOR USER
IFE SAMFRK,< UMOVEM A,0(AC)>	;STORE THE AC FOR THE USER
	JRST MRETN		;AND RETURN FROM THE UUO

RETM11:	AOS 0(P)		;SKIP RETURN A MINUS 1
RETM1:	MOVNI A,1		;RETURN A MINUS ONE
	JRST STOTAC		;TO USER'S AC

;LOCAL UUO SERVICE

MYUU:	MOVEM EE,SEE
	MOVEM FF,SFF
IFN SAMFRK,<
	MOVE EE,MONUPC
	MOVEM EE,MYUUO		;PC TO UUO RETURN
>
	LDB EE,[POINT 9,MY40,8]
	SUBI EE,42		;FIRST LOCAL UUO
	CAIL EE,0		;LOCAL UUO?
	CAILE EE,2
	JRST [	MOVE EE,SEE	;NO, MUST HAVE BEEN ^C, REENTER
		JRST COMPT2]	;TREAT AS USER OP
	JRST	@.+1(EE)
	EXP MMOVE,MMOVEM,MXCT

MXCT:	HRRZ EE,MY40		;PTR TO INST TO XCT
	MOVEI EE,@(EE)		;COMPUTE EFFECTIVE ADDR
	CAIGE EE,20
	ADDI EE,ACS		;E IN ACS, OFFSET
	HLL EE,@MY40	
	TLZ EE,37		;FLUSH IND AND INDEX
	XCT EE
	JRST MUR1
	AOS MYUUO		;FOR SKIP TYPE INSTRUCTIONS THAT DID
	JRST MUR1

MMOVE:	LDB EE,[POINT 4,MY40,12]
	HRRZ FF,MY40		;EFFECTIVE ADDR
	CAIGE FF,20		;AC?
	ADDI FF,ACS		;YES, POINT TO SAVED AC'S
	MOVE FF,(FF)		;FETCH OBJECT
	MOVEM FF,(EE)		;PUT INTO PROPER AC
	JRST MUR2

MMOVEM:	LDB EE,[POINT 4,MY40,12]
	MOVE EE,(EE)
	HRRZ FF,MY40
	CAIGE FF,20
	ADDI FF,ACS
	MOVEM EE,(FF)
	JRST MUR2

MUR2:	MOVE FF,SFF
MUR1:	MOVE EE,SEE
	JRSTF @MYUUO

SUBTTL UUO PROCESSORS FOR INDIVIDUAL UUO'S
;10/50 CALL AND CALLI TABLES
;NOTE THAT NEGATIVE CALLIS AND 0-55 HAVE SIXBIT CALLS
; WHILE 56 UP DO NOT.
MXSIXB==55			;MAXIMUM CALLI WHICH HAS A SIXBIT ARG

DEFINE MCALLI
<CC JAMJFN,JAMJFN
 CC FILJFN,FILJFN
 CC SQUEZE,SQUEZE
 CC UNSQZE,UNSQZE
 CC LIGHTS,LIGHTS
>
DEFINE PCALLI
<CC RESET,RESET
 CC DDTIN,DDTIN
 CC SETDDT,SETDDT
 CC DDTOUT,DDTOUT
 CC DEVCHR,DEVCHR
 CC DDTGT
 CC GETCHR,GETCHR
 CC DDTRL
;10
 CC WAIT
 CC CORE,CORE
 CC EXIT,EXIT
 CC UTPCLR,UTPCLR
 CC DATE,DATE
 CC LOGIN,ILEGAL
 CC APRENB,APRENB
 CC LOGOUT,EXIT
;20
 CC SWITCH,SWITCH
 CC REASSI,ILEGAL
 CC TIMER,TIMER
 CC MSTIME,MSTIME
 CC GETPPN,GETPPN
 CC TRPSET,ILEGAL
 CC TRPJEN,ILEGAL
 CC RUNTIM,RUNTIM
;30
 CC PJOB,PJOB
 CC SLEEP,SLEEP
 CC SETPOV
 CC PEEK,RETZER
 CC GETLIN,GETLIN
 CC RUN,RUN
 CC SETUWP,SETUWP
 CC REMAP,REMAP
;40
 CC GETSEG,GETSEG
 CC GETTAB,GETTAB
 CC SPY
 CC SETNAM,SETNAM
 CC TMPCOR
 CC DSKCHR
 CC SYSSTR
 CC JOBSTR
;50
 CC STRUUO
 CC SYSPHY
 CC FRECHN
 CC DEVTYP,DEVTYP
 CC DEVSTS
 CC DEVPPN
 CC SEEK
 CC RTTRP
;60
 CC LOCK
 CC JOBSTS
 CC LOCATE
 CC WHERE
 CC DEVNAM
 CC CTLJOB
 CC GOBSTR
 CC ACTIVA
;70
 CC DEACTI
 CC HPQ
 CC HIBER
 CC WAKE
 CC CHGPPN
 CC SETUUO
 CC DEVGEN
 CC OTHUSR
;100
 CC CHKACC
 CC DEVSIZ,DEVSIZ
REPEAT 0,<
 CC DAEMON
 CC JOBPEK
 CC ATTACH
 CC DAEFIN
 CC FRCUUO
 CC DEVLNM
;110
 CC PATH.
 CC METER.
 CC MTCHR.
 CC JBSET.
 CC POKE.
 CC TRMNO.
 CC TRMOP.
 CC RESDV.
;120
 CC DISK.
 CC DVRST.
 CC DVURS.
>
>


DEFINE CC (A,B)<
IFB <B>,<
	JRST CMRETN		;   A UNIMPLEMENTED
>
IFNB <B>,<
	JRST	B		; A HANDLER
>
>

MCLIT:
MCALLI				;TRANSFER TO NEGATIVE CALLI'S
NMCLI==.-MCLIT			;NUMBER OF MINUS CALLI'S
CALLTV:				;ADDRESS OF TABLE ENTRY FOR CALLI 0

PCALLI				;TRANSFERS FOR POSITIVE CALLI'S

NPCLI==.-CALLTV

;UUO'S
;CALL AND CALLI

UCALL:	UMOVE A,@FORTY	;ARG TO CALL IN SIXBIT, NAME OF ROUTINE
	MOVSI B,-<NPCAL+NMCAL>	;LENGTH OF TWO SIXBIT TABLES
	CAMN A,CALLIT-NMCAL(B)	;THIS ENTRY IN NAME TABLE?
	JRST [MOVEI B,-NMCAL(B)	;YES. GET CALLI NUMBER IT WOULD BE
		JRST UCALL1]	;AND GO TO CALLI HANDLER
	AOBJN B,.-2		;NO, TRY NEXT NAME
CMRETN:	IFN FTSTAT,<
	AOS SL.UNI>		;COUNT UNIMPLEMENTED CALLS
	JRST MRETN		;MAKE A NO-OP.

UCALLI:	HRRZ B,FORTY		;EFFECTIVE ADDR IS THE ARG
	TRNE B,.S		;EXTEND SIGN INTO PHYSICAL BIT.
	TROA B,1B19		;IT'S NEGATIVE.
	TRZ B,1B19		;ITS POSITIVE
	MOVEI A,NPCLI+NMCLI	;TOTAL CALLI LENGTH. CATCHES NEGATIVE
				; OUT OF RANGE TOO, BY HALF-WORD ARITHMETIC
	CAIGE A,NMCLI(B)	;OFFSET TO ACCOUNT FOR LEGAL NEGATIVE VALUES
	JRST CMRETN		;LARGE ARGUMENTS ARE NO-OPS
UCALL1:	IFN FTSTAT,<
	TRNN B,777600		;ONLY COUNT 0-177 CALLI'S
	AOS SL.CLI(B)>		;IN STATISTICS PAGE
	JRST @CALLTV(B)		;DISPATCH

LIGHTS:	MOVEI A,.S		;THIS FORK
	RPCAP			;GET PROCESS CAPABILITIES
	MOVE A,CAC		;GET ARGUMENT TO DISPLAY
	TRNE C,WHEEL!OPER!MAINT	;WILL MONITOR COMPLAIN ABOUT LITES?
	LITES			;NO. DO IT.
	JRST MRETN

SWITCH:	SWTCH
	JRST STOTAC

;BBN-LOCAL CALLI'S - SUBJECT TO DELETION OR CHANGE WITHOUT NOTICE!!

FILJFN:	HRRZ A,CAC		;CHANNEL NUMBER
	TRZ A,777760		;MAKE SURE IN RANGE
	IMULI A,NTABS		;CONVERT TO TABLE ADDRESS
	HRRZ A,JFNTAB(A)	;GET THE JFN NOW ON THIS FILE
	JUMPE A,STOTAC		;RETURN NON-SKIP IF NULL
	JRST STOTC1		;AND SKIP IF OK.

JAMJFN:	HLRZ B,CAC		;CHANNEL ARG
	ANDI B,17		;MAKE SURE REASONABLE CHANNEL
	IMULI B,NTABS		;TABLE ADDRESS
	HRRZ A,JFNTAB(B)	;GET OLD JFN
	HRRZM CAC,JFNTAB(B)	;PUT IN NEW ONE, HOPE IT WORKS.
	JRST STOTC1		;RETURN SKIPPING WITH OLD JFN IN AC

GETTAB:	HRRZ A,CAC		;GET REQUESTED TABLE NUMBER
	CAIL A,NGTTAB		;KNOWN TO US?
	JRST MRETN		;NO
	HLRZ B,CAC		;YES. GET REQUESTED ENTRY NUMBER
	CAIE B,-1		;THIS JOB?
	CAIN B,-2		;THIS HISEG?
	MOVE B,MYJOBN		;YES. PLUG IN JOB NUMBER.
	JRST @GTTAB(A)		;GO TO TABLE HANDLER

GTTAB:	EXP .GTSTS,.GTADR,.GTPPN,.GTPRG,.GTTIM,.GTKCT,.GTPRV,.GTSWP
	EXP .GTTTY,.GTCNF,.GTNSW,.GTSDT,.GTSGN,.GTODP,.GTLDV
NGTTAB==.-GTTAB

;UNIMPLEMENTED ONES:
.GTADR==MRETN
.GTKCT==MRETN
.GTPRV==MRETN
.GTSWP==MRETN
.GTNSW==MRETN
.GTSDT==MRETN
.GTSGN==MRETN
.GTODP==MRETN
.GTLDV==MRETN

.GTPPN:	CAME B,MYJOBN		;WANT OWN PPN?
	JRST [MOVE A,['JOBDIR']		;NO. GET ONE HE WANTS
		SYSGT
		JUMPE B,MRETN
		MOVE A,B		;TABLE NUMBER
		HLL A,CAC		;INDEX = JOB NUMBER
		GETAB
		  JRST MRETN
		HLRZ A,A		;ONLY LOGGED-IN DIR
		JRST STOTC1]		;RETURN LOGGED-IN DIRECTORY
	MOVE A,MYPPN			;RETURN THIS JOB'S LOGGED IN DIRECTORY
	JRST STOTC1

.GTPRG:	CAME B,MYJOBN		;WANT OWN JOB?
	JRST MRETN		;NO. DON'T BOTHER
	GETNM			;GET THIS JOB'S NAME IN SIXBIT
	JRST STOTC1		;AND RETURN IT.

.GTTIM:	CAME B,MYJOBN
	JRST MRETN
	JOBTM
	IMULI A,^D60
	IDIVI A,^D1000
	JRST STOTC1
.GTTTY:	MOVE D,B		;MOVE JOB NUMBER OUT OF THE WAY
	MOVE A,['JOBTTY']
	SYSGT
	JUMPE B,MRETN
	MOVE A,B
	HRL A,D			;JOB,,TABLE
	GETAB
	  JRST MRETN
	HLRE A,A		;TERMINAL NUMBER OR -1
	JRST STOTC1		;RETURN TO USER

.GTCNF:	CAIE B,17		;STATES WORD?
	JRST MRETN		;NO. IMPLEMENT MORE LATER, NOT NOW.
	MOVSI A,750501		;STATES AS SUPPORTED BY PA1050
	JRST STOTC1		;SKIP RETURN THIS ANSWER

.GTSTS:	CAME B,MYJOBN		;SELF?
	JRST MRETN		;NO. NOT YET IMPLEMENTED
	MOVSI A,040004		;JNA AND JLOG
	JRST STOTC1		;SKIP RETURN

SUBTTL TTY HANDLING


DDTIN:	PUSHJ P,NOCTRO		;CLEAR OUTPUT SUPPRESS BIT
	MOVEI A,100		;PRIMARY INPUT FILE
	RFMOD			;READ CURRENT TTY STATUS
	PUSH P,B		;AND SAVE IT
	TRO B,170300		;SET ALL WAKES, OUTPUT MODE 3
	SFMOD			;SET THE NEW MODES
	MOVE D,CAC		;ADDRESS TO STORE STRING IN USER SPACE
	HRLI D,440700
	MOVEM D,IOBPT
DDTIN1:	PUSHJ P,TTYBIN		;GET A CHAR FROM TTY
DDTIN3:	XCTMU [IDPB B,IOBPT]	;POINTER IN M, DEST IN USER SPACE
	CAIE B,EOL		;EOL FROM TTY SERVICE?
	JRST DDTIN2		;NO
	MOVEI B,15		;YES, CONVERT TO CR,LF
	XCTMU [DPB B,IOBPT]	;DEPOSIT OVER THE EOL
	MOVEI B,12		;LF
	JRST DDTIN3

DDTIN2:	SIBE			;ANY MORE INPUT CHARS?
	JRST DDTIN1		;YES, GO FETCH THEM
	MOVEI B,0
	XCTMU [IDPB B,IOBPT]	;TERMINATE INPUT WITH NULL
	POP P,B			;RETRIEVE OLD TT STATUS
	SFMOD			;AND RESET IT
	JRST MRETN

SETDDT:	UMOVEM CAC,JOBDDT		;SET HIS DDT ADDRESS
	JRST MRETN

SUBTTL TTCALL AND OTHER TERMINAL HANDLING UUO'S
;TTCALL UUO, DISPATCH BY AC FIELD.
;AC VALUES ARE:
;0=INCHRW 1=OUTCHR 2=INCHRS 3=OUTSTR 4=INCHWL 5=INCHSL 6=GETLCH
;7=SETLCH 10=RESCAN 11=CLRBFI 12=CLRBFO 13=SKPINC 14=SKPINL
;15=IONEOU 16=CPOPJ 17=CPOPJ

UTTCLL:	MOVE E,TYSTAT		;CARRY AROUND TTY STATUS BITS IN E
IFN FTSTAT,<
	AOS SL.TCL(AC)>	;COUNT THE TYPE OF TTCALL
	JRST @.+1(AC)
	EXP TTCL0,TTCL1,TTCL2,TTCL3,TTCL4,TTCL5,TTCL6,TTCL7
	EXP TTCL10,TTCL11,TTCL12,TTCL13,TTCL14,TTCL15
	EXP MRETN,MRETN		;16 AND 17 NOT IMPLEMENTED

TBOUND:	MOVEI A,100
	HRRZ C,FORTY		;ARG MUST NOT BE BETWEEN 20 AND 137
	CAIGE C,140
	CAIGE C,20
	POPJ P,
	PUSHJ P,ERRARG

TTCL2:	PUSHJ P,NOCTRO		;DEFEAT CONTROL O
	PUSHJ P,TBOUND
	PUSHJ P,ECHIMM		;SET ECHO IMMEDIATE
	SKIPG TTCNT		;ANY CHARS IN MY BUFFER?
	JRST TTCL2A		;NO, TRY MONITOR BUFFER
	AOS (P)			;YES, SUCCESSFUL SKIP RETURN
	JRST TTGET		;GO GET IT
TTCL2A:	SIBE			;NO, ANY IN MONITOR BUFFER?
	AOSA 0(P)		;SUCCESSFUL RETURN
	JRST SLOWRT		;NOTHING THERE. RETURN SLOWLY.
	JRST TTCL0A

ECHIMM:	RFMOD
	MOVEM B,SAVMOD		;PREVIOUS MODE WILL BE RESTORED ON
	TRZN B,3B25		;CLEAR ECHO BITS. WAS NO ECHO?
	POPJ P,			;YES, DON'T CHANGE
	TRO B,1B25		;SET ECHO MODE TO IMMEDIATE FOR TTY
	SFMOD
	POPJ P,

RESMOD:	SKIPN SAVMOD		;RESTORE SAVED ECHO MODE?
	POPJ P,			;NO, NOTHING THERE
	RFMOD
	XOR B,SAVMOD		;RESTORE ECHO MODE BITS
	TRZ B,3B25
	XOR B,SAVMOD
	SETZM SAVMOD		;ONLY DO IT ONCE
	SFMOD
	POPJ P,

TTCL0:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
	PUSHJ P,TBOUND		;LEGAL DESTINATION?
	PUSHJ P,RESMOD		;RESTORE SAVED ECHO MODE

TTGET:	SOSGE TTCNT		;ANY CHARS IN BUFFER?
	JRST TTCL0A		;NOTHING THERE - GO BACK TO REFILL
	ILDB B,TTPNT

TTXIT:	UMOVEM B,(C)		;RETURN THE CHAR
	JRST MRETN

TTCL0A:	RFMOD
	TRO B,17B23!3B29	;BREAK ON ANYTHING
	SFMOD
	MOVE E,TYSTAT		;GET STATUS BITS OF TTY
	PUSH P,C		;PRESERVE ARG
	PUSHJ P,TTYST2		;SET ECHO CONTROL
	PUSHJ P,TTBFI3		;SET UP THE TTCALL BUFFER
	POP P,C			;RESTORE ARG
	PUSHJ P,TTYBIN		;GET A CHAR FROM TTY
	TRNE E,1B29		;FULL CHAR SET MODE?
	JRST TTCL0B		;YES. DON'T CRUNCH ALTMODES
	CAIE B,176		;OLD ALTMODE
	CAIN B,33		;ESCAPE?
	MOVEI B,STDALT		;YES. MAKE STANDARD ALTMODE
TTCL0B:	CAIE B,37		;END OF LINE?
	JRST TTXIT		;NO - FEED IT TO USER
	PUSHJ P, TTEOL		;YES-CONVERT TO CR-LF
	JRST TTGET

TTCL1:	MOVEI A,101		;OUTPUT A SINGLE CHAR
	UMOVE B,@FORTY
	PUSHJ P,TTYBOU		;OUTPUT CHARACTER, CHECKING ^L, ^O
	JRST MRETN

TTCL15:	MOVEI A,101		;OUTPUT ONE IMAGE CHARACTER.
	RFMOD			;SO SWITCH TTY TO BINARY TO DO IT.
	PUSH P,B		;SAVE PREVIOUS MODE
	TRZ B,3B29		;BINARY
	SFMOD
	UMOVE B,@FORTY		;GET USER'S CHARACTER
	PUSHJ P,TTYBO1		;SEND IT
	POP P,B			;RESTORE PREVIOUS MODE
	SFMOD			; ..
	JRST MRETN		;DONE WITH THIS TTCALL

TTYBOU:				;ROUTINE TO OUTPUT A BYTE TO TTY
	SKIPGE TYSTAT		;CONTROL O FLAG (OUTPUT SUPPR) ON?
	POPJ P,0		;YES. DON'T OUTPUT
	CAIN A,100		;OUTPUT TO PRIMARY INPUT SOMEHOW?
	MOVEI A,101		;YES. MAKE IT OUTPUT.
	CAIN B,C.FF		;FORMFEED?
	JRST TTYBOF		;YES. GO CHECK INDICATE FLAG
	CAIN B,EOL		;WANT TO GET THE REAL "037" OUT?
	JRST [	RFMOD		;YES. SWITCH TO BINARY.
		PUSH P,B
		TRZ B,3B29
		SFMOD
		MOVEI B,EOL
		PUSHJ P,TTYBO1
		POP P,B
		SFMOD
		POPJ P,0]	;END OF SEND EOL IN BINARY
	;ELSE FALL INTO OUTPUTTER
TTYBO1:	BOUT			;ORDINARY. OUTPUT IT.
	POPJ P,0		;AND RETURN
TTYBOF:	TLNN PF,L.INDF		;FORMFEED. SEND OR INDICATE?
	JRST TTYBO1		;SEND.
	HRROI B,[ASCIZ /^L
/]				;INDICATION. NOTE CLOBBERS B AND C
	MOVEI C,0		;STRING LENGTH COUNTER
	SOUT			;STRING TO TTY (JFN IN A)
	POPJ P,0		;AND RETURN

TTCL4:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
	PUSHJ P,TBOUND		;LEGAL DESTINATION?
	PUSHJ P,RESMOD		;RESTORE SAVED ECHO MODE
	SKIPN TTCNT
	PUSHJ P,TTBFIN
	SKIPE TTLINE		;IS THERE A LINE THERE?
	JRST TTGET2		;YES, GO GET IT

TTLP1:	PUSHJ P,TTFIL2		;TRY TO FILL BUFFER
	SKIPL TTLINE		;NOW DO WE HAVE A LINE?
	JRST TTLP1		;NO- TRY AGAIN
	JRST TTGET2		;NOW THERE IS A LINE THERE


TTCL5:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
	PUSHJ P,TBOUND
	SKIPN TTCNT
	PUSHJ P,TTBFIN
	SKIPL TTLINE		;IS THERE A LINE?
	PUSHJ P,TTFILL		;NO,TRY TO GET ONE
	SKIPL TTLINE		;NOW IS THERE ONE?
	JRST TTCL5A		;NO, GIVE UP AND NONSKIP RETURN
	AOS 0(P)		;YES- SUCCESSFUL SKIP RETURN
TTGET2:	ILDB B,TTPNT
	UMOVEM B,(C)		;GIVE CHAR TO USER
	SOSLE TTCNT		;COUNT IT
	JRST MRETN		;MORE LEFT
	SETZM TTLINE		;OUT OF CHARS
	PUSHJ P,TTBFIN		;INIT BUFFER
	JRST MRETN

TTCL5A:	PUSHJ P,ECHIMM		;SET ECHO MODE TO IMMEDIATE
	JRST SLOWRT		;AND RETURN (SLOWLY) TO USER


TTFILL:	MOVEI A,100
	SIBE			;SOMETHING IN INPUT BUFFER?
	SKIPA			;YES
	POPJ P,			;NO, FORGET IT

TTFIL2:	PUSHJ P,TTYBIN		;DO A BIN FROM TTY
	CAIL B,40		;CONTROL?
	CAILE B,174		;ALTMODE OR RUBOUT?
	JRST TTCNTL		;YES

TTFIL1:	IDPB B,TTPNT		;NO- STUFF IT
	AOS TTCNT
	JRST TTFILL		;AND GET MORE

TTCNTL:	TRNE E,1B29		;IN FCS MODE?
	JRST TTCNT1		;YES. DON'T CRUNCH ALTMODES OR GRAB CTLS
	CAIE B,176		;OLD ALTMODE?
	CAIN B,33		;OR ESCAPE?
	MOVEI B,175		;YES. CONVERT TO 10/50 ALTMODE
	CAIE B,177		;RUBOUT CHARACTER?
	CAIN B,"A"-100		;CHAR DELETE?
	JRST DELCH		;YES
	CAIE B,"U"-100		;CONTROL U (10/50 BUFFER CLEAR)?
	CAIN B,"X"-100		;CLEAR BUFFER?
	JRST DELBF		;YES
TTCNT1:	CAIN B,37		;END OF LINE?
	JRST TTEOL		;YES
	IDPB B,TTPNT		;FAIRLY ORDINARY CONTROL CHAR
	AOS TTCNT
	CAIE B,7		;BELL?
	CAIL B,175		;ALTMODE OR RUBOUT?
	JRST TTBRK		;YES
	CAIE B,"U"-100		;CONTROL U IN FCS?
	CAIN B,"Z"-100		;END OF FILE?
	JRST TTBRK1		;YES
	CAIN B,33		;ESCAPE?
	JRST TTBRK		;YES. BREAK CHARACTER
	CAIGE B,15		;VERTICAL FORMAT CONTROL?
	CAIGE B,12
	JRST TTFILL		;NON- FORMAT CONTROL - KEEP FILLING
	JRST TTBRK		;SOME FORMAT CHAR


TTEOL:	MOVEI B,15		;CARRIAGE RETURN
	IDPB B,TTPNT
	AOS TTCNT
	MOVEI B,12		;LINE FEED
	IDPB B,TTPNT
	AOS TTCNT
	JRST TTBRK		;GO BACK TO USER

TTBRK1:	PUSHJ P,CRLF		;CRLF FOR ^Z, ^U CHARS
TTBRK:	MOVE B,[POINT 7,TTBUF]	;FMT CONTROL - BREAK TO USER
	MOVEM B,TTPNT
	SETOM TTLINE		;NOW THERE IS A LINE IN MY BUFFER
	POPJ P,


TTBFIN:	MOVEI A,100
	MOVE E,TYSTAT		;GET TTY FLAGS
	PUSH P,C		;SAVE AC
	PUSHJ P,TTYST1		;SET TTY STATUS
	POP P,C			;RESTORE AC
TTBFI3:	MOVE B,[POINT 7,TTBUF]
	MOVEM B,TTPNT
	SETZM TTCNT
	SETZM TTLINE
	POPJ P,

DELBF:	PUSHJ P,TTBFIN	;REINIT BUFFER
	HRROI A,[ASCIZ /__
/]
CPSOUT:	PSOUT
	JRST TTFILL		;AND START OVER

DELCH:	SKIPG TTCNT	;SOMETHING TO DELETE?
	JRST NOCHAR		;NO
	PUSH P,1
	MOVEI 1,"\"
	PBOUT
	LDB 1,TTPNT		;TYPE BACK CHAR TO BE DELETED
	PBOUT
	POP P,1
	SOS TTCNT		;DECREMENT COUNT
	MOVE B,TTPNT		;AND POINTER
	CAML B,[XWD 350700,0]
	JRST WDBACK		;HAVE TO BACK UP A WORD
	ADD B,[XWD 70000,0]
	JRST .+2
WDBACK:	SUB B,[XWD 340000,1]	;BACK UP A WORD
	MOVEM B,TTPNT
	JRST TTFILL		;AND KEEP FILLING BUFFER

NOCHAR:	PUSH P,1
	MOVEI 1,7		;BELL
	PBOUT			;RING IT
	POP P,1
	JRST TTFILL

CRLF:	PUSH P,A		;TYPE OUT A CRLF, SAVE A
	HRROI A,CRLFM
	PSOUT
	POP P,A
	POPJ P,0		;AND RETURN

CRLFM:	ASCIZ /
/

;SET DEVICE STATUS FOR TTY

TTYSTS:	MOVE E,FLAGWD(BB)
	MOVE A,JFNTAB(BB)
TTYST1:	RFMOD			;READ TERMINAL MODE
	TRZ B,17B23!3B25!3B29	;CLEAR WAKEUP, ECHO, MODE
	TRNN E,1B28		;SUPPRESS ECHO REQUESTED BY USER?
	TRO B,2B25		;NO. ALLOW ECHOING
	TRO B,14B23!3B29	;CONTROLS, ASCII MODE WITH NO OUTPUT XLATION
	SFMOD			;SET THIS MODE WORD
TTYST2:	TRNE E,1B27		;USER WANT ALT $ SUPPRESSED?
	JRST ECHO1		;YES. GO GET DIFFERENT BITS
	MOVE B,FCOC2		;GET USUAL CHAR OUTPUT WORDS.
	TLNE PF,L.INDF		;USER WANT ^L INDICATED?
	TRC B,3B25		;YES. CHANGE BITS FOR ^L FROM 2 TO 1
	MOVE C,FCOC3		;BOTH CONTROL WORDS
	TRNE E,1B29		;FCS MODE?
	TLZ C,(3B7)		;YES. CLOBBER ECHOING OF ^U GRAPHIC.
	SFCOC			;SET CONTROL OUTPUT MODES
	POPJ P,0		;RETURN FROM TTYSTS/TTYST2

ECHO1:	MOVE B,SELFEC		;ECHO CONTROLS AS SELF
	MOVE C,B		;ALL OF THEM
	SFCOC			;TO MONITOR
	POPJ P,0		;RETURN

;ECHO BYTES FOR CONTROL CHARACTERS:
; 00 MEANS IGNORE, DISCARD.
; 01 MEANS INDICATE BY ^X
; 10 MEANS SEND AND ACCT (SIM IF NECESSARY ONLY)
; 11 MEANS SIMULATE AND ACCT

;		 @,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q
FCOC2:	BYTE (2) 0,0,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1
;		 R,S,T,U,V,W,X,Y,Z,[ \ ] ^ _
FCOC3:	BYTE (2) 1,1,1,1,1,1,1,1,1,3,1,1,1,2
SELFEC:	BYTE (2) 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2




DDTOUT:	MOVE D,CAC		;ADDRESS OF STRING TO TYPE OUT
	TLOA D,-1		;MAKE STRING POINTER, SKIP TO OUTPUT
TTCL3:	HRRO D,FORTY
	TRNN D,-20		;IN THE USERS AC'S?
	HRRI D,ACS(D)		;YES. MOVE POINTER
	MOVEI A,101		;JFN FOR "TTY"
	HRLI D,440700		;PARSE THE STRING INTO BYTES
	ILDB B,D		;GET A BYTE
	JUMPE B,MRETN		;QUIT ON FIRST NULL
	PUSHJ P,TTYBOU		;OUTPUT, CHECKING ^O, INDICATE ^L
	JRST .-3		;LOOP TILL END OF STRING

TTCL11:	MOVEI A,100	;CLEAR INPUT BUFFER
	CFIBF
	PUSHJ P,TTBFIN		;AND CLEAR MY BUFFER
	JRST MRETN

TTCL12:	MOVEI A,101	;CLEAR OUTPUT BUFFER
	CFOBF
	JRST MRETN

TTCL13:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
	MOVEI A,100		;SKIP IF CHAR AVAIL FOR INPUT
	SKIPG TTCNT		; ANY CHAR IN MY BUFFER?
	SIBE
	JRST MRETN2		;YES. SKIP RETURN.
	JRST SLOWRT		;NO. SLOW RETURN.


TTCL14:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
	SKIPL TTLINE		;DO I HAVE A LINE?
	PUSHJ P,TTFILL		;NO, TRY TO GET ONE
	SKIPE TTLINE		;NOW DO I HAVE ONE?
	JRST MRETN2		;YES, SUCCESS, SKIP RETURN
SLOWRT:	MOVEI A,^D100		;IN CASE OF DUMB SKPINC/JRST .-1
;	DISMS			; SLOW IT DOWN A LITTLE
;;;ABOVE TAKEN OUT AGAIN CAUSE OF DEC DDT TTCALL DURING WORD SRCH.
	JRST MRETN

TTCL6:	PUSHJ P,TBOUND
	UMOVE B,0(C)
	SETZ C,
	CAIL B,0		;CONTROL TTY?
	JRST TT6NO		;NO, RETURN A ZERO
 	PUSH P,A		;SAVE JFN
	DVCHR			;GET THE TRUE POOP ON TTY
	HRLI C,0		;CLEAR LEFT HALF. JUST LINE NUMBER
	POP P,A			;USE JFN NOT TTY NUMBER (REDIRECT)
	RFMOD			;GET TERMINAL CHARACTERISTICS
	TRNE B,3B33		;SHUFFLE BETWEEN TENEX AND 1050 BITS
	TLO C,(1B5)		;HALF DUPLEX BIT
	TLNE B,(1B2)		;TABS?
	TLO C,(1B14)		;TABS.
	TLNE B,(1B3)		;LOWER CASE?
	TLO C,(1B13)		;LOWER CASE.
	TRNE E,1B28		;NO ECHO IN INIT FLAGS?
	TLO C,(1B15)		;YES.
TT6NO:	UMOVEM C,@FORTY		;RETURN THE ANSWER TO USER
	JRST MRETN		;END OF UUO

TTCL7:	PUSHJ P,TBOUND		;CHECK ARGUMENT
	RFMOD			;GET CHARACTERISTICS OF TERMINAL
	UMOVE C,0(C)		;GET USER'S DESIRED BITS
	TLNE C,(1B13)		;WANT LOWER CASE?
	TLOA B,(1B3)		;YES.
	TLZ B,(1B3)		;NO.
	TLNE C,(1B14)		;WANT TABS?
	TLOA B,(1B2)		;YES
	TLZ B,(1B2)		;NO
	TRO B,2B25		;ASSUME ECHO
	TRZ E,1B28		;CLEAR NO-ECHO IN INIT
;*** THIS AIN'T RIGHT!!!! ***
	TLNE C,(1B15)		;WANT ECHO?
	TRO E,1B28		;YES. TURN IT ON.
	MOVEM E,TYSTAT		;SAVE THAT DECISION
	TRNE E,1B28		;ECHO DECIDED ON?
	TRZ B,3B25		;NO. CLEAR IN TENEX MODE.
	SFMOD			;GIVE TO MONITOR
	JRST MRETN		;AND RETURN FROM TTCALL 7

TTCL10:	PUSHJ P,TTBFIN
	JRST TTEOL

;SQUEZE AND UNSQZE ARE REALLY STRING-TO-DIRECTORY AND
;DIRECTORY-TO-STRING

;IT IS ASSUMED THAT SQUEZE IS USED ONLY WHERE A CUSP HAS
;ACCUMULATED A WORD OF SIXBIT FOR A PROJ-PROG DESIGNATOR
;SQUEZE CONVERTS IT TO A DIRECTORY NUMBER WHICH CAN BE USED
;IN LOOKUP AND ENTER
;THE WORD OF SIXBIT CAN BE EITHER: (1) SIX CHARACTERS WHICH
;SHOULD UNIQUELY IDENTIFY A DIRECTORY, OR (2) SIX DIGITS SPECIFYING
;A DIRECTORY NUMBER WHICH WILL BE CONVERTED TO BINARY AND RETURNED

SQUEZE:	MOVE B,CAC		;SIXBIT TO MAKE INTO DIRECTORY NUMBER
	MOVE A,[POINT 7,STRNG1,-1]
	SETZB F,D		;ACCUMULATE SUM IN F, FLAG CHARS IN D
	MOVEI E,6		;COUNT SIX CHARS
SQZ2:	SETZ C,
	ROTC B,6		;GET CHAR
	JUMPE C,SQZ1		;IGNORE BLANKS
	ADDI C,40		;MAKE IT ASCII FROM SIXBIT
	IDPB C,A		;PUT IN STRING FOR STDIR
	CAIL C,"0"		;DIGIT?
	CAILE C,"9"
	AOJA D,SQZ1		;NO, FLAG NON-DIGIT
	LSH F,3			;ACCUMULATE OCTAL SUM
	ADDI F,-20(C)
SQZ1:	SOJG E,SQZ2
	JUMPE D,[ MOVE A,F	;ONLY DIGITS ENCOUNTERED, RETURN SUM
		  JRST STOTAC]
	SETO A,
	HRROI B,STRNG1
	STDIR			;GET DIRECTORY NUMBER FROM STRING
	  JFCL			;AMBIGUOUS OR
	  MOVEI A,0		;NO SUCH MATCH. GIVE BACK A ZERO
	JRST STOTAC		;RETURN ANSWER IN AC

;UNSQZE CONVERTS A DIRECTORY NUMBER TO A WORD OF SIXBIT CONTAINING
;THE FIRST SIX CHARACTERS OF THE DIRECTORY NAME

UNSQZE:	HRRZ B,CAC		;GET DIRECTORY NUMBER
	MOVEI C,0		;WHERE SIXBIT WILL GO
	HRROI A,STRNG1		;TEMP LOCATION FOR THE 7-BIT STRING
	DIRST			;GET THE DIRECTORY NAME STRING
	 JRST UNSQ1		;WRONG NUMBER, RETURN 0
	MOVE A,[POINT 7,STRNG1,-1]
	MOVE B,[POINT 6,C,-1]	;ACCUMULATE SIXBIT IN AC3
	MOVEI F,6		;ONLY SIX CHARS
UNSQ2:	ILDB D,A
	JUMPE D,UNSQ1		;NULL MARKS END OF STRING
	SUBI D,40		;ASCII BACK TO SIXBIT
	IDPB D,B
	SOJG F,UNSQ2
UNSQ1:	MOVE A,C		;ANSWER
	JRST STOTAC		;RETURN IT TO USER

GETLIN:	HRROI A,[ASCIZ /TTY/]
	STDEV			;DEVICE CODE IN 2
	PUSHJ P,ERROR
	MOVE A,[POINT 7,D]	;STRING INTO D
	DEVST
	PUSHJ P,ERROR
	MOVE A,[POINT 6,B]	;CONVERT TO SIXBIT IN B
	SETZ B,

GETLN1:	SETZ C,
	LSHC C,7		;PICK OFF NEXT 7 BITS
	JUMPE C,GETLN2		;UNTIL DONE
	SUBI C,40		;CONVERT TO SIXBIT
	IDPB C,A
	JRST GETLN1

GETLN2:	MOVE A,B		;ANSWER FROM B
	JRST STOTAC		;TO USER'S AC

SUBTTL TRAP HANDLING

;APR TRAPS ENABLE
; USER CALL IS
;	MOVEI AC,BITS
;	CALLI AC,16
;
;WHERE BITS ARE 1B18 FOR REPEATED TRAPS (EXCEPT CLK)
;	1B19 FOR PDLOV, 1B22 FOR ILL MEM REF, 1B23 FOR NXM
;	1B26 FOR CLOCK (NOT YET SUPPORTED), 1B29 FOR FOV, 1B32 FOR AROV

APRENB:	MOVSI A,400000	;THIS FORK
	MOVE B,[XWD LEVTAB,CHNTAB]
	SIR			;NEW PSEUDOINTERRUPT CHANNELS
	MOVEM CAC,USRENB		;SAVE FOR LATER REFERENCE
	LSH CAC,1			;MATCH UP WITH ENABLE FLAGS
	ANDI CAC,220		;FOR OV AND FOV
	MOVEM CAC,CNIWRD		;AND REMEMBER FOR APR CONI
	PUSHJ P,SETPSI	;SET UP PSI AS INDICATED BY USRENB
	EIR			;ENABLE INTERRUPT SYSTEM
	JRST MRETN

;IO ERROR - THIS DOES NOT GET PASSED TO THE USER VIA CNIWRD
; RATHER IT CAUSES IO ERROR BITS TO BE SET IN THE FILE STATUS WORD

IOERR:	SKIPL INPAT
	JRST IOERQQ		;NOT MY ERROR. GIVE TYPEOUT
	MOVEM 7,IAC+7		;SAVE SOME AC'S
	MOVEI 7,IAC
	BLT 7,IAC+6
	MOVEI 7,1B19+1B20	;PREPARE TO SET THESE BITS IN STAT WD
IOI1:	MOVE 1,BB		;EXTENSIVE CHECK TO BE SURE WE KNOW
	CAIL 1,0		;WHAT WE'RE DOING
	CAIL 1,NTABS*20		;BB SHOULD HAVE INDEX TO IO CHANNEL
	JRST IOER1		;DOESN'T, IGNORE INTERRUPT
	IDIVI 1,NTABS		;SHOULD BE POINTING TO FIRST OF BLOCK
	JUMPN 2,IOER1		;IGNORE INT IF IT ISN'T
	HRRZ 1,IAC+1		;AC1 AT TIME OF INTERRUPT
	CAME 1,JFNTAB(BB)	;CONTAINS JFN?
	JRST IOER1		;NO, FLUSH
	IORM 7,FLAGWD(BB)	;ALL SEEMS IN ORDER, SET ERROR BITS
IOER1:	MOVSI 7,IAC		;RESTORE AC'S
	BLT 7,7
	DEBRK			;AND RESUME IO

IOERQQ:	MOVEM 7,IAC+7
	MOVEI 7,IAC
	BLT 7,IAC+6
	HRROI A,[ASCIZ \
% I/O ERROR NOT FROM PA1050, AT USER LOC \]
	PSOUT
	MOVEI A,101
	HRRZ B,RETSAV
	MOVEI C,10
	NOUT
	  JFCL
	HRROI A,CRLFM
	PSOUT
	JRST IOER1

CTOINT:	MOVEM A,IAC+A		;STASH AC A ON A CONTROL O INT
	MOVEM B,IAC+B		;ALSO AC B
	MOVEI A,101		;PRIMARY FILE
	MOVSI B,.S		;SIGN OF TYSTAT
	XORB B,TYSTAT		;COMPLEMENT IT.
	SKIPGE B		;ON NOW?
	CFOBF			;YES. CLEAR TTY OUTPUT BUFFER
	HRROI A,[ASCIZ /^O
/]
	PSOUT			;TYPE OUT THE ECHO FOR THE ^O
	MOVE A,RETSAV		;SEE WHERE THE BREAK WAS FROM
	TLNE A,(1B5)		;FROM USER MODE?
	JRST ABDBRK		;YES. NOT IN A JSYS.
	MOVE B,-1(A)		;GET THE INSTRUCTION
	CAME B,CPSOUT		;PRIMARY I/O?
	CAMN B,CPBOUT		; ..
	JRST CTOIN1		;YES.
	CAME B,CBOUT		;NO. DIRECTED I/O?
	CAMN B,CSOUT		; ..
	SKIPA
	JRST ABDBRK		;NO. JUST DEBREAK
	MOVE B,IAC+A		;YES. GET THE JFN.
	CAIE B,100		;PRIMARY FILE?
	CAIN B,101		; ..
	JRST CTOIN1		;YES
	JRST ABDBRK		;NO. RETURN TO IT
CTOIN1:	TLO A,(1B5)		;FORCE TTY JSYS TO QUIT.
	MOVEM A,RETSAV		;PUT BACK FOR DEBRK
ABDBRK:	MOVE A,IAC+A		;GET THE AC'S BACK
	MOVE B,IAC+B		; ..
	DEBRK			;AND DISMISS THE PSI

NXPINT:	MOVEM A,IAC+A
	MOVEM B,IAC+B		;PRESERVE TWO AC'S
	MOVEI A,.S		;THIS FORK
	GTRPW			;GET THE TRAP STATUS WORD
	SKIPN INPAT		;FROM INSIDE PAT?
	TLNE A,1		;OR FROM MONITOR MAP (SPURIOUS)?
	JRST ABDBRK		;YES. QUIT. PROCESS CONTINUES.
	HRRZS A			;ADDRESS REFERRED TO
	TRNE A,776000		;REFERENCE TO PAGE 0 OR 1 IS OK.
	CAMG A,JBREL		;ABOVE USER'S LEGIT AREA?
	JRST ABDBRK		;NO. FILLING IN SPACE. OK.
	TRNN A,.S		;ABOVE JOBREL. IN HIGH SEGMENT?
	JRST NXPBAD		;NO. BAD.
	HRRZ B,JBHRL		;SPACE ALLOWED IN HIGH SEG
	CAMG A,B		;OUT OF BOUNDS IN HIGH SEG?
	JRST ABDBRK		;NO. SCRATCH PAGE IN HIGH SEG.
				;***SHOULD CHECK UWP BIT***
NXPBAD:	MOVEM A,IAC+C		;STASH ADDRESS FOR A MOMENT
	HRRZ B,A		;PAGE REFERENCED BY ACCIDENT
	LSH B,-11		;PAGE NUMBER FROM ADDRESS
	HRLI B,.S		;IN THIS FORK
	SETO A,			;TO OBLIVION
	PMAP			;GET RID OF THE PAGE
	MOVE A,IAC+C		;GET THE ADDRESS BACK
	MOVE B,USRENB		;DID USER ASK FOR THESE ERRORS?
	TRNE B,1B22!1B23	;BY ILL MEM REF OR NXM?
	JRST MINT1		;YES. GO SNEAK INTO MEMINT CODE.
	MOVEI B,NXPTRP		;PC TO GET THIS TRAP
	EXCH B,RETSAV		;PUT IT IN DE-BREAK PC
	HRL B,A			;SAVE ADDRESS ATTEMPTED TOO
	MOVEM B,MONUPC		;***WHERE SHOULD THIS REALLY GO?
	JRST ABDBRK		;AND DEBREAK, STOPPING USER.

;HERE ON NON-PSI LEVEL AFTER STOPPING USER.
NXPTRP:	MOVEM 17,ACS+17		;STASH USER'S AC'S
	MOVEI 17,ACS
	BLT 17,ACS+16		; ..
	MOVE P,PATSTK		;GET THE STACK AC TO PDL
	MOVE PF,PFLAGS		;AND THE GENERAL FLAGS
	TMSG <$? ILLEGAL REFERENCE TO ADDRESS >
	PUSHJ P,CLRPSI		;PSI SYSTEM NOT WANTED DURING HALTF
	MOVEI A,101		;TO TTY OUTPUT
	HLRZ B,MONUPC		;ADDRESS ATTEMPTED
	MOVEI C,10		;OCTAL RADIX
	NOUT			;TYPE OUT THE ADDRESS
	  JFCL
ATUSER:	HRROI A,[ASCIZ / AT USER /]
	PSOUT
	MOVEI A,101		;ADDRESS THE TTY AGAIN
	HRRZ B,MONUPC		;GET THE PC AT TIME OF ERROR
	TLO B,(1B5)		;USER MODE BIT
				; *** LOST OLD ARITH FLAGS. FOO.***
	MOVEM B,PDL		;IN CASE HE SAYS CONTINUE.
	HRRZS B			;CLEAR FOR NOUT
	MOVEI C,10		;RESET OCTAL IN CASE OF ATUSER ENTRY
	NOUT			;TYPE IT OUT
	  JFCL			;"CAN'T FAIL"
	MOVEI A,EOL		;CRLF
	PBOUT			;TYPE CRLF
NXPHLT:	PUSHJ P,CLRPSI	;CLEAR COMPATIBILITY VECTOR AND PSI SYSTEM
	SETZM INPAT		;NO STACK AHEAD
	MOVSI 17,ACS		;RESTORE USER AC'S
	BLT 17,17		; ..
	HALTF			;HOW TO STOP AND ALLOW CONTINUE, MAKE
				; ALL THIS MORE GENERAL!!!
	MOVE P,PATSTK		;HE TYPED CONTINUE. CAN'T, BUT NEED
	MOVE PF,PFLAGS		;STACK AND FLAGS TO SAY SO.
	PUSHJ P,SETCV		;RESET EXEC CONTROL
	PUSHJ P,SETPSI	; ..
	TMSG <$? CAN'T CONTINUE$>
	JRST NXPHLT

NOCTRO:	MOVSI E,.S		;CLEAR SIGN OF TYSTAT
	ANDCAB E,TYSTAT		;CLEAR IN AC AND CORE
	POPJ P,0		;THATS ALL

OVINT:	SKIPE INPAT
	JRST ERRINT
	SETOM INPAT		;TURN ON PAT UUO SIMULATOR
	MOVEM A,IAC+1
	MOVE A,RETSAV
	TLO A,(1B0)		;MARK OVERFLOW IN SAVED FLAGS
	UMOVEM A,JOBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,10		;OVERFLOW
	JRST INT

FOVINT:	SKIPE INPAT
	JRST ERRINT
	SETOM INPAT
	MOVEM A,IAC+1
	MOVE A,RETSAV
	TLO A,(1B0+1B3)		;MARK OV AND FOV IN FLAGS
	UMOVEM A,JOBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,100		;FLOATING OVERFLOW
	JRST INT

PDLINT:	SKIPE INPAT
	JRST ERRINT
	SETOM INPAT
	MOVEM A,IAC+1
	MOVE A,RETSAV
	UMOVEM A,JOBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,200000		;PDL OVERLFOW
	JRST INT

MINT1:	MOVE A,IAC+A		;HERE FROM NXPBAD. FAKE MEMINT
	MOVE B,IAC+B		;BY RESETTING AC'S AND THEN
	JRST MINT2		; JUMPING INTO MEM INT ROUTINE

MEMINT:	SKIPE INPAT
	JRST ERRINT
MINT2:	SETOM INPAT
	MOVEM A,IAC+1
	MOVEM B,IAC+2
	MOVEI A,400000
	GTRPW
	MOVE B,IAC+2
	MOVE A,RETSAV
	UMOVEM A,JOBTPC		;SETUP RETURN PC
	MOVE A,CNIWRD
	TRO A,20000		;MEM PRO VIOLATION
INT:	UMOVEM A,JOBCNI	;SETUP APR CONI
	UMOVE A,JOBAPR
	HRRM A,RETSAV		;RETURN TO USER INTERRUPT ROUTINE
	MOVE A,IAC+1
	SETZM INPAT		;TURN OFF PAT UUO SIMULATOR
	DEBRK
	HALTF
INSINT:			;HERE ON ILLEGAL INSTRUCTION TRAP
	MOVEM A,IAC+A		;STASH USER AC
	MOVEI A,INSTRP		;DIDDLE THE DEBREAK
	EXCH A,RETSAV		;TO COME BACK AT NON-PSI LEVEL
	MOVEM A,MONUPC		;STASH THE INT LOCATION
	MOVE A,IAC+A		;RESTORE THE AC
	DEBRK			;CLEAR OFF THE PSI CHANNEL
INSTRP:	MOVEM 17,ACS+17		;STASH ALL AC'S
	MOVEI 17,ACS		; ..
	BLT 17,ACS+16		; ..
	MOVE P,PATSTK		;GET A PDL STACK
	MOVE PF,PFLAGS		;AND SYSTEM FLAGS
	SETOM INPAT		;FLAG PAT STACK READY, ETC.
	TMSG <$? ILLEGAL INSTRUCTION >
	MOVEI A,PROJFN		;TO THE TTY
	MOVE D,MONUPC		;WHERE IT CAME FROM
	UMOVE B,-1(D)		;WHERE INSTRUCTION SHOULD BE
	MOVEM D,MONUPC		;RESTORE MONUPC, CLOBBERED BY UMOVE
	MOVEI C,^D8		;LIST IT IN OCTAL
	NOUT			;TYPE IT AS A NUMBER
	  JFCL
	TLC B,(<JRST 4,0>)	;IS IT A HALT?
	TLNE B,777400		; ..
	JRST INST1		;NO.
	TMSG < (HALT)>		;YES. SAY SO.
INST1:	JRST ATUSER		;AND THE PC, THEN STOP.

	SUBTTL MORE UUO SIMULATIONS

REMAP:	MOVE D,CAC		;USER ARGUMENT IN WORDS
	TRO D,1777		;ROUND UP TO NEXT 10/50 BLOCK BOUNDARY
	CAIL D,400000		;BELOW MAX?
	JRST MRETN		;NO, RETURN BAD
	AOS 0(P)		;SET RETURN GOOD
	HRRZM D,JBREL		;CLEAR MEMORY OF HIGH SEG
	SETZM JBHRL
	XCTUU [HRRM D,JOBREL]	;SET NEW JOBREL
	XCTUU [SETZM JOBHRL]	;FLUSH OLD HISEG SIZE
	ADDI D,1		;FIRST ADDRESS OF STUFF TO BE MOVED
	SETO 1,			;SET ABOUT CLEARING OLD HISEG
	MOVE 2,[XWD 400000,400]	;THIS FORK,,PAGE 400
REMAP3:	PMAP			;MAP INTO OBLIVION
	MOVEI 3,0(2)
	CAIGE 3,PATPAG-1	;UNTIL WE REACH THIS CODE
	AOJA 2,REMAP3
	LDB 1,[POINT 9,D,26]	;NUMBER OF FIRST PAGE TO MOVE
	HRLI 1,400000		;XWD FORK,PN FOR RPACS
REMAP1:	TRNE 1,400		;REACHED TOP OF LOW SEG?
	JRST REMAP2		;YES
	RPACS			;CHECK THIS PAGE
	TLNE 2,(1B5)		;DOES IT EXIST?
	TLNN 2,(1B2+1B3+1B4)	;YES, IS IT ACCESSIBLE?
	JRST .+2		;NO, OUTSIDE LOW SEGMENT
	AOJA 1,REMAP1		;YES, KEEP CHECKING
REMAP2:	MOVEI 1,0(1)		;TOP OF REMAP BLOCK FOUND, GET PN
	MOVEM 1,LOTOP		;PAGE BEYOND LOW SEGMENT
	LSH 1,^D9		;MAKE INTO ADDRESS
	CAIG 1,0(D)		;OF NON-0 SIZE?
	JRST MRETN		;NO, NOTHING TO DO
	MOVSI 2,0(D)		;XWD FROM,TO FOR BLT
	HRRI 2,400000
	SUBI 1,(D)		;SIZE OF HISEG
	ADDI 1,377777		;TOP LOCATION
	CAIL 1,PATLOC		;DON'T STEP ON SELF
	JRST MRETN		;NOT POSSIBLE TO DO REMAP.
	HRRZM 1,JBHRL
	XCTUU [HRRM 1,JOBHRL]	;NOTE IT
	BLT 2,0(1)
	SETO 1,			;NOW FLUSH THE BLOCK FROM THE LOW SEG
	LDB 2,[POINT 9,D,26]
	HRLI 2,400000
	MOVE D,LOTOP		;PAGE BEYOND LOW SEGMENT
REMAP4:	PMAP
	CAILE D,(2)
	AOJA 2,REMAP4
	JRST MRETN

;THE FOLLOWING ROUTINES ALL HAVE CONVERSIONS TO AND FROM SECONDS

RUNTIM:	JUMPE CAC,RUNTM9	;JOB ZERO MEANS SELF
	MOVE A,[SIXBIT /TICKPS/]
	SYSGT			;GET TICKS PER SECOND
	MOVE B,A
	HRLZ A,CAC		;JOB NUMBER TO LH OF A
	HRRI A,1		;TABLE 1, RUNTIME INDEXED BY JOB
	GETAB
	 MOVEI A,0		;ERROR ON LOOK GIVES ZERO RESULT
	JUMPGE A,.+2		;POSITIVE NO IS OK
	 MOVEI A,0		;NEGATIVE NUMBER SAYS NO SUCH JOB
RUNTM0:	MOVEI E,^D1000		;MOST COMMON UNITS
	CAMN B,E		;ALREADY CORRECT UNITS?
	JRST RUNTM8		;YES
RUNTM1:	CAMGE B,E	;IS THE VALUE IN SMALLER UNITS THAN FINAL ANS?
	JRST RUNTM3		;NO
	IDIV B,E		;DIVIDE THE LARGER FUDGE FACTOR BY THE SMALLER
RUNTM2:	IDIV A,B		;NOW DIVIDE BY THE FF
RUNTM8:	JRST STOTAC		;RETURN TO USER'S AC

RUNTM3:	IMUL A,E		;THIS RESULT SHOULD FIT
	JRST RUNTM2

RUNTM9:	MOVNI 1,5
	RUNTM			;GET RUN TIME FOR THIS JOB
	JRST RUNTM0

TIMER:	MOVEI E,^D60		;CLOCK TICKS (60THS) SINCE MIDNIGHT
	SETO B,			;TO REQUEST CURRENT TIME
	SETZ D,			;NORMAL FLAGS
	ODCNV
	MOVEI A,0(D)		;SECONDS SINCE MIDNIGHT
	MOVEI B,1		;UNITS (SECONDS)
	JRST RUNTM1		;GO CONVERT TO PROPER UNITS AND RETURN

SLEEP:	MOVE A,CAC		;NUMBER OF SECONDS TO SLEEP
	ANDI A,7777		;MOD 2^12
	IMULI A,^D1000
	IDIVI A,^D60		;CONVERT TO MS.
	DISMS			;DISMISS FOR APPROPRIATE TIME
	JRST MRETN

PJOB:	SKIPA A,MYJOBN		;GET NUMBER SET AT ONCE TIME
GETPPN:	HRRZ A,MYPPN		;GET DIRECTORY NUMBER
	JRST STOTAC

MSTIME:	TIME			;GET UPTIME IN MS
	SUB 1,ITIME1		;MINUS TIME AT START
	ADD 1,ITIME2		;PLUS TOD AT START = TOD IN MSEC
	IDIV 1,MSPDAY		;IN CASE OVER A DAY
	MOVE A,B		;ANSWER TO RETURN
	JRST STOTAC

MSPDAY:	EXP ^D<24*60*60*1000>	;MILLISECONDS PER DAY

;SOME DEVICE TYPE THINGS

GETCHR:
DEVCHR:	MOVE D,CAC		;SIXBIT DEVICE NAME
	JUMPL	D,DEVCH1	;IF IT IS NEG. MUST BE SIXBIT
	CAIGE	D,20		;IS IT A CHANNEL
	PUSHJ	P,GETDEV	;YES GO GET ASSOCIATED DEVICE
DEVCH1:	PUSHJ P,DVCHR1		;CALL COMMON ROUTINE
	  JFCL			;NONEXISTENT DEVICE
	JRST STOTAC		;RETURN AC A TO USER

GETDEV:	SETZM	A		;SET RETURN INCASE NO DEVICE
	IMULI	D,NTABS		;GET TABLE OFFSET
	SKIPE	D		;CHANNEL 0 NOT ALLOWED
	SKIPN	D,DEVNAM(D)	;GET DEVICE
	AOS	0(P)		;IF NO DEVICE SKIP RETURN
	POPJ	P,		;RETURN



DEVSIZ:	UMOVE D,1(CAC)		;GET THE SIXBIT ARG DEVICE NAME
	PUSHJ P,DVCHR1		;GET ITS CHARACTERISTICS
	  JRST RETM11		;NO SUCH DEV. RETURN A MINUS 1
	HLRZ B,B		;GET THE TENEX DEVICE TYPE
	ANDI B,777		; ..
	UMOVE D,0(CAC)		;AND THE MODE WORD
	ANDI D,17		;JUST THE MODE FIELD
	MOVNI A,2		;ANSWER IF ILLEGAL
	MOVEI E,1		;BIT FOR MODE
	LSH E,(D)		;TO BIT POSITION
	TDNN E,DEVTBL(B)	;LEGAL?
	JRST STOTC1		;NO. RETURN THE -2
	CAIL D,15		;OK. IS MODE DUMP?
	JRST RETZR1		;YES. SKIP RETURN A ZERO
	HRRZ A,DEVTB2(B)	;NO. BUFFERED. GET BUFFER SIZE
	ADD A,[2,,3]		;LH IS TWO BUFFERS, RH IS SIZE WITH HDR
	JRST STOTC1		;RETURN THAT AS ANSWER, SKIP.

DEVTYP:	MOVE D,CAC		;GET ARGUMENT IN CASE SIXBIT
	TLNE CAC,-1		;DEVICE NAME?
	JRST DVTYP1		;YES.
	CAILE CAC,17		;LEGAL CHANNEL NUMBER?
	JRST MRETN		;NO
	MOVEI A,(CAC)		;YES
	IMULI A,NTABS		;GET TABLE OFFSET
	SKIPE D,DEVNAM(A)	;A DEVICE THERE?
DVTYP1:	PUSHJ P,DVCHR1		;YES. GET THE BITS FROM TENEX DVCHR TO B
	  JRST RETZR1		;ERROR. SKIP RETURN WITH A ZERO
	HLRZ D,B		;GET THE TENEX INDEX
	ANDI D,777		; ..
	MOVE A,DVTYPT(D)	;GET FIXED BITS
	HLRZ C,C		;GET JOB NUMBER
	CAIN C,-1		;FREE?
	MOVEI C,0		;YES
	DPB C,[POINT 9,A,26]	;PUT IN ANSWER
	TLNE B,(1B5)		;AVAILABLE?
	TLO A,(1B12)		;YES
	JRST STOTC1		;SKIP RETURN WITH ANSWER

;COMMON ROUTINE FOR DEVCHR, DEVSIZ

DVCHR1:	PUSH P,D
	GJINF
	HRLI D,600012
	EXCH D,0(P)
	CAMN D,[SIXBIT /SYS/]	;DEVICE SYS?
	MOVSI D,'DSK'
	CAMN D,[SIXBIT /TTY/]
	JRST [	MOVSI D,(1B6)	;CONTROLLING TERMINAL BITS
		JRST DEVC3]	; ..
	MOVEI E,BUFFER		;PLACE TO PUT ASCIZ STRING OF DEVICE
	PUSHJ P,SIXTO7
	MOVEI C,0
	MOVNI B,1		;MINUS ONE FLAG IF NOT FOUND BY DVCHR
	HRROI A,BUFFER		;ARGUMENT FOR STRING TO DEVICE
	STDEV			;GET THE DEVICE TYPE
	  JRST DEVC2		;NONE
	MOVE A,B		;TO RIGHT AC
	DVCHR			;GET THE BITS
	HLRZ D,B
	ANDI D,777		;DEVICE NUMBER
	MOVE D,DEVTBL(D)	;10/50 DEVICE CHARACTERISTICS
	TLNE B,(1B5)		;IS THE THING AVAILABLE TO THIS JOB?
	TLO D,40		;YES
	TLNE B,(1B6)		;ASSIGNED?
	TRO D,1B18		;YES. SET ASSCON IN 10/50 MODE WORD
	CAMN A,0(P)		;WAS IT THE JOB'S TTY?
DEVC3:	TDO D,CONTTY		;YES. PUT IN EXTRA BITS
DEVC1:	AOS -1(P)		;SKIP RETURN
DEVC2:	MOVE A,D		;CHARACTERISTICS IN A FOR
	POP P,(P)		;DISCARD STACKED TTY DESIGNATOR
	POPJ P,0		;CALLER TO RETURN TO USER

;10/50 DEVICE CHARACTERISTICS

CONTTY:	XWD 030053,400003	;BITS FOR A CONTROLLING TTY
DEVTBL:	XWD 201047,154403	;DSK A,AL,I,B,IB,DR,D
	XWD 0,0			;DRM
	XWD 000023,154403	;MTA DITTO DSK
	XWD 001107,154403	;DTA DITTO DSK
	XWD 000202,014403	;PTR A,AL,I,B,IB
	XWD 000401,014403	;PTP DITTO PTR
	XWD 002001,020000	;DSP ID ONLY
	XWD 040001,000403	;LPT A,AL,I
	XWD 100002,010403	;CDR A,AL,I,B
	XWD 100001,014003	;CDP A,AL,B,IB
DEVTTY:	XWD 000053,000403	;TTY A,AL,I
	XWD 000053,000003	;TTP
	XWD 000053,000003	;TTR
	XWD 000043,014403	;NIL
	XWD 000047,014403	;NET
	XWD 000001,000400	;PLT

;10/50 STANDARD BUFFER SIZE FOR EACH DEVICE

DEVTB2:	EXP 200,0,200,177,40,40,0,31,33,32,20,20,20,200,100,43,20

;TABLE OF BITS FOR DEVTYP CALLI

DVTYPT:	400003,,0	;DSK
	0		;DRM
	7,,2		;MTA
	400003,,1	;DTA
	6,,4		;PTR
	5,,5		;PTP
	0		;DSP
	5,,7		;LPT
	2,,10		;CDR
	1,,11		;CDP
	13,,3		;TTY
	13,,3		;TTP
	13,,3		;TTR
	3,,0		;NIL
	0		;NET
	1,,13		;PLT

UTPCLR:	PUSHJ P,SETUPG
	JRST MRETN
	CAIE AA,3		;IS IT DECTAPE?
	JRST MRETN		;NO, UTPCLR IS A NOP

	INIDR			;YES, INITIALIZE THE DIRECTORY
	PUSHJ P,ERROR
	JRST MRETN

DATE:	SETO B,			;TO REQUEST CURRENT TAD
	PUSHJ P,NODATE
	ANDI D,7777		;12 BITS WORTH ONLY
	MOVE A,D		;DATE TO A FOR RETURN TO USER
	JRST STOTAC		; ..

NODATE:	SETZ D,			;NORMAL FLAGS
	ODCNV			;GET YEAR, MONTH, DAY, ETC.
	HRRZ A,D		;SAVE SECONDS SINCE MIDNIGHT
	HLRZ D,B		;YEAR
	SUBI D,^D1964		;CONVERT TO 10/50 FORMAT, I.E. ...
	IMULI D,^D12		;(YEAR-1964)*12 
	ADDI D,0(B)
	IMULI D,^D31		;((YEAR-1964)*12+(MONTH-1))*31
	HLRZ C,C
	ADDI D,0(C)		; ... +DAY-1
	ANDI D,7777		;12 BITS ONLY
	MOVEI 	B,(A)		;SECS SINCE MIDNIGHT
	IDIVI 	B,^D60		;MINUTES
	ANDI B,3777		;ONLY 11 BITS WORTH
	LSH B,^D12
	IOR D,B
	POPJ P,

SUBTTL UUOS FOR FILE OPERATIONS

;FILE STUFF

GSTATS:	PUSHJ P,SETUP
	MOVE C,FLAGWD(BB)
	MOVE B,DEVTBL(AA)	;DEVICE TYPE BITS
	TLNE B,MTADEV		;MAGTAPE?
	JRST GST2		;YES
	HRRZ A,C
	POPJ P,

;ROUTINE TO GET STATUS FOR MAGTAPE.
;RETURNS WITH GDSTS DATA IN B, UPDATED 10/50 STATUS IN A.
;IOBKTL ISN'T SET, DUE TO THE COMPLEXITY OF 1B23 OF TENEX GDSTS.
; THE CALLER IS LEFT TO DO THAT

GST2:	MOVE A,JFNTAB(BB)	;ARGUMENT TO GDSTS
	GDSTS			;GET TENEX STATUS
	MOVE C,FLAGWD(BB)	;OLD TEN FIFTY STATUS
	TRZ C,606000		;BITS WHICH MAY NEED UPDATING
	MOVE A,B		;TENEX BITS TO A
	ANDI A,606000		;ONLY ONES TO KEEP ARE MATCHING HDW BITS
	IOR A,C			;ADD IN OLD STATUS AND IOBKTL
	HRRZS A			;JUST RIGHT-HALF
	POPJ P,0		;RETURN

UGETST:	PUSHJ P,GSTATS
	UMOVEM A,@FORTY
	JRST MRETN

USTATO:	PUSHJ P,GSTATS
	TDNE A,FORTY
	JRST MRETN2		;SKIP RETURN
	JRST MRETN		;NOSKIP RETURN

USTATZ:	PUSHJ P,GSTATS
	TDNN A,FORTY
	JRST MRETN2		;SKIP RETURN
	JRST MRETN		;NOSKIP RETURN

USETST:	PUSHJ P,SETUP
	MOVE A,JFNTAB(BB)
	HRRZ B,FORTY
	HRRM B,FLAGWD(BB)	;SAVE MODE ETC
	MOVSI A,TTYDEV
	TDNE A,DEVTBL(AA)	;TTY?
	PUSHJ P,TTYSTS		;YES
	JRST MRETN

UOPEN:	TLOA C,-1
UINIT:	TLZ C,-1
	PUSHJ P,SETUPG		;IS A DEVICE ALREADY INIT'ED?
	  JRST UINIT1		;NO
	PUSH P,C		;SAVE WHETHER OPEN OR INIT
	PUSHJ P,URELR		;CALL RELEASE FOR THIS CHANNEL
	POP P,C

UINIT1:	JUMPL C,UOPEN1		;WAS IT OPEN?
	MOVE A,(P)		;A TO POINT AT FIRST OF THREE ARGS
	AOS 0(P)
	AOS 0(P)		;P TO POINT TO R1
	MOVE C,FORTY		;MAY BE THE RESULT OF AN XCT
	SOJA A,UOPEN2

UOPEN1:	HRRZ A,FORTY		;EFFECTIVE ADR IS POINTER TO THREE ARGS
	UMOVE C,(A)
UOPEN2:	HRRZM C,FLAGWD(BB)	;TAKES CARE OF STATUS FOR NOW

	UMOVE C,2(A)
	MOVEM C,BUFHTB(BB)	;XWD OBUFH,IBUFH
	UMOVE C,1(A)		;SIXBIT NAME FROM USER
	MOVEM C,DEVNAM(BB)	;SAVE IT IN SIXBIT
	PUSHJ P,DEV67		;PUT IT IN DEVNM7
	MOVE C,DEVNAM(BB)	;GET SIXBIT BACK

;FIND OUT WHAT DEVICE REALLY IS
;CHECK FOR LEGAL MODE
;SET BUFFER SIZE AND BYTE SIZE IN C

UOPEN3:	HRROI A,DEVNM7
	MOVEI B,0
	MOVEI D,NSPDDV-1	;NUMBER OF SPECIAL DISK DEVICES
	CAMN C,SPDDVT(D)	;CHECK FOR SPECIAL DISK DEVICE
  	  JRST UOPENE		;HANDLE IF SO
	SOJGE D,.-2		;LOOP LOOKING IF NOT
	MOVSI B,12
	CAMN C,[SIXBIT /TTY/]
	JRST UOPENE
	STDEV			;GET DEVICE DESIGNATOR
	 JRST MRETN		;NO SUCH DEVICE,CHECK FOR 10/50 NAMES!!

UOPENE:	MOVEM B,DEVNUM(BB)	;SAVE DEVICE DESIGNATOR
	MOVE D,FLAGWD(BB)
	CAMN C,[SIXBIT /TTY/]	;CONTROLLING TERMINAL?
	HRRZM D,TYSTAT		;YES. UPDATE THE COPY WE'RE KEEPING
	LDB AA,PDVNUM		;GET THE TENEX DEVICE TYPE NUMBER
	MOVE C,DEVTBL(AA)	;GET LEGAL 10/50 MODE BITS
	ANDI D,17		;WHAT MODE
	MOVEI E,1
	ROT E,(D)		;PUT BIT IN 35-N
	TRNN C,(E)		;IS MODE LEGAL FOR THIS DEVICE
	 JRST MRETN		;NO	****NOT RIGHT. SHOULD BE ILLMOD***
	CAILE D,14		;BUFFERED?
	JRST UOPEN4		;NO
	MOVSI C,004400		;FIDDLE WITH MODE NUMBER TO GET BYTE SIZE
	CAIGE D,10		;MODE >=10?
	MOVSI C,000700		;NO, 7 BIT, NOT 36
	MOVEI E,0
	MOVE D,BUFHTB(BB)
	TRNN D,-1		;IS THERE AN INPUT HEADER?
	JRST .+4		;NO
	UMOVEM E,(D)
	UMOVEM C,1(D)
	UMOVEM E,2(D)

	HLRZ D,D		;FIRST TIME LEFT HALF IS OUTPUT HEADER
	JUMPN D,.-4		;EITHER NO OUT HDR OR SECOND TIME THRU

UOPEN4:	MOVSI B,INITF		;CHANNEL INIT'ED
	IORB B,FLAGWD(BB)	;MARK IT.
	MOVEI D,17
	ANDI D,(B)
	MOVE B,DEVTBL(AA)
	TLNE B,DTADEV		;DECTAPE IN BUFFERED MODE?
	CAILE D,14
	TLNE B,DSKDEV		;OR DSK?
	JRST MRETN2		;YES, CAN'T GTJFN YET.
	MOVE B,DEVTBL(AA)
	TLNN B,DTADEV!MTADEV	;IS IT A DECTAPE OR MAGTAPE?
	JRST UOPEN6		;NO,ALL DONE
	MOVE A,DEVNUM(BB)	;GET DEVICE DESIGNATOR
	TLO A,(1B3)		;SUPRESS READING DIRECTORY
	MOUNT
	PUSHJ P,ERROR
UOPEN6:	MOVS A,DEVNAM(BB)	;GET DEVICE NAME
	CAIE A,'TTY'		;USER CONSOLE?
	JRST UOPEN7		;NO
	MOVEI A,PROJFN		;YES, USE PRIMARY
	MOVEM A,JFNTAB(BB)
	PUSHJ P,TTYSTS		;SET STATUS
	JRST MRETN2		;DONE

UOPEN7:	MOVSI A,TTYDEV
	TDNE A,DEVTBL(AA)	;IS DEVICE A TTY?
	PUSHJ P,TTYSTS		;YES, SET STATUS
	PUSHJ P,UOPEN5		;SETUP JFN TABLE
	GTJFN
	PUSHJ P,ERROR
	MOVEM A,JFNTAB(BB)
	JRST	 MRETN2

UOPEN5:	MOVE A,[XWD JBLOCK+3,JBLOCK+4]
	SETZM JBLOCK+3
	BLT A,JBLOCK+10
	HRROI A,DEVNM7		;NAME OF DEVICE IN ASCIZ
	MOVEM A,JBLOCK+2
	MOVE A,[XWD 377777,377777]
	MOVEM A,JBLOCK+1
	SETZM JBLOCK
	SETZ B,
	MOVEI A,JBLOCK
	POPJ P,
PDVNUM:	POINT 6,DEVNUM(BB),17		;NUMERIC DEVICE TYPE FROM DESIGNATOR

UINBUF:	TLOA C,-1
UOUTBF:	TLZ C,-1
	PUSHJ P,SETUP

	MOVE D,FLAGWD(BB)
	TLNN D,INITF		;CHANNEL INIT'ED?
	PUSHJ P,ERRCHN		;NO-YOU LOSE
	MOVE CC,BUFHTB(BB)
	TLNN C,-1		;HEADER POINTER ALREADY IN RIGHT HALF?
	HLRZ CC,CC		;OBUF,IBUF_0,OBUF
	MOVSI B,INBUFF
	TLNN C,-1
	MOVSI B,OUTBFF
	HRRZ C,FORTY		;NUMBER OF BUFFERS IN RING
	CAIN C,0		;DID USRE SPECIFY ZERO BUFFERS?
	MOVEI C,2		;YES, GIVE HIM TWO
	PUSHJ P,IOBUF
	JRST MRETN

IOBUF:	IORM B,FLAGWD(BB)
	UMOVE D,JOBFF		;WHERE TO START RING
	MOVEI E,(D)		;SPARE COPY OF START

	MOVE B,DEVTB2(AA)
	MOVEI G,3(B)		;TOTAL LENGTH OF EACH BUFFER
	IMULI G,(C)		;TIMES NUMBER OF BUFFERS
	ADDI G,(D)		;PLUS BEGINNING ADDRESS
	CAILE G,PATLOC		;MUST BE BELOW COMPATIBILITY CODE
	PUSHJ P,ERRARG
	CAML G,JBREL		;IS THERE ENOUGH CORE NOW?
	PUSHJ P,XPAND		;NO, GET SOME MORE

	MOVSI F,400000		;RING USE BIT
	HRRI F,1(D)		;POINTER TO SECOND WORD OF FIRST BUFFER
	UMOVEM F,(CC)		;GOES IN FIRST WORD OF HEADER

	MOVSI F,1(B)		;SIZE+1 IN LH OF SECOND WORD  OF EACH BUFFER

UIOBFL:	HRRI F,1(D)		;POINTER TO SELF IN RIGHT HALF
	ADDI F,3(B)		;PLUS LENGTH OF A COMPLETE BUFFER
	CAIN C,1		;EXCEPT THE LAST BUFFER
	HRRI F,1(E)		;WHICH POINTS BACK TO THE FIRST

	UMOVEM F,1(D)		;SET  RING PTR TO XWD SIZE+1,NXTBUF+1

	ADDI D,3(B)		;POINT BEYOND THIS BUFFER
	SOJG C,UIOBFL		;BACK IF MORE BUFFERS TO SET UP
	XCTUU [HRRM D,JOBFF]	;SET JOBFF BEYOND BUFFERS
	POPJ P,

XPAND:	PUSH P,CAC		;CORE UUO WANTS ARG IN CAC
	HRRZ CAC,G		;PHONY UP A CORE UUO FOR LOW SEG.
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSHJ P,CORU10		;EXPAND CORE TO GET IT
	PUSHJ P,ERROR		;ERROR RETURN- COULDN'T
	POP P,D
	POP P,C
	POP P,B
	POP P,CAC		;RESTORE I/O CALL CAC
	POPJ P,			;OK- ALL DONE.

ULOOKP:	PUSHJ P,SETUP
	MOVE D,FLAGWD(BB)
	TLNN D,INITF
	PUSHJ P,ERRCHN
	PUSHJ P,DIRCHK		;SKIP IF HAS DIRECTORY
	  JRST MRETN2		;NO, NOP.
	MOVEI A,1		;CLOSE INPUT SIDE
	MOVEM A,IOCNT
	PUSHJ P,UCL1R		;CLOSE IT AND RELEASE JFN
	ANDI D,17
	MOVE B,DEVTBL(AA)
	TLNE B,DTADEV		;DECTAPE IN BUFFERED MODE?
	CAILE D,14
	TLNE B,DSKDEV		;OR DSK?
	JRST ULK6		;YES- DO GTJFN NOW
	SKIPN A,JFNTAB(BB)	;NO- MUST HAVE JFN ALREADY
	PUSHJ P,ERRCHN
	JRST ULK7

ULK6:	PUSHJ P,LUKPAR
	MOVSI A,102000
	MOVEM A,JBLOCK		;VERSION 0,BITS FOR READING
	MOVEI B,0
	MOVEI A,JBLOCK
	GTJFN
	JRST LOOKER
	MOVEM A,JFNTAB(BB)	;ASSIGNED JFN

ULK7:	MOVEI B,1B19		;OPEN FOR INPUT
	PUSHJ P,OPENX
	MOVSI B,IOPENF!LOOKPF
	IORM B,FLAGWD(BB)	;DENOTE FILE OPEN SO CLOSE WILL REALLY CLOSE
	LDB B,PDVNUM		;GET DEVICE TYPE NUMBER
	MOVSI D,200000		;MULTIPLE DIRECTORY DEVICE BIT
	TDNN D,DEVTBL(B)	;IS IT ONE OF THOSE?
	JRST MRETN2		;NO, ALL DONE FOR NOW

ULK1:	MOVSI B,22		;XWD 22,0 I.E. WHOLE FDB
	MOVEI C,FDBB		;PSB BUFFER FOR FILE DESCRIPTOR BLOCK
	GTFDB
	MOVE B,FDBB+15		;LAST REF DATE AND TIME
	PUSHJ P,NODATE
	ANDI D,7777		;12 BITS ONLY
	TRNE PF,R.UEXT		;EXTENDED LOOKUP?
	JRST ULK8
	XCTUU [HRRM D,1(G)]	;2 FOR MDD
	SKIPA
ULK8:	XCTUU [HRRM D,3(G)]

ULK2:	MOVE A,FDBB+4	;PROTECTION WORD
; *** CONVERT TO BITS 0-8 OF 10/50 PROTECTION ***
; *** ENDING UP IN BITS 0-8 OF F ***
	MOVSI F,(0B8)		;FOR NOW, NO PROTECTION

	MOVE B,FDBB+14		;LAST WRITE, NOT CREATION OF VERSION
	PUSHJ P,NODATE
	IOR F,D			;ADD DATE,TIME TO PROT ALREADY IN F0-8
	TRNE PF,R.UEXT		;EXTENDED LOOKUP
	JRST ULK9
	UMOVEM F,2(G)		;PROTECTION,0 MODE,TIME AND DATE
	SKIPA
ULK9:	UMOVEM F,4(G)

ULK3:	LDB B,[POINT 6,FDBB+11,11]	;BYTE SIZE
	SKIPN B			;MAKE 0 SIZE 36/ RS
	MOVEI B,^D36
	MOVEI A,^D36
	IDIVI A,(B)		;NO OF BYTES IN A WORD
	MOVE B,FDBB+12		;NO OF BYTES IN FILE
	IDIVI B,(A)		;NO OF WORDS IN FILE
	SKIPE C			;INTEGER WORDS
	ADDI B,1		;ROUND UP
	CAILE B,-1		;<256K WORDS?
	JRST ULK4		;NOPE
	MOVNI B,(B)		;YES, -NO OF WORDS
	JRST ULK5
ULK4:	TRNE B,177		;EVEN NO OF BLOCKS?
	ADDI B,200		;NO, ROUND UP 1 BLOCK
	ASH B,-7		;CONVERT WORDS TO 128 WORD BLOCKS
ULK5:	TRNE PF,R.UEXT		;EXTENDED LOOKUP?
	JRST ULK10
	XCTUU [HRLM B,3(G)]
	JRST ULK11
ULK10:	XCTUU [MOVNM B,5(G)]
	UMOVE B,0(G)		;GET NUMBER OF ARGS
	MOVEI B,0(B)		; ..
	CAIGE B,6		;ROOM FOR VERSION?
	JRST ULK11		;NO
	HLRZ B,FDBB+7		;YES. GET VERSION.
	UMOVEM B,6(G)		;RETURN VALUE.
ULK11:	JRST MRETN2


OPENX:	MOVE D,FLAGWD(BB)
	TLNE D,INITF		;IS IT INIT'ED?
	SKIPN A,JFNTAB(BB)	;AND HAS IT A JFN?
	PUSHJ P,ERRCHN		;NO
	MOVE C,B		;SAVE MODE FOR OPENING
	GTSTS
	JUMPGE B,OPENX3		;IS FILE ALREADY OPEN?
	TLNE B,(1B1)		;YES.- OPEN FOR INPUT?
	TRO C,1B19		;YES- SAVE THAT INFO
	TLNE B,(1B2)		;OPEN FOR OUTPUT?
	TRO C,1B20		;YES- SAVE THAT INFO
	TLO A,400000		;PRESERVE JFN
	CLOSF			;AND CLOSE FILE
	PUSHJ P,ERROR
	PUSH P,C		;SAVE OPEN BITS
	MOVE B,[XWD 1,1]	;GET WORD INDICATING DELETION
	MOVEI C,FDBTMP
	HRRZ A,A
	GTFDB
	MOVSI C,(1B3)
	TDNN C,FDBTMP		;IS FILE DELETED?
	JRST OPENX5		;NO
	HRLI A,1		;YES, UNDELETE IT
	MOVSI B,(1B3)
	SETZ C,
	CHFDB
	HRLI A,12
	SETO B,
	CHFDB			;CLEAR THE EOF COUNTER

OPENX5:	POP P,C
	HRRZ A,A

OPENX3:	MOVE B,C		;NOW IT CAN BE OPENED
	MOVEI C,17
	ANDI C,(D)		;MODE
	LDB AA,PDVNUM		;GET DEVICE TYPE NUMBER
	MOVE D,DEVTBL(AA)
	TLNE D,DTADEV		;IS THIS DUMP MODE TO DECTAPE?
	CAIG C,14
	TLNE D,MTADEV		;OR ANYTHING TO MAGTAPE?
	JRST OPENX1		;YES- OPEN IN DUMP MODE
	HRLI B,070000		;NO- OPEN IN ASCII MODE
	TLNE D,PTRDEV+PTPDEV	;IS PAPER TAPE?
	JRST [	CAIGE C,10	;YES, ASCII MODE?
		JRST OPENX2	;YES
		HRLI B,100000	;BYTE SIZE IS 8 IF IMAGE MODE
		CAIL C,13
		HRLI B,440000	;36 IF BINARY MODE
		DPB C,[POINT 4,B,9] ;PASS ALONG MODE
		JRST OPENX2]
	TLNN D,HASDIR		;UNLESS THIS IS A DIRECTORY DEVICE
	CAIL C,10		;OR BINARY MODE SPECIFIED
	HRLI B,440000		;IN WHICH CASE USE BINARY MODE
	JRST OPENX2

OPENX1:	HRLI B,447400	;DUMP MODE

OPENX2:	HRRZ A,A
	OPENF
	JRST OPENX4
	MOVE B,DEVTBL(AA)
	TLNN B,MTADEV		;MAGTAPE?
	POPJ P,			;NO,ALL DONE
	HRRZ B,FLAGWD(BB)
	ANDI B,7B28		;DENSITY AND PARITY BITS
	TRO B,1B21		;SUPRESS AUTO ERROR CORRECTION
	MOVE A,JFNTAB(BB)
	SDSTS
	POPJ P,

OPENX4:	CAIE A,OPNX8		;UNMOUNTED DEVICE?
	PUSHJ P,ERROR		;NO, LOSE.
	MOVE A,DEVTBL(AA)
	TLNN A,PTRDEV		;PAPERTAPE READER?
	PUSHJ P,ERROR
	MOVEI A,^D5000
	DISMS			;GIVE THE OPERATOR ANOTHER 2 SEC.
	MOVE A,JFNTAB(BB)
	JRST OPENX2		;AND TRY AGAIN

;0 - FILE NOT FOUND
;1 - DIRECTORY NOT FOUND
;2 - READ PROTECTED

LOOKER:	MOVEI B,0
	CAIN A,GJFX17		;NO SUCH DIRECTORY
	AOJA B,LOOKR2
	CAIE A,GJFX18		;NO SUCH FILE NAME
	CAIN A,GJFX19		;NO SUCH EXT
	JRST LOOKR2
	CAIN A,GJFX20		;NO SUCH VERSION
	JRST LOOKR2
LOOKRX:	SETZ B,
LOOKR2:	XCTUU [HRRM B,1(G)]	;PUT ERROR NUMBER IN RH E+1
	JRST MRETN

OPENFR:	MOVEI B,1
	CAIN A,OPNX2		;NO SUCH FILE
	SOJA B,LOOKR2
	CAIN A,OPNX3		;READ PROTECTED
	AOJA B,LOOKR2
	JRST LOOKRX		;UNEXPECTED ERROR

ER0:	TRZA B,-1
ER4:	MOVEI B,4
	JRST LOOKR2
ER5:	MOVEI B,5
	JRST LOOKR2

;TRANSLATE LOOKUP AND ENTER PARAMETERS TO STRINGS

LUKPAR:	TRZ PF,R.TMPX		;NOT TMP EXTENSION (YET)
	HRRZ G,FORTY		;POINTER TO PARAMETER BLOCK
	UMOVE D,(G)		;NAME IN SIXBIT
	TLNN D,-1		;IS LEFT HALF ZERO?
	CAIGE D,3		;AND RIGHT HALF >= 3?
	TRZA PF,R.UEXT		;NO. CLEAR FLAG.
	TRO PF,R.UEXT		;YES - INDICATE EXTENDED ENTER BLOCK
	PUSH P,D		;PRESERVE DEVICE NAME
	PUSHJ P,DEV67		;CONVERT DEVICE NAME TO SEVEN BIT
	POP P,D			;RESTORE DEVICE NAME
	HRROI E,FILNM7		;WHERE TO PUT ASCIZ OF NAME
	MOVEM E,JBLOCK+4	;POINTER TO NAME
	TRNE PF,R.UEXT		;EXTENDED LOOKUP/ENTER?
	UMOVE D,2(G)		;YES.
	MOVEM D,FILNAM(BB)	;SAVE THE SIXBIT FILENAME
	PUSHJ P,SIXTO7
	XCTUU [HLLZ D,1(G)]	;EXTENSION
	HRROI E,EXT7
	MOVEM E,JBLOCK+5	;POINTER TO EXTENSION
	TRNE PF,R.UEXT		;SKIP IF NOT EXTENDED LOOKUP
	XCTUU [HLLZ D,3(G)]
	MOVEM D,EXT(BB)		;SAVE THE SIXBIT VERSION
	CAMN D,[SIXBIT /TMP/]	;TEMPORARY FILE?
	TRO PF,R.TMPX		;YES. MAKE ;T IN TENEX VERSION
	PUSHJ P,SIXTO7
	UMOVE 2,3(G)		;"PROJ-PROG" I.E. DIRECT NAME
	SETZM JBLOCK+3		;WE MIGHT NOT HAVE ONE
	SETZM DIRNUM(BB)	;ASSUME OWN DIRECTORY
	TRNE PF,R.UEXT		;EXTENDED LOOKUP/ENTER?
	UMOVE 2,1(G)
	PUSHJ P,CHKDIR		;TRANSLATE SIXBIT DIR TO ASCII TO NUMBER
	JUMPLE 2,LUKPR2		;SO LEAVE 0 FOR GTJFN
	TLZ 2,1			;ASSUME PROJECT 1 OR 0 IS DIR NO.
	HRROI 1,DIRNAM		;DIRECTORY NAME STRING STORAGE
	DIRST			;CONVERT TO STRING
	  JRST LUKPR2		;WRONG NUMBER, LEAVE 0
	HRRZM B,DIRNUM(BB)	;STORE DIRECTORY NUMBER
	HRROI E,DIRNAM
	MOVEM E,JBLOCK+3	;POINTER FOR GTJFN
LUKPR2:	HRROI E,DEVNM7
	MOVEI B,NSPDDV-1	;NUMBER OF DISK DEVICES
	MOVE D,DEVNAM(BB)	;GET DEVICE NAME
	CAMN D,SPDDVT(B)	;CHECK FOR SPECIAL DEVIWE
	  JRST LUKPR3		;HANDLE SPECIAL IF SO
	SOJGE B,.-2		;LOOP LOOKING
	JRST LUKPR1		;STD DEVICE--HANDLE

LUKPR3:	HRRO E,SPDDVN(B)	;GET NAME OF DEVICE
	MOVEM E,JBLOCK+3	;SAVE FOR GTJFN
	HRROI E,[ASCIZ /DSK/]	;AND USE DEVICE DSK

LUKPR1:	MOVEM E,JBLOCK+2
	MOVE E,[XWD 377777,377777]
	MOVEM E,JBLOCK+1
	POPJ P,

;   SPDDVT--TABLE OF SPECIAL DEVICES FOR DISK.  THESE ALL REFER
;      TO VARIOUS STD DIRECTORYS WITH DSK: AS THE DEVICE.  THE
;      CURRENT ONES ARE:
;
;	SUP:	<SYSSUP>
;	LIB:	<LIBRARY>
;	HLP:	<DOC>
;	SYS:	<SUBSYS>
;

SPDDVT:
	SIXBIT /SUP/		;SIXBIT DEVICE NAMES
	SIXBIT /LIB/
	SIXBIT /HLP/
SPDSYS:	SIXBIT /SYS/

NSPDDV== .-SPDDVT		;NUMBER OF SUCH DEVICES


SPDDVN:				;TABLE OF DIRECTORY NAMES
	POINT 7,[ASCIZ /SYSSUP/]
	POINT 7,[ASCIZ /LIBRARY/]
	POINT 7,[ASCIZ /DOC/]
	POINT 7,[ASCIZ /SUBSYS/]

;   CHKDIR--CHECK DIRECTORY FOR BEING SIXBIT AND IF SO, CHANGE
;      FIRST TO ASCII THEN TO TENEX NUMBER (W/ RECOGNITION).
;

CHKDIR:	TLNN B,770000		;CHECK FOR SIXBIT NAME
	POPJ P,			;NOT--USE AS IS
	PUSH P,B		;SAVE OLD VALUE
	MOVE D,B		;SIXBIT TO D
	HRROI E,DIRNAM		;STIRNG PTR TO E
	PUSHJ P,SIXTO7		;CONVERT TO ASCII
	MOVSI 1,400000		;NEGATIVE NUM W/O B17
	HRROI 2,DIRNAM		;PTR TO NAME
	STDIR			;GET DIRECTORY NUMBER
	  TRN			;FAIL OR
	  SKIPA A,0(P)		;  AMBIGUOUS YIELDS INITIAL
	  HRRZS A		;IF OK, ISOLATE DIRECTORY NUMBER
	POP P,B			;FIX STACK
	MOVE B,A		;GET RESULT TO RETURN
	POPJ P,			;AND DONE

UENTER:	PUSHJ P,SETUP
	MOVE D,FLAGWD(BB)
	TLNN D,INITF
	PUSHJ P,ERRCHN
	PUSHJ P,DIRCHK		;DIRECTORY TYPE DEVICE?
	  JRST MRETN2		;NO,NOP.
	MOVE A,DEVTBL(AA)	;DEVICE BITS
	TLNN A,DSKDEV		;A DISK?
	JRST UENT1		;NO
	MOVE A,FLAGWD(BB)	;YES. GET ITS ST@TUS
	TLNN A,IOPENF		;FILE ALREADY OPEN FOR INPUT?
	JRST UENT1		;NO
	MOVEI B,3B20		;YES. WANT TO UPDATE. SET WRITE ALSO
	JRST ENTR41		;GO DO IT.

UENT1:	SETZM IOCNT		;PREPARE FOR CLOSE
	PUSHJ P,UCL1R		;CLOSE AND RELEASE JFN
	MOVEI D,17
	AND D,FLAGWD(BB)
	MOVE B,DEVTBL(AA)
	TLNE B,DTADEV		;DECTAPE IN BUFFERED MODE?
	CAILE D,14		;OR DSK?
	TLNE B,DSKDEV
	JRST ENTR3		;YES- DO GTJFN NOW
	SKIPN A,JFNTAB(BB)	;HAVE A JFN ALREADY?
	PUSHJ P,ERRCHN		;NO
	JRST ENTR4		;YES. GO OPEN IT.

ENTR3:	PUSHJ P,LUKPAR		;SET UP SAME PARAMETERS AS LOOKUP
	UMOVE D,(G)
	JUMPE D,ER0		;ZERO FILE NAME FOR ENTER
	MOVSI D,IOPENF
	TDNE D,FLAGWD(BB)	;FILE OPENF FOR READING ALREADY?
	PUSHJ P,ERRARG
	MOVSI E,400000
REPEAT 0,<			;THIS IDEA DOESNT WORK WITH STOPGAP...
	TRZE PF,R.TMPX		;WAS EXTENSION "TMP"?
	TLO E,(1B5)		;YES. MAKE ;T FILE
>
ENTER1:	MOVEM E,JBLOCK
	MOVEI B,0		;NO PRIMARY STRING
	MOVEI A,JBLOCK
	GTJFN
	  JRST ENTRER
	MOVEM A,JFNTAB(BB)	;SAVE GOTTEN JFN
ENTR4:	MOVEI B,1B20		;OPEN FOR WRITING
ENTR41:	PUSHJ P,OPENX
	MOVSI A,OOPENF!ENTERF
	IORM A,FLAGWD(BB)
	JRST MRETN2

ENTRER:	MOVEI B,2		;ASSUME PROTECTION ERROR
	CAIN A,GJFX17		;CHECK IT
	SOJA B,LOOKR2		;DIRECTORY NOT FOUND
	JRST LOOKR2		;PROTECTION ERROR

URENME:	PUSHJ P,SETUP
	MOVE D,FLAGWD(BB)
	TLNN D,INITF
	PUSHJ P,ERRCHN
	PUSHJ P,DIRCHK		;DIRECTORY DEVICE?
	  JRST MRETN2		;NO

	MOVSI A,LOOKPF!ENTERF
	TDNN A,FLAGWD(BB)
	JRST ER5		;NO FILE PREVIOUSLY SELECTED
	SETZM IOCNT		
	PUSHJ P,UCL1K		;AND CLOSE THE SELECTED FILE

	HRRZ AA,FORTY
	XCTUU [SKIPN D,(AA)]
	JRST RENDEL
	TLNN D,-1		;IS LEFT HALF ZERO?
	CAIGE D,3		;AND RIGHT HALF >= 3?
	TRZA PF,R.UEXT		;NO. CLEAR FLAG.
	TRO PF,R.UEXT		;YES - INDICATE EXTENDED ENTER BLOCK
	TRNE PF,R.UEXT		;EXTENDED LOOKUP/ENTER?
	UMOVE D,2(AA)		;YES.
	JUMPE D,RENDEL		;EXTENDED--CHECK FOR DELETE
	MOVE A,FILNAM(BB)	;SAVE OLD FILE NAME
	MOVEM A,BUFFER		; ..
	MOVEM D,FILNAM(BB)	;SET NEW FILE NAME
	MOVEI E,FILNM7		;STORAGE FOR ASCIZ OF NEM OND.
	PUSHJ P,SIXTO7		;CONVERT NEW FILE NAME

	MOVE A,FILNAM(BB)
	CAME A,BUFFER
	JRST RENME1		;NAME DIFFERS
	MOVE A,EXT(BB)
	MOVEM A,BUFFER		;SAVE OLD EXTENSION
	XCTUU [HLLZ D,1(AA)]
	TRNE PF,R.UEXT		;SKIP IF NOT EXTENDED LOOKUP
	XCTUU [HLLZ D,3(AA)]
	MOVEM D,EXT(BB)		;STORE THE SIXBIT EXTENSION
	MOVEI E,EXT7		;STRING STORAGE FOR ASCIZ EXT
	PUSHJ P,SIXTO7		;CONVERT NEW EXT

	MOVE A,EXT(BB)
	CAME A,BUFFER
	JRST RENME2		;EXTENSION DIFFERS

				;PROTECTION CHANGE ONLY
	JRST MRETN2		;FOR NOW NOP SINCE NO PROTECTION

;NOTE - DOESN'T RENAME ACCROSS DIRECTORIES....

RENME1:	XCTUU [HLLZ D,1(AA)]
	TRNE PF,R.UEXT		;SKIP IF NOT EXTENDED LOOKUP
	XCTUU [HLLZ D,3(AA)]
	MOVEM D,EXT(BB)		;STORE NEW EXT IN SIXBIT
	MOVEI E,EXT7
	PUSHJ P,SIXTO7
RENME2:	UMOVE B,3(AA)
	TRNE PF,R.UEXT		;EXTENDED LOOKUP/ENTER?
	UMOVE B,1(AA)
	PUSHJ P,CHKDIR		;CHECK FOR SIX BIT DIRECTORYS
	SKIPGE B		;USER SUPPLY A PROJ-PROG NUMBER?
	MOVEI B,0		;NO.
	TLNE B,-2		;YES. PROJECT 0 OR 1?
	JRST MRETN		;NO. CAN'T TRANSLATE IT.
	HRRZM B,DIRNUM(BB)	;YES. STOR TENEX DIRECTORY NUMBER
	MOVSI A,600000		;NEW FILE ONLY FOR OUTPUT
	MOVEM A,JBLOCK
	MOVE A,[XWD 377777,377777]	;NO STRING
	MOVEM A,JBLOCK+1
	PUSHJ P,DEV67		;CONVERT THE DEVICE NAME TO ASCIZ
	HRROI A,DEVNM7		;POINTER TO THE ASCIZ
	MOVEM A,JBLOCK +2
	SETZM JBLOCK+3		;IN CASE NO DIR NAME
	SKIPG B,DIRNUM(BB)
	JRST RENME3
	HRROI A,DIRNAM
	DIRST			;MAKE IT INTO A NAME
	  JRST MRETN		;HE DOESNT EXIST (SHOULD GIVE CODE 1)
	HRROI A,DIRNAM		;POINTER TO NAME IN ASCIZ
	MOVEM A,JBLOCK+3
RENME3:	HRROI A,FILNM7
	MOVEM A,JBLOCK+4
	HRROI A,EXT7
	MOVEM A,JBLOCK+5
	SETZM JBLOCK+6
	SETZM JBLOCK+7
	SETZM JBLOCK+10
	MOVEI B,0		;NO PRIMARY STRING
	MOVEI A,JBLOCK
	GTJFN
	JRST MRETN		;ERROR RETURN
	PUSH P,A
	MOVE A,JFNTAB(BB)	;OLD JFN
	POP P,B			;NEW JFN
	RNAMF
	 PUSHJ P,ERROR
	MOVEM B,JFNTAB(BB)	;NEW JFN
	JRST MRETN2

RENDEL:	MOVE A,JFNTAB(BB)	;ZERO FILE NAME ON RENAME, IE DELETE
	DELF
	 PUSHJ P,ERROR
	SETZM JFNTAB(BB)	;INDICATE THAT THE JFN NO LONGER VALID
	JRST MRETN2

UCLOSE:	PUSHJ P,SETUPG
	  JRST MRETN		;NOTHING TO BE OPEN, RETURN IMMEDIATELY
	MOVE A,FORTY		;MOVE CLOSE BITS
	MOVEM A,IOCNT		;TO WHERE UCL1 WILL SEE THEM
	PUSHJ P,UCL1K		;CLOSE, KEEPING JFN
	JRST MRETN

UCL1K:	TROA PF,R.KJFN		;KEEP THE JFN
UCL1R:	TRZ PF,R.KJFN		;RELEASE THE JFN
	MOVEI B,1
	TDNE B,IOCNT		;CLOSE OUTPUT?
	JRST UCL2		;NO
	PUSH P,IOCNT
	PUSH P,FORTY
	SETZM FORTY
	MOVSI B,OOPENF
	MOVEI A,17
	AND A,FLAGWD(BB)
	CAIG A,14		;BUFFERED MODE?
	TDNN B,FLAGWD(BB)	;AND OPEN FOR OUTPUT?
	SKIPA			;NO- ALL DONE
	PUSHJ P,OUTTN		;IF OPEN FOR WRITING, DO LAST OUT
	 JFCL			;PITY
	POP P,FORTY
	POP P,IOCNT
	LDB AA,PDVNUM		;WHAT KIND OF DEVICE
	MOVE A,FLAGWD(BB)	;AND CURRENT FLAGS
	MOVE B,DEVTBL(AA)
	TLNE A,OOPENF		;IF OPEN FOR OUTPUT
	TLNN B,MTADEV		;AND ITS A MAG TAPE
	JRST UCL2		; (NO--DONE)
	MOVE A,JFNTAB(BB)	;YES--NEED TO PUT EOT ON TAPE
	MOVEI B,3
	MTOPR			;WRITE 2 EOFS
	MTOPR
	MOVEI B,7		;AND BACK UP OVER 1 OF THEM
	MTOPR
UCL2:	MOVEI B,2		;CLOSING INPUT SIDE?
	TDNN B,IOCNT		; ..
	SKIPG MAPTAB(BB)	;YES. HAVE A PAGE MAPPED?
	JRST UCL4		;NO.
	MOVEI B,(BB)		;RECONSTRUCT PAGE NUMBER.
	IDIVI B,NTABS		;FROM TABLE OFFSET
	MOVEI B,IOMPGS(B)	;PAGE NUMBER.
	HRLI B,.S		;IN THIS FORK
	SETOB A,MAPTAB(BB)	;TO OBLIVION
	PMAP			;CLEAR IT OUT
UCL4:	MOVE B,FLAGWD(BB)
	MOVE A,IOCNT
	TRNN A,1		;CLOSING OUTPUT?
	TLZ B,OOPENF		;YES
	TRNN A,2		;CLOSING INPUT?
	TLZ B,IOPENF		;YES
	HRRZ A,JFNTAB(BB)
	TLNE B,OOPENF+IOPENF	;BOTH SIDE NOW CLOSED?
	JRST UCL3
	JUMPE A,UCL3		;GOT A JFN
	CAIE A,PRIJFN		;OTHER THAN PRIMARY
	CAIN A,PROJFN
	JRST UCL3
	TRNE PF,R.KJFN		;KEEPING JFN?
	TLO A,.S		;YES. SET SIGN BIT FOR CLOSF
	CLOSF			;CLOSE IT
	  JFCL			;MULTIPLE CLOSE IS NOP
	SKIPE A,JFNTAB(BB)	;DON'T RELEASE JFN IF IT IS ZERO
	TRNE PF,R.KJFN		;OR CALLER SAID KEEP IT
	JRST UCL3
	RLJFN
	PUSHJ P,ERROR
	SETZM JFNTAB(BB)
UCL3:	MOVEI A,2		;B34
	TDNN A,IOCNT		;OMIT INPUT SIDE?
	PUSHJ P,CLOSEI		;NAH, CLOSE IT
	MOVEI A,1		;B35
	TDNN A,IOCNT
	PUSHJ P,CLOSEO
	POPJ P,

CLOSEI:	MOVSI B,IOPENF+INFIRF
	HRRZ A,BUFHTB(BB)	;PTR TO INPUT BUFFER HEADER
CLOSI2:	TDNN B,FLAGWD(BB)
	POPJ P,
	TRO B,1B22		;CLEAR EOF.
	ANDCAB B,FLAGWD(BB)
	ANDI B,17
	CAIE A,0		;IS THERE A BUFFER?
	CAILE B,14		;AND IN BUFFERED MODE?
	POPJ P,			;NO

	MOVSI B,400000		;CLOSE A BUFFER RING
	XCTUU [SKIPE (A)]	;HAS BUFFER RING BEEN SET UP?
	XCTUU [TDNE B,(A)]	;AND HAS IT BEEN USED?
	POPJ P,			;NO, FORGET IT

	XCTUU [IORB B,(A)]
	XCTUU [SETZM 2(A)]	;CLEAR BYTE COUNT

	MOVEI D,(B)		;EXTRA COPY FOR END TEST

BUFLP:	MOVEI C,(B)
	CAMLE C,JBREL		;ARE RING LINK POINTERS OK?
	PUSHJ P,ERRARG		;NO, SMASHED SOMEHOW
	MOVSI B,400000
	XCTUU [ANDCAB B,(C)]	;CLEAR BUFFER USE BIT AND FETCH CHAIN POINTER
	CAIE D,(B)		;BACK AROUND TO FIRST ONE IN RING?
	JRST BUFLP		;NO
	POPJ P,

CLOSEO:	MOVSI B,OOPENF+OUFIRF
	HLRZ A,BUFHTB(BB)
	JRST CLOSI2

DIRCHK:	MOVE B,JFNTAB(BB)	;IS THIS PRIMARY I/O
	CAIE B,PRIJFN
	CAIN B,PROJFN
	POPJ P,			;YES--PRETEND CAN'T RENAME, ETC.
	MOVE B,DEVTBL(AA)	;GET DEVICE BITS
	TLNE B,HASDIR		;HAVE A DIRECTORY?
	AOS 0(P)		;YES. SKIP RETURN
	POPJ P,0		;RETURN.

DEV67:	MOVE D,DEVNAM(BB)	;GET THE SIXBIT NAME
	HRROI E,DEVNM7		;WHERE ASCIZ SHOULD GET PUT
	JRST SIXTO7		;CONVERT IT.

;SETUP ON ENTRY TO IO UUO'S

SETUP:	PUSHJ P,SETUPG		;CALL CONDITIONAL SETUP ROUTINE
	  PUSHJ P,ERRCHN	;NOT OPEN. ERROR.
	POPJ P,0		;OK.

;CONVERSION FROM SIXBIT TO ASCIZ
;C - CLOBBERABLE
;D - SIXBIT THING TO CONVERT
;E - POINTER TO DESTINATION

SIXTO7:	HRLI E,440700	;ASSUME ALL ASCIZ'S START ON WORD BOUNDARY
	SETZM 0(E)		;CLEAR DESTINATION WORD
	JUMPE D,SIXT7B		;QUIT IF STRING EMPTY
SIXT7A:	MOVEI C,0
	ROTC C,6		;PUT ONE CHAR INTO C
	ADDI C,40		;OFFSET
	CAIE C,"."
	CAIN C,":"
	PUSHJ P,SPECCH
	CAIE C,";"
	CAIN C,"<"
	PUSHJ P,SPECCH
	CAIE C,">"
	CAIN C,"="
	PUSHJ P,SPECCH
	CAIE C,"@"
	CAIN C,"*"
	PUSHJ P,SPECCH
	CAIE C,"_"
	CAIN C,40
	PUSHJ P,SPECCH
	IDPB C,E		;STORE AWAY
	JUMPN D,SIXT7A		;ANY MORE CHARS IN THING?
SIXT7B:	IDPB D,E		;STORE A ZERO TERMINATOR
	POPJ P,

SPECCH:	PUSH P,C
	MOVEI C,"V"-100		;USE CNTL-V TO QUOTE IT
	IDPB C,E
	POP P,C
	POPJ P,

SETUPG:	MOVE BB,AC		;CHANNEL NUMBER
	IMULI BB,NTABS
	LDB AA,PDVNUM		;GET NUMERIC DEVICE TYPE
	SKIPE DEVNAM(BB)		;SOMETHING OF A CROCK.
	AOS 0(P)
	POPJ P,

UUSETO:	TROA PF,R.DIRN		;FLAG USETO VS USETI
UUSETI:	TRZ PF,R.DIRN		;USETI VS USETO
	PUSHJ P,SETUP
	CAIN AA,3		;IS IT DECTAPE?
	JRST DTASET		;YES
	PUSHJ P,PTRGET
	  JRST MRETN		;NO GOOD
	MOVE C,B		;NUMBER OF BYTES IN FILE
	HRRZ B,FORTY		;BUFFER NUMBER
	SOJGE B,.+2
	SETZ B,
	IMUL B,DEVTB2(AA)	;BUFFER SIZE
	TRNN PF,R.DIRN		;OUTPUT?
	CAIGE B,0(C)		;NO. INPUT BEYOND EOF?
	JRST UUSET1		;NO
	MOVEI A,1B22		;INPUT, EOF FLAG SET
	IORM A,FLAGWD(BB)
	JRST MRETN

UUSET1:	SFPTR
	  PUSHJ P,ERROR		;NO GOOD
	JRST MRETN

PTRGET:	PUSHJ P,DIRCHK		;DIRECTORY DEVICE?
	  POPJ P,0		;NO. NO-OP
	MOVE A,FLAGWD(BB)		;CHANNEL FLAGS
	TLNE A,LOOKPF!ENTERF	;MUST BE LOOKED UP OR ENTERED
	TLNN A,OOPENF!IOPENF	;AND OPEN FOR INPUT OR OUTPUT
	PUSHJ P,ERRARG		;ERROR
	MOVE A,JFNTAB(BB)
;NOTE - FOLLOWING IN PLACE OF SIZEF WHICH FAILS IF FILE NEVER CLOSED.
	RFPTR			;WHERE ARE WE IN FILE?
	  PUSHJ P,ERROR
	PUSH P,B		;SAVE IT
	SETO B,			;REQUEST CURRENT EOF
	SFPTR			; ..
	  PUSHJ P,ERROR
	RFPTR			;FIND WHERE THAT IS
	  PUSHJ P,ERROR
	EXCH B,0(P)		;SAVE ANSWER
	SFPTR			;RESTORE TO WHERE WE WERE AT CALL
	  PUSHJ P,ERROR		;CAN'T FAIL...
	POP P,B			;RETURN THE LENGTH OF FILE
	AOS(P)			;SKIP RETURN
	POPJ P,

UUGETF:	PUSHJ P,SETUP		;GET AA AND BB
	PUSHJ P,PTRGET		;FIRST FREE WORD
	JRST MRETN
	IDIV B,DEVTB2(AA)
	SKIPE C			;FIRST WORD OF BUFFER?
	ADDI B,1		;NO-GO TO NEXT BUFF
	HRRZ A,FORTY		;TARGET ADDRESS
	UMOVEM B,(A)
	JRST MRETN

DTASET:	MOVE C,FLAGWD(BB)
	TLNE C,OOPENF!IOPENF	;IS IT OPEN?
	JRST DTAST2		;YES.
	MOVE A,JFNTAB(BB)	;NO, OPEN IT
	MOVE B,[XWD 447400,300000]	;IN DUMP MODE
	OPENF
	PUSHJ P,ERROR
	MOVSI B,OOPENF!IOPENF
	IORM B,FLAGWD(BB)	;MARK IT AS OPEN

DTAST2:	MOVE A,JFNTAB(BB)
	MOVEI B,30		;DECLARE BLOCK FOR DUMP I/O
	ANDI C,17		;TEN50 INIT MODE FIELD
	CAIE C,17		;DUMP MODE?
	MOVEI B,6		;NO. SKIP SOME RECORDS.
	HRRZ C,FORTY		;BLOCK TO POSITION TO
	MTOPR
	JRST MRETN
UMTAPE:	PUSHJ P,SETUP
	MOVE A,FLAGWD(BB)	;IS IT INIT'ED?
	TLNN A,INITF
	PUSHJ P,ERRCHN
	CAIE AA,2		;IS DEVICE A MAGTAPE?
	JRST MRETN		;NO, NOP
	SKIPE A,JFNTAB(BB)	;HAS IT A JFN?
	JRST MTAPE2
	PUSHJ P,JBKSET		;INITIALIZE JBLOCK
	PUSHJ P,DEV67		;MOVE THE NAME TO ASCIZ BLOCK
	HRROI A,DEVNM7		;POINTER TO IT.
	MOVEM A,JBLOCK+2	;DEVICE NAME MTAX
	MOVSI A,400000		;FOR OUTPUT
	MOVEM A,JBLOCK
	SETZ B,
	MOVEI A,JBLOCK
	GTJFN
	PUSHJ P,ERROR
	MOVEM A,JFNTAB(BB)

MTAPE2:	GTSTS
	JUMPGE B,MTAPE3		;JUMP IF NOT YET OPENED
	PUSHJ P,MTAPE1
	JRST MRETN
MTAPE3:	MOVE B,[XWD 447400,300000] ;OPEN IN DUMP MODE
	OPENF
	PUSHJ P,ERROR
	PUSHJ P,MTAPE1
	HRLI A,400000		;OPENED IT ONLY TO DO THE MTOPR.
	CLOSF
	PUSHJ P,ERROR
	JRST MRETN

MTAPE1:	HRRZ B,FORTY		;GET COMMAND
	MTOPR			;DO IT
	POPJ P,

;IN, OUT, INPUT, OUTPUT

UOUT:	PUSHJ P,OUTT
	JRST UIOSK

UIN:	PUSHJ P,INN
UIOSK:	MOVE A,FLAGWD(BB)
	TRNE A,762000		;DATA ERRS, EOF, OR EOT?
	JRST UIOSK1		;YES
	MOVE A,JFNTAB(BB)
	GTSTS
	TRNE B,700000
UIOSK1:	AOS 0(P)
	JRST MRETN

UINPUT:	PUSHJ P,INN
	JRST MRETN

UOUTPT:	PUSHJ P,OUTT
	JRST MRETN

JBKSET:	MOVE A,[XWD 377777,377777]	;NO FILES
	MOVEM A,JBLOCK+1
	SETZM JBLOCK+2		;SYSTEM DEFAULTS ON EVERYTHING
	MOVE A,[XWD JBLOCK+2,JBLOCK+3]
	BLT A,JBLOCK+10
	POPJ P,

;IN AND INPUT OPERATORS

INN:	PUSHJ P,SETUP
	MOVE A,FLAGWD(BB)
	TLNE A,IOPENF		;OPEN FOR INPUT?
	JRST INN3		;YES
	MOVEI B,1B19
	PUSHJ P,OPENX		;OPEN IT FOR INPUT
	MOVSI A,IOPENF
	IORB A,FLAGWD(BB)	;MARK THAT FACT

INN3:	ANDI A,17		;GET MODE INITED IN.
	CAIL A,15		;IS IT A BUFFERED MODE?
	JRST INDMP		;NO, DUMP MODE
	HRRZ CC,BUFHTB(BB)	;BUFFER HEADER
	HRRZ A,FORTY
	CAIE A,0		;SPECIFYING NEW RING?
	MOVEM A,0(CC)		;YES, STORE ADDRESS
	MOVSI A,INFIRF		;FIRST TIME FLAG
	TDNE A,FLAGWD(BB)	;IS IT?
	JRST INN2		;NO
	IORB A,FLAGWD(BB)	;YES, BUT NOT NEXT TIME ...
	TLNN A,OOPENF!OUFIRF	;NO MAPPING IF OUTPUT ALSO
	CAIE AA,0		;OR IF NOT ON DISK
	SKIPA
	SETOM MAPTAB(BB)	;FLAG TO TRY MAPPING INPUT DATA
INN1:	MOVE A,JFNTAB(BB)	;THE JFN
	SIZEF			;TRY TO GET SIZE IN BYTES OF FILE
	  JRST INNT		;CAN'T
	PUSH P,B		;SAVE IT
	MOVE B,[XWD 1,11]	;NOW GET BYTE SIZE FROM FDB
	MOVEI C,C
	GTFDB
	POP P,B
	ROT C,^D12		;BYTE SIZE IN BITS 6-11
	ANDI C,77
	CAIE C,07		;7 BIT?
INNT:	MOVSI B,200000		;DEFAULT BYTE COUNT IS INFINITY
	MOVEM B,BYTCNT(BB)	;WILL BE COUNTED DOWN BY INPUT OPN'S
	MOVSI A,IOPENF
	MOVSI B,INBUFF
	MOVEI C,2		;TWO BUFFERS
	XCTUU [SKIPN 0(CC)]	;BUFFERS SET UP?
	PUSHJ P,IOBUF		;NO SET UP A TWO BUFFER RING
	XCTUU [SKIPL A,(CC)]	;DON'T ADVANCE BUFFER THE FIRST 
INN2:	XCTUU [MOVE A,@(CC)]	;ADVANCE THE BUFFER
	MOVSI B,.S		;SIGN BIT
	ANDCAM B,@(CC)		;CURRENT BUFFER SHD BE RELEASED
	XCTUU [HRRZM A,(CC)]
	PUSHJ P,INIBUF		;ZERO BUFFER AND SET UP PTR AND COUNT
	MOVE A,JFNTAB(BB)

INN2A:	PUSHJ P,@INDSPT(AA)	;SETUP SHOULD SET UP AA WITH DEVICE NUMBER
	PUSHJ P,SETIBF		;COMPUTE COUNT AND SET UP NEW PTR
	MOVE B,0(CC)		;CURRENT BUFFER ADDRESS
	HRRZ A,FLAGWD(BB)	;FILE STATUS
	UMOVEM A,-1(B)		;STORE STATUS AT BEGINNING OF BUFFER
	POPJ P,

INDSPT:	EXP INDSK,ITRAP,INMTA,INBYT,INBYT,ITRAP,ITRAP,ITRAP
	EXP ITRAP,ITRAP,INTTY,ITRAP,INTTY,INBYT,INBYT,ITRAP

INDMP:	MOVE A,JFNTAB(BB)	;JFN
	CAIN AA,0		;DEVICE DISK?
	JRST INDM2		;YES- SIMULATE DUMPI BY SIN
	HRRZ B,FORTY		;NO- USE DUMPI
	CAIGE B,20		;IN THE AC'S?
	ADDI B,ACS		;YES. POINT TO THEM
	TRZ PF,R.DIRN		;DIRECTION IS INPUT (FOR MTA)
	MOVE C,DEVTBL(AA)	;IS IT A MAGTAPE?
	TLNE C,MTADEV		; ..
	JRST MTALP1		;YES. TREAT SEPARATELY
INDM1:	DUMPI
	  JRST INDMER		;ERROR. SEE IF FIXABLE.
INDM3:	POPJ P,

INDM2:	HRRZ D,FORTY		;COMMAND LIST POINTER
INCML:	CAIGE D,20		;IN THE ACS?
	ADDI D,ACS		;YES. POINT TO STORED ACS
	MOVE C,(D)		;COMMAND LOOP
	JUMPE C,INDM3		;DONE ON ZERO COMMAND
	TLNE C,-1		;ZERO LEFT HALF MEANS GOTO
	JRST INDM4
	MOVE D,C
	JRST INCML		;GET NEW COMMAND

INDM4:	HRRI B,1(C)		;FIRST LOCATION
	HRLI B,444400		;BINARY TRANSFER
	HLRO C,C		;WORD COUNT
	MOVEM C,MTDUMP		;SAVE COUNTER BEFORE I/O
	SIN
	MOVEM B,SPDELC		;SAVE BYTE PTR AFTER I/O
	GTSTS			;HOW DID IT GO?
	TLNN B,1000		;EOF?
	JRST [	RFPTR		;ROUND TO 200 WORD RECORDS
		  PUSHJ P,ERROR
		TRZE B,177
		ADDI B,200
		SFPTR		;POINT TO NEXT RECORD BOUNDARY
		  PUSHJ P,ERROR
		AOJA D,INCML]	;GO GET NEW COMMAND
	CAML C,[-177]		;ONE OR MORE BLOCKS NOT READ?
				;NOTE. REAL EOF CONDITION IS A MESS!
	JRST INDM4A		;NO. NO EOF TO USER YET
	MOVEI A,1B22		;YES. REALLY EOF.
	IORM A,FLAGWD(BB)	;SET 10/50 EOF BIT
	JRST INDM3		;DONE.

INDM4A:	MOVEI A,0		;CLEAR REST OF REQUESTED I/O LIST
	MOVE B,SPDELC		;SEE HOW MUCH NEEDS CLEARING
	AOJG C,INDM3		;COUNT UP THRU 0
	IDPB A,B		;NEED ANOTHER ZERO
	JRST .-2		;DONE YET?

INDMER:	PUSHJ P,DTAX3Q		;SEE IF SIZE ERROR ON DTA
	PUSH P,B		;YES. STASH POSITION OF OFFENDING IOWD
	PUSH P,0(B)		;STASH THE IOWD ON STACK
INDME1:	MOVSI A,MAXIOL		;SEE IF A K LEFT
	ADD A,0(P)		; ..
	JUMPG A,INDME2		;NO. SHOULD BE READY TO QUIT.
	MOVSI A,-MAXIOL		;A REASONABLE SIZE IOWD
	HRR A,0(P)		;FIRST PART OF THE BIG LIST
	MOVEM A,DMPLST		;PLACE TO STASH IOL
	SETZM DMPLST+1		;TERMINATE LIST
	MOVE A,JFNTAB(BB)	;READY TO DO SOME I/O. GET JFN
	MOVEI B,DMPLST		;WHERE IO LIST IS
	DUMPI			;TRY THIS
	  PUSHJ P,ERROR		;IF THIS LOSES, GIVE UP.
	MOVE A,[XWD MAXIOL,MAXIOL]	;UPDATE PARTIAL IOWD ON STACK
	ADDM A,0(P)		; ..
	JRST INDME1		;TRY THE REST OF IOLIST
INDME2:	POP P,DMPLST		;SHOULD BE READY TO HANDLE THIS
	MOVE A,JFNTAB(BB)	;GET THE JFN
	HLLZ B,DMPLST		;IS IT BY LUCK EMPTY NOW?
	JUMPE B,INDME3		;JUMP IF SO
	MOVEI B,DMPLST
	DUMPI			;READ IT
	  PUSHJ P,ERROR		;CAN'T
INDME3:	POP P,B			;RESTORE PLACE IN I/O LIST
	ADDI B,1		;NEXT WORD.
	SKIPE 0(B)		;END OF LIST, I HOPE?
	JRST INDM1		;NO. HAVE TO TRY THAT PART OF LIST
	JRST INDM3		;END. QUIT INDMP SUBR

DTAX3Q:	CAIE A,DUMPX3		;RECOVERABLE LENGTH ERROR?
	  JRST ERROR		;NO. GIVE ERROR MESSAGE
	LDB A,PDVNUM		;GET DEVICE TYPE CODE.
	CAIE A,3		;DECTAPE?
	JRST ERROR		;NOPE. LOSE.
	POPJ P,0		;YES. RETURN.

;SET BUFFER FOR USER AFTER INPUT

SETIBF:	MOVE B,IOCNT		;BYTES NOT XFERRED LAST TIME
	LDB C,[POINT 6,IOBPT,11] ;BYTE SIZE OF XFER
	XCTMU [LDB D,[POINT 6,1(CC),11]] ;USER'S BYTE SIZE
	CAIN C,0(D)		;SAME?
	JRST SETIB1		;YES
	CAIG C,0(D)		;XFER SIZE BIGGER?
	JRST SETIB2		;NO
	IDIVI C,0(D)		;XFER SIZE BIGGER, GET RATIO
	IMUL B,C		;NUMBER USER-SIZE BYTES NOT XFER'D
SETIB1:	MOVN C,B		;B NOW HAS NUMBER NOT XFERRED
	XCTUU [SUB B,2(CC)]	;-BUFSIZ GIVES MINUS NUMBER XFERRED
	ADDB B,BYTCNT(BB)	;COUNTDOWN BYTES IN FILE
	CAIGE B,0		;GONE PAST END?
	ADD C,B			;YES, ADJUST SIZE OF LAST XFER
	XCTUU [ADDB C,2(CC)]	;ACTUAL BYTES XFERRED TO USER
	MOVE B,C		;BYTES
	MOVEI C,^D36		;BITS PER WORD
	XCTMU [LDB D,[POINT 6,1(CC),11]]	;USER'S BITS PER BYTE 
	IDIVI C,(D)		;BYTES PER WORD
	IDIVI B,(C)		;WORDS
	SKIPE C			;AND FRACTION THEREOF
	ADDI B,1
	MOVE C,0(CC)		;CURRENT BUFFER ADDRESS
	XCTMU [HRRM B,1(C)]	;STORE THE WORD COUNT WITH BUFFER
	POPJ P,

SETIB2:	PUSHJ P,BUGSTP		;SHOULDNT HAVE DONE SMALLER THAN USER,
	IDIVI D,0(C)		;BUT OTHERWISE, THIS FIXES UP
	IDIV B,D		;BYTE COUNT
	JRST SETIB2

INTTY:	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
	PUSHJ P,TTYSTS		;SET TTY STATUS UP
	MOVE G,IOCNT		;SAVE FULL BUF COUNT FOR DELETE
INTTY1:	SOSGE IOCNT
	JRST INDON1		;BUFFER FULL
INTTD1:	PUSHJ P,TTYBIN		;READ A CHAR FROM TTY
	CAIN B,37		;EOL?
	JRST INTTEO
	MOVE E, FLAGWD(BB)
	TRNE E,1B29		;TRANSPARENT MODE?
	JRST INTTY2		;YES
	CAIE B,177		;RUBOUT, OR
	CAIN B,"A"-100		;CONTROL-A?
	JRST INTTDC		;DELETES CHARACTER
	CAIE B,"U"-100		;CONTROL U?
	CAIN B,"X"-100		;CONTROL-X?
	JRST INTTDB		;DELETES BUFFER (LINE)
	CAIE B,176		;OLD ALTMODE?
	CAIN B,33		;OR ESCAPE?
	MOVEI B,STDALT		;YES, CHANGE TO 10/50 ALTMODE
INTTY2:	XCTMU [IDPB B,IOBPT]	;PUT IT AWAY
	CAIN B,"Z"-100		;EOF?
	JRST INTTY8		;YES
	CAIGE B,175		;ALT, OLD ALT, OR RUBOUT?
	CAIN B,"G"-100		;OR BELL?
	JRST INTTY9		;YES. BREAK CHARACTERS
	CAIE B,33		;ESCAPE?
	CAIN B,"U"-100		;OR CONTROL U?
	JRST INTTY9		;YES. BREAK CHARACTER.
	CAIL B,12		;A FORM CONTROL CHAR?
	CAILE B,15
	JRST INTTY1		;NO, BACK FOR ANOTHER CHARACTER
	JRST INTTY9		;YES, WAKE UP

INTTEO:	MOVEI B,15		;REPLACE EOL BY CR-LF
	XCT INTTY2
	SOS IOCNT		;NO END CHECK HERE, COULD LOSE
	MOVEI B,12
	JRST INTTY2

INDON1:	AOS IOCNT
	JRST INTTY9

INTTY8:	PUSHJ P,CRLF		;TYPE CRLF ECHO
INTY8A:	MOVEI A,1B22		;EOF FLAG IN STATUS WORD
	IORM A,FLAGWD(BB)
INTTY9:	MOVSI A,400000	;BUFFER USE FLAG
	XCTUU [IORM A,@(CC)]
	MOVE A,IOCNT
	IDIVI A,5		;DOES IT END ON WORD BOUNDARY?
	JUMPE B,INTTY7		;YES, ALL DONE.
	MOVE A,B
	SETZ B,

FILWD:	XCT INTTY2		;FILL REST OF LAST WORD WITH ZEROES
	SOS IOCNT
	SOJG A,FILWD

INTTY7:	POPJ P,

TTYBIN:	CAIN A,101		;IS IT PRIMARY OUTPUT?
	MOVEI A,100		;YES. MAKE PRIMARY INPUT.
TTYBPC=.+1			;AFTER THE BIN, FOR INTERRUPT CHECK
	BIN			;GET THE CHAR FROM TTY
	POPJ P,0		;RETURN FROM TTY BYTE INPUT

INTTDB:	PUSH P,A		;SAVE JFN
	HRROI A,[ASCIZ /__
/]
	PSOUT			;EDITING INDICATION
	POP P,A
	PUSHJ P,INTDC1		;DELETE A CHARACTER
	  JRST INTTY1		;NO MORE. DONE.
	JRST .-2		;DELETE ANOTHER

INTTDC:	PUSHJ P,INTDC1
	JRST INTTY1		;BUFFER NOW EMPTY
	PUSH P,1
	MOVEI 1,"\"
	PBOUT
	MOVEM B,STRNG1		;PUT POINTER IN MEMORY
	XCTMU [ILDB 1,STRNG1]	;WHERE ILDB WILL GET IT
	PBOUT			;NOTE CHARACTER DELETED
	POP P,1
	JRST INTTD1		;CHARACTER DELETED

INTDC1:	AOS B,IOCNT		;UNCOUNT THE CHARACTER
	CAIL B,0(G)		;BUFFER NOW EMPTY?
	JRST INTDC2		;YES
	IBP IOBPT
	IBP IOBPT
	IBP IOBPT
	IBP IOBPT
	SOS B,IOBPT
	JRST CPOPJ1

INTDC2:	PUSH P,A
	MOVEI A,C.BELL		;BELL
	PBOUT			;RING IT
	JRST APOPJ

IFN SAMFRK,<
INBYT:	BIN			;GET FIRST BYTE
	MOVE G,B		;SAVE IT
	GTSTS
	TLNE B,1000		;END OF FILE?
	JRST INTY8A		;YES
	MOVE B,G
	SOSGE IOCNT
	JRST INDON1
	IDPB B,IOBPT
	MOVE 2,IOBPT
	MOVN 3,IOCNT
	SIN			;LET MONITOR DO THE LOOPING
	MOVEM 2,IOBPT
	MOVNM 3,IOCNT		;STORE UPDATED BYTE COUNT
	JRST INTTY9
>

;ROUTINE TO INPUT FROM DSK VIA PMAP SINCE SIN IS SLOWER.

INDSK:	SKIPN B,MAPTAB(BB)	;HAS MAPPING BEEN VETOED?
	JRST INBYT		;YES. USE BYTE ROUTINE
	RFPTR			;GET CURRENT POSITION, SAVE IT
	  PUSHJ P,ERROR
	PUSH P,B		;STACK CURRENT POINTER
	MOVE C,B		;COPY IT
	LSH C,-11		;MAKE PAGE NUMBER
	HRLI C,(A)		;PUT IN JFN
	CAMN C,MAPTAB(BB)	;SAME PAGE AS CURRENTLY MAPPED?
	JRST INDSKB		;YES.
	MOVEM C,MAPTAB(BB)	;NO. MARK THAT'S WHAT WE WILL GET NOW
	MOVE A,C		;SET AS ARG TO RPACS
	RPACS			;SEE IF PAGE EXISTS.
	TLNN B,(1B5)		; ..
	SETOB A,MAPTAB(BB)	;NO, PUT EMPTY PAGE IN MAP.  WILL GET 0'S
				;   IF REFERENCED, DUE TO HOLEY FILE
	MOVEI B,IOMPGS(AC)	;YES. CONVERT IO CHANNEL NUMBER TO
	HRLI B,.S		; PAGE HANDLE FOR MAPPING
	MOVSI C,(1B2)		;REQUEST READ ACCESS
	PMAP			;GET THE PAGE
INDSKB:	PUSHJ P,PTRGET		;GET ADDRESS OF EOF
	  PUSHJ P,ERROR		;CANT FAIL
	POP P,C			;GET CURRENT POSITION
	CAML C,B		;BEYOND END?
	JRST INTY8A		;YES.
	MOVE B,C		;GET COPY FOR THIS BUFFFER
	ADDI B,200		;AND UPDATE IT FOR THIS BUFFER
	SFPTR			; ..
	  PUSHJ P,ERROR		;CANT FAIL ..
	MOVEI B,IOMPGS(AC)	;GET PAGE NUMBER FROM IO CHANNEL NUMBER
	LSH B,11		;MAKE AN ADDRESS
	ANDI C,777		;WORD WITHIN PAGE
	ADDI C,(B)		;PLUS PAGE IN THIS FORK
	MOVSI A,(C)		;MAKES BLT "FROM" ADDRESS
	HRR A,IOBPT		;TO ADDRESS -1
	ADDI A,1		;TO ADDRESS
	MOVEI B,177(A)		;LAST ADDRESS
	BLT A,0(B)		;MOVE THE DATA
	SETZM IOCNT		;ASSUME COUNT WAS 200
	MOVEI A,200		;UPDATE ONE MORE BUFFER READ.
	ADDM A,IOBPT		; ..
	JRST INTTY9		;BUFFER MOVED. GO FINISH UP.

OUTMTA:	TROA PF,R.DIRN		;FLAG OUTPUT DIRECTION
INMTA:	TRZ PF,R.DIRN		;FLAG INPUT DIRECTION
	SKIPG B,IOCNT
	POPJ P,
	SETZM ERRCNT		;CLEAR RETRY COUNT
	MOVE C,IOBPT		;POINTER INTO BUFFER
	ADDM B,IOBPT		;UPDATE POINTER
	MOVN B,B		;IOWD FOR TRANSFER
	HRLI C,(B)
	MOVEM C,DMPLST		;PUT IT N COMMAND LIST
	SETZM DMPLST+1		;WITH TERMINATOR
	MOVEI B,DMPLST		;WHERE LIST STARTS
	SETZM MTDUMP		;CLEAR RECOVERY CELL
MTALP2:	MOVEM B,SPDELC		;INITIAL COMMAND
MTALP:	MOVE B,SPDELC		;NEXT OR CORRECTED IOL
	TRNE PF,R.DIRN		;OUTPUT?
	JRST DMP2		;YES. GO DO OUTPUT
	DUMPI
	  JRST EOFCHK
	JRST DMP3

MTALP1:	SETZM ERRCNT		;NO ERRORS. ENTER HERE FROM DUMP I/O
	SETOM MTDUMP		;FLAG DUMP MODE REQUEST
	JRST MTALP2		;GO TO IT

DMP2:	DUMPO
	JRST DMPOER
DMP3:	SETZM IOCNT		;OK
	JRST RECCH1		;UPDATE THE STATUS

EOFCHK:	CAIE A,IOX4		;EOF?
	JRST RECCHK		;NO
	MOVEI A,1B22
	IORM A,FLAGWD(BB)
	JRST DMP3

DMPOER:	PUSHJ P,TAPERR		;RETRY
	  JRST MTAERR		;TRIED TOO MANY TIMES.
	JRST MTALP		;TRY AGAIN

;INPUT ERROR OTHER THAN EOF FROM DUMPI

RECCHK:	MOVE A,JFNTAB(BB)	;GET THE JFN
	GDSTS			;GET THE TENEX STATUS
	TRNE B,722000		;ERRORS?
	JRST [	PUSHJ P,TAPERR	;YES. TOO MANY?
		  JRST MTAERR	;YES.
		JRST MTALP]	;NO. TRY AGAIN.
	TRNN B,10000		;RECORD LENGTH ERROR?
	PUSHJ P,ERROR		;SOME OTHER I/O ERROR I DON'T KNOW ABOUT
	SKIPG ERRCNT		;RETRIED THIS ONE YET?
	PUSHJ P,TAPERR		;NO. TRY IT OVER ONCE
	JRST RECCH2		;TOO MANY. IT'S FOR REAL (MAYBE OK, THO.)
	JRST MTALP		;TRY IT OVER ONCE.

RECCH2:	HLRZ C,C		;WORD COUNT
	SUB C,IOCNT		;WORDS NOT TRANSFERRED
	MOVNM C,IOCNT
MTAERR:	PUSHJ P,GST2		;CONVERT TO 10/50 ERROR BITS
	SKIPG IOCNT		;WAS ERROR REALLY TOO LONG?
	TRO A,1B21		;YES. TOO SHORT ISN'T AN ERROR ON 10/50
	HRRM A,FLAGWD(BB)	;STORE STATUS BITS.
	MOVE A,JFNTAB(BB)
	SETZ B,
	MTOPR			;CLR ERROR FLAGS
	POPJ P,

;HERE ON SUCCESS FOR DUMPI OR DUMPO, NO ERRORS. JUST UPDATE
; THE PHYSICAL UNIT STATUS BITS

RECCH1:	PUSHJ P,GST2		;UPDATE FLAGS
	HRRM A,FLAGWD(BB)	;IN CHANNEL CONTROL BLOCK
	POPJ P,0		;AND RETURN TO DUMP IO PROCESSOR

TAPERR:	AOS A,ERRCNT
	CAIL A,MAXERR		;TRIED ENOUGH?
	POPJ P,0		;YES
RETRY:	MOVE A,JFNTAB(BB)
	MOVEI B,7
	MTOPR			;BACKSPACE ONE RECORD
REPEAT 0,<			;THIS DOESN'T WORK BECAUSE
				;WON'T BE AT BOT AFTER BACKSPACE,
				; DUE TO 3 INCHES BLANK OFF BOT.
	GDSTS
	TRNE B,4000		;BEGINNING OF TAPE?
	JRST CPOPJ1		;YES. TRY AGAIN
	MOVEI B,7		;NO
	MTOPR			;BACK ONE MORE
	MOVEI B,6
	MTOPR			;AND FORWARD ONE
>
	JRST CPOPJ1		;GO TRY AGAIN
OUTT:	PUSHJ P,SETUP
	MOVE B,FLAGWD(BB)
	TLNE B,OOPENF		;OPEN FOR OUTPUT?
	JRST OUTTN		;YES
	SKIPN JFNTAB(BB)	;DOES IT HAVE JFN?
	TLNN B,OUFIRF		;OR IS IT FIRST TIME THROUGH?
	TLNN B,INITF		;AND IS IT INIT'ED?
	PUSHJ P,ERRCHN		;NO- ERROR
	SKIPN JFNTAB(BB)	;DOES IT HAVE JFN?
	JRST OUTTN		;NO, DON'T OPEN IT YET
	MOVEI B,1B20
	PUSHJ P,OPENX		;OPEN FOR OUTPUT
	MOVSI A,OOPENF
	IORM A,FLAGWD(BB)		;AND MARK IT

OUTTN:	MOVEI A,17
	AND A,FLAGWD(BB)	;MODE
	CAIL A,15		;IS IT A BUFFERED MODE?
	JRST OUTDMP		;NO
	HLRZ CC,BUFHTB(BB)	;OUTPUT BUFFER HEADER POINTER
	HRRZ A,FORTY
	CAIE A,0		;NEW RING?
	MOVEM A,0(CC)		;YES, STORE ADDRESS
	MOVSI A,OUFIRF		;FIRST TIME THROUGH FLAG
	TDNE A,FLAGWD(BB)	;IS IT?
	JRST OUTT2		;NO
	IORM A,FLAGWD(BB)	;YES
OUTT1:	MOVEI C,2
	MOVSI B,OUTBFF		;OUTBUF DONE FLAG
	XCTUU [SKIPN 0(CC)]	;OUTPUT BUFFERS SETUP?
	PUSHJ P,IOBUF		;NOT YET
	XCTUU [SKIPGE A,0(CC)]	;CLEAR RING USE BIT BY STEPPING
	JRST OUTT9		;BUFFER TO ITSELF, AND CLEAR BUFFER TOO

OUTT2:	PUSHJ P,SETOBF
	MOVE A,JFNTAB(BB)	;GET DESTINATION
	PUSHJ P,@OUTLST(AA)
	MOVE B,0(CC)		;CURRENT BUFFER ADDRESS
	HRRZ A,FLAGWD(BB)	;FILE STATUS
	MOVEM A,-1(B)		;STORE LATTER IN BEGINNING OF FORMER
	XCTUU [MOVE A,@(CC)]	;ADVANCE THE BUFFER
OUTT9:	XCTUU [HRRZM A,(CC)]
	PUSHJ P,INIBUF
	POPJ P,

OUTLST:	EXP OUTBYT		;DSK
	EXP ITRAP		;DRM
	EXP OUTMTA		;MTA
	EXP OUTBYT		;DTA
	EXP ITRAP		;PTR
	EXP OUTBYT		;PTP
	EXP ITRAP		;PTR
	EXP OUTASC		;LPT
	EXP ITRAP,ITRAP,OUTTTY	;CDR,CDP,TTY
	EXP OUTTTY,ITRAP	;TTP,TTR
	EXP OUTBYT		;NIL
	EXP OUTBYT		;NET
	EXP OUTBYT		;PLT

OUTDMP:	MOVE A,JFNTAB(BB)	;JFN
	CAIN AA,0		;DISK DEVICE TYPE?
	JRST OUTDM2		;YES- SIMULATE DUMPO BY SOUT
	HRRZ B,FORTY		;NO- USE DUMPO
	CAIGE B,20		;POINTER IN AC'S?
	ADDI B,ACS		;YES. POINT TO STORED ACS
	TRO PF,R.DIRN		;DIRECTION IS OUTPUT.
	MOVE C,DEVTBL(AA)
	TLNE C,MTADEV		;MAG TAPE?
	JRST MTALP1		;YES. GO TO MAG TAPE HANDLER
OUTDM1:	DUMPO
	  JRST OUDMER		;LOST. SEE IF RECOVERABLE
OUTDM3:	POPJ P,

OUDMER:	PUSHJ P,DTAX3Q		;SEE IF DTA SIZE ERROR.
	PUSH P,B		;YES. SAVE POSITION OF IOWD
	PUSH P,0(B)		;STASH OFFENDING IOWD
OUDME1:	MOVSI A,MAXIOL		;A REASONABLE TENEX LENGTH
	ADD A,0(P)		;WITHIN THAT FAR OF END?
	JUMPG A,OUDME2		;JUMP IF SO.
	MOVSI A,-MAXIOL		;MAKE A PARTIAL IOWD
	HRR A,0(P)		; ..
	MOVEM A,DMPLST		;STASH IT FOR DUMPO
	SETZM DMPLST+1		;AND CLEAR FOR A TERMINATOR
	MOVE A,JFNTAB(BB)	;GET THE JFN
	MOVEI B,DMPLST		;AND WHERE THE SHORT IOL IS
	DUMPO			;TRY IT AGAIN, SAM
	  PUSHJ P,ERROR		;IF THIS LOSES, GIVE UP.
	MOVE A,[XWD MAXIOL,MAXIOL]	;UPDATE THE POINTER
	ADDM A,0(P)		; ..
	JRST OUDME1		;AND TRY THE REST OF IT
OUDME2:	POP P,DMPLST		;GET BACK THE PARTIAL IOLIST LEFT
	MOVE A,JFNTAB(BB)	;GET THE JFN BACK
	HLLZ B,DMPLST		;DID IOL JUST NOW RUN OUT?
	JUMPE B,OUDME3		;IF SO, SKIP I/O
	MOVEI B,DMPLST		;POINT TO IO LIST
	DUMPO			;TRY TO OUTPUT REMAINING STUFF
	  PUSHJ P,ERROR		;CAN'T
OUDME3:	POP P,B			;GET THE POSITION IN ORIGINAL IOL
	ADDI B,1		;POINT AFTER TROUBLESOME GUY
	SKIPE 0(B)		;MORE TO DO YET?
	JRST OUTDM1		;YES. GO TRY NEXT IOWD
	JRST OUTDM3		;NO. QUIT.

OUTDM2:	HRRZ D,FORTY		;COMMAND LIST POINTER
OUTCML:	CAIGE D,20		;IN THE ACS?
	ADDI D,ACS		;YES. POINT TO STORED ACS
	MOVE C,(D)		;COMMAND LOOP
	JUMPE C,OUTDM3		;DONE ON ZERO COMMAND
	TLNE C,-1		;ZERO LEFT HALF MEANS GOTO
	JRST OUTDM4		;NO,REAL IO WORD
	MOVE D,C
	JRST OUTCML

OUTDM4:	HRRI B,1(C)		;FIRST LOCATION
	HRLI B,444400		;BINARY TRANSFER
	HLRO C,C		;WORD COUNT
	PUSH P,C		;SAVE NUMBER OF WORDS
	SOUT
	POP P,C			;GET NUMBER OF WORDS SENT
OUDM4L:	TRNN C,177		;WAS IT A MULTIPLE OF 200 OCTAL?
	AOJA D,OUTCML		;YES, GO GET NEXT COMMAND
	MOVEI B,0		;NO. SEND A ZERO
	BOUT			; ..
	SOJA C,OUDM4L		;AND SEE IF FULL BLK

;ASCII OUTPUT ROUTINES
OUTTTY:	LDB B,[POINT 4,FLAGWD(BB),35]	;IO MODE
	CAIL B,10		;BINARY?
	JRST OUTTTB		;YES.
OUTTTL:	SOSGE IOCNT		;COUNT DOWN THE BYTES
	POPJ P,0		;NO MORE IN BUFFER
	XCTMU [ILDB B,IOBPT]	;GET ANOTHER BYTE FROM USER BUFFER
	SKIPE B			;BUT DONT OUTPUT NULLS
	PUSHJ P,TTYBOU	;OUTPUT THE BYTE, CHECK ^O, INDICATE.
	JRST OUTTTL		;LOOP FOR MORE FROM BUFFER

OUTTTB:	RFMOD			;GET FILE MODE
	PUSH P,B		;SAVE IT
	TRZ B,3B29		;SET TO BINARY FOR OUTPUT
	SFMOD			; ..
OUTTBL:	SOSGE IOCNT		;COUNT OF BYTES
	JRST OUTTTX		;DONE
	XCTMU [ILDB B,IOBPT]	;GET A BYTE
	PUSHJ P,TTYBO1		;DO THE BOUT AT COMMON PC
	JRST OUTTBL		;LOOP THRU BUFFER
OUTTTX:	POP P,B			;GET BACK OLD TTY MODE
	SFMOD
	POPJ P,0

OUTASC:	SOSGE IOCNT		;COUNT BYTES
	POPJ P,			;NO MORE IN BUFFER
	XCTMU [ILDB B,IOBPT]	;FETCH BYTE FROM BUFFER, PTR IN HEADER
	JUMPE B,OUTASC		;IGNORE NULLS
	BOUT			;OUTPUT TO FILE.
	JRST OUTASC

IFN SAMFRK,<
OUTBYT:	MOVE 2,IOBPT
	MOVN 3,IOCNT
	JUMPGE 3,CPOPJ		;IT'S POSSIBLE THERE'S NOTHING TO DO
	SOUT
	MOVEM 2,IOBPT
	SETZM IOCNT
	POPJ P,
>

;PREPARE FULL BUFFER FOR EMPTYING

SETOBF:	MOVEI B,17
	AND B,FLAGWD(BB)	;MODE
	XCTUU [HLLZ C,1(CC)]	;GET BYTE SIZE BITS
	XCTUU [HRRZ D,1(CC)]	;FETCH RH OF BYTE POINTER
	UMOVE E,(CC)
	SUBI D,1(E)		;PTR TO ZERO'TH WORD OF DATA
	CAIN AA,0		;DISK?
	HRRZ D,DEVTB2(AA)	;YES. 10/50 ALWAYS COPIES 200 WDS.
;;;EXCEPT LAST BLOCK - ON CLOSE - IS SHORTER. SHOULD SIMULATE THAT.
;;; BY SKIPN FORTY, SKIPA???
	MOVEI A,1B31
	TDNE A,FLAGWD(BB)	;USER WANTS TO SPECIFY OWN COUNT?
	JRST SETOB1		;GO GET USER'S COUNT
	MOVEI F,0(D)		;SAVE UN-MULTIPLIED COUNT
	LDB A,[POINT 6,C,11]	;BYTE SIZE
	PUSH P,B		;SAVE B OVER DIVIDE
	PUSH P,A		;PUSH SIZE
	MOVEI A,44		;WORD LENGTH
	SKIPE 0(P)		;IN CASE CLOBBERED
	IDIV A,0(P)		;BYTES PER WORD
	POP P,B			;DISCARD BYTE SIZE
	POP P,B			;RESTORE B
	IMULI D,0(A)		;BYTE COUNT IN THOSE WORDS
SETOB2:	JUMPLE D,SETOB3		;PERHAPS NOTHING TO DO
	MOVEI C,1(E)		;CONSTRUCT BYTE POINTER FOR XFER
	MOVSI E,HASDIR+MTADEV	;USUAL CHECK FOR WORD TRANSFERS
	HRLI C,0700		;TRANSFER 7-BIT UNLESS
	CAIGE B,10		;MODE IS BINARY, OR
	TDNE E,DEVTBL(AA)	;DEVICE HAS DIRECTORY OR IS MAGTAPE
	HRLI C,4400		;IN WHICH CASE TRANSFER 36-BIT
	MOVEM C,IOBPT
	TLNE C,4000		;IF 36-BIT XFER,
	MOVE D,F		;USE UN-MULTIPLIED COUNT
SETOB3:	MOVEM D,IOCNT		;LEAVE COUNT FOR XFER ROUTINE
	POPJ P,

SETOB1:	UMOVE D,1(E)		;COUNT
	MOVEI F,0(D)
	TLNE C,4000		;BINARY?
	JRST SETOB2		;YES
	LDB A,[POINT 6,C,11]	;NEED TO CONVERT. GET BYTE SIZE.
	PUSH P,B		;SAVE B OVER DIVIDE
	PUSH P,A		;BYTE SIZE
	MOVEI A,44		;WORD LENGTH
	SKIPE 0(P)		;IN CASE OF JUNK
	IDIV A,0(P)		;BYTES PER WORD
	POP P,B			;DISCARD BYTE SIZE
	POP P,B			;RESTORE B
	IDIVI F,0(A)		;CONVERT BYTES TO WORDS
	SKIPE G
	AOS D,F			;AND FRACTIONS THEREOF
	JRST SETOB2


;PREPARE EMPTY BUFFER

INIBUF:	XCTUU [SETZM 1(A)]	;ZERO THE BUFFER
	MOVSI B,1(A)
	HRRI B,2(A)
	HLRZ C,(A)		;SIZE OF DATA AREA+1.
	ANDI C,377777		;CLEAR RING USE BIT
	CAIN AA,0		;IF IT'S A DISK
	MOVEI C,201		;FORCE CORRECT SIZE BUFFER
	CAILE C,1		;SHOULD BE NONZERO BUFFER SIZE
	CAILE C,2000		;BUT NOT TOO BIG
	PUSHJ P,ERRARG
	SUBI C,1
	PUSH P,C		;SAVE FOR LATER USE
	ADDI C,1(A)
	XCTUU [BLT B,(C)]
	MOVEI D,17
	AND D,FLAGWD(BB)	;MODE
	XCTUU [HLLZ B,1(CC)]	;GET SIZE BITS
	TLZ B,770077
	HRRI B,1(A)
	UMOVEM B,1(CC)		;INITIALIZE BYTE POINTER
	LDB C,[POINT 6,B,11]	;BYTE SIZE
	MOVEI A,44		;WORD SIZE
	PUSH P,B		;SAVE B OVER DIVIDE
	SKIPE C			;IN CASE OF JUNK IN HEADER
	IDIVI A,0(C)		;BYTES PER WORD
	POP P,B			;RESTORE B
	IMUL A,0(P)		;BYTES IN BUFFER
	UMOVEM A,2(CC)		;INIT BYTE COUNT
	MOVSI E,HASDIR+MTADEV	;SEE IF 36-BIT XFER POSSIBLE
	HRLI B,0700		;7-BIT UNLESS...
	CAIGE D,10		;BINARY MODE, OR
	TDNE E,DEVTBL(AA)	;DIRECTORY DEVICE OR MAGTAPE
	HRLI B,4400		;IN WHICH CASE 36-BIT
	MOVEM B,IOBPT
	POP P,A			;BUFFER LENGTH
	TLNN B,4000		;SMALL BYTES?
	IMULI A,5		;YES, 5 PER WORD
	MOVEM A,IOCNT
	POPJ P,

URELEA:	PUSHJ P,SETUPG
	JRST MRETN		;NOTHING TO RELEASE

	PUSHJ P,URELR		;DO THE RELEASE
	JRST MRETN

URELR:	SKIPN DEVNAM(BB)
	POPJ P,
	LDB AA,PDVNUM		;GET DEVICE TYPE CODE
	SETZM IOCNT
	PUSHJ P,UCL1K		;CLOSE FILE, KEEPING JFN
	MOVE A,JFNTAB(BB)
	CAIE A,PRIJFN		;REAL JFN?
	CAIN A,PROJFN		; ..
	JRST UREL2		;NO
	MOVE A,JFNTAB(BB)	;GET JFN BACK
	JUMPE A,UREL2
	RLJFN
	PUSHJ P,ERROR

UREL2:	HLLZS FLAGWD(BB)	;CLEAR INIT BITS.
	MOVS A,DEVNAM(BB)	;GET SWAPPED DEVICE NAME
	CAIN A,'TTY'		;CONTROLLING TTY?
	PUSHJ P,TTYSTS		;YES. SET UP FOR NORMAL INIT BITS
	SETZM CHTABS(BB)
	MOVSI A,CHTABS(BB)
	HRRI A,CHTABS+1(BB)
	BLT A,CHTABS+NTABS-1(BB)
	POPJ P,

IRESET:	SETZM USRENB		;CLEAR USER-REQUESTED INTERRUPTS
	PUSHJ P,SETPSI	;AND ADJUST PSI SYSTEM ACCORDINGLY
	PUSHJ P,NOCTRO	;CLEAR CONTROL-O FLAG
	MOVEI BB,NTABS		;CHANNEL 1
	PUSHJ P,URELR		;RELEASE IT
	ADDI BB,NTABS
	CAIE BB,20*NTABS
	JRST .-3		;NEXT CHANNEL
REL0:	MOVEI BB,0		;CHANNEL 0
	PUSHJ P,URELR		;RELEASE IT
	POPJ P,

SUBTTL ENVIRONMENT STUFF. SAVGET.

RUN:	PUSHJ P,IRESET		;RELEASE ALL THE CHANNELS
	TROA PF,R.RUNU		;DENOTE GETSEG, NOT RUN
GETSEG:	TRZ PF,R.RUNU		;DENOTE RUN, NOT GETSEG
	PUSHJ P,REL0		;RELEASE CHANNEL 0
	HLRZM CAC,MTDUMP	;STASH THE CCL OFFSET
	UMOVE A,@PDL		;GET RETURN INSTRUCTION
	LSH A,-30		;SEE IF IT'S A HALT
	CAIN A,2542		; ..
	TRO PF,R.RHLT		;YES. REMEMBER THAT.
	MOVEI AA,1(CAC)		;POINTER TO NAME IN ARG LIST
	UMOVE D,(AA)
	HRROI E,FILNM7
	MOVEM E,JBLOCK+4
	PUSHJ P,SIXTO7
	UMOVE D,-1(AA)		;DEVICE NAME
	HRROI E,DEVNM7
	MOVEM E,JBLOCK+2
	MOVEI B,NSPDDV-1	;NUMBER OF SPECIAL DISK DEVICES
	CAMN D,SPDDVT(B)	;CHECK FOR MATCH
	  JRST RUN11B		;HANDLE SPECIAL DEVICE
	SOJGE B,.-2		;LOOP IF MORE TO LOOK AT
	JRST RUN11		;HANDLE STD DEVICE
RUN11B:	CAMN D,SPDSYS		;CHECK SPECIFICLY FOR SYS:
	TRO F,R.SYS		;SET ON BIT FOR IT (SYSTEM NAMES)
	HRRO D,SPDDVN(B)	;GET ASCII NAME POINTER
	MOVEM D,JBLOCK+3	;SAVE FOR GTJFN
	MOVE D,[ASCIZ /DSK/]	;DEVICE STRING
	MOVEM D,DEVNM7		;SAVE IT
	JRST RUN12		;AND SKIP

RUN11:	PUSHJ P,SIXTO7		;PUT IN DEVICE NAME FROM USER
	UMOVE B,3(AA)		;PPN FROM USER
	PUSHJ P,CHKDIR		;HANDLE SIXBIT DIRECTORY NAMES
	JUMPLE B,RUN11A		;SELF IF .LE. 0
	TLZ B,1			;ALLOW PROJECT 0 OR 1
	HRROI A,DIRNAM		;STORE DIRECTORY NAME
	MOVEM A,JBLOCK+3	;ARG TO GTJFN
	DIRST			;USER EXIST?
RUN11A:	  SETZM JBLOCK+3	;NO. TRY IN OWN DIRECTORY

	;FALL THRU

RUN12:	HRROI E,EXT7		;POINT TO EXTENSION STORAGE
	MOVEM E,JBLOCK+5	;FOR GTJFN, THOUGH DON'T KNOW EXT YET

	MOVSI A,100000
	MOVEM A,JBLOCK
	MOVE A,[XWD 377777,377777]
	MOVEM A,JBLOCK+1
	TRZ PF,R.FAIL		;FLAG FIRST TIME THRU LOOKUP PROCESS
RUN12A:	XCTUU [HLLZ D,1(AA)]	;GET EXTENSION
	JUMPE D,RUN19		;NONE THERE- TRY DEFAULTS
	TRNN PF,R.RUNU		;GETSEG?
	JRST RUN19		;YES. IGNORE SUPPLIED EXT.
	PUSHJ P,RUN15		;USE GIVEN EXT
	  JRST RUN13		;SUCCESS- FOUND IT
	TROE PF,R.FAIL		;FAILED. FIRST PASS?
	JRST MRETN		;NO, NO SUCH FILE
	SETZM JBLOCK+3		;TRY CONNECTED DIRECTORY
	JRST RUN12A		;LOOP BACK AROUND.

;HERE FOR DEFAULT EXTENSION(S)

RUN19:	PUSHJ P,RUN08		;TRY TO GET EXTENSION .SHR
	  JRST RUN13		;SUCCESS
	PUSHJ P,RUN09		;NO GOOD- TRY FOR .HGH
	  JRST RUN13		;SUCCESS
	PUSHJ P,RUN10		;TRY FOR .SAV
	JRST [	TRNE PF,R.RUNU	;FOUND .SAV - GETSEG OR RUN?
		JRST RUN18	;RUN. LOAD WHOLE THING.
		JRST RUN13]	;GETSEG. JUST HIGH PART.
GETFAL:	TROE PF,R.FAIL		;SKIP IF HAVEN'T TRIED OWN DIR YET.
	JRST RETZER		;RUN LOSES IF NO .SAV EITHER
	TRZ F,R.SYS		;NOW NOT FROM SYS
	SETZM JBLOCK+3		;OWN DIRECTORY IS DEFAULT
	JRST RUN19		;TRY AGAIN

;HERE AFTER GTJFN SUCCEEDS

RUN13:	MOVEM A,JFNTAB
	TRNE PF,R.RUNU		;RUN UUO? (NOT GETSEG)
	JRST RUN23		;YES
	PUSHJ P,DOGTSG		;DO THE PAGE TRANSFERS
	  JRST RETZER		;WEREN'T ANY IN HIGH SEGMENT
	JRST RUN24		;OK, GO FINISH UP

RUN23:	UMOVE B,0(AA)		;GET SIXBIT PROGRAM NAME
	PUSH P,B		;SAVE IT
	PUSH P,JOBERR		;AND ERROR COUNT
	HRLI A,400000		;CURRENT FORK, THIS JFN
	GET
	MOVEI A,400000		;THIS FORK
	GEVEC			;GET ENTRY VECTOR
	XCTUU [HRRM B,JOBSA]	;STORE STARTING ADDRESS
	POP P,JOBERR		;RESTORE ERROR COUNT
	POP P,A			;NAME OF PROGRAM
	TRNE F,R.SYS		;FROM SUBSYS DIRECTORY?
	SETNM			;YES. UPDATE SYSTEM TABLES
RUN24:	MOVE A,JFNTAB
	RLJFN			;TRY TO RELEASE JFN
	  JFCL			;WON'T RELEASE IF SSAV FILE
	TRNE PF,R.RUNU		;WAS THIS A RUN UUO?
	JRST RUN21		;YES
	UMOVE B,400003		;GETSEG ONLY CHANGES JOBHRL
	HLRZS B			;SET TO TOP OF THAT K OF CORE
	TRNE B,-1		;UNLESS THERE ISN'T ONE
	TRO B,401777		;HIGH SEG, ONE K.
	UMOVEM B,JOBHRL
	MOVEM B,JBHRL
	JRST RUN14

RUN21:	PUSHJ P,SETVES
	XCTUU [HLRZ A,JOBCOR]
	CAIGE A,JOBDA		;SHOULD THERE BE A LOW SEG TOO?
	JRST RUN14		;NO
	MOVSI D,(SIXBIT/LOW/)	;YES- GET IT
	HRROI E,EXT7
	PUSHJ P,SIXTO7
	MOVEI A,JBLOCK
	SETZ B,
	GTJFN
	  JRST RUN20		;NO GOOD- CAN'T FIND IT
RUN18:	MOVEM A,JFNTAB
	UMOVE B,0(AA)		;GET SIXBIT PROGRAM NAME
	PUSH P,B		;SAVE IT
	PUSH P,JOBERR		;AND ERROR COUNT
	HRLI A,400000
	GET
	MOVE A,JFNTAB
	RLJFN			;TRY TO RELEASE JFN
	  JFCL			;WON'T RELEASE IF SSAV FILE
	POP P,JOBERR		;RESTORE ERROR COUNT
	POP P,A			;AND PROGRAM NAME
	TRNE F,R.SYS		;A SYSTEM PROGRAM?
	SETNM			;YES. TELL MONITOR
	HRRZ A,JBREL		;GET CURRENT LOW SEG
	UMOVE B,JOBREL		;AND NEW ONE
	PUSHJ P,SHRINK		;REDUCE SEGMENT IF NEEDED
	HRRZ A,JBHRL		;ALSO CURRENT HIGH SEG
	UMOVE B,JOBHRL		;AND NEW ONE
	MOVEM B,JBHRL		;UPDATE PAT'S COPY.
	HRRZS B			;RIGHT HALF ONLY
	CAIL A,.S		;IF THERE IS A CURRENT ONE,
	PUSHJ P,SHRINK		;REDUCE IT AS NEEDED
	UMOVE A,JOBREL
	MOVEM A,JBREL

RUN14:	SETZ BB,
	PUSHJ P,UREL2		;RELEASE CHANNEL 0
	TRNN PF,R.RUNU		;WAS IT A RUN UUO?
	JRST MRETN2		;RETURN SKIPPING FROM GETSEG
	UMOVE A,JOBSA		;RUN GOES OFF TO PROG START ADR
	ADD A,MTDUMP		;PLUS USER'S CCL OFFSET
	UMOVEM A,JOBSA		;UPDATE JOBSA BY OFFSET
				;;;IF OFFSET OVER 1, MEDDLING...
	HRRM A,(P)
	JRST MRETN

RUN08:	MOVSI D,(SIXBIT/SHR/)
	JRST RUN15
RUN09:	MOVSI D,(SIXBIT/HGH/)
	JRST RUN15
RUN10:	MOVSI D,(SIXBIT/SAV/)
RUN15:	HRROI E,EXT7
	PUSHJ P,SIXTO7
	MOVEI A,JBLOCK
	SETZ B,
	GTJFN
	  AOS 0(P)		;FAILED
	POPJ P,			;SUCCESSFULLY GOT JFN

RUN20:	SETZ BB,
	PUSHJ P,UREL2		;RELEASE CHANNEL 0
	JRST MRETN		;TAKE ERROR EXIT

;SHRINK A SEGMENT. A/ OLD WORDS TOP, B/ NEW WORDS TOP.
SHRINK:	JUMPE A,CPOPJ		;IN CASE OLD VALUE MISSING
	CAIG A,(B)		;OLD REALLY BIGGER?
	POPJ P,0		;NO. RETURN.
	PUSH P,A		;BE TRANSPARENT
	PUSH P,B
	PUSH P,D
	CAIL A,400000		;OLD IN HISEG?
	CAIL B,377777		;YES, NEW IN LOW SEG?
	SKIPA			;NO, BOTH IN SAME SEG.
	MOVEI B,377777		;YES, DONT SHRINK HIGH INTO LOW.
	MOVEI D,(A)		;COPY OLD SIZE
	LSH D,-11		;CONVERT TO PAGE NUMBERS
	LSH B,-11
	SETO A,			;REMAP FROM NULL-SPACE
	TLOA B,400000		;THIS FORK. SKIP.
	PMAP			;PAGE TO REMOVE
	CAILE D,(B)		;REMOVED ALL INTERVENI.G?
	AOJA B,.-2		;NOT. REMOVE ONE MORE
	POP P,D			;RESTORE ACS.
	JRST BAPOPJ		;AND RETURN.

;SUBROUTINE TO GET HIGH SEGMENT PAGES INTO FORK
;SKIPS IF THERE ARE ANY PAGES IN HIGH SEG

DOGTSG:	TRZ PF,R.PAGX		;NO HIGH PAGES SEEN YET.
	MOVSI A,(1B1)		;FLAG WANT A NEW FORK
	CFORK			;GET ONE
	  PUSHJ P,ERROR		;SHOULD BE ABLE TO.
	MOVE F,A		;HOLD FORK NUMBER
	HRLZ A,F		;FORK TO GET INTO
	HRR A,JFNTAB		;JFN OF CHANNEL ZERO
	GET			;GET THE FILE
	MOVEI G,400		;PAGE OF HIGH SEG
DOGSL1:	MOVSI A,0(F)		;FORK GOTTEN INTO
	HRR A,G			;PAGE NUMBER
	RPACS			;PAGE EXIST?
	TLNN B,(1B5)		; ..
	JRST [SETO A,		;NO. REMOVE CORRESPONDING PAGE IN THIS
		JRST DOGS1B]	; FORK'S SPACE
	TRO PF,R.PAGX		;YES. AT LEAST ONE PAGE EXISTS
	TLNN B,(1B10)		;PRIVATE MEMORY?
	JRST DOGS1A		;NO. CAN COPY VIA RMAP.
	MOVE B,[XWD .S,PATSPG]	;YES. PUT IT INTO SCRATCH PAGE
	MOVSI C,(1B2)		;MAKE INDIRECT POINTER FOR READ
	PMAP			; ..
	MOVEI C,0(G)		;PAGE IT'S GOING TO.
	HRLI C,PATSPG		;FROM SCRATCH PAGE
	LSH C,11		;WORDS, NOT PAGES.
	MOVEI B,777(C)		;TO END OF PAGE
	BLT C,0(B)		;MOVE IT.
	JRST DOGSN1		;ON TO NEXT PAGE.
DOGS1A:	RMAP			;GET HANDLE ON PAGE
DOGS1B:	MOVE B,G		;PAGE IN THIS FORK
	HRLI B,.S		;THIS FORK HANDLE
	MOVSI C,120400		;ACCESS IS R,X,CW
	PMAP			;GET THE PAGE
DOGSN1:	CAIGE G,PATPAG-1	;THROUGH ALL PAGES UP TO PAT?
	AOJA G,DOGSL1		;NO, GET ANOTHER ONE.
	HRRZ A,F		;INFERIOR FORK NAME
	KFORK			;KILL IT OFF.
	TRNE PF,R.PAGX		;WERE THERE ANY PAGES?
	AOS 0(P)		;YES. SKIP RETURN.
	POPJ P,0		;RETURN FROM DO GETSEG ROUTINE

;COPY VESTIGAL JOB DATA AREA FROM HISEG TO LOSEG

SETVES:	MOVSI B,-NVSTIG
	UMOVE C,400000(B)
	XCT VESTIG(B)
SETVS1:	AOBJN B,.-2
	UMOVE B,JOBHRL
	MOVEM B,JBHRL
	POPJ P,

VESTIG:	UMOVEM C,JOBSA
	UMOVEM C,41
	UMOVEM C,JOBCOR
	JRST [	XCTUU [HRRZM C,JOBREN]
		HLRS C		;REL TOP OF HIGH SEG
		TRNE C,-1	;IF THERE IS ANY
		TRO C,401777	;TOP OF THE K IN HIGH SEG
		UMOVEM C,JOBHRL	;STORE IT IN LOW JOB DATA AREA
		JRST SETVS1]
	UMOVEM C,JOBVER
NVSTIG==.-VESTIG

;COPY VESTIGAL JOB DATA AREA FROM LOSEG TO HISEG

MAKVES:	MOVSI B,-NVSTIG
	XCT VESTG2(B)

MAKVS2:	UMOVEM C,400000(B)

MAKVS1:	AOBJN B,.-2
	POPJ P,

VESTG2:	UMOVE C,JOBSA
	UMOVE C,41
	UMOVE C,JOBCOR
	JRST [XCTUU [HLL C,JOBHRL]
		XCTUU [HRR C,JOBREN]
		JRST MAKVS2 ]
	UMOVE C,JOBVER


;CALLI 0 RESET HANDLER

RESET:	MOVE 2,[XWD -20,JFNTAB]

RS3:	MOVE 1,(2)		;GET JFN FOR CHANNEL 0
	JUMPE 1,RS2		;DOES IT HAVE  ONE?
	CAIE A,PRIJFN
	CAIN A,PROJFN		;DON'T CLOSE PRIMARY I/O
	JRST RS2
	CLOSF			;YES
	MOVE 1,(2)
	RLJFN
	JFCL

RS2:	ADDI 2,NTABS-1
	AOBJN 2,RS3		;NOW DO IT FOR CHANNELS 1-17

	MOVE 1,[XWD CHTABS,CHTABS+1]
	SETZM -1(1)
	BLT 1,CHTEND-1		;CLEAR FILE DATA AREA
	XCTUU [HLRZ A,JOBSA]
	XCTUU [HRRM A,JOBFF]
	PUSHJ P,TTBFIN		;CLEAR TTCALL INPUT BUFFER
	PUSHJ P,SETPSI		;SET UP THE PSI SYSTEM
	JRST MRETN

CORE:	SKIPE CAC		;0 ARG GIVES FREE CORE, ERROR RETURN
	PUSHJ P,COREUU
	SKIPA
	AOS 0(P)		;OK RETURN, R2
	MOVEI A,PATLOC		;RETURN HOW MUCH HE CAN HAVE
	LSH A,-^D10		;IN K
	JRST STOTAC		;RETURN IT IN THE AC

COREUU:	TLNN CAC,-1		;ANY CHANGE TO HIGH SEGMENT?
	JRST COREU4		;NO
	HLRZ B,CAC
	TRO B,1777
	HRRZ C,JBHRL
	CAIN C,0		;NONE?
	MOVEI C,377777		;YES. PRETEND WORD BEFORE POSSIBLE TOP
	HRRZ D,JBREL
	CAIG D,400000		;MAX OF JOBREL , 400000
	MOVEI D,400000
	CAIG B,(D)		;NEGATIVE HISEG LENGTH?
	JRST FLUSHI		;YES
	CAIG B,(C)		;MORE THAN BEFORE?
	JRST COREU2		;NO
	PUSHJ P,CCLEAR		;CLEAR MAP FOR NEW CORE
	JRST COREU3
COREU2:	HRRZ D,JBREL
	ADDI D,(B)
	CAILE D,-1		;DO THE TWO OVERLAP?
	POPJ P,			;YES, R1
	MOVEI A,(C)		;GET OLD WORD SIZE
	PUSHJ P,SHRINK		;REMOVE PAGES IF NEEDED.
	JRST COREU3		;ON TO CHECK LOW SEG.

CCLEAR:	CAIGE B,2(C)		;REALLY GROWING
	POPJ P,			;NO SAME AS OLD
	PUSH P,B
	PUSH P,C		;SAVE ARGS
	LSH C,-11		;PAGE # OF OLD HIGH
	LSH B,-11		;PAGE # OF NEW HIGH
	MOVNI D,1(B)		;COMPUTE DISTANCE
	ADDI D,1(C)		; ..
	HRLZS D			;NEGATIVE COUNT IN LH
	HRRI D,1(C)		;FIRST TO THROW AWAY
CCLRLP:	SETO A,			;ARG FOR REMOVING PAGES FROM MAP
	MOVE B,D		;PAGE NUMBER IN RH
	HRLI B,400000		;THIS FORK
	PMAP			;MAKE SURE SLOT EMPTY
	AOBJN D,CCLRLP		;ALL PAGES IN NEW CORE AREA
	POP P,C
	POP P,B
	POPJ P,

FLUSHI:	HRRZ A,JBHRL		;OLD HIGH SEG SIZE
	MOVEI B,.S-1		;NEW SIZE IS ZERO.
	PUSHJ P,SHRINK		;SHRINK THE HIGH SEGMENT
	SETZ B,

COREU3:	MOVEM B,JBHRL
	XCTUU [HRRM B,JOBHRL]

COREU4:	TRNN CAC,-1		;ANY CHANGE TO LOW SEG?
	JRST CPOPJ1		;NO
CORU10:	HRRZ B,CAC
	TRO B,1777
	HRRZ C,JBREL
	CAIL B,PATLOC		;ARG OK?
	POPJ P,

	MOVEM B,JBREL
	XCTUU [HRRM B,JOBREL]	;NEW JOBREL
	HRRZ B,JBREL		;NEW JOBREL
	CAIG B,(C)		;MORE THAN BEFORE?
	JRST COREU7		;NO

	PUSHJ P,CCLEAR		;CLEAR MAP FOR NEW LOW SEG AREA

COREU6:	JRST COREU9

COREU7:	MOVEI A,0(C)		;NEW LOW SEG
	PUSHJ P,SHRINK		;ADJUST SEGMENT SIZE
COREU9:	JRST CPOPJ1

	XLIST			;DONT LIST LIT STATEMENT WHICH IS BIG
	LIT			;REDUCE WORKING SET IF LUCKY
	LIST			;LIT IS TO REDUCE WORKING SET IF LUCKY

SUBTTL ONCE AND OTHER RARE ROUTINES

MLON


;FIRST TIME INITIALIZATION

ONCE:	MOVE A,20		;REFERENCE PAGE 0 TO CREATE IT IF NEEDED
	MOVE A,1777		;AND PAGE 1 ( A WHOLE K)
	MOVE A,[XWD TSLOC,TSLOC+1]
	SETZM -1(A)
	BLT A,CLRTOP
	MOVSI PF,L.DBUG		;CLEAR ALL FLAGS BUT THIS ONE
	ANDM PF,PFLAGS		; ..
	MOVSI PF,L.ONCE		;AND SET THIS ONE, BEEN THRU ONCE CODE
	IORB PF,PFLAGS		;AND LOAD FLAGS INTO AC.
	GJINF			;GET THESE ONLY ONCE
	MOVEM C,MYJOBN
	MOVEM B,MYPPN		;LOGGED-IN DIR AS PPN
	UMOVE A,JOBREL
	JUMPN A,ONCE1		;SETUP?
	MOVE A,[XWD 400000,400]	;NO, IS THERE A READABLE PAGE 400?
	RPACS
	TLNE B,(1B2)
	PUSHJ P,SETVES		;YES,SETUP JOB DATA AREA FROM VESTIG
	MOVEI C,PATPAG-1	;SCAN MAP TO FIND HIGHEST USED PAGE
	XCTUU [SKIPE JOBHRL]	;HIGH SEG?
	MOVEI C,377		;YES, SCAN DOWN FROM HISEG
	MOVSI A,400000
	HRRI A,0(C)
	RPACS
	TLNN B,(1B2)		;IS PAGE READABLE?
	SOJG C,.-3		;NO
	MOVEI A,0(C)		;THIS IS HIGHEST PAGE
	LSH A,^D9
	HRRZ B,JOBCOR		;HIGHEST LOAD ADDRESS
	CAIGE A,0(B)		;MAX OF THAT AND HIGHEST PAGE
	MOVEI A,0(B)
ONCE1:	TRO A,1777		;1K PAGES
	UMOVEM A,JOBREL
	MOVEM A,JBREL
	UMOVE A,JOBS41		;SAVED CONTENTS OF 41
	XCTUU [SKIPN 41]	;41 NEEDS SETUP?
	UMOVEM A,41		;YES

	UMOVE A,JOBHRL
	CAIE A,0		;DON'T CHANGE IF NO HISEG
	TRO A,1777		;1K PAGE
	UMOVEM A,JOBHRL
	MOVEM A,JBHRL
	PUSHJ P,SETPSI		;SET UP PSEUDO INTERRUPT SYSTEM
	MOVEI A,101		;CONTROLLING TERMINAL
	RFCOC			;SEE WHAT ECHOING OF CONTROLS IS SET AT
	TRNN B,4000		;HAS USER REQUESTED ^L BE INDICATED?
	TLO PF,L.INDF		;YES. CARRY THAT DATUM AROUND IN FLAGS
IFN FTSTAT,<
	MOVSI A,100001		;GET THE STATISTICS FILE
	HRROI B,[ASCIZ /<SYSTEM>PA1050.STATISTICS;1/]
	GTJFN
	  JRST NOSTAT		;HASN'T BEEN MADE ON SYS
	PUSH P,A		;SAVE JFN
	MOVEI B,302000		;OPEN THAWED, READ, WRITE
	OPENF
	  JRST [POP P,A		;CAN'T OPEN IT. RELEASE JFN
		RLJFN		; ..
		  JFCL		;REALLY CAN'T. IGNORE.
		JRST NOSTAT]	;AND SKIP THIS
	POP P,A			;GET THE JFN
	MOVSI A,(A)		;PAGE 0 OF THE FILE
	MOVE B,[.S,,STATPG]	;STATISTICS PAGE IN THIS FORK
	MOVSI C,140000		;R/W ACCESS
	PMAP			;MAKE THEM EQUIVALENT
	AOS SL.ONC		;COUNT MAPPING IN THE PAGE, ABOUT SAME
				; AS USER FIRST CALLING PAT.
NOSTAT:>			;END OF STATISTICS OPENER
	TIME			;SYSTEM UPTIME
	MOVEM A,ITIME1		;SAVE FOR USE IN MSTIME
	SETO 2,
	MOVEI 4,0
	ODCNV			;TIME OF DAY IN SECONDS
	MOVEI A,(D)		; TO A
	IMULI A,^D1000		;IN MILLISECONDS
	MOVEM A,ITIME2		;SAVE FOR MSTIME
	MOVEM PF,PFLAGS		;STASH PF IN CORE ON EXIT FROM ONCE
	POPJ P,0		;AND RETURN FROM ONCE-ONLY ROUTINE

;DEBUG$G AFTER LOADING SETS UP SO SYSTEM'S PAT WONT BE LOADED.

DEBUG:	MOVE P,PATSTK		;SET UP A STACK POINTER
	PUSHJ P,SETCV		;SET COMPATIBILITY VECTOR
	SETOM INPAT		;FLAG FOR UUO PROCESSOR
	MOVSI PF,L.DBUG		;SET FLAG NOT TO GRAB ^C INT
	IORB PF,PFLAGS		;IN CORE AND AC FLAG WORDS
	PUSHJ P,ONCE		;SET UP TEMP STORAGE AND PSI SYS
	SETZM INPAT		;NOT PROCESSING IN PAT NOW
	JRST DDTLOC		;GO TO DDT

SETCV:	MOVEI A,.S		;THIS FORK
	MOVE B,[XWD EVECL,EVEC]	;SIZE AND LOCATION OF COMPAT VECTOR
	MOVE C,[XWD MONUUO,MONUPC] ;PLACE FOR MONITOR TO STASH UUO, PC
	SCVEC			;SET COMPATIBILITY VECTOR
	POPJ P,0		;RETURN

;PRODUCE <SUBSYS>'S SHARE FILE OF THIS CODE


MAKEPF:	RESET			;CLEAR THE WORLD
	MOVE P,PATSTK		;NEED A STACK HERE
	PUSHJ P,CLRPSI		;MAKE SURE NO LEFTOVER INTS
	MOVEI 1,400000
	MOVE 2,[XWD EVECL,EVEC]	;EXEC WILL SCVEC FROM THIS EVEC
	SEVEC			; WHEN IT BRINGS IN PA1050 ON A UUO
	MOVSI 1,(1B0+1B17)	;OUTPUT+SHORT FORM
	HRROI 2,[ASCIZ /PA1050.SAV;A220100/]
	GTJFN
	PUSHJ P,ERROR
	MOVEM A,JFNTAB		;PRESERVE OVER TYPEOUT
	TMSG < SAVED VERSION >	;COMMENT COMPLETED
	MOVEI A,101
	MOVE B,PVLOC		;TYPE VERSION IN OCTAL
	MOVEI C,10
	NOUT			;ON TTY
	  JFCL
	TMSG < AS FILE$ >
	MOVEI A,101
	HRRZ B,JFNTAB
	MOVE C,[211112,,110011]
	JFNS			;TYPE FILE NAME
	MOVE A,JFNTAB
	HRLI 1,400000		;THIS FORK,
	HLRE 2,SJBSYM	;GET LENGTH OF SYMBOL TABLE
	MOVNS 2			;POSITIVE LENGTH
	ADDI 2,ENDFF		;PLUS WHERE THEY START IS END OF SYMS.
	LSH 2,-11		;BEGINNING OF THAT PAGE
	MOVNI 2,1(2)		;-<PAGE AFTER END>
	MOVSI 2,PATPAG(2)	;(PLUS START IS -LENGTH) TO LH
	MOVEI 3,PATLOC
	LSH 3,-^D9		;FIRST PAGE
	HRRI 2,120000(3)	;WITH READ AND EXECUTE ALLOW BITS
	MOVEI C,0		;DOCUMENTED TO WANT 0 IN C
	SSAVE			;CREATE SHARE FILE
	PUSHJ P,CRLF
	HALTF

;GET 10/50 .SHR TYPE FILE

GETSHR:	RESET			;CLEAR TENEX STUFF
	CALLI 0			;'FIRST' UUO
	MOVE P,PATSTK
	SETOM INPAT
	HRROI 1,[ASCIZ /
LOAD SHR FILE FROM /]
	PSOUT
	MOVSI 1,120003
	MOVE 2,[XWD 100,101]
	GTJFN
	PUSHJ P,ERROR
	MOVE 2,[XWD 440000,200000]
	OPENF
	PUSHJ P,ERROR
	MOVEI 7,400000		;HIGH SEGMENT ADDRESS
GSHR1:	BIN
	JUMPN 2,GSHR3		;IF NON-0, CAN'T BE END OF FILE
	GTSTS
	TLNE 2,1000
	JRST GSHR2
	SETZ 2,			;NOT EOF, STORE THE 0
GSHR3:	MOVEM 2,0(7)
	AOJA 7,GSHR1

GSHR2:	CLOSF
	PUSHJ P,ERROR
	PUSHJ P,SETVES		;SETUP VESTIGAL DATA
	MOVEI 1,400000
	HRRZ 2,JOBSA
	HRLI 2,<JRST>B53	;LH SPECIFYING 10/50 ENTRY VECTOR
	SEVEC
	SETZM INPAT
	HALTF

;SUBROUTINE SETPSI TO SET UP THE PSEUDO INTERRUPT SYSTEM, AND
; SET FOR ^O AS AN INTERRUPT.

SETPSI:	MOVEI A,.S		;THIS FORK
	DIR			;DISABLE INTERRUPT SYSTEM
	MOVE B,[XWD PSITAB,LEVTAB] ;COPY PURE TABLES TO
	SKIPN LEVTAB		; IMPURE AREA, FIRST TIME ONLY.
	BLT B,CHNTAB+^D35	;FIRST TIME. COPY IT.
	MOVE B,[XWD LEVTAB,CHNTAB] ;TELL MONITOR WHERE THEY ARE
	SIR			; ..
SPSCTO:	MOVSI A,17		;AND CONTROL O TO
	HRRI A,COPSIN		;ITS CHANNEL NUMBER
	ATI			; ..
	MOVEI A,.S		;THIS FORK
	MOVE B,ONCHNS		;CHANNELS ALWAYS DESIRED
	MOVE C,USRENB		;THOSE USER MAY WANT
	TRNE C,1B19		;PDL OV?
	TLO B,(1B9)		;YES
	TRNE C,1B23!1B22	;ILL MEM REF, NXM?
	TDO B,[EXP 1B16!1B17!1B18]
;	TRNE C,1B26		;CLOCK FLAG
;	TLO B,(1B14)		;TIME OF DAY? *** NOT YET IMPL
	TRNE C,1B29		;FOV?
	TLO B,(1B7)		;YES
	TRNE C,1B32		;AR OV?
	TLO B,(1B6)		;YES.
	AIC			;TURN ON THOSE CHANNELS
	ANDCA B,ALLCHN		;TURN OFF UNSELECTED ONES FROM ABOVE
	DIC			; ..
	EIR			;AND ENABLE THE INTERRUPT SYSTEM
	POPJ P,0		;RETURN FROM SETPSI

ONCHNS:	EXP <1B<COPSIN>>!<1B<CCPSIN>>!1B11!1B15!1B22	;^O,IO ERR, ILL INST, NXPAGE
;AND MASK OF ALL THAT MIGHT WANT TO BE ON
ALLCHN:	EXP <1B<COPSIN>>!<1B<CCPSIN>>!1B6!1B7!1B9!1B11!1B14!1B15!7B18!1B22

CLRPSI:	MOVEI A,.S		;THIS FORK
	CIS			;CLEAR WAITING INTS
	DIR			;DISABLE INT SYSTEM
	SETO B,			;ALL CHANNELS
	DIC			;DISABLE ALL CHANNELS
	MOVEI A,.S		;THIS FORK
	SETZB C,B		;CLEAR COMPATIBILITY VECTOR
	SCVEC			;SO WILL GET NEW ONE AFTER LOADING
				;AND NOT CONFUSE NON-1050 PROGRAMS
	POPJ P,0		;AND RETURN FROM CLRPSI

PSITAB:
				;LEVTAB
	EXP RETSAV		;STORAGE FOR CHANNEL 1 PC
	0
	0
				;CHNTAB
	0			;CHANNEL 0
	0			;CHANNEL 1
	0			;CHANNEL 2
	0			;CHANNEL 3
	0			;CHANNEL 4
	0			;CHANNEL 5
	XWD 1,OVINT		;OVERFLOW ON CHANNEL 6
	XWD 1,FOVINT		;FLOATING OVERFLOW ON CHANNEL 7
	0			;CHANNEL 8
	XWD 1,PDLINT		;PDL OVERFLOW ON CHANNEL 9
	0			;EOF ON CHANNEL 10
	XWD 1,IOERR		;IO DATA ERROR (11)
	0			;CHANNEL 12
	0			;CHANNEL 13
	0			;CHANNEL 14
	XWD 1,INSINT		;ILLEGAL INST, CH 15
	XWD 1,MEMINT		;CHANNEL 16 ILLEGAL READ
	XWD 1,MEMINT		;CHANNEL 17 ILLEGAL WRITE
	XWD 1,MEMINT		;CHANNEL 18 ILLEGAL EXECUTE
	0			;CHANNEL 19 SUBSIDIARY FORK TERM
	0			;CHANNEL 20 MACHINE SIZE ERROR
	0			;CHANNEL 21 TRAP TO USER
	XWD 1,NXPINT		;CHAN 22, NONEXISTENT PAGE
	0			;CHANNEL 23
	0			;CHANNEL 24
	0			;CHANNEL 25
	0			;CAHNNEL 26
	0			;CHANNEL 27
	0			;CHANNEL 28
	0			;CHANNEL 29
COPSIN==.-PSITAB-3		;CHANNEL FOR CONTROL O
	XWD 1,CTOINT		;CHANNEL 30
CCPSIN==.-PSITAB-3		;CHANNEL FOR REENTER HANDLER
	XWD 1,CSTART		;CHANNEL 31
	0			;CHANNEL 32
	0			;CHANNEL 33
	0			;CHANNEL 34
	0			;CHANNEL 35
IFN .-PSITAB-^D36-^D3,<PRINTX PSITAB LENGTH WRONG>

;CREATE 10/50 SHR TYPE FILE

MAKSHR:	CALLI 0
	MOVE P,PATSTK
	SETOM INPAT
	PUSHJ P,MAKVES		;COPY JOB DATA AREA TO VESTIGAL AREA
	MOVEI A,400000
	UMOVE B,JOBSA
	HRLI B,1
	SEVEC			;SETUP ENTRR VECTOR

MAKS2:	HRROI A,[ASCIZ/
SSAV ON FILE = /]
	PSOUT
	MOVSI A,460003
	MOVE B,[XWD 100,101]
	GTJFN
	JRST MAKS2
	HRLI A,400000
	SETZ C,
	MOVE B,[XWD -300,400+520B26]
	SSAVE			;SSAVE PAGES 400 TO 677 WITH
				;READ, EXECUTE, COPY ON WRITE.
	PUSHJ P,CLRPSI		;NO PI'S OR COMPATIBILITY VECTOR
	SETZM INPAT
	HALTF

IFN SAMFRK,<			;THIS ONLY WRITTEN FOR SAME FORK

CSTART:
	SKIPN INPAT		;HAVE AC'S AND STACK?
	JRST CSTNIP		;NO. NOT IN PAT.
	PUSH P,A		;STASH AN AC
	HRRZ A,CSTOPC		;WHERE IS THE RETURN TO?
	CAIE A,TTYBPC		;TTY INPUT WAIT?
	JRST CSTRUN		;NO. RUNNING A UUO
	MOVE A,PDL		;YES. GET TTY UUO RETURN.
	SUBI A,1		;POINT BACK AT THE UUO
	MOVEM A,JOBOPC		;STORE FOR USER
	PUSHJ P,CSTADR		;FIND ADDRESS OF THE START/ETC
	HRRZM A,RETSAV		;DEBREAK TO HERE
	SETZM INPAT		;SNEAK OUT THE BACK DOOR OF PAT
	MOVSI 17,ACS		;GET THE USER'S AC'S BACK
	BLT 17,17		; ..
	DEBRK			;END OF INTERRUPT
CSTRUN:	PUSHJ P,CSTADR		;GET ADDRESS TO GO TO
	HRROM A,CSTFLG		;STORE IN FLAG FOR MRETN
	POP P,A			;RESTORE AC A
	DEBRK			;END OF INTERRUPT
CSTNIP:	MOVEM P,SEE		;SAVE USER AC P
	MOVE P,PSISTK		;SET UP A STACK
	PUSH P,A		;AND STASH ANOTHER AC
	HRRZ A,RETSAV		;WHERE WERE WE?
	CAIG A,ENDFF		;IN PAT?
	CAIGE A,PATLOC		; ..
	SKIPA A,RETSAV		;NO. DEBREAK ADDRESS TO JOBOPC
	MOVE A,MONUPC		;YES, IN SETUP OR EXIT. GET CALL ADDR.
	MOVEM A,JOBOPC		;STORE FOR USER TO SEE
	PUSHJ P,CSTADR		;GET PLACE TO GO TO
	MOVEM A,RETSAV		;AND MAKE DEBRK GO THERE
	POP P,A			;RESTORE AC'S USED
	MOVE P,SEE		; ..
	DEBRK			;AND GO TO NEW ADDRESS

CSTADR:	PUSH P,B
	PUSH P,C
	PUSHJ P,SETPSI		;IN CASE NOT ALL CHANNELS ON WHEN
	POP P,C			; USER TYPED ^C. GET THEM BACK
	POP P,B
	SKIPL A,CSTCOD		;GET THE CODE FROM EXEC
	JRST CSTAD1		;POSITIVE IS GOTO ADDR
	MOVMS A			;MAKE CODE POSITIVE
	CAILE A,CSTMCD		;OR OUT OF RANGE?
	MOVEI A,0		;YES. GO STRAIGHT TO TENEX DDT
	XCT [	MOVEI A,DDTLOC		;FORCE DDT
		HRRZ A,JOBSA		;START COMMAND
		HRRZ A,JOBREN		;REENTER COMMAND
		JRST [	HRRZ A,JOBDDT	;USER'S OWN DDT?
			TRNN A,-1	;ANYTHING THERE?
			MOVEI A,DDTLOC	;NO. USE TENEX DDT
			JRST CSTAD1]](A)
	TRNN A,-1		;AN ADDRESS AVAILABLE?
	MOVEI A,CSTADX		;NO.
CSTAD1:	PUSH P,E		;THIS AC NEEDS SAVING IF ON INT LVL
	PUSHJ P,NOCTRO	;CLEAR CONTROL-O ON MON-USER XITION
	POP P,E		;RESTORE AC E
	POPJ P,0		;RETURN ADDRESS IN A

CSTADX:	TMSG <$? NO START ADDRESS$>
	PUSHJ P,CLRPSI	;CLEAR PSI AND COMPAT VECTOR
	HALTF
	PUSHJ P,SETCV		;IF CONTINUED, PUT COMP VEC BACK
	PUSHJ P,SETPSI		;AND PSI SYSTEM.
	JRSTF @JOBOPC		;IF HE CONTINUES, GO HERE.
>				;END OF IFN SAMFRK

;UTILITY AND ERROR ROUTINES

TMSGQ:	PUSH P,A		;DON'T CLOBBER AC'S
	PUSH P,B
	MOVE B,@-2(P)
TMSG1:	ILDB A,B
	ADDI A,40
	CAIN A,"/"
	JRST TMSG2
	CAIN A,"$"
	MOVEI A,EOL
CPBOUT:	PBOUT
	JRST TMSG1
BAPOPJ:
TMSG2:	POP P,B
APOPJ:	POP P,A
	POPJ P,

ERRARG:	TMSG <$? BAD ARGUMENT FOR UUO CALL.$>
	JRST ERROR2

ERRCHN:	TMSG <$? I-O TO UNASSIGNED CHANNEL.$>
	JRST ERROR2

BUGSTP:	TMSG <$? COMPATIBILITY ERROR OR UNIMPLEMENTED FUNCTION$>
	JRST ERROR1

ERROR:	HRLOI B,.S
	SETZ C,
	MOVEI A,101
	ERSTR
	JFCL
	JFCL

ERROR1:	TMSG <$COMPATIBILITY LOCATION = >
	SOUT
	HRRZ B,(P)
	SUBI B,1
	MOVEI C,10
	NOUT
	JFCL
	SETZ C,

ERROR2:	TMSG <$USER LOCATION >
	JRST TRP2

ITRAP:	TMSG <$? ILLEGAL UUO AT LOCATION >
TRP2:	HRRZ 2,PDL
	SUBI 2,1
	MOVEI 3,^D8
	MOVEI 1,101
	NOUT
	  JFCL
	TMSG <$INSTRUCTION = >
	HRRZ 2,PDL
	UMOVE 2,-1(2)
	MOVEI 3,^D8
	MOVEI 1,PROJFN
	NOUT
	  JFCL
	TMSG <$>
	TRO PF,R.FERR		;FLAG ERROR TO PREVENT SUICIDE
	JRST EXIT2		;RESTORE ACS AND HALTF

ERRINT:	MOVEM A,IAC+1		;AN OV, FOV, PDL, OR MEMPRO INTERRUPT
	MOVEM B,IAC+2		; HAS HAPPENED INSIDE COMPATIBILITY
	MOVEM C,IAC+3
	MOVEI A,101
	HRROI B,[ASCIZ/
? UNEXPECTED INTERRUPT AT COMPATIBILITY LOCATION = /]
	SETZ C,
CSOUT:	SOUT
	HRRZ B,RETSAV		;SAVED PC
	MOVEI C,10		;OCTAL
	NOUT
	PUSHJ P,ERROR
	MOVEI B,37
CBOUT:	BOUT
	MOVE A,IAC+1
	MOVE B,IAC+2
	MOVE C,IAC+3
	DEBRK
	HALTF

;CALL SIXBIT TABLE HERE BECAUSE RARELY USED.
DEFINE CC (A,B)
<
	SIXBIT /A/ >

MCALT:			;TABLE FOR CALL FOR NEG CALLI'S
MCALLI				;SIXBIT NAMES OF NEGATIVE CALLS
NMCAL==.-MCALT			;NUMBER OF MINUS CALLS

CALLIT:
DEFINE CC (A,B)<
IFLE .-CALLIT-MXSIXB,<
	SIXBIT /A/
>>
PCALLI	;SIXBIT TABLE OF POSITIVE CALLI'S

NPCAL==.-CALLIT		;NUMBER OF POSITIVE CALLS

ILEGAL:	PUSHJ P,ITRAP		;ILLEGAL UUO CATCHER

SETUWP:	JRST MRETN2		;SKIP RETURN

EXIT:	TRZ PF,R.EXIT		;ASSUME EXIT 0,
	CAIE AC,0		;MONRET AS OPPOSED TO EXIT?
	TROA PF,R.EXIT		;YES. FLAG THAT.
	PUSHJ P,IRESET		;RELEASE IF CALLI 0,12

EXIT2:	MOVE A,PDL		;CALLING PC
	MOVEM A,JOBPD1		;TO STACK
	MOVEM A,JOBOPC		;AND TO JOBOPC EARLY, SINCE WILL KILL PAT.
	HRRZ A,JBHRL		;IS THERE A HIGH SEG?
	CAILE A,.S		; ..
	PUSHJ P,MAKVES		;YES. MAY BE LOADER EXIT. MAKE HIGH VEST
	PUSHJ P,NOCTRO		;CLEAR CONTROL O FLAG
	MOVEI A,PRIJFN		;CLEAR OUT THE MODE TO REASONABLE.
	RFMOD
	TRZ B,77B23+3B25+3B29	;FIELDS OF INTEREST
	TRO B,77B23+2B25+1B29	;NEW VALUES
	SFMOD			;SET THEM.
	TRNE PF,R.EXIT		;EXIT OR MONRET?
	JRST EXIT3		;MONRET. DON'T SAY "EXIT"
	TMSG <$EXIT.$^C$>
	TRNE PF,R.FERR		;FATAL ERROR?
	JRST EXIT3		;YES. LEAVE CORPSE FOR AUTOPSY
	PUSHJ P,CLRPSI		;CLEAR ALL PSI ACTIVITY
	MOVE 0,ACS		;RESTORE USER AC 0
	MOVEI A,SUICA-1		;STASH SOME AC'S
	PUSH A,ACS+A		;IN LOW CORE
	PUSH A,ACS+B
	PUSH A,ACS+C
	SETZM INPAT		;NOTE THAT NO LONGER HAVE A STACK
	MOVE A,[XWD ACS+D,D]	;RESTORE REST OF USER'S AC'S
	BLT A,17		; ..
	MOVE A,[XWD KSUIC,SUICID] ;MOVE THE SUICIDE CODE TO LOW CORE
	BLT A,ESUIC		; ..
	MOVSI B,.S		;THIS FORK FOR PMAP
	SETO A,			;TO NONEXISTENCE
	MOVSI C,-NPATPG		;LOOP CONTROL
	JRST SUICID		;AND GO DELETE PA1050 FROM MAP

EXIT3:	MOVEM P,EXITAD		;SAVE P STACK POINTER FOR CONTINUE
	PUSH P,[EXIT1]		;ADDRESS OF HALTF INSTRUCTION
	JRST MRETN		;RESTORE AC'S AND HALT

EXIT1:	HALTF
	MOVE P,EXITAD		;RESTORE STACK PTR ON CONTINUE
	MOVE PF,PFLAGS		;AND OUR FLAGS
	PUSHJ P,SETCV		;SET COMPATIBILITY VECTOR
	PUSHJ P,SETPSI		;IF CONTINUED
	JRST MRETN		;IF CONTINUED

KSUIC:				;CODE FOR SUICIDE OF PAT
PHASE 20			;WHERE TO MOVE IT TO
SUICID:	HRRI B,PATPAG(C)	;PAGE OF THIS FORK TO FLUSH
	PMAP			;DO IT.
	AOBJN C,SUICID		;FOR ALL OF PAT
	MOVE A,SUICA		;RESTORE LAST 3 ACS
	MOVE B,SUICB
	MOVE C,SUICC
	HALTF
	JRST .-1
ESUIC==.-1
SUICA:	BLOCK 1
SUICB:	BLOCK 1
SUICC:	BLOCK 1
DEPHASE

SETNAM:	MOVE A,CAC		;SIXBIT NAME OF USER PROGRAM
	SETNM
	JRST MRETN

;AFTER-LOADING FIXUP

LIN2:	MOVE P,PATSTK		;GET A STACK
	PUSHJ P,CLRPSI		;CLEAR COMPAT VECTOR AND PSI SYSTEM
	SETO 1,
	MOVSI 2,400000
LIN3:	PMAP			;FLUSH EVERYTHING NOT IN PAT
	MOVEI 4,0(2)
	CAIGE 4,PATPAG-1
	AOJA 2,LIN3
	HALTF

	XLIST			;LITERALS
	LIT			;HIGH CORE LITERALS
	LIST

FFF0:
FFF:	BLOCK 100		;PATCH SPACE
ENDFF:				;END OF EVERYTHING, USED BY MAKEPF,LINIT

IFN SAMFRK,<
	LOC 140			;IN LOW SEGMENT FOR FIXUPS
>

;START HERE AFTER LOADING

LINIT:!	RESET			;TURN OFF PI SYSTEM
	MOVEI A,.S		;CLOBBER THE PSI SYSTEM
	DIR			; DISABLE SYSTEM
	CIS			;CLEAR ANYTHING PENDING
	SETO B,			;ALL ONES
	DIC			;DISABLE ALL CHANNELS
	MOVE A,[JRST COMPAT]	;SHOULD BE FIRST WORD OF PROGRAM
	CAMN A,KEVEC-PATLOC+LODORG ;IS IT?
	JRST LIN0		;YES. OK.
	HRROI A,[ASCIZ /
? LOADING ERROR
/]
	PSOUT			;SOMEONE HAS CHANGED THE LOADER!
	HALTF
LIN0:!	MOVEI B,PATPAG		;PAGE WHERE PAT LIVES
	HRLI B,400000
	SETO A,
LIN1:!	PMAP			;CLEAR AREA TO PUT CODE
	ADDI B,1
	TRNN B,1000
	JRST LIN1
	MOVE A,[XWD LODORG,PATLOC]	;READY TO BLT THE CODE
	BLT A,ENDFF		;WHERE IT SHOULD END
	MOVE A,[KEVEC,,EVEC]	;MOVE LITERAL VECTOR TO RUNNING VECTOR
	MOVEI B,EVECL(A)	;END OF RUNNING VECTOR
	BLT A,-1(B)		;SEEMS TO BE ONLY WAY TO GET TO 700000.
	HLRE A,JOBSYM		;-LENGTH OF SYM TAB
	MOVMS A			;+ LENGTH OF SYM TAB
	HRLZ B,JOBSYM		;WHERE SYMTAB NOW STARTS
	HRRI B,ENDFF		;WHERE IT WILL START
	HRRM B,JOBSYM		;UPDATE JOBSYM ITSELF
	BLT B,ENDFF(A)		;MOVE THE SYMBOLS
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SUBSYS>UDDT.SAV/]
	GTJFN
	0
	HRLI 1,400000
	GET			;GET DDT
	MOVE 1,JOBSYM
	MOVEM 1,@DDTLOC+1	;SETUP DDT SYMTAB PTR
	MOVEM 1,SJBSYM	;STORE AT ENTRY VECTOR+DELTA TOO
	JRST LIN2		;COMPLETE FIXUP IN HIGH CORE

	XLIST			;LITERALS
	LIT
	LIST

	END LINIT
