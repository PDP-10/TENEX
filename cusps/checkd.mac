;<LIEB>CHECKD.MAC;2    30-MAY-75 15:29:08    EDIT BY LIEB

;CHANGE LABLES TO RUN ON V50 MACRO
;<LIEB>CHECKD.MAC;1    30-MAY-75 13:40:49    EDIT BY LIEB
;INTEGRATED SUMEX CHANGES FOR LPT ON JOB0 RUN ELIMINATED QUICK OPTION
;<SOURCES>CHECKD.FAI;8    20-NOV-72  0:09:44	EDIT BY WALLACE
;<SOURCES>CHECKD.FAI;7    22-SEP-72 14:35:28	EDIT BY MURPHY

;10 JAN 72, 1707:
;D. MURPHY

	TITLE CHECKD
	SUBTTL	R.S.TOMLINSON 30 SEPTEMBER 70
	SEARCH STENEX

; AC'S

A=1
B=2
C=3
D=4
XX=10
YY=11
XX=10
YY=11
AA=11   ;REGS FOR BSYS
BB=12
CC=13
DD=14
P=17

OPDEF 	CALL	[PUSHJ P,]
DEFINE	ERROR(S,X)<
JRST [	TMSG <S>
	X]>

DEFINE	TMSG(S)<
	HRROI B,[ASCIZ S]
	PUSHJ P,TMSGQ>

IFDEF LPTSW,<
DEFINE	LPMSG(S)<
	HRROI B,[ASCIZ S]
	PUSHJ P,LPMSGQ>
> 
IFNDEF LPTSW,<DEFINE LPMSG (S) <TMSG (S)>>

DEFINE TYPEM(S)<
	PUSHJ P,RPTERR
	HRROI B,[ASCIZ /S/]
	PUSHJ P,TMSGQ>

DEFINE TYPEN(S)<
	PUSHJ P,RPTERR
	MOVEI 1,37
	PBOUT
	HRROI B,[ASCIZ /S/]
	PUSHJ P,TMSGQ>


NBWTK==<NPGTK+43>/44	; BIT WORDS PER TRACK
NTRACK==HITRK-LOTRK		;NUMBER OF ALLOCATABLE TRACKS
NEWFB==4
DSKMSK==777774
DASIZ==2000
; BIT IN FACTSW INDICATING CHECKDSK FOUND ERRORS
;  (SET AT START OF CHECKDSK AND RESET AT FINISH IF NO ERRORS
;   DISCOVERED -
;   CURRENTLY ONLY SET FOR MDA )

CHKDSE==100000000000

; VARIABLES IN DIRECTORY

DIRECT=750000
	LOC 750000

DIRORG:	BLOCK 0		; ORIGIN
DIRLCK:	BLOCK 1		; DIRECTORY LOCK
DIRUSE: BLOCK 1		; DIRECTORY USE INDICATOR
DIRNUM:	BLOCK 1		; NUMBER OF THIS DIRECTORY
SYMBOT:	BLOCK 1		; SYMBOL TABLE BOTTOM
SYMTOP:	BLOCK 1		; SYMBOL TABLE TOP
DIRFRE:	BLOCK 7		; FREE STORAGE HEADER
FRETOP:	BLOCK 1		; CURRENT TOP OF FREE STORAGE AREA
DIRDPW:	BLOCK 1		; DEFAULT FILE PROTECTION WORD
DIRPRT:	BLOCK 1		; DIRECTORY PROTECTION WORD
DIRDBK:	BLOCK 1		; DEFAULT BACKUP SPECIFICATION
DIRGRP:	BLOCK 1		;GROUPS HAVING ACCESS TO THIS DIRECTORY
DIRSAV:	BLOCK 1		;A PLACE TO PUT POINTERS TO BE GC'ED
DIRDSK:	BLOCK 1		;LH-MAX ALLOCATION THIS DIRECTORY,
			;RH-CURRENT ALLOCATION
SPARE:	BLOCK 2		;LOCATIONS FOR ADDITIONAL VARIABLES
DIRLOC:	BLOCK 1		;  FOR SAVING LOCATION IN THE DIRECTORY
DIRINP:	BLOCK 1		; TEMP TO SAVE POINTER TO INPUT FOR LOOKUP
DIRINC:	BLOCK 1		; TEMP TO HOLD INCREMENT FOR SEARCHING
DIRMSK:	BLOCK 1		; TEMP TO HOLD MASK FOR LOOKUPS
DIRSCN:	BLOCK 1		; TEMP TO SAVE POINTER TO POINTER
DIFREE:	BLOCK 0		; BEGINNING OF FREE AREA


; VARIABLES IN SUBINDEX DIRECTORY BLOCK 0

DIRHTO==DIRDPW		; DIRECTORY NUMBER HASH TABLE ORIGIN
DIRHTL==DIRPRT		; DIRECTORY NUMBER HASH TABLE LENGTH

; PARAMETERS AND BITS PERTINENT TO DIRECTORIES

	LOC 0
	BLOCK 1		; THE HEADER, NOT REFERENCED SYMBOLICALLY
FDBCTL:!BLOCK 1		; LH ==> CONTROL BITS (SEE BELOW)
			; RH ==> LOCATION OF FILE NAME BLOCK
FDBEXT:!BLOCK 1		; LH ==> LOCATION OF EXTENSION BLOCK
			; RH ==> POINTER TO OTHER EXTENSIONS
FDBADR:!BLOCK 1		; THE FILE ADDRESS & CLASS FIELD
FDBPRT:!BLOCK 1		; FILE PROTECTION WORD
FDBCRE:!BLOCK 1		; CREATION DATE & TIME OF VERSION 1
FDBUSE:!BLOCK 1		; LH ==> LAST WRITER DIRECTORY NUMBER
			; RH ==> USE COUNT (+1 FOR EACH INDIRECT POINTER
			;  AND SAVED ENVIRONMENT)
FDBVER:!BLOCK 1		; LH ==> VERSION NUMBER
			;  THIS IS JOB NUMBER FOR TEMP FILES
			; RH ==> POINTER TO OTHER VERSIONS
FDBACT:!BLOCK 1		; ACCOUNT INFOR FOR CHARGING
			;  + FOR LOCATION OF STRING BLOCK
			;  - FOR NUMBER
FDBBYV:!BLOCK 1		; 0-5 ==> NUMBER OF VERSION TO RETAIN
			; 6-11 ==> LAST BYTE SIZE
			; RH ==> COUNT OF ACTUAL PAGES IN FILE
FDBSIZ:!BLOCK 1		; LENGTH OF FILE IN BYTES
FDBCRV:!BLOCK 1		; CREATION DATE AND TIME OF THIS VERSION
FDBWRT:!BLOCK 1		; DATE & TIME OF LAST WRITE
FDBREF:!BLOCK 1		; DATE & TIME OF LAST REFERENCE
FDBCNT:!BLOCK 1		; LH ==> COUNT OF WRITES
			; RH ==> COUNT OF REFERENCES
FDBBCK:!BLOCK 5		; WORDS FOR BACKUP SYSTEM
FDBUSW:!BLOCK 1		; USER SETTABLE WORD
FDBLEN:			; LENGTH OF FDB


; POINTERS TO THINGS IN FDB

PFILPC:	POINT 18,FDBBYV(A),35	; POINTER TO SIZE IN PAGES OF FILE
PFILBS:	POINT 6,FDBBYV(A),11	; POINTER TO LAST BYTE SIZE
PFILVC:	POINT 6,FDBBYV(A),5	; POINTER TO VERSION RETENTION COUNT

; BITS IN LH OF FDBCTL

FDBTMP==400000		; FILE IS TEMPORARY
FDBPRM==200000		; FILE IS PERMANENT
FDBNEX==100000		; NO EXTENSION FOR THIS FDB YET
			;  THE FILE DOES NOT REALLY EXIST
FDBDEL==040000		; FILE IS DELETED
FDBNXF==020000		; FILE DOES NOT EXIST (FIRST WRITE NOT COMPLETE)
FDBLNG==010000		; LONG FILE
FDBSHT==004000		; COMPRESSED PAGE TABLE
FDBENV==002000		; ENVIRONMENT FILE
FDBSUB==001000		; SUBROUTINE FILE
; SYMBOLS IN DIRECTORY DESCRIPTOR BLOCK

	LOC 0

	BLOCK 1		; HEADER NOT REFERENCED SYMBOLLICALLY
DDBNAM:!BLOCK 1		; LH ==> POINTER TO PASSWORD STRING BLOCK
			; RH ==> POINTER TO NAME STRING BLOCK
DDBMAX:!BLOCK 1		; MAXIMUM DISK STORAGE FOR THIS DIRECTORY
DDBLOG:!BLOCK 1		; TIME AND DATE OF LAST LOGIN
DDBPRV:!BLOCK 1		; PRIVILEGE BITS
DDBMOD:!BLOCK 1		; MODE BITS
DDBRES:!BLOCK 1		; SPECIAL RESOURCE INFORMATION
DDBNUM:!BLOCK 1		; LH ==> DIRECTORY NUMBER
			; RH ==> POINTER TO SPECIAL INFORMATION BLOCK
			; 0 MEANS NO SPECIAL INFO
DDBLEN:



	RELOC


; ********************
;	INITIALIZATION OF CONSTANTS AND INTERRUPTS
; ********************

START:	MOVE P,[IOWD 100,PDL]
	PUSHJ P,RESET1
	SETZM REBLDF
	GJINF
	MOVEM 3,JOBNO
	SETOM WHEEL
	MOVEI A,400000
	RPCAP
	TRNN B,600000
	SETZM WHEEL
	MOVE C,[1B0!1B3!1B18!1B19]
	EPCAP
	SKIPN WHEEL
	HALTF
REPEAT 0,<
	MOVE 1,[CHKDSE]		;TURN ON ERRORS FOUND
	MOVE 2,1
	SMON
>
	SETZM ERRORS		;NO ERRORS YET
	GDSKC
	MOVEM 1,ZUSED
	MOVEM 2,ZLEFT
;   CLEAR INSTRUMENTATION DATA
	SETZM I$ST1
	MOVE 1,[XWD I$ST1,I$ST1+1]
	BLT 1,I$ST2
;
;	INITIALIZE VARIABLES TO 0--THEY ARE ALL DEFINED IN A  CONTIGUIOUS
;	BLOCK THOUGH NOT RELATED
	SETZM BLKZRO
	MOVE 1,[XWD BLKZRO,BLKZRO+1]
	BLT 1,BLKZRX
;
	SETZM OPCNT	;# OF OUTSTANDING I/0 OPS
	SETZM NFRKS	;# OF ASYNC FORKS CREATED
	MOVEI 1,400000
	CIS
	EIR
;
	MOVE 2,[XWD 3,IODONE]   ;IIC ROUTINE
	MOVEM 2,CHNTAB+^D23
;
	MOVE 2,[XWD LEVTAB,CHNTAB]
	SIR
	MOVNI 2,1
	DIC
IFDEF LPTSW,<MOVE 2,[XWD 340707,710000]>
IFNDEF LPTSW,<MOVE 2,[XWD 300707,710000]>
	AIC			;ACTIVATE ALL ERROR OR SCREWUP CHANS
	SETOM PSIF		;TURN ON LOCAL PSI FLAG
IFDEF LPTSW,<
	MOVEI 1,101		;DEFAULT ERROR OUTPUT TO TTY
	MOVEM 1,LPT
>
	SETOM DETAIL		;DETAIL FOR JOB 0
	MOVE 1,JB0OPT		;SET UP OPTIONS FOR JOB0
	MOVEM 1,OPTION
;
	MOVE 1,[XWD 23,2]	;SUMMARY INT. ^S
	ATI
	SKIPN JOBNO		;IF JOB 0,
	JRST J0B		;DON'T ENABLE ^C INTERRUPT
	SETZM DETAIL		;DEFAULT NO DETAIL FOR NON JOB 0
	MOVE 1,DEFOPT		;SET UP NON JOB 0 DEFAULT OPTIONS
	MOVEM 1,OPTION
	MOVE 1,[XWD 3,1]
	ATI
; ********************
;	ASK FOR OPTIONS
; ********************

OPT5:
	TMSG </
OPTIONS (? FOR HELP) />
	SETZM 16	;CLEAR OPTION REGISTER
OPT2:
	PBIN		;GET CHARACTER
;		CONVERT LOWER-CASE TO UPPER-CASE
	CAIL 1,141
	CAIL 1,173
	SKIPA
	SUBI 1,40	;LOWER IS NOW UPPER
;
	MOVSI 3,-OPSIZ
OPT:
	CAMN 1,OPTBL(3)	;VALID CHARACTER
	JRST @OPTBL1(3)  ;YES--DO SOMETHING WITH IT
	AOBJN 3,OPT	;CONTINUE SEARCHING
	TMSG </  ?  />	;NOT VALID
	JRST OPT2

OPT4:		;RESOLVE OPTION CONFLICTS
	TDNE 16,BITS+REBLD	;FIX UP REBUILD-BIT TABLE OPTIONS
	JRST [TDZ 16,[U$+X$+C$+I$+M$+S$]
		TDO 16,[W$+F$]
		JRST .+1]
	TDNE 16,BITS+MAP	;MAP OPTION
	MOVE 16,[M$+U$]
	TDNE 16,BITS+INIT
	MOVE 16,[I$+U$]
;
	TDNN 16,BITS+USER
	TDO 16,BITS+WHOLE	;MUST BE FOR WHOLE DISK
	TDNE 16,BITS+WHOLE
	TDZ 16,BITS+USER
;
	TDNE 16,BITS+CHPT
	MOVE 16,BITS+CHPT
OPT11:
	MOVEM 16,OPTION		;SAVE OPTIONS
;
	TMSG </OPTIONS ARE: />
	MOVSI 3,-OPSIZ1
OPT10:
	TDNE 16,BITS(3)	;SUMMARIZE OPTIONS REQUESTED
	JRST [ MOVE 1,OPTBL(3)   ;GET CHARACTER
		PBOUT
		MOVEI 1," "
		PBOUT
		JRST .+1]
	AOBJN 3,OPT10
	TMSG </ AGREE?/>
	PUSHJ P,CONFRM
	JRST OPT5	;WASN'T CONFIRMED--START OVER
	TDNE 16,BITS+DTL
	SETOM DETAIL
	TDNE 16,BITS+SCAN
	PUSHJ P,SCN	;INIT SCAN FOR DISK ADDRESSES
	MOVE 16,OPTION
	TDNE 16,BITS+REBLD
	PUSHJ P,RBL	;INIT REBUILDING OF BIT TABLE
	JRST J0B

CONFRM:		;GET CONFIRMATION FROM USER
	PBIN
	CAIN 1,37
	JRST SKPRET
	MOVE 2,1	;SAVE CHARACTER
	MOVEI 1,37
	PBOUT
	CAIN 2,"y"
	JRST SKPRET	;LOWER-CASE Y OK TOO
	CAIE 2,"Y"
	POPJ P,
	JRST SKPRET


OPT1:
	IOR 16,BITS(3)	;SET OPTION
	JRST OPT2

OPT6:
	MOVEI 1,37	;HELP COMMAND
	PBOUT

	MOVSI 3,-OPSIZ1
OPT6A:
	MOVE 1,OPTBL(3)
	SKIPE 1		;PRINT DESCRIPTION ONLY
	PBOUT
	HRRO 1,OPTDES(3)	;PRINT DESCRIPTION
	PSOUT
	AOBJN 3,OPT6A
	JRST OPT5


; ********************
;	TABLES TO PROCESS OPTIONS
; ********************

OPTBL:
	0	;CONTROL ENTRY
	"W"	;WHOLE DISK
	"U"	;SINGLE USER
	0	;CONTROL ENTRY
	"F"	;FILE VERIFICATION TOO
	"D"	;DETAILED ERROR REPORT
	"S"	;SCAN FOR DISK ADDRESSES
IFDEF LPTSW,<"L"	;OUTPUT ERRORS TO LP1>
	0	;CONTROL ENTRY
	"R"	;REBUILD BIT TABLE
	"X"	;FIX A DIRECTORY
	"C"	;CHECKPOINT SYSTEM DIRECTORIES
	"I"	;INITIALIZE A DIRECTORY
	"M"	;MAP A DIRECTORY FOR DDT PROBING
OPSIZ1=.-OPTBL
	"?"	;HELP COMMAND
	","	;DELIMITER
	177	;RUBOUT--START OVER
	37	;CARRIAGE RETURN
OPSIZ=.-OPTBL

OPTBL1:		;ROUTINES TO HANDLE CHARACTER
	0
	OPT1	;W
	OPT1	;U
	0
	OPT1	;F
	OPT1	;D
	OPT1	;S
IFDEF LPTSW,<OPT1	;L>
	0
	OPT1	;R
	OPT1	;X
	OPT1	;C
	OPT1	;I
	OPT1	;M
	OPT6	;?
	OPT2	;,
	OPT5	;RUBOUT
	OPT4	;C/R

OPTDES:		;DECREIPTION FOR HELP
	[ASCIZ /OPTIONS INDICATING SCOPE
/]
	[ASCIZ /--WHOLE DISK
/]
	[ASCIZ /--SINGLE USER
/]
	[ASCIZ /OPTIONS CONCERNED WITH VERIFYING
/]
	[ASCIZ /--FILE VERIFICATION TOO
/]
	[ASCIZ /--DETAILED ERROR REPORT
/]
	[ASCIZ /--SCAN FOR DISK ADDRESSES
/]
IFDEF LPTSW,<[ASCIZ /--OUTPUT ERRORS TO LP1:
/]>
	[ASCIZ $OPTIONS TO FIX/MAINTAIN THE FILE SYSTEM
$]
	[ASCIZ /--REBUILD BIT TABLE
/]
	[ASCIZ /--FIX UP A DIRECTORY
/]
	[ASCIZ /--CHECKPOINT SYSTEM DIRECTORIES
/]
	[ASCIZ /--INITIALIZE A DIRECTORY
/]
	[ASCIZ /--MAP A DIRECTORY FOR DDT PROBING
/]

BITS:
	0
	XWD 400000,0	;WHOLE DISK
	XWD 200000,0	;SINGLE USER
	0
	XWD 100000,0	;FILE VERIFICATION
	XWD 40000,0	;DETAILED REPORT
	XWD 20000,0	;SCAN FOR DSK ADR
IFDEF LPTSW,<XWD 200,0	;OUTPUT ERRORS TO LINEPRINTER>
	0
	XWD 10000,0	;REBUILD BIT TABLE
	XWD 4000,0	;FIX A DIR
	XWD 2000,0	;CHECKPOINT SYS
	XWD 1000,0	;INIT A DIR
	XWD 400,0	;MAP A DIR

WHOLE=1
USER=2
FILE=4
DTL=5
SCAN=6
IFDEF LPTSW,<
LPTO=7
REBLD=11
FIX=12
CHPT=13
INIT=14
MAP=15
>
IFNDEF LPTSW,<
REBLD=10
FIX=11
CHPT=12
INIT=13
MAP=14
>
W$==400000000000
U$==200000000000
F$==100000000000
D$==40000000000
X$==4000000000
C$==2000000000
I$==1000000000
M$==400000000
S$==20000000000
IFDEF LPTSW,<L$==200000000>

IFDEF LPTSW,<JB0OPT:	W$+F$+D$+L$>
IFNDEF LPTSW,<JB0OPT:	W$+F$+D$>
DEFOPT: W$+F$
;********************
;	SET UP TO REBUILD BIT TABLE
; ********************

RBL:
	TMSG </BEGIN REBUILDING BIT TABLE
/>
	SETOM REBLDF
	MOVE 7,[HITRK*NSECTK]
BGN2:	SUBI 7,NSECTK
	MOVSI 6,-NPGTK		; PREPARE TO INDEX THRU PAGES THIS TRACK
BGN3:	HRRZ 1,6
	IMULI 1,NSECPG
	ADD 1,7
	DSKAS			;ASSIGN THE PAGE
	JFCL			;WHETHER OR NOT IT WAS ASSIGNED
	TLO 1,(1B0)		;NOW DEASSIGN IT, THUS CLEARING
	DSKAS			;THE ENTIRE BIT TABLE
	AOBJN 6,BGN3		; LOOP FOR ALL PAGES THIS TRACK
	CAMLE 7,[LOTRK*NSECTK]
	JRST BGN2
	POPJ P,

;********************
;	ROUTINE TO SET UP SCAN-FOR -DISK-ADDRESSES
; ********************
SCN:
	HRROI A,[ASCIZ /
ENTER DISC ADDRESSES /]
	PSOUT
J0A1:	HRROI A,[ASCIZ / FROM FILE: /]
	PSOUT
	MOVSI A,120003
	MOVE B,[XWD 100,101]
	GTJFN
	 JRST J0A1
	MOVEM A,DAJFN
	MOVE B,[XWD 70000,200000]
	OPENF
	JRST  [MOVE A,DAJFN
		RLJFN
		 JFCL
		JRST J0A1]
	MOVSI XX,-DASIZ
;
;	READ DISK ADDRESS --MUST BE LOGICAL ADDRESS--BIT 14 DOESN'T
;	HAVE TO BE SET
;	RUBOUT MAY BE USED TO CANCEL ADDRESS
;	END LIST BY TYPING ^Z
;	DASIZ (2000) ADDRESSES ARE ALLOWED
;
RDDALP:	MOVE A,DAJFN
	MOVEI C,10
	NIN			; READ A DISC ADDRESS
	 JRST RDDAX		; PROBABLE EXTRA TERMINATOR
	MOVEM B,DATAB+1(XX)
	BKJFN			; TRY TO GET TERMINATOR
	 JRST RDDAW		; CAN'T. ASSUME EOL
	BIN			; READ TERMINATOR
	CAIN B,177		; CHECK FOR RUBOUT
	 JRST [	HRROI A,[ASCIZ /XXX
/]
		PSOUT
		JRST RDDAV]
	MOVE A,DATAB+1(XX)
;;;	CADSK
	TLZ A,DSKMSK	;SAVE ONLY LOGICAL ADR
	TLO A,10	;TURN DISK ADDR BIT
	MOVEM A,DATAB(XX)
	AOBJP XX,.+1
	AOBJP XX,RDDAZ
RDDAV:	CAIE B,"Z"-100
	JUMPN B,RDDALP
	JRST RDDAW

RDDAX:	MOVE A,DAJFN
	GTSTS
	TLNE B,1000
	 JRST RDDAW
	BKJFN
	 JRST RDDALP
	BIN
	JRST RDDAV

RDDAZ:	HRROI A,[ASCIZ /
TABLE FULL./]
	PSOUT
RDDAW:	HLRES XX
	MOVNS XX
	SUBI XX,DASIZ
	HRLZM XX,DALIST
	MOVE A,DAJFN
	CLOSF
	 JFCL
	POPJ P,0
; ********************
;	MAIN CONTROL LOOP FOR CHECKING ENTIRE DISK
; ********************
J0B:	MOVEI A,37
	PBOUT
	MOVE 1,OPTION
;
;   INITIALIZE INFERIOR FORKS
	TDNN 1,[F$+S$]     ;ONLY START THEM IF NECESSARY
	JRST J0B1
	MOVN 5,NFKS
	TDNE 1,BITS+USER	;SINGLE USER?
	MOVN 5,NUFKS		;YES--CREATE LESS FORKS
	HRLM 5,NNFKS
	SETZM PTT	;ASSIGN PAGE FOR LONG FILE IB
	MOVE 5,NNFKS	;SCAN ALL FORKS
J0B2:
	SKIPE 1,FKHAND(5)   ;FORK ALREADY HERE?
	JRST [RFSTS
		SKIPL 1		;IS THERE A FORK TO KILL
		KFORK
		JRST .+1]
	MOVEI 4,0(5)	;INIT THE BUFFER THIS FORK IS TO DO I/O IN
	LSH 4,9
	SETZM PT(4)	;REF PAGE SO IT WILL BE IN FORK'S MAP
	SETZM FKOP(5)	;NO OPERATION TO DO YET
	MOVSI 1,640000	;START FORK,INDIRECT MAP THROUGH THIS FORK
	HRRI 1,STFRK   ;STARTING PC
	MOVEI 2,FKREG
	HRRZM 5,FKREG+10	;INITIAL PARAMETER TO FORK
	CFORK
	JRST J0B3	;ERROR CREATING FORK
	MOVEM 1,FKHAND(5)   ;SAVE FORK HANDLE
	MOVEI 2,FKBAS_-^D9	;UN-PMAP CERTAIN PAGES
	HRL 2,1			;I.E.--THE ONES PRIVATE TO FORK
	AOS NFRKS		;INCR # OF FORKS CREATED
	MOVNI 1,1
J0B4:
	PMAP
	ADDI 2,1		;NEXT PAGE
	MOVEI 4,0(2)
	CAIG 4,777
	JRST J0B4
	MOVE 1,FKHAND(5)		;CAN NOW START FORK
	MOVEI 2,STFRK		;ENTRY POINT
	SFORK
J0B3:
	AOBJN 5,J0B2
;
;
J0B1:
	MOVE 1,OPTION
IFDEF LPTSW,<
	TDNE 1,BITS+LPTO	;OUTPUT ERRORS TO LPT?
	CALL LPTINI		;YES, SET IT UP
>
	TDNE 1,BITS+CHPT	;CHECKPOINT OPTION?
	JRST CHKPT		;YES--DO IT
	HRROI B,[ASCIZ /<SYSTEM>DIRECTORY;1/]
	MOVSI 1,1
	GTJFN
	JRST BADER
	MOVEI B,302000
	OPENF
	JRST BADER1
	MOVEM A,FDJFN
	PUSHJ P,INIBTB
	PUSHJ P,SCANDI	;SCAN ALL DIRECTORIES
	PUSHJ P,RESET1
QUIT:	
	MOVEI 1,23	;^S
	DTI
	SKIPN JOBNO
	JRST QUIT1
	MOVEI 1,3	;^C
	DTI
QUIT1:
REPEAT 0,<
	MOVE 1,[CHKDSE]
	SETZ 2,
	SKIPN ERRORS
	SMON
>
IFDEF SUMEX,<
	MOVE 1,[CHKDSE]
	MOVE 2,1
	SKIPE ERRORS
	SKIPE JOBNO
	SKIPA
	SMON
>
;
	HALTF
	JRST .-1
;
;
BADER:
	HRROI 1,[ASCIZ /GTJFN/]
	SKIPA
BADER1:
	HRROI 1,[ASCIZ /OPENF/]	  ;PRINT ERROR MSGS FOR <SYSTEM>DIRRC
				  ;TORY FILE
	PSOUT
	HRROI 1,[ASCIZ / ON <SYSTEM>DIRECTORY;1 FAILED.
GET SOFTWARE HELP IMMEDIATELY.
/]
	PSOUT
	JRST QUIT
; ********************
;	CLEAN UP BEFORE EXITING
; ********************

RESET1:	MOVNI 1,1
	CLOSF
	0
	RLJFN
	0
	SETZM DEFVER
	MOVE A,[XWD DEFVER,DEFVER+1]
	BLT A,DEFEXT+4
	MOVE A,[XWD 377777,377777]
	MOVEM A,FILS
	MOVEI 1,101
	RFMOD
	TRO 2,770000
	SFMOD
	MOVEI A,-4
	KFORK
	POPJ P,

LEVTAB:	RET1
	RET2
	RET3

CHNTAB:	XWD 2,BADINT
	XWD 1,CONTC
	XWD 3,SUMINT
IFDEF LPTSW,<
	XWD 3,LPTINT
	REPEAT 44-4,<XWD 2,BADINT>
	>
IFNDEF LPTSW,<
	REPEAT 44-3,<XWD 2,BADINT>
>
; ********************
;	INTERRUPT HANDLER
; ********************

;	^S CAUSES CURRENT DIRECTORY TO BE PRINTED
SUMINT:	SKIPE PSIF		;IGNORE IF IN TRANSITORY STATE
	SKIPN CURDIR
	DEBRK
	PUSH P,1
	PUSH P,2
	PUSH P,3
	TMSG </WORKING ON USER />
	MOVEI 1,101
	MOVE 2,CURDIR
	DIRST
	JFCL
	MOVEI 1,11		;PUT OUT TAB
	PBOUT
	MOVEI 1,101
	MOVE 2,CURDIR
	MOVEI 3,^D8
	NOUT			;PUT OUT DIR NUM IN OCTAL
	JFCL
	MOVEI 1,37
	PBOUT
	POP P,3
	POP P,2
	POP P,1
	DEBRK

BADINT:	PUSH P,1
	PUSH P,2
	PUSH P,3
	TMSG </
UNEXPECTED INTERRUPT
/>
	POP P,3
	POP P,2
	POP P,1
	DEBRK			;IGNORE IT

CONTC:	SKIPN PSIF		;IF IN TRANSITORY STATE,
	DEBRK			;IGNORE IT
	PUSH P,1
	PUSH P,2
	PUSH P,3
	SKIPN LOCKED
	JRST CONTC1
	MOVE 1,[XWD 400000,DIRORG/1000]
	MOVSI 2,140000
	SPACS
	SETOM DIRLCK
	SETZM LOCKED
	MOVSI 2,100000
	SPACS
CONTC1:	TMSG </^C
/>
	JRST QUIT

IFDEF LPTSW,<
LPTINT:	PUSH P,1
	PUSH P,2
	PUSH P,3
	CALL LPTINI
	POP P,3
	POP P,2
	POP P,1
	DEBRK
>

;   HANDLE CHAN 23 INTERRUPTS CAUSED BY IIC FROM INFERIOR FORK
IODONE:
	PUSH P,1
	SETOM INTFLG	;SET FLAG FOR SCAN ROUTINE
	HRRZ 1,RET3		;GET RETURN ADDR
	TLNE 1,10000		;IN USER MODE?
	JRST IODN1		;NO--JUST GO BACK
	CAIL 1,WAIT1		;AT WAIT INSTRUCTION?
	CAILE 1,WAIT2
	SKIPA
	JRST [MOVEI 1,OPCMLA    ;YES--GET CHECKD GOING AGAIN
		HRRM 1,RET3
		JRST .+1]
IODN1:
	POP P,1
	DEBRK
;
SCANDI:MOVEI B,1
	MOVE 16,OPTION		;SINGLE USER
	TDNE 16,BITS+USER
	JRST SCNUSR		;YES--FIND WHO
SCNDIL:	MOVE A,[POINT 7,DIRNAM]
	DIRST
	JRST SCNDI1
	MOVEM B,CURDIR
;
	HRRZ A,B
	PUSHJ P,SCANFD
	MOVE B,CURDIR
SCNDI1:
	MOVE 16,OPTION
	TDNE 16,BITS+USER
	JRST SCNDI3
	CAIG B,1000
	AOJA B,SCNDIL
	MOVE 16,OPTION
	TDNE 16,BITS+FILE   ;CAN'T SUMMARIZE IF FILES WEREN'T EXAMINED
	PUSHJ P,FINBTB	;SUMMARIZE AVAIL PAGES
;
SCNDI3:
	HRROI 1,[ASCIZ /
NO ERRORS
/]
	SKIPE ERRORS		;PRINT FINAL MESSAGE
	HRROI 1,[ASCIZ /
ERRORS FOUND
/]
	PSOUT
;
	SKIPN 2,OFFCNT		;SEE IF ANY DIRS WERE FIXED (PAGE CNT)
	JRST SCD14
;
	MOVEI 1,101	;PRINT THE # OF DIRS
	MOVE 3,[XWD 100003,12]
	NOUT
	JFCL
	HRROI 1,[ASCIZ / DIRECTORY/]
	CAIE 2,1		;GET CORRECT MESSAGE
	HRROI 1,[ASCIZ / DIRECTORIES/]
	PSOUT
	HRROI 1,[ASCIZ / HAD TOTAL PAGE COUNTS CORRECTED
/]
	PSOUT
;
SCD14:
	SKIPN 2,NOTBT		;ANY DA'S NOT IN BIT TABLE??
	POPJ P,

	MOVEI 1,101
	MOVE 3,[XWD 100005,12]
	NOUT
	JFCL
	HRROI 1,[ASCIZ / DISK ADDR'S WERE NOT IN BT--CORRECTED
/]
	PSOUT
	POPJ P,0


SCNUSR:
	TMSG </USER: />
	MOVE 3,USPTR	;SET UP STRING POINTER TO SAVE NAME
SCNU1:
	PBIN		;GET CHAR FROM USER
	CAIE 1,37	;END?
	JRST SCNU2
	SETZM 1		;FAKE AN ASCIZ
	IDPB 1,3
	MOVE 2,USPTR
	STDIR		;CONVERT TO DIR #
	JRST SCNU3	;NO GOOD
	JRST SCNU3
	HRRZ 2,1	;GET DIR # ONLY
	MOVEI 1,">"
	DPB 1,3	;USED BY FIX-UP OPTIONS
	MOVEM 3,MESPTR		;SAVE FOR POSSIBLE MESSAGE.TXT STRING
	JRST SCNDIL

SCNU2:
	CAIN 1,177
	JRST SCNU3
	IDPB 1,3	;SAVE CHAR
	CAME 3,[POINT 7,USRNAM+14,27]  ;TOO BIG?
	JRST SCNU1
SCNU3:
	HRROI 1,[ASCIZ / ?
/]
	PSOUT
	JRST SCNUSR
; ********************
;	GIVEN A DIRECTORY,CALL ROUTINES THAT VERIFY IT
; ********************

SCANFD:HRRZS A
	PUSHJ P,SETFD		; MAP THE APPROPRIATE DIRECTORY
	MOVE A,[POINT 7,DIRNAM]
	MOVEM A,DIRPTR
	MOVE B,CURDIR
	DIRST
	JFCL
	MOVEI B,0
	IDPB B,A
	MOVE A,DIRPTR
	MOVEM A,DEFDIR
	SETZM DIRERR	;ERROR PRINTOUT FLAG
	SETZM DEFNAM
	SETZM NBAD
	SETZM PAGCNT	;INIT COUNT OF FILE PAGES
	MOVE B,ERRORS		;SAVE CURRENT ERROR COUNT TO SEE IF THIS
			;GOT THE ERROS LATER
	MOVEM B,OERROR


	PUSHJ P,.SETVR	;GO VERIFY DIRECTORY STRUCTURE

	SKIPE NBAD
	JRST SCAN4
;
	MOVE 16,OPTIONS	;SEE IF FILES SHOULD BE VERIFIED
	TDNN 16,BITS+FILE
	TDNE 16,BITS+SCAN	;CAN JUST SCAN FOR IB'S
	SKIPA
	JRST SCAN4	;DONT DO IT
	MOVE D,SYMBOT
SCAN1:	CAMGE D,SYMTOP
	JRST SCAN2
	PUSHJ P,OPRNDN		;WAIT FOR I/O TO COMPLETE

SCAN4:
	MOVE 1,[XWD 400000,DIRORG/1000]
	MOVSI 2,140000
	SPACS
	MOVEI 1,400000
	DIR
;
;	SEE IF WE WANT TO CORRECT TOTAL PAGE COUNT
	MOVE 16,OPTIONS
	TDNE 16,BITS+FILE	;MUST HAVE GONE THROUGH ALL FILES
	JRST [TDNE 16,BITS+SCAN	;VERIFYING--NOT SCANNING
		JRST .+1
		MOVE B,ERRORS	;ANY ERRORS ENCOUNTERED?
		CAME B,OERROR; IF NOT, CAN FIX UP PAGE COUNT
		JRST .+1
		MOVE 16,PAGCNT
		HRRZ 15,DIRDSK
		CAME 16,15
		AOS OFFCNT	;JUST KEEP TRACK OF IT
		HRRM 16,DIRDSK	;PUT IN CORRECTED COUNT
		JRST .+1]
;
	SETOM DIRLCK
	SETZM LOCKED
	EIR
	MOVE 1,[XWD 400000,DIRORG/1000]
	MOVSI 2,100000
	SPACS
	POPJ P,

SCAN2:	HLRO A,DIRORG(D)
	ADDI A,DIRORG+1
	MOVEM A,DEFNAM
	HRRZ A,DIRORG(D)
	TRNE A,700000
	AOJA D,SCAN1
	PUSH P,D
	MOVE D,A
;	VERIFY ALL FILES WITH THIS FILE NAME
	PUSHJ P,SCAN3
;
	POP P,D
	AOJA D,SCAN1
SCAN3:	SKIPN D
	POPJ P,0
	HLRO A,DIRORG+FDBEXT(D)
	ADDI A,DIRORG+1
	MOVEM A,DEFEXT
	PUSH P,D
	PUSHJ P,SCAN7
	POP P,D
	HRRZ D,FDBEXT+DIRORG(D)
	JRST SCAN3

SCAN7:	SKIPN D
	POPJ P,
	HLRZ A,DIRORG+FDBVER(D)
	HRRM A,DEFVER
	PUSH P,D
	PUSHJ P,BUILD	;LOOK AT ALL DISK ADDRESS ASSOCIATED
			;WITH THIS FILE AND VERIFY THEM
	POP P,D
	HRRZ D,FDBVER+DIRORG(D)
	JRST SCAN7


; ********************
;	GIVEN A DIRECTORY,MAP IT INTO THIS PROGRAM
; ********************

SETFD:	MOVE B,FDJFN
	MOVMS A
	LSH A,3
	HRL A,B
	MOVE B,[XWD 400000,DIRORG/1000]
	MOVSI C,140000
SETFDL:	PMAP
	MOVSI C,100000
	AOS B
	CAMN B,[XWD 400000,DIRORG/1000+10]
	ADDI A,10000-10
	CAMGE B,[XWD 400000,DIRORG/1000+20]
	AOJA A,SETFDL

	MOVE 16,OPTIONS
	TDNE 16,BITS+MAP	;MAP IN DIRECTORY ONLY
	JRST SETFD6	
	TDNE 16,BITS+INIT	;INIT THIS DIRECTORY?
	JRST SETFD8		;YES

;
	SKIPN JOBNO
	SETOM DIRLCK
SETFDP:	SETZM PSIF
	AOSE DIRLCK
	JRST SETFD1		;DIRECTORY IS LOCKED ALREADY
SETFD3:
	SETOM DIRFRE+1		;MAKE SURE FREE-SPACE LOCK IS OK
	SETOM LOCKED
	SETOM PSIF
	MOVE 1,[XWD 400000,DIRORG/1000]
	MOVSI 2,100000
	SPACS
	POPJ P,

SETFD1:
	SETOM PSIF
	TDNN 16,BITS+FIX	;IN BUSINESS OF FIXING DIRECTORIES?
	JRST SETFD4		;NO--WAIT FOR UNLOCK
	MOVEI A,101
	MOVE B,CURDIR
	DIRST
	JFCL
	HRROI 1,[ASCIZ / LOCKED. UNLOCK?/]
	PSOUT
	PUSHJ P,CONFRM
	JRST SETFD4	;WASN'T CONFIRMED
	SETOM DIRLCK	;UNLOCK IT
	JRST SETFDP

SETFD4:
	SETOM PSIF
	MOVEI A,^D2000	;WAIT AND TRY AGAIN
	DISMS
	SETZM PSIF
	AOSE DIRLCK	;FINALLY GET UNLOCKED?
	JRST SETFD4	;NO
	JRST SETFD3

SETFD6:		;GET DDT AND TRANSFER CONTROL TO IT
	JRST QUIT
;			(TEMPP--USER CAN ENTER DDT MANUALLY)

SETFD8:
	SETZM PSIF	;DONT ALLOW INTRPTS
	PUSHJ P,INIBLK	;INITIALIZE DIRECTORY
	POPJ P,0
; ********************
;	GIVEN AN FDB,EXAMINE ITS INDEX BLOCK AND DISK ADDRESSES
; ********************

BUILD:	SKIPN A,FDBADR+DIRORG(D)
	POPJ P,			; NO DISC ADDRESS
	;  INSTRUMENTATION-COUNT # OF FILES SEEN
	AOS I$FSEN	;FILES SEEN
;
	PUSH P,D
	MOVE B,FDBCTL+DIRORG(D)		;STOP EVERYTHING IF LONG FILE
	TLNE B,FDBLNG
	JRST [CALL OPRNDN
		MOVE D,0(P)	;RESTORE FDB POINTER
		CALL SETNM	;RESTORE NAME POINTERS
		JRST .+1]
	SETZM NBAD
	MOVE B,[XWD NBAD,NBAD+1]
	BLT B,NIBT
;		CHECK NXF FLAG
	MOVE B,FDBCTL+DIRORG(D)
	TLNE B,FDBNEX
	POPJ P,0		;IGNORE FILES THAT SYSTEM ALSO IGNORES
	SETOM PAGNN
	PUSHJ P,MRKBTB		; CHECK AND MARK BIT TABLE
	JRST BADPT1	;INDEX BLOCK ADR UNUSABLE
;
	MOVE C,FDBCTL+DIRORG(D)
	TLNE C,FDBLNG
	JRST BUILNG
	MOVEI 3,REGFIL		;PASS ADDRESS OF COMPL ROUTINE
	PUSHJ P,MRKPT		; CHECK AND MARK PT
BUILDX:	POP P,D
	POPJ P,0		;EXIT WITH AN OPERATION IN PROGRESS
;

; ************************
;	EXIT ROUTINE FOR COMPLETION OF IO--PRINTS ANY ERRORS IN FILE
; *************************
;
;	ASSUMES STACK CONTAINS FDB OFFSET INTO DIRECTORY
BADPT1:
;   INSTRUMENTATION--COUNT FILES COMPLETED
	AOS I$FCMP
;
	POP P,D
	HRRZ C,FDBBYV+DIRORG(D)   ;GET PAGE CNT OF FILE
	ADDM C,PAGCNT		;GET TOTAL
	SKIPG A,NBAD		; ANYTHING BAD HERE?
	POPJ P,
BAD1:	;DISK I/O ERROR ON INDEX BLOCK
;	MAIN INDEX BLOCK OF REGULAR FILE,OR
;	SUB-INDEX BLOCK OF LONG FILE
	MOVE B,NBPT
	ADDM B,NBPTT	;;;;CONDENSE INTO ONE MSG
BAD2A:	;DISK I/O ERROR ON MAIN INDEX BLOCK OF LONG FILE
	SKIPN B,NBPTT
	JRST BAD3
	MOVE C,[XWD 4,12]
	PUSHJ P,LPNOUT
	LPMSG <% I/O
%>
BAD3:	;TOTAL NUMBER OF GARBAGE DISK ADDRESSES
	SKIPN B,NIDA
	JRST BAD4
	MOVE C,[XWD 4,12]
	PUSHJ P,LPNOUT
	LPMSG </ IDA
/>
BAD4:	;TOTAL NUMBER OF MULTIPLY ASSIGNED DISK ADDRESSES
	SKIPN B,NMDA
	JRST BAD5
	MOVE C,[XWD 4,12]
	PUSHJ P,LPNOUT
	LPMSG </ MDA
/>
BAD5:	;NUMBER OF SEARCHED ADDRESSES (WHEN DOING A SCAN FOR DISK ADR)
	SKIPN B,NSDA
	 JRST BAD7
	ADDM B,FERS		;A FAKE ERROR
	MOVE C,[XWD 4,12]
	PUSHJ P,LPNOUT
	LPMSG </ SDA
/>
BAD7:
	MOVN 1,FERS	;COMPUTE REAL ERRORS
	ADDM 1,ERRORS
	ADDM 1,NBAD
	SKIPN NBAD
	POPJ P,0
;
	MOVE 16,OPTIONS
	TDNN 16,BITS+FIX	;FIX BAD FILES?
	POPJ P,0	;NO
	HRROI 1,[ASCIZ /  BAD FILE. DELETE?/]
	PSOUT
	PUSHJ P,CONFRM
	POPJ P,0	;DDONT FIX
	PUSHJ P,ENAWRT		;WRITE ENA DIRECTORY
	SETZM FDBADR+DIRORG(D)	;CLEAR DISK POINTERS
	SETZM FDBSIZ+DIRORG(D)
	HLLZS FDBBYV+DIRORG(D)
	MOVSI 1,FDBDEL
	IORM 1,FDBCTL+DIRORG(D);DELETED FLAG
	POPJ P,0
; *********************
;	GO THROUGH THE MASTER INDEX BLOCK OF A LONG FILE
; ********************
BUILNG:
;			LET ALL I/O RUN DOWN
	MOVEI B,PTT
	MOVE D,0(P)	;PARAMETER WHICH GETS PASSED TO COMPLETION
			;ROUTINE
	MOVE 1,FDBADR+DIRORG(D)  ;GET DISK ADR
	MOVEI 3,LNGDNE	;COMPLETION ROUTINE FOR LONG FILE
	PUSHJ P,DSKRED
	CALL OPRNDN	;WAIT--DON'T LET ANY OTHER FILES GET STARTED
	JRST BUILDX
;
;
;
;    COME HERE WHEN MASTER IB FOR LONG FILE IS READ
LNGDNE:
	PUSH P,D	;SAVE FOR BADPT1 ROUTINE

	JUMPN 1, [	AOS NBPTT
		PUSHJ P,RPTERR  ;REPORT ERROR
		JRST BADPT1]
	SETZB 1,CURPAG
	HRROM 1,PAGNN		;FLAG FOR WHICH PAGE # WE'RE ON
	MOVEI YY,PTT		;SET UP FOR PRESCAN
	PUSHJ P,IDAPRE	;PRESCAN INDEX BLOCK
	JRST BADPT1		;THERE WERE ERRORS
;
	MOVSI XX,-1000
BUILN1:	SKIPN A,PTT(XX)
	JRST BUILN2
	HRROM XX,PAGNN		;SAVE INDEX INTO PTT FOR ERROR RTN
	PUSHJ P,MRKBTB
	JRST BUILN2	;CAN'T READ THIS SUB-INDEX-BLOCK
	SKIPE NIDA	;GET OUT ASAP IF IDA'S--STILL MAY HAVE
;			CAUSED A FEW MDA'S
	JRST [MOVE 16,OPTION	;OK IF JUST SCANNING
		TDNN 16,BITS+SCAN
		JRST BUILN3
		JRST .+1]
	MOVE D,CURPAG		;PARAMETER
	MOVEI 3,LNGDN1		;SEND COMPLETION RTN TO MRKPT
	PUSHJ P,MRKPT
BUILN2:
	MOVEI 1,1000
	ADDM 1,CURPAG
	AOBJN XX,BUILN1
BUILN3:
	CALL OPRNDN	;RUN DOWN OPERATIONS AGAIN
	JRST BADPT1

; ********************
;	VERIFY CONTENTS OF A PAGE TABLE
; ********************
;
MRKPT:
;	CAN GET HERE IF FILE OPTION IS ON OR IF SCAN FOR DA IS ON
;	DONT GO THROUGH DTA IF SCAN FOR DA ONLY IS ON
;	REG 3 HAS ADDRESS OF COMPLETION ROUTINE
	MOVE 16,OPTIONS
	TDNN 16,BITS+FILE
	POPJ P,0
	PUSH P,A
	MOVEI B,PT
	PUSHJ P,DSKRED
	POP P,A
	POPJ P,0	;EXIT--ASYNC I/O STARTED
;
;
;   COMPLETION ROUTINE WHEN SUB-INDEX BLOCK OF LONG FILE IS READ
;	D=PARAMETER;FOR LONG FILES, D= CURRENT PAGE #
LNGDN1:
	MOVEM D,PAGNN
	CALL MRKPT3
	POPJ P,0
;
;	D=PARAMETER; FOR REG FILES, D=FDB OFFSET IN DIRECTORY
REGFIL:
	PUSH P,D	;SAVE FOR CALL TO BADPT1
	SETZM PAGNN
	SETZM NBAD
	MOVE YY,[XWD NBAD,NBAD+1]
	BLT YY,NIBT	;CLEAR ERROR COUNTS
	CALL SETNM	;SET UP FILE NAME STRINGS
	CALL MRKPT3
	JRST BADPT1
;
;
;	ENTER WITH:
;	1=ERROR CODE RETURNED FROM DSKOP
;	6=FORK SLOT #
MRKPT3:
	JUMPN 1, [	AOS NBPT
		PUSHJ P,RPTERR  ;REPORT ERROR
		POPJ P,]
;
	HRRZ YY,FKCOR(6)	;DO A PRESCAN OF INDEX BLOCK
	PUSHJ P,IDAPRE
	POPJ P,0		;INDEX BLOCK BAD
	MOVSI YY,-1000
	HRR YY,FKCOR(6)	;GET BUFFER USED
MRKPT1:	SKIPN A,0(YY)
	JRST MRKPT2
	PUSHJ P,MRKBTB
	JFCL
MRKPT2:	AOS PAGNN
	AOBJN YY,MRKPT1
	POPJ P,
;
;
SETNM:		;SET UP STRING POINTERS FOR ERROR ROUTINES
	HRRO YY,DIRORG+FDBCTL(D)	;FILE NAME
	ADDI YY,DIRORG+1
	MOVEM YY,DEFNAM
	HLRO YY,DIRORG+FDBEXT(D)	;EXTENSION
	ADDI YY,DIRORG+1
	MOVEM YY,DEFEXT
	HLRZ YY,DIRORG+FDBVER(D)
	HRRM YY,DEFVER		;VERSION
	POPJ P,0
;
;*******************
;	PRESCAN THE INDEX BLOCK
;***********************

IDAPRE:
;		YY= ADDRESS OF PAGE TO BE SCANNED
	MOVE 16,OPTION
	TDNE 16,BITS+SCAN	;OK IF JUST SCANNING
	JRST SKPRET
	SKIPE NIDA	;MAY ALREADY BE IDA'S IF LONG FILE
	POPJ P,0
	HRLI YY,-1000
	PUSH P,PAGNN
IDAPR1:
	MOVE 1,0(YY)
	SKIPE 1
	PUSHJ P,IDACHK
	JFCL
	AOS PAGNN
	AOBJN YY,IDAPR1
	SKIPN NIDA
	AOS -1(P)
	POP P,PAGNN
	POPJ P,0
;
IDACHK:
	PUSH P,A
	PUSH P,B
	PUSH P,C
	JUMPE A,MRKBTZ	;NOTHING WRONG HERE
	TLNN A,10
	JRST IDA
	TLZ A,DSKMSK
	IDIVI A,NSECTK
	CAIL A,LOTRK
	CAIL A,HITRK
	JRST IDA
	IDIVI 2,NSECPG
	JUMPN 3,IDA		;ADDRESS MUST BE A BEG OF PAGE
	MOVEM A,-2(P)	;SAVE RETURN REGS
	MOVEM B,-1(P)
	JRST MRKBTZ
; ********************
;	VERIFY AND MARK A GIVEN PAGE INTO CHECKDSK'S TABLE
; ********************
;
MRKBTB:	PUSH P,A
	PUSH P,B
	PUSH P,C
	TLZ A,777760
	SKIPN B,DALIST
	 JRST MRKBT1
	CAMN A,DATAB(B)
	 JRST SDA		; ADDRESS IS BEING SEARCHED
	AOBJN B,.+1
	AOBJN B,.-3
;
MRKBT1:
	PUSHJ P,IDACHK		;SEE IF A VALID ADDRESS
	JRST MRKBTX		;BAD ADDRESS
;
	MOVE 16,OPTION		;DON'T USE DSKAS WHEN JUST SCANNING
	TDNE 16,BITS+SCAN
	JRST MRKBTZ
;
	PUSH P,1
	IDIVI B,^D36
	IMULI A,NBWTK
	ADD A,B
	MOVSI B,400000
	MOVNS C
	ROT B,(C)
	MOVE C,B
	POP P,B
	TDNN C,DSKBTB(A)
	JRST MDA
	ANDCAM C,DSKBTB(A)
	SOS DSKFCT(B)
	MOVE A,-2(P)
	TLZ A,DSKMSK
	DSKAS
	JRST MRKBT2		;DONT REPORT "NOT IN BT" ANYMORE
			;SINCE THIS IS SELF-CORRECTING BUT
			;ERROR MSGS SCARES OPERATORS
	SKIPN REBLDF
	AOS NOTBT	;KEEP COUNT FOR MSG AT END OF CHECKDSK


MRKBT2:
MRKBTZ:	AOS -3(P)
MRKBTX:	POP P,C
	POP P,B
	POP P,A
	POPJ P,

IDA:
	AOS NIDA		;INCR IDA ERROR COUNT
	PUSHJ P,RPTERR	;REPORT ERROR
	SKIPN DETAIL
	JRST MRKBTX	;DONT WANT DETAILED REPORT
	MOVE 2,-2(P)
	MOVEI C,10
;
	PUSHJ P,LPNOUT
	LPMSG </ IDA />
	JRST MRKBTP

SDA:
	MOVE 15,B	;SAVE NUMBER
	PUSHJ P,IDACHK	;SEE IF VALID ADDRESS--FOR SKIP RETURN
	SKIPA		;NOT VALID
	AOS -3(P)
	PUSHJ P,RPTERR	;REPORT THE SEARCHED ADDRESS
	MOVE 2,DATAB+1(15)
	MOVEI C,10
	PUSHJ P,LPNOUT
	LPMSG </ SDA />
	AOS NSDA
	JRST MRKBTP

MDA:
	AOS NMDA	;INCR MDA ERROR COUNT
	PUSHJ P,RPTERR	;REPORT ERROR
	MOVE 2,-2(P)
	MOVEI C,10
;
	SKIPN DETAIL	;SEE IF DETAILED ERRORS WANTED
	JRST MRKBTX
	PUSHJ P,LPNOUT
	LPMSG </ MDA />
MRKBTP:
	MOVEI C,10	;POSSIBLY PRINT OUT PAGE NUMBER OF PGE IN ERROR
	MOVE B,PAGNN
	CAMN B,[-1]
	JRST [LPMSG </ MAIN IB
/ >
		JRST MRKBTX]
	JUMPL B,[LPMSG </SUB IB  />     ;INDEX BLOCK ERROR IN LONG FILE
		HRRZS B
		JRST .+1]

	PUSHJ P,LPNOUT
	LPMSG </
/>
	JRST MRKBTX
DSKRED:	PUSH P,A
;
;
	MOVE 5,OPCNT	;ROOM FOR ANOTHER OPERATION?
	CAML 5,NFRKS
	CALL OPCML	;COMPLETE AN OPERATION
	TLZ A,DSKMSK	;CLEAR STRAY BITS
;
;
;	INSTRUMENTATION--SEE IF OUTSTANDING I/O
	AOS I$IO	;# OF I/O OPERATIONS
	MOVSI 6,-I$MAX
I$TST:	CAMGE 1,I$BND(6)
	JRST I$TST1
	AOBJN 6,I$TST	;FIND WHAT DRIVE THE ADR IS ON
	JRST I$TST3
I$TST1:
	AOS I$CNT(6)	;# OF OPS ON THAT DRIVE
	MOVSI 5,-I$MAX	;FIND OUT IF POSSIBILITY OF OVERLAP
	SETZM 16
I$TST2:
	SKIPE I$CNT(5)
	AOS 16
	AOBJN 5,I$TST2	;CHECK ALL DRIVES
	CAILE 16,1	;MORE THAN 1 DRIVE USED?
	AOS I$OVLP
I$TST3:
;
	MOVE 5,NNFKS
DSKRD1:
	SKIPE FKOP(5)	;IS THIS A FREE FORK?
	JRST [AOBJN 5,DSKRD1
		HRROI 1,[ASCIZ /ERROR WITH FORK HANDLING/]
		PSOUT
		PUSHJ P,RESET1
		JRST QUIT]
	MOVEM 6,FKDRV(5)	;SAVE DRIVE #
	TLO 1,(1B0)		;SET LOGICAL ADR FLAG
	MOVEM 1,FKADR(5)	;SAVE DISK ADDRESS
	CAIE 2,PTT	;LONG FILE OPERATION HAS SPECIAL BUFFER
	JRST [MOVEI 2,0(5)
		LSH 2,9
		ADDI 2,PT   ;MAKE PAGE ADR
		JRST .+1]
	MOVEM 2,FKCOR(5)	;SAVE CORE ADDRESS
	TLO 3,(1B0)		;SET OPERATION IN PROGRESS
	MOVEM 3,FKOP(5)
	MOVEM 4,FKPARM(5)    ;SAVE PARAMETER FOR COMPLETION RTN
	AOS OPCNT		;INCR # OF OUTSTANDING OPS
	MOVE 1,FKHAND(5)
;;;	MOVEI 2,1B23
;;;	IIC		;GET FORK GOING AGAIN
	MOVEI 2,DODSK
	SFORK
;
;
;
	POP P,A
	POPJ P,

INIBTB:	MOVEI A,NPGTK
	MOVEM A,DSKFCT
	MOVE A,[XWD DSKFCT,DSKFCT+1]
	BLT A,DSKFCT+HITRK-1
	SETOM DSKBTB
	MOVE A,[XWD DSKBTB,DSKBTB+1]
	BLT A,DSKBTB+NBWTK-1
	MOVE A,[XWD DSKBTB,DSKBTB+NBWTK]
	BLT A,DSKBTB+NBWTK*HITRK-1
	POPJ P,

; ********************
;   ROUTINES FOR MULTIPLE I/O FORKS
; ********************
;
OPCML:
;	CHECK FOR AN OPERATION THAT HAS COMPLETED AND FINISH IT OFF
;
	PUSH P,1	;SAVE REGISTERS
	PUSH P,2
	PUSH P,3
	PUSH P,4
;
OPCMLA:
	SETZM INTFLG	;SIGNIFY BEGINNING OF POLLING LOOP
	SETZM 7
	MOVE 6,NNFKS
OPCML3:
	SKIPN FKHAND(6)	;IS THERE A FORK HERE
	JRST OPCML1
	SKIPL 5,FKOP(6)	;IS THERE AN OPERATION WHICH IS TILL IN PROGRESS
	JRST OPCML2	;NO--IT IS DONE
	SETOM 7
OPCML1:
	AOBJN 6,OPCML3	;OPERATION IS REMEMBERED
	JUMPE 7,OPCMLX		;NOTHING THERE
WAIT1:
;;;	SKIPN INTFLG		;DID OPERATION COMPLETE IN MEANTIME?
;;;	WAIT	;NO--WAIT FOR ONE
	SKIPE INTFLG
	JRST OPCMLA
	PUSH P,1
	MOVEI 1,3
	DISMS
	POP P,1
WAIT2:	JRST OPCMLA

OPCML2:
	JUMPE 5,OPCML1	;NOTHING THERE
	SETZM FKOP(6)
;	INSTRUMENTATION
	MOVE 1,FKDRV(6)	;GET DRIVE #
	SOS I$CNT(1)	;DECR # OF OPS ON THE DRIVE
;
	SOS OPCNT
	MOVE 1,FKSTAT(6)	;STATUS OF OPERATION
	MOVE D,FKPARM(6)	;PARAMETER FOR COMPL ROUTINE
	CALL 0(5)
OPCMLX:
	POP P,4
	POP P,3
	POP P,2
	POP P,1
	POPJ P,0

OPRNDN:	
;	OPERATION RUN-DOWN--WAIT FOR ALL TO COMPLETE
	SKIPN OPCNT
	POPJ P,0
	CALL OPCML
	JRST OPRNDN

;********************

;	THIS IS THE I/O FORK ITSELF
;	REG 10 HAS THE OFFSET INTO THE FORKSTAT TABLE FOR THIS
;	FORK
;********************

STFRK:
	MOVEI 1,400000
	CIS
;		SET UP THE FORK'S WORKING PAGE (PRIVATE TO THIS
;		FORK
	MOVEI 1,FKPC
	MOVEM 1,LEVTFK
	MOVE 1,[XWD 1,DOINT]
	MOVEM 1,CHNTFK+^D23
	MOVEI 1,400000
	MOVE 2,[XWD LEVTFK,CHNTFK]
	SIR	;DEFINE WHERE TABLES ARE
	MOVE 2,[XWD 0,1B23]
	AIC		;ALLOW INTERRUPTS ON CHANNEL 23
	EIR

DODSK:
	SKIPL FKOP(10)
	WAIT
DODSK1:
	MOVE 1,FKADR(10)
	MOVEI 2,1000
	MOVE 3,FKCOR(10)	;REGS ARE SET UP FOR DSKOP
	DSKOP
	MOVEM 1,FKSTAT(10)
	MOVSI 1,(1B0)
	ANDCAM 1,FKOP(10)	;INDICATE OPERATION IS DONE
	SETOM 1		;INTERRUPT SUPERIOR FORK
	MOVEI 2,1B23
;;;	IIC
	JFCL
	JRST DODSK

DOINT:
	HRR 4,FKPC	;WHERE WAS FORK EXECUTING
	TLNE 4,10000	;MUST BE IN USER MODE
	DEBRK
	CAIL 4,DODSK	;WATCH OUT FOR TIMING SPLINTERS
	CAILE 4,DODSK1
	DEBRK
	MOVEI 4,DODSK	;CHANGE PC
	HRRM 4,FKPC
	DEBRK

FINBTB:	TMSG </
/>
	MOVE XX,[XWD LOTRK-HITRK,LOTRK]
	SETZ B,
	ADD B,DSKFCT(XX)
	AOBJN XX,.-1
	PUSH P,B
	MOVEI 3,12
	PUSHJ P,TTNOUT
	TMSG </ PAGES LEFT, />
	POP P,B
	MOVNS B
	ADD B,[NPGTK*NTRACK]
	MOVEI C,12
	PUSHJ P,TTNOUT
	TMSG </ PAGES USED.  SYSTEM SAYS:
/>
	GDSKC
	MOVEM 1,QUSED
	MOVEM 2,QLEFT
	MOVE 2,ZLEFT
	MOVEI 3,12
	PUSHJ P,TTNOUT
	MOVEI 1,"-"
	PBOUT
	MOVE 2,QLEFT
	PUSHJ P,TTNOUT
	TMSG </ LEFT, />
	MOVE 2,ZUSED
	MOVEI 3,12
	PUSHJ P,TTNOUT
	MOVEI 1,"-"
	PBOUT
	MOVE 2,QUSED
	PUSHJ P,TTNOUT
	TMSG </ PAGES USED.
/>
	POPJ P,

; ********************
;	VARIOUS TERMINAL RTNS AND ERROR ROUTINES
; ********************
IFNDEF LPTSW,<LPNOUT:>
TTNOUT:	MOVEI A,101
	NOUT
	JFCL
	POPJ P,

IFNDEF LPTSW,<LPMSGQ:>
TMSGQ:	MOVEI 1,101
	MOVEI C,0
	SOUT
	POPJ P,

IFDEF LPTSW,<
LPNOUT:	MOVE A,LPT
	NOUT
	JFCL
	POPJ P,

LPMSGQ:	MOVE A,LPT
	MOVEI C,0
	SOUT
	POPJ P,

LPTINI:	MOVSI A,1
	HRROI B,[ASCIZ /LP1:/]
	GTJFN
	 JRST NOLPT
	MOVE C,A
	MOVE B,[XWD 070000,100200] ;OPEN FOR WRITING
	OPENF
	 JRST  [MOVE A,C	;COULDNT GET LPT
		RLJFN
		JFCL
		JRST NOLPT]
	MOVEM C,LPT
	MOVEI 1,400000		;ON INTERRUPT SIDE?
	RWM
	TLNN 2,(7B3)
	 POPJ P,		;NO, RETURN
	HRROI 1,[ASCIZ \
GOT LP1:
\]
	PSOUT
	POPJ P,
NOLPT:	MOVEI 1,400000
	RWM
	TLNE 2,(7B3)		;ON INTERRUPT SIDE?
	 JRST NOLPT1
	MOVEI 1,101		;OUTPUT TO TTY INSTEAD
	MOVEM 1,LPT
	HRROI A,[ASCIZ \
COULDN'T OPEN LP1:
\]
	PSOUT
NOLPT1:	MOVEI 1,400000
	MOVSI 2,(1B3)		;QUEUE UP A CHECK
	MOVEI 3,^D15*^D1000	;IN 15 SECONDS
	IIT
	POPJ P,
> ;END IFDEF LPTSW


;	REPORT ERROR IN FILE--TYPES DIRECTORY NAME IF IT HASN'T BEEN
;	TYPED AND TYPES FILE NAME IF THERE IS ONE
;
RPTERR:	
	SKIPN CURDIR
	POPJ P,
	SKIPE DIRERR	;FIRST ERROR ON DIRECTORY
	JRST RPT1	;NO
	LPMSG <\

*** \>
	MOVE B,DIRPTR	;OUTPUT DIRECTORY NAME
	CALL LPMSGQ
	SETOM DIRERR	;INDICATE DIR NAME HAS BEEN PRINTED
	LPMSG <\
\>
RPT1:
	SKIPN NBAD	;HAS FILE NAME ALREADY BEEN PRINTED
	SKIPN 1,DEFNAM	;IS THERE A FILE NAME
	JRST RPT2
	LPMSG <\
\>
	MOVE B,DEFNAM
	CALL LPMSGQ	;PRINT FILE NAME
	LPMSG <".">
	MOVE B,DEFEXT	;PRINT EXTENSION
	CALL LPMSGQ
	LPMSG <";">
	HRRZ B,DEFVER
	MOVEI C,12
	CALL LPNOUT
	LPMSG <\
\>
RPT2:
	AOS NBAD
	AOS ERRORS
	POPJ P,
PT=100000
;		PT IS AN ARRAY OF BUFFERS--1 PAGE FOR EACH FORK FOR I/O
PTT=160000
DSKFCT=200000
DSKBTB=DSKFCT+HITRK
;

ERRORS:	BLOCK 1
DIRERR:	BLOCK 1	;FLAG TO INDICATE IF DIR NAME HAS BEEN TYPED
;	NOTE--NBAD TO NIBT MUST BE TOGETHER FOR BLT
;
NBAD:	BLOCK 1
NDE:	BLOCK 1
NBPT:	BLOCK 1
NBPTE:	BLOCK 1
NBPTT:	BLOCK 1
NBPTTE:	BLOCK 1
NIDA:	BLOCK 1
NMDA:	BLOCK 1
NSDA:	BLOCK 1
FERS:	BLOCK 1		;FAKE ERRORS
NIBT:	BLOCK 1
;	NOTE: THE FOLLOWING BLOCK MUST BE CONTIGUOUS SO IT
;	CAN BE ZEROED AT START OF PROGRAM
;	BLOCK GOES FROM BLKZRO TO BLKZRX
BLKZRO:
NOTBT:	BLOCK 1
CURPAG:	BLOCK 1
PAGNN:	BLOCK 1
NBPTA:	BLOCK 1
DALIST:	BLOCK 1
OFFCNT:	BLOCK 1	;# OF DIRS THAT HAVE INCORRECT PGE CNTS
BLKZRX:		;;POINTS TO LAST WORD OF BLOCK
LOCKED:	BLOCK 1	;FLAG SAYING WE HAVE A DIR LOCKED
DATAB:	BLOCK DASIZ
DAJFN:	BLOCK 1
PDL:	BLOCK 100
DIRPTR:	BLOCK 1
DIRNAM:	BLOCK 12
JOBNO:	BLOCK 1
IFDEF LPTSW,<LPT: BLOCK 1>
RET1:	BLOCK 1
RET2:	BLOCK 1
RET3:	BLOCK 1
PAGCNT:	BLOCK 1   ;CUM. TOTAL OF DIRS PAGES
OERROR:	BLOCK 1	;TEMP SAVE FOR OLD COUNT IN ERROR
REBLDF:	BLOCK 1
PSIF:	BLOCK 1
ZLEFT:	BLOCK 1
ZUSED:	BLOCK 1
QLEFT:	BLOCK 1
QUSED:	BLOCK 1
WHEEL:	BLOCK 1
FDJFN:	BLOCK 1
DEFVER:	BLOCK 1
FILS:	BLOCK 1
DEFDEV:	BLOCK 1
DEFDIR:	BLOCK 1
DEFNAM:	BLOCK 1
DEFEXT:	BLOCK 1
	BLOCK 4
;
;	OPTION FLAGS BASED ON OPERATOR ANSWERS TO CHECKD QUESTIONS
DETAIL:	BLOCK 1	;DETAILED ERROR PRINTOUT--IDA'S,MDA'S,ETC.
OPTION:	BLOCK 1   ;OPTION FLAGS FROM USER
USRNAM:	ASCIZ /</
	BLOCK 14
	BLOCK 5		;FOR MESSAGE.TXT
MSG:	ASCIZ	/MESSAGE.TXT/
MESPTR:	BLOCK 1
USPTR:	POINT 7,USRNAM,6
FDADR:	BLOCK 1	;TEMP SAVE WHEN DOING A CHECKPOINT
;
;	BUFFERS USED FOR CHECKPOINTING
CHKBUF=740000
IBBUF=741000
DTABUF=742000
;
;
;    CELLSS USED BY NEW MULTIPLE FORK HANDLING FOR FASTER I/O
;
MAXFRK==10
NNFKS:	XWD -MAXFRK,0
NFKS:	MAXFRK
NUFKS:	2	;DONT GO THROUGH SO MUCH FORK CREATION OVERHEAD
			;WHEN IT IS JUST ONE USER
NFRKS:	0	;CURRENT # CREATED
;
;  PARALLEL TABLES FOR MULTIPLE FORK HANDLING
FKHAND:	BLOCK 15	;FORK HANDLE
FKOP:	BLOCK 15	;<0 IF OPERATION IN PROGRESS-ALSO,ADR OF COMPL
;			ROUTINE
FKADR:	BLOCK 15	;DISK ADDRESS FOR I/O
FKCOR:	BLOCK 15	;CORE ADDRESS FOR DATA
FKPARM:	BLOCK 15	;PARAMETER  PASSED TO COMPLETION ROUTINE
FKSTAT:	BLOCK 15	;STATUS OF COMPLETED I/O
FKDRV:	BLOCK 15	;DRIVE OPERATION IS ON

FKREG:	BLOCK 20	;INITIAL REGISTERS FOR FORK

OPCNT:	BLOCK 1		;# OF OUTSTANDING I/O OPERATIONS
INTFLG:	BLOCK 1	;INTERRUPT OCCURRED FLAG
FKBAS=500000		;PAGE INDIVIDUAL FOR EACH FORK
FKPC==FKBAS		;INTERRUPTED PC
LEVTFK==FKPC+1		;FORK LEVEL TABLE
CHNTFK==LEVTFK+3		;CHANNEL TABLE

;	INSTRUMENTATION VARIABLES
I$ST1:		;START OF AREA TO CLEAR
I$FSEN:	BLOCK 1		;TOTAL FILES SEEN
I$FCMP:	BLOCK 1		;TOTAL FILES COMPLETED
I$IO:	BLOCK 1		;# OF I/O OPERATIONS
I$OVLP:	BLOCK 1		;# OF POSSIBLE OVERLAPPED OPERATIONS
I$MAX==NPACKS+1
I$CNT:	BLOCK I$MAX
I$ST2:		;END OF AREA TO CLEAR
;
I$BND:
	I=0
	REPEAT I$MAX,<NTKUN*NPGTK*I*NSECPG
			I=I+1>
;	FLAGS USED BY CODE SWIPED FROM BSYS
CURDIR:	BLOCK 1	;CURRENT DIRECTORY
CNTFDB:	BLOCK 1	;FDB TABLE COUNT
SYMEND:	BLOCK 1	;SAVE FOR SYMTOP
SYMPTR:	BLOCK 1	;SAVE FOR SYMBOT
DIRADR:	BLOCK 1	;CURRENT DIRECTORY ADDRESS
CEF:	BLOCK 1	;CURRENT EXTENSION POINTER
CVF:	BLOCK 1	;CURRENT VERSION POINTER
LVF:	BLOCK 1	;LAST VERSION POINTER
NEF:	BLOCK 1	;NEXT EXTENSION POINTER
NVF:	BLOCK 1	;LAST VERSION POINTER
SYMENT:	BLOCK 1	;TEMP SAVE FOR CURRENT SYMBOL TBL ENTRY
ADRFDB:	BLOCK 1	;CURRENT FDB
FDBTBL:	BLOCK 2000  ;TABLE OF SAVED FDB'S
TDRMSK:	BLOCK 1	;MASK CONSTRUCTED IN $SETMSK
FLCNT:	BLOCK 1
TDRINP:	BLOCK 1	;CELL USED BY $SETMSK

;******************************************************
;  "DOVERI"	VERIFY USER DIRECTORY ROUTINE
;******************************************************

DOVERI:
	MOVEI	AA,FDBTBL	;POINT TOSTARTOF SAVED FDB'S
	MOVE	CC,CVF		;PICK UP CURRENT FDB
	SKIPN	CNTFDB		;SKIP IN SOME THERE
	JRST	DOVER2		;IF NOT PUT THIS ONE IN
	MOVE	BB,CNTFDB	;LOAD COUNT
DOVER1:
	CAMN	CC,0(AA)	;ALREDY IN TABLE?
	JRST	[
		TYPEN	<  FDB IN MULTIPLE STRINGS OR RING -  SYM1= >
		MOVE	B,1(AA)		;LOAD PREVIOUS SYM ENTRY ADDR
		MOVEI	C,10		;OCTAL
		NOUT
		  JFCL
		;GO TYPE ERROR DATA
		CALL VERR
		POPJ P,
		JRST	DOVER3]		;AND CHECK OTHER ERRORS
	ADDI	AA,2		;POINT TO NEXT ENTRY
	SOJN	BB,DOVER1	;LOOP THROUGH ENTIRE TABLE
DOVER2:
	MOVEM	CC,0(AA)	;SAVE THIS ONE
	MOVE	CC,SYMENT	;AND SYMTAB POINTER TOO
	SUB	CC,DIRADR	;MAKE IT A DISPLACEMENT
	MOVEM	CC,1(AA)
	AOS	CNTFDB		;BUMP COUNT
DOVER3:
	MOVE	AA,DIRADR	;LOAD DIRECTORY ADDRESS
	MOVE	BB,ADRFDB	;LOAD FDB ADDRESS (REAL)
	HLRZ	C,0(BB)		;LOAD FDB HEADER WORD
	CAIE	C,400100	;SKIP IF REAL FDB (OR BDB)
	JRST	[
		TYPEN	<  INVALID FDB HEADER>
		CALL	VERR
		POPJ P,0
		JRST	.+1]
	MOVE	C,FDBCTL(BB)	;LOAD FILE NAME STRING POINTER
	TLNE	C,FDBNEX+FDBNXF	;SKIP IF IT EXISTS
	JRST SKPRET		;IGNORE IF NOT
	ADD	C,AA		;MAKE IT A REAL ADDR
	HLRZ	C,0(C)		;PICK UP HEADER WORD
	CAIE	C,400001	;SKIP IF VALID HEADER
	JRST   [
		TYPEN	<  INVALID FILE NAME STRING POINTER>
		CALL	VERR
		POPJ P,
		JRST	.+1]
	HLRZ	C,FDBEXT(BB)		;LOAD EXT STRING POINTER
	ADD	C,AA		;MAKE IT REAL
	HLRZ	C,0(C)		;PICKUP HEADER
	CAIE	C,400002	;SKIP IF VALID
	JRST   [
		TYPEN	<  INVALID EXT STRING POINTER>
		CALL	VERR
		POPJ P,
		JRST	.+1]
	MOVE	C,FDBACT(BB)	;PICKUP POSSIBLE ACCT STRING PTR
	TLNE	C,500000	;SKIP IF NOT ACCOUNT #
	JRST	DOVER4		;BYPASS IF #
	ADD	C,AA		;MAKE IT REAL
	HLRZ	C,0(C)		;PICK UP HEADER
	CAIE	C,-1		;SKIP IF OK
	JRST   [
		TYPEN	<  INVALID ACCOUNT STRING POINTER>
		CALL	VERR
		POPJ P,
		JRST	.+1]
DOVER4:
	MOVE	AA,SYMENT
	SUB	AA,DIRADR
	CAMN	AA,SYMBOT	;SKIP IF NOT 1ST ENTRY
	JRST	VERDSK		;IGNORE THIS CHECK FOR 1ST
; CONSTRUCT "RST" LOOKUP POINTER FOR LAST FILE NAME STRING
	MOVE	AA,SYMENT
	HLRZ	A,-1(AA)	;PICK UP LAST FILE STRING PTR
	ADD	A,DIRADR	;MAKE IT REAL
	MOVN	C,0(A)
	HRLI	A,2(C)
	AOJ	A,
	PUSH	P,A		;SAVE LOOKUP POINTER
	CALL	$SETMSK	;GO CONSTRUCT MASK FOR COMPARE
	POP	P,A
;NOW CONSTRUCT "RST" LOOKUP POINTER FOR CURRENT FILE NAME
	HLRZ	B,0(AA)		;PICKUP CURRENT FILE STRING PTR
	ADD	B,DIRADR	;KE IT REAL
	MOVN	C,0(B)
	HRLI	B,2(C)
	AOJ	B,
	MOVE	C,TDRMSK	;LOAD MASK CONSTRUCTED ABOVE
	CALL	STRCMP		;GO COMPARE STRINGS
	  JRST	VERDSK		;A<B OK ASCENDING
	  SKIPA			;A>B BAD FALL INTO ERROR CODE
	JRST	VERDSK		;;A SUBSET OF B --OK
	 TYPEN	<FILE NAMES NOT IN ASCENDING ORDER >
	 TYPEN	<  LAST FILE = >
	HLRZ	B,-1(AA)	;LOAD LAST
	ADD	B,DIRADR	;MAKE IT REAL
	ADDI	B,1		;STEP OVER HEADER
	HRLI	B,-1		;MAKE IT A STRING POINTER
	SETZ	C,		;ASCIZ
	SOUT
	TYPEM	<  CURRENT FILE = >
	HLRZ	B,0(AA)		;LOAD CURRENT FILE POINTER
	ADD	B,DIRADR	;MAKE IT REAL
	AOJ	B,		;STEP OVER HEADER
	HRLI	B,-1
	SETZ	C,		;ASCIZ
	SOUT
	CALL	VERR		;TYPE OTHER FOR GOOD MEASURE
	POPJ P,
VERDSK:	JRST SKPRET
;******************************************************
;  "CHECK" 	THIS ROUTINE IS THE MAJOR CONTROL FOR PROCESSING
;******************************************************

;		FILE VERSION AND EXTENTION FDB'S (TAPE AND DISC)
;  AT ENTRY	A	FILE SYMBOL TABLE ENTRY
;		B	ADDRESS OF ENTRY
;		DIRADR	ADDRESS OF DIRECTORY BEING PROCESSED
;A-(EXTOFFSET)=LEF,RH(A)=CEF
CHECK:
	HRRZM	A,CEF		;SET CURRENT EXT. POINTER 
	MOVEM	B,SYMENT	;SAVE ENTRY ADDRESS FOR LATER
	MOVE	C,DIRADR	;LOAD ADDRESS OF CURRENT DIRECTORY
	SUBI	B,FDBEXT(C)	;SUBTRACT EXT. POINTER DISPL
CHECK1:
	MOVE	B,CEF		;LOAD CURRENT EXT.POINTER
	MOVEM	B,CVF		;SET CURRENT VER. PTR
	SETZM	LVF		;SET LAST VER. PTR = 0
CHECK2:
	MOVE	A,CVF		;SET INDEX = CURRENT FDB
	ADD	A,DIRADR	;MAKE IT A REAL ADDRESS
	MOVE	B,[XWD 400100,FDBLEN] ;LOAD HEADER WORD
	CAME	B,0(A)		;CHECK IF REALLY AND FDB
	JRST	[TYPEN	<INVALID SYMTAB ENTRY (FDB PTR)>
		JRST	VERR]		;GO TYPE GOOD SHIT AND RETURN
	MOVEM	A,ADRFDB	;SAVE IT FOR LATER
	HRRZ	B,FDBEXT(A)	;GET NEXT EXTENTION POINTER
	SKIPN	LVF		;SKIP IF NOT AT TOP OF VER CHAIN
	HRRZM	B,NEF		;SET NEXT EXT. PTR
	HRR	B,FDBVER(A)	;GET NEXT VERSION POINTER
	HRRZM	B,NVF		;SET MY PTR
	CALL	DOVERI	;GO CHECK STRING POINTERS
	POPJ P,0	;DIREC HAS BEEN FIXED--START OVER
CHECK4:
	MOVE	A,CVF	
	MOVEM	A,LVF		;CVF=LVF
	SKIPE	NVF		;SKIP IF THERE IS NO NEXT VERSION
	JRST	[MOVE	A,NVF
		MOVEM	A,CVF		;NVF GOES TO CVF
		JRST	CHECK2]		;GO CHECK IF DELETED
	SKIPE	NEF			;SKIP IF THERE IS NO NEXT EXT.
	JRST	[MOVE	A,NEF
		MOVEM	A,CEF		;SET NEXT EXT TO CURRENT
		JRST	CHECK1]		;AND GO LOOK AT THIS ONE
	JRST SKPRET
;******************************************************
;  ".SETVR"	SETUP TO VERIFY A USER DIRECTORY
;******************************************************

;	CHECKS FOR VALID SYMTAB ENTRIES AND STRING HEADERS
.SETVR:
	MOVE A,DIRNUM	;GET DIRECTORY #
	CAME A,CURDIR	;IS IT WHAT I WANTED?
	JRST	[
		TYPEN	<  ?? INCORRECT DIRECTORY NUMBER (DIRNUM) ??>
		CALL NOFIX	;CAN'T FIX IT--PROBABLY MORE PROBS
		JRST	.+1]
SETVR1:;
;	VERIFY FREE-SPACE CHAIN
;
	HLRZ 1,DIRFRE+4		;GET MAX TOP OF FREE STORAGE
	CAME 1,FRETOP	;CHECK OTHER FREE SPACE LIMIT
	JRST	[TYPEN <INCORRECT OFFSET IN FRETOP>
		CALL NOFIX
		HLRZ 1,DIRFRE+4   ;RESTORE REG 1
		JRST .+1]
	MOVEI 4,DIRFRE-DIRORG
	HRRZ 2,DIRFRE+4	;GET MIN BOTTOM
	CAIL 2,DIFREE-DIRORG  ;BOTTOM CANT BE TOO LOW
	CAILE 2,0(1)		;BOTTOM HAS TO BE BELOW TOP
	JRST FRERR		;TYPE ERROR
	MOVE 3,DIRFRE+2		;AMOUNT OF FREE SPACE
	CAIGE 3,20000		;MAX SPACE EVER ALLOWED IN DIR
	CAIL 1,20000		;MAX TOP CANT BE TOO BIG
	JRST FRERR
SETVR3:
	HLRZ 5,DIRORG(4)	;GET POINTER TO A BLOCK
	JUMPE 5,FREND		;END OF LIST
	CAIGE 5,0(1)		;CANT BE OVER TOP
	CAIGE 5,0(2)		;MUST BE OVER BOTTOM
	JRST FRERR
	HRRZ 6,DIRORG(5)	;GET SIZE
	JUMPE 6,FRERR		;CANT HAVE 0-SIZED BLOCK
	SUB 3,6		;ACCOUNT FOR SIZE
	JUMPL 3,FRERR		;EXHAUSTED TOTAL SIZE
	MOVE 4,5
	JRST SETVR3
FREND:	SKIPE 3		;END OF CHAIN--MUST HAVE ACCOUNTED FOR
	JRST FRERR		;ALL OF THE SPACE
SETVR4:
	SETZM CNTFDB	;SET FDB TABLE COUNT=0


	SETZM	FLCNT		;SET FILE COUNT = 0
	MOVE	B,SYMTOP	;LOAD END POINTER
	ADDI	B,DIRECT-1	;MAKE IT REAL
	MOVEM	B,SYMEND	;SAVE FOR COMPARE
	MOVE	B,SYMBOT	;LOAD START OF SYMTAB
	ADDI	B,DIRECT	;MAKE IT REAL(POINT TO 1ST SYMBOL)
	MOVEM	B,SYMPTR	;SET WORKING POINTER
	MOVEI	A,DIRECT	;LOAD DISC DIRECTORY ADDRESS
	MOVEM	A,DIRADR	;AND SET CURRENT DIRECTORY ADDRESS
SETVR2:
	MOVE	B,SYMPTR	;LOAD WORKING POINTER
	CAMLE	B,SYMEND	;SKIP IF NOT PASSED END OF TABLE
	POPJ P,0
	HRRZ	A,@SYMPTR	;LOAD FDB POINTER (MAYBE)
	MOVE	B,SYMPTR	;LOAD SYMBOL TABLE ENTRY ADDRESS
	AOS	SYMPTR		;POINT TO NEXT ENTRY(SYMTAB)
	TRZE	A,700000	;SKIP IF ENTRY TYPE =0
	JRST	SETVR2		;GO CHECK IF DONE WITH SYMTAB
	CALL	CHECK		;GO CHECK THIS FILE (F= REQUEST FLAGS)
	JRST SETVR4		;ERRORS--START OVER
	JRST	SETVR2		;AND CONTINUE PROCESSING SYMTAB


FRERR:
	TYPEN <INCORRECT FREE SPACE CHAIN AT >
	MOVE 2,4		;OFFSET
	MOVEI 3,10
	PUSHJ P,TTNOUT
	MOVE 16,OPTIONS
	TDNE 16,BITS+FIX
	JRST FRERR1	;FIX FREE-SPACE CHAIN
	MOVEI 1,37
	PBOUT
	JRST SETVR4

FRERR1:
	HRROI 1,[ASCIZ / FIX?/]
	PSOUT
	PUSHJ P,CONFRM
	JRST SETVR4
	PUSHJ P,UNLDIR	;UNLOCK DIRECTORY
	MOVE 1,CURDIR
	DELDF
	PUSHJ P,LCKDIR	;LOCK DIRECTORY AGAIN
	JRST SETVR1

;******************************************************
;  "STRCMP"	STRING COMPARE ROUTINE
;******************************************************

; CALL:	LH(A)		; MINUS NUMBER OF FULL WORDS IN STRING 1
;	RH(A)		; LOC OF FIRST WORD OF STRING
;	LH(B)		; MINUS NUMBER OF FULL WORDS IN STRING 2
;	RH(B)		; LOC OF FIRST WORD OF STRING
;	C		; A MASK OF 1'S FOR LAST WORD OF STRING1
;	PUSHJ P,STRCMP
; RETURN
;	+1	; A < B
;	+2	; A > B
;	+3	; A = INITIAL SUBSET OF B
;	+4	; A = B
; CLOBBERS A,B,C,D
STRCMP:
	PUSH P,C
STRCM0:
	JUMPGE A,STRCM1	; DOWN TO LAST WORD OF STRING A
	JCRY0 .+1		; CLEAP CARRY 0
	MOVE D,(B)		; GET WORD OF STRING B
	MOVE C,(A)		; AND WORD OF STRING A
	ANDCMI C,1		; GET RID OF SUPERFLUOUS BITS 35
	ANDCMI D,1
	SUB	D,C		; COMPARE THE WORDS
	JUMPE D,STRCM2	; EQUAL, STEP TO NEXT WORD
	JCRY0 .+2		; A < B
STRCM3:
	AOS -1(P)		; A > B
	POP P,C
	POPJ P,
STRCM2:
	JUMPGE B,STRCM3		; IS B GONE?
	AOBJN A,.+1		; NO, STEP TO NEXT WORD
	AOBJN B,STRCM0
	JRST STRCM0
STRCM1:
	POP P,C
	MOVE D,(A)		; GET LAST WORD OF STRING A
	AND D,C			; GET RID OF GARBAGE
	SKIPL B			; IF STRING B IS ALSO DOWN TO LAST WORD,
	CAME D,(B)		; CHECK FOR EXACT MATCH
	JRST STRCM4		; NOT EXACT MATCH
	MOVEI D,3		; EXACT MATCH
	ADDM D,(P)		; TRIPLE SKIP
	POPJ P,
STRCM4:
	AND C,(B)		; TRUNCATE STRING B TO SAME LENGTH AS A
	JCRY0 .+1		; CLEAR CARRY 0
	SUB C,D			; COMPARE A TO TRUNCATED B
	JUMPE C,SK2RET		; EQUAL, SUBSET
	JCRY0 CPOPJ		; A < B
	JRST SKPRET		; A > B
SK3RET:
	AOS	(P)
SK2RET:
	AOS	(P)
SKPRET:
	AOS	(P)
CPOPJ:
	POPJ	P,0

;******************************************************
;  "$SETMS"	SAME AS SETMSK ONLY FOR TAPE DIRECTORY
;******************************************************

; SETUP MASK AND INPUT POINTER FOR DIRECTORY LOOKS
; CALL:	A	; LOOKUP POINTER
;	PUSHJ P,$SETMS
; RETURN
;	+1	; IN DIRINP, A STRING COMPARE POINTER TO INPUT
; IN DIRMSK, A MASK OF ONES FOR MASKING LAST WORD OF INPUT STRING
; CLOBBERS A,B,C,D
$SETMS:
	HLRE D,A		; GET SIZE OF THE STRING BLOCK
	SUBM A,D		; GET LOC OF LAST FULL WORD
	MOVSI B,774000		; 7 BIT MASK LEFT JUSTIFIED
	MOVNI C,1		; MASK OF BITS TO IGNORE
$SETM0:
	TDNN B,1(D)		; LOOK FOR THE TERMINATING NULL
	JRST $SETM1		; THERE IT IS, C HAS 1'S FOR IGNORATION
	LSH B,-7		; NOT THERE, SHIFT TO NEXT BIT
	LSH C,-7
	JRST $SETM0
$SETM1:
	SETCAM C,TDRMSK		; GET MASK OF BITS TO TEST IN LAST WORD
	AOS A
	MOVEM A,TDRINP		; SAVE INPUT POINTER
	POPJ P,

;********************
;	TYPE SYMTAB ERROR DATA
;********************
VERR:	;ERROR BAD BLOCK FOUND TYPE PERTINATE SHIT
	TYPEN	<  SYMADR= >
	MOVE	B,SYMENT	;LOAD REAL ADDR OF SYMTAB ENTRY
	SUB	B,DIRADR	;MAKE IT DISPLACEMENT
	MOVEI	C,10		;OCTAL
	PUSHJ P,TTNOUT
	TYPEM	<,  SYMENT= >
	HLRZ	B,@SYMENT	;PICK UP LH (FLNM POINTER)
	MOVEI	C,10
	PUSHJ P,TTNOUT
	MOVEI 1,","
	PBOUT
	HRRZ	B,@SYMENT	;LH (FDB POINTER)
	PUSHJ P,TTNOUT
	TYPEM	<  FDBADR= >
	MOVE	B,CVF		;PICK UP CURRENT VERSION FDB ADDR (DISP)
	MOVEI	C,10
	PUSHJ P,TTNOUT
	MOVEI 1,37
	PBOUT
	PUSHJ P,BADBLK		;SEE IF ENTRY SHOULD BE FIXED
	POPJ P,0		;ENTRY WAS FIXED--DON'T
				;KEEP PROCESSING DIR AT THIS POINT
	JRST SKPRET


;********************
;	HANDLE BAD SYMTAB ENTRIES IN FIX MODE
;********************
BADBLK:
	MOVE 16,OPTIONS
	TDNN 16,BITS+FIX	;IN REPAIR MODE
	JRST SKPRET		;NO
	HRROI 1,[ASCIZ /DELETE SYMADR ENTRY?/]
	PSOUT
	PUSHJ P,CONFRM
	JRST SKPRET		;NO
	PUSHJ P,ENAWRT
	MOVE 4,SYMENT		;GET SYMTAB ENTRY IN QUESTION
	SUB 4,DIRADR		;MAKE A DISPLACEMENT
BADBK4:
	CAMG 4,SYMBOT
	JRST BADBK5
	MOVE 5,DIRORG-1(4)
	MOVEM 5,DIRORG(4)	;SLIDE OVER BAD ENTRY
	SUBI 4,1
	JRST BADBK4
BADBK5:
	AOS 1,SYMBOT		;THE BAD ENTRY IS NOW GONE
	PUSHJ P,DISWRT		;TURN OFF DIR WRITE MODE
	POPJ P,0

;********************
;	ENA OR DIS WRITE ACCESS TO A DIR
;********************
DISWRT:
	MOVSI 2,100000	;SET ACCESS OF DIR TO READ ONLY
	SKIPA
ENAWRT:
	MOVSI 2,140000	;SET ACCESS OF DIR TO ALLOW WRITE
	MOVE 1,[XWD 400000,DIRORG/1000]
WRT1:
	MOVE 3,2
	RPACS		;SEE IF PAGE EXISTS
	EXCH 2,3
	TLNE 3,10000	;PAGE EXISTS
	SPACS
	ADDI 1,1
	CAME 1,[XWD 400000,DIRORG/1000+20]
	JRST WRT1
	POPJ P,0
;********************
;	INITIALIZE A DIRECTORY
;********************
INIBLK:
	SETZM PSIF
	MOVE 1,CURDIR
	CAIN 1,1		;DONT TOUCH SYSTEM DIR
	JRST INI2
;
	PUSHJ P,ENAWRT
	MOVEI 1,25	;MOST COMMON BLOCK SIZE
	MOVEI 2,1000
	MOVE 3,CURDIR	;GET DIRECTORY NUMBER
;
	;THIS CODE IS SWIPED FROM DIRECT.MAC IN TENEX
	PUSH P,A
	MOVE A,[XWD DIRORG,DIRORG+1]
	SETZM DIRORG
	BLT A,DIRORG-1(B)	;CLEAR ALL OF DIRECTORY
	POP P,DIRFRE+3
	MOVEM C,DIRNUM
	MOVE A,[XWD 500000,777752]
	MOVEM A,DIRDPW		;DEFAULT PROTECTION IS ALL ACCESS
	MOVE A,[XWD 500000,777740]
	MOVEM A,DIRPRT
	MOVEI A,2
	MOVEM A,DIRDBK
	MOVEM B,SYMBOT		;NULL SYMBOL TABLE
	MOVEM B,SYMTOP
	MOVEI A,DIFREE-DIRORG
	HRLOM A,DIRFRE
	HRRM A,DIRFRE+4
	SUB A,B		;NEGATIVE OF SPACE TO A
	ASH A,-6
;			RESERV 1/64 OF SPACE FOR SYMTAB
	ADD A,B		;REMAINDER FOR DYNAMIC STORAGE
	MOVEM A,FRETOP
	HRLM A,DIRFRE+4
	SUBI A,DIFREE-DIRORG
	MOVEM A,DIFREE
	MOVEM A,DIRFRE+2
	SETOM DIRFRE+1
;
;	GO THROUGH A BUNCH OF SHIT TO CREATE MESSAGE.TXT
	MOVE 1,MESPTR
	MOVE 2,[POINT 7,MSG-1,35]
INI3:
	ILDB 3,2
	IDPB 3,1	;MOVE MESSAGE.TXT STRING TO DIR NAME
	JUMPN 3,INI3
;
	SETOM DIRLCK
	PUSHJ P,DISWRT
	HRROI 2,USRNAM	;NAME OF FILE
	MOVSI 1,400001	;OPTIONS
	GTJFN
	JFCL
	HRLI A,FDBCTL	;OFFSET--FLAGS
	MOVSI 2,FDBPRM+FDBNXF+FDBDEL
	MOVSI 3,FDBPRM+FDBDEL
	CHFDB
	HRLI 1,FDBPRT	;PROTECTION IS SPECIAL
	MOVEI 3,770404
	MOVEI 2,-1
	CHFDB
	SETOM PSIF
	HRRZS 1
	RLJFN		;RELEASE JFN FOR MESSAGE.TXT
	JFCL
;
	POPJ P,0
INI2:
	HRROI 1,[ASCIZ /GOOD GOD--NOT SYSTEM
/]
	PSOUT
	POPJ P,0

;*********************
;	LOCK A DIRECTORY
;********************
LCKDIR:
	PUSHJ P,ENAWRT
	SETZM PSIF	;DONT ALLOW INTERRUPTS
	AOSE DIRLCK	;LOCKED
	JRST LCKDR1	;YES
	SETOM LOCKED	;SET INTERNAL FLAG
	PUSHJ P,DISWRT	;SET DIR TO READ ONLY
	SETOM PSIF	;ALLOW INTS AGAIN
	POPJ P,
LCKDR1:
	PUSHJ P,DISWRT
	SETOM PSIF	;ALLOW INTS
	MOVEI 1,^D1000
	DISMS
	JRST LCKDIR

;********************
;	UNLOCK A DIRECTORY
;********************
UNLDIR:
	PUSHJ P,ENAWRT
	SETZM LOCKED
	SETOM DIRLCK
	PUSHJ P,DISWRT
	POPJ P,

;
NOFIX:		;SOME ERRORS WON'T BE CORRECTED BECAUSE THEY
;			INDICATE PROBLEMS THAT A PROGRAMMER SHOULD SEE
	TYPEM <-FURTHER CHECS REQ'D>
	POPJ P,0

;********************
;	ROUTINE TO CHECKPOINT CRITICAL SYSTEM PAGES IN CASE OF 
;	DISK DISASTER
;********************

CHKPT:
REPEAT 0,<
OFS=100
CHKARA=DSKKPL
CHKSIZ==DSKKPS*NPGTK  ;NUMBER OF PGS IN CHKPOINT AREA
CHKLOC:	400010000000+CHKARA
CHKPT:
;		GET THE STARTING LOCATION TO ALL FILE SYSTEM
	MOVE 1,[SIXBIT 'DIDSCI']
	SYSGT
	SETZM FDADR
	MOVE 14,CHKLOC
	ADDI 14,NSECPG
	MOVEI 13,1	;OFFSET IN CHKBUF FOR CHKSUMS
	MOVEI 11,0	;OFFSET IN CHKBUF FOR POINTERS

	PUSHJ P,RDIB	;READ FIRST IB AND IT'S DATA
;
	MOVE 1,FDADR	;READ IN LONG-FILE IB FOR DIRECTORIES
	PUSHJ P,RDIB
;
	MOVE 1,FDADR
	MOVEI 2,1000
	MOVEI 3,IBBUF
	PUSHJ P,RD
	MOVE 1,IBBUF
	PUSHJ P,RD
	MOVE 1,[XWD IBBUF+20,IBBUF+21]
	SETZM IBBUF+20	;CLEAR OUT EVERYTHING EXCEPT POINTERS TO SYS DIR
	BLT 1,IBBUF+777
	PUSHJ P,RDIB1	;READ IN SYS DIR AND SAVE
;
;	SAVE THE DISK-BIT-TABLE FILE
	MOVE 1,[XWD 100001,1]
	HRROI 2,[ASCIZ /<SYSTEM>DSKBTTBL.;1/]
	GTJFN
	0
	MOVE 2,[XWD 25,0]	;FIND IB ADR
	MOVEI 3,IBBUF
	GTFDB
	MOVE 1,FDBADR+IBBUF
	PUSHJ P,RDIB		;SAVE THE FILE
;
	MOVE 14,CHKLOC		;WRITE OUT CHECKSUM PAGE
	MOVEI 3,CHKBUF
	SETZM 13
	PUSHJ P,WRPAG		;WRITE OUT
	TYPEN <CHECKPOINT COMPLETE
>
	JRST QUIT

;
RDIB:		;READ IN AN INDEX BLOCK AND WRITE OUT DATA PAGES
	MOVEI 3,IBBUF
	PUSHJ P,RD
RDIB1:
	MOVEM 15,CHKBUF(11)	;SAVE DSK ADR OF IB
	MOVEM 13,CHKBUF+1(11)	;SAVE PAGE OFFSET IN SAVE AREA
	ADDI 11,2
	PUSHJ P,WRPAG	;WRITE OUT THE INDEX BLOCK
	MOVSI 12,-1000   ;READ DATA PAGES
RDIB3:
	MOVE 1,IBBUF(12)
	JUMPE 1,RDIB2
	MOVEI 3,DTABUF
	PUSHJ P,RD
	MOVE 1,DIRDBK-DIRORG+DTABUF	;GET ADR OF DIRECTORY IB
	SKIPN FDADR	;ALREADY HAVE IT
	MOVEM 1,FDADR
	PUSHJ P,WRPAG	;WRITE OUT DATA PAGE
RDIB2:
	AOBJN 12,RDIB3
	POPJ P,

WRPAG:
	MOVSI 1,-1000	;CHECKSUM PAGE BEFORE WRITING OUT
	SETZM 4		;INIT CHKSUM
WRPAG1:
	XOR 4,0(3)
	ADDI 3,1	;GO TO NEXT WORD
	AOBJN 1,WRPAG1
	MOVEM 4,CHKBUF+OFS(13)   ;SAVE IN CHECKSUM BUFFER
	ADDI 13,1
	SUBI 3,1000	;GET ADR BACK
	MOVE 1,14	;NEXT SAVE ADR ON DISK
	MOVE 2,[XWD 10,1000]
	DSKOP
	JUMPN 1,[
		HRROI 1,[ASCIZ /WRITE ERROR AT /]
		PSOUT
		MOVEI C,10
		MOVE B,14  ;DSK ADR
		TLZ B,DSKMSK
		PUSHJ P,TTNOUT
		HRROI 1,[ASCIZ / CONTINUING
/]
		PSOUT
		JRST .+1
		]
	ADDI 14,NSECPG	;GO TO NEXT ADDRESS
	CAMN 14,[400010000000+CHKARA+CHKSIZ-1]
	JRST [HRROI 1,[ASCIZ /SAVE AREA FULL--ABORTED
/]
		PSOUT
		JRST QUIT]
	POPJ P,0

RD:
	MOVE 15,1	;SAVE DSK ADR FOR LATER
	TLO 1,(1B0)
	MOVEI 2,1000	;SIZE
	DSKOP
	SKIPN 1		;ERROR?
	POPJ P,
	HRROI 1,[ASCIZ /READ ERROR AT /]
	MOVEI C,10
	MOVE B,15
	TLZ B,DSKMSK
	PUSHJ P,TTNOUT	;WRITE OUT NUMBER
	HRROI 1,[ASCIZ / CHECKPOINT ABORTED
/]
	PSOUT
>;END REPEAT 0
	JRST QUIT
	END START
;
