;<AUGUST>MAGTAP.MAC;13 21-Jan-82 12:38:31, Edit by FRENCH
;MAKE MTAIDO REAL FLAG, DON'T INIT IT IN MTAINI
;<AUGUST>MAGTAP.MAC;12 12-Jan-82 15:41:14, Edit by FRENCH
;ALLOW MOUNT AND DISMAOUT NOPS WITHOUT ASSIGN CHECK.
;ALLOW GDSTS WITHOUT ASSIGN CHECK (BUT NOT SDSTS)
;<AUGUST>MAGTAP.MAC;11 12-Jan-82 12:58:56, Edit by FRENCH
;ALL MTA OPERATIONS REQUIRE DEVICE BE ASSIGNED FIRST
;ADDED MTAASS MACRO AND SUPPORT ROUTINES TO DO THIS
;<FOONEX>MAGTAP.MAC;9 24-Sep-81 16:12:42, Edit by FRENCH
;FIX BUGGY .MTREA.  BUGGY ONLY IF NON-INTERRUPTABLE MODE
;SWAP USAGE OF ACS A AND B IN THAT ROUTINE
;<FOONEX>MAGTAP.MAC;8 20-Sep-81 16:32:14, Edit by FRENCH
;add mtaido so interruptable and non-inTERRUPTABLE CAN COEXIST
;<FOONEX>MAGTAP.MAC;5 16-Sep-81 15:44:04, Edit by FRENCH
;ADD INTERRUPTABLE READ AND WRITE RECORD STUFF
;DSK:<FOONEX>MAGTAP.MAC;4 31-Oct-80 17:32:33, Edit by PETERS
; Fix MTDRET errors properly returned to caller
;DSK:<FOONEX>MAGTAP.MAC;3 30-Oct-80 18:08:23, Edit by PETERS
; Fix activity test junk so it works right
;DSK:<FOONEX>MAGTAP.MAC;2 30-Oct-80 16:54:16, Edit by PETERS
; Fix a couple crocks and add support for EBCDIC data mode
;DSK:<FOONEX>MAGTAP.MAC;1  2-Jul-80 17:37:28, Edit by PETERS
; First pass at DMA magtape interface for F3
;<134-TENEX>MAGTAP.F3A;18    14-Aug-79 16:14:15    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;17    10-Aug-79 19:04:07    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;16    10-Aug-79 18:31:50    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;15     2-Aug-79 15:33:36    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;14     2-Aug-79 15:13:41    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;13     1-Aug-79 23:26:59    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;12     1-Aug-79 23:20:12    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;11     1-Aug-79 23:12:18    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;10     1-Aug-79 21:08:45    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;9     1-Aug-79 19:36:24    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;8     2-Jul-79 16:03:33    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;7    22-Jun-79 17:40:22    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;6    20-Jun-79 13:26:07    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;5    19-Jun-79 21:31:29    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;4    19-Jun-79 21:14:34    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;3    19-Jun-79 20:31:54    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;2    19-Jun-79 15:42:40    EDIT BY PETERS
;<134-TENEX>MAGTAP.F3A;1    17-Jun-79 16:55:53    EDIT BY PETERS

;TENEX MAGTAPE MODULE FOR F3A

SEARCH STENEX,PROLOG
TITLE MAGTAP

INTERN MTAINI,MTARST,MTACHK,MTASV,MTADTB
EXTERN MTATIM,CPOPJ,SKPRET,BUGHLT,DISE,BHC,EDISMS
EXTERN DEVUNT,DEVCHR,NDEV,DEVX4

;PARAMETERS AND DEFINITIONS FOR F3A MAGTAPE

;BITS IN RIGHT HALF MTASTS - DO NOT CHANGE - THESE ARE DEFINED BY THE
;GDSTS AND SDSTS MAGTAPE DEVICE SPECIFIC STUFF

MTAILW==400000		;LAST OPERATION WAS A WRITE AND WRITES ARE PROHIBITED
MTADVE==200000		;TIMEOUT ON LAST OPERATION
MTAIOE==100000		;LAST OPERATION SUFFERED FROM AN IO DATA ERROR
MTASAE==040000		;SUPPRESS AUTOMATIC ERROR CORRECTION
MTAEOF==020000		;EOF WAS SEEN DURING THE LAST OPERATION
MTALNE==010000		;LAST OPERATION WAS A READ AND RECORD LENGTH WAS WRONG
MTABOT==004000		;DRIVE IS AT LOAD POINT
MTAEOT==002000		;DRIVE IS AT END OF TAPE
MTAPAR==001000		;ON IF PARITY EVEN, OFF IF ODD
MTADEN==000600		;DENSITY FIELD
MTADFD==000000		;DENSITY FIELD, SYSTEM DEFAULT (HIGH)
MTALOD==000200		;DENSITY FIELD, SET LOW DENSITY
MTAMED==000400		;DENSITY FIELD, SET MEDIUM DENSITY
MTAHID==000600		;DENSITY FIELD, SET HIGH DENSITY

;MACRO SOFTWARE MAGTAPE OPERATION CODES - DO NOT CHANGE - THESE ARE
;DEFINED BY THE MTOPR MAGTAPE DEVICE SPECIFIC STUFF

MTAREW==000001		;REWIND TAPE
MTAWEF==000003		;WRITE EOF
MTAFSR==000006		;FORWARD SPACE ONE RECORD
MTABSR==000007		;BACK SPACE ONE RECORD
MTAUNL==000011		;REWIND AND UNLOAD
MTAWRG==000013		;WRITE GAP
MTAFSF==000016		;FORWARD SPACE ONE FILE
MTABSF==000017		;BACK SPACE ONE FILE
MTAEBC==000020		;SET DATA MODE EBCDIC
MTADEC==000021		;SET DATA MODE CORE DUMP (DEC)

;READ AND WRITE RECORD ARE CONSIDERED INTERNALLY HERE AS OPERATION CODES

MTARDR==000100		;READ ONE RECORD
MTAWRR==000101		;WRITE ONE RECORD

;MTOPER FUNCTION TYPES KNOWN TO MICROCODE - MAY BE DIFFERENT THAN THOSE
;USED BY MTOPR JSYS - PASSED TO MICROCODE AS THE E OF AN MTOPER

MICREW==000000		;REWIND TAPE
MICWEF==000001		;WRITE EOF
MICFSR==000005		;FORWARD SPACE ONE RECORD
MICBSR==000006		;BACK SPACE ONE RECORD
MICERG==000013		;ERASE GAP
MICEBC==000050		;SET DATA MODE EBCDIC
MICDEC==000051		;SET DATA MODE CORE DUMP (DEC)

;OPDEFS FOR MAGTAPE IOTS

OPDEF MTOPER [726000,,0]	;CONTROL FUNCTION IOT
OPDEF MTRSTS [727000,,0]	;READ STATUS IOT
OPDEF MTWRIT [731000,,0]	;WRITE E WORDS STARTING AT (AC)
OPDEF MTREAD [732000,,0]	;READ E WORDS STARTING AT (AC)
OPDEF MTCONI [733000,,0]	;DO CONI
OPDEF MTCONO [734000,,0]	;DO CONO
OPDEF MTCNSO [735000,,0]	;DO CONSO (NO CONSZ, NOT NEEDED)
OPDEF MTDATI [736000,,0]	;DO DATAI

;CONI BITS: B18 - OVERRUN
;	    B19 - CNTRLR BUSY
;	    B20 - FMTR BUSY
;	    B32 - INTERRUPT FLAG
;	    B33-35 - PI LEVEL

;CONO BITS: B29 - CLEAR FMTR
;	    B31 - CLEAR INTERRUPT FLAG
;	    B33-35 - PI LEVEL (0 FOR OFF)

;DATAI BITS: RETNRS MICFLG ETC BITS DFINED BELOW


;MICROCODE TAPE STATUS BITS RETURNED IN LH AC AFTER MTREAD AND MTWRIT IOTS

MICFLG==400000		;SOME FLAG IS BEING RETURNED BY THE MICROCODE
MICEOF==200000		;EOF SEEN FLAG FROM MICROCODE
MICTPE==100000		;TAPE PARITY ERROR FLAG FROM MICROCODE
MICLNE==040000		;LENGTH ERROR FLAG FROM MICROCODE

;HARDWARE STATUS BIT DEFINITIONS RETURNED IN RIGHT HALF BY MTRSTS

HDWNLN==000040		;UNIT IS ONLINE
HDWREW==000020		;UNIT IS REWINDING
HDWFPT==000010		;UNIT IS WRITE PROTECTED
HDWBOT==000004		;UNIT IS AT LOAD POINT
HDWRDY==000002		;UNIT IS READY
HDWEOT==000001		;UNIT IS AT END OF TAPE


;BITS FOUND IN LH MTAIFG

MTIPND==400000		;UNIT IS PENDING A COMPLETION INTERRUPT


;STORAGE DECLARATIONS FOR MAGTAPE MODULE

LS MTASVR,1		;MAGTAPE INTERRUPT RETURN WORD
LS MTALCK,MTAN		;LOCK WORD FOR MAGTAPE UNITS
LS MTASTS,MTAN		;ZERO ELSE LH=-1, RH=DEVICE DEPENDENT STATUS BITS
LS MTAICM,MTAN		;INTERRUPT COMMUNICATION CELL, GETS MICFLG ETC
LS MTAIFG,MTAN		;INTERRUPT STATUS CELL LH=FLAGS,,RH=RETRY COUNT FOR WRT
LS MTAXFR,MTAN		;ZERO ELSE LAST XFER WORD FOR THIS UNIT


;INITIALIZATION AND RESTART ROUTINE

USE RESPC

MTAIDO:	1			;NON-ZERO TO GET INTERRUPTABLE OPERATION

MTAINI:
MTARST:	MTCONO 120		;CLEAR FMTR, CLEAR INT FLAG, CLEAR PI LEVEL
	MOVSI UNIT,-MTAN	;DO THIS FOR EACH UNIT
MTARS1:	SETOM MTALCK(UNIT)	;UNLOCK LOCK
	SETZM MTASTS(UNIT)	;SAY THIS UNIT NOT OPEN
	SETZM MTAICM(UNIT)	;CLEAR INTERRUPT COMM CELL
	SETZM MTAIFG(UNIT)	;CLEAR INTERRUPT FLAG CELL
	SETZM MTAXFR(UNIT)	;SAY NO XFERS EVER ATTEMPTED ON THIS UNIT
	AOBJN UNIT,MTARS1	;LOOP IF MORE UNITS TO INITIALIZE
	RET

;PERIODIC CHECK OF MAGTAPE - CALLED HERE FROM SCHEDULER CLOCK ROUTINE

MTACHK:	MOVEI A,^D10000		;DO THIS EVERY TEN SECONDS
	MOVEM A,MTATIM		;LEAVE FOR CLOCK COUNTDOWN
	RET			;FOR NOW THERE IS NOTHING TO CHECK...

;INTERRUPT SERVICE ROUTINE FOR MAGTAPE
;ACS 0-4 SAVED

MTASV:	XWD MTASVR,.+1		;JSYS HERE FROM PISRV
	SKIPE MTAIDO		;INTERRUPTABLE OPERATION?
	MTCNSO 10		;IS THIS INTERRUPT FOR US?
	 JRST @MTASVR		;NOTA...
	MTCONO 20		;CLEAR FLAG AND TURN OFF INTERRUPTS
	SETZ A,			;ONLY ZEROTH UNIT!!
	MTDATI MTAICM(A)	;READ STATUS FOR 0TH UNIT (DUMB CNTRLR)
	MOVSI B,MTIPND
	ANDCAM B,MTAIFG(A)	;MTIPND NOW OFF
	JRST @MTASVR		;DISMISS

;SCHEDULER TEST FOR ACTIVE UNIT

ACTTST:	MTRSTS C		;GET STATUS
	TRNN C,HDWNLN		;ON LINE?
	 JRST 1(D)		;NO-OFFLINE
	MOVE B,MTAIFG(A)	;GET INTERRUPT FLAGS
	SKIPE MTAIDO		;INTERRUPTABLE OPERATION?
	 TLNN B,MTIPND		;INTERRUPT PENDING?
	TRNE C,HDWREW		;NO-IS UNIT REWINDING?
	 JRST 0(D)		;STILL ACTIVE (ONLINE, INT PNDG OR RWNDNG)
	JRST 1(D)		;NOT ACTIVE (ONLINE, NO INT PNDING, NOT RWNDNG)

;SCHED TEST TO SEE IF INTERRUPT PENDING FOR UNIT
;UNIT IN A

PNDTST:	MOVSI B,MTIPND
	TDNE B,MTAIFG(A)	;INT STILL PENDING?
	 JRST 0(4)		;YES
	JRST 1(4)		;NO-WAKE UP



USE SWAPPC

;CHECK THAT DEVICE ASSIGNED
;DO POPJ IF NOT WITH ERROR # IN 1
;DEV SET UP FROM CHKJFN!
;CLOBBERS NO ACS EXCEPT AC1 ON ERROR

DEFINE MTAASS
<	CALL MTAACK		;CHECK ON ASSIGNMENT
	 RET			;ERROR # IN 1
>				;OK FALLS THRU

;SKIP IF OK TO DO MAG TAPE OP
;NO SKIP IF NOT, ERROR # IN 1
;CLOBBERS NO ACS

MTAACK:	PUSH P,1		;CLOBBER NO ACS
	PUSH P,2
	HLRZ 2,DEV		;UNIT #
	CALL MTADEV
	 JRST MTAAC2		;SOMETHING WRONG IF THIS FAILED
	HLRZ 1,DEVUNT(1)	;GET ASSIGNING JOB #
	CAME 1,JOBNO		;US?
	 JRST MTAAC2		;NO
	AOS -2(P)		;YES-SKIP RET
MTAAC1:	POP P,2
	POP P,1
	RET

MTAAC2:	MOVEI 1,DEVX4		;ERROR # IN AC 1
	MOVEM 1,-1(P)		;ONTO STACK FOR POPING
	JRST MTAAC1		;NO SKIP


;ACCEPTS MTA UNIT # IN 2
;RETURNS DEVICE # IN RH 1 (REALLY AOBJN PTR IN 1)

MTADEV:	PUSH P,2		;SAVE ACS
	PUSH P,3
	HRLI 2,2		;PUT MTA DEVICE TYPE IN LH 2
	MOVNI 1,NDEV
	HRLZS 1			;1/ -NDEV,,0 AOBJN PTR
MTADE1:	HLLZ 3,DEVCHR(1)	;GET DEVICE TYPE IN LH 3
	TLZ 3,777000		;ONLY
	HRR 3,DEVUNT(1)		;AND UNIT # IN RH 3
	CAME 2,3		;RIGHT DEVICE AND UNIT #?
	 AOBJN 1,MTADE1		;NO-LOOP TIL FOUND
	POP P,3			;RESTORE ACS
	POP P,2
	JUMPL 1,SKPRET		;SKPRET IF FOUND
	RET			;RET IF NOT FOUND



;MAGTAPE DEVICE DEPENDENT DISPATCH TABLE FOR VARIOUS LOGICAL OPERATIONS

MTADTB:	CPOPJ			;SET DIRECTORY
	CPOPJ			;NAME LOOKUP
	CPOPJ			;EXTENSION LOOKUP
	CPOPJ			;VERSION LOOKUP
	CPOPJ			;FILE PROTECTION INSERTION
	CPOPJ			;FILE ACCOUNT INSERTION
	CPOPJ			;FILE STATUS INSERTION
	MTAOPN			;FILE OPEN
	CPOPJ			;SEQUENTIAL INPUT
	CPOPJ			;SEQUENTIAL OUTPUT
	MTACLZ			;FILE CLOSE
	CPOPJ			;FILE RENAME
	CPOPJ			;FILE DELETION
	MTDMPI			;DUMP INPUT
	MTDMPO			;DUMP OUTPUT
	SKPRET			;MOUNT DEVICE
	SKPRET			;DISMOUNT DEVICE
	CPOPJ			;INITIALIZE DIRECTORY
	MMTOPR			;MTOPR HANDLER
	MTAGDS			;GET DEVICE STATUS
	MTASDS			;SET DEVICE STATUS



;FILE OPEN ROUTINE FOR MAGTAPE

MTAOPN:	MTAASS			;CHECK TO SEE THAT IT IS ASSIGNED
	TLNE STS,74000		;CHECK REQUESTED ACCESS
	JRST MTILAC		;ACCESS OTHER THAN READ OR WRITE REQUESTED
	LDB A,[POINT 4,STS,35]	;CHECK REQUESTED MODE
	CAIE A,17		;BETTER BE DUMP IO MODE
	JRST MTILMD		;BUT ITS NOT...
	HLRZ UNIT,DEV		;GET UNIT
	NOINT			;PREVENT INTERRUPTS WHILE LOCKED
	LOCK MTALCK(UNIT)	;LOCK IT
	SKIPE MTASTS(UNIT)	;THIS UNIT ALREADY OPEN?
	JRST MTBUSY		;YES, LOSE
	MOVSI IOS,-1		;NO, BUT IT IS NOW
	MOVEM IOS,MTASTS(UNIT)	;MARK IT AS SUCH AND ZERO INITIAL STATUS
	SETZM MTAICM(UNIT)	;CLEAR INTERUPT COMMUNICATION WORD
	SETZM MTAIFG(UNIT)	;CLEAR INTERUPT FLAG WORD
	MTOPER A,MICDEC		;DEFAULT DATA MODE IS CORE DUMP (SET IN UCODE)
	UNLOCK MTALCK(UNIT)	;UNLOCK UNIT
	OKINT			;OK TO INTERRUPT NOW
	JRST SKPRET		;SAY SUCESSFULLY OPENED!

MTILAC:	MOVEI A,OPNX15		;NON READ/WRITE ACCESS NOT ALLOWED
	RET

MTILMD:	MOVEI A,OPNX14		;ILLEGAL MODE
	RET

MTBUSY:	MOVEI A,OPNX9		;FILE BUSY
	UNLOCK MTALCK(UNIT)	;UNLOCK UNIT
	OKINT			;OK TO INTERRUPT NOW
	RET

;FILE CLOSE ROUTINE FOR MAGTAPE

MTACLZ:	MTAASS			;CHECK TO SEE THAT IT IS ASSIGNED
	HLRZ UNIT,DEV		;GET UNIT
	NOINT			;PREVENT INTERRUPTS WHILE LOCKED
	LOCK MTALCK(UNIT)	;LOCK IT
	SETZM MTASTS(UNIT)	;SAY UNIT NOT OPEN ANY MORE
	SETZM MTAICM(UNIT)	;CLEAR INTERUPT COMMUNICATION WORD
	SETZM MTAIFG(UNIT)	;CLEAR INTERUPT FLAG WORD
	SETZM MTAXFR(UNIT)	;SAY NO TRANSFERS EVER DONE ON THIS UNIT
	MTOPER A,MTADEC		;DEFAULT DATA MODE IS CORE DUMP (SET IN UCODE)
	UNLOCK MTALCK(UNIT)	;UNLOCK LOCK
	OKINT			;OK TO INTERRUPT NOW
	JRST SKPRET		;RETURN OK

;DUMP INPUT/OUTPUT ROUTINES FOR MAGTAPE

MTDMPI:	SKIPA B,[MTARDR]	;IF DUMPI THEN OPERATION IS READ
MTDMPO:	MOVEI B,MTAWRR		;ELSE IF DUMPO THEN OPERATION IS WRITE
	MTAASS			;CHECK TO SEE THAT IT IS ASSIGNED
	EXCH A,B		;PUT THESE IN RIGHT ORDER FOR MTDOOP
	TLC B,-1		;CONVERT IOWD FORMAT TO
	ADD B,BHC+1		;WORD-COUNT,,MEMORY-ADDRESS-FIRST FORMAT
	JRST MTDOOP		;GO PERFORM MAGTAPE OPERATION

;MTOPR ROUTINE FOR MAGTAPE

MMTOPR:	MTAASS			;CHECK TO SEE THAT IT IS ASSIGNED
	HRRZ A,B		;PUT OP-CODE IN A WHERE IT'S WANTED
	CAIL A,MTARDR		;IS OP-CODE WITHIN RANGE?
	SETZ A,			;NO, DO NO-OP RESET INSTEAD
	JRST MTDOOP		;GO DO IT

;GDSTS ROUTINE FOR MAGTAPE

MTAGDS:	HLRZ UNIT,DEV		;GET UNIT
	NOINT			;PREVENT INTERRUPTS WHILE LOCKED
	LOCK MTALCK(UNIT)	;LOCK IT
	CALL DISACT		;WAIT FOR UNIT TO BE INACTIVE
	HRRZ A,MTASTS(UNIT)	;GIVE MASTER STATUS BITS TO USER
	UNLOCK MTALCK(UNIT)	;UNLOCK UNIT
	OKINT			;OK TO INTERRUPT NOW
	RET

;SDSTS ROUTINE FOR MAGTAPE

MTASDS:	MTAASS			;CHECK TO SEE THAT IT IS ASSIGNED
	HLRZ UNIT,DEV		;GET UNIT
	NOINT			;PREVENT INTERRUPTS WHILE LOCKED
	LOCK MTALCK(UNIT)	;LOCK IT
	CALL DISACT		;WAIT FOR UNIT TO BE INACTIVE
	MOVEI B,MTASAE!MTAPAR!MTADEN	;PREPARE MASK OF BITS TO TWIDDLE
	MOVE IOS,MTASTS(UNIT)	;GET CURRENT STATUS
	AND A,B			;MASK OFF BITS USER SHOULDN'T CHANGE
	ANDCAM B,IOS		;ZERO CHANGABLE BITS IN CURRENT STATUS
	IORM A,IOS		;NOW UPDATE THEM WITH USER REQUEST
	HRROM IOS,MTASTS(UNIT)	;AND PUT THEM BACK IN MASTER STATUS WORD
	UNLOCK MTALCK(UNIT)	;UNLOCK UNIT
	OKINT			;OK TO INTERRUPT NOW
	RET

;ACTUAL MAGTAPE CONTROL ROUTINE
;CALLED WITH OP-CODE IN A, MTAXFR WORD IF ANY IN B
;UPDATES MTASTS AFTER OP AND SETS IO DATA ERROR AND EOF FLAGS IN AC ZERO
;IF NEEDED

MTDOOP:	HLRZ UNIT,DEV		;GET UNIT
	NOINT			;PREVENT INTERRUPTS WHILE LOCKED
	LOCK MTALCK(UNIT)	;LOCK IT
	CALL DISACT		;WAIT FOR UNIT TO BE INACTIVE
	MOVE IOS,MTASTS(UNIT)	;GET CURRENT STATUS
	ANDI IOS,MTASAE!MTAPAR!MTADEN	;ZERO EVERYTHING EXCEPT USER MODES
	MTRSTS C		;GET UNIT STATUS
	TEST(O,ERRF)		;SET ERROR FLAG IN CASE UNIT IS LOSING
	TRNE C,HDWNLN		;SKIP IF UNIT NOT ONLINE
	TRNN C,HDWRDY		;SKIP IF UNIT READY
	JRST MTDRET		;UNIT IS LOSING, DON'T TRY TO EXECUTE OP
	TEST(Z,ERRF)		;UNIT OK, TAKE BACK BAD BIT
	CAIE A,MTAREW		;REWIND?
	CAIN A,MTAUNL		;OR REWIND-UNLOAD?
	JRST REWIND		;YES, SAME FOR BOTH SINCE DRIVE WON'T UNLOAD
	CAIN A,MTAWEF		;WRITE END OF FILE?
	JRST WRTEOF		;YES
	CAIN A,MTAFSR		;FORWARD SPACE RECORD?
	JRST FSPREC		;YES
	CAIN A,MTABSR		;BACK SPACE RECORD?
	JRST BSPREC		;YES
	CAIN A,MTAWRG		;WRITE GAP?
	JRST WRTGAP		;YES
	CAIN A,MTAFSF		;FORWARD SPACE FILE?
	JRST FSPFIL		;YES
	CAIN A,MTABSF		;BACK SPACE FILE?
	JRST BSPFIL		;YES
	CAIN A,MTAEBC		;SET DATA MODE EBCDIC?
	JRST SETEBC		;YES
	CAIN A,MTADEC		;SET DATA MODE CORE DUMP?
	JRST SETDEC		;YES
	CAIN A,MTARDR		;READ RECORD?
	JRST .MTREA		;YES
	CAIN A,MTAWRR		;WRITE RECORD?
	JRST .MTWRI		;YES

;FALL THROUGH HERE FOR NOP CASE OR JUMP HERE TO RETURN

MTDRET:	MTRSTS A		;GET STATUS TO A
	TRNE A,HDWNLN		;SKIP IF UNIT NOT ONLINE
	TRNN A,HDWRDY		;SKIP IF UNIT READY
	TRO IOS,MTADVE		;INFORM USER OF UNIT'S UNTIMELY DEMISE
	TRNE A,HDWBOT		;AT LOAD POINT?
	TRO IOS,MTABOT		;YES, UPDATE MASTER STATUS
	TRNE A,HDWEOT		;AT EOT?
	TRO IOS,MTAEOT		;YES, UPDATE MASTER STATUS
	HRROM IOS,MTASTS(UNIT)	;PUT BACK UPDATED STATUS BITS
	TRNE IOS,MTAILW!MTADVE!MTAIOE!MTALNE!MTAEOT	;SADNESS BITS ON?
	TEST(O,ERRF)		;YES, NOTIFY CALLER OF LOSSAGE
	TRNE IOS,MTAEOF		;EOF BIT ON?
	TEST(O,EOFF)		;YES, NOTIFY CALLER OF EOF
	UNLOCK MTALCK(UNIT)	;UNLOCK LOCK
	OKINT			;OK TO INTERRUPT NOW
	RET			;RETURN TO CALLER OF DEVICE DEPENDENT ROUTINES

;REWIND AND REWIND-UNLOAD

REWIND:	MTRSTS A		;GET HARDWARE STATUS
	TRNE A,HDWNLN		;IS UNIT OFFLINE?
	TRNE A,HDWBOT		;OR NOW AT LOAD POINT?
	JRST MTDRET		;YES, RETURN AND UPDATE STATUS
				;NO-MUST MOVE TAPE
	MTOPER A,MICREW		;EXECUTE REWIND, NO INTERRUPT EXPECTED
	JRST MTDRET		;RETURN AND UPDATE STATUS


;WRITE EOF

WRTEOF:	MTRSTS A		;FETCH HARDWARE STATUS BITS TO A
	TEST(NE,WRTF)		;IF UNIT IS NOT OPENED FOR WRITE
	TRNE A,HDWFPT		;OR NOT WRITE ENABLED IN HARDWARE
	 JRST MTDRET		;THEN THIS IS A NO-OP
	CALL INTRDY
	MTOPER A,MICWEF		;ELSE DO IT, OP CODE #1
	CALL INTWAT
	JRST MTDRET		;RETURN AND UPDATE STATUS

;FORWARD SPACE RECORD

FSPREC:	MTRSTS A		;GET STATUS TO A
	TRNE A,HDWEOT		;AT EOT?
	 JRST MTDRET		;YES, DO NOTHING
				;NO-MUST MOVE TAPE
	CALL INTRDY
	MTOPER A,MICFSR		;SKIP RECORD AND GET STATUS TO A
	CALL INTWAT
	TLNE A,MICEOF		;EOF SEEN?
	TRO IOS,MTAEOF		;YES, REFLECT IN STATUS
	JRST MTDRET		;UPDATE STATUS AND RETURN

;BACK SPACE RECORD

BSPREC:	MTRSTS A		;GET STATUS TO A
	TRNE A,HDWBOT		;AT LOAD POINT?
	JRST MTDRET		;YES, DO NOTHING
				;NO-MUST MOVE TAPE
	CALL INTRDY
	MTOPER A,MICBSR		;BACK SPACE RECORD
	CALL INTWAT
	JRST MTDRET		;UPDATE STATUS AND RETURN

;WRITE GAP

WRTGAP:	JRST MTDRET		;THIS IS CURRENTLY A NO-OP ON THE F3A

;FORWARD SPACE FILE

FSPFIL:	MTRSTS A		;GET STATUS TO A
	TRNE A,HDWEOT		;AT EOT?
	JRST MTDRET		;YES, DO NOTHING
				;NO-MUST MOVE TAPE
	CALL INTRDY
	MTOPER A,MICFSR		;SKIP FILE AND GET STATUS TO A
	CALL INTWAT
	TLNN A,MICEOF		;EOF SEEN?
	JRST FSPFIL		;NO, KEEP LOOKING
	TRO IOS,MTAEOF		;YES, REFLECT IN STATUS
	JRST MTDRET		;UPDATE STATUS AND RETURN

;BACK SPACE FILE

BSPFIL:	MTRSTS A		;GET STATUS TO A
	TRNE A,HDWBOT		;AT LOAD POINT?
	JRST MTDRET		;YES, DO NOTHING
				;NO-MUST MOVE TAPE
	CALL INTRDY
	MTOPER A,MICBSR		;BACK SPACE RECORD AND GET STATUS TO A
	CALL INTWAT
	TLNN A,MICEOF		;EOF SEEN?
	 JRST BSPFIL		;NO, KEEP LOOKING
	CALL INTRDY
	MTOPER A,MICFSR		;YES, NOW SKIP FORWARD ONE RECORD
	CALL INTWAT
	JRST MTDRET		;UPDATE STATUS AND RETURN

SETEBC:	MTOPER A,MICEBC		;SET DATA MODE EBCDIC
	JRST MTDRET		;UPDATE STATUS AND RETURN

SETDEC:	MTOPER A,MICDEC		;SET DATA MODE CORE DUMP
	JRST MTDRET		;UPDATE STATUS AND RETURN

;READ RECORD

.MTREA:	MOVEM B,MTAXFR(UNIT)	;PRESERVE XFER WORD
	HLRZS B			;GET WORD COUNT IN B
	CAILE B,TAPBSZ		;MAKE SURE NOT TO OVERFLOW BUFFER
	MOVEI B,TAPBSZ		;FORCE FIT IF NECESSARY
	MOVEI A,TAPBUF		;PUT RECORD IN CROCK BLT BUFFER
	CALL INTRDY
	MTREAD A,0(B)		;NOW READ ONE RECORD
	CALL INTWAT
	HRRZ B,MTAXFR(UNIT)	;PREPARE TO BLT RECORD - SET "TO" OF BLT
	HLRZ C,MTAXFR(UNIT)	;RETRIEVE WORD COUNT
	CAILE C,TAPBSZ		;CHECK SIZE TO NEVER BLT MORE
	MOVEI C,TAPBSZ		;THAN BUFFER HOLDS
	ADD C,B			;CREATE "UNTIL" OF BLT
	HRLI B,TAPBUF		;SET UP "FROM" OF BLT
	BLT B,-1(C)		;MOVE BUFFER TO ULTIMATE DESTINATION
	JUMPGE A,MTDRET		;UPDATE STATUS AND RETURN IF NO FLAGS
	TLNE A,MICEOF		;EOF SEEN?
	TRO IOS,MTAEOF		;YES, SET IOS FLAG
	TLNE A,MICTPE		;TAPE ERROR LOSSAGE?
	TRO IOS,MTAIOE		;YES, SET IOS FLAG
	TLNE A,MICLNE		;LENGTH ERROR?
	TRO IOS,MTALNE		;YES, SET IOS FLAG
	TLNE A,MICEOF		;EOF SEEN?
	TEST(O,EOFF)		;YES, SET UNIVERSAL FLAG
	TLNE A,MICTPE		;TAPE ERROR LOSSAGE?
	TEST(O,ERRF)		;YES, SET UNIVERSAL FLAG
	TLNE A,MICLNE		;LENGTH ERROR?
	TEST(O,ERRF)		;YES, SET UNIVERSAL FLAG
	JRST MTDRET		;UPDATE STATUS AND RETURN

;WRITE RECORD

.MTWRI:	MTRSTS A		;GET STATUS TO A
	TRO IOS,MTAILW		;PREPARE FOR WRITE LOCK FAILURE
	TEST(NE,WRTF)		;IF UNIT IS NOT OPENED FOR WRITE
	TRNE A,HDWFPT		;OR NOT WRITE ENABLED IN HARDWARE
	JRST MTDRET		;THEN THIS IS AN ILLEGAL WRITE
	TRZ IOS,MTAILW		;ELSE TURN OFF BAD BIT
	MOVEM B,MTAXFR(UNIT)	;PRESERVE XFER WORD
	MOVEI A,TAPBUF		;PREPARE TO BLT RECORD - SET UP "TO" OF BLT
	HRL A,MTAXFR(UNIT)	;SET "FROM" OF BLT TO LOCATION OF RECORD
	HLRZ B,MTAXFR(UNIT)	;GET WORD COUNT
	CAILE B,TAPBSZ		;MAKE SURE IT IS NOT BIGGER THAN BUFFER
	MOVEI B,TAPBSZ		;ELSE BRUTALLY FORCE FIT
	BLT A,TAPBUF-1(B)	;MOVE RECORD TO BUFFER BEFORE WRITING
	MOVEI A,TAPBUF		;WRITE RECORD FROM TAPBUF
	CALL INTRDY
	MOVEI C,^D10		;10 RETRIES (UCODE CAN'T DO IT NOW)
	IORM C,MTAIFG(UNIT)	;INSTALL IN FLAG WORD
	PUSH P,A		;SAVE INCASE RETRY NECESSARY
	PUSH P,B
.MTWR0:	MTWRIT A,0(B)		;WRITE ONE RECORD
	CALL INTWAT
	TLNE A,MICTPE		;HARD ERROR? (NO RETRY FOR INTERRUPT STYLE!)
	 JRST .MTWRR		;YES-RETRY
.MTWR1:	SUB P,[2,,2]		;DISGARD RETRY SAVED INFO
	JRST MTDRET		;NO-UPDATE STATUS AND RETURN
		
.MTWR2:	TRO IOS,MTAIOE		;IO ERROR
	JRST .MTWR1		;RETURN TO USER

;HERE FOR WRITE RETRY, DEC THE RETRY COUNT AN TRY AGAIN
;IF COUNT RUNS OUT THEN JUST GO TO MTDRET TO RETURN HARD ERROR BIT
;ERROR DETECTION IN UCODE ALREADY BLASTED FMTR AND DRIVE

.MTWRR:	HRRZ A,MTAIFG(UNIT)	;GET RETRY COUNT
	SUBI A,1		;DEC IT
	HRRM A,MTAIFG(UNIT)	;UPDATE
	CAIGE A,0		;RAN OUT?
	 JRST .MTWR2		;YES-JUST RETURN TO USER	
	PUSH P,MTAIFG(UNIT)	;SAVE STATE FOR WRITE OPERATION
	CALL INTRDY		;READY FOR BACKSPACE OPERATION
	MTOPER A,MICBSR		;BACK SPACE RECORD
	CALL INTWAT
	CALL INTRDY		;READY FOR ERASE GAP
	MTOPER A,MICERG		;ERASE GAP
	CALL INTWAT
	POP P,MTAIFG(UNIT)	;RESTORE WRITE OPERATION INT STATE INFO
	MOVE A,-1(P)		;GET RETRY INFO
	MOVE B,0(P)
	CALL INTRDR		;READY FOR INT BUT DON'T HURT RETRY COUNT
	JRST .MTWR0		;XCT INSTRUCTION AGAIN



;WAIT FOR UNIT TO INTERRUPT (ALWAYS DISMIS SO TAPE DOES NOT HOG
;			    IE. IF INT ALREAY HAPPENED, DETECT IN WAIT TEST)

DISPND:	PUSH P,A		;CLOBBER NO ACS
	HRL A,UNIT		;UNIT FOR SCHED TEST!
	HRRI A,PNDTST
	JSYS EDISMS		;GO WAIT UNITL IT IS
	POP P,A
	RET			;INTERRUPT SEEN,  MICFLG ETC IN MTAICM(UNIT)



;WAIT FOR UNIT TO BE INACTIVE

DISACT:	PUSH P,A		;GETS UNIT FOR ACTTST
	PUSH P,B		;ACTTST CLOBBERS B,C
	PUSH P,C
	PUSH P,D		;WE CLOBBER D CALLING IT
	HRRZ A,UNIT		;PUT UNIT IN A FOR ACTTST
	JSP D,ACTTST		;CALL SCHED WAIT TEST AT PROCESS LEVEL
	 JRST DISAC1		;STILL ACTIVE
DISRET:	POP P,D			;QUICKIE!
	POP P,C
	POP P,B
	POP P,A
	RET

DISAC1:	HRL A,UNIT
	HRRI A,ACTTST		;PREPARE TO WAIT UNTIL UNIT INACTIVE OR OFFLINE
	JSYS EDISMS		;GO WAIT UNITL IT IS
	JRST DISRET



;INTERRUPT ROUTINES

;ACCEPTS UNIT IN UNIT
;SET MTIPND AND 0 RETRY COUNT IN MTAIFG AND CLEAR MTAICM

INTRDY:	HLLZS MTAIFG(UNIT)	;CLEAR RETRY COUNT
	JRST INTRDR

;ACCEPTS UNIT IN UNIT
;SET MTIPND (LEAVE RETRY COUNT ALONE) AND CLEAR MTAICM
;TURN ON TAPE INTERRUPTS

INTRDR:	SKIPN MTAIDO		;INTERRUPTABLE OPERATION?
	 RET			;NO, LEAVE PI LEVEL ZERO!
	PUSH P,A
	MOVSI A,MTIPND
	IORM A,MTAIFG(UNIT)	;SAY INTERRUPT PENDING
	SETZM MTAICM(UNIT)	;CLEAR COMMUNICATION WORD
	MTCONO MTACHN		;ALLOW INTERRUPTS BY SETTING PI LEVEL
	POP P,A
	RET


;ACCEPTS UNIT IN UNIT
;WAIT TIL INTERRUPT SEEN AND
;XFER STUFF FROM MTAICM TO A

INTWAT:	SKIPN MTAIDO		;INTERRUPTABLE OPERATION?
	 RET			;NO, NOTHING TO WAIT FOR!
	CALL DISPND		;WAIT FOR OP TO COMPLETE INTERRUPTABLY
	MOVE A,MTAICM(UNIT)	;XFER MICFLG ETC
	RET			;MTAICM(UNIT) HOLDS LAST INTERRUPT MICFLG ETC.


END

