;<AUGUST>TYMSRV.EDC;11  4-Mar-82 10:16:28, Edit by ECARTER
;ADDED FGWTON AND FGWTOF MACROS AND SUPPORT ROUTINES FOR BIT 2
;<AUGUST>TYMSRV.EDC;4  2-Mar-82 17:57:23, Edit by ECARTER
;ADDED GET TIME FROM TYMNET TYMOP FUNCTION 26
;<AUGUST>TYMSRV.MAC;213 26-Feb-82 15:58:44, Edit by FRENCH
;REMOVE PORT OPTION FROM GTBAUD AND STBAUD
;REQUIRE LINE CONNECTED IN TRMTCR MESSAGE VIA MESAGE MACRO
;<AUGUST>TYMSRV.MAC;211 25-Feb-82 19:30:35, Edit by ECARTER
;REMOVE BAUD RATE TABLE, DON'T TRANSLATE TYMNET CODES INTO BAUD RATES
;<AUGUST>TYMSRV.MAC;197 25-Feb-82 12:39:31, Edit by FRENCH
;ADDED FLAG LOCK, UNLOCK ETC MACROS.
;ADDED OTY2EX ENTRY POINTS FOR UNCHECKED PORT # IN 2 INSTEAD OF TTY
;<AUGUST>TYMSRV.EDC;6 24-Feb-82 18:50:13, Edit by ECARTER
;ADDED GET BAUD AND SET BAUD TYMOP FUNCTIONS
;<AUGUST>TYMSRV.PEF;4 22-Feb-82 17:16:36, Edit by FRENCH
;GET TIME FROM TYMNET ON START UP
;<EDCMON>TYMSRV.MAC;176 11-Nov-81 12:04:58, Edit by ECARTER
;REMOVED KAFLG,KIFLG,KLFLG,SMFLG,F3FLG CONDITIONALS
;<FOONEX>TYMSRV.MAC;174 15-Oct-81 15:43:47, Edit by FRENCH
;CHANGE JSYS MENTR TO MCENT
;<FOONEX>TYMSRV.MAC;173 24-Aug-81 14:09:30, Edit by FRENCH
;ADDED NEW TYMNET TTY TYPES, NOTE: GATEWAY AUX CIR IS TYPE ^D14
;<FOONEX>TYMSRV.MAC;171 24-Aug-81 11:21:44, Edit by FRENCH
;tymnet tty type is 5 bits now
;<FOONEX>TYMSRV.MAC;169 23-Jul-81 15:54:11, Edit by FRENCH
;ADDED AUXATA TYMOP FUNCTION
;<FOONEX>TYMSRV.MAC;168 22-Jul-81 15:07:24, Edit by FRENCH
;MAKE TYMFLG BE PART OF GETAB TABLE
;<FOONEX>TYMSRV.MAC;165  6-Jul-81 12:59:15, Edit by FRENCH
;ADD XON-XOFF STUFF
;<FOONEX>TYMSRV.MAC;162  4-Jun-81 17:38:04, Edit by FRENCH
;REMOVE REF TO XTTFLG
;<FOONEX>TYMSRV.MAC;159 10-Feb-81 11:50:00, Edit by FRENCH
;auxnam stuff
;<FOONEX>TYMSRV.MAC;150 30-Jan-81 11:02:45, Edit by FRENCH
;JOB 0 WAS WASTING TIME WITH CONFREE STATE LINES
;<FOONEX>TYMSRV.MAC;148 23-Jan-81 12:43:33, Edit by FRENCH
;DON'T REQUIRE LINE BE CONNECTED  ON RCVING A ZAPPER.
;IF NOT, BE QUIET AND CLEAN EVERYTHING UP
;<FOONEX>TYMSRV.MAC;145  9-Jan-81 12:46:20, Edit by FRENCH
;JOB 0 SHOULD CLEAN UP ALL DISCONNECTED STATES, NOT JUST CONAD3
;AND CONDC3.  TYMNET FLAKES AND LEAVES CONAD1,2 ETC STATES AND
;THEY NEVER GET CLEANED UP
;<FOONEX>TYMSRV.MAC;144  9-Jan-81 11:21:28, Edit by FRENCH
;SWAP DEF OF CONAD1 AND CONAD2 FOR CONSISTENCY
;DSK:<FOONEX>TYMSRV.MAC;143 16-Dec-80 12:30:07, Edit by FRENCH
;RANGE CHECK WAKEUP REASON IN AUXBL6
;DSK:<FOONEX>TYMSRV.MAC;142  6-Nov-80 11:28:04, Edit by FRENCH
;ADD B2 TO AUXBLD OPTION BITS
;DSK:<FOONEX>TYMSRV.MAC;141 30-Oct-80 15:50:18, Edit by FRENCH
;USE TYMPTR AT TYMOBK
;DSK:<PEFMON>TYMSRV.MAC;3 29-Oct-80 18:14:36, Edit by FRENCH
;DEAL WITH RCA ABOVE 256K
;DSK:<FOONEX>TYMSRV.MAC;139 24-Oct-80 14:29:33, Edit by FRENCH
;UPED IBPOFF TO 512.  SINCE CHANGED TTYSRV'S IBPNBF TO 13.
;DSK:<PEFMON>TYMSRV.MAC;29 24-Oct-80 13:48:48, Edit by FRENCH
;MORE BLK IO STUFF, ESPECIALLY SETBKI,SETBKO STUFF
;DSK:<FOONEX>TYMSRV.MAC;136 22-Oct-80 19:59:54, Edit by FRENCH
;ADDED YSTSNK,YSTSAK,YSTSBD
;DSK:<FOONEX>TYMSRV.MAC;135 22-Oct-80 17:52:46, Edit by FRENCH
;ADDED YSTAX2 COUNTER FOR STATS
;DSK:<FRENCH>TYMSRV.MAC;134 22-Oct-80 12:42:01, Edit by FRENCH
;ADDE AX2CLK FOR CLEANUP CLOCK AFTER PSI HANDLED IN AUXBLD
;DSK:<FOONEX>TYMSRV.MAC;130 20-Oct-80 09:28:23, Edit by FRENCH
;TURN ON CR DELAY FLAG FOR ALL TERM TYPES WITH A,B,C PARAMS 0
;DSK:<FOONEX>TYMSRV.MAC;127 14-Oct-80 18:11:53, Edit by FRENCH
;REORGANIZE TYMIN0 FOR CHR MESSAGE SPEED AND CONSISTENCY
;DSK:<FOONEX>FOO.BAR;13 14-Oct-80 15:22:38, Edit by FRENCH
;ADDED LN AND CN TO MESAGE MACRO AND SUPPORT MASKS TYMLNW,TYMCNW
;DSK:<FOONEX>TYMSRV.MAC;127  9-Oct-80 17:39:49, Edit by FRENCH
;MORE FIXES TO AUX BUILDING STUFF
;DSK:<FOONEX>TYMSRV.MAC;126  8-Oct-80 15:23:30, Edit by FRENCH
;INIT BLKLCK TABLE IN TYMINI AND TYMRST
;DSK:<FOONEX>TYMSRV.MAC;125  3-Oct-80 15:29:47, Edit by FRENCH
;ADDED BLOCK MODE IO IMPLEMENTATION
;<FOONEX>TYMSRV.MAC;123    18-Jun-80 12:41:09    EDIT BY LYNCH
;<FOONEX>TYMSRV.MAC;122    18-Jun-80 09:19:53    EDIT BY LYNCH
;DSK:<134-TENEX>TYMSRV.MAC;120  6-May-80 20:31:24, Edit by FRENCH
;FIX BUG IN TYMRST (DON'T PASS LINE # AOBJN PTR TO PSI ROUTINES)
;TURN OFF CARRIER OFF BIT IN TTFLGS BEFORE ISSUEING INTERRUPT
;DSK:<134-TENEX>TYMSRV.MAC;119 25-Apr-80 14:09:20, Edit by FRENCH
;DON'T CLEAR SYSNDX TABLE ON BASE RESYNC
;ONLY DO IT ONCE IN TYMINI
;<134-TENEX>TYMSRV.MAC;118     4-Apr-80 16:57:15    EDIT BY PETERS
; Make TYMDOB simply return without yellow ball negotiation
;DSK:<134-TENEX>TYMSRV.MAC;117  4-Apr-80 15:13:15, Edit by FRENCH
;TYMENT TYPE A GETS NVT NOW FOR SLOW AND FAST SPEEDS
;DSK:<134-TENEX>TYMSRV.MAC;116  2-Apr-80 11:21:47, Edit by FRENCH
;CLEAR TTLPOS FOR LINE RIGHT AFTER SETYP SO GET PAGING RIGHT
;DSK:<134-TENEX>TYMSRV.MAC;115 25-Mar-80 11:28:48, Edit by FRENCH
;FIX BUG IN AUXBLD.  RESTORE USER PTR TO LOGIN STRING FOR CPYFU1
;DSK:<134-TENEX>TYMSRV.MAC;114 18-Mar-80 14:21:26, Edit by PETERS
; Fix CAPMSK reference to be EXTERNAL
;<FRENCH>TYMSRV.MAC;1    17-Mar-80 21:20:06    EDIT BY FRENCH
;TTY TYPE 16 IS VT100, FIX TYMNET PARAMETERS FOR IT
;DSK:<134-TENEX>TYMSRV.MAC;112 17-Mar-80 12:58:19, Edit by FRENCH
;DO FANCY INPUT TTY BUFFER SPLICE WHEN NECESSARY FOR IBP ADJUSTING
;FIX UP ILLEGAL EXTERNAL ARITHMETIC FOR TTY PARAMETERS
;DSK:<134-TENEX>TYMSRV.MAC;111 29-Feb-80 14:03:17, Edit by FRENCH
;MAKE PTT 5 BIT BYTES TO ALLOW FOR NEW TERMINAL PARAMETERS
;DSK:<134-TENEX>TYMSRV.MAC;110 27-Feb-80 14:43:56, Edit by FRENCH
;ADDED MORE UPTODATE TERMINAL PARAMETER CODE DEFINTIONS
;DSK:<134-TENEX>TYMSRV.MAC;109 22-Feb-80 15:05:55, Edit by FRENCH
;MAKE TYMNET THINK OF DUMMY TTY TYPES AS NVTS
;DSK:<134-TENEX>TYMSRV.MAC;108 22-Feb-80 14:56:17, Edit by FRENCH
;REWORK TERMINAL TYPE TABLES FOR AGREEMENT WITH EXEC AND TTYSRV
;PUT IBPNBF IN TTYSRV AND MAKE EXTERNAL HERE
;DSK:<134-TENEX>TYMSRV.MAC;105 21-Feb-80 20:05:22, Edit by FRENCH
;JOB 0 UNDOES POSSIBLE INPUT BUFFER DIDDLING WHEN FREEING LINE
;DSK:<134-TENEX>TYMSRV.MAC;104 21-Feb-80 19:41:28, Edit by FRENCH
;WHEN TYMNET TTY TYPE IS 0 (DESTINATION END OF AUX CIRCUIT)
;ENABLE IBP AND DIDDLE INPUT BUFFER PARAMETERS FOR LINE IN TYMCTL
;DSK:<134-TENEX>TYMSRV.MAC;103 21-Feb-80 19:26:35, Edit by FRENCH
;REWORKED IBP STUFF.  AUX CIRCUITS ALWAYS GET BUILT WITH IPBOF ENABLED
;WITH SPECIAL INPUT BUFFER PARAMETERS.  SETIBP DIDDLES BUFFER
;PARAMETERS ALSO.
;DSK:<134-TENEX>TYMSRV.MAC;102 19-Feb-80 16:50:58, Edit by FRENCH
;ADDED PRIVELEDGE CHECK FOR AUX BUILDING AT AUXBLD
;DSK:<134-TENEX>TYMSRV.MAC;101 14-Feb-80 13:59:46, Edit by FRENCH
;CONDITIONAL IBPOFF OFF F3FLG
;DSK:<134-TENEX>TYMSRV.MAC;100 11-Feb-80 12:54:53, Edit by FRENCH
;FIX GETLNS TO GET LINE # CORRECTLY
;DSK:<134-TENEX>TYMSRV.MAC;99 29-Jan-80 12:31:03, Edit by FRENCH
;ADDED IFN KL FOR NO CACHEING OF TYMBPG
;<134-TENEX>TYMSRV.MAC;98    27-Jan-80 18:52:22    EDIT BY PETERS
; Fix IFDEF/IFNDEF F3AFLG to IFE/IFN F3FLG
;DSK:<134-TENEX>TYMSRV.MAC;97 24-Jan-80 17:26:11, Edit by FRENCH
;ADDED JUNK IMULI'S IN FNSYNC FOR MICROCODE LOSAGE DELAY REQUIRED FOR F3A
;DSK:<134-TENEX>TYMSRV.MAC;95 23-Jan-80 23:03:44, Edit by FRENCH
;MORE BUG FIXES AS RESULT OF LATE NIGHT DEBUGGING
;<134-TENEX>TYMSRV.MAC;88    20-Jan-80 23:41:35    EDIT BY FRENCH
;FIX MORE QUEUEING BUGS
;DSK:<134-TENEX>TYMSRV.MAC;83 20-Jan-80 17:49:37, Edit by FRENCH
;VARIOUS BUG FIXES FIRST FIRST PASS AT AUX CIRCUIT QUEUE DEBUGGING
;DSK:<134-TENEX>TYMSRV.MAC;81 15-Jan-80 16:39:13, Edit by FRENCH
;DSK:<134-TENEX>TYMSRV.MAC;79 14-Jan-80 19:45:02, Edit by FRENCH
;ADDED TYMRLA ROUTINE, CALL TTRLAB IN JOB 0 CLEANUP OF LINES
;<134-TENEX>TYMSRV.MAC;78    21-Dec-79 23:48:58    EDIT BY LOWE
;CHANGED F3FLG USAGE FROM IFE/IFN TO IFDEF/IFNDEF AS USED BY JCP
;<DSK:<134-TENEX>TYMSRV.MAC;75> 20-Dec-79 12:24:26, Edit by FRENCH
;ADDED RETY WIN MESSAGE IF FNSYNC RETRY SUCCEEDS
;<DSK:<134-TENEX>TYMSRV.MAC;74> 19-Dec-79 12:05:28, Edit by FRENCH
;SEND RESET IF ALARM GOES OFF, ALARM PERIOD UP TO 1 MINUTE
;<DSK:<134-TENEX>TYMSRV.MAC;73> 18-Dec-79 20:26:03, Edit by FRENCH
;CONTINUED HACKING OF JOB 0 TYMNET NODE RESETING LOGIC
;<134-TENEX>TYMSRV.MAC;70    18-Dec-79 18:14:21    EDIT BY FRENCH
;FIX TYMCHK FOR BAD MOVEM 1,TYMRST (SHOULD BE TYMSTS)
;CHANGED IBPOFF FROM 40 TO 200
;FIX FENCEPOST PROBLEM FOR TERMINAL TYPES IN TYMX0.
;MAKE TYMRST JOB 0 FUNCTION SO FOONLY NODE RESYNC CAN TAKE LONG TIME
;WITHOUT HANGING MACHINE.
;TERMINATE AUX CIRCUIT STRINGS WITH ";" INSTEAD OF ANOTHER SUPER AUX REQ.
;RESET COMMUNICATIONS HEADER BEFORE DOING INTERAFCE RESET
;RESET YHCRSH VIA TEMPLATE TOO IN TYMRST
;ADDED CODE FOR FOO - NODE INTERFACE VIA F3FLG DEFINED IN PARAMS
;<134-TENEX>TYMSRV.MAC;48    15-Dec-79 17:04:53    EDIT BY FRENCH
;REWORK TYMCTL H2H DETECTION NOT TO EAT NON H2H CHARS IN ANY WAY
;FIX CROCK AT TYMX9 IF LINE NO LONGER CONNECTED, ADDED TYMBYE FOR THAT
;<134-TENEX>TYMSRV.MAC;47    14-Dec-79 19:51:45    EDIT BY FRENCH
;ADDED NTHOST OUTPUT TO BASE IN TYMRST CODE
;<134-TENEX>TYMSRV.MAC;46    14-Dec-79 13:38:28    EDIT BY PETERS
; Changed TYMBUF to TYMBAS in two places to make it possible
; To assemble for a standard (non-SUMEX) Tymbase
;<134-TENEX>TYMSRV.MAC;30    12-Dec-79 21:00:08    EDIT BY FRENCH
;MERGED AUXQUE STUFF.  NO TURNING BACK NOW
;<134-TENEX>TYMSRV.MAC;22     9-Dec-79 20:13:23    EDIT BY FRENCH
;ADDED TYMROK ROUTINE TO BE CALLED FROM RELD TO PREVENT USERS
;FROM STEPPING ON AUX CIRCUITS WITHOUT USING AUXRLS TYMOP FUNCTION.
;<134-TENEX>TYMSRV.MAC;21     9-Dec-79 19:11:21    EDIT BY FRENCH
;ADDED CONAH1 AND CONAH2 AUX CIRCUIT STATES FOR FLOW CTL IN HANGUP CODE
;<134-TENEX>TYMSRV.MAC;19     9-Dec-79 16:38:46    EDIT BY FRENCH
;ADDED AUXRLS FUNCTION CODE AND ROUTINE TO .TYMOP
;<134-TENEX>TYMSRV.MAC;17     7-Dec-79 15:02:38    EDIT BY FRENCH
;REWORKED PSI STUFF FOR AUX CIRCUITS AND NORMAL LINES
;AUXCIRCUITS ALWAYS GET POKED ON TERM CODE 32
;NORMAL LINES ON 30
;<PEFMON>TYMSRV.MAC;3     6-Dec-79 15:52:00    EDIT BY FRENCH
;CALL TTPS2T IN TTYSRV INSTEAD OF TTPSI2 AT TYMPS2
;<PEFMON>TYMSRV.MAC;2     5-Dec-79 20:44:35    EDIT BY FRENCH
;ADDED TYMLFP ROUTINE CALLED FROM TTYSRV TO CHECK TO SEE IF TYMNET
;LINES SHOULD GET LINEFEED PADDING BY TENEX.
;FIXED TERMINAL TYPE HANDLING, GET NVT TYPE FOR AUX CIRCUITS .
;ADDED CLEARING OF AUXINF AT SUPBAD.
;<PEFMON>TYMSRV.MAC;4    28-Nov-79 19:30:03    EDIT BY FRENCH
;ADDED UNSTYP ROUTINE FOR UNIMPLMENETED CODE IGNORING.
;CHANGED PSI TERMINAL CODE FROM 30 TO 32 AT TYMDET. (NEW TENEX
;USES 30 AND 31)
;<134-TENEX>TYMSRV.MAC;13     3-Oct-79 18:43:06    EDIT BY PETERS
;installed input backpressure crock at SETIBP
;<134-TENEX>TYMSRV.MAC;12    17-Jul-79 22:02:53    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;11     9-Apr-79 18:15:52    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;10    10-Sep-78 16:08:36    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;9    29-Aug-78 16:09:20    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;8    27-Aug-78 19:40:04    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;7    16-Aug-78 20:31:19    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;6    13-Aug-78 14:36:30    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;5    15-Jul-78 18:40:33    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;4    10-Jul-78 13:14:52    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;3     8-Jul-78 17:14:18    EDIT BY PETERS
;<134-TENEX>TYMSRV.MAC;2     1-Jun-78 15:10:03    EDIT BY PETERS
;<MON>TYMSRV.MAC;3    22-MAR-77 15:15:18    EDIT BY SWEER
; SAVE LINE AROUND TTCHI CALL IN LOGGER
;<SCHULZ>TYMSRV.MAC;2    24-NOV-76 11:04:23    EDIT BY SWEER
; FIXED TYSAVP HANDLING AND IMPROVED TTY CHECK IN .TYMOP
;<MON>TYMSRV.MAC;25    12-APR-76 16:30:36    EDIT BY SWEER
; ADDED HEATHMAN FIXES TO IGNORE DATA/TIME MSG ON STARTUP
; AND BETTER HANDLING OF INPUT BACK PRESSURE
	SUBTTL DATA DEFINITIONS, STORAGE, POINTERS, ETC
;
;	TYMBASE interface handler
;	Michael Heathman  8/74, 7/75
;	SUMEX-AIM
;	Stanford University Medical Center
;	Stanford, Ca. 94305
;

	search prolog
	title TYMSRV

;
;	EXTERNALS, INTERNALS
;
	EXTERNAL CHKTIM			;LINK TO JOBZRO
	EXTERNAL JB0FLG,BUGNTE,SETJFK ;link to SWPMON
	EXTERNAL DISE,DISGE,PSILOB,PSIR4,STIME,ETIME,JOBDIR ;link to SCHED
	EXTERNAL CHKDEV,CHKTTC,DEVUNT,DEVCHR,NDEV ;LINK TO JSYS
	EXTERNAL MSTKOV		;link TO PISRV
	EXTERNAL LSTERR		;link to FILE
	EXTERNAL CPYFU1		;link to FUTILI
	EXTERNAL TYMXX2,TYMXX3,TYMXX4,TYMXX5,TYMX24,DEVX2
	external bhc,bits,bughlt,BUGCHK,capenb,chktty,edisms
	external entflg,fkint,insked,itrap1,jobpt,logdes
	external mentr,mretn,mretne,normtf,r,skmrtn
	external tadsec,tci,tci0,tcibf,tcobq,todclk
	external ttchi,ttdobe,TTSIBE,ttdpsi,ttect,tteout,ttflgs
	external ttfork,ttfrec,ttict,ttiin,TTIOUT
	external ttimax,ttmod1,ttnin,ttnou,ttoct,ttoin
	external ttomax,ttoout,ttpsi,ttpsi2,ttrec4,ttrlob,TTRLAB
	external ttrne,ttylmd,ttype,typcrt,unlckf,wrpmsk
	external ttflgs,tymchx,MINUS1
	EXTERNAL TTPS2T,NYCHBF,NINBUF,IBPNBF,TTGTBF,TTLPOS
	EXTERNAL MLKPG,MULKPG,FPTA,RCMVE,RCMVEM,RCIORM
	EXTERNAL ASGPAG,RELFRE


	INTERNAL TYMNFK		;link to SCHED
	INTERNAL TYMX0,TYMJB0	;link to SWPMON
	INTERNAL TYHNGU		;link to JSYS
	INTERNAL TYMCHK		;link to SCHED
	INTERNAL YHCRSH,TYMCLK	;link to PISRV
	INTERNAL .TYMBW,.TYMBR,.TYMLI,.TYMOP ;link to PROLOG
	internal greent,tymeco,tymtci,tymini,tymdob
	internal tymchi,tymcib,rcvcmp,tymtyp,tymcob,TYMLFP
	internal nthost,tymptr
	INTERNAL TYMROK		;LINK TO DEVJS (.RELD)
	INTERNAL TYMQUE		;LINK TO JOBINI
	INTERNAL LGOAUX,TYMRLA	;LINK TO LOG2JS


;
;	DEFINITIONS
;
IRNGS==200		;input ring size
ORNGS==400		;output ring size
YKEY==633751506262	;base key
NTYMOT==NTYMTT		;number of lines to check for output at one
			;pass through TYMOUT
NXFRMX==177		;maximum # of chars to send for one line
IFG NXFRMX-177,<PRINTX NXFRMX must be less than 200>
STATSW==1		;assemble TYMSRV statisics keeping code

NAUXLN==1		;number of parallel aux circuit initiations possible
NAXTRY==2		;number of aux cir bldging retrys on super error
AUXID==1		;present aux cir id for all aux cir building
			;will change when TYMSHARE implements parallel
			;aux circuit building
BUFSIZ==13		;size of buffer in which to store TYMNET connect
			;name (buffer is stack)

;SEE TTYSRV FOR DEF OF IBPNBF (# INPUT BUFFERS FOR AUX CIRCUITS)

IBPOFF==^D512		;INPUT BACK PRESSURE TURN ON POINT, OR MAX
			;PROBABLE # OF CHARS IN IRING AT ANY ONE TIME.

; VARIOUS CLOCK PERIODS

KEYPRD==^D10*^D1000		;KEY CHECK INTERVAL FOR FOONLEY
OVRPRD==^D20*^D1000		;interface overdue period

SNCPRD==^D20*^D1000		;TIMEOUT FOR NODE RESYNC
J0RPRD==^D30*^D1000		;HOW LONG TO WAIT BEFORE NEXT
				;RETRY TO RESYNC NODE

IKEYCT==OVRPRD/KEYPRD	;RESET VALUE FOR KEYCT

YELPRD==^D60*^D1000	;yellow ball overdue time limit
RSTPRD==^D5*^D1000	;crash reset "silence" period
YALRMP==^D60*^D1000	;TYMBASE disabled check period
AUXPRD==2*^D60*^D1000	;aux circuit overdue period
AUXTIM==3*^D60*^D1000	;HOW LONG AUX CIRCUIT CAN BE QUEUED FOR
AUXTMC==^D5*^D1000	;HOW OFTEN JOB 0 RUNS AUXCKT

NZEROS==300		;WRT THIS MANY 0 TO RESYNC NODE


;	REGISTERS

A==1
B==2
C==3
D==4
LINE==2			;line number index
JFN==11
IPTR==11		;input iring pointer
OPTR==12		;output oring pointer


;SPECIAL OPCODES FOR FOONLY-NODE INTERFACE

OPDEF FN.RST [744000,,0]	;RESET FOO-NODE INTERFACE
OPDEF FN.WRT [745000,,0]	;WRITE TO FOO-NODE INTERFACE
OPDEF FN.RED [746000,,0]	;READ FROM FOO-NODE INTERFACE



; AUX CIRCUIT ID BUILDING STATES

AUXFRE==0		;available for building
AUXUSE==1		;claimed for use
AUXREQ==2		;first supervisor request sent
AUXSGR==3		;supervisor acknowledge
AUXSGN==4		;signon string sent
AUXLGR==5		;auxlog received
AUXBLT==6		;aux circuit built
AUXRTY==7		;supervisor error received, retry
AUXPS2==10		;first flush state on PSI interrupt
AUXPS3==11		;second flush state on PSI interrupt
AUXPS4==12		;third flush state on PSI interrupt

; LINE CONNECTION STATES

CONFRE==0			;line disconnected from TYMNET
CONLG1==<CONNF>B47+1		;line connected, init not started
CONLG2==<CONNF>B47+2		;line connected, init routine reading
CONLG3==<CONNF>B47+3		;line connected, init routine in operation
CONCTL==<CONNF+INITF>B47 	;line connected to TENEX as controlling tty
CONHG1==<CONNF+INITF>B47+4 	;post-init hang up waiting for empty buffers
CONHG2==<CONNF+INITF>B47+5 	;post-init hang up waiting for yellow ball
CONHG3==<CONNF>B47+4		;pre-init hang up waiting for empty buffers
CONHG4==<CONNF>B47+5		;pre-init hang up waiting for yellow ball
CONDC1==3			;disconnected while init, wait till init thru
CONDC2==2			;zapped while reading init stuff
CONDC3==<INITF>B47+1		;type disconnect message

CONAL1==<CONNF+AUXF>B47+1 	;aux circuit connected, waiting for super ok
CONAL2==<CONNF+AUXF>B47+2 	;aux circuit connected, not yet inited
CONAL3==<CONNF+AUXF>B47+3 	;aux circuit connected, init in operation
CONAUX==<CONNF+AUXF+INITF>B47	;line connected to TENEX as aux circuit
CONAH1==<CONNF+AUXF+INITF>B47+4 ;POST INIT HANGUP WAITING FOR EMPTY BUFFS
CONAH2==<CONNF+AUXF+INITF>B47+5 ;POST INIT HANGUP WAITING FOR YELLOW BALL
CONAD1==<AUXF>B47+3		;aux circuit zapped while waiting for super ok
CONAD2==<AUXF>B47+2		;aux cir zapped while initing
CONAD3==<AUXF+INITF>B47+1 	;deassign aux circuit and type disc message

COMMENT $ 

KNOWN BUGS AND DESIRED CHANGES:

	1) When entering any of the PS2,3,4 states, the supervisor response
	   timer gets reset, allowing the supervisor to remain silent and
	   leave the auxbld process locked in the corresponding PSI flush
	   state. The fix is to transfer the supervisor time out routines
	   from the WTLST routine to the SCHED level routines, and on time
	   out, return AUXSTS to the FRE state.  If the AUXBLD process
	   gets hung up this way, just zap AUXSTS to FRE (SETZM AUXINF(n)).

	2) There needs to be a translation table between TYMNET supervisor
	   error codes and TENEX error codes of the 600nnn variety, with
	   a TENEX error code for "unrecognzed SUPERVISOR error".  The 
	   supervisor errors are:

		1 - Illegal signon string format
		2 - Unrecognized signon string
		3 - Bad Master User Directory (MUD); supervisor blew its mind
		4 - System unavailable

	3) Some timer studies I did do, show that the code is not as
	   efficient as I would like.  I would suggest putting switches
	   in the YLTCHK and TYMOUT sections of the code which are turned
	   on whenever a yellow ball is sent or whenever any output is
	   placed in the output buffers (or the HG1 or HG3 states are
	   entered) respectively.  The YLTCHK and TYMOUT routines
	   should only execute when these switches are on, and turn them
	   off when they are through.  This would eliminate multiple
	   line scans.


		Michael Heathman 8/75

   This is a state map of the connect/disconnect sequence.  The state
variable is a combination of CONSTS and the left half of TTFORK, represented
here as the last three capital letters of the CONXXX states defined above
and the numeric vaule of (lh) TTFORK (where "n" is the job number).
Events are lower case letters along the transition path nearest the 
originating state.  Actions (where they can be squeezed in) are in 
parenthesis.
								  
  ----------------------FRE,-1---------------------		 -^c
  !		     aux   ^  log		  !      	 ----
  !			   !			  v   -^c	 ^  v zap
  !			   !			LG1,-1---  ---->CTL,-1---
  !			   !		       ^c !    	!  !     ^  !^c	!
  !			   ! -frk	     zap  v-frk	!  ! -frk!  v	!
  !			   !<---FRE,-2<---------LG1,-2--!  !	CTL,-2	!
  !			   !   frk!   -----       !frk	!  ! frk/  !zap	!
  v  zap		   v  det v  /read!  zap  v	!  !   v   v	!
AL1,n--------------------->!<---FRE,n<----------LG1,n 	!  !   !   !<----
  ! sup ok		   !   /  ^		  !read	!  !   !   !
  v  zap	     msg   !  /	  !msg	     zap  v	------ !   !
AL2,n---------->AD1,n----->! !	DC2,n<----------LG2,n 	   ! ! !   !
  ! msg			   ! !			  ! msg	   ! ! !   !
  v  zap		   ! !		     zap  v	   ! ! !   !
AL3,n---------->AD2,n	   ! !	DC1,n<----------LG3,n  det ! ! !   !
  !init	      init!	   ! !	  !init	      init!   -----! ! !   !
  v  zap	  v  job 0 ! !	  v	     zap  v  /       ! !   !
AUX,n---------->AD3,n----->! --<DC3,n<----------CTL,n<-------!--   !
  ! hang		   !  job 0	     hang !    ------!------
  v			   !			  v   /	     !
  -------------------------!------------------->HG1,-1       -->HG3,-1
			   !		    zap/  !empty    zap/   !empty
			   !job 0    /---------	  v	     /	   v
			   !<---DC3,-1<---------HG2,-1	     !	HG4,-1
			   !	    	    zap or yellow    v	   !yellow
			   !<---------------------------------------  or
								     zap

EVENT			   from	STATE	     to	STATE	ACTION

log   log code received,	FRE,-1		LG1,-1
      TENEX line found

aux   auxilliary circuit built,	FRE,-1		AL1,n	assign line
      TENEX line found

^c    ^C accepted, fork		LG1,-1		LG1,-2
      requested

				CTL,-1		CTL,-2

-^c   ^C rejected		LG1,-1		HG3,-1	

				CTL,-1		CTL,-1

frk   fork started		LG1,-2		LG1,n

				FRE,-2		FRE,n

				CTL,,-2		CTL,n

-frk  fork rejected		LG1,-2		HG3,-1

				FRE,-2		FRE,-1

				CTL,-2		CTL,-1

read  TYMNET connect string	LG1,n		LG2,n
      reading commenced

				FRE,n		FRE,n	skip initialization

msg   connect message started	LG2,n		LG3,n

				DC2,n		FRE,n	skip initialization

				AL2,n		AL3,n	

				AD1,n		FRE,-1	deassign line

init  initialization complete	LG3,n		CTL,n	

				DC1,n		DC3,n	detach interrupt

				AL3,n		AUX,n	

				AD2,n		AD3,n	detach interrupt

hang  program requested 	CTL,n		HG1,-1
      hang up

				AUX,n		HG1,-1

empty output buffer empty	HG1,-1		HG2,-1	send yellow ball

				HG3,-1		HG4,-1	send yellow ball

yellow yellow ball returned	HG2,-1		DC3,-1	send zapper

				HG4,-1		FRE,-1

job 0 job 0 disconnect msg	DC3,-1		FRE,-1

				DC3,n		FRE,n

				AD3,n		FRE,-1	deassign line

zap   received zapper		LG1,-2		FRE,-2

				LG1,n		FRE,n

				LG2,n		DC2,n

				LG3,n		DC1,n	

				CTL,n		DC3,n	detach interrupt

				HG1,-1		DC3,-1

				HG2,-1		DC3,-1

				HG3,-1		FRE,-1

				HG4,-1		FRE,-1

				CTL,-1		HG1,-1

				CTL,-2		HG1,-1

				AL1,n		FRE,-1	deassign line

				AL2,n		AD1,n

				AL3,n		AD2,n

				AUX,n		AD3,n	detach interrupt

   Auxilliary circuit building state map.  Again, states correspond to
last three capital letters of AUXBLD symbols defined above, events are
in lower case.


   ---------------------------->FRE<------------------------------
   !				 !				 !
   !				 !				 !
   !				 v				 !
   !				USE				 !
   !				 !    new			 !
   !				 !   --------------------------->!
   ! sup		     psi v  / err			 !
   !<---PS2<--------------------REQ-----------			 !
   !	 ! ack		     ack !  \ time   !			 !
   !	 !			 !   --------!------------------>!
   !	 !		   psi   v	     !			 !
   !	 !<---------------------SGR          !			 !
   !	 !		    prog !    new    !			 !
   !	 !			 !   --------!------------------>!
   ! sup v		     psi v  / err    v		   prog  !
   !<---PS3<--------------------SGN-------------------->RTY----->!
   !	 ! log		     log !  \ time   ^			 !
   !	 !			 !   --------!------------------>!
   !	 !			 !    new    !			 !
   !	 !			 !   --------!------------------>!
   ! sup v		     psi v  / err    !			 !
   !<---PS4<--------------------LGR-----------			 !
     or ack   		     ack !  \ time			 !
				 !   --------------------------->!
				 v
				BLT


EVENT			   from	STATE	     to	STATE	ACTION

prog  program action		FRE		USE	lock AUXBLD process

				USE		REQ	send super request
				
				SGR		SGN	send sign on string

				RTY		REQ	retry, send super
							request

ack   supervisor acknowldege	REQ		SGR

				PS2		PS3	send super request
							w/o signon string
							to force termination
							error	

				PS4		FRE	

log   aux cir login		SGN		LOG	

				PS3		PS4	zap line

err   supervisor error		REQ		RTY	retry
							
				SGN		RTY	retry

				LGR		RTY	retry

new   new supervisor takeover	REQ		FRE	restart
							
				SGN		FRE	restart

				LGR		FRE	restart

time  supervisor time out	REQ		FRE	abort

				SGN		FRE	abort	

				LGR		FRE	abort

sup   is err, new, or time

psi   PSI interrupt rcvd	REQ		PS2	restart 

				SGR		PS3	restart 
	
				SGN		PS3	restart 
							
				LGR		PS4	zap line, restart
ACTIONS

retry	release process, increment retry counter, lock and start process

restart	release process, reset retry counter, lock and start process

abort	release process, return error to user
$ ;end COMMENT

;
;	VARIABLES
;
LS(DYMLNS,NTYMTT)	;individual line TYMNET status
TYMLNS=:DYMLNS-TYMTTL	;offset for tymlines only

LS(DYMBKS,NTYMTT)	;individual line TYMNET BLOCK MODE status
TYMBKS=:DYMBKS-TYMTTL	;offset for tymlines only

LS(DLTCHK,NTYMTT)	;over due yellow ball clock
YLTCHK=:DLTCHK-TYMTTL

LS(DYNODS,NTYMTT)	;TYMNET connection source info (tty type, node, port)
TYNODS=:DYNODS-TYMTTL

LS(TYMTEN,NTYMTT)	;TYMNET to TENEX line number conversion, indexed
			;by TYMNET port number, RH gives TENEX line number
TENTYM=:TYMTEN-TYMTTL	;TENEX to TYMNET line number conversion, indexed
			;by TENEX line number, LH gives TYMNET port number
			;-1 in both cases means disconnected

LS(TYMPRT,NTYMTT)	;INDEX BY PORT #
			;CONTAINS BAUDLK!BAUDIN!BAUD CODE

	BAUDLK==1B0	;LOCK BIT FOR PORT
	BAUDIN==1B1	;BAUD CODE IS IN RH

LS(DYMCMM,NTYMTT)	;mask of control messages to deferredly interrupt
TYMCMM=:DYMCMM-TYMTTL

LS(DYMCMR,NTYMTT)	;last received deferred control message
TYMCMR=:DYMCMR-TYMTTL

LS(DYMCMI,NTYMTT)	;XWD system fork number of fork to receive deferred
TYMCMI=:DYMCMI-TYMTTL	;control message interrupt,,PSI channel for int.

LS(DUXINF,NAUXLN)	;auxilliary circuit building information
AUXINF=:DUXINF-AUXID

LS(DUXCLK,NAUXLN)	;aux circuit clock
AUXCLK=:DUXCLK-AUXID

LS(DX2CLK,NAUXLN)	;aux circuit CLEANUP CLOCK AFTER PSI HANDLED IN AUXBLD
AX2CLK=:DX2CLK-AUXID

LS(TYMSVC,1)		;supervisor version number
LS(KEYTIM)		;keyword check clock
LS(KEYCT)		;key clobber count, and interface status flag
LS(LTYMOT)		;last line checked for output in TYMOUT
LS(TYMCSH)		;TYMBASE crash reason, YBCRSH saved on RESET
LS(TYSAVP)		;intrpt side pc on oring full
LS(TYSAV1,4)		;  "     "   ac's    "    "
LS(TYMSTS)		;JOB 0 tymnet interface status notification word
LS(TIMNET)		;HOLDS 32 BIT # FOR GETTING TIME FROM TYMNET SUPER
LS(YALRMC)		;Apparently disabled TYMBASE alarm clock
LS(TYMCS2)		;clock level routine reg 2 save word
LS(TYMENT)		;answer/shut switch .LE. 0 =) shut
			;		    .EQ. 0 =) according to ENTFLG
			;		    .GE. 0 =) answering
LS(IBPFLG)		;IBP OFF MESSAGE FROM SHCED SIDE FOUND FULL ORING
LS(TYM1ST)		;NON-ZERO IF INITED INTERFACE AT LEAST ONCE


LS(J0RTIM)		;HOLDS WHEN TO RETRY NODE RESET
LS(TIMFLG)		;TIME REQUEST FLAG WORD

;	TYMSRV statistics variables, switch controlled

IFN STATSW,<
LS(YSTLYL)		;lost yellow balls
LS(YSTBZP)		;buffer zaps
LS(YSTRST)		;resets
LS(YSTIMD)		;input message packets (DISPATCHABLE MESSAGES)
LS(YSTIMC)		;input message packets (CHR MESSAGES)
LS(YSTOMS)		;output message packets
LS(YSTOFL)		;oring fulls
LS(YSTBPO)		;back pressure ons
LS(YSTBCR)		;base crash messages
LS(YSTAX2)		;# TIMES AX2CLK WENT OFF (AUXBLD PSI EMERGENCY CLEANUP)
LS(YSTSNK)		;# TIMES SUP NAK CLEANED UP PSIED AUXBLD
LS(YSTSAK)		;# TIMES SUP ACK CLEANED UP PSIED AUXBLD
LS(YSTSBD)		;# TIMES SUP BAD RESPONSE CLEANED UP PSIED AUXBLD
	>



;STORAGE FOR AUXQUE STUFF

QMAGCN==-3		;AUXQUE MAGIC NUMBER USED FOR ASSIGNING TO QUE

LS(AUXCTM)		;HOLDS NEXT TIME FOR JOB 0 TO AUXCKT

LS(DUXCTL,NTYMTT)	;HOLDS H2H FUNCTION AND DATA FOR NEW LINE
AUXCTL=:DUXCTL-TYMTTL	;-1 IF FREE (GETS USED FOR AUX CIRCS ONLY)

LS(DUXDJQ,NTYMTT)	;EDBITS,UDBITS,,DJOB
AUXDJQ=:DUXDJQ-TYMTTL	;-1 IF FREE (GETS USED FOR AUX CIRCS ONLY)

LS(DUXSJQ,NTYMTT)	;ESBITS,USBITS,,SJOB
AUXSJQ=:DUXSJQ-TYMTTL	;-1 IF FREE (GETS USED FOR AUX CIRCS ONLY)

LS(DUXTMQ,NTYMTT)	;AUXQUE ALARM CLOCK
AUXTMQ=:DUXTMQ-TYMTTL	;-1 IF FREE (GETS USED FOR AUX CIRCS ONLY)

NSYSND==15		;# SLOTS IN SYSNDX

LS(DYSNDX,NSYSND)	;SYSNDX TABLE (CONTAINS DJOBS OF SYSTEM PROCESSES)
SYSNDX=:DYSNDX-1	;0TH NOT USEABLE SO CAN SPECIFY AS NEGATIVE INDEX



;BLOCK IO PARAMETERS AND STORAGE

NBKIOQ==10			;SIZE OF QUEUE

;FLAGS IN LH BLKSTL
BLKXHF==400000			;HI BIT OF ENTRY STATE
BLKXLF==200000			;LO BIT OF ENTRY STATE
BLKWRF==100000			;WRITE IF ON, READ IF OFF
BLKERF==040000			;ERROR OCCURED, ERROR IN BLKRET
BLKINF==020000			;INTERRUPT WHEN XFR COMPLETED
BLKULF==010000			;PAGE NEEDS TO BE UNLOCKED WHEN DONE
BLKRSF==004000			;RETURN STATUS IN HEADER WORD

OPDEF BLKSTA [POINT 2,BLKSTL(.-.),1]	;TEMPLATE FOR STATE BYTE


;HEADER WORD ERROR BITS FOR XFER ERRORS
BLKERB==400000			;OUT OF BUFFER ERROR
BLKERT==200000			;BASE TIMEOUT ERROR


;STORAGE

LS (BLKLKC,1)			;COUNT OF LOCKED ENTRIES

LS (BLKLCK,NBKIOQ)		;ENTRY LOCK (-1 WHEN FREE)
LS (BLKADR,NBKIOQ)		;DESIRED COUNT,,REAL CORE PAGE
LS (BLKSTL,NBKIOQ)		;STATUS BITS,,LINE #
LS (BLKRET,NBKIOQ)		;XFER ERROR BITS,,RETURNED COUNT
LS (BLKUPG,NBKIOQ)		;PAGE UNLOCK INFO IF BLKULF LIT IN BLKSTL
LS (BLKCHN,NBKIOQ)		;FORWARD CHAIN (HEAD IS ALWAYS STATE 2)


;BLOCK IO DOCUMENTATION

;0TH WORD OF BLOCK IS OVERHEAD WORD.
;COUNT IS 1 TRHU 777 AND DOES NOT INCLUDE THE OVERHEAD WORD.
;RETURNED COUNT < DESIRED COUNT IS NOT CONSIDERED AN ERROR AND
;MUST BE CHECKED BY THE USER.

;AT TIME OF CALL:

; !         18 BITS            ,,    9 BITS     !     9 BITS        !
; -------------------------------------------------------------------
; !            0               ,,      0        !   DESIRED COUNT   !
; -------------------------------------------------------------------

;RETURNED (UNLESS INHIBITED)

; !         18 BITS            ,,    9 BITS      !     9 BITS       !
; -------------------------------------------------------------------
; !  XFER ERROR BITS OR 0      ,, RETURNED COUNT !   DESIRED COUNT  !
; -------------------------------------------------------------------


;BLOCK IO QUEUE ENTRY STATES
;BLKXLF AND BLKXHF ARE ALIGNED FOR BUMPING TO NEXT STATE VIA:
;	LDB,AOS,DPB
;
;BLKXHF     BLKXLF       STATE
;  0          0          0 - QUEUE BEING MANIPULATED IF ENTRY IS LOCKED
;  0          1          1 - XFER START REQUESTED (QUEUED VIA CHAIN WORDS)
;  1          0          2 - XFER STARTED AND OUTSTANDING (AT MOST 1 / LINE)
;  1          1          3 - XFER DONE



;	POINTERS

;	TYMLNS(LINE) fields
CONSTS:	POINT 6,TYMLNS(2),5	;connect state
;	TYNODS(1) fields (assumes TYMNET tty designator in 1)
NODTYP:	POINT 8,TYNODS-400000(1),16	;terminal type (LOW 5 BITS)
NOD1:	POINT 6,TYNODS-400000(1),29	;first half of origin node number
NOD2:	POINT 6,TYNODS-400000(1),35	;second half
NODLIN:	POINT 7,TYNODS-400000(1),23	;port number at origin node
;	AUXINF(LINE) fields
AUXSTS:	POINT 9,AUXINF(2),35	;state/status
AUXSVC:	POINT 9,AUXINF(2),26	;supervisor version
AUXLIN:	POINT 9,AUXINF(2),17	;job/line number
AUXSVR:	POINT 9,AUXINF(2),8	;supervisor response
;	TYMCMR(LINE) fields
CMCOD:	POINT 8,TYMCMR(2),7	;deferred control message node
CMSBT:	POINT 8,TYMCMR(2),15	;deferred control message subtype
CMDAT:	POINT 8,TYMCMR(2),23	;deferred control message data

;	getab entries for tymnet host number table

nthost:	thostn			;tymnet local host number
tymptr:	xwd -ntymtt,tymttl	;just like arpanet lhostn table
DEFAXN:	AXNDEF			;DEFAULT AUX CIR USERNAME, 1 WORD ASCIZ
TYMFLG:: -1			;tymnet enabled if nonzero

;	end of tymnet host number getab entries

;
;	FLAGS
;
;	TYMLNS(LINE) flags (LH)
CONMSK==770000		;disconnect mask test
CONNF=400000		;active circuit on line
AUXF=200000		;this line is an AUX CIR origination
INITF=100000		;line initialized, connection complete
OBPF=004000		;OUTPUT back pressure on
IBPF=002000		;INPUT BACK PRESSURE ON
IBPOF=001000		;ENABLE INPUT BACK PRESSURE
CDMPF=000400		;dump incoming chars (Clear input buff)
GREENF=000200		;GREEN BALL RECEIVED

USECOF==000001		;user echo mode flag - USER SETTABLE

;	TYMLNS(LINE) flags (RH)
TABF=1B29		;TYMSAT to echo tab
ECHOF=1B30		;echo on sent to TYMSAT
HDPXF=1B31		;TYMSAT in half duplex mode
DEFF=3B33		;TYMSAT deferred echo mode


;FLAGS IN LH TYMBKS WORD (LOW 9 BITS IS QUEUE INDEX)

BKIMOD==400000		;ON IF BLK MODE INPUT
BKIACT==200000		;LINE HAS BLOCK INPUT XFER ACTIVE
BKIRTY==100000		;SCHED MUST RETRY OTYPEH FOR ACTIVE INPUT ENTRY
BKIIHR==040000		;TYPIHR OUTSTANDING

;FLAGS IN RH TYMBKS WORD (LOW 9 BITS IS QUEUE INDEX

BKOMOD==400000		;ON IF BLK MODE OUTPUT
BKOACT==200000		;LINE HAS BLOCK OUTPUT XFER ACTIVE
BKORTY==100000		;SCHED MUST RETRY OTYPEH FOR ACTIVE OUTPUT ENTRY
BKOOHR==040000		;TYPOHR OUTSTANDING

;PTR TEMPLATES FOR BLK IO QUEUE INDEXES

OPDEF BKINDX [POINT ^D9,TYMBKS(.-.),17]	;INPUT
OPDEF BKONDX [POINT ^D9,TYMBKS(.-.),17]	;OUTPUT

;	TYMSTS flags (LH)
CRASHF=400000		;received crash message from TYMBASE
DIEDF=200000		;TYMBASE has died
RESETF=100000		;interface has been reset
UPF=040000		;TYMBASE just came up
ANSF=020000		;TENEX answering
ALARMF=010000		;TYMBASE apparently disabled
JB0RST==004000		;REQUEST JOB 0 TO CALL TYMRST
RTYWIN==002000		;RESYNC RETRY MADE IT

;	TIMFLG flags (LH)

TIMELK==1B0		;TYMNET TIME REQUEST LOCK
TIMEIN==1B1		;GOT TIME MESSAGE FROM SUPER
TIMEJ0==1B2		;JOB ZERO REQUEST FOR TIME
TIMEUS==1B3		;USER REQUEST FOR TIME VIA TYMOP



; MACROS

DEFINE	ERR(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERRD]>



;FOLLOWING MACROS ASSUME EFFADR IS IN RESIDENT UNMAPPED MONITOR

;CLEAR FLAG

DEFINE CLRFLG (EFFADR,BITSYM)
<	PUSH P,1
	MOVE 1,[BITSYM]
	ANDCAM 1,EFFADR
	POP P,1
>

;SET FLAG

DEFINE SETFLG (EFFADR,BITSYM)
<	PUSH P,1
	MOVE 1,[BITSYM]
	IORM 1,EFFADR
	POP P,1
>

;VALUES NECESSARY TO DETECT IF SCHED TEST RTN NEEDS TO BE ASSEMBLED
;.IF NEEDED AND IFDEF STUFF INSUFFICIENT FOR THIS COMPLEXITY

ONTST==0		;B0 MEANS WT0ON HAS BEEN ASSEMBLED, ETC.
OFFTST==0		;B0 MEANS WT0OOFF HAS BEEN ASSEMBLED, ETC.

;MACRO USED BY FGWTMC TO BUILD LABEL FROM BIT #
;ALL ARGS ARE TEXT!

DEFINE LBLBIT (PREFIX,BITNAM,SUFFIX) <PREFIX'BITNAM'SUFFIX>

;MACRO USED BY FGWAIT TO PUT APPROPRIATE SCHED WAIT TEST IN 
;RH OF AC 1 AND ASSEMBLE SCHED TEST IF NECESSARY
;NOTE:  MUST BE USED IN SWAP MON ONLY!!!!

DEFINE FGWTMC (BITSYM,COND)
<BITPOS==0		;;STARTING BIT TEST POSITION
 REPEAT ^D36,<IFE <BITPOS-^L<BITSYM>>,<

	HRRI 1,LBLBIT (WT,\BITPOS,COND)	;;RH 1 GETS SCHED TST ADR

..ASSM==0		;;ASSUME DO NOT NEED TO ASSEMBLE SCHED TEST

IFE BITSYM&<COND'TST>,<	..ASSM==1			;;ASSEMBLE IT
			COND'TST==<COND'TST>!BITSYM	;;REMEMBER DID IT
		      > ;;END IFE BITSYM&COND'TST

IFN ..ASSM,<
				RESCD
      LBLBIT (WT,\BITPOS,COND): MOVE 2,[BITSYM]
	    IFIDN <COND> <OFF>,<TDNE 2,(1)>
	    IFIDN <COND> <ON>,< TDNN 2,(1)>
				 JRST 0(4)
				JRST 1(4)
				SWAPCD
		> ;;END OF IFN ..ASSM
					> ;;END OF IFE BITPOS-^LBITSYM
	BITPOS==BITPOS+1
	     > ;;END OF REPEAT
> ;END OF FGWTMC MACRO

;WAIT FOR FLAG MEET CONDITION
;GO NOSKED

DEFINE FGWAIT (EFFADR,BITSYM,COND,%AGAIN,%COND)
<		PUSH P,1
	%AGAIN:	NOSKED
		MOVE 1,[BITSYM]
IFIDN <COND> <ON>,< TDNE 1,EFFADR		;;OFF?>
IFIDN <COND> <OFF>,<TDNN 1,EFFADR		;;ON?>
		 JRST %COND		;;YES
		OKSKED			;;NO
		HRLI 1,EFFADR
		FGWTMC (<BITSYM>,<COND>) ;;DO SCHED TEST SETUP
		JSYS EDISMS
		JRST %AGAIN		;;TRY AGAIN

	%COND:	POP P,1			;;STILL NOSKED
>


;WAIT FOR FLAG TO BE OFF, SET IT AND GO NOINT

DEFINE FGLOCK (EFFADR,BITSYM)
<	FGWAIT (<EFFADR>,<BITSYM>,<OFF>)	;;WAIT FOR IT TO BE OFF
	SETFLG (<EFFADR>,<BITSYM>)	;;SET IT
	NOINT				;;NO USER INTS
	OKSKED				;;UNDO NOSKED FROM FGWAIT
>

;CLEAR FLAG AND GO OKINT

DEFINE FGUNLK (EFFADR,BITSYM)
<	CLRFLG (<EFFADR>,<BITSYM>)
	OKINT
>



	SUBTTL TYMNET terminal type translation
;
;	TENEX to TYMNET
;
	RESCD

;TYMTCS sub type numbers in order as below

PTT:	BYTE (5)TMCPA,TMCPB,TMCPC,TMCELF,TMCECR,TMCCRD,TMCPAR

PTTPA:	POINT 8,TYMTTP(A),7	;parameter A padding
PTTPB:	POINT 8,TYMTTP(A),15	;parameter B padding
PTTPC:	POINT 8,TYMTTP(A),23	;parameter C padding
PTTPL:	POINT 1,TYMTTP(A),24	;echo LF with CR
PTTPR:	POINT 1,TYMTTP(A),25	;echo CR with LF
PTTPD:	POINT 1,TYMTTP(A),26	;CR delay
PTTPP:	POINT 1,TYMTTP(A),27	;parity

	RADIX 10	;**********

;THIS TABLE MUST AGREE WITH TTYSRV AND THE EXEC'S TRANSLATION OF
;USER STRINGS TO TERMINAL TYPE #
;INDEXED BY TERMINAL TYPE #

;THE CLAIM IS THAT WITH CR DELAY ON, NET USES A,B,C FOR DELAY CALC.
;WITH CR DELAY OFF, NET USES SOME WEIRD # WHICH IS NON-0 (maybe param d)
;SO SHOULD ALWAYS HAVE CR DELAY ON BUT A,B,C 0 IF NO DELAY WANTED

TYMTTP:	BYTE(8) 64,0,2 (1)0,1,1,0	;(0) mod tty33
	BYTE(8) 64,0,2 (1)0,1,1,0	;(1) mod tty35
	BYTE(8) 64,0,2 (1)0,1,1,0	;(2) mod tty37
	BYTE(8) 16,3,7 (1)0,1,1,0	;(3) TI, EX
	BYTE(8) 0,0,0  (1)0,0,1,0	;(4) UNUSED
	BYTE(8) 0,0,0  (1)0,0,1,0	;(5) UNUSED
	BYTE(8) 0,0,0  (1)0,0,1,0	;(6) UNUSED
	BYTE(8) 0,0,0  (1)0,0,1,0	;(7) NVT
	BYTE(8) 4,5,26 (1)0,1,1,1	;(10) LA30,TERMINAET
	BYTE(8) 16,5,5 (1)0,1,1,0	;(11) TI733
	BYTE(8) 0,0,0  (1)0,1,1,0	;(12) SCOPE
	BYTE(8) 0,0,0  (1)0,1,1,0	;(13) LINEPROCESSOR
	BYTE(8) 0,0,0  (1)0,1,1,0	;(14) DATAMEDIA
	BYTE(8) 16,0,4 (1)0,1,1,0	;(15) DCT500
	BYTE(8) 0,0,0  (1)0,1,1,0	;(16) VT100
	BYTE(8) 4,0,4  (1)0,1,1,0	;(17) UNIVAC
	BYTE(8) 0,0,0  (1)0,1,1,0	;(20) TYM444
	BYTE(8) 0,0,0  (1)0,1,1,0	;(21) TYM420
	BYTE(8) 0,0,0  (1)0,1,1,0	;(22) ADM42
	BYTE(8) 0,0,0  (1)0,1,1,0	;(23) IBM3101
	BYTE(8) 0,0,0  (1)0,1,1,0	;(24) TYM430

REPEAT 50-<.-TYMTTP>,<
	BYTE(8) 0,0,0  (1)0,0,1,0	;(25:47) DUMMIES LIKE NVTS
>

	RADIX 8		;*****

;
;	TYMNET to TENEX
;

DYTYPU:	3			;DEFAULT TENEX TERMINAL TYPE FOR UNKOWNS

DYTYP:	7			;GET NVT FOR AUX CIRCUITS
	7			;(1-A) CRT
        15			;(2-C) DTC500
	3			;(3-E) EXECUPORT
        16			;(4-G) PARITY TERMINET360
	2			;(5-B) TTY37
        17			;(6-F) UNIVAC
	2			;(7-J) PARITY TTY37
	3			;(8-N) SPLIT SPEED EXECUPORT
        3			;(9-CR) 2741 FAKE IT SINCE USER CAN'T
				;SET TO TYPE 2741
	0			;(10-D)	TTY33
	11			;(11-I)	TI733
	7			;(12-A) 1200 BAUD CRT
	7			;(13) BURROUGHS POLLED
	7			;(14) GATEWAY AUX CIRCUIT
	7			;(15) BAUDOT
	7			;(16) 2400 BAUD CRT
	7			;(17) 3270
	7			;(18) 3270 PRINTER
	7			;(19) 4800 BAUD CRT
	7			;(20) 9600 BAUD CRT

MXYTYP=.-DYTYP-1		;MAX TYPE WE KNOW ABOUT


	SUBTTL HOST/BASE INTERFACE DATA STRUCTURE
;
;	ring buffer definitions
;

	RESCD
TMPLT:	PHASE TYMBAS

YLOCK:	YKEY		;key
	0		;not used
	0		;base dump loc * 16 - not used

YIRNG:	IRING_4		;input ring loc * 16
YISIZ:	IRNGS_4		;input ring size * 16
YIHP:	0		;host set input pointer
YIBP:	0		;base set input pointer

YORNG:	ORING_4		;output ring loc *16
YOSIZ:	ORNGS_4		;output ring size * 16
YOHP:	0		;host set output pointer
YOBP:	0		;base set output pointer

YBCRSH:	0		;base set crash indicator + reason
YHCRSH:	0		;host set crash reason

IRING=TYMBUF+TYMBSZ-<IRNGS+ORNGS>
	IFL IRING-., <PRINTX TYMNET RING BUFFERS TOO LARGE>
ORING=IRING+IRNGS
	DEPHASE

;
;	pointer definitions
;
	RESCD

PITYPE:	POINT 8,IRING(IPTR),7	;input type field
PIPORT:	POINT 8,IRING(IPTR),15	;input port field
PISUBT:	POINT 8,IRING(IPTR),23	;input subtype field
PIDATA:	POINT 8,IRING(IPTR),31	;input data field

POTYPE: POINT 8,ORING(OPTR),7	;output type field
POPORT:	POINT 8,ORING(OPTR),15	;output port field
POSUBT:	POINT 8,ORING(OPTR),23	;output subtype field
PODATA:	POINT 8,ORING(OPTR),31	;output data field

	SUBTTL HOST TO BASE INTERFACE MESSAGE DEFINITIONS

; ARGUMENTS: NAME, LABEL, TYPE, (USER/WHEEL RECEIVE/SEND STATUS)
; LN = 1 => LINE # PROVIDED IN MESSAGE
; CN = 1 => THAT LINE # MUST BE CONNECTED

	DEFINE MESAGE (NAM,LABEL,TP,RU,SU,RW,SW,LN,CN)
<
	DEFINE TYM'NAM
<
	MOVEI C,TYP'NAM
	CALL OTYPE'TP			;;TTY # IN 2
>

	DEFINE TY2'NAM
<
	MOVEI C,TYP'NAM
	CALL OTY2E'TP			;;PORT # IN 2
>

TYP'NAM:! JRST LABEL 

IFL  <TYP'NAM-^D36>,<	RUSR0==RUSR0!<RU>B<TYP'NAM>
			SUSR0==SUSR0!<SU>B<TYP'NAM>
			RWHL0==RWHL0!<RW>B<TYP'NAM>
			SWHL0==SWHL0!<SW>B<TYP'NAM>
			LNBT0==LNBT0!<LN>B<TYP'NAM>
			CNBT0==CNBT0!<CN>B<TYP'NAM>
		  >


IFGE <TYP'NAM-^D36>,<	RUSR1==RUSR1!<RU>B<TYP'NAM-^D36>
			SUSR1==SUSR1!<SU>B<TYP'NAM-^D36>
			RWHL1==RWHL1!<RW>B<TYP'NAM-^D36>
			SWHL1==SWHL1!<SW>B<TYP'NAM-^D36>
			LNBT1==LNBT1!<LN>B<TYP'NAM-^D36>
			CNBT1==CNBT1!<CN>B<TYP'NAM-^D36>
		  >
>

;CLEAR ASSEMBLY BIT MASKS

RUSR0==0
SUSR0==0
RWHL0==0
SWHL0==0
LNBT0==0
CNBT0==0
RUSR1==0
SUSR1==0
RWHL1==0
SWHL1==0
LNBT1==0
CNBT1==0

	RESCD	    

;IGNORE,IGNOR1 AND BADTIN SHOULD HAVE LN,CN BE 0,0 SO TYMIN0 WILL PASS
;THEM TRHOUGH AND CAN GET TO THESE ROUTINES REGARDLESS OF WHAT THEY
;REALLY SHOULD HAVE FOR LN,CN WERE THEY IMPLEMENTED

TYPFCN:	PHASE 0
	MESAGE (ZRO,INVTYP,A,0,0,0,0,0,0) ;0 illegal type
	MESAGE (ANS,IGNORE,A,0,0,0,0,0,0) ;1 system is answering
	MESAGE (SHT,IGNORE,A,0,0,0,1,0,0) ;2 system is up but shut
	MESAGE (CRS,CRSH,A,0,0,0,1,0,0)   ;3 sender is crashed
	MESAGE (DIE,IGNORE,A,0,0,0,1,0,0) ;4 recipient should crash
	MESAGE (NSP,NEWSUP,A,0,0,0,0,0,0) ;5 base taken over by new supervisor
	MESAGE (LOG,LOGGER,B,0,0,0,0,1,0) ;6 login, next 4 data chrs are 
				;the info about terminal type, and port 
				;or origin, then name, etc.
	MESAGE (AUX,AUXLOG,B,0,0,0,0,1,0) ;7 supervisor response to
				;establishing auxillary circuit
	MESAGE (NOP,BPON,B,0,0,0,0,1,1)   ;10 backpreasure on
	MESAGE (OUP,BPOFF,B,0,0,0,0,1,1)  ;11 back pressure off
	MESAGE (GOB,GOBBLE,B,1,1,1,1,1,1) ;12 character gobbler
	MESAGE (ZAP,ZAPPER,B,0,0,0,0,1,0) ;13 circuit zapper
	MESAGE (EDC,EDEC,B,1,1,1,1,1,1,1,1) ;14 enter defered echo mode
	MESAGE (LDC,LDEC,B,1,1,1,1,1,1)   ;15 leave deferred echo mode
	MESAGE (GRN,GREEN,B,1,1,1,1,1,1)  ;16 green ball
	MESAGE (RED,RED,B,1,1,1,1,1,1)    ;17 red ball
	MESAGE (YEL,YELLOW,B,1,1,1,1,1,1) ;20 yellow ball
	MESAGE (ORG,YELLOW,B,1,1,1,1,1,1) ;21 orange ball
	MESAGE (HNG,IGNORE,B,1,0,1,0,0,0) ;22 hang character - not used
	MESAGE (ETM,IGNORE,B,1,1,1,1,0,0) ;23 enter 2741 transparent mode
	MESAGE (LTM,IGNORE,B,1,1,1,1,0,0) ;24 leave 2741 transparent mode
	MESAGE (LOS,BLACK,C,1,1,1,1,1,1)  ;25 lost ball, data has been lost
				;FROM buffers. the data filed may tell how
				;many were lost
	MESAGE (SUP,IGNORE,C,1,0,1,0,0,0) ;26 supervisor request (aux circuits)
	MESAGE (SUR,SUPRSP,C,0,0,1,0,0,0) ;27 supervisor respons (aux circuits)
	MESAGE (AXC,IGNORE,C,0,0,0,1,0,0) ;30 supervisor string character
;******************************************************************
;  !!NOT TO BE ISSUED ON INTERRUPT SIDE
	MESAGE (TSP,IGNOR2,F,0,0,0,0,0,0) ;31 test pattern probe
	MESAGE (TSR,IGNOR2,F,0,0,0,0,0,0) ;32 test pattern response
	MESAGE (SAD,IGNOR2,F,0,0,0,0,0,0) ;33 host sad
;******************************************************************
	MESAGE (ECN,IGNORE,B,1,1,1,1,0,0) ;34 echo on
 	MESAGE (ECF,IGNORE,B,1,1,1,1,0,0) ;35 echo off
	MESAGE (TCS,IGNORE,D,1,1,1,1,0,0) ;36 term characteristics, first data
				;byte indicates which characteristics
				;second data byte indicates 
				;value to set to
	MESAGE (TCP,IGNORE,C,1,1,1,1,0,0) ;37 term characteristcs probe, data byte
				;indicates which terminal characteristic
				;were requested
	MESAGE (TCR,TRMCHR,D,1,1,1,1,1,1) ;40 term characteristcs response, data
				;is just like tcs, comes in response
				;to a probe; also is reflected by remote
				;when terminal characteristics are sent
	MESAGE (HSI,BADTIN,C,0,0,0,0,0,0)  ;41 host up and answereing with # of
				;ports in port byte, and host # in data
				;byte
	MESAGE (CLP,BADTIN,A,0,0,0,0,0,0) ;42 SUPER CLOCK INFO REQUEST
	MESAGE (CLR,SUPTIM,F,0,0,0,0,0,0) ;43 SUPER CLOCK INFO
	MESAGE (BKO,BADTIN,H,0,0,0,0,0,0) ;44 START BLK OUTPUT
	MESAGE (BOC,TIMBOC,B,0,0,0,0,1,1) ;45 BLK OUPTUT COMPLETE
	MESAGE (BIN,BADTIN,H,0,0,0,0,0,0) ;46 START BLK INPUT
	MESAGE (INB,TIMINB,D,0,0,0,0,1,1) ;47 BLK INPUT DONE, OUT OF BUFFER
	MESAGE (INE,TIMINE,D,0,0,0,0,1,1) ;50 BLK INPUT DONE, COMPLETED
	MESAGE (INT,TIMINT,D,0,0,0,0,1,1) ;51 BLK INPUT DONE, TIMEOUT
	MESAGE (IRQ,BADTIN,B,0,0,0,0,0,0) ;52 RQST BLK INPUT TERMINATION
	MESAGE (IHR,TIMIHR,D,0,0,0,0,1,1) ;53 BLK INPUT DONE, HOST REQUEST
	MESAGE (ORQ,BADTIN,B,0,0,0,0,0,0) ;54 RQST BLK OUTPUT TERMINATION
	MESAGE (OHR,TIMOHR,B,0,0,0,0,1,1) ;55 BLK OUTPUT DONE, HOST REQUEST
	MESAGE (NEG,IGNORE,C,0,0,0,0,0,0) ;56 BLK IO PORT NEGOTIATION
	MESAGE (BRK,IGNORE,B,0,0,0,0,0,0) ;57 BREAK CHR RECVD
	MESAGE (PSR,IGNORE,C,0,0,0,0,0,0) ;60 PORT STATUS
	MESAGE (EAO,BADTIN,B,0,0,0,0,0,0) ;61 ENTER ALT OUTPUT DEVICE MODE

MAXTYP=.-1

	DEPHASE
;
;	Terminal characteristic subtypes
;
TMCECO==0			;echo
TMCCIE==1			;echo tab (^I)
TMCELF==2			;echo lf as lf cr delay
TMCECR==3			;echo cr as cr lf
TMCCRD==4			;cr delay
TMCIR==5			;input rate
TMCOR==6			;output rate
TMCPAR==7			;parity
TMCHDX==10			;half duplex
TMCPA==11			;paramater A
TMCPB==12			;parameter B
TMCPC==13			;parameter C
TMCXEN==14			;X-ENABLE
TMCHEC==15			;ECHO CONTROL H
TMCREN==16			;REVERSE X-ENABLE
TMCKAT==17			;KATAKANA
TMCBRK==20			;TERMINAL OUTPUT ON BREAK

MXTRMC==20			;MAX TERMINAL CHR ALLOWED

; USER ALLOWABLE RECEIVE/SEND COMMUNICATIONS MESSAGE MASKS (COMPLEMENT MASKS)

CMMSK0:	^-RUSR0			;RECEIVE NON-WHEEL MASK 0TH WRD
	^-SUSR0			;SEND NON-WHEEL MASK 0TH WRD
	^-RWHL0		 	;RECEIVE WHEEL MASK 0TH WRD
	^-SWHL0			;SEND WHEEL MASK  0TH WRD

CMMSK1:	^-RUSR1			;RECEIVE NON-WHEEL MASK 1ST WRD
	^-SUSR1			;SEND NON-WHEEL MASK 1ST WRD
	^-RWHL1		 	;RECEIVE WHEEL MASK 1ST WRD
	^-SWHL1			;SEND WHEEL MASK  1ST WRD

TYMLNW:	LNBT0			;INPUT LINE CHECK MASKS (2 WORD TABLE)
	LNBT1

TYMCNW:	CNBT0			;INPUT CONNECTED LINE CHECK MASKS (2 WD TABLE)
	CNBT1


	SUBTTL INITIALIZATION AND RESET ROUTINES
	RESCD


BCRASH:	MOVE A,YBCRSH		;save reason for TYMBASE crash
	MOVEM A,TYMCSH
	MOVSI A,CRASHF!JB0RST		;notify job0
	IORM A,TYMSTS
	AOS JB0FLG
;;;	BUG(NTE,<TYMSRV: TYMBASE DIED>)
	RET


TYMINA:	SETOM TYMFLG		;enter here to turn tymnet on when off
TYMINI:	SETZM KEYTIM		;force REQUEST FOR TYMRST on next TYMCHK
	SETOM KEYCT
	SETZM YBCRSH
	SETZM YALRMC
	MOVE 1,[DYSNDX,,DYSNDX+1]	;CLEAR SYSNDX TABLE
	SETOM DYSNDX
	BLT 1,DYSNDX+NSYSND-1
	MOVE 1,[BLKLCK,,BLKLCK+1]	;CLEAR BLKLCK TABLE
	SETOM BLKLCK
	BLT 1,BLKLCK+NBKIOQ-1
	SETZM BLKLKC			;# LOCKED
	MOVE 1,[TYMPRT,,TYMPRT+1]
	SETZM TYMPRT
	BLT 1,TYMPRT+NTYMTT-1		;CLEAR PORT STATUS TABLE
	RET


SKPRET:	AOS (P)
	RET

	SUBTTL CLOCK LEVEL KEY CHECKING ROUTINE
;
;	CALLED FROM PIAPR, MUST USE ONLY REG A
;
TYMCLK:	skipe tymflg		;skip if tymnet turned off	
	SKIPE YBCRSH		;base crashed?
	 JRST (2)		;yes

	SKIPGE	KEYCT		;interface up?
	 JRST (2)		;no

	MOVE A,TODCLK		;time to check key?
	CAMGE A,KEYTIM
	 JRST (2)		;no

	ADDI A,KEYPRD		;checking key, reset timer
	MOVEM A,KEYTIM

	MOVE A,[YKEY]		;test and set key
	EXCH A,YLOCK

	CAME A,[YKEY]		;was key clobbered?
	 JRST TYMCL0		;yes, reset check counter

	SKIPG A,KEYCT		;no, are we waiting for base to come up?
	 JRST (2)		;yes, then do nothing but wait

	SOJG A,TYMCL1		;no, base is active, we are checking
				;the key, if still ok, go do things

	BUG(NTE,<TYMSRV: TYMBASE OVERDUE>) ;key has been unclobbered too long

	SETOM KEYCT
	MOVE A,TODCLK
	ADDI A,RSTPRD
	MOVEM A,KEYTIM
	JRST (2)

TYMCL0:	MOVEI A,IKEYCT		;RESET KEYCT WITH THIS
TYMCL1:	EXCH A,KEYCT		;reset key count
	JUMPN A,(2)		;first time up?
	MOVSI A,UPF		;yes
	IORM A,TYMSTS
	MOVSI A,ALARMF		;RESET ANY ALARM
	ANDCAM A,TYMSTS
	SETZM YALRMC		;AND TURN OFF TYMBASE DISABLED ALARM CLOCK
	AOS JB0FLG		;tell job 0
	JRST (2)

	SUBTTL	SCHEDULER LEVEL DRIVER

TYMCHK:	MOVEI A,^D100		;do this ten times per second
	MOVEM A,TYMTIM##		;save for sched to decrement
	SKIPN TYMFLG		;tymnet turned on??
	 RET			;no, do nothing
	SKIPE YBCRSH		;base crashed?
	 JRST BCRASH		;yes

	SKIPE A,YALRMC		;TYMBASE DISABLED ALARM CLOCK ARMED?
	 JRST  [CAML A,TODCLK	;YES, ALARM TRIPPED?
		JRST .+1	;NO, NOT YET
		MOVSI A,ALARMF	;YES, TELL JOB0 CHECKER
		IORM A,TYMSTS
		AOS JB0FLG
		SETZM YALRMC	;AND TURN OFF ALARM
		SKIPN KEYCT	;DID NODE NEVER ANSWER OUR RESET?
		 JRST TYMCH1	;YES-SEND OUT ANOTHER RESET
		JRST .+1]	;JUST FALL THRU

	SKIPLE	A,KEYCT		;interface status
	 JRST TYMC6		;up, transfer
	 JUMPE A,TYMC8		;reset, waiting for base

	MOVE B,TODCLK		;down
	CAMGE B,KEYTIM		;should we reset
	 JRST TYMC8		;no

TYMCH1:	MOVE 1,TYMSTS
	TLOE 1,JB0RST
	 JRST TYMC06		;STILL SET, SEE IF SHOULD POKE JB0
	MOVEM 1,TYMSTS		;JUST SET IT
	AOS JB0FLG		;POKE JOB 0 TO DO IT
	JRST TYMC5		;TERMINATE TYMCHK

TYMC06:	SKIPE 1,J0RTIM		;ALWAYS POKE JB0 IF NOT RETRYING
	CAMG 1,TODCLK		;TIME TO RETRY VIA JOB 0?
	 AOS JB0FLG		;YES, POKE JOB 0
	JRST TYMC5		;TERMINATE TYMCHK

TYMC6:	SKIPN TYSAVP		;restart blocked interface?
	 JRST  [CALL ENTCHK	;check ans/shut status
		 CALL TYMC3	;(oring full)
		JRST TYMIN]
;
;	blocked oring on interrupt side is handled by popping to top
;	of the stack and CALL TYMC3.  This saves PC and critical reg's
;	and notifies TYMCHK to attempt restart next time through.
;	CALL's to TYMC3 must be from top of stack, and only ac's 2-5
;	are saved-IPTR and OPTR are regenerated from the
;	respective rings.
;
	MOVE 5,[TYSAV1,,B]	;restore critical registers
	BLT 5,5
	MOVE IPTR,YIHP
	MOVE OPTR,YOHP
;	JRST @TYSAVP		;try doing output again
	PUSH P,TYSAVP		;DO THIS SO WE CAN CLEAR TYSAVP
	SETZM TYSAVP
	RET			;RETURN TO WHERE TYSAVP POINTED

TYMC3:	POP P,A			;interface blocked for oring output on
	SUBI A,2		;intrpt side, save pc and critical ac's
IFN STATSW,<AOS YSTOFL>		;count oring fulls

TYMC4:	MOVEM A,TYSAVP		;save pc
	MOVE A,[B,,TYSAV1]	;save ac's
	BLT A,TYSAV1+3
;
;	internal confusion and errors are handled by JRST TYMC7 after
;	an appropriate BUGCHK if there is nothing on the stack, or
;	by SETOM KEYCT and getting to TYMC5 as soon as possible
;
TYMC5:	SKIPL KEYCT		;any fatal errors this time through?
	 JRST TYMC8		;NO

TYMC7:	SETOM KEYCT		;come here on any interface internal
	MOVE A,TODCLK		;confusion, silences key for 
	ADDI A,RSTPRD		;one second, resets interface
	MOVEM A,KEYTIM

TYMC8:	MOVEI 2,1		;ONE TO CHECK
	SKIPN 1,AX2CLK(2)	;CLEANUP TIMER ON?
	 RET			;NO
	CAML 1,TODCLK		;TIME TO GIVE UP ON SUP CLEANUP MESSAGE?
	 RET			;NOT YET
	SETZM AX2CLK(2)		;YES-RESET CLOCK
	SETZM AUXINF(2)		;AND RELEASE LOCK AND STATUS
IFN STATSW,<AOS YSTAX2>
	RET

;
;	CHECK ANS/SHUT STATUS
;
ENTCHK:	MOVSI A,ANSF
	SKIPLE TYMENT		;force up
	 JRST ENTUP		;yes
	SKIPE TYMENT		;force down?
	 JRST ENTDWN		;yes
	SKIPL ENTFLG		;is ENTFLG answering or shut?
	 JRST ENTDWN		;shut

ENTUP:	TDNE A,TYMSTS		;answering
	 JRST SKPRET
	TYMANS
	 RET
	IORM A,TYMSTS
	JRST SKPRET

ENTDWN:	TDNN A,TYMSTS		;shut
	 JRST SKPRET
	TYMSHT
	 RET
	ANDCAM A,TYMSTS
	JRST SKPRET

	SUBTTL BASE TO HOST MESSAGE DISPATCHER

TYMIN:	MOVE IPTR,YIHP		;set up iring host pointer
TYMIN0:	CAMN IPTR,YIBP		;pending input?
	 JRST IBPCHK		;no pending input

	LDB C,PITYPE		;get message type (CAN'T BE NEGATIVE)
	CAIG C,MAXTYP		;check for legal message type
	 JRST TYMIND		;LET 0:MAXTYP THROUGH
	TRNE C,200		;CHR MESSAGE?
	 JRST TYMINC		;YES-LET IT THROUGH
	JRST INVTYP		;OOPS, NOT IN DISPATCH OR CHR MESSAGE


;HERE FOR DISPATCHABLE NON-CHR MESSAGE

TYMIND:	LDB LINE,PIPORT		;get port number
	MOVE 4,3		;MESSAGE TYPE INTO 4
	IDIVI 4,^D36		;4/ INDEX, 5/ BIT #
	MOVE 5,BITS(5)		;MAKE TEST MASK FROM TYPE CODE
	TDNN 5,TYMLNW(4)	;NEEDS VALID LINE CHECK?
	 JRST TYMID1		;NO-DISPATCH, UNCKED LINE IN 2 (TYMNET PORT)
	CAIL LINE,NTYMTT	;LEGAL LINE?
	 JRST BADLIN
	HRRZ LINE,TYMTEN(LINE)	;xlate TYMNET port number to TENEX line no.
	TDNN 5,TYMCNW(4)	;NEEDS CONNECTED LINE CHECK?
	 JRST TYMID1		;NO-DISPATCH, POSSIBLY UNCONNED LEGAL LINE IN 2
	CAIN LINE,-1		;CONNECTED?
	 JRST INOCON		;not
TYMID1:
IFN STATSW,<AOS YSTIMD>
	JRST @TYPFCN(C)		;DISPATCH


;HERE FOR CHR MESSAGE

TYMINC:	LDB LINE,PIPORT		;get port number
	CAIL LINE,NTYMTT	;LEGAL LINE?
	 JRST BADLIN
	HRRZ LINE,TYMTEN(LINE)	;xlate TYMNET port number to TENEX line no.
	CAIN LINE,-1		
	 JRST INOCON		;not
	TRZ C,200		;LEAVE JUST CHR CNT IN 3
IFN STATSW,<AOS YSTIMC>
	 JRST ITYPEG		;DO CHR MESSAGE


IGNOR2:	AOJ IPTR,
IGNORE:	AOJ IPTR,		;advance pointer
TYMIN1:	ANDI IPTR,IRNGS-1	;take care of wraparound
	MOVEM IPTR,YIHP		;tell base
	JRST TYMIN0		;try for more input
;
;  May need # read packets cutoff to prevent excessive time here
;

BADTIN:	BUG(NTE, <TYMSRV: BAD MESSAGE TYPE INPUT FROM TYMBASE>)
	AOJA IPTR,TYMIN0

INVTYP:	BUG(NTE, <TYMSRV: INVALID MESSAGE TYPE INPUT FROM TYMBASE>)
	JRST TYMC7		;we're going to crash, so lets not do
				;any more

BADLIN:	BUG(NTE, <TYMSRV: BAD LINE # ON TYMBASE INPUT>)
	JRST INOCN1

INOCON:	BUG(NTE, <TYMSRV: INPUT REC'D ON DISCONNECTED LINE>)
INOCN1:	TRZE C,200		;WAS TYPE G MESSAGE?
	 JRST ITYPG2		;GO IGONRE IT
	CAIL C,31		;TYPE F?
	CAILE C,33
	AOJA IPTR,TYMIN1	;IGNORE AND GET MORE
	AOJA IPTR,.-1		;TYPE F.


	SUBTTL BASE TO HOST MESSAGE HANDLERS

ITYPEG:	LDB 1,CONSTS		;GET CONNECTION STATUS
	CAIE 1,CONHG3		;HANGING UP NON INITED LINE?
	CAIN 1,CONHG4
	 JRST ITYPG2		;YES
	
REPEAT 0,<
	TLNN A,FHEDF		;flush TYMNET header?
	 TDZA A,A		;yes
	 SETO A,		;no
	PUSH P,A		;save flag
>
	
	PUSH P,C		;save count
	PUSH P,PIPORT		;set up ILDB pointer
	PUSH P,LINE		;save line number, because TTCHI may clobber
	MOVE 13,C		;set counter

ITYPG0:	ILDB A,-1(P)		;get char
	MOVE LINE,(P)		;restore line no.
	SETZ 6,
REPEAT 0,<
	SKIPN -3(P)		;flush TYMNET header?
	 JRST  [ANDI A,177	;yes, look for <cr> or ";"
		CAIE A,";"
		CAIN A,15
		CAIA
		 JRST .+2
		SETOM -3(P)	;yes, say were through flushing
		MOVSI A,FHEDF
		ANDCAM A,TYMLNS(LINE)
		JRST .+2]
>
	CALL TTCHI		;stuff it into buffer
	SOJG 13,ITYPG0		;continue if more

	SUB P,BHC+2		;pop ILDB pointer
	POP P,C			;get total count to advance pointer
REPEAT 0,<
	SUB P,BHC+1		;pop TYMNET header flush flag
>
ITYPG2:	ADDI C,2+3
	CAIE C,37+5		;37 CHARACTER MESSAGE?
	JRST ITYPG3		;NO, HANDLE NORMALLY
	LSH C,-2		;YES, FINISH INPUT RING POINTER
	ADD IPTR,C		;UPDATE
	MOVSI C,IBPF
	IORM C,TYMLNS(B)
	MOVSI C,IBPOF		;HANDLING IBP ON THIS LINE?
	TDNN C,TYMLNS(B)
	JRST ITYPG4		;NO, IMMEDAITELY TURN OFF IBP
	LDB C,TTIMAX		;YES, CHECK BUFFER CHAR COUNT
	LSH C,-2		;IF LESS THAN 1/4 FULL
	CAMGE C,TTICT(B)
	JRST TYMIN1		;TOO FULL, DON'T TURN OFF IBP
ITYPG4:	MOVEI C,11		;EMPTY ENOUGH, TURN OFF IBP
	PUSHJ P,OTYPEB
	PUSHJ P,TYMC3		;FULL ORING
	MOVSI C,IBPF		;AND INDICATE IBP TURNED OFF
	ANDCAM C,TYMLNS(B)
	JRST TYMIN1
ITYPG3:	LSH C,-2
	ADD IPTR,C
	
	MOVE 3,TYMLNS(2)	;CHECK TO SEE IF WE ARE HANDLING INPUT
	TLNN 3,IBPF		;BACK PRESSURE AND THAT THERE IS PRESENTLY
	TLNN 3,IBPOF		;NO INPUT BACK PRESSURE ON.
	 JRST TYMIN1		;IF THIS IS NOT SO,RETURN NOW.
	LDB 3,TTIMAX		;GET BUFFER SIZE
	SUBI 3,IBPOFF		;AND COMPUTE WHEN TO TURN INPUT BACK PRESSURE ON
	CAMLE 3,TTICT(2)	;TOO MANY CHARS IN BUFFER?
	 JRST TYMIN1		;NOT YET
	TYMNOP			;YES, TURN ON BACK PRESSURE
	 CALL TYMC3		;(ORING OVERFLOW)
	MOVSI 3,IBPF		;TELL OURSELVES WE SENT INPUT BACK PRESSURE
	IORM 3,TYMLNS(2)
	JRST TYMIN1

GOBBLE:	CALL TCIBF		;character gobbler, kill input buffer
	AOJA IPTR,TYMIN1

BPON:	MOVSI C,OBPF		;say we received back pressure
	IORM C,TYMLNS(LINE)
IFN STATSW,<AOS YSTBPO>		;count back pressures
	AOJA IPTR,TYMIN1

BPOFF:	MOVSI C,OBPF		;turn back pressure flag off
	ANDCAM C,TYMLNS(LINE)
	AOJA IPTR,TYMIN1

BLACK:	
IFN STATSW,<AOS YSTBZP>		;count buffer zaps
	AOJA IPTR,TYMIN1	;ignore buffer zaps unless user traps them

ZAPPER:	TYMZAP			;echo all received zaps
	 CALL TYMC3
	CALL TYDISC		;reset everything but connect state
	LDB 3,CONSTS		;get connect state to figure new conn state
	TRNE 3,<CONNF>B47	;if connected,
	 CALL ZAP		;disconnect
	AOJA IPTR,TYMIN1	;HERE CONFRE OR DISCONNECTED, JOB 0 WILL HANDLE

ZAP:	MOVE 1,BITS-40(3)	;translate state to bit mask
	HLRZ 4,TTFORK(2)	;get other state word
	CAIN 3,CONCTL		;attached as ctrltt?
	 JRST CTLZAP		;fire off detach int and set disc state
	CAIN 3,CONAUX		;attached as aux circuit?
	 JRST AUXZAP		;FIRE OFF AUX BRK INT AND NOTIFY JOB 0
	TLNE 1,(1B<CONHG3-32>+1B<CONHG4-32>+1B<CONLG1-32>)
				;(1b<...> takes decimal 32 = octal 40)
	 JRST ZAPP1		;disappear silently
	TLNE 1,(1B<CONHG1-32>+1B<CONHG2-32>)
	 JRST ZAPP2		;notify job 0
	CAIN 3,CONAL1
	 JRST  [SETOM TTFORK(2)	;reset ttfork and disappear quietly
		hrrzs	ttype(2) ;clear XONXOFF STUFF
		JRST ZAPP1]
	TRZ 3,<CONNF>B47	;on all other states, set to corresponding
	JRST ZAPP3		;disconnected state

CTLZAP:	CALL TYMDET
	MOVEI 3,CONDC3
	JRST ZAPP3		;set state and return
	
AUXZAP:	CALL TYMDET
	MOVEI 3,CONAD3
	JRST ZAPP3

ZAPLGO:	JUMPL 4,ZAPP1		;if no job, reset and disappear
	PUSH P,2
	HRRZ 2,JOBPT(4)		;get top fork of job
	MOVSI 1,400000+PSILOB	;set logout interrupt on it
	IORM 1,FKINT(2)
	CALL PSIR4		
	POP P,2			;and fall into reset conn status entry

ZAPP1:	SKIPA 3,[CONFRE]
ZAPP2:	MOVEI 3,CONDC3
ZAPP3:	DPB 3,CONSTS
	CAIN 3,CONFRE		;FREE?
	 RET			;YES-JUST RETURN
	TRNN 3,<CONNF>B47	;NO-A CONNECTED STATE?
	 AOS JB0FLG		;NO-DISCONNECTED, HAVE JOB 0 CLEAN UP
	RET

;ISSUE INTERRUPT AS APPROPRIATE FOR TYPE OF TYMNET LINE
;A CONTROLLING TTY ALWAYS GETS TER CODE 30 (CARRIER OFF)
;ANY OTHER LINE (AUX CIRCUIT OR NOT) WILL GET 32 (NON-CTTY CARRIER OFF)
;ACCEPTS LINE # IN 2

TYMDET:	SKIPGE 1,TTFORK(2)		;line has job?
	 RET				;no
	HLRZS 1				;GET JOB USING THIS TTY
	ANDCMI 1,600000			;FLUSH EXTRANEOUS BITS
	HLRZ 1,JOBPT(1)			;1/ JOB CTTY LINE #
	MOVEI 3,^D30			;ASSUME CTTY INT (CARRIER OFF)
	CAIE 2,(1)			;ARE WE GONNA INT FOR CTTY?
	 MOVEI 3,^D32			;NO-GET NON-CTTY INT THEN
	CALL TYMPSI			;ISSUE IT
	RET

TYDPSI:	TDZA 4,4		;say this is a deferred PSI
TYMPSI:	SETO 4,			;say this is an immediate PSI
	SKIPGE 1,TTFORK(LINE)	;line has job?
	 RET			;no
	HLRZS 1			;get job no
	PUSH P,B		;TTPSI2 destroys B
	SKIPGE 1,JOBPT(1)	;job detached?
	 JRST TYMPS2		;yes, go ahead and send interrupt
	HLRZ 2,1		;get ctrltt for that job
	MOVE 5,BITS(3)		;get mask bit for interrupt
	IOR 4,TTDPSI(2)		;check ac4 to see if should check TTDPSI
	TDNE 5,TTPSI(2)		;if ctrltt has interrupt enabled
	TDNN 5,4
	 JRST .+2
TYMPS2:	CALL TTPS2T		;give it to them
	POP P,B
	RET

TYDISC:	SETZM YLTCHK(LINE)	;zappers cancel outstanding yellow balls
	MOVEI C,1B35
	ANDCAM C,TTFLGS(LINE)	;say "carrier off"
	HLRZ A,TENTYM(LINE)	;get TYMNET port
	SETO C,			
	HRLM C,TENTYM(LINE)	;nil out TENEX to TYMNET link
	HRRM C,TYMTEN(A)	;nil out TYMNET to TENEX link
	SETOM AUXSJQ(LINE)	;CLEAR AUXQUE INTERNAL TABLE ENTIES
	SETOM AUXDJQ(LINE)
	SETOM AUXTMQ(LINE)
	SETOM AUXCTL(LINE)
	RET


LOGGER:	CALL LOGLIN		;check and/or get line
	 JRST LOGZAP		;no free lines, just fade away
		
	MOVE 3,[<CONLG1>B5+ECHOF] ;INITIAL TYMLNS STATE
	MOVEM 3,TYMLNS(2)
	SETZM TYMBKS(2)		;INITAL BLOCK IO STATUS

	SETZB 6,TTPSI(LINE)	
	DPB 6,[POINT 2,TTFLGS(LINE),29]	;set mode to binary, no ints 
	DPB 6,TTYLMD		;to pass following TYMNET data through 

	MOVEI A,3		;fake a ^C 
	PUSH	P,LINE
	CALL TTCHI		
	POP	P,LINE

	HLRZ A,TTFORK(LINE)	;DID FORK START?
	CAIE A,-1
	AOJA IPTR,TYMIN1	;yes

	MOVEI 3,CONHG3		;no, hang up line
	DPB 3,CONSTS
	AOJA IPTR,TYMIN1	

AUXLOG:	LDB 4,PISUBT		;get ident
	EXCH 4,2		;id into ac2, saving LINE for later
	CALL CHKAXI		;check ident
	 JRST LOGZAP		;illegal ident
	LDB 1,AUXSTS		;get id state
	CAIN 1,AUXPS3		;log while PSI abort of process?
	 JRST  [MOVEI 1,AUXPS4	;yes, say we're expecting to abort a super
		DPB 1,AUXSTS	;response
		JRST LOGZAP]	;and silently kill line
	CAIE 1,AUXSGN		;login string has been sent?
	 JRST AXLBAD		;no, bad
	MOVEI 1,AUXLGR		;yes,
	DPB 1,AUXSTS		;set state to "got line"
	EXCH LINE,4		;line into ac2
	CALL LOGLIN		;get line
	 SETO LINE,		;no free lines, indicate w/ illegal line #
	EXCH 4,2		;ident into ac2
	LDB 3,AUXLIN		;get job number for line
	DPB 4,AUXLIN		;save new line number
	JUMPL 4,LOGZAP		;no free lines, disconnect
	HRLM 3,TTFORK(4)	;assign tty line to job waiting for line
	MOVE 2,4		;IBPBFR WANTS LINE # IN 2
	CALL IBPBFR		;FIX UP IBP BUFFER PARAMETERS, NO BUFFERS YET
	MOVE 3,[<CONAL1>B5+<IBPOF>B17] ;INITIAL TYMLNS STATE
	MOVEM 3,TYMLNS(2)
	SETZM TYMBKS(2)		;INITAL BLK IO STATUS
	AOJA IPTR,TYMIN1

AXLBAD:	BUG(NTE, <TYMSRV: UNEXPECTED AUX LOGIN>)
	JRST LOGZAP

CHKAXI:	CAIN 2,AUXID		;checks incoming aux circuit id for validity
	 JRST SKPRET		;when TYMSHARE starts building aux circuits
	BUG(NTE, <TYMSRV: ILLEGAL AUX CIR IDENT>)
	RET			;in parallel, this will have to be changed

LOGLIN:	CAIE LINE,-1		;have line?
	 JRST  LOGLI3		;yes, this is funny, as a login or auxlogin
				;should be on a new line...clean things up

	MOVE LINE,TYMPTR	 ;no, find a free TENEX line
	MOVSI C,CONMSK
	TDNN C,TYMLNS(LINE)	;disconnected line
	SKIPL TTFORK(LINE)	;and unassigned?
	AOBJN LINE,.-2		;no

	JUMPGE LINE,LOGLI1	;if AOBJN fell through, no free lines
	HRRZS LINE		;line number only
	LDB C,PIPORT		;get TYMNET port number
	HRLM C,TENTYM(LINE)	;connect to TENEX line number
	HRRM LINE,TYMTEN(C)	;connect TENEX line number to TYMNET port
	MOVEI C,1B35
	IORM C,TTFLGS(LINE)	;say "carrier on"
	JRST SKPRET		;take good return

LOGLI1:	BUG(NTE,<TYMSRV: NO UNASSIGNED TYMNET TTY LINES>)
	RET			;take error return

LOGLI3:	BUG(NTE,<TYMSRV: LOGIN ON CONNECTED LINE>)
repeat 0,<
	SUB P,BHC+1
	JRST TYMC7		;intolerable internal confusion
>
	ret			;ajs @ sumex 3/22/78

LOGZAP:	LDB LINE,PIPORT		;no free TENEX lines, get TYMNET port number
	MOVEI C,TYPZAP
	CALL OTYPES		;avoid conn check
	 CALL TYMC3		;oring overflow
	AOJA IPTR,TYMIN1	;go on for more messages

NEWSUP:	AOS 1,TYMSVC		;increment supervisor version
	CAILE 1,777		;wrap around at 9 bits
	 SETZM TYMSVC
	BUG(NTE,<TYMSRV: SUPERVISOR TAKEOVER>)
	AOJA IPTR,TYMIN1

SUPTIM:	MOVE 1,TIMFLG
	TLNN 1,(TIMEUS!TIMEJ0)	;DID WE REQUEST THIS MESSAGE?
	 JRST IGNOR2		;NO, FLUSH IT	 
	MOVE 3,PIPORT		;PT TO PORT FOR ILDB'S OF 4 DATA BYTES
	ILDB 1,3		;GET HI BYTE
	LSH 1,^D24		;POSITION
	ILDB 2,3		;GET 2ND BYTE
	LSH 2,^D16		;POSITION
	IOR 1,2			;AND ENTER
	ILDB 2,3		;GET 3RD BYTE
	LSH 2,^D8		;POSITION
	IOR 1,2			;AND ENTER
	ILDB 2,3		;GET 4TH BYTE (POSITIONED)
	IOR 1,2			;ENTER
	MOVEM 1,TIMNET		;PUT WHERE JOB 0 AND GETTYM SEES IT
	SETFLG (<TIMFLG>,<TIMEIN>)	;SAY ITS IN
	MOVE 1,TIMFLG
	TLNN 1,(TIMEUS)		;DID USER REQUEST THIS VIA TYMOP?
	 AOS JB0FLG		;NO, POKE JOB 0 TO SEE IT FAST
	JRST IGNOR2		;FINISHED	



SUPRSP:	MOVE A,LINE		;supervisor ack or err event
	CALL CHKAXI		;legal ident?
	 AOJA IPTR,TYMIN1	;no, just ignore
	SETZM AX2CLK(2)		;CLEAR CLEAUP TIMER
	LDB 4,PISUBT		;get supervisor response
	DPB 4,AUXSVR		;save it
	LDB 1,AUXSTS		;get preset state of id
	MOVE 1,BITS(1)		;turn into mask for quick checking
	JUMPE 4,SUPACK		;event is supervisor request ack
	TLNE 1,(1B<AUXPS2>+1B<AUXPS3>+1B<AUXPS4>) ;event is request nak
	 JRST  [SETZM AUXINF(2)	;if we were waiting to close out PSI
		IFN STATSW,<AOS YSTSNK>
		AOJA IPTR,TYMIN1] ;interrupted build, release id
	TLNN 1,(1B<AUXREQ>+1B<AUXSGN>+1B<AUXLGR>) 
	 JRST SUPBAD
	MOVEI 1,AUXRTY		;if we were building, re try
	JRST SUPSET

SUPACK:	TLNE 1,(1B<AUXREQ>)	;if we had just sent our first super req
	 JRST  [MOVEI 1,AUXSGR	;say the super granted it
		JRST SUPSET]
	TLNE 1,(1B<AUXLGR>)	;if we already had a log
	 JRST  [MOVEI 1,AUXBLT	;say we have the line
		DPB 1,AUXSTS
		LDB 2,AUXLIN
		MOVEI 1,CONAL2	;confirm the connection of this line
		DPB 1,CONSTS
		AOJA IPTR,TYMIN1]
	TLNE 1,(1B<AUXPS4>)	;if we were closing out a PSI intrrptd build
	 JRST  [SETZM AUXINF(2)	;release the id
		IFN STATSW,<AOS YSTSAK>
		AOJA IPTR,TYMIN1]
	TLNN 1,(1B<AUXPS2>)
	 JRST [	IFN STATSW,<AOS YSTSBD>
		JRST SUPBAD]
	MOVEI 3,TYPSUP		;if we got a PSI after the first super req
	CALL OTYPES		;send off a second one w/o a login string
	 CALL TYMC3
	MOVE 1,TODCLK		;SET UP TIMER
	ADDI 1,AUXPRD		;FOR ONE MINUTE
	MOVEM 1,AX2CLK(2) 	;PUT A TIMER ON THIS MESSAGE TOO
	MOVEI 1,AUXPS3		;to force an error and close out the id

SUPSET:	DPB 1,AUXSTS
	AOJA IPTR,TYMIN1
	
SUPBAD:	BUG(NTE, <TYMSRV: UNEXPECTED SUPERVISOR RESPONSE RECEIVED>)
	SETZM AUXINF(2)		;CLEAR AUXINF SO DON'T BLOCK OUT OTHERS
	AOJA IPTR,TYMIN1	;ignore illegal super responses

CRSH:	BUG(NTE, <TYMSRV: TYMBASE COMING UP FROM CRASH>)
IFN STATSW,<AOS YSTBCR>
	AOJA IPTR,TYMIN1

LDEC:	MOVEI C,DEFF		;remote in immediate echo mode, looks to
	IORM C,TYMLNS(LINE)	;TENEX like half duplex
	AOJA IPTR,TYMIN1

EDEC:	MOVEI C,DEFF		;remote in deferred echo mode, looks
	ANDCAM C,TYMLNS(LINE)	;tell ;to TENEX like full duplex
	AOJA IPTR,TYMIN1

	SUBTTL INPUT BACK PRESSURE HANDLER

;	INPUT BACK PRESSURE TURNED ON AT ITYPG2 WHEN INPUT BUFFER OVERFLOWS
;	PRESET LEVEL.

;	TYMTCI JUMPED TO FROM TCI0 AND TCIBF TO TURN IBP OFF
;	IF NEED BE

TYMTCI:	MOVE 3,TYMLNS(2)	;CHECK FOR INPUT BP WAKEUP
	TLNN 3,IBPF	;IS INPUT BACK PRESSURE ON NOW?
	 RET		;NO, SIMPLY RETURN
	CALL IBPKIL	;YES, SEE IF WE SHOULD TURN IT OFF.
	 CALL [SKIPN INSKED	;TRIED TO SEND BPOFF, BUT ORING OVRFLW,
		JRST OFULLR	;IF NOT IN SCHED, JUST MAKE FORK WAIT,
		AOS IBPFLG	;ELSE, NOTIFY TYMSRV TO DO IT LATER.
		RET]
	RET

IBPKIL:	LDB 3,TTIMAX	;COMPUTE WAKE UP POINT FROM BUFFER SIZE
	LSH 3,-2	;TURN OFF BACK PRESSURE TO TYMBASE WHEN INPUT BUFF
	CAMGE 3,TTICT(2) 	;ONE QUARTER FULL
	 JRST SKPRET		;NOT THERE YET
	TYMOUP		;SEND BACK PRESSURE OFF
	 RET		;ORING OVERFLOW
	MOVSI 3,IBPF	;AND TELL OURRSELVES WHAT WERRE DOING
	ANDCAM 3,TYMLNS(2)
	JRST SKPRET

;	IBPCHK CALLED AFTER TYMIN AND BEFORE YELCHK AND TYMOUT TO TAKE
;	CARE OF ANY LINES THAT TRIED TO SEND AN IBP OFF MESSAGE FROM
;	THE SCHEDULER SIDE, BUT NOT IN TYMSRV, AND FOUND THE ORING FULL.

IBPCHK:	SKIPN IBPFLG		;ANY BELATED IBPKILS WE HAVE TO DO?
	 JRST YELCHK		;NO
	MOVE 2,TYMPTR		 ;YES, SET UP CHECKING LOOP
	MOVSI 1,IBPF
IBPCH1:	TDNN 1,TYMLNS(2)	;IS LINE HAVE IBP ON?
	 JRST IBPCH2		;NO, SKIP CHECK
	CALL IBPKIL		;YES, CHECK LINE, KILL IBP IF POSSIBLE
	 CALL TYMC3		;ORING OVERFLOW
	SOSLE IBPFLG		;TO SAVE TIME, ONLY IPBKILL THIS MANY LINES
IBPCH2:	AOBJN 2,IBPCH1		;CHECK ALL LINES
	SETZM IBPFLG		;RESET FLAG
	JRST YELCHK


	SUBTTL yellow ball handler

SNDYEL:	NOSKD1
	SKIPL TYMLNS(LINE)	;don't set yellow clock on disconnected lines
	 JRST YELLO2

	TYMYEL			;send yellow ball
	 JRST OKRET		;if oring full, let upper level handle
	MOVE C,TODCLK		;yellow ball send, set up clock
	ADDI C,YELPRD
	MOVEM C,YLTCHK(LINE)
	JRST OKSKPR

YELLOW:	SKIPE YLTCHK(LINE)	;yellow ball received, one of ours?
	 JRST	[CALL YELLO1	;yes
		 CALL TYMC3	;oring full
		AOJA IPTR,TYMIN1]
	CAIN C,TYPORG		;if orange
	 AOJA IPTR,TYMIN1	;don't reflect
	TYMORG			;somebody elses, echo as orange
	 CALL TYMC3
	AOJA IPTR,TYMIN1

YELLO2:	OKSKD1

YELLO1:	SETZM YLTCHK(LINE)	;yellow ball returned as orange, stop clock
	MOVSI C,CDMPF		;if dumping chars in CIBF
	ANDCAM C,TYMLNS(LINE)	;stop
	LDB C,CONSTS		;get connection state
	CAIE C,CONHG2		;hanging up line?
	CAIN C,CONHG4
	 JRST TYHNG2		;yes
	CAIN C,CONAH2		;HANGING UP AUX CIRCUIT?
	 JRST TYHNG2		;YES
	JRST SKPRET		;normal (non-oring-full) exit

YELCHK:	MOVE LINE,TYMPTR	;scan all TYMNET lines for overdue

YELCK1:	SKIPE A,YLTCHK(LINE)	;expecting yellow balls?
	CAMLE A,TODCLK		;yes, overdue?
	 JRST YELCK2		;no

	BUG(NTE,<TYMSRV: YELLOW BALL OVERDUE>)

IFN STATSW,<AOS YSTLYL>
	CALL YELLO1		;simulate rec'd orange ball
	 CALL TYMC3		;oring full

YELCK2:	AOBJN LINE,YELCK1
	JRST TYMOUT

	SUBTTL HOST TO BASE INTERFACE DRIVER

TYMOUT:	MOVSI LINE,-NTYMOT	;check a given number of lines for
	JUMPE LINE,TYMOBK	;output (no lines to check)
	HRR LINE,LTYMOT		;starting where we left off last time

TYMO1:	SKIPL TTFLGS(LINE)	;line output active?
	 JRST TYMO6
IFN NDLS,<
	CAMN LINE,TTHNGL##	;checking for hung line?
	 SETZM TTHNGT##		;if so, say active
>
	MOVE D,TYMLNS(LINE)
	TLNE D,OBPF		;back pressure on
	 JRST TYMO3
	HLLZ D,TTYPE(2)		;GET XON/XOFF FLAGS
	TLNE D,(1B0)		;XON FROZEN?
	 JRST TYMO3		;YES
TYMO4:	SKIPE C,TTECT(LINE)	;no, any echo output pending?
	 JRST TYMSNE		;yes
	SKIPE C,TTOCT(LINE)	;no, any normal output pending?
	 JRST TYMSNO		;yes

	MOVSI C,400000		;no, flag as silent
	ANDCAM C,TTFLGS(LINE)
	CALL TTRLOB		;and release buffers

	CALL GREENT		;send green ball if desired and possible
	 CALL TYMC3		;oring full

TYMO6:	LDB 3,CONSTS		;no, any body waiting for output to become
	CAIE 3,CONHG1		;inactive?
	CAIN 3,CONHG3
	 JRST TYHNG1
	CAIN 3,CONAH1		;AUX CIRCUIT WAITNG FOR LINE TO CLEAR OF DATA?
	 JRST TYHNG1		;YES
	JRST TYMO3

TYMSNE:	SKIPN D,TTEOUT(LINE)	;get echo buffer pointer
	 BUG(HLT, <TYM ECHO OUTPUT - NO BUFFER BUT COUNT NON-ZERO>)

	CALL OTYPEG		;put out as many characters as possible
	 JRST TYMO2		;no characters output, buffer full

	MOVEM D,TTEOUT(LINE)	;and pointer
	MOVEM C,TTECT(LINE)
	JRST TYMO5

TYMSNO:	SKIPN D,TTOOUT(LINE)	;same for normal output buffer
	 BUG(HLT, <TYM OUTPUT - NO BUFFER BUT COUNT NON-ZERO>)

	CALL OTYPEG
	 JRST TYMO2

	MOVEM D,TTOOUT(LINE)
	MOVEM C,TTOCT(LINE)

TYMO5:	TRNN A,1000		;last char removed from buffer a ball code?
	 JRST TYMO3		;no, continue normally

	MOVE C,A		;reposition registers (UGH!!)
	MOVE D,6
	CALL OTYPED		;send control message
	 CALL TYMC3		;oring full

	JRST TYMO4		;finish emptying output buffer
TYMO3:	MOVEI C,TYMTTL+NTYMTT-1	;line wraparound
	CAIG C,(LINE)
	 HRRI LINE,TYMTTL-1
	AOBJN LINE,TYMO1

TYMO2:	HRRM LINE,LTYMOT	;save line for next time
	JRST TYMOBK		;CHECK BLK IO RETRY STUFF



;HERE CHECK FOR LINES THAT NEED RETRY OF OTYPEH TO START BLK IO
;TERMINATES ON 1ST FAILURE

TYMOBK: MOVE 2,TYMPTR		;SCAN ALL LINES
TYMOB1:	MOVE 1,TYMBKS(2)	;GET FLAGS
	TLNE 1,BKIRTY		;ANY INPUT NEED A NUDGE?
	 JRST TYMOB4		;DO IT
TYMOB2:	TRNE 1,BKORTY		;ANY OUTPUT NEED A NUDGE?
	 JRST TYMOB5		;DO IT
TYMOB3:	AOBJN 2,TYMOB1		;LOOP TIL DONE
	JRST TYMC5		;MADE IT ALL THE WAY

;HERE WHEN RETRY REQUESTED FOR INPUT, LINE # IN 2
;PRESEVES ACS 1,2

TYMOB4:	PUSH P,1
	PUSH P,2
	TLNN 1,BKIACT		;BETTER BE
	 JSP 3,TYMOBX		;UGH...
	LDB 1,[BKINDX(2)]	;GET THE NDX
	LDB 3,[BLKSTA(1)]	;GET STATE
	CAIE 3,2		;MUST BE STATE 2
	 JSP 3,TYMOBX		;UGH...
	MOVE 1,BLKADR(1)	;GET COUNT,,REAL CORE PAGE
	HRRZS 2			;JUST LINE # IN 2
	MOVEI 3,TYPBIN
	CALL OTYPEH		;INPUT RETRY
	 JRST TYMOB6		;FAILED AGAIN-ORING STILL FULL-TRY AGAIN LATER
	POP P,2			;GET AOBJN
	MOVSI 1,BKIRTY		;TURN THIS GUY OFF NOW
	ANDCAM 1,TYMBKS(2)
	POP P,1			;RESTORE FLAGS
	JRST TYMOB2		;BACK INTO MAINLINE

;HERE WHEN RETRY REQUESTED FOR OUTPUT, LINE # IN 2
;PRESEVES ACS 1,2

TYMOB5:	PUSH P,1
	PUSH P,2
	TRNN 1,BKOACT		;BETTER BE
	 JSP 3,TYMOBX		;UGH...
	LDB 1,[BKONDX(2)]	;GET THE NDX
	LDB 3,[BLKSTA(1)]	;GET STATE
	CAIE 3,2		;MUST BE STATE 2
	 JSP 3,TYMOBX		;UGH...
	MOVE 1,BLKADR(1)	;GET COUNT,,REAL CORE PAGE
	HRRZS 2			;JUST LINE # IN 2
	MOVEI 3,TYPBKO
	CALL OTYPEH		;OUTPUT RETRY
	 JRST TYMOB6		;FAILED AGAIN-ORING STILL FULL-TRY AGAIN LATER
	POP P,2			;GET AOBJN
	MOVEI 1,BKORTY		;TURN THIS GUY OFF NOW
	ANDCAM 1,TYMBKS(2)
	POP P,1			;RESTORE FLAGS
	JRST TYMOB3		;BACK INTO MAINLINE

;HERE WHEN OTYPEH FAILED AGAIN.  ORING FULL, RETRY NO MORE FOR NOW

TYMOB6: POP P,2			;RESTORE ACS PUSHED DURING RETRY
	POP P,1
	JRST TYMC5		;DONE WITH OUTPUT FOR NOW


;HERE VIA JSP 3, WHEN INCONSISTENCY FOUND

TYMOBX: BUG(HLT,<TYMSRV: BLK IO RETRY REQUESTED FOR INCONSISTENT ENTRY>)


	SUBTTL HOST TO BASE INTERFACE HANDLER
;
;	single word types (A,B,C,D)
;
;	C/ type
;	LINE/ TENEX port number
;	D/ first arg
;	5/ second arg
;
;	CALL routine
;	 +1 no room in buffer/illegal pointer
;	 +2 normal return
;
OTYPES:	NOSKD1
	CALL OROOM		;entry to output put 1 word format message
	 JRST OKRET		;w/o checking connection, or xlating line
	MOVE 6,LINE
	JRST OTYPE3

OTY2EA:				;SAME SINCE NO PORT #
OTYPEA:	NOSKD1			;SHUT OF SCHED UNLESS THAT'S US
	CALL OROOM		;ANY ROOM?
	 JRST OKRET		;NO, DO NOTHING
	DPB C,POTYPE		;YES, PUT ITEM IN TYPE FIELD
	AOJA OPTR,OTYPE1	;INCREMENT POINTER AND RETURN


;THIS ENTRY ACCEPTS PORT # IN 2 (DOES NOT NEED TO BE INITIALIZED0

OTY2EB:
OTY2EC:
OTY2ED:	NOSKD1
	CALL OROOM
	 JRST OKRET
	HRRZ 6,2		;PUT PORT IN 6
	JRST OTYPE3		;AND MERGE

OTYPEB:
OTYPEC:
OTYPED:	NOSKD1
	SKIPGE TENTYM(LINE)	;no, disconnected line?
	 JRST OKSKPR
	CALL OROOM		;any room?
	  JRST OKRET		;no
	HLRZ 6,TENTYM(LINE)	;xlate line number
OTYPE3:	DPB C,POTYPE		;set in type field
	DPB 6,POPORT		;set in port field
	DPB D,POSUBT		;set in subtype field
	DPB 5,PODATA		;set in data field

	AOJ OPTR,		;advance pointer
OTYPE1:	ANDI OPTR,ORNGS-1	;take care of wraparound
	MOVEM OPTR,YOHP		;tell base
IFN STATSW,<AOS YSTOMS>		;count output message packets

OKSKPR:	AOS (P)
OKRET:	OKSKD1			;turn scheduling back on
	RET

;
;	double word type (F)
;
;	C/ type
;	LINE/ TENEX port number
;	D/ word of data
;
;	CALL OTYPEF
;	 +1 no room in buffer/illegal pointer return
;	 +2 normal return
;
;	!!NOT TO BE USED FROM INTERRUPT SIDE, OR ELSE INTERFACE
;	DEADLOCK MAY DEVELOP!!!  If IRING input causes ORING output
;	to occur which issues TYPE F when ORING host pointer at 
;	end of ORING buffer, interrupt side will never become aware
;	that there more room will ever become available in ORING.
;

;THIS ENTRY ACCEPTS PORT # IN 2 (DOES NOT NEED TO BE INITIALIZED0

OTY2EF:	NOSKD1
	CALL OROOM
	 JRST OKRET
	SOJLE 6,OKRET
	HRRZ 6,2		;PORT # IN 6
	JRST OTYPF1		;MERGE

OTYPEF:	NOSKD1
	SKIPGE TENTYM(LINE)	;connected line?
	 JRST OKSKPR		;no, ignore
	CALL OROOM		;any room
	 JRST OKRET		;no, none at all
	SOJLE 6,OKRET		;yes, enough room? if not return
	HLRZ 6,TENTYM(LINE)	;xlate line number
OTYPF1:	DPB 6,POPORT		;set in line field
	DPB C,POTYPE		;set in type field
	HLRM D,ORING(OPTR)	;set in first halfword of data
	HRLM D,ORING+1(OPTR)	;set in fecond

	MOVEI OPTR,2(OPTR)	;advance pointer
	JRST OTYPE1		;go tell base


;OUTPUT TYPE H MESSAGE (KINDA SPECIAL FOR BLOCK IO)

;CLOBBERS NO ACS!!!
;NO SKIP IF ORING FULL

;ACCEPTS  1/ COUNT,,PAGE (1ST WD IS OVERHEAD & NOT PART OF COUNT)
;	  2/ LINE #
;	  3/ MESSAGE TYPE
;

;THIS ENTRY ACCEPTS PORT # IN 2 (DOES NOT NEED TO BE INITIALIZED0

OTY2EH:	NOSKD1
	PUSH P,1		;DON'T CLOBBER THESE
	PUSH P,2
	PUSH P,3
	PUSH P,4
	PUSH P,5
	PUSH P,6
	CALL OROOM		;any room
	 JRST OTYHOK		;no, none at all
	SOJLE 6,OTYHOK		;yes, enough room? if not return
	HRRZ 6,2		;PORT # IN 6
	JRST OTYPH1		;MERGE

OTYPEH:	NOSKD1
	SKIPGE TENTYM(LINE)	;connected line?
	 JRST OKSKPR		;no, ignore
	PUSH P,1		;DON'T CLOBBER THESE
	PUSH P,2
	PUSH P,3
	PUSH P,4
	PUSH P,5
	PUSH P,6
	CALL OROOM		;any room
	 JRST OTYHOK		;no, none at all
	SOJLE 6,OTYHOK		;yes, enough room? if not return
	HLRZ 6,TENTYM(2)	;xlate line number
OTYPH1:	DPB 6,POPORT		;set in line field
	DPB 3,POTYPE		;set in type field
	LDB 6,[POINT ^D8,-5(P),^D9]	;GET HI BITS OF 16 BIT COUNT
	DPB 6,POSUBT		;MAKE IT HI BYTE OF COUNT
	LDB 6,[POINT ^D8,-5(P),^D17]	;GET LO BITS OF 16 BIT ADR
	DPB 6,PODATA		;MAKE IT LO BYTE OF COUNT
	ADDI OPTR,1		;BUMP WORKING ORING PTR
	HRRZ 1,-5(P)		;GET PAGE
	LSH 1,^D9		;MAKE ADR
	ADDI 1,1		;DONT INCLUDE OVERHEAD WORD
	LDB 6,[POINT ^D8,1,^D19]	;GET HI BITS OF ADR
	DPB 6,POTYPE		;MAKE IT HI BYTE OF 24 BIT ADR
	LDB 6,[POINT ^D8,1,^D27]	;GET MID BITS OF ADR
	DPB 6,POPORT		;MAKE IT MID BYTE OF 24 BIT ADR
	LDB 6,[POINT ^D8,1,^D35]	;GET LO BITS OF ADR
	DPB 6,POSUBT		;MAKE IT LO BYTE OF 24 BIT ADR

	ANDI OPTR,ORNGS-1	;take care of wraparound
	MOVEM OPTR,YOHP		;tell base

IFN STATSW,<AOS YSTOMS>		;count output message packets

	AOS -6(P)		;SKIP RET
OTYHOK:	OKSKD1			;OKSKED
	POP P,6			;RETURN
	POP P,5
	POP P,4
	POP P,3
	POP P,2
	POP P,1
	RET


;
;	character xfer type (G)
;
;	C/ maximum number of characters to xfer
;	LINE/ port number
;	D/ ILDB pointer to characters
;
;	CALL OTYPEG
;	 +1 no room in buffer/illegal pointer
;	 +2 normal return
;
;	xfers max num chars, or as many as will fit in oring
;
OTYPEG:	NOSKD1
	SKIPGE TENTYM(LINE)	;ignore output to disconnected line
	 JRST  [SETZ C,		;fake full transfer
		JRST OKSKPR]

	CALL OROOM		;any room
	 JRST OKRET		;no

	LSH 6,2			;yes, get space in characters
	SUBI 6,2		;2 char overhead for type and port
	CAILE 6,NXFRMX		;max number of chars
	 MOVEI 6,NXFRMX
	CAILE 6,(C)		;max requested chars
	 MOVEI 6,(C)
	PUSH P,6		;save initial char count

	MOVE 5,POPORT		;get IDPB pointer

OTYPG1:	TDNN D,WRPMSK		;check for buffer ptr wraparound
	HRR D,1-TTSIZ(D)	;if so, get next buffer
	ILDB A,D       		;get character
	TRNE A,1000		;ball code and not regular char?
	 JRST OTYPG2
	ANDI A,377
	IDPB A,5		;put it in buffer
	SOJG 6,OTYPG1		;inc buffer count

OTYPG2:	POP P,5			;get # to move
	SUB 5,6			;sub # not moved to get # moved
	SUB C,5
	JUMPLE 5,OTYPG3		;if no chars sent, even though there was 
				;space (because of control code cut off)
				;skip making TYMNET packet
	TRO 5,200		;make into type G byte

	DPB 5,POTYPE		;set into type field
	HLRZ 6,TENTYM(LINE)	;xlate line to port
	DPB 6,POPORT		;set in line field

	SUBI 5,200-2-3		;change to # words
	LSH 5,-2		
	ADD OPTR,5		;adv host pointer
	ANDI OPTR,ORNGS-1	;take care of wraparound
	MOVEM OPTR,YOHP		;tell base
IFN STATSW,<AOS YSTOMS>		;count output message packets
OTYPG3:	
	TRNN A,1000		;ended because of control message?
	 JRST OKSKPR		;no, ended normally
	TDNN D,WRPMSK		;check for buffer ptr wraparound
	HRR D,1-TTSIZ(D)	;if so, get next buffer
	ILDB 6,D       		;get character
	TDNN D,WRPMSK		;check for buffer ptr wraparound
	HRR D,1-TTSIZ(D)	;if so, get next buffer
	ILDB 5,D       		;get character
	SUBI C,3		;update char count
	JRST OKSKPR
;
;	get room in oring subroutine
;
OROOM:	MOVE OPTR,YOHP		;get host pointer
	MOVE 6,YOBP		;get base pointer

	SKIPL OPTR		;illegal host pointer?
	CAIL OPTR,ORNGS
	 JRST ILLPTR		;for shame TYMNET

	SKIPL 6			;illegal base pointer?
	CAIL 6,ORNGS
	 JRST ILLPTR		;yes
  
	SUB 6,OPTR		;which one ahead
	SOJL 6,[MOVEI 6,ORNGS	;if host pointer ahead, room is to end
		SKIPN YOBP	;of ORING, unless base is on 0
		MOVEI 6,ORNGS-1	;then, to leave space between pointers,
		SUB 6,OPTR	;cannot use last ORING word. get room
		JRST .+1]	;to end of ORING.
	JUMPG 6,SKPRET		;if any room skip return
	RET			;else no room exit

ILLPTR:	BUG(NTE, <TYMSRV: ILLEGAL TYMBASE OUTPUT POINTER>)
	SETOM KEYCT		;force tymbase crash
	RET

	SUBTTL TTYSRV routines

TYMCHI:	MOVE D,TYMLNS(LINE)	;get line status
	TLNE D,CDMPF		;dumping chars for a CIB?
	 RET			;don't insert or echo char
	TRNE D,DEFF		;remote in immediate mode?
	 JRST TTREC4		;yes, looks like "half" duplex
	JRST TYMCHX		;no, handle normally

TYMNFK:	LDB 1,CONSTS
	CAIE 1,CONLG1		;initial connection?
	 RET			;no, just return
	MOVEI 1,CONHG3		;yes
	DPB 1,CONSTS		;set in hang up state
	RET

	SWAPCD

TYMCOB:	TYMGOB			;clear output buffer
	 CALL OFULLR		;no oring room
	RET

TYMDOB:	RET			;MAKE THIS DO NOTHING FOR NOW
	CALL SNDYEL
	 CALL OFULLR		;no oring room

	MOVEI A,TYMOBT		;set up to dismiss until yellow
	HRLI A,(LINE)		;ball comes back
	JSYS EDISMS
	RET			;output buffer now empty

	RESCD

TYMOBT:	SKIPE B,YLTCHK(A)	;yellow ball been received?
	 JRST 0(4)		;no
	JRST 1(4)		;yes, end dismiss

	SWAPCD

TYMCIB:	MOVSI A,CDMPF		;simulate wait for input buffer clear
	IORM A,TYMLNS(LINE)	;tell everybody here to dump chars.
	TYMECF			;tell remote not to echo
	 CALL OFULLR		;(oring full)
	MOVEI C,ECHOF		;note that we turned echo off
	ANDCAM C,TYMLNS(LINE)
	CALL TTDOBE		;dismiss until present output gets to
				;remote
	MOVSI A,CDMPF		;ok, we're back in business
	ANDCAM A,TYMLNS(LINE)	;turn off char dump
	CALL TYMECO		;see if we should echo again
	RET


TYMTYP:	MOVSI A,INITF
	TDNN A,TYMLNS(LINE)	;ignore TYMNET set types if connection
	 RET			;incomplete
	CALL TYMECO		;check echo status for changed mech bits
	HRRZ A,TTYPE(LINE)	;tab echoing, get terminal typ

	MOVSI 7,-7		;set 7 TYMNET terminal parameters for each
	PUSH P,[POINT 5,PTT]	;STTYP

TYMTP1:	ILDB D,(P)		;get TYMTCS subtype number
	LDB 5,PTT+1(7)		;get parameter for this line
	TYMTCS
	 CALL OFULLR		;(full oring)
	AOBJN 7,TYMTP1

	SUB P,[XWD 1,1]		;pop stack
	RET

OFULLR:	PUSH P,A		;entry to dismiss and restart
	HRREI A,-3		;packet output
	ADDM A,-1(P)		;back up PC
	CAIA

OFULLP:	PUSH P,A      
IFN STATSW,<AOS YSTOFL>          ;count full orings

	MOVEI A,OFULLT
	HRL A,YOBP
	JSYS EDISMS		;dismiss until more room in ORING

	POP P,A
	RET

	RESCD

;SKIPS IF TYMNET LINE SHOULD GET LF PADDING FROM TENEX
;CALLED FROM TTYSRV AT TTSM2
;ACCEPTS 2/ LINE #
;	3/ TENEX TYPE #

TYMLFP:	PUSH P,1			;HURT NO ACS
	MOVE 1,3			;WHERE PTRS LIKE IT
	LDB 1,PTTPR			;TYMNET ECONG CR WITH LF?
	JUMPE 1,TYMLF1			;NO-PAD LINEFEED THEN
	MOVE 1,3			;YES-TYMNET PADDING CR'S?
	LDB 1,PTTPD
	JUMPN 1,TYMLF0			;YES-DON'T LET TENEX PAD LF THEN
TYMLF1:	AOS -1(P)			;SKIP TO PAD
TYMLF0:	POP P,1				;RESTORE AC
	RET

;FIX UP INPUT BUFFER ALLOCATION FOR IBP PARAMETERS
;ACCEPTS TTY LINE # IN 2
;ALSO SPLICES NEW TTY BUFFERS INPLACE IF SOME BUFFERS ARE CURRENTLY ASSIGNED
;SO MAX CHAR COUNTS WILL BE RIGHT

TTBFSP:	PUSH P,1
	PUSH P,3			;CLOBBER NO ACS
TTBFS0:	MOVEI 3,IBPNBF			;# TTY BUFFERS FOR IBP
	LDB 1,TTIIN			;GET MAX # NOW
	SUB 3,1				;GET DIFF TO GET
	JUMPE 3,TTBFS5			;NOP IF NONE, ALREADY GOT MAXIMUM

	NOSKED				;KEEP SCHEULER AWAY FROM IRING

	SKIPN TTIIN(2)			;ANY BUFFER CURRENTLY EXIST?
	 JRST TTBFS4			;NO-NO SPLICE NECESSARY
	PUSH P,3			;YES, SAVE # NEEDED
	CALL TTGTBF			;GET THEM
	 JRST TTBFS2			;COULDN'T, WAIT FOR THEM
	HRRZI 3,-1(3)			;3/ ADR OF 1ST NEW BUFFER FROM PTR
	HRRZ 1,TTIIN(2)			;GET OLD BYTE PTR ADR PART
	TDNN 1,WRPMSK			;CONVERT TO BUFFER ADR
	SUBI 1,TTSIZ
	ANDCM 1,WRPMSK
	ADDI 1,1			;1/ ADR OF OLD BUFFER
	MOVEM 1,(P)			;SAVE IT, REUSE STACK
TTBFS1:	MOVE 4,1			;COPY SO CAN CLOBBER
	HRRZ 1,(4)			;GET WHAT IS PTING TO
	CAME 1,(P)			;BACK TO STARTING BUFFER?
	 JRST TTBFS1			;NO, LOOP FOR CHAINED RING
	EXCH 1,(3)			;YES, SPLICE OLD BUFFERS BETWEEN
	MOVEM 1,(4)			;1ST & 2ND NEW BUFFERS
	JRST TTBFS3			;NOW DIDDLE STATIC MAX CHAR COUNTS

;HERE WHEN COULDN'T GET ENOUGH BUFFERS FOR IBP

TTBFS2:	OKSKED
	POP P,3				;GET # NEEDED IN 3
	MOVEI 1,TTBFST			;SCHED TEST TO WAIT ON
	HRL 1,3				;# NEEDED IN LH TEST WORD
	JSYS EDISMS
	JRST TTBFS0			;TRY AGAIN

;SHED TEST USED ABOVE TO WAIT FOR SUFFICIENT TTY BUFFERS

TTBFST:	CAMLE 1,TTFREC			;ENOUGH?
	 JRST 0(4)			;NOPE
	JRST 1(4)			;YEP, WAKE UP

;HERE AFTER ASSIGNING BUFFERS AND NOW NEED TO FIX STATIC MAX COUNTS
;OR NO BUFFERS EXISTED, THEREFORE ASSIGNED NONE BUT MUST DIDDLE MAX COUNTS

TTBFS3:	POP P,3				;RESYNC STACK, BUFFERS ASSIGNED
TTBFS4:	CALL IBPBFR			;NOW DIDDLE STATIC MAX COUNTS

	OKSKED

TTBFS5:	POP P,3				;RESTORE ACS
	POP P,1
	RET


;ADJUST STATIC MAX INPUT BUFFER PARAMETERS

IBPBFR:	PUSH P,1
	MOVEI 1,IBPNBF		;NUMBER OF INPUT BUFFERS
	DPB 1,TTNIN
	MOVEI 1,IBPNBF		;MAX # INPUT BUFFERS (EXTERNAL ARITHMETIC)
	IMULI 1,NYCHBF		;MAX # CHARS
	SUBI 1,1		;ADJUST
	DPB 1,TTIMAX
	POP P,1
	RET

;UNDO WHAT IBPBFR DID FOR US
;ACCEPTS TTY LINE # IN 2
;ASSUMES THERE ARE NO TTY BUFFERS CURRENTLY ASSIGNED
;SO NO NEED TO WORRY ABOUT CHAR MAX CHAR COUNTS FOR BUFFERS

IBPRFB:	PUSH P,1
	MOVEI 1,NINBUF		;NUMBER OF INPUT BUFFERS
	DPB 1,TTNIN
	MOVEI 1,NINBUF		;MAX # INPUT BUFFERS (EXTERNAL ARITHMETIC)
	IMULI 1,NYCHBF		;MAX # CHARS
	SUBI 1,1		;ADJUST
	DPB 1,TTIMAX
	POP P,1
	RET

;SKIPS IF LINE ASSOCIATED WITH AUX CIRCUIT
;EITHER IS ORIGINATOR WITH AUXF ON OR TERMINATOR WITH TTY TYPE OF 0
;ACCEPTS LINE # IN 2

TYMAUX:	PUSH P,1
	PUSH P,3
	MOVEI 1,400000(2)	;FOR NODTYP
	LDB 3,NODTYP
	ANDI 3,37		;KEEP JUST THE TYPE BITS (IGNORE FLAGS)
	MOVE 1,TYMLNS(2)
	TLNE 1,AUXF		;ORIGIN?
	 JRST TYMAU1
	CAIE 3,0		;OR TERMINATOR?
	CAIN 3,^D14		;GATEWAY AUX IS 14.
TYMAU1: AOS -2(P)		;YES-SKIP RET
	POP P,3
	POP P,1
	RET


OFULLT:	CAMN A,YOBP		;see if base has moved its output ptr
	JRST 0(4)		;no, not yet, keep waiting
	JRST 1(4)		;yes, it has, go stuff some more

	SUBTTL line disconnect handler

;
;	can be called from either program or interrupt side
;	to wait for output buffer to clear, send and receive
;	a yellow ball, disconnect the line, and re-init the line
;THIS MAY NOW BE CALLED TO HANG UP AUX CIRCUITS TOO.
;JOB 0 TAKES CARE OF THE FINAL STATE HANGUP AND DOES RELD FOR AUX CIRCUITS
;
TYHNGU:	NOSKED
	LDB 3,CONSTS		;get connection status
	TRNN 3,<CONNF>B47	;is line connected
	 JRST OKRET		;if not, ignore
	TRNE 3,<AUXF>B47	;WORKING ON AN AUX CIRCUIT?
	 JRST [MOVEI 3,CONAH1	;YES - KEEP AUX STATUS
		JRST TYHN1U]
	MOVEI 3,CONHG1		;wait for buffer to empty
TYHN1U:	DPB 3,CONSTS
	JRST OKRET

TYHNG1:	CAIN 3,CONAH1		;WORKING ON AUX CIRCUIT HANGUP?
	 JRST [MOVEI 3,CONAH2	;YES-STEP TO NEXT AUX CIRCUIT STATE
		JRST TYHN11]
	CAIN 3,CONHG3		;TENEX buffers now empty, pre-init hangup?
	 SKIPA 3,[CONHG4]	;yes
	MOVEI 3,CONHG2
TYHN11:	DPB 3,CONSTS		;set state
	CALL SNDYEL		;output buffer now empty, send yellow
	 CALL TYMC3		;oring full
	JRST TYMO3		;finish output driver

TYHNG2:	TYMZAP			;yellow ball received, zap line
	 RET			;oring full
	AOS (P)			;skip return from interrupt side

	LDB 3,CONSTS		;what was state?
	CAIN 3,CONAH2		;WORKING ON AUX CIRCUIT?
	 JRST [MOVEI 3,CONAD3	;YES-STEP TO FINAL DISC STATE FOR JOB 0
		JRST TYHN12]
	CAIN 3,CONHG4		;if waiting for pre-init close out
	 SKIPA 3,[CONFRE]	;disappear silently,
	MOVEI 3,CONDC3		;else, ask for job 0 to type disc msg
TYHN12:	DPB 3,CONSTS
	TRNN 3,<CONNF>B47	;A CONNECTED STATE STILL?
	 AOS JB0FLG		;ask job 0 TO CLEAN UP APPROPRIATELY
	JRST TYDISC


;CALLED BY RELDD TO CHECK TO SEE IF USER CAN DO IT FOR AUX LINE
;PREVIOUSLY THIS HAD BEEN THE WAY TO HANGUP AUX CIRCUITS BUT IS 
;UNACCEPTABLE NOW.  USER MUST USE THE AUXRLS FUNCTION OF .TYMOP
;WHICH WILL GET JOB 0 TO RELD THE LINE AFTER PROPER ZAPPING
;AND CLEANUP OF INTERNAL TABLES.
;HOWEVER, IF LINE IS IN PROPER STATE, LET IT GO.  THATS HOW
;JOB 0 AND OTHER KNOWLEDGEABLE USERS GET AROUND THIS CHECK.
;CONTROLLING TTY TYMNET LINES ARE OK TOO, ITS JUST AUX WE CARE ABOUT

;ACCEPTS LINE # IN 1

TYMROK:	PUSH P,1
	PUSH P,2
	HRRZ 2,1		;WHERE CONSTS LIKES IT
	LDB 1,CONSTS
	TRNE 1,<AUXF>B47	;AUX CIRCUIT LINE?
	TRNN 1,<CONNF>B47	;YES-IN A DISCONNECTED STATE?
	 AOS -2(P)		;SKIP RET (NOT AUX OR LEGAL AUX STATE)
	POP P,2
	POP P,1
	RET

	SUBTTL echo handler
;
;	To be called any where from on the program side and decide
;	whether the TYMNET line should be echoing at the remote or not
;	and put it into the appropriate mode
;
	SWAPCD

TYMECO:	MOVEI D,TMCHDX
	MOVEI A,HDPXF
	MOVE C,TTFLGS(LINE)	;check changed tty modes
	TRNE C,3B33		;changed to half duplex?
	 JRST  [TDNE A,TYMLNS(LINE)	;from full?
		 RET			;no, already was half
		SETO 5,			;tell remote going to half
		TYMTCS
		 CALL OFULLR		;full oring
		MOVEI A,HDPXF!DEFF	;tell us remote in half-dpx
		IORM A,TYMLNS(LINE)	;and we are not to echo
		RET]
	TDNE A,TYMLNS(LINE)	;to full from half?
	 JRST  [SETZ 5,			;yes, tell remote to go to full
		TYMTCS
		 CALL OFULLR		;full oring
		MOVEI A,ECHOF		;tell us remote in full dpx
		DPB A,[POINT 4,TYMLNS(LINE),33] ;and in deffered echo
		JRST .+1]		;check for echo and tab

	MOVEI A,ECHOF
	MOVSI D,USECOF		;always local echo?
	TDNE D,TYMLNS(LINE)
	 JRST NOECO		;yes
	TRNN C,3B25
	 JRST NOECO		;TENEX NO ECHO mode inhibits remote echo
	TRNN C,3B29
	 JRST NOECO		;so does BINARY mode
;	MOVE 5,FCMOD1(LINE)	;check CCOC codes  !!removed for sake of
;	TLNN 5,(2B15)		;apparent response time  MAH 10/8/74!!
;	 JRST NOECO		;BELL (^G) inhibited or xlate
;	TRNN 5,2B21
;	 JRST NOECO		;LF (^J)       "      "   "
;	TRNN 5,2B27
;	 JRST NOECO		;CR (^M)       "      "   "

	TDNN A,TYMLNS(LINE)	;remote should have echo on
	 JRST  [TYMECN			;if not already on, turn it on
		 CALL OFULLR
		IORM A,TYMLNS(LINE)	;and note that it is on
		JRST .+1]

	MOVEI A,TABF		;see if we should turn tab echo on
	MOVEI D,TMCCIE
	MOVSI C,(1B2)		;mechanical tabs available?
	TDNN C,TTFLGS(LINE)
	 JRST NOTAB		;no
	TRC 5,2B19		;yes, echo real tab char?
	TRNN 5,3B19
	 JRST NOTAB		;no

	TDNE A,TYMLNS(LINE)	;already in that mode?
	 RET			;yes
	MOVEI 5,1		;tell remote to echo tab carh
	TYMTCS
	 CALL OFULLR		;oring full
	IORM A,TYMLNS(LINE)	;note that fact for us
	RET

NOTAB:	TDNN A,TYMLNS(LINE)	;tab echo mode already off?
	 RET			;yes
	MOVEI 5,0		;no, turn it off
	TYMTCS
	 CALL OFULLR		;oring full
	ANDCAM A,TYMLNS(LINE)	;note tab echo mode off
	RET

NOECO:	TDNN A,TYMLNS(LINE)	;echo mode already off?
	 RET			;yes
	TYMECF			;no, tell remote
	 CALL OFULLR		;oring full
	ANDCAM A,TYMLNS(LINE)	;turn off echo mode switch
	RET

	SUBTTL GREEN ball handler

	RESCD

GREEN:	MOVSI C,GREENF		;turn on the green ball flag
	IORM C,TYMLNS(LINE)
GREEN1:	CALL GREENT		;see if we can reflect a green ball now
	 CALL TYMC3		;oring full
	AOJA IPTR,TYMIN1

RED:	MOVSI C,GREENF		;cancel any green balls
	ANDCAM C,TYMLNS(LINE)
	TYMRED			;echo red
	 CALL TYMC3		;(oring full)
	AOJA IPTR,TYMIN1

GREENT:	HRRE C,TTFORK(LINE)	;see if we should send green ball
	JUMPL C,GREEN2		;if fork is not input hung then no

	SKIPGE TTFLGS(LINE)	;output active?
	 JRST GREEN2		;no

	MOVSI C,GREENF
	TDNN C,TYMLNS(LINE)	;was green ball requested?
	 JRST GREEN2		;no

	TYMGRN			;yes, send green ball
	 JRST	[SKIPE INSKED	;oring full, are we on program or inrpt
		 RET		;side? On inrpt side here
		 CALL OFULLP	;on program side here
		 JRST GREENT]	;reque test

	MOVSI C,GREENF		;green ball send, cancel flag
	ANDCAM C,TYMLNS(LINE)

GREEN2:	SKIPE INSKED		;interrupt side?
	 AOS (P)		;yes
	RET			;no

	SUBTTL	TYMOP JSYS


;			TYMOP		JSYS 654
;
; TYMnet utility OPerator; performs a variety of TYMNET utility
; functions.
;
; Accepts in 1:	0-8   option bits
;		9-17  function
;		18-35 TYMNET tty designator
;
;	 2 & 3:	function dependent arguments
;
;
;			TYMOP
;
; Returns + 1:	Unsuccessful, with error number in 1, and if supervisor
;		error, supervisor error number in 2
;	    2:	Successful, 2 & 3 possibly updated
;
;
; see tymop doc for function documentation
;

	SWAPCD

.TYMOP:	MCENT
	LDB 4,[POINT 9,1,17]	;get dispatch code
	CAIL 4,0		;SIMPLE RANGE CHECK
	CAILE 4,NTYMOP-1	;LET RTNS CHK OTHER THEMSELVES
	 RETERR(TYMXX7)		;illegal TYMOP code
	JRST YOPDSP(4)		;DISPATCH, 1,2,3 ACS INTACT, 4 CLOBBERED

YOPDSP:	RETERR (TYMXX7)		;0 - ILLEGAL FUNCTION CODE
	JRST AUXBLD		;1 - BUILD AUX CIRCUIT
	JRST GETLNS		;2 - get line status
	JRST SETIBP		;3 - set INPUT BACK PRESSURE FOR LINE
	JRST GETINS		;4 - get interrupt status
	JRST SETINS		;5 - set interrupt status
	JRST QUEAUX		;6 - QUEUE AUX CIRCUIT
	JRST CLMAUX		;7 - CLAIM AUX CIRCUIT
	JRST DEQAUX		;10 - DEQ AUX CIRCUIT
	JRST SETSYS		;11 - SET SYSNDX SLOT
	JRST CLRSYS		;12 - CLEAR SYSNDX SLOT
	JRST GETSYS		;13 - GET SYSNDX SLOT CONTENTS
	JRST AUXRLS		;14 - RELEASE AUX CIRCUIT
	JRST GETCMD		;15 - get deffered control message
	JRST SNDCMD		;16 - send deffered control message
	JRST SETBKI		;17 - SET BLOCK MODE INPUT FOR LINE
	JRST SETBKO		;20 - SET BLOCK MODE OUTPUT FOR LINE
	JRST GETBLK		;21 - RECEIVE IO BLOCK
	JRST SNDBLK		;22 - SEND IO BLOCK
	JRST AUXATA		;23 - ATTACH AUX CIRCUIT TO JOB
	JRST STBAUD		;24 - SET LINE SPEED (BAUD RATE)
	JRST GTBAUD		;25 - GET LINE SPEED (BAUD RATE)
	JRST GETTYM		;26 - GET TIME FROM TYMNET
NTYMOP==.-YOPDSP


;GET TIME FROM TYMNET AND RETURN TO USER
;RETURNS DATE AND TIME IN INTERNAL FORMAT IN 2

GETTYM:	FGWAIT (<TIMFLG>,<TIMEJ0>,<OFF>) ;WAIT TILL JOB 0 NOT REQUESTING TIME
	OKSKED				;UNDO NOSKED IN FGWAIT
	FGLOCK (<TIMFLG>,<TIMELK>)	;LOCK TIME ENTRY, NOINT
	SETFLG (<TIMFLG>,<TIMEUS>)	;SAY USER IS REQUESTING
	CLRFLG (<TIMFLG>,<TIMEIN>)	;TURN OFF READY FLAG
	TYMCLP				;REQUEST DATE AND TIME
	 CALL OFULLR			;ERROR - ORING FULL
	FGWAIT (<TIMFLG>,<TIMEIN>,<ON>)	;WAIT FOR TIMEIN TO GET TURNED ON
	OKSKED				;UNDO NOSKED IN FGWAIT
	MOVE 3,TIMNET			;GET DATE AND TIME IN 3
	CLRFLG (<TIMFLG>,<TIMEUS!TIMEIN>)	;CLEAR FLAGS
	FGUNLK (<TIMFLG>,<TIMELK>)	;UNLOCK TIME REQUEST, OKINT
	HRROI 1,[ASCIZ/JAN 1,1974 00:00:00-GMT/]
	SETZ 2,
	IDTIM			;GET INTERNAL FORMAT FOR TYMNET DAY 0
	 RETERR (TYMX34)	;FAILED
	MOVE 1,2		;GET IN 1
	MOVE 2,3		;GET 32 BIT SECS SINCE THEN GMT
	IDIVI 2,<^D24*^D60*^D60>	;2/ DAYS, 3/ SECS GMT
	LSH 2,^D18		;DAYS INTO POSITION
	ADD 1,2			;ADD TO DAYS
	HRRZ 2,1		;GET SECS
	ADD 2,3			;TOTAL SECS GMT
	IDIVI 2,<^D24*^D60*^D60>	;2/ DAYS, 3/ SECS GMT
	LSH 2,^D18		;DAYS INTO POSITION
	ADD 1,2			;ADD TO DAYS
	HRR 1,3			;FINAL SECS GMT
	UMOVEM 1,2		;RETURN IT TO USER
	JRST SKMRTN		;RETURN

;SET LINE SPEED (BAUD RATE)

;ACCEPTS RH 1/ TTY DESIGNATOR
;	 RH 2/ INPUT BAUD RATE CODE,,OUTPUT BAUD RATE CODE

STBAUD:	HRRZ JFN,1		;TTY WAS GIVEN, WHERE CHKTTC LIKES IT
	CALL CHKTTC
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	HLRZ 2,TENTYM(2)	;GET PORT NUMBER
	MOVEI 4,TMCIR		;CHARACTERISTIC TO SET, INPUT BAUD RATE
	UMOVE 5,2		;GET RATE CODES FEOM USER ARGS
	PUSH P,2		;SAVE PORT
	PUSH P,5		;SAVE RATES
	MOVSS 5			;GET INPUT RATE IN RH
	TY2TCS			;TYPE 36 - SET TERMINAL CHARACTERISTICS
	 CALL OFULLR		;ERROR, RING BUFFER FULL
	MOVEI 4,TMCOR		;CHARACTERISTIC TO SET, OUTPUT BAUD RATE
	POP P,5			;RATES AGAIN
	POP P,2			;PORT AGAIN
	TY2TCS			;TYPE 36 - SET TERMINAL CHARACTERISTICS
	 CALL OFULLR		;ERROR, RING BUFFER FULL
	JRST SKMRTN		;RETURN



;GET LINE SPEED (BAUD RATE)

;ACCEPTS 1/ TTY DESIGNATOR
;RETURNS +2 WITH BAUD RATE CODES IN 2 (INPUT,,OUTPUT)
;		RATE WILL BE -1 IF ERROR OCURRED

GTBAUD:	HRRZI 2,-400000(1)	;GET LINE # IN 2
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	HLRZ 2,TENTYM(2)	;GET PORT NUMBER
	CAIN 2,-1
	 RETERR (TYMX33)	;NOT A CONNECTED PORT
	PUSH P,2		;RESERVE SPACE FOR ANSWER
	PUSH P,2		;SAVE PORT # ON STACK
	FGLOCK (<TYMPRT(2)>,<BAUDLK>)	;LOCK PORT ENTRY, NOINT
	CLRFLG (<TYMPRT(2)>,<BAUDIN>)	;TURN OFF READY FLAG
	MOVEI 4,TMCIR		;CHARACTERISTIC TO PROBE, INPUT BAUD RATE
	TY2TCP			;TYPE 37 - PROBE TERMINAL CHARACTERISTICS
	 CALL OFULLR		;ERROR - ORING FULL
	MOVE 2,0(P)		;RESTORE PORT TO 2
	FGWAIT (<TYMPRT(2)>,<BAUDIN>,<ON>)	;WAIT FOR BAUDIN TO GO ON
	HRRZ 1,TYMPRT(2)	;GET BAUD CODE IN 1
	OKSKED			;UNDO NOSKED IN FGWAIT
	HRLZM 1,-1(P)		;GET INPUT RATE OR -1 IN LH, O IN RH OF ANSWER
	CLRFLG (<TYMPRT(2)>,<BAUDIN>)	;TURN OFF READY FLAG
	MOVEI 4,TMCOR		;CHARACTERISTIC TO PROBE, INPUT BAUD RATE
	TY2TCP			;TYPE 37 - PROBE TERMINAL CHARACTERISTICS
	 CALL OFULLR		;ERROR - ORING FULL
	MOVE 2,0(P)		;PORT AGAIN
	FGWAIT (<TYMPRT(2)>,<BAUDIN>,<ON>)	;WAIT FOR BAUDIN TO GO ON
	HRRZ 1,TYMPRT(2)	;GET BAUD CODE IN 1
	OKSKED			;UNDO NOSKED IN FGWAIT
	FGUNLK (<TYMPRT(2)>,<BAUDLK>)	;UNLOCK PORT ENTRY, GO OKINT
	IOR 1,-1(P)		;OR POSITIONED INPUT AND OUTPUT RATES
	UMOVEM 1,2		;RETURN IT TO USER
	SUB P,[2,,2]		;RESYNC STACK
	JRST SKMRTN		;DONE

	RESCD

;PORT ALREADY KNOWN TO BE A LEGAL PORT #

TRMCHR:	LDB 2,PIPORT		;GET PORT NUMBER IN 2
	SKIPL TYMPRT(2)		;ENTRY LOCKED AND EXPECTING DATA?
	 JRST IGNORE
	LDB 1,PISUBT		;GET CODE
	CAIE 1,TMCIR		;IS THIS A BAUD RATE?
	CAIN 1,TMCOR
	 CAIA
	JRST IGNORE		;NO-FLUSH IT
	LDB 1,PIDATA		;GET BAUD RATE
	HRRM 1,TYMPRT(2)	;ENTER BAUD CODE IN PORT TABLE
	SETFLG (<TYMPRT(2)>,<BAUDIN>)	;SAY ITS THERE
	AOJA IPTR,TYMIN1	;DONE

	SWAPCD

;ATTACH AUX CIRCUIT TO JOB AND MAKE CTTY AND PRIMARY IO DEVICE FOR THIS FORK
;AND ITS INFERIORS

;ACCEPTS RH 1 TTY DESIGNATOR

AUXATA:	MOVE 4,1		;SAVE ACS
	HRRZ JFN,4		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	CALL TYMAUX		;ASSOCIATED WITH AUX CIRCUIT?
	 RETERR (TYMX23)	;NO
	HLRZ 3,TTFORK(2)	;GET OWNER IN 3
	CAME 3,JOBNO		;SAME AS THIS JOB?
	 RETERR (TYMXX9)	;NO-LOSE FOR NOW

	NOINT

	PUSH P,CAPENB		;SAVE OLD CAPENB
	MOVSI 1,(1B6)		;CTTY CAP
	IORM 1,CAPENB		;GIVE IT TEMPORARILY
	MOVE 5,JOBPT(3)		;SAVE OLD CTTY FOR JOB
	MOVE 6,CTRLTT		;SAVE OLD CTRLTT
	HRLM 2,JOBPT(3)		;MAKE NEW CTTY FOR JOB
	MOVEM 2,CTRLTT		;MAKE CTRLTT IN JSB
	MOVE 1,[1B2!400000]	;RESET TO JOB CTTY THIS AND ALL INFERIORS
	HRRZ 2,4		;TERMINAL DESIGNATOR
	SCTTY
	 RETERR	(TYMX32,<MOVEM 5,JOBPT(3) ;;RESTORE OLD CTTY FOR JOB
			MOVEM 6,CTRLTT	 ;;RESTORE OLD CTRLTT
			POP P,CAPENB	 ;;RESOTRE OLD CAPENB
			OKINT>)		 ; PASS ERROR VIA AC1
	MOVEI 1,-3		;THIS AND ALL INFERIOR FORKS
	SETO 2,			;THE CONTROLLING TERMINAL
	SPJFN
	POP P,CAPENB		;RESOTRE OLD CAPENB
	OKINT
	JRST SKMRTN		;SKIP FOR SUCCESS



;RELEASE AUX CIRCUIT

AUXRLS:	MOVE 4,1		;SAVE ACS
	MOVE 5,2
	MOVE 6,3
	HRRZ JFN,4		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	CALL TYMAUX		;ASSOCIATED WITH AUX CIRCUIT?
	 RETERR (TYMX23)		;NO
	HLRZ 1,TTFORK(2)	;GET OWNER IN 1
	CAME 1,JOBNO		;SAME AS THIS JOB?
	 RETERR (TYMXX9)	;NO-LOSE FOR NOW
	CALL TYHNGU		;INIT: WAIT FOR LINE TO CLEAR AND ZAP
	JRST SKMRTN		;SKIP SUCCESS


	SUBTTL	auxilliary circuit builder

;	MUST HAVE AUXBLD PRIVELEGE BIT TYMOX IN CAPMSK (OR WHEEL OR OPER)

;	1/ B0 - Wait for AUXBLD process if busy
;	   B1 - F,DATA IS IN 3 FOR HOST TO HOST PROTOCOL
;	   B2 - DO NOT SEND HOST TO HOST PROTOCOL
;	   B3 - USE SIGNO STRING PROVIDED BY USER
;	   B4 - USE JOB'S AUXNAM FOR SIGNON STRING
;	2/ Asciz string pointer to signon STRING in user space
;	3/ F,DATA WHERE F=0 FOR EXEC AND DATA IS DON'T CARE
;			F=1 FOR QUE FOR JOB USING UDBITS IN DATA
;			F=2 FOR EXEC BLK MODE
;			F=3 FOR QUE BLK MODE USING UDBITS IN DATA
;	      F IS 8 BITS, REST IS DATA
;	
;	IF 0B3 AND 0B4 => USE SYSTEM DEFAULT AUX CIR SIGNON NAME
;	IF 1B3 AND 1B4 => ERROR
;
;	If all goes well, the building process is the following,
;	1) send supervisor request (type 26); 2) receive supervisor
;	acknowledge; 3) send signon string (character at a time with type
;	30's); 4) terminate sting with another supervisor request (type 26);
;	5) receive aux log in (type 7); 6) receive another supervisor
;	acknowledge, whereupon the line is assigned to the job.  If all
;	does not go well, see the state diagram at the beginning of this
;	file.  In particular, since the fork can be waiting quite a while
;	(2 mins) for a supervisor response and shouldn't stay NOINT, PSI
;	interrupts disassociate the fork from the building process, and
;	let the SCHED level routines abort the building process

AUXBLD:	MOVE 11,1		;SAVE ARG ACS IN 11,12,13
	MOVE 12,2
	MOVE 13,3
	TLNE 11,(1B3)		;IF BOTH ON, USER IS CONFUSED
	TLNN 11,(1B4)
	 CAIA
	RETERR (TYMX30)
	TLNN 11,(1B3)		;USER PROVIDING NAME?
	 JRST AUXCN1		;NO-OK SO FAR
	MOVE 1,CAPMSK##		;GET CAP MASK FOR USER
	MOVE 2,CAPENB		;GET CAPS ENABLED
	TRNN 2,WHEEL!OPER	;THESE GUYS CAN DO IT IF ENABLED
	TRNE 1,TYMOX		;CAN DO IT?
	 JRST AUXCN2		;OK
	RETERR (TYMX10)		;NOPE
	
AUXCN1:	TLNN 11,(1B4)		;WANTS TO USE AUXNAM?
	 JRST AUXCN2		;NO-USE SYSTEM DEFAULT, COOL
	SKIPN AUXNAM		;YES-GOT ONE TO USE?
	 RETERR (TYMX31)	;NO
AUXCN2:	ADD P,BHC+10		;GET STRING STORAGE SPACE
	JUMPGE P,MSTKOV
	TLNE 11,(1B2)		;DON'T SEND HOST TO HOST?
	 JRST AUXB00		;DON'T CHECK IT THEN
	TLNN 11,(1B1)		;GONNA SPECIFY FUNCTION?
	 JRST AUXB00		;NO-FLY WITH DEFAULT

	LSH 3,-^D28		;FUNCTION INTO POSITION
	CAIL 3,0		;RANGE CHECK
	CAILE 3,MTYMQU
	 RETERR (TYMX18)	;BAD FUNCTION

AUXB00:	MOVEI 1,-10(P)
	MOVE 2,12		;USER MODE PTR
	CALL CPYFU1		;COPY STRING FROM USER ONTO STACK
	 JRST MRETNE		;PASS ERROR TO USER (CAN'T HAPPEN)

	MOVEI 2,AUXID		;FAKE AN AUX CIR BLDG ID UNTIL TYMNET GETS
				;PARALLEL CIRCUIT BUILDING
AUXBL0:	NOSKED
	SKIPE AUXINF(2)		;GET PROCESS
	JRST [	OKSKED
		TLNN 11,(1B0)	;WAIT?
		 RETERR(TYMXX1)
		MOVEI 1,AUXINF(2) ;WAIT FOR AUXLCK TO UNLOCK
		CALL DISE
		JRST AUXBL0]
	AOS AUXINF(2)		;CLAIM PROCESS OWNERSHIP
	NOINT
	OKSKED

	MOVSI 4,-NAXTRY		;TRY THIS MANY TIMES
AUXBL2:	MOVE 1,TYMSVC		;NOTE SUPERVISOR VERSION TO USE IN
	LSH 1,^D9
	ADDI 1,AUXREQ		;SET STATE TO FIRST SUP REQ SENT
	MOVEM 1,AUXINF(2)	;CHECKING FOR SUPERVISOR TAKEOVER

	MOVEI 3,TYPSUP		;OUTPUT SUPERVISOR REQUEST
	CALL OTYPES
	 CALL OFULLR		;(FULL ORING)

	CALL AUXBL6		;WAIT FOR RESPONSE
	AOBJN 4,AUXBL2		;ERROR RESPONSE, TRY AGAIN
	JUMPGE 4,AUXBL7		;SUPERVISOR ERRROR RESPONSE

AUXBL5:	TLNE 11,(1B3)		;USE USER PROVIDED STRING?
	 JRST AUXB52		;YES-LEGALITY ALREADY CHECKED
	TLNN 11,(1B4)		;USE JOB'S AUXNAM?	
	 SKIPA 1,[POINT 7,DEFAXN]	;NO-USE SYSTEM DEFAULT
	MOVE 1,[POINT 7,AUXNAM]	;YES-PT TO JOB'S AUXNAM
	CALL AUXBL4		;SEND OUT USERNAME
	MOVEI 1,-7(P)		;GET USER STRING PTR
	HRLI 1,(POINT 7,0)	;STRIP OFF HIS/HER USERNAME IN STRING
AUXB50:	ILDB 4,1		;SKIP TIL TERM OR FIELD SEPARATOR
	CAIE 4,0
	CAIN 4," "
	 JRST AUXB51		;TERMINATOR SEEN
	CAIE 4,15
	CAIN 4,";"
	 JRST AUXB51		;TERMINATOR SEEN
	CAIE 4,":"		;FIELD SEPARATOR?
	 JRST AUXB50		;SKIP OVER VALID CHR
AUXB51:	ADD 1,[70000,,0]	;BACKUP PTR TO PT TO REASON FOR SKIP STOP
	TLNE 1,400000
	SUB 1,[430000,,1]
	JRST AUXB53		;NOW SEND WHATS LEFT OF USER STRING

AUXB52:	MOVEI 1,-7(P)		;GET FULL STRING POINTER PROVIDED BY USER
	HRLI 1,(POINT 7,0)
AUXB53:	CALL AUXBL4		;SEND REMAINDER OF USER PROVIDED STRING
	MOVE 1,TYMSVC		;NOTE SUPERVISOR VERSION USED IN CHECKING
	LSH 1,^D9		;SUPERVISOR TAKEOVER, SAY SUPR RESP PENDING
	HRL 1,JOBNO		;NOTE JOBNO FOR AUXLOG TO USE IN ASSIGNING
	ADDI 1,AUXSGN		;SET SECOND SUPER REQUEST SENT STATE
	MOVEM 1,AUXINF(2)

	MOVEI 3,TYPAXC		;THIS USED TO BE TYPSUP (ANOTHER SUP RQST)
	MOVEI 4,";"		;TERMINATE WITH ";"
	CALL OTYPES
	 CALL OFULLR

	CALL AUXBL6		;WAIT FOR RESPONSE
	 JRST AUXBL7		;SUPERVISOR RESPONDED WITH AN ERROR

AUXB10:	LDB 1,AUXLIN		;GET LINE NUMBER
	CAIL 1,TYMTTL		;TYMNET LINE?
	CAIL 1,TYMTTL+NTYMTT
	 JRST  [MOVEI 1,TYMXX3	;NO, NO FREE LINES
		JRST AUXBL8]
	SETZM AUXINF(2)		;CLEAR AUX IDENT VARIABLES BEFORE RELEASING
	SUB P,BHC+10		;CLEAR STACK
	
	MOVE 2,1
	NOSKED
	LDB 3,CONSTS		;GET CONNECTION STATUS
	TRNN 3,<CONNF>B47	;GOT ZAPPED AFTER SUPER OK RESPONSE?
	 JRST  [MOVEI 3,CONFRE	;YES, SILENTLY FREE LINE
		DPB 3,CONSTS
		SETOM TTFORK(2)
		hrrzs	ttype(2)	;clear XON XOFF STUFF
		OKSKED
		MOVEI 1,TYMXX4
		JRST AUXBL8]
	MOVEI 3,CONAL3		;SET INITIALZATION IN PROGRESS STATE
	DPB 3,CONSTS
	OKSKED

	MOVEI 1,400000(2)	;SET UP LINE NUMBER
	ADD P,BHC+3
	JUMPGE P,MSTKOV
	MOVEI 7,-<3-1>(P)
	SETZM TYNODS-400000(1)
	MOVEI 2,3		;SIZE OF EFACT BLOCK

	CALL INIMSG		;SET UP LINE AND NOTE CONNECT
	SUB P,BHC+3

	ASND			;ASSIGN THE LINE TO THIS JOB
	 JFCL			;PASS ERROR BACK TO USER
	HRR 11,1		;RETURN LINE DESIGNATOR TO USER RH 1
				;BUT LEAVE OPTION BITS TEMPORARILY
	MOVE 2,NORMTF		;SET UP MODES
	TRZ 2,3B29		;BINARY INITIAL MODE
	STPAR
	SFMOD
	MOVEI 2,TYPCRT
	STTYP

	MOVEI 2,-400000(1)
	SETZM TTLPOS(2)		;RESET POSITIONS
	NOSKED
	LDB 3,CONSTS		;GET CONNNECTION STATUS
	TRNN 3,<CONNF>B47	;STILL CONNECTED?
	 JRST  [CALL AUXZAP	;FIRE OFF LINE DETACHED INTERUPT
		OKSKED		;AND TELL JOB 0 ABOUT IT
		JRST AUXB11]	;AND RETURN TO USER
	MOVEI 3,CONAUX		;LINE CONNECTED
	DPB 3,CONSTS
	OKSKED

	TLNE 11,(1B2)		;DON'T SEND HOST TO HOST?
	 JRST AUXB11		;SKIP IT THEN
	SETZ 4,			;ASSUME DEFAULT EXEC FUNCTION 0
	TLNE 11,(1B1)		;SPECFYING FUNCTION?
	MOVE 4,13		;YES-GET INFO WORD USER SPECIFIED IN 4
	MOVEI 2,200		;SEND HOST TO HOST PROTOCOL
	BOUT			;AUXTTY DESIGNATOR STILL IN 1
	MOVE 2,[POINT 8,4]	;8 BIT PTR TO 4
	MOVNI 3,4		;FUNCTION AND D0,D1,D2
	SOUT
	MOVE 3,[POINT 4,4,35]	;POINT AT LAST 4 BITS OF DATA
	LDB 2,3			;GET THEM
	LSH 2,4			;UP INTO HI 4 BITS OF BYTE
	BOUT			;SEND D3
	MOVEI 2,200		;SEND TERMINATOR OF H2H PROTOCOL
	BOUT			;FALL INTO GO HOMER


AUXB11:	HRRZS 11		;SUCCESS, CLEAR OPTION BITS FROM USER AC 1
	CALL AUXB20		;RET USER ACS
	OKINT
	JRST SKMRTN		;AND SKIP RETURN TO USER

; ERROR, ABORT PROCESS

AUXBL7:	LDB 12,AUXSVR		;GET ERROR CODE IN USER ACS 2
	MOVEI 1,TYMXX5		;MAKE INTO TENEX ERROR MESSAGE

AUXBL8:	MOVEM 1,LSTERR		;STORE LAST USER ERROR IN PSB
	MOVE 11,1		;STORE ERROR IN USER AC 1

AUXBL9:	SETZM AUXINF(2)		;CLEAR AUX IDENT VARIABLES BEFORE RELEASING
	CALL AUXB20		;RET USER ACS
	OKINT
	JRST MRETN		;AND RETURN

AUXBL4:	ILDB 4,1		;SEND LOGIN STRING, CHAR AT A TIME
	CAIE 4,0		;STOP AT NULL
	CAIN 4," "		;OR SPACE
	 RET
	CAIE 4,15		;CARRIAGE RETURN
	CAIN 4,";"		;OR ";"
	 RET			;WE TERMINATE LINE TO SUP, NOT USER
	MOVEI 3,TYPAXC		;SEND AUX LOGIN CHAR
	CALL OTYPES
	 CALL OFULLR		;(FULL ORING)
	JRST AUXBL4

AUXB20:	UMOVEM 11,1		;RET USER ACS
	UMOVEM 12,2
	UMOVEM 13,3
	RET

; WAIT FOR SUPERVISOR RESPONSE

AUXBL6: MOVE 1,TODCLK		;SET UP TIMER
	ADDI 1,AUXPRD		;FOR ONE MINUTE
	MOVEM 1,AUXCLK(2)

	HRRI 1,AUXRT		;WAIT FOR RESPONSE
	HRL 1,2			;ON THIS AUX IDENT
	JSYS EDISMS
	MOVE 3,AUXCLK(2)	;SAVE CLOCK INCASE NEEDED
	SETZM AUXCLK(2)		;CLEAR REAL CLOCK

	LDB 1,AUXSVC		;GET REASON FOR WAIT STOP
	CAIL 1,1		;GOT CLOBBERED SOME HOW?
	CAILE 1,5		;RANGE CHECK
	 MOVEI 1,1		;YES-HANDLE SAME AS NEW SUPER
	CAIE 1,3		;SKIP RET?
	CAIN 1,4		;OR SUPER ERROR NO SKIP RET?
	 CAIA
	SUB P,BHC+1		;NO-POP OFF CALLER OF THIS ROUTINE
	JRST .(1)

;AUXRT WAKEUP DISPATCH

	JRST   [SETZM AUXINF(2)	;1 - NEW SUPER
		OKINT		;ACCEPT INTERRUPTS
	 	JRST AUXBL0]	;TRY AGAIN
	JRST   [SETZM AUXINF(2)	;2 - TIMER EXPIRED
		MOVEI 1,TYMXX2
		JRST AUXBL8]
	JRST SKPRET		;3 - CONTINUE PROCESS
	RET			;4 - SUPERVISOR ERROR
	JRST AUXINT		;5 - PSI INTERRUPT

;END OF DISPATCH


; WAIT FOR SUPERVISOR RESPONSE TEST ROUTINE

	RESCD
AUXRT:	MOVE 2,1		;SET UP IDENT NUMBER 

	MOVEI 3,1
	LDB 1,AUXSVC		;CHECK SUPERVISOR TAKEOVER COUNT
	CAME 1,TYMSVC		;SUPERVISOR TAKE OVER LATELY?
	 JRST AUXRT1

	LDB 1,AUXSTS		;GET STATE CODE
	MOVEI 3,3
	CAIE 1,AUXSGR		;GRANTED STATE
	CAIN 1,AUXBLT		;OR GOT LINE STATE
	 JRST AUXRT1		;CONTINUE
	MOVEI 3,4
	CAIN 1,AUXRTY		;SUPERVISOR ERROR
	 JRST AUXRT1
	
	MOVEI 3,2
	MOVE 1,AUXCLK(2)	;TIME EXPIRED?
	CAMG 1,TODCLK
	 JRST AUXRT1

	SKIPN FKINT(7)		;INTERRUPT PENDING?
	 JRST 0(4)		;NO, WAIT
	MOVEI 3,5
	
AUXRT1:	DPB 3,AUXSVC		;PASS ACTION TO TAKE, BACK TO PROGRAM
	JRST 1(4)

; PSI INTERRUPT PENDING, ABORT PROCESS AND RETRY

;AUX CLOCK IN 3 TO BE USED IN AX2CLK FOR CONTINUED CLEANUP TIMEOUT
;IF ENTER PSI STATE THAT WAITS FOR MESSAGE FROM SUP TO CLEAN UP, USE 3
;IF ENTER PSI STATE WHERE WE SEND OUT A MESSAGE TO SUP, USE FULL AUXPRD

AUXINT:	NOSKED			;WE WERE PSI INTERRUPTED, FREEZE THINGS 
	LDB 1,AUXSTS		;WHILE WE LOOK, GET ID STATE
	CAIN 1,AUXRTY		;RECVD SUPER ERROR?
	 JRST AUXIN2		;IF SO, ACCEPT INTERUPT
	CAIN 1,AUXREQ		;STILL AWAITING 1ST SUPER RESP?
	 JRST  [MOVEI 1,AUXPS2	;SET ID INTO FIRST FLUSH STATE, AND ACCEPT
		MOVEM 3,AX2CLK(2)	;STILL TO TIME OUT
		JRST AUXIN1]
	CAIN 1,AUXSGR		;RECVD 1ST SUPER RESP
	 JRST  [MOVEI 1,AUXPS3	;;YES,SET INTO SECOND FLUSH STATE
		DPB 1,AUXSTS
		OKSKED
		MOVEI 3,TYPSUP	;AND SEND 2ND REQUEST W/O LOGIN STRING
		CALL OTYPES	;TO FORCE ERROR
		 CALL OFULLR
		MOVE 1,TODCLK	;SET UP TIMER
		ADDI 1,AUXPRD	;FOR ONE MINUTE
		MOVEM 1,AX2CLK(2) ;PUT A TIMER ON THIS MESSAGE TOO
		JRST AUXIN3]	;THEN ACCEPT INT
	CAIN 1,AUXSGN		;AWAITING 2ND SUPER RESP?
	 JRST  [MOVEM 3,AX2CLK(2)	;STILL TO TIME OUT
		MOVEI 1,AUXPS3	;YES, SET INTO SECOND FLUSH STATE, AND ACCEPT
		JRST AUXIN1]
	CAIN 1,AUXLGR		;GOT LOG IN
	 JRST  [MOVEI 1,AUXPS4	;SET INTO 3RD FLUSH STATE
		DPB 1,AUXSTS
		LDB 2,AUXLIN
		CAIL 2,TYMTTL	;AND IF WE GOT A LINE
		CAIL 2,TYMTTL+NTYMTT
		 JRST AUXIN2
		SKIPL TYMLNS(LINE) ;CONNECTED?
		 JRST AUXIN2	;NO, ALREADY ZAPPED
		HLRZ 4,TENTYM(LINE) ;GET THE PORT
		CALL TYDISC	;DISCONNECT THE PORT FROM US
		MOVEI 3,CONFRE	;FREE UP THE STATE
		DPB 3,CONSTS
		HRROS TTFORK(LINE) ;FINISH DISCONNECT
		hrrzs	ttype(2)	;clear XON XOFF STUFF
		OKSKED
		MOVE 2,4	;HAVE TO ZAP LINE THIS FUNNY WAY REMAIN 
		MOVEI 3,TYPZAP	;OKSKED WHILE CALLING OTYPES YET PREVENTING
		CALL OTYPES	;ASYNCHRONOUS ZAPS FROM TYMNET FROM SCREWING
		 CALL OFULLR	;THINGS UP
		MOVE 1,TODCLK	;SET UP TIMER
		ADDI 1,AUXPRD	;FOR ONE MINUTE
		MOVEM 1,AX2CLK(2) ;PUT A TIMER ON THIS MESSAGE TOO
		JRST AUXIN3]	;AND ACCEPT INTERRUPT
	CAIN 1,AUXBLT		;IF WE HAVE A LINE BY NOW
	 JRST  [OKSKED		;CONTINUE DEFERR INTERRUPT TIL THROUGH
		JRST AUXB10]
	SETZB 1,AUXINF(2)	;WE SHOULDN'T GET HERE, BUT IF WE DO,
				;RELEASE THE WHOLE DAMN THING
AUXIN1:	DPB 1,AUXSTS
AUXIN2:	OKSKED
AUXIN3:	OKINT			;PSI INTERRUPT, ACCEPT INTERRUPT
 	JRST AUXBL0		;AND IF WE GET BACK, TRY AGAIN


;0TH SLOT OF SYSNDX IS NOT USED!!!
;ALLOWS FOR NEGATIVE SPEC OF SYSNDX INSTEAD OF JOB #

;SET SYSNDX ENTRY
;ACCEPTS 1/ OPTION BITS,11,,0
;	 2/ SYSNDX
;	 3/ JOB #

;OPTION BITS :1B0 - JOB # IN 3

;RETURNS: +1  ERROR, 1/ ERROR CODE
;	  +2  ENTERED

	SWAPCD

SETSYS:	MOVE 4,1			;GET USER ACS
	MOVE 5,2
	MOVE 6,3
	MOVE 1,CAPENB			;CAN DO?
	TRNN 1,WHEEL!OPER
	 RETERR (TYMX10)		;INSUFF CAPS
	MOVE 1,5			;GET SYSNDX
	CALL SYSXCK			;CHECK ON IT (CHK FREE NOSKED)
	 RETERR (TYMX12)		;ILLEGAL
	TLNN 4,(1B0)			;SPECIFYING JOB #?
	MOVE 6,JOBNO			;GET DEFAULT JOB #
	CAIL 6,0			;LEGAL JOB?
	CAILE 6,NJOBS-1
	 RETERR (TYMX11)		;NO

	NOSKED				;PLAY SAFE

	MOVE 1,SYSNDX(5)		;GET CURRENT ENTRY
	CAME 1,MINUS1			;FREE?
	 RETERR (TYMX13,<OKSKED>)	;NO-MUST BE TO CLOBBER IT
	MOVEM 6,SYSNDX(5)		;STORE JOB #

	OKSKED

	JRST SKMRTN			;SUCCESS RETURN



;CLEAR SYSNDX ENTRY
;ACCEPTS 1/ OPTION BITS,12,,0
;	 2/ SYSNDX

;OPTION BITS:

;RETURNS: +1  ERROR, 1/ ERROR CODE
;	  +2  CLEARED , 1/ PREVIOUS CONTENTS JUST CLOBBERED

CLRSYS:	MOVE 4,1			;SAVE USER ACS
	MOVE 5,2
	MOVE 1,CAPENB
	TRNN 1,WHEEL!OPER
	 RETERR (TYMX10)
	MOVE 1,5
	CALL SYSXCK
	 RETERR (TYMX12)
	SETOM SYSNDX(1)
	UMOVEM 2,1			;RET PREVIOUS CONTENTS IN 1
	JRST SKMRTN			;SUCCESS RETURN


;GET SYSNDX ENTRY
;ACCEPTS 1/ OPTION BITS,13,,0
;	 2/ SYSNDX

;OPTION BITS:

;RETURNS: +1  ERROR, 1/ ERROR CODE
;	  +2  1/ CONTENTS, -1 IF FREE

GETSYS:	MOVE 4,1			;GET USER ACS
	MOVE 5,2
	MOVE 1,5			;GET SYSNDX IN 1
	CALL SYSXCK			;CHECK IT
	 RETERR (TYMX12)
	UMOVEM 2,1
	JRST SKMRTN			;SUCCESS RETURN

;CHECK ON SYSNDX AND RETURN CONTENTS OF SLOT IF VALID
;ACCEPTS 1/ SYSNDX
;RETURNS +1 ILLEGAL SYSNDX
;	 +2 2/ CONTENTS OF SLOT

	RESCD

SYSXCK:	CAIL 1,1			;1ST VALID IS INDEX 1!!!
	CAILE 1,NSYSND
	 RET
	MOVE 2,SYSNDX(1)		;OK, GET IT
	JRST SKPRET


;QUEUE A TYMNET TTY FOR DJOB
;ACCEPTS 1/ OPTION BITS,6,,TTY DESIGNATOR
;	 2/ 0,USBITS,,0
;	 3/ 0,UDBITS,,<DJOB (OR SYSNDX # IF NEGATIVE)>
;
;OPTION BITS: NONE
;
;RETURNS +1 ERROR   1/ ERROR CODE
;	 +2 OK, TTY QUEUED

	SWAPCD

QUEAUX:	MOVE 4,1			;GET ACS 1-3 INTO 4-6
	MOVE 5,2
	MOVE 6,3
	TLZ 5,777000			;CLEAR EBITS FROM USER WORDS
	TLZ 6,777000
	HRRZI 2,-400000(4)		;GET LINE #
	CAIL 2,TYMTTL			;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMX15)
	CALL TYMAUX			;ASSOCIATED WITH AUX CIRCUIT?
	 RETERR (TYMX23)		;NO

	NOSKED				;FOR QUEUE HANDLING AND DELICATE STUFF

	LDB 1,CONSTS			;GET CONNECTION STATE
	CAIE 1,CONAUX			;MUST BE IN COMPLETED CONNECTED STATE
	CAIN 1,CONCTL
	 CAIA
	RETERR (TYMX15,<OKSKED>)	;AINT
	MOVE 1,AUXDJQ(2)		;CHECK THAT LINE NOT QUEUED YET
	CAME 1,MINUS1			;IS IT?
	RETERR (TYMX15,<OKSKED>)	;HOW DID THIS HAPPEN?
	HRRE 2,6			;GET DJOB OR NEG SYSNDX
	JUMPGE 2,QUEAU1			;JUMP IF DJOB
	MOVN 1,2			;MAKE SYSNDX
	CALL SYSXCK			;RANGE CHECK SYSNDX
	 RETERR (TYMX12,<OKSKED>)	;BAD RANGE
	JUMPL 2,[RETERR (TYMX14,<OKSKED>)] ;IS FREE
	HRR 6,2				;REPLACE SYSNDX WITH JOB #
	TLO 6,(1B0)			;AND REMEMBER WE OBTAINED IT FROM THERE
QUEAU1:	CAIL 2,0			;RANGE CHECK DJOB IN 2
	CAILE 2,NJOBS-1
	 RETERR (TYMX11,<OKSKED>)	;BAD DJOB
	HRRZ 1,JOBDIR(2)		;LOGGED IN?
	JUMPE 1,[RETERR (TYMX11,<OKSKED>)] ;NO-ILLEGAL
	JRST QUEAU2			;ALL CHECKS MADE IT, DO WORK


;ALL CHECKS PERFORMED AND BLESSED IF HERE, STILL NOSKED!!! (HURRY UP)

QUEAU2:	HRRZI 2,-400000(4)			;GET LINE #
	MOVEM 6,AUXDJQ(2)		;ENTER DESTIN JOBATION QUE
	HRR 5,JOBNO			;ENTER SOURCE JOB #
	MOVEM 5,AUXSJQ(2)		;ENTER SOURCE JOB QUE
	CALL GIVAUX			;NOW DIDDLE TERMINAL OWNERSHIP
	MOVE 1,TODCLK			;AND SET ALARM CLOCK
	ADDI 1,AUXTIM			;TO THIS VALUE
	MOVEM 1,AUXTMQ(2)		;WHEN TO TIMEOUT

	OKSKED				;ITS SAFE NOW

	UMOVEM 4,1			;UPDATE USER ACS
	UMOVEM 5,2			;SO THEY CAN SEE WHAT
	UMOVEM 6,3			;WE DID FOR THEM
	JRST SKMRTN			;SUCCESS RETURN


;CALLED NOSKED!!!
;EXECUTED BY JOB GIVING AWAY AUXTTY TO AUXQUE STUFF
;ACCEPTS 2/ LINE # (MUST BE LEGAL TTY UNIT #)

	RESCD

GIVAUX:	PUSH P,1			;SAVE SCRATCH ACS
	PUSH P,2
	PUSH P,3
	MOVEI 1,QMAGCN			;TTFORK GETS QMAGCN LH FOR QUEUED
	HRLM 1,TTFORK(2)
	CALL AUXDEV			;GET DEV # IN RH 1
	MOVEI 3,QMAGCN			;THE QUEUE MAGIC #
	HRLM 3,DEVUNT(1)		;SO NOBODY CAN ASND IT
	MOVSI 3,(1B6)			;AND SAY ASSIGNED IN CHR WRD
	IORM 3,DEVCHR(1)
	POP P,3				;RESTORE SCRATCH ACS
	POP P,2
	POP P,1
	RET



;CALLED NOSKED!!!
;EXECUTED BY JOB TAKING AUXTTY FROM AUXQUE STUFF
;ACCEPTS 2/ LINE # (MUST BE LEGAL TTY UNIT #)

TAKAUX:	PUSH P,1			;SAVE SCRATCH ACS
	PUSH P,2
	PUSH P,3
	HLRZ 1,TTFORK(2)		;GET OWNING JOB
	CAIE 1,QMAGCN			;QUEUED FOR US?
	 CALL AUXBDQ			;SHOULDN'T HAPPEN
	CALL AUXDEV			;GET DEV # IN RH 1
	HLRZ 3,DEVUNT(1)		;GET ASSIGNED STATE
	CAIE 3,QMAGCN			;QUEUED FOR US?
	 CALL AUXBDQ			;SHOULDN'T HAPPEN
	MOVE 3,JOBNO			;MAKE US THE OWNER NOW
	HRLM 3,DEVUNT(1)		;1B6 STILL ON IN DEVCHR(1)
	HRLM 3,TTFORK(2)		;OWNER IN TTFORK TOO
	POP P,3				;RESTORE SCRATCH ACS
	POP P,2
	POP P,1
	RET

AUXBDQ:	BUG(CHK,<INCONSISTENT QUEUE STATE, NOT QMAGCN>)
	RET


;ACCEPTS TTY UNIT # IN 2
;RETURNS DEVICE # IN RH 1 (REALLY AOBJN PTR IN 1)

AUXDEV:	PUSH P,2		;SAVE ACS
	PUSH P,3
	HRLI 2,12		;PUT TTY DEVICE TYPE IN LH 2
	MOVNI 1,NDEV
	HRLZS 1			;1/ -NDEV,,0 AOBJN PTR
AUXDE1:	HLLZ 3,DEVCHR(1)	;GET DEVICE TYPE IN LH 3
	TLZ 3,777000		;ONLY
	HRR 3,DEVUNT(1)		;AND UNIT # IN RH 3
	CAME 2,3		;RIGHT DEVICE AND UNIT #?
	 AOBJN 1,AUXDE1		;NO-LOOP TIL FOUND
	POP P,3			;RESTORE ACS
	POP P,2
	JUMPL 1,R		;RET IF FOUND
	BUG(HLT,<ILLEGAL TTY # IN AUXDEV>)

;DEQUEUE AUX CIRCUIT

;ACCEPTS: 1/ OPTION BITS,10,,AUXTTY
;	 2/ 0,<UDBITS OR 0>,,<DJOB (OR SYSNDX IF NEGATIVE)>
;	 3/ SJOB

;OPTION BITS:	1B1 - IGNORE RH 2 AND DEQUEUE ALL JOBS QUEUED BY SJOB
;		1B3 - SJOB IN 3 (WHEEL REQUIRED)
;		1B4 - AUXTTY IN 1 (IGNORE 2)

;NOTE:  UDBITS IN 2 WILL BE USED ONLY IF NON-0 (SINCE 0 COULD NEVER WIN AND)

;RETURNS:	+1 ERROR CODE IN 1
;		+2 ACTION COMPLETED, ACS 1,2,3 UPDATED

;DEQUEUE ONE JOB AT A TIME

	SWAPCD

DEQAUX:	MOVE 4,1			;COPY USER ACS
	MOVE 5,2
	MOVE 6,3
	MOVE 1,CAPENB
	TLNE 4,(1B3)			;WANT TO USE PRIVY BITS?
	TRNE 1,WHEEL!OPER		;AND CAN
	 CAIA
	RETERR (TYMX10)
	TLNN 4,(1B3)			;GONNA SPECIFY SJOB?
	HRRZ 6,JOBNO			;NO-USE THIS JOB
	TLNE 4,(1B4)			;AUXTTY SPECIFIED?
	 JRST DEQAUA			;YES-IGNORE STUFF IN 2
	TLNE 4,(1B1)			;NO-IGNORE RH 2?
	 JRST DEQAU2			;IGNORE
	HRRE 2,5			;GET DJOB OR SYSNDX
	JUMPGE 2,DEQAU1			;JUMPE IF DJOB
	MOVN 1,2			;MAKE TRUE INDEX
	CALL SYSXCK			;RANGE CHECK SYSNDX
	 RETERR (TYMX12)		;BAD RANGE
	JUMPL 2,[RETERR (TYMX14)]	;JUMP IF FREE SLOT
	HRR 5,2				;OK - REPLACE RH 2
DEQAU1:	CAIL 2,0			;RANGE CHECK DJOB IN 1
	CAILE 2,NJOBS-1
	 RETERR (TYMX11)
	TLNN 4,(1B3)			;SPECIFIED SJOB?
	 JRST DEQAU2			;NO
	HRRZ 1,6			;GET IT
	CAIL 1,0			;RANGE CHECK IT
	CAILE 1,NJOBS-1
	 RETERR (TYMX11)

DEQAU2:	NOSKED				;DO THE WORK SAFELY

	MOVE 1,[-NTYMTT,,DUXDJQ]	;SEARCH DJOB QUE FOR IT
	HRRZ 2,6			;SJOB (MIGHT BE US)
DEQAU3:	CALL JBINTB			;THERE?
	 RETERR (TYMX17,<OKSKED>)	;NO - ERROR
	MOVE 3,(1)			;YES-SJOB LOGGED OUT?
	TLNE 3,(1B0)
	 JRST DEQAU6			;YES-CAN'T TOUCH IT THEN
	TLNE 4,(1B1)			;OK - IGNORE ITS DJOB?
	 JRST DEQAU4			;YES
	HRRZS 3				;NO-MUST MATCH DJOB
	CAIE 3,(5)			;SAME? (LOOK OUT ON XTENDED KL)
	 JRST DEQAU6			;NO
DEQAU4:	TLNN 5,000777			;YES-USE UDBITS?
	 JRST DEQAU5			;NO - A HIT?
	MOVE 3,(1)			;YES-GET TEST WORD
	AND 3,5				;PLAY BITS GAME
	TLNN 3,000777			;A HIT?
	 JRST DEQAU6			;NO
DEQAU5:	HRRZ 2,1			;2/ AUXDJQ+LINE #
	SUBI 2,AUXDJQ			;2/ LINE #
	HRRI 4,400000(2)		;PUT INTO USER ACS AS DEVICE
	SETOM AUXDJQ(2)			;CLEAR DJOB QUE
	SETOM AUXSJQ(2)			;AND SJOB QUE
	SETOM AUXTMQ(2)			;AND ALARM CLOCK
	HLRZ 3,TTFORK(2)		;GET WHO TERMINAL BELONGS TO
	CAIE 3,QMAGCN			;QUEUE MAGIC NUMBER?
	 CALL AUXBDQ			;NO-HESITATE
	HRROS TTFORK(2)			;OK, CLEAR IT
	CALL AUXDEV			;GET DEV # IN RH 1
	HLRZ 3,DEVUNT(1)		;GET OWNER
	CAIE 3,QMAGCN			;QUEUE MAGIC NUMBER?
	 CALL AUXBDQ			;NO-HESITATE
	HRROS DEVUNT(1)			;OK, CLEAR IT
	MOVSI 3,(1B6)			;AND CLEAR BIT IN CHARACTERISTICS
	ANDCAM 3,DEVCHR(1)

	OKSKED

	CALL TYHNGU			;INIT HANG UP LINE SEQ
	UMOVEM 4,1			;UPDATE USER ACS
	UMOVEM 5,2
	UMOVEM 6,3
	JRST SKMRTN			;SUCCESS RETURN

DEQAU6:	AOBJN 1,DEQAU3			;STEP AOBJN FOR JBINTB ROUTINE
	RETERR (TYMX17,<OKSKED>)	;FAILED TO FIND IT


;AUXTTY IN 1, CAPS OK, SJOB DEFINED

DEQAUA:	HRRZI 2,-400000(4)		;GET LINE #
	CAIL 2,TYMTTL			;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMX15)
	CALL TYMAUX			;ASSOCIATED WITH AUX CIRCUIT?
	 RETERR (TYMX23)			;NO

	NOSKED				;DO THE WORK

	LDB 1,CONSTS			;CHECK STS OF CONNECTION
	CAIE 1,CONAUX			;CONNECT STATE OK?
	CAIN 1,CONCTL
	 CAIA				;YES
	RETERR (TYMX15,<OKSKED>)	;NO
	MOVE 1,AUXDJQ(2)		;QUEUED?
	CAMN 1,MINUS1
	 RETERR (TYMX15,<OKSKED>)	;NO
	MOVE 1,CAPENB			;GET CAPS ENABLED
	TRNE 1,WHEEL!OPER		;SKIP SOURCE JOB CHECK IF GOD
	 JRST DEQA1A			;NO CHECKING
	MOVE 1,AUXSJQ(2)		;GET SJOB
	TLNE 1,(1B0)			;LOGGED OUT?
	 RETERR (TYMX11,<OKSKED>)	;YES-CAN'T TOUCH
	HRRZ 1,AUXSJQ(2)		;GET SJOB
	CAIE 1,(6)			;QUEUED BY THIS JOB?
	 RETERR (TYMX16,<OKSKED>)	;NO
DEQA1A:	MOVEI 1,AUXDJQ(2)		;PT AT DJOB QUE SLOT
	JRST DEQAU5			;JOIN CODE TO COBBER AUX CIRCUIT


;CLAIM AUXTTY QUEUED FOR US BY SOMEONE ELSE WHEN AND OF UDBITS NON-0
;ACCEPTS 1/ OPTION BITS,7,,0
;	 2/ 0,<UDBITS OR 0>,,<DJOB (OR SYSNDX IF NEG) IF OPTION BIT 1B1 ON>

;OPTION BITS:	1B1 - DJOB (OR SYSNDX IF NEG) IN RH 2 (WHEEL REQUIRED)
;		1B3 - LISTEN IF NO JOBS FOUND

;NOTE:  1B1 OFF => (RH 2 <= JOBNO)
;NOTE:  UDBITS IN 2 WILL BE USED ONLY IF NON-0 (SINCE 0 COULD NEVER WIN AND)

;RETURNS +1 ERROR, ERROR CODE IN 1
;	 +2 OK - UPDATED ACS IN 1,2,3 (3 GETS SJOB STUFF)

	SWAPCD

CLMAUX:	MOVE 4,1			;COPY USER ACS
	MOVE 5,2
	SETZ 6,				;GONNA GET SJOB STUFF
	MOVE 1,CAPENB
	TLNE 4,(1B1)			;WANTS TO USE PRIVY BITS?
	TRNE 1,WHEEL!OPER		;AND CAN?
	 CAIA				;YES
	RETERR (TYMX10)			;NOT ENOUGH CAPS
	TLNN 4,(1B1)			;GONNA SPECIFY DJOB?
	HRR 5,JOBNO			;NO-GET THIS JOB THEN
	HRRE 2,5			;YES-GET DJOB OR NEG SYSNDX
	JUMPGE 2,CLMAU1			;JUMP IF DJOB
	MOVN 1,2			;MAKE TRUE SYSNDX #
	CALL SYSXCK			;RANGE CHECK SYSNDX
	 RETERR (TYMX12)		;BAD RANGE
	JUMPL 2,[RETERR (TYMX14)]	;JUMP IF FREE SLOT
	HRR 5,2				;OK-REPLACE DJOB WITH THIS JOB
CLMAU1:	CAIL 2,0			;RANGE CHECK DJOB IN 2
	CAILE 2,NJOBS-1
	 RETERR (TYMX11)		;LOSE

CLMAU0:	NOSKED				;DO THE WORK

	MOVE 1,[-NTYMTT,,DUXDJQ]	;SCAN FOR DJOB
CLMAU2:	HRRZ 2,5			;DJOB IN 2
	CALL JBINTB			;THERE?
	 JRST CLMAU4			;NOT FOUND
	MOVE 3,(1)			;HIT, GET ENTRY
	AND 3,5				;AND BITS
	TLNE 5,000777			;USER SPECIFIED UBITS?
	TLNE 3,000777			;YES-NON-0 AND?
	 CAIA				;NOT SPECIFIED OR NON-0 AND
	  JRST CLMAU3			;NO HIT-LOOP TIL FOUND
	HRRZ 2,1			;HIT-MAKE 2/ AUXDJQ+LINE #
	SUBI 2,AUXDJQ			;2/ LINE #
	CALL TAKAUX			;GRAB IT
	HRRI 4,400000(2)		;GIVE USER AUXTTY ANSWER
	MOVE 5,AUXDJQ(2)		;GIVE USER DJOB STUFF
	SETOM AUXDJQ(2)			;AND DJOB STUFF
	MOVE 6,AUXSJQ(2)		;GIVE SJOB STUFF TO USER
	SETOM AUXSJQ(2)			;AND CLEAR THAT ENTRY
	SETOM AUXTMQ(2)			;CLOBBER UNEXPIRED ALARMCLOCK
	SETOM AUXCTL(2)			;CLEAR THIS JUST FOR KICKS TOO

	OKSKED

	UMOVEM 4,1			;RETURN ACS 1,2,3
	UMOVEM 5,2
	UMOVEM 6,3
	JRST SKMRTN			;SUCCESS RETURN

CLMAU3:	AOBJN 1,CLMAU2			;STEP AOBJN FOR JBINTB ROUTINE
	JRST CLMAU4

;HERE IF NO QUEUED JOBS FOUND - POSSIBLY WANT TO LISTEN

CLMAU4:	OKSKED
	TLNN 4,(1B3)			;LISTEN?
	 RETERR (TYMX17)		;NO-NO JOBS QUEUED ERROR
	MOVE 1,5			;CREATE JOB,UBITS,,ADR
	MOVE 2,[POINT ^D9,1,8]		;POINT AT HI 9 BITS IN AC 1
	DPB 1,2				;SHUFFLE JOB (9 BIT RESTRICTION)
	HRRI 1,AUXLSN			;WAIT TEST
	JSYS EDISMS
	JRST CLMAU0			;GO NOSKED AND CHECK IT OUT

;SCHED TEST FOR ABOVE LISTENING

	RESCD

AUXLSN:	HRRZ 2,1			;1/ 0,,JOB#,UBITS
	LSH 2,-^D9			;2/ JOB #
	HRLZ 5,1
	TLZ 5,777000			;5/ UBITS,,0
	MOVE 1,[-NTYMTT,,DUXDJQ]	;SCAN DJOB TABLE USING DBITS
AUXLS1:	CALL JBINTB			;IS IT THERE?
	 JRST 0(4)			;NOT FOUND
	JUMPE 5,1(4)			;WAKE UP IF NOT USING UBITS, FOUND JOB
	MOVE 3,5			;CHECK THE BITS
	AND 3,(1)			;DESTRUCTIVE TEST
	CAIE 3,0			;SKIP IF NO HIT
	 JRST 1(4)			;WAKE UP - FOUND ONE
	AOBJN 1,AUXLS1			;STEP AOBJN FOR JBINTB ROUTINE
	JRST 0(4)			;NOT FOUND



	SUBTTL	CONTROL MESSAGE HANDLING

; HANDLE INPUT CONTROL MESSAGES THAT ARE MASKED ON FOR A GIVEN LINE

	RESCD

RCVSMI:	LDB 1,TTIMAX		;DO WE HAVE ENOUGH SPACE?
	SUBI 1,3		;IT TAKES 3 BYTES TO STORE A SPECIAL MSG
	LDB 4,TTNIN		;ALREADY HAVE BUFFERS?
	SKIPN TTIIN(2)		;ALREADY HAVE BUFFERS?
	 CAMG 4,TTFREC		;NO, ENOUGH FREE?
	CAMG 1,TTICT(2)		;YES, ENOUGH ROOM IN BUFFERS
	 AOJA IPTR,TYMIN1	;NO, SKIP THE MESSAGE
	MOVEI 1,1000(3)		;1000 BIT SAYS THIS IS A CONTROL MESSAGE
	PUSH P,TTMOD1(2)	;SAVE TERMINAL DATA MODE
	SETZ 3,
	DPB 3,TTYLMD		;FAKE BINARY MODE TO FORCE WAKE UP
	CALL TTRNE		;PUT BALL IN BUFFER AND WAKE UP FORK
	LDB 1,PISUBT		;GET SUBTYPE
	CALL TTRNE
	LDB 1,PIDATA
	CALL TTRNE
	POP P,TTMOD1(2)		;RESTORE TERMINAL DATA MODE
	AOJA IPTR,TYMIN1	;RETURN TO INPUT STREAM

; CALLED FROM TCI TO HANDLE INPUT CONTROL MESSAGE INTERRUPTS

	SWAPCD

RCVCMP:	CAIL 2,TYMTTL
	CAIL 2,TYMTTL+NTYMTT
	 BUG (HLT,<TYMSRV: TYMNET DEFERRED BALL CODE ON NON TYMNET LINE>)
	DPB 1,CMCOD		;SAVE MESSAGE CODE
	CALL TCI0		;GET SUBTYPE DATA
	DPB 1,CMSBT
	CALL TCI0		;GET DATA TYPE
	DPB 1,CMDAT

	HRRZ 3,TYMCMI(2)	;GET TERMINAL CODE FOR INTERRUPT
	SKIPN 3
	 MOVEI 3,^D35		;DEFAULT
	CALL TYDPSI		;GIVE DEFERRED PSI INTERRUPT
	JRST TCI

;ACCEPTS 1/ BALL MASK (LIMITED TO 36 BITS FOR NOW)

;ALWAYS CHECKS ONLY 0TH WORD OF MASK (FOR NOW)

CHKRCM:	SETZ 4,			;FOR RECEIVE CHECK, SUBTYPE ALWAYS OK
	PUSH P,[0]		;CHECK RECEIVE CONTROL MESSAGE MASK
	JRST .+2
CHKSCM:	PUSH P,[1]		;CHECK SEND CONTROL MESSAGE MASK
	EXCH 3,(P)
	PUSH P,4
	MOVE 4,CAPENB
	TRNE 4,WHEEL!OPER
	 ADDI 3,2
	POP P,4
	TDNE 1,CMMSK0(3) 	;CHECK APPROPRIATE MASK
	 RETERR (TYMXX6)	;ILLEGAL BIT ON
	POP P,3
	TRNE 1,1B<36>+1B<37>+1B<40> ;TERM CHARACTERISTIC CODE?
	CAIG 4,MXTRMC		;YES, IS SUBTYPE LEGAL?
	 RET			;NO, DON'T CHECK SUBTYPE
	RETERR (TYMXX6)		;NO

GETCMD:	HRRZ JFN,1		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	MOVE 1,TYMCMR(2)
	UMOVEM 1,2
	JRST SKMRTN

SNDCMD:	HRRZ JFN,1		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	UMOVE 1,2		;GET CONTROL MESSAGE
	LDB 3,[POINT 8,1,7]	;GET CODE
	LDB 4,[POINT 8,1,15]	;GET SUBTYPE 
	LDB 5,[POINT 8,1,23]
	MOVE 1,BITS(3)		;CHANGE TO MASK
	CALL CHKSCM		;CHECK SEND CONTROL MESSAGE MASK
SNDCM3:	NOSKED			;NO ONE ELSE TO RUN WHILE WE CHECK BUFFS
	LDB 6,TTNOU		;GET NUMBER OF BUFFERS NEEDED
	LDB 1,TTOMAX		;GET NUMBER OF CHARS IN BUFFS
	SUBI 1,3		;WE WILL NEED SPACE FOR 3 CHARS
	SKIPN TTOIN(2)		;ANY BUFFERS ALREADY?
	 CAMG 6,TTFREC		;NO, ENOUGH FREE BUFFERS?
	CAMG 1,TTOCT(2)		;YES, ENOUGH SPACE IN BUFFERS?
	 JRST  [OKSKED		;NO, WAIT FOR THE ABOVE CONDITIONS TO HAPPEN
		MOVEI 1,SNDCMT
		HRLI 1,(2)
		JSYS EDISMS
		JRST SNDCM3]
				;NOW THAT WE ARE SURE WE WONT GET A BUFFER
				;FULL CONDX ON OUTPUT AND ALL THREE BYTES
				;WILL GET INTO THE BUFFER
	MOVE 1,3		;REPOSITION THE CONTROL MESSAGE CODE
	TRO 1,1000		;1000 BIT SAYS CONTROL MESSAGE 
	CALL TCOBQ		;SEND THE C.M. CODE
	MOVE 1,4
	CALL TCOBQ		;SEND THE SUBTYPE
	MOVE 1,5
	CALL TCOBQ		;SEND THE DATA
	OKSKED
	JRST SKMRTN

	RESCD
SNDCMT:	MOVE 1,2
	LDB 1,TTOMAX		;GET CHAR COUNT IN OUTPUT BUFFER
	SUBI 1,3		;NEED AT LEAST 3 CHARS
	LDB 3,TTNOU		;GET NUMBER OF BUFFERS NEEDED
	SKIPN TTOIN(2)		;ANY BUFFERS?
	 CAMG 3,TTFREC		;NO ENOUGH FREE ONES?
	CAMG 1,TTOCT(2)		;ENOUGH FREE CHARS IN EXISTING BUFFERS?
	 JRST 0(4)		;NO, NO RUN
	JRST 1(4)		;YES, RUN

	SWAPCD

GETLNS:	HRRZI 2,-400000(1)	;GET LINE # IN 2
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	MOVE 1,TYNODS(2)		;RETURN LOGIN INFO
	UMOVEM 1,2
	MOVE 1,TYMLNS(2)		;AND LINE STATUS TO USER
	UMOVEM 1,3
	JRST SKMRTN

;SETIBP TURNS ON IBPOF FLAG BUT ALSO ALLOWS LINE TO HAVE SPECIAL NUMBER
;INPUT BUFFERS ON NEXT ASSIGNMENT OF THOSE BUFFERS TO ALLOW FOR
;IRING OVERRUN (PHASE LAG BETWEEN GETTING CHARS AND SENDING IBP MSG)

SETIBP:	HRRZ JFN,1		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	CALL TTBFSP		;FIX UP INPUT BUFFER STUFF
	MOVSI 1,IBPOF		;SET INPUT BACKPRESSURE FLAG
	IORM 1,TYMLNS(2)	;PUT IN LINE STATUS WORD
	JRST SKMRTN


GETINS:	HRRZ JFN,1		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	MOVE 1,TYMCMM(2)
	UMOVEM 1,2
	MOVE 1,TYMCMI(2)
	UMOVEM 1,3
	JRST SKMRTN

SETINS:	HRRZ JFN,1		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	UMOVE 1,2		;GET 36 BIT MASK (LIMITED TO THIS FOR NOW)
	CALL CHKRCM			;CHECK FOR ALLOWABLE RECEIVE BITS
	UMOVE 3,3
	CAIL 3,^D36			;LEGAL TERMINAL CODE?
	 ITERR (TERMX1)			;YES
	NOSKED
	MOVEM 1,TYMCMM(2)
	MOVEM 3,TYMCMI(2)
	OKSKED
	JRST SKMRTN

	SUBTTL login code from EXEC0
	SWAPCD

TYMX0:	NOSKED
	LDB 3,CONSTS		;get connection status
	TRNE 3,<INITF>B47	;already initialized?
	 JRST OKRET		;yes
	TRNN 3,<CONNF>B47	;line not connected?
	 JRST TYMX3
	MOVEI 3,CONLG2		;tell every one we're reading, a zap
	DPB 3,CONSTS		;now would hang us for ever
	OKSKED

	ADD P,BHC+BUFSIZ	;get buffer space
	JUMPGE P,MSTKOV
	MOVEI 7,-<BUFSIZ-1>(P)

	SETZM TYNODS(2)		;init TYNODS
	MOVEI 1,400000(2)
	CALL TYMX9		;get TYMNETS terminal type
	DPB B,NODTYP		;terminal type
	CALL TYMX9
	DPB B,NOD1		;first half of origin node number
	CALL TYMX9
	DPB B,NOD2		;second half
	CALL TYMX9		;port number at origin node
	DPB B,NODLIN		;port number at origin node

	MOVE C,[POINT 7,3(7)]	;set up to save TYMNET login name
	MOVSI D,-<<BUFSIZ-3>*5-1> ;max number of chars to read for buffersize

TYMX1:	CALL TYMX9		;get another byte
	ANDI B,177		;save only ascii
	SKIPGE D		;if buffer not full
	 IDPB B,C		;put byte in FACT entry
	CAIE B,";"		;name field finished? (";" or cr)
	CAIN B,15
	 AOJA D,TYMX2		;yes, count terminator
	AOBJN D,TYMX1		;no, count char
	JRST TYMX1		;count char if buffer is full

TYMX2:	TRNE D,1		;read in an even # bytes?

	 JFCL		;GOLTZ DIDN'T DO EVEN BYTE HACK RIGHT

	SETZ B,			;finish off name string
	DPB B,C			;with null terminator
	AOJL D,.+2		;filled buffer? (count terminating null)
	 MOVEI D,<BUFSIZ-3>*5	;yes, use full buffer size + null as count
	HRRZS D
	ADDI D,4		;round up to # words
	IDIVI D,5
	ADDI D,3		;add in first three words
	PUSH P,D		;save character count for later

TYMX4:	MOVEI 2,-400000(1)
	NOSKED
	LDB C,CONSTS		;get line connection state
	TRNN C,<CONNF>B47	;line already disconnected?
	 JRST  [MOVEI 3,CONFRE	;yes
		DPB 3,CONSTS	;don't give a disconnect message
		SUB P,BHC+BUFSIZ+1 ;restore stack
		JRST TYMX3]	;and let the exec autologout
	MOVEI 3,CONLG3		;ready to initialize, set state accordingly
	DPB 3,CONSTS
	OKSKED

	CALL TYMCTL		;SET UP AUXCTL BY TALKING H2H PROTOCOL
		
	POP P,B			;get size of efact block
	CALL INIMSG		;do connect message

;XFER LOGIN NAME TO AUXBLD NAME STORAGE IN JSB (ASCIZ STRING STORED)

	PUSH P,1			;SAVE LINE DESIGNATOR
	MOVE 1,[POINT 7,3(7)]	;THE TEMP BUFFER
	MOVE 2,[POINT 7,AUXNAM]	;JSB LOGIN NAME HOLDER
	MOVEI 3,<SAUXNA*5>-1	;# CHRS WE CAN SAVE
	SETZM AUXNAM		;INVALID TIL INITED
AUXNLP:	ILDB 4,1		;GET A CHR
	CAIN 4,174		;UNCHECKED NAME PREFIX?
	 JRST AUXNL2		;YES-DON'T INIT AUXNAM
	CAIE 4,";"		;TERMINATOR?
	CAIN 4,15
AUXNL1:	 SETZ 4,		;YES-REPLACE WITH NULL
	IDPB 4,2		;DEPOSIT CHR OR NULL
	JUMPE 4,AUXNL2		;QUIT ON NULL (FROM BUFFER OR TERM REPLACER)
	SOJG 3,AUXNLP
	JRST AUXNL1		;STORED ALL CHRS POSSIBLE, ADD NULL AND QUIT

AUXNL2:	POP P,1			;RESOTRE DESIGNATOR
	SUB P,BHC+BUFSIZ

	MOVE B,NORMTF
	LDB C,NODTYP		;get TYMNET terminal type
	TRNE C,40		;TYMNET says half-duplex?
	 TRO B,2B33		;YES-LINE HALF DUPLEX
	ANDI C,37		;get TYMNET terminal type 
	CAILE C,MXYTYP		;if out side table range use default
	 SKIPA C,DYTYPU		;GET UNKOWN DEFAULT TERMINAL TYPE
	MOVE C,DYTYP(C)		;xlate to our TE TYPE (FOR AUX CIRS TOO)

	STPAR			;set SFMOD word
	SFMOD
	MOVE B,C
	STTYP			;set type

	MOVEI 2,-400000(1)
	SETZM TTLPOS(2)		;RESET POSITIONS
	NOSKED
	LDB 3,CONSTS		;get connection state
	TRNN 3,<CONNF>B47	;got zapped while initializing?
	 JRST  [CALL CTLZAP
		MOVEI 1,400000(2) ;restore ac1 for the rest of EXEC0
		JRST OKRET]
	MOVEI 3,CONCTL		;else, we're in normally
	DPB 3,CONSTS
	OKSKED
	jrst tymx99			;go set up echo state

TYMX3:	OKSKED
	MOVEI 1,400000(2) ;no, probably an advise
	MOVE 2,NORMTF		;give standard modes
	STPAR
	SFMOD
	MOVE 2,TYPCRT
	STTYP
	MOVEI 2,-400000(1)
	SETZM TTLPOS(2)		;RESET POSITIONS

tymx99:	movsi 1,USECOF		;set up to force local echo
	hrrz 2,ctrltt		;make real sure we have a good line number
	cail 2,tymttl		;and that it's a tymnet line
	caile 2,tymtth		;else carefully
	ret			;do nothing!!
	iorm 1,tymlns(2)	;force host echo always
	movei 1,echof		;remote echo state flag
	jrst noeco		;go shut off for real if not already off

TYMX9:	SIBE			;ANY CHARS FOR THIS LINE
	 JRST TYMX91		;YES-EAT IT
	CALL TYMWTC		;WAIT TIL CHAR IS THERE
	JRST TYMX9		;TRY AGAIN

TYMX91:	BIN			;GET CHAR IN 2
	RET

;WAIT UNTIL A CHAR IS CHAR INPUT BUFFER FOR TTY DESIGNATOR IN 1
;IF LINE GETS DISCONNECTED FIRST, FALL INTO BLACK HOLE
;ONLY RETURNS IF CHAR READY TO BE EATEN FOR CONNECTED LINE


TYMWTC:	PUSH P,1
	HRLI 1,-400000(1)	;set up to dismiss until something read,
	HRRI 1,TYMXZT		;or line zapped
	JSYS EDISMS
	POP P,1
	SKIPGE TYMLNS-400000(1)	;line disconnected?
	 RET			;no, still connected, must be something there
TYMBYE:	SETO 1,
	LGOUT			;INITING JOB FALLS INTO BLACK HOLE
	 JFCL
	JRST TYMBYE

	RESCD

TYMXZT:	SKIPN TTICT(1)		;if buffer not empty
	SKIPL TYMLNS(1)		;or line zapped
	 JRST 1(4)		;continue
	JRST 0(4)		;else wait
	

	SWAPCD

INIMSG:	RET

TYFACT:	RET


;CALLED BY JOB LOGGING OUT AT HLTJB
;SCAN DEVICE TABLES LOOKING FOR TYMNET AUX TTY ASSIGNED TO JOBNO.
;DO AUXRLS FUNCTION OF TYMOP ON ALL FOUND

TYMRLA:	MOVNI 2,NDEV##
	HRLZS 2
	HRRZ 3,JOBNO
	HRLI 3,12		;3/ DEV BITS,,JOB NO
TYMRL1:	HLLZ 1,DEVCHR(2)	;GET TEST DEV BITS
	TLZ 1,777000		;JUST IMPORTANT BITS
	HLR 1,DEVUNT(2)		;ASSIGNING JOB IN RH
	CAME 1,3		;RIGHT DEV,,RIGHT JOB?
	 JRST TYMRL2		;NO
	HRRZ 1,DEVUNT(2)	;YES-GET TTY # IN 1
	CAIL 1,TYMTTL		;TYMNET RANGE CHECK
	CAILE 1,TYMTTH
	 JRST TYMRL2		;NOT
	PUSH P,2		;SAVE AOBJN PTR
	MOVE 2,1		;GET TTY # IN 2 FOR CONSTS
	LDB 1,CONSTS		;GET CONNECTION STATE
	POP P,2			;RESTORE AOBJN PTR
	TRNN 1,<AUXF>B47	;AUX CIRCUIT?
	 JRST TYMRL2		;NO
	HRRZ 1,DEVUNT(2)	;TTY #
	ADD 1,[14,,400000]	;MAKE FUNCTION,,DEVICE DESIGNATOR
	TYMOP			;RELEASE AUX CIRCUIT
	 JFCL
TYMRL2:	AOBJN 2,TYMRL1		;LOOP FOR ALL DEVICES
	RET

;CALLED BY JOB LOGGING OUT AT PROCESS LEVEL.
;CLEANS UP AUXQUE TABLES FOR THAT JOB.

;ACTION:
;IF JOB FOUND IN SYSNDX TABLE:
;	CLEAR ENTRY IN SYSNDX TABLE
;IF JOB FOUND IN AUXDJQ:
;	CLEAR ENTRY IN AUXDJQ
;	CLEAR CORRESPONDING ENTRY IN AUXSJQ
;	CLEAR CORRESPONDING ENTRY IN AUXTMQ
;	ZAP CORRESPONDING AUX CIRCUITS
;IF JOB FOUND IN AUXSJQ:
;	SET "LOCAL JOB LOGGED OUT" BIT IN ENTRY IN AUXSJQ

	SWAPCD

LGOAUX:	PUSH P,1
	PUSH P,2
	PUSH P,3			;SAVE ALL ACS CLOBBERED

	NOSKED				;SAFE WHILE MANIPULATING

	MOVE 1,[-NSYSND,,SYSNDX]	;WORK ON SYSNDX TABLE
	MOVE 2,JOBNO			;THE JOB NUM
LGOAU1:	CALL JBINTB			;JOBNO IN TABLE?
	 JRST LGOAU2			;NO-DONE WITH TABLE
	SETOM (1)			;CLEAR THIS SLOT
	AOBJN 1,LGOAU1			;LOOP, STEP AOBJN IN 1
					;POSSIBLY FALL THROUGH

LGOAU2:	MOVE 1,[-NTYMTT,,DUXDJQ]	;WORK ON AUXDJQ TABLE
LGOAU3:	MOVE 2,JOBNO			;THE JOB NUM
	CALL JBINTB			;IN TABLE?
	 JRST LGOAU4			;NO-DONE WITH DUXDJQ
	HRRZ 2,1			;2/ AUXDJQ+LINE #
	SUBI 2,AUXDJQ			;2/ LINE #
	SETOM AUXDJQ(2)			;CLEAR DJOB STUFF
	SETOM AUXSJQ(2)			;AND SJOB STUFF
	SETOM AUXTMQ(2)			;AND TIMER STUFF
	SETOM AUXCTL(2)			;AND THIS FOR KICKS TOO
	PUSH P,1			;SAVE STUFF WE CARE ABOUT
	CALL TYHNGU			;INIT AUX CIRCUIT HANGUP SEQ
	POP P,1
	AOBJN 1,LGOAU3			;LOOP. STEP AOBJN IN 1
					;POSSIBLY FALL THROUGH

LGOAU4:	MOVE 1,[-NTYMTT,,DUXSJQ]	;NOW WORK ON DUXSJQ
	MOVE 2,JOBNO			;THE JOB NUM
	MOVSI 3,(1B0)			;THE SOURCE JOB LOGGED OUT BIT
LGOAU5:	CALL JBINTB			;IN TABLE?
	 JRST LGOAU6			;NO-DONE WITH TABLE
	IORM 3,(1)			;YES-SAY SOURCE JOB LOGGED OUT
	AOBJN 1,LGOAU5			;LOOP, STEP AOBJN IN 1
					;POSSIBLY FALL THROUGH
LGOAU6:	OKSKED
	POP P,3				;RESTORE ACS
	POP P,2
	POP P,1
	RET


;ACCEPTS 1/ AOBJN PTR TO TABLE
;	 2/ JOB NUM TO SEARCH FOR

;SKIPS IF JOB NUM FOUND WITH 1/ AOBJN PTR PTING TO SLOT
;NO SKIP IF NOT FOUND, EXHAUSTED AOBJN PTR IN 1

	RESCD

JBINTB:	PUSH P,2		;CLOBBER ONLY AC 1
JBINT1:	HRRZ 2,(1)		;GET JOB NUM IN RH OF TABLE ENTRY
	CAMN 2,0(P)		;SAME AS WHAT WE ARE LOOKING FOR?
	 AOSA -1(P)		;SKIP RET WITH PTR IN 1
	AOBJN 1,JBINT1		;LOOP TIL EXHAUSTED OR FOUND
JBINT2:	POP P,2			;RESTORE 2
	RET


;AUXCTL ENTRY LOOKS LIKE:

;	!---------------------------------------!
;	!		-1			!	;FREE
;	!---------------------------------------!
;	!   F   !   D0   !   D1   !   D2   ! D3 !	;IN USE
;	!---------------------------------------!
;	!      7!      15!      23!      31!  35!	;BIT POSITIONS

;WHERE F IS THE FUNCTION CODE AND Dn ARE THE DATA

;CURRENTLY DEFINED FUNCTIONS:

;	EXEC:	F=0, DATA IS <DON'T CARE>
;	QUE:	F=1, DATA IS <UDBITS,,DJOB (OR SYSNDX IF NEGATIVE)>
;	EXCBLK:	F=2, DATA IS <DON'T CARE>
;	QUEBLK:	F=3, DATA IS <UDBITS,,DJOB (OR SYSNDX IF NEG)>
;

;UDBITS IS ONLY 9 BITS WIDE


;EVERYTHING COMES IN AS A STREAM OF 8 BIT BYTES IN HOST TO HOST PROTOCOL
;FORMAT (H2H):

;	200,F,D0,D1,D2,D3,200

;NOTE: ONLY THE HI 4 BITS OF D3 ARE RETAINED

;UTILITY POINTERS FOR MANIPULATING AUXCTL ENTRIES

	SWAPCD

AUXCTP:	POINT 8,AUXCTL-400000(1)	;IDPB STARTING WITH FUNCTION BYTE

AUXCTF:	POINT 8,AUXCTL-400000(1),7	;DPB FOR FUNCTION BYTE
AUXCT0:	POINT 8,AUXCTL-400000(1),15	;DPB FOR DATA BYTE 0
AUXCT1:	POINT 8,AUXCTL-400000(1),23	;DPB FOR DATA BYTE 1
AUXCT2:	POINT 8,AUXCTL-400000(1),31	;DPB FOR DATA BYTE 2
AUXCT3:	POINT 4,AUXCTL-400000(1),35	;DPB FOR DATA BYTE 3

AUXCFN:	POINT 8,AUXCTL(2),7		;LDB FOR FUNCTION CODE BYTE
AUXCDT:	POINT 24,AUXCTL(2),35		;LDB FOR DATA


;CALLED FROM TYMX0 (AT JOBINI TIME) TO DETERMINE IF TALKING HOST
;TO HOST PROTOCOL AND IF SO TO SUCK UP THE BYTE STREAM AND SET UP
;AUXCTL ENTRY FOR LINE FOR LATER USE
;ACCEPTS TTY DESIGNATOR IN 1, TERMINAL TYPE PTED AT BY NODTYP
;IT IS ASSUMED ONE CAN TELL THE DIFFERENCE BETWEEN NORMAL TERMINAL
;LINES AND AUX CIRCUIT LINES BY THE TERMINAL TYPE.  TYMNET DOC
;CLAIMS AUX CIRCUIT TERMINAL TYPE WILL BE 0.

TYMCTL:	PUSH P,1
	PUSH P,2
	PUSH P,3
	SETOM AUXCTL-400000(1)		;CLEAR OUT ENTRY
	LDB 2,NODTYP			;GET TERMINAL TYPE
	ANDI 2,37			;LOOK AT JUST INTERESTING BITS
	CAIE 2,0			;TYPE 0 IS AUX CIRCUIT ORIGIN
	CAIN 2,^D14			;GATEWAY AUX CIRCUIT IS 14.
	 CAIA
	  JRST TYMCT2			;ITS NORMAL TERMINAL, NO H2H
	MOVSI 2,IBPOF			;ENABLE IBP FOR AUX CIRCUIT LINES
	IORM 2,TYMLNS-400000(1)
	MOVEI 2,-400000(1)		;SIMPLE LINE # IN 2 FOR TTBFSP
	CALL TTBFSP			;FIX UP INPUT TTY BUFFER STUFF
	CALL TYMCTH			;CAREFULLY CHK H2H ON 1ST CHAR
	 JRST TYMCTX			;NO-UNEATEN CHAR IN 2
	CALL TYMX9			;YES-UNEATEN SO EAT IT
	CAIE 2,200			;THIS MUST BE 200 IF TYMX9 RETURNED
	 BUG(CHK,<INCONSISTENT 1ST H2H CHAR IN TYMCTL>)
	MOVEI 3,4			;OK - H2H - EAT THIS MANY IN LOOP
	MOVE 4,AUXCTP			;PT AT AUXCTL ENTRY
TYMCT1:	CALL TYMX9			;EAT A BYTE
	IDPB 2,4			;STORE IT
	SOJG 3,TYMCT1			;LOOP
	CALL TYMX9			;GET ONE MORE
	LSH 2,-4			;SLIDE IT DOWN TO GET HI BITS
	MOVE 4,AUXCT3			;PUT IT HERE
	DPB 2,4
	CALL TYMX9			;GET TERMINATOR BYTE NOW
	CAIE 2,200			;IS IT?
	 SETOM AUXCTL-400000(1)		;NO-MAKE BELIEVE NEVER DID IT
TYMCT2:	POP P,3
	POP P,2
	POP P,1
	RET

;HERE WITH UNEATEN CHAR IN 2 AND TTY DESIGNATOR IN 1
;1ST CHAR DETERMINED NOT TO BE 1ST OF H2H PROTOCOL
;IF IT IS A 177, EAT IT AND PASS ON THROUGH (USER GETTING AROUND H2H)
;OTHERWISE EAT NO CHARS AND PASS ON THRU

TYMCTX:	CAIN 2,177			;IS 1ST UNEATEN CHAR A RUBOUT?
	 CALL TYMX9			;YES-EAT IT AND PASS ON THROUGH
	SETOM AUXCTL-400000(1)		;INSURE THIS IS UNUSED (NO H2H)
	JRST TYMCT2			;PASS ON THROUGH WITH AUXCTL = UNUSED

;SKIP IF TALKING H2H
;NO SKIP IF NOT
;IN EITHER CASE EAT NO CHARS (JUST EXAMINE INPUT BUFFER)
;RETURNS 1ST UNEATEN CHAR IN 2
;ACCEPTS TTY DESIGNATOR IN 1

TYMCTH:	SIBE				;ANY CHARS?
	 JRST TYMC1H			;YES-CHECK IT OUT
	CALL TYMWTC			;NO-WAIT TIL THERE ARE
	JRST TYMCTH			;OK-NOT DISC, TRY AGAIN

TYMC1H:	MOVE 2,TTIOUT-400000(1)		;YES-GET INPUT OUTPUT PTR FOR LINE
	ILDB 2,2			;GET 1ST CHAR, DON'T ADVANCE REAL PTR
	ANDI 2,377			;LOOK AT JUST 8 BIT CHAR
	CAIN 2,200			;IS IT 1ST OF H2H PROTOCOL?
	 AOS (P)			;YES-SKIP
	RET

;ACCEPTS LINE # IN 2
;SKIP IF TALKING AUX H2H PROTOCOL
;NO SKIP IF NOT

	SWAPCD

TYMH2H:	PUSH P,2
	MOVE 2,AUXCTL(2)		;GET ENTRY FILLED OUT ABOVE
	CAME 2,MINUS1			;DID IT DO IT RIGHT?
	 AOS -1(P)			;YES
	POP P,2
	RET


;CALLED WITH LINE IN 2 FROM EXEC0 JUST BEFORE GETTING USER AN EXEC

	SWAPCD

TYMQUE:	CALL TYMH2H			;TALKING H2H FOR THIS LINE?
	 RET				;NO-PASS THRU
	LDB 1,AUXCFN			;YES-GET FUNCTION CODE
	CAIL 1,0			;RANGE CHECK
	CAILE 1,MTYMQU
	 JRST TYMQX1			;ILLEGAL FUNCTION CODE
	JRST @TYMQU1(1)			;DISPATCH

TYMQU1:	TYMEXC				;EXEC (RING INPUT,OUTPUT)
	TYMQJB				;QUE AUX LINE FOR DJOB (RING I/O)
	TYMEBI				;BLOCK INPUT, RING OUTPUT EXEC
	TYMEBO				;RING INPUT, BLOCK OUTPUT EXEC
	TYMEBM				;BLOCK INPUT, BLOCK OUTPUT EXEC
	TYMQBI				;BLOCK INPUT, RING OUTPUT QUE AUX
	TYMQBO				;RING INPUT, BLOCK OUTPUT QUE AUX
	TYMQBM				;BLOCK INPUT, BLOCK OUTPUT QUE AUX
MTYMQU==.-TYMQU1-1			;MAX FUNCTION CODE ALLOWED

;EXEC

TYMEXC:	SETZM TYMBKS(2)			;NOT BLK MODE
	RET				;SIMPLE PASS ON THRU EXEC


;EXEC BLOCK MODE

TYMEBI:	MOVSI 1,BKIMOD			;BLK MOD INPUT ONLY
	IORM 1,TYMBKS(2)		;ENTER BLK MOD FLAG
	RET				;EXEC

TYMEBO:	MOVEI 1,BKOMOD			;BLK MOD OUTPUT ONLY
	IORM 1,TYMBKS(2)		;ENTER BLK MOD FLAG
	RET				;EXEC

TYMEBM:	MOVSI 1,BKIMOD			;BLK MOD I/O
	HRRI 1,BKOMOD
	IORM 1,TYMBKS(2)		;ENTER BLK MOD FLAG
	RET				;EXEC


;AUX QUE BLOCK MODE

TYMQBI:	MOVSI 1,BKIMOD			;BLK MOD INPUT ONLY
	IORM 1,TYMBKS(2)		;ENTER BLK MOD FLAG
	JRST TY0QJB			;QUE FOR DJOB

TYMQBO:	MOVEI 1,BKOMOD			;BLK MOD OUTPUT ONLY
	IORM 1,TYMBKS(2)		;ENTER BLK MOD FLAG
	JRST TY0QJB			;QUE FOR DJOB

TYMQBM:	MOVSI 1,BKIMOD			;BLK MOD I/O
	HRRI 1,BKOMOD
	IORM 1,TYMBKS(2)		;ENTER BLK MOD FLAG
	JRST TY0QJB			;QUE FOR DJOB


;QUE AUX LINE FOR JOB IN AUXCTL (DJOB) ALONG WITH UDBITS

TYMQJB:	SETZM TYMBKS(2)			;NOT BLOCK IO
TY0QJB:	NOSKED				;NOTHING CHANGES

	HRRE 1,AUXCTL(2)		;GET DJOB FROM H2H DATA
	JUMPGE 1,TYMQJ1			;JUMP IF JOB #
	MOVNS 1				;MAKE POSITIVE SYSNDX IN 1
	CALL SYSXCK			;CHK ON SYSNDX
	 JRST TYMQUX			;ILLEGAL SYSNDX
	JUMPL 2,TYMQUX			;FREE IS ILLEGAL TOO
	MOVE 1,2			;JOB # IN 1
TYMQJ1:	HRRE 3,JOBDIR(1)		;DJOB LOGGED?
	JUMPE 3,TYMQUX			;JUMP IF NOT
	HRRZ 1,CTRLTT			;THIS STORES LINE FOR US (NICE)
	MOVE 3,AUXCTL(1)		;GET UDBITS,,DJOB
	TLZ 3,777000			;CLR EDBITS
	SETZ 2,				;USBITS 0
	IOR 1,[6,,400000]		;COMPLETE FUNCTION AND DESIGNTR

	OKSKED

	TYMOP				;QUE IT FOR DJOB WITH UDBITS
	 JRST TYMQX1			;FAILED

TYMQJ2:	MOVE 1,JOBNO
	HRROS JOBPT(1)
	SETOB 1,CTRLTT			;SAY WE HAVE NO CTRLTT
	LGOUT				;BYE
	BUG(CHK,<FAILED TO LGOUT JOB IN TYMQUE>)
	JRST TYMQJ2			;LOOP TIL SMASHED

;HERE ON FAILURE IN TYMQUE STUFF

TYMQUX:	OKSKED				;IF FAILED NOSKED
TYMQX1:	RET				;JUST RETURN ON FAILURE
					;SHOULD GET US AN EXEC


;THIS HAD PREVIOUSLY BEEN CALLED AT SCHED LEVEL.  NOW JOB 0 FUNCTION
;INCASE RUNNING ON FOO AND HAVE TO DO 300 ZEROES CROCK.
;TURNS OFF TYMFLG SO NOBY TRIES ANYTHING WHILE WE ARE INITING
;AT PROCESS LEVEL

TYMRST:	PUSH P,TYMFLG		;SAVE STATE OF THINGS
	SETZM TYMFLG		;NOBODY DOES ANYTHING NOW
	SKIPN 3,J0RTIM		;IS THIS A RETRY?
	JRST TYMRS0		;NO-DO EVERYTHING
	CAMG 3,TODCLK		;YES-TIME TO DO IT?
	 JRST TYMRTY		;YES-DID TABLES ALREADY, TRY RESET AGAIN
	JRST TYMRSR		;NO-JB0 HERE PREMATURELY

TYMRS0:	MOVE C,[XWD TMPLT,TYMBAS] ;init interface
	BLT C,YHCRSH
	MOVE LINE,TYMPTR	 ;detach jobs w/ zapped circuits
TYMRS1:	PUSH P,LINE		;SAVE AOBJN PTR
	HRRZS LINE		;JUST LINE # IN LINE FOR PSI STUFF
	MOVEI 3,1B35		;DO CARRIER OFF FIRST SO PSI TAKES HOLD
	ANDCAM 3,TTFLGS(LINE)	;say "carrier off"
	LDB 3,CONSTS
	TRNN 3,<CONNF>B47		;CONNECTED STATE?
	 JRST [	SETZM TYMLNS(LINE)	;NO-CLEAR TYMLNS IF NOT CONNECTED
		JRST .+2]		;AND THE REST
	 CALL ZAP			;YES-ZAP AND LET JOB 0 CLEAN UP TYMLNS
	SETOM TENTYM(LINE)
	SETZM TYMBKS(LINE)
	SETZM YLTCHK(LINE)	
	SETZM TYMCMM(LINE)
	SETZM TYMCMI(LINE)
	SETOM AUXCTL(LINE)	;CLEAR ALL AUXQUE STUFF
	SETOM AUXTMQ(LINE)
	SETOM AUXDJQ(LINE)
	SETOM AUXSJQ(LINE)
	POP P,LINE		;RESTORE AOBJN PTR
	AOBJN LINE,TYMRS1

	SETZM AUXCTM		;JOB 0 TIMER FOR TYMCKT

	MOVSI C,-NAUXLN

	SETZM AUXCLK(C)
	SETZM AX2CLK(C)
	SETZM AUXINF(C)
	AOBJN C,.-2

	MOVE 1,[BLKLCK,,BLKLCK+1]	;CLEAR BLKLCK TABLE
	SETOM BLKLCK
	BLT 1,BLKLCK+NBKIOQ-1
	SETZM BLKLKC			;# LOCKED

IFN STATSW,<AOS YSTRST>		;count resets

	SETZM TYSAVP		;init normal TYMIN entry
	MOVEI A,TYMTTL		;reset output line check counter
	MOVEM A,LTYMOT

;JUMP TO HERE IF RETRYING TO RESET NODE (JUMP OVER RESETING TABLES)


TYMRTY:	CALL FNSYNC		;DO FOONLY NODE SYNC
	 JRST TYMRSR		;FAILED, J0RTIM SET
				;SKIPPED, J0RTIM CLEARED

	MOVEI LINE,NTYMTT	;start up interface, tell base # lines
	MOVEI C,TYPHSI		;don't issue TYMHSI because line number
	MOVE 4,NTHOST			;SAY WHO WE ARE TO BASE
	CALL OTYPES		;must not be checked for CONNF
	 JRST BADBEG		;impossible no room
	MOVSI A,ANSF		;reset TYMBASE answering status
	ANDCAM A,TYMSTS		;to force the appropriate ANSWER response
	CALL ENTCHK		;set ans/shut status
	 JRST BADBEG

	MOVE A,TODCLK		;set up time to check key
	ADDI A,KEYPRD
	MOVEM A,KEYTIM
	SETZM KEYCT		;set to wait for base to respond
	MOVE A,TODCLK		;SET DISABLED BASE ALARM CLOCK
	ADDI A,YALRMP
	MOVEM A,YALRMC
	MOVSI A,RESETF
	IORM A,TYMSTS
	MOVSI 1,JB0RST		;IF HERE MEANS DID IT ALL
	ANDCAM 1,TYMSTS		;DON'T REQUEST TYMRST ANYMORE
TYMRSR:	POP P,TYMFLG		;BACK TO STATE WE ENTERED WITH
	RET

BADBEG:	BUG(NTE, <TYMSRV: ORING SCREWED UP ON TYMBASE STARTUP>)
	JRST TYMRSR



FNSYNC:	MOVE 3,TODCLK		;GET ENTER TIME
	ADDI 3,SNCPRD		;3/ WHEN MUST BE DONE
	MOVE 4,TODCLK		;4/ REMEMBER ENTER TIME ALSO
	FN.RST 0		;TURN OFF INPUT AND OUTPUT
	MOVEI 2,NZEROS		;THIS MANY ZEROES TO INTERFACE
FNSYN0:	FN.WRT 0		;WRITE ONE
FNSYN1:	IMULI 1,1		;WASTE TIME FOR POOLE LOSAGE
	IMULI 1,1		;WASTE TIME FOR POOLE LOSAGE
	IMULI 1,1		;WASTE TIME FOR POOLE LOSAGE
	FN.RED 1		;READ STATUS
	TLNE 1,(1B5)		;ACCEPTED BY NODE?
	 JRST FNSYN2		;YES-LOOP FOR MORE 0'S
	CAMLE 3,TODCLK		;TIMED OUT?
	JRST FNSYN1		;NO-KEEP LOOKING FOR ACCEPTANCE BIT
	BUG(NTE,<TYMSRV: FAILED TO RESYNC WITH NODE>)
	MOVE 1,TODCLK
	ADDI 1,J0RPRD		;3/ WHEN TO TRY AGAIN
	MOVEM 1,J0RTIM		;REMEMBER IT
	JRST FNSYN3		;DIDDLE CHKTIM

FNSYN2:	SOJG 2,FNSYN0		;ACCEPTED, LOOP FOR MORE
	FN.RST 1B34!1B35	;NOW TURN ON INPUT AND OUTPUT
	MOVSI 1,RTYWIN		;FLAG FOR JOB 0 RETRY WIN MESSAGE
	SKIPE J0RTIM		;WAS THIS A RETRY?
	 IORM 1,TYMSTS		;YES-REQUEST MESSAGE FROM OURSELVES (JOB 0)
	SETZM J0RTIM		;SAY NOT RETRYING NEXT TIME IN HERE
	AOS (P)			;SKIP SUCCESS
FNSYN3:	MOVE 1,TODCLK
	SUB 1,4			;1/ TIME SPENT IN HERE
	ADDM 1,CHKTIM		;DON'T LET JOB 0 SEE TIME SPENT HERE
	RET			;SKIP IF SUCCESS




;REQUEST TIME FROM TYMNET AT PROCESS LEVEL
;SKIPS AND SETS TIMFLG FLAG IF SUCCESS

TYTMRQ:	TYMCLP				;REQUEST DATE AND TIME
	 RET
	SETFLG (<TIMFLG>,<TIMEJ0>)	;SAY WE ARE REQUESTING
	HRROI 1,[ASCIZ/
[TIME AND DATE REQUESTED FROM TYMNET]
/]
	PSOUT
	JRST SKPRET

;SET TIME VIA 32 BIT VALUE IN TIMNET
;SKIPS FOR SUCCESS, CLEARS FLAGS ALWAYS

TYTMST:	CLRFLG (<TIMFLG>,<TIMEJ0!TIMEIN>)
	MOVE 3,TIMNET		;GET 32 BIT SECS SINCE THEN GMT
	HRROI 1,[ASCIZ/JAN 1,1974 00:00:00-GMT/]
	SETZ 2,
	IDTIM			;GET INTERNAL FORMAT FOR TYMNET DAY 0
	 RET			;FAILED
	MOVE 1,2		;GET IN 1
	MOVE 2,3
	IDIVI 2,<^D24*^D60*^D60>	;2/ DAYS, 3/ SECS GMT
	LSH 2,^D18		;DAYS INTO POSITION
	ADD 1,2			;ADD TO DAYS
	HRRZ 2,1		;GET SECS
	ADD 2,3			;TOTAL SECS GMT
	IDIVI 2,<^D24*^D60*^D60>	;2/ DAYS, 3/ SECS GMT
	LSH 2,^D18		;DAYS INTO POSITION
	ADD 1,2			;ADD TO DAYS
	HRR 1,3			;FINAL SECS GMT
	SKIPL TADSEC		;STILL NO DATE AND TIME?
	 JRST SKPRET		;SOMEONE MUST HAVE SET IT WHILE WE WAITED
				;BELIEVE THE HUMAN
	STAD
	 RET			;FAILED????
	HRROI 1,[ASCIZ/
[Time and date RCVD from TYMNET: /]
	PSOUT
	MOVEI 1,101
	SETOB 2,3
	ODTIM
	HRROI 1,[ASCIZ/]
/]
	PSOUT
	JRST SKPRET		;WIN



	SUBTTL JOB0 zapped line checker

TYMJB0:	SKIPN TYMFLG		;NO SKIP IF TYMNET OFF
	 RET
	MOVE 1,TYMSTS
	TLNN 1,JB0RST		;TYMRST REQUEST?
	SKIPN TYM1ST		;NO-BUT FIRST TIME HERE?
	 CALL TYMRST		;DO IT, CLR JB0RST IF SUCCESS, SET TYM1ST
	SETOM TYM1ST		;SAY DID IT AT LEAST ONCE
	MOVE 1,TYMSTS
	TLNE 1,JB0RST		;STILL WANT A RESET THOUGH?
	 JRST TYJB03		;YES-JUST DO MESSAGE AND GET OUT, TRY LATER
	SKIPL TADSEC		;TIME SET YET?
	 JRST TYJB00		;YES
	MOVE 1,TIMFLG
	TLNE 1,(TIMEJ0)		;OUTSTANDING TIME REQUEST?
	 JRST TYMJ00		;YES-SEE IF ITS IN YET
	CALL TYTMRQ		;NO-REQUEST TIME FROM SUPER	
	 JRST TYJB03		;FAILED-JUST DO MESSAGE AND GET OUT, TRY LATER
TYMJ00:	MOVE 1,TIMFLG		;HERE TIMEJ0 FLAG SET
	TLNN 1,(TIMEIN)		;DID ANSWER COME IN YET?
	 JRST TYJB03		;NO -JUST DO MESSAGE AND GET OUT, TRY LATER
	CALL TYTMST		;YES-ITS IN TIMNET, DO STAD
	 JRST TYJB03		;FAILED-JUST DO MESSAGE AND GET OUT, TRY LATER
TYJB00:	CLRFLG (<TYMSTS>,<TIMEJ0!TIMEIN>)	;INSURE THESE ARE OFF IF HERE

	MOVE LINE,TYMPTR	 ;check all TYMNET lines

TYJB01:	LDB 3,CONSTS		;get connection state
	CAIE 3,CONFRE		;FREE?
	TRNE 3,<CONNF>B47	;IN DISCONNECTED STATE?
	 JRST TYJB02		;FREE OR CONNECTED AND NOTHING TO DO
	PUSH P,B		;save line number AOBJN
	MOVEI A,400000(B)	;turn line number into tty designator
	PUSH P,A		;save tty designator
	CALL CHKDEV		;get assignation status of line
	 CAIE A,DEVX2		;assigned?
	  TDZA B,B		;no
	HRRZS DEVUNT(B)		;still assigned, smash in job 0 ownership
	POP P,A			;restore tty designator
	SKIPE B			;still assigned?
	 RELD			;yes, release it INT ISSUED ALREADY
	  JFCL

	HRRZ LINE,(P)		;JUST LINE # IN 2

	NOSKED			;KEEP SHEDULER AWAY FROM IRING
	CALL TTRLAB		;NOW CLEAN UP ALL LINE BUFFERS
	CALL IBPRFB		;UNDO WHAT WE MAY HAVE DONE FOR AUX CIRCUIT
	OKSKED			;STATIC INPUT BUFFER COUNTS

	POP P,LINE		;restore line number AOBJN
	SETZM TYMLNS(LINE)	;release line

TYJB02:	AOBJN LINE,TYJB01

	CALL AUXCKT		;CHECK FOR AUXQUE TIMEOUTS


	SUBTTL CHECK INTERFACE STATUS

TYJB03:	ADD P,BHC+3
	JUMPGE P,MSTKOV
	MOVEI 7,-2(P)		;set up buffer for FACT file messages

	MOVE A,[XWD 163000,3]	;interface status message type
	MOVEM A,(7)

	GTAD			;time for FACT file messge
	MOVEM A,2(7)		;MIGHT BE -1

	MOVSI D,-NYMSG		;check all possible states
TYMS1:	HLLZ A,MSGTAB(D)	;get flag to check
	TDNN A,TYMSTS		;is it on?
	 JRST TYMS2		;no, go on to next

	HRRZ 5,D		;GET MESSAGE #
	ANDCAM A,TYMSTS		;YES, TURN IT OFF
	MOVEM A,1(7)		;SET IT INTO FACT FILE MESSAGE BUFFER
	CAIN 5,YMSGC		;CRASH MESSAGE?
	 JRST  [LDB 1,[POINT 16,TYMCSH,15] ;PUT CRASH REASON INTO 
		HRRM 1,1(7)	;FACT FILE MESSAGE
		JRST .+1]
	MOVSI A,-3		;FACT FILE MESSAGE LENGTH
	CALL TYFACT		;ENTER FACT FILE MESSAGE

	MOVEI A,101		;TELL JB0 TTY ABOUT IT
	DOBE

	HRROI 1,[ASCIZ/
/]
	PSOUT
	GTAD
	CAMN 1,[-1]
	 JRST [	HRROI 1,[ASCIZ/(TIME NOT SET)/]
		PSOUT
		JRST TYMS12]

	MOVEI A,101
	SETO B,			;TIME STAMP
	MOVSI C,045241		;SHORT FORMAT
	ODTIM

TYMS12:	HRRO A,MSGTAB(D)	;GET MESSAGE
	PSOUT

	CAIN 5,YMSGC		;CRASH MESSAGE?
	 JRST  [HRROI A,[ASCIZ / @ /]
		PSOUT

		LDB 2,[POINT 16,TYMCSH,31]	;GET CRASH ADDRESS
		MOVEI 1,101	;TYPE TO LOG TTY
		MOVEI 3,^D8	;IN OCTAL
		NOUT
		 JFCL
	
		HRROI A,[ASCIZ / - /]
		PSOUT

		LDB 2,[POINT 16,TYMCSH,15]	;GET CRASH REASON
		MOVEI 1,101
		NOUT
		 JFCL

		HRROI A,[ASCIZ /: /]
		PSOUT

		HRROI 1,[ASCIZ /UNKNOWN REASON/]
		CAIGE 2,NTYBMG
		HRRO 1,TYBMSG(2)
		PSOUT

		JRST .+1]

	CAIN 5,YMSGA		;ALARM MESSAGE?
 	 JRST  [HRROI A,[ASCIZ //] ;YES, RING BELLS
		PSOUT
		JRST .+1]

	HRROI 1,[ASCIZ/
/]
	PSOUT
TYMS2:	AOBJN D,TYMS1		;LOOK FOR MORE

	SUB P,BHC+3		;POP EFACT BUFFER
	RET			;NO

MSGTAB:	
YMSGA==.-MSGTAB
	XWD ALARMF,[ASCIZ / TYMBASE APPARENTLY DISABLED/]
YMSGC==.-MSGTAB
	XWD CRASHF,[ASCIZ / TYMBASE CRASHED/] 
	XWD DIEDF,[ASCIZ / TYMBASE DIED/]
	XWD RTYWIN,[ASCIZ/ TYMBASE SYNC RETRY WON/]
	XWD RESETF,[ASCIZ / TYMBASE RESET/]
	XWD UPF,[ASCIZ / TYMBASE UP/]
NYMSG==.-MSGTAB

TYBMSG:	[ASCIZ /HOST going down - key not refreshed/]
	[ASCIZ /HOST crashing due to BASE crash/]
	[ASCIZ /MIC error or MIC reject tring to read key/]
	[ASCIZ /Read bad key from HOST/]
	[ASCIZ /Bad data type or port number from host/]
	[ASCIZ /Illogical data type from HOST/]
	[ASCIZ /MIC busy trying to read HOST/]
	[ASCIZ /Input ring processing time-out/]
	[ASCIZ /MIC time-out error (SEN 337)/]
	[ASCIZ /Parity error from MIC (SEN 237)/]
	[ASCIZ /MIC busy for 232 cycles/]
	[ASCIZ /MIC busy (IN) - obsolete, can't happen/]
	[ASCIZ /MIC busy (LOCK)/]
NTYBMG==.-TYBMSG


;CALLED BY JOB 0 TO CHECK ON QUEUED AUX CIRCUITS QUEUED TOO LONG
;SHOULD CHECK 1 LINE PER CALL IF SPENDING TOO MUCH TIME HERE

	SWAPCD

AUXCKT:	MOVE 1,TODCLK			;GET TIME NOW
	SKIPE AUXCTM			;SET YET?
	CAML 1,AUXCTM			;YES-TIME TO DO THIS?
	 CAIA				;1ST TIME OR TIME TO DO IT
	RET				;WAIT TIL TIME TO DO IT
	MOVE 1,[-NTYMTT,,DUXTMQ]	;SCAN ALARM CLK TABLE
AUXCK1:	MOVE 2,(1)			;GET TODCLK
	CAMN 2,MINUS1			;UNUSED?
	 JRST AUXCK2			;SKIP IT
	CAMG 2,TODCLK			;TIMED OUT?
	 CALL AUXCK3			;YES-DEQUE IT
AUXCK2:	AOBJN 1,AUXCK1			;LOOP TIL ENTIRE TABLE SEEN
	MOVE 1,TODCLK			;UPDATE TIMER FOR THIS ROUTINE
	ADDI 1,AUXTMC			;THIS MUCH LATER
	MOVEM 1,AUXCTM			;REMEMBER IT
	RET

AUXCK3:	PUSH P,1			;SAVE AOBJN PTR
	HRRZS 1				;1/ AUXTMQ+LINE #
	SUBI 1,AUXTMQ			;1/ LINE #
	HRRZ 3,AUXSJQ(1)		;GET SJOB IN 3
	IOR 1,[1B3!1B4!10B17!400000B35]	;OPTION BITS, CODE & DEVICE BITS
	TYMOP				;DEQUE IT
	 BUG(CHK,<JOB 0 FAILED TO DEQ TIMED OUT AUX CIRCUIT IN QUE>)
	POP P,1
	RET


	SUBTTL TYMNET BUFFER UTILITY JSYS'S

;
;	get/put word from/into TYMNET buffer, utility JSYS
;	for loading TYMBASE, debugging, etc.
;
;	1/ word to get/put
;	2/ offset address into TYMNET buffer
;	
;	always returns +1, no errors, ever.
;
.TYMBW:	SKIPL 2			;set word into TYMNET buffer
	CAIL 2,TYMBSZ		;no op if address is outside of buffer
	 XCT MJRSTF
	MOVEM 1,TYMBUF(2)
	XCT MJRSTF

.TYMBR:	SKIPL 2			;read word from TYMNET buffer
	CAIL 2,TYMBSZ
	 XCT MJRSTF
	MOVE 1,TYMBUF(2)
	XCT MJRSTF

;
;	TYMLI JSYS
;
;	always returns +1 with node information for connected TYMNET
;	line.  for non-TYMNET lines, or non-TTY devices, returns
;	-1.
;
;	TYMNET node info is:
;		0 - 8   9   -   16    17  -  23    24  - 35
;		  0   terminal type  port number  origin node
;
.TYMLI:	MCENT
	CALL CHKTTY		;get TYMNET particular information
	 JRST .GTTY1		;not a tty, return not TYMNET tty info

	CAIL LINE,TYMTTL
	CAIL LINE,TYMTTL+NTYMTT
.GTTY1:	SKIPA A,[-1]		;not TYMNET tty, give -1
	MOVE A,TYNODS(LINE)	;TYMNET tty, get right info.

	UMOVEM A,B
	CALL UNLCKF
	JRST MRETN



	SWAPCD

;ENTER AND LEAVE BLOCK MODE FOR EACH OF INPUT AND OUTPUT SIDES.

;OPTION BITS: B0 ON FOR BLK MOD, OFF FOR NON BLK MODE
;SET BLK MODE INPUT SIDE

SETBKI:	HRRZ JFN,1		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	CALL TYMAUX		;ASSOCIATED WITH AUX CIRCUIT?
	 RETERR (TYMX23)	;NO
	UMOVE 3,1		;GET ARGS
	TLNN 3,(1B0)		;CLEAR BLOCK MODE?
	 JRST SETBI1		;YES

	MOVE 1,TYMBKS(2)	;GET BLK MODE STATUS
	TLNE 1,BKIMOD		;ALREADY IN BKI MODE?
	 JRST SKMRTN		;YES-NOTHING TO DO

	NOSKED			;LET NO CHRS IN

	CALL TTSIBE		;CAN'T HAVE CHRS WAITING TO BE EATEN
	 RETERR (TYMX25,<OKSKED>)	;STILL CHRS TO EAT-USER MUST DO IT
	PUSH P,2		;SAVE LINE #
	CALL ASGPAG		;GET JSB PAG
	 RETERR (TYMX26,<POP P,2
			 OKSKED>)	;FAILED, CLAIM JOB RESOURCES NOT ENOUGH
	PUSH P,1		;SAVE ADDRESS
	MOVE 1,-1(P)		;GET LINE #
	MOVSI 2,BKIMOD		;SET FLAG SAYING IN BLK INPUT NOW
	IORM 2,TYMBKS(1)
	MOVE 2,0(P)		;GET ADR IN 2
	SETZM (2)		;HEADER WORD OF BLOCK WITH 0 COUNT
	IOR 1,[20,,400000]	;WAIT FOR CMPLT

	OKSKED

	TYMOP			;GET THE DUMMY BLOCK WITH 0 COUNT TO ENTER BKI
	 RETERR (TYMX27,<POP P,1	;RESTORE ADR
			 POP P,2	;AND LINE
			 MOVSI 3,BKIMOD	;TURN OFF FLAG
			 ANDCAM 3,TYMBKS(2)
			 CALL RELFRE>)
	POP P,1			;RESTORE ADR
	POP P,2			;AND LINE
	CALL RELFRE		;FREE THE DUMMY BLOCK
	JRST SKMRTN		;BASE THINKS WE ARE DOING BKI NOW

;HERE TO LEAVE BLOCK MODE

SETBI1:	MOVE 1,TYMBKS(2)	;GET BLK MODE STATUS
	TLNN 1,BKIMOD		;ALREADY IN BKI MODE?
	 JRST SKMRTN		;NO-NOTHING TO DO
	PUSH P,2		;SAVE LINE

SETBI2:	NOSKED

	SETZ 1,			;0B0 FOR READ DIRECTION
	CALL BLKGOK		;SEE IF XFERS ACTIVE
	 JRST SETBI3		;YES-WAIT TIL NONE
	MOVSI 1,BKIMOD		;CLEAR FLAG
	MOVE 2,0(P)		;GET LINE
	ANDCAM 1,TYMBKS(2)
	MOVSI 1,BKIIHR		;SAY TYPIHR OUTSTANDING
	IORM 1,TYMBKS(2)

	OKSKED

	TYMIRQ			;SEND OUT TYPIRQ FOR LINE
	 RETERR (TYMX27,<POP P,2	;GET LINE
			 MOVSI 1,BKIMOD	;TURN BKIMOD BACK ON
			 IORM 1,TYMBKS(2)
			 MOVSI 1,BKIIHR	;AND NEVER SENT THE IRQ
			 ANDCAM 1,TYMBKS(2)>)
	POP P,2			;GET LINE #
	MOVEI 1,IHRTST
	HRL 1,2
	JSYS EDISMS		;WAIT FOR BASE ACK
	JRST SKMRTN

SETBI3:	OKSKED

	MOVEI 1,IOKTST		;WAIT TIL NOT XFERS ACTIVE
	HRL 1,0(P)
	JSYS EDISMS
	MOVE 2,0(P)
	JRST SETBI2		;TRY AGAIN


	RESCD

;SCHED TESTS

IOKTST:	MOVE 2,1
	SETZ 1,
	CALL BLKGOK
	 JRST 0(4)
	JRST 1(4)

IHRTST:	MOVE 2,TYMBKS(1)	;BKIIHR FLAG OFF YET?
	TLNE 2,BKIIHR
	 JRST 0(4)
	JRST 1(4)



	SWAPCD

;OPTION BITS: B0 ON FOR BLK MOD, OFF FOR NON BLK MODE
;SET BLOCK MODE OUTPUT SIDE

SETBKO:	HRRZ JFN,1		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	CALL TYMAUX		;ASSOCIATED WITH AUX CIRCUIT?
	 RETERR (TYMX23)	;NO
	UMOVE 3,1		;GET ARGS
	TLNN 3,(1B0)		;CLEAR BLOCK MODE?
	 JRST SETBO1		;YES

	MOVE 1,TYMBKS(2)	;GET BLK MODE STATUS
	TRNE 1,BKOMOD		;ALREADY IN BKO MODE?
	 JRST SKMRTN		;YES-NOTHING TO DO
	CALL TTDOBE		;WAIT FOR RING CHRS TO GO OUT

	NOSKED			;LET NO CHRS OUT

	PUSH P,2		;SAVE LINE #
	CALL ASGPAG		;GET JSB PAG
	 RETERR (TYMX26,<POP P,2
			 OKSKED>)	;FAILED, CLAIM JOB RESOURCES NOT ENOUGH
	PUSH P,1		;SAVE ADR
	MOVE 1,-1(P)		;GET LINE #
	MOVEI 2,BKOMOD		;SET FLAG SAYING IN BLK OUTPUT NOW
	IORM 2,TYMBKS(1)
	MOVE 2,0(P)		;GET ADR IN 2
	SETZM (2)		;HEADER WORD OF BLOCK WITH 0 COUNT
	IOR 1,[21,,400000]	;WAIT FOR CMPLT

	OKSKED

	TYMOP			;SEND THE DUMMY BLOCK WITH 0 COUNT TO ENTER BKO
	 RETERR (TYMX27,<POP P,1	;RESTORE ADR
			 POP P,2	;AND LINE
			 MOVEI 3,BKOMOD	;TURN OFF FLAG
			 ANDCAM 3,TYMBKS(2)
			 CALL RELFRE>)
	POP P,1			;RESTORE ADR
	POP P,2			;AND LINE
	CALL RELFRE		;FREE THE DUMMY BLOCK
	JRST SKMRTN		;BASE THINKS WE ARE DOING BKO NOW

;HERE TO LEAVE BLOCK MODE

;HERE TO LEAVE BLOCK MODE

SETBO1:	MOVE 1,TYMBKS(2)	;GET BLK MODE STATUS
	TRNN 1,BKOMOD		;ALREADY IN BKO MODE?
	 JRST SKMRTN		;NO-NOTHING TO DO
	PUSH P,2		;SAVE LINE

SETBO2:	NOSKED

	MOVSI 1,(1B0)		;1B0 FOR WRITE DIRECTION
	CALL BLKGOK		;SEE IF XFERS ACTIVE
	 JRST SETBO3		;YES-WAIT TIL NOT
	MOVEI 1,BKOMOD		;CLEAR FLAG
	MOVE 2,0(P)		;GET LINE
	ANDCAM 1,TYMBKS(2)
	MOVEI 1,BKOOHR		;SAY TYPOHR OUTSTANDING
	IORM 1,TYMBKS(2)

	OKSKED

	TYMORQ			;SEND OUT TYPORQ FOR LINE
	 RETERR (TYMX27,<POP P,2	;GET LINE
			 MOVSI 1,BKOMOD	;TURN BKOMOD BACK ON
			 IORM 1,TYMBKS(2)
			 MOVEI 1,BKOOHR	;AND NEVER SENT THE ORQ
			 ANDCAM 1,TYMBKS(2)>)
	POP P,2			;GET LINE #
	MOVEI 1,OHRTST
	HRL 1,2
	JSYS EDISMS		;WAIT FOR BASE ACK
	JRST SKMRTN


SETBO3:	OKSKED

	MOVEI 1,OOKTST		;WAIT TIL NOT XFERS ACTIVE
	HRL 1,0(P)
	JSYS EDISMS
	MOVE 2,0(P)
	JRST SETBO2		;TRY AGAIN


	RESCD

;SCHED TESTS

OOKTST:	MOVE 2,1
	MOVSI 1,(1B0)
	CALL BLKGOK
	 JRST 0(4)
	JRST 1(4)

OHRTST:	MOVE 2,TYMBKS(1)	;BKOOHR FLAG OFF YET?
	TRNE 2,BKOOHR
	 JRST 0(4)
	JRST 1(4)



	SWAPCD

;GET AN I/O BLOCK IN

;ACCEPTS:
;	1/ option bits,20,,tty designoator
;		where option bits are: NONE
;		     B0: 1 - POKE TERMINAL INT 33 ON COMPLETION
;			 0 - WAIT FOR COMPLETION
;		     B1: 1 - DON'T RETURN STATUS IN BLOCK HEADER WRD
;			 0 - ALLOW RETURN OF STATUS IN BLOCK HEADER WRD
;	2/ START ADR OF BLOCK (ON PAGE BOUNDRY)
;
;RETURNS:
;	+1 error code in 1
;	+2 success, UPDATED 0TH WORD IN BLOCK IF APPROPRIATE

GETBLK:	SETZ 3,			;FLAG TO SAY READING A BLOCK
	CALL XFRBLK		;DO IT
	 CAIA			;ERROR
	JRST SKMRTN		;SKIP
	 UMOVEM 1,1		;RETURN ERROR TO USER
	 JRST MRETN		;NO SKIP

;SEND AN IO BLOCK OUT
;USER CAN PREVENT DIRTYING OF PAGE WITH RETURNED STATUS WITH 1B1 OPTION BIT

;ACCEPTS:
;	1/ option bits,21,,tty designoator
;		where option bits are:
;		   B0:  1 - POKE TERMINAL INT 34 ON COMPLETION
;			0 - WAIT FOR COMPLETION
;		   B1:  1 - DON'T RETURN STATUS IN BLOCK HEADER WRD
;			0 - ALLOW RETURN OF STATUS IN BLOCK HEADER WRD
;	2/ START ADR OF BLOCK (ON PAGE BOUNDRY)
;
;RETURNS:
;	+1 error code in 1
;	+2 success, UPDATED 0TH WORD IN BLOCK IF APPROPRIATE

SNDBLK:	MOVSI 3,(1B0)		;FLAG TO SAY WRITING A BLOCK
	CALL XFRBLK		;DO IT
	 CAIA			;ERROR
	JRST SKMRTN		;SKIP
	 UMOVEM 1,1		;RETURN ERROR TO USER
	 JRST MRETN		;NO SKIP



;MAIN CODE FOR BLOCK IO XFERS
;ACCEPTS IN 3/ B0 ON FOR WRITE, OFF FOR READ
;STACK HAS: -1(P)	;PC AND FLAGS OF TYMOP JSYS
	    -0(P)	;RETURN PC TO CALLER
;SKIP FOR SUCCESS
;NO SKIP WITH ERROR IN 1 ON FAILURE

XFRBLK:	MOVE 4,1		;SAVE USER ARGS
	MOVE 5,2
	MOVE 6,3		;SAVE READ/WRITE FLAG
	HRRZ JFN,4		;WHERE CHKTTC LIKES TTY DESIGNATOR
	CALL CHKTTC		;CHECK ON IT
	 RETERR (TYMXX8,<CALL UNLCKF>)
	CALL UNLCKF		;OK, UNDO LOCK, 2/ LINE #
	CAIL 2,TYMTTL		;RANGE CHECK
	CAILE 2,TYMTTH
	 RETERR (TYMXX8)	;NOT TYMNET LINE
	CALL TYMAUX		;IS IT ASSOCIATED WITH AUX CIRCUIT?
	 RETERR (TYMX23)	;NO
	MOVE 1,TYMBKS(2)
	TLNE 6,(1B0)		;INPUT?
	 JRST XFRBL0		;NO-OUTPUT	 
	TLNN 1,BKIMOD		;IN BLK INPUT MODE?
	 RETERR (TYMX19)	;NO
	JRST XFRB00		;YES

XFRBL0:	TRNN 1,BKOMOD		;IN BLK OUTPUT MODE?
	 RETERR (TYMX19)	;NO
XFRB00:	TLNE 5,000777		;MUST BE PAGE ALIGNED
	 RETERR (TYMX21)	;ISN'T
	UMOVE 1,(5)
	HRRES 1			;GET DESIRED COUNT
	CAIL 1,1
	CAILE 1,777		; 1 <= COUNT <= 777
	 RETERR (TYMX22)	;ILLEGAL WORD COUNT
	CALL GETBKE		;GET AND LOCK A FREE BLK ENTRY, INDEX IN 1
	MOVE 7,1		;RETURNED NOINT, SAVE ENTRY INDEX IN 7
	HRRM 2,BLKSTL(7)	;SAVE LINE # IN RH STATUS WORD
	SETZ 1,			;INIT FLAGS
	TLNE 6,(1B0)		;WRITING?
	 TLO 1,BLKWRF		;YES-WRITE FLAG
	TLNN 4,(1B1)		;OK TO DIRTY PAGE WITH RETURNED STATUS?
	 TLO 1,BLKRSF		;YES
	TLNE 4,(1B0)		;INTERRUPT ON COMPLETION?
	 TLO 1,BLKINF		;YES-INTERRUPT FLAG
	IORM 1,BLKSTL(7)	;SET IN QUEUE ENTRY, STATE 0
	HRRZ 1,5		;GET VIRTUAL ADR OF PAGE OF DATA TO SEND
	MOVE 3,-1(P)		;GET PC WORD AT TYMOP JSYS CALL
	TLNE 3,UMODF		;CHECK USER MODE BIT AT CALL
	HRLI 1,(1B0)		;CALLED FROM USER, INDICATE IN ADDRESS
	HRRZ 3,5		;GET VIRTUAL ADR
	CAIGE 3,PPRMA		;RESIDENT MONITOR ADDRESS?
	JUMPGE 1,[LSH 1,^D-9	;MAKE PAGE NUMBER (NO NEED TO UNLOCK)
		  JRST XFRBL1]	;PAGE ADR IN 1
	UMOVE 3,0(5)		;REF THE PAGE TO ASSIGN IT
	CALL FPTA		;GET PTN.PN FOR USER OR NON-RES MON PAGE
	MOVEM 1,BLKUPG(7)	;SAVE INFO TO UNLOCK PAGE
	CALL MLKPG		;LOCK THE PAGE, GET REAL CORE PAGE # IN AC 1
	MOVSI 3,BLKULF		;FLAG TO SAY NEEDS TO BE UNLOCKED WHEN DONE
	IORM 3,BLKSTL(7)	;INTO STATUS WORD FOR LATER
XFRBL1:	MOVE 2,BLKSTL(7)	;GET STATUS WE ARE SETTING UP FOR
	MOVSI 3,(CORMB)		;CORE MODIFIED BIT
	TLNE 2,BLKWRF		;IF READING
	TLNE 2,BLKRSF		;OR RETURNING STATUS FOR WRITE
	 IORM 3,CST0(1)		;NOTE CORE CHANGED
	UMOVE 3,(5)		;GET DESIRED COUNT,,REAL CORE PAGE IN 1
	HRL 1,3			;KEEP XCT MAPPED STUFF SIMPLE
	MOVEM 1,BLKADR(7)	;STORE IT FOR ENTRY (CNT,,PAGE)

	NOSKED

	MOVE 1,6		;1B0 SET FOR OUTPUT DIRECTION, CLEAR FOR INPUT
	HRRZ 2,BLKSTL(7)	;LINE IN 2
	CALL BLKGOK		;OK TO START THE XFER?	
	 JRST XFRBLQ		;CONFLICT-QUEUE AS STATE 1 , NDX IN 1
	MOVE 2,BLKSTL(7)	;START IO, NO STATE 1 OR 2 SEEN
	TLNE 2,BLKWRF		;INPUT?
	 JRST XFRBLO		;NO OUTPUT
	DPB 7,[BKINDX(2)]	;STORE ACTIVE INPUT INDEX IN LINE TABLE
	MOVSI 1,BKIACT		;FLAG IT IS ACTIVE
	IORM 1,TYMBKS(2)
	MOVEI 3,TYPBIN		;INPUT TYPE
	JRST XFRBLA

XFRBLO:	DPB 7,[BKONDX(2)]	;STORE ACTIVE OUTPUT INDEX IN LINE TABLE
	MOVEI 1,BKOACT		;FLAG IT IS ACTIVE
	IORM 1,TYMBKS(2)
	MOVEI 3,TYPBKO		;OUTPUT TYPE
XFRBLA:	HRRZS 2			;ONLY LINE # IN 2
	MOVEI 1,2		;AND STEP IT TO STATE 2
	DPB 1,[BLKSTA(7)]	;SET STATE INTO BLKSTL FOR ENTRY JUST PROCESSED
	MOVE 1,BLKADR(7)	;COUNT,,REAL CORE PAGE IN 1
	CALL OTYPEH		;TELL BASE TO START BLK IO
	 JRST [MOVSI 1,BKIRTY	;ORING FULL, ACS OK-TELL SCHED TO RETRY
		CAIE 3,TYPBIN	;INPUT?
	       MOVEI 1,BKORTY	;NO-OUTPUT
	       IORM 1,TYMBKS(2)	;INTO LINE FLAGS
	       JRST .+1]
	JRST XFRBQ1

XFRBLQ: MOVEM 7,BLKCHN(1)	;CHAIN TO US-WE ARE THE TAIL NOW
	MOVEI 1,1		;GO TO STATE ONE (REQUEST XFER)
	DPB 1,[BLKSTA(7)]	;SET STATE INTO BLKSTL FOR ENTRY JUST PROCESSED

XFRBQ1:	OKSKED

	TLNE 4,(1B0)		;REQUESTED INTERRUPT?
	 JRST XFRBL4		;YES-JUST RETURN-PAGE IS LOCKED AND QUEUED ETC.
	LDB 1,[BLKSTA(7)]	;GET STATE NOW
	CAIN 1,3		;DONE YET?
	 JRST XFRBL2		;YES
	MOVEI 1,BLKDNT		;NO-SCHED WAIT FOR BLK DUN
	HRL 1,7			;WITH INDEX
	JSYS EDISMS		;NO - WAIT FOR IT
XFRBL2: MOVE 3,BLKSTL(7)	;GET STATUS BITS
	TLNN 3,BLKERF		;XFER ERROR?
	 JRST XFRBL3		;NO
	MOVEI 1,TYMX24		;YES-TELL USER CAN FIND ERROR BITS IN BLOCK
	CAIA			;IF DIDN'T PREVENT IT AND DONT SKIP RET
XFRBL3:	AOS (P)			;SKIP RET IF NO XFER ERROR
	TLNE 3,BLKULF		;NEED TO UNLOCK PAGE?
	 CALL MULKPG		;UNLOCK IT
	MOVE 1,7		;BLK INDEX IN 1
	CALL ULKBLK		;UNLOCK ENTRY, GO OKINT
	RET			;0TH WD HAS <ERROR OR 0,,RET CNT,DESIRD CNT>

XFRBL4:	OKINT			;ALLOW INTS-SYSTEM TAKING CARE OF CLEANUP NOW
	JRST SKPRET		;USER WILL GET INT FROM SYSTEM WHEN XFER DONE



;GET A FREE BLK IO ENTRY IN QUEUE
;RETURNS ADR IN 1
;RETURNS NOINT

GETBKE:	CALL LCKBLK			;TRY TO LOCK AN ENTRY
	 CAIA				;FAILED-SCHED TEST WAIT FOR ONE
	RET				;LOCKED ENTRY INDEX IN 1, NOINT
	MOVEI 1,GETBKT			;NOT NOINT
	JSYS EDISMS			;TRY TO LOCK IN SHCED TEST
	JRST GETBKE			;TRY TO LOCK IT AGAIN

;TRY TO LOCK A BLK ENTRY
;SKIPS IF SUCCESS WITH LOCKED ENTRY INDEX IN 1, INITS BLOCK WORDS
;GOES NOINT ON SUCCESS

LCKBLK:	MOVSI 1,-NBKIOQ			;SCAN LOCK TABLE
	NOSKED
LCKBK1:	AOSN BLKLCK(1)			;TRY TO LOCK ONE
	 JRST LCKBK2			;LOCKED
	AOBJN 1,LCKBK1			;SCAN ENTIRE TABLE
	OKSKED
	RET	

LCKBK2:	AOS BLKLKC		;ACCOUNT FOR ANOTHER ONE LOCKED
	SETZM BLKADR(1)		;CLEAR THE IOWD
	SETZM BLKSTL(1)		;CLEAR THE STATUS WORD
	SETZM BLKRET(1)		;CLEAR THE ERROR WORD
	SETZM BLKUPG(1)		;CLEAR UNLOCK PAGE INFO
	SETOM BLKCHN(1)		;SET CHAIN WORD TO TAIL OF CHAIN
	NOINT			;RETURN NOINT
	OKSKED
	HRRZS 1			;KEEP JUST ENTRY INDEX IN AC 1
	JRST SKPRET

;FREE A BLK ENTRY
;ACCEPTS INDEX IN 1
;GOES OKINT

ULKBLK:	NOSKED
	SOS BLKLKC		;CLAIM ANOTHER IS FREE
	SETOM BLKLCK(1)		;UNLOCK IT MAKING THAT SO
	OKINT			;ALLOW INTS AGAIN
	OKSKED
	RET



	RESCD

;SCHED TEST TO SEE IF ANY BLK ENTRIES FREE YET

GETBKT:	MOVE 1,BLKLKC			;GET LOCK COUNT
	CAIL 1,NBKIOQ			;INDICATES AT LEAST ONE FREE?
	 JRST 0(4)			;STILL CAN'T
	JRST 1(4)			;PROCESS MUST LOCK IT ITSELF

;SCHED WAIT TEST FOR BLK ENTRY MARKED AS DONE

BLKDNT:	LDB 1,[BLKSTA(1)]	;GET STATE NOW
	CAIE 1,3		;WAKE UP IF DONE
	 JRST 0(4)
	JRST 1(4)


;ACCEPTS 1/ 1B0 FOR WRITE DIRECTION (OUTPUT)
;	    0B0 FOR READ DIRECTION (INPUT)
;	 2/ LINE #


;RETURNS +1 ALREADY ACTIVE, INDEX OF CHAIN TAIL IN 1
;	 +2 OK  NOTHING ACTIVE OR QUEUED

BLKGOK:	MOVE 3,TYMBKS(2)	;GET FLAGS
	TLNE 1,(1B0)		;WHICH DIRECTION
	 JRST BLKGO1		;WRITING
	TLNN 3,BKIACT		;ACTIVE?
	 JRST SKPRET		;NO-NO CONFLICTS
	LDB 1,[BKINDX(2)]	;YES-GET THE INDEX OF HEAD OF CHAIN
	JRST BLKGO2		;CHASE AND RETURN TAIL

BLKGO1:	TRNN 3,BKOACT		;ACTIVE?
	 JRST SKPRET		;NO-NO CONFLICTS
	LDB 1,[BKONDX(2)]	;YES-GET INDEX OF HEAD OF CHAIN
BLKGO2:	SKIPGE 2,BLKCHN(1)	;TAIL OF CHAIN?
	 RET			;YES-ITS INDEX IN 1
	MOVE 1,2
	JRST BLKGO2		;CHASE TIL TAIL SEEN





;BLOCK INPUT COMPLETE
;MESSAGE TYPE IN 3
;LINE IN 2, ALREADY PASSED CONNECTION TEST

;POSSIBLE ERRORS: BLKERB OUT OF BUFFER (TYMINB)    RETURNED COUNT IS VALID
;		  BLKERT TIMEOUT BY BASE (TYMINT)  RETURNED COUNT IS VALID

TIMINB:	MOVSI 3,BLKERB		;ERROR - OUT OF BUFFER
	JRST TIMNE0

TIMINT:	MOVSI 3,BLKERT		;ERROR - BASE TIMEOUT
	JRST TIMNE0


TIMINE:	SETZ 3,			;NO ERROR - COMPLETED
TIMNE0:	MOVE 1,TYMBKS(2)	;ERROR BITS IN 3
	TLNE 1,BKIMOD		;BLOCK MODE?
	TLNN 1,BKIACT		;AND ACTIVE INPUT SIDE?
	 JSP 1,NOBLKM		;NO-ERROR
	TLNE 1,BKIRTY		;THIS MUST BE OFF
	 JSP 1,NOBLKM		;CAN'T BE RETRYING IF HERE
	LDB 7,[BKINDX(2)]	;GET BLOCK MODE QUEUE INDEX
	LDB 1,PISUBT		;GET HI PART OF RETURNED COUNT
	LSH 1,^D8		;INTO POSITION
	LDB 2,PIDATA		;GET LO PART OF RETURNED COUNT
	IOR 1,2			;COUNT IN 1
	CAILE 1,777		;CHECK FOR LEGAL COUNT
	 BUG (HLT,<TYMSRV: IMPOSSIBLE RETURNED BLOCK INPUT COUNT>)
	IOR 1,3			;ENTER ERROR BITS INTO LH
	MOVEM 1,BLKRET(7)	;STORE ERROR BITS,,RETURNED COUNT
	MOVSI 2,BLKERF		;ERROR FLAG FOR QUEUE ENTRY
	TLNE 1,-1		;ANY XFER ERRORS?
	 IORM 2,BLKSTL(7)	;YES-SET FLAG IN ENTRY
	MOVE 3,BLKSTL(7)	;GET FLAGS
	TLNN 3,BLKRSF		;RETURN STATUS STUFF IN HEADER?
	 JRST TIMNE1		;NO
	HRRZ 1,BLKRET(7)	;GET RETURNED COUNT
	LSH 1,^D9		;INTO POSITION
	HLL 1,BLKRET(7)		;MAKE <ERROR BITS,,RET CNT,0>
	HRRZ 2,BLKADR(7)	;GET REAL CORE PAGE IN 2
	LSH 2,^D9		;MAKE IT REAL CORE ADR
	CALL RCIORM		;IORM 1,RCA
TIMNE1:	MOVEI 1,3		;GO TO STATE 3
	DPB 1,[BLKSTA(7)]
	MOVSI 1,BKIACT		;SAY NO MORE ACTIVE INPUT
	HRRZ 2,BLKSTL(7)	;LINE #
	ANDCAM 1,TYMBKS(2)	;NO MORE ACTIVE BLK INPUT FOR LINE
	SKIPGE 1,BLKCHN(7)	;GET NDX OF NEXT ON QUEUE
	 JRST TIMNE2		;NONE-THIS WAS THE TAIL
	HRRZ 2,BLKSTL(1)	;GET ITS LINE (MUST BE THE SAME)
	DPB 1,[BKINDX(2)]	;STORE ACTIVE INPUT INDEX IN LINE TABLE
	MOVSI 3,BKIACT		;FLAG IT IS ACTIVE
	IORM 3,TYMBKS(2)
	MOVEI 3,2		;AND STEP IT TO STATE 2
	DPB 3,[BLKSTA(1)]	
	MOVE 1,BLKADR(1)	;COUNT,,REAL CORE PAGE IN 1 (ABANDON NDX)
	MOVEI 3,TYPBIN
	CALL OTYPEH		;INPUT START BLK IO
	 JRST [MOVSI 1,BKIRTY	;ORING FULL, ACS OK-TELL SCHED TO RETRY
	       IORM 1,TYMBKS(2)	;INTO LINE FLAGS
	       JRST .+1]
TIMNE2:	MOVE 1,BLKSTL(7)	;GET TERMINATED ENTRY STATUS BITS AGAIN
	TLNN 1,BLKINF		;GIVE INTERRUPT AND CLEAN UP?
	 AOJA IPTR,TYMIN1	;NO-FORK WILL WAKE ON TRANSITION TO STATE 3
	TLNN 1,BLKULF		;YES-NEED TO UNLOCK THE PAGE?
	 JRST TIMNE3		;NO
	MOVE 1,BLKUPG(7)	;GET INFO
	CALL MULKPG		;DO IT
TIMNE3:	HRRZ 2,BLKSTL(7)	;LINE #
	MOVEI 3,^D33		;THIS TERMINAL CODE FOR INPUT DONE INTS
	CALL TYMPSI		;ISSUE INT 
	MOVE 1,7		;UNLOCK ENTRY
	CALL ULKBLK
	AOJA IPTR,TYMIN1	;DO NEXT MESSAGE


TIMIHR:	MOVE 1,TYMBKS(2)	;GET LINE BLK MODE STATUS
	TLZN 1,BKIIHR		;WAS IHR OUTSTANDING? (TURN IT OFF)
	 BUG (CHK,<TYMSRV: TYPIHR RCVD UNEXPECTEDLY>)
	MOVEM 1,TYMBKS(2)	;STORE NEW STATUS
	AOJA IPTR,TYMIN1



NOBLKM:	BUG(CHK,<TYMSRV: BLOCK IO MESSAGE FOR LINE IN BAD BLOCK MODE STATE>)
	JRST IGNORE

;BLOCK OUTPUT COMPLETE
;MESSAGE TYPE IN 3
;LINE IN 2, ALREADY PASSED CONNECTION TEST


TIMBOC:	SETZ 3,			;NO ERROR - COMPLETED
TIMBO0:	MOVE 1,TYMBKS(2)	;NOT AN ERROR
	TRNE 1,BKOMOD		;BLOCK MODE?
	TRNN 1,BKOACT		;AND ACTIVE OUTPUT SIDE?
	 JSP 1,NOBLKM		;NO-ERROR
	TRNE 1,BKORTY		;THIS MUST BE OFF
	 JSP 1,NOBLKM		;CAN'T BE RETRYING IF HERE
	LDB 7,[BKONDX(2)]	;GET BLOCK MODE QUEUE INDEX
	HLRZ 1,BLKADR(7)	;GET 0,,DESIRED COUNT
	IOR 1,3			;ENTER ERROR BITS INTO LH
	MOVEM 1,BLKRET(7)	;STORE ERROR BITS,,RETURNED COUNT (FAKE)
	MOVSI 2,BLKERF		;ERROR FLAG FOR QUEUE ENTRY
	TLNE 1,-1		;ANY XFER ERRORS?
	 IORM 2,BLKSTL(7)	;YES-SET FLAG IN ENTRY
	MOVE 3,BLKSTL(7)	;GET FLAGS
	TLNN 3,BLKRSF		;RETURN STATUS STUFF IN HEADER?
	 JRST TIMBO1		;NO
	HRRZ 1,BLKRET(7)	;GET RETURNED COUNT
	LSH 1,^D9		;INTO POSITION
	HLL 1,BLKRET(7)		;MAKE <ERROR BITS,,RET CNT,0>
	HRRZ 2,BLKADR(7)	;GET REAL CORE PAGE IN 2
	LSH 2,^D9		;MAKE IT REAL CORE ADR
	CALL RCIORM		;IORM 1,RCA
TIMBO1:	MOVEI 1,3		;GO TO STATE 3
	DPB 1,[BLKSTA(7)]
	MOVEI 1,BKOACT		;SAY NO MORE ACTIVE OUTPUT
	HRRZ 2,BLKSTL(7)	;LINE #
	ANDCAM 1,TYMBKS(2)	;NO MORE ACTIVE BLK OUTPUT FOR LINE
	SKIPGE 1,BLKCHN(7)	;GET NDX OF NEXT ON QUEUE
	 JRST TIMBO2		;NONE-THIS WAS THE TAIL
	HRRZ 2,BLKSTL(1)	;GET ITS LINE (MUST BE THE SAME)
	DPB 1,[BKONDX(2)]	;STORE ACTIVE OUTPUT INDEX IN LINE TABLE
	MOVEI 3,BKOACT		;FLAG IT IS ACTIVE
	IORM 3,TYMBKS(2)
	MOVEI 3,2		;AND STEP IT TO STATE 2
	DPB 3,[BLKSTA(1)]	
	MOVE 1,BLKADR(1)	;COUNT,,REAL CORE PAGE IN 1 (ABANDON NDX)
	MOVEI 3,TYPBKO
	CALL OTYPEH			;OUTPUT START BLK IO
	 JRST [MOVEI 1,BKORTY	;ORING FULL-ACS OK, TELL SCHED TO RETRY
	       IORM 1,TYMBKS(2)	;INTO LINE FLAGS
	       JRST .+1]
TIMBO2:	MOVE 1,BLKSTL(7)	;GET TERMINATED ENTRY STATUS BITS AGAIN
	TLNN 1,BLKINF		;GIVE INTERRUPT AND CLEAN UP?
	 AOJA IPTR,TYMIN1	;NO-FORK WILL WAKE ON TRANSITION TO STATE 3
	TLNN 1,BLKULF		;YES-NEED TO UNLOCK THE PAGE?
	 JRST TIMBO3		;NO
	MOVE 1,BLKUPG(7)	;GET INFO
	CALL MULKPG		;DO IT
TIMBO3:	HRRZ 2,BLKSTL(7)	;LINE #
	MOVEI 3,^D34		;THIS TERMINAL CODE FOR OUTPUT DONE INTS
	CALL TYMPSI		;ISSUE INT 
	MOVE 1,7		;UNLOCK ENTRY
	CALL ULKBLK
	AOJA IPTR,TYMIN1	;DO NEXT MESSAGE

TIMOHR:	MOVE 1,TYMBKS(2)	;GET LINE BLK MODE STATUS
	TRZN 1,BKOOHR		;WAS IHR OUTSTANDING? (TURN IT OFF)
	 BUG (CHK,<TYMSRV: TYPOHR RCVD UNEXPECTEDLY>)
	MOVEM 1,TYMBKS(2)	;STORE NEW STATUS
	AOJA IPTR,TYMIN1



	END

