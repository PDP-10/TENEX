	TITLE MAKLIB
		SUBTTL    10-JAN-75		JANET I. EGAN /JIE
	;ORIGINALLY KNOWN AS FUDGE2 AUTHOR ED YOURDON
	CUSTVR==0
	DECVER==1
	DECMVR==0
	DECEVR==6

	LOC   137
		<.JBVER=<DECVER>B11+<DECMVR>B17+<DECEVR>>
	RELOC
	SEARCH	C,SCNMAC
IFNDEF	PURESW,<PURESW==1>
IFN	PURESW,<TWOSEGMENTS
	LOW:	RELOC	400000>

;MAKLIB ACCUMULATOR DEFINITIONS

	F=0		;FLAGS
	T1=1		;TEMPORARIES
	A=T1
	T2=2
	B=T2
	T3=3
	T=T3
	C=4
	T4=C

	D=5
	P1=5
	E=6
	N=7
	G=10
	FPT=12
	R=13
	S=14
	DIS=15
	PTR=16
	P=17
MAXMOD==^D20		;MAXIMUM NUMBER OF MODULE NAMES PER COMMAND
FSSIZE==.FXLEN+1+MAXMOD		;LNTH OF SPEC AREA INCL SWTCHS & NAMES
.FXPRG==.FXLEN+1		;PROGRAM NAME POINTER


SW.APP==1B18		;APPEND
SW.DEL==1B19		;DELETE
SW.EXT==1B20		;EXTRACT
SW.INS==1B21		;INSERT
SW.MAS==1B22		;MASTER
SW.REP==1B23		;REPLACE

SW.LST==1B35		;LIST
SW.NOL==1B34		;DELETE LOCAL SYMBOLS
SW.POI==1B33		;LIST ENTRY POINTS
SW.IND==1B32		;INDEX
SW.BAC==1B31
SW.ADV==1B30
SW.EOT==1B29
SW.REW==1B28
SW.ZER==1B27

;INPUT-OUTPUT CHANNELS
LSTO==0		;ASCII OUTPUT CHANNEL
OBIN==1		;BINARY OUTPUT CHANNEL
MIN==2		;MASTER FILE INPUT CHANNEL
TRIN==3		;TRANSACTION FILE INPUT
	SUBTTL REVISION HISTORY

	;START OF MAKLIB VERSION 1
	;FORMERLY FUDGE2
	;EDITS TO FUDGE2 VERSION 16
	;46	(9164) IGNORE SPACE (RATHER THAN SAME AS COMMA)
	;47	INCREASE SIZE OF ENTRY BLOCK TO 200 FOR SAIL LIBRARY
	;50	CORRECT LOOP IN PROCESSING F40 REL FILES, SPR 14,133
	;	JNT, 18-OCT-74
	;01	MAKE ALL SWITCHES EXCEPT INDEX AND INSERT(BECAUSE NOT
	;	UNIQUE TO ONE LETTER) RECOGNIZABLE AS ONE LETTER
	;	ABBREVIATIONS.
	;02	ISSUE CORRECT ERROR MESSAGE FOR PROTECTION VIOLATION.
	;03	DO NOT ALLOW INDEX,NOLOCAL,LIST,POINTS ON OUTPUT
	;	SINCE THIS CAUSES INPUT SWITCHES NOT TO BE
	; 	PROCESSED AND SWITCHES ON OUTPUT DON'T MAKE SENSE.
	;	QAR DATED 24-JUN-75
	;	FIXED	15-JUL-75
	;04	MAKLIB DOES NOT REPLACE SPECIFIED EXTENSION WITH
	;	.LST ON LIST AND POINTS.
	;	QAR	DATED 16-MAY-75
	;	FIXED	15-JUL-75
	;05	ERROR MESSAGE FOR MODULES OUT OF ORDER CHANGED FROM
	;	"FOO NOT FOUND" TO "FOO NOT FOUND OR MODULE
	;	NAMES NOT IN SEQUENCE".
	;	QAR DATED 16-MAY-75    FIXED 16-JUL-75


	SUBTTL INITIALIZE AND SETUP OF MAKLIB
MAKLIB:
	TDZA	T1,T1			; IN CASE OF CCL ENTRY
	MOVEI	T1,1		;COMPUTE STARTING OFFSET
	RESET			;RESET I/O DEVICES
	MOVE	[XWD	LOW,LOW+1]
	SETZM	LOW
	BLT	LOWTOP-1
IFN	PURESW,<
	MOVE	[XWD	HIGH,LOW]
	BLT	LOWBLK>
	MOVE	P,[IOWD 200,PDLIST] ;SET UP PUSHDOWN POINTER
	MOVEM	T1,OFFSET	;STORE STARTING OFFSET

	MOVE	T1,[2,,[0
			XWD	OFFSET,'LIB'] ;MY OFFSET AND CCL NAME
		]
	PUSHJ	P,.ISCAN##	;INITIALIZE SCAN
	MOVE	T1,.JBFF##	;SAVE .JBFF
	MOVEM	T1,ORGFF	;  FOR LATER

	SUBTTL	MAKLIB COMMAND SCANNER

MAKSCN:				;SCAN ARGUMENT BLOCK
	SETZ	F,
	MOVE	T1,[11,,[IOWD MKLSWL,MKLSWN
			XWD MKLSWD,MKLSWM
			XWD  0,MKLSWP
			-1
			XWD  CLRANS,0
			XWD ALLIN,ALLOUT
				0
				0
			XWD 0,STORER
			]]
	PUSHJ	P,.TSCAN##		;SCAN THE COMMAND LINE
	PUSHJ	P,CHECK		;SEE IF EVERYTHING IS THERE
	SETZM	WLDTMP		;CLEAR OUT TEMPORARY AREA FOR WILD
	MOVE	T1,OUTBEG		;TELL SCAN START OF OUTPUT SPEC
	MOVEI	T2,OPNBLK		;  NAME OF OPEN BLOCK
	MOVE	T3,[.RBSIZ+1,,LKPBLK]	;   LOOKUP BLOCK
	HLRZM	T3,LKPBLK
	PUSHJ	P,.STOPN##		;SCAN BLKS TO OPEN &LOOKUP BLKS
		JRST	EXIT
	JRST	SWTPRC			;NOW TO PROCESS THE SWITCHES



OPNFAI:	PUSHJ	P,E.DFO##
	JRST	MAKSCN		;GO PROMPT AGAIN
LKPFAI:
	MOVEI	T1,LKPBLK
	MOVEI	T2,6
	MOVEI	T3,INBEG
	PUSHJ	P,E.LKEN##
	JRST	MAKSCN

DM	XXX,1,0,0

DEFINE	SWTCHS,<
	SP	*APPEND,SW.APP,.SWSIX##,XXX
	SP	*DELETE,SW.DEL,.SWSIX##,XXX
	SP	*EXTRAC,SW.EXT,.SWSIX##,XXX
	SP	INSERT,SW.INS,.SWSIX##,XXX
	SP	*MASTER,SW.MAS,.SWSIX##,XXX
	SP	*REPLAC,SW.REP,.SWSIX##,XXX
	SS	*LIST,<POINTR (SWIWRD,SW.LST)>,1,FS.NUE
	SS	*NOLOC,<POINTR (SWIWRD,SW.NOL)>,1,FS.NUE
	SS	*POINTS,<POINTR (SWIWRD,SW.POI)>,1,FS.NUE
	SS	INDEX,<POINTR (SWIWRD,SW.IND)>,1,FS.NUE
>
DOSCAN(MKLSW)



CLRANS:
	SETZM	SWIWRD
	MOVE	T1,[SWIWRD,,SWIWRD+1]	;POINT TO WORD FULL OF SWITCHES
	BLT	T1,CURFIL		;CLEAR OUT CURRENT ANSWER
	MOVE	T1,ORGFF		;RESTORE
	MOVEM	T1,.JBFF##		;  .JBFF
	POPJ	P,



ALLOUT:
	MOVE	T1,.JBFF##		;POINT TO
	MOVEM	T1,OUTEND		;  END OF OUTPUT AREA
	SKIPN	OUTBEG			;HAVE WE STARTED ALREADY?
	MOVEM	T1,OUTBEG		;NO--THIS IS THE BEGINNING
	JRST	ALLOC1
ALLIN:
	MOVE	T1,.JBFF##		;POINT TO
	MOVEM	T1,INEND		; END OF INPUT AREA
	SKIPN	INBEG			; IF WE HAVEN'T STARTED YET
	MOVEM	T1,INBEG		;  THIS IS THE BEGINNING
ALLOC1:
	MOVEM	T1,CURFIL
	MOVEI	T2,FSSIZE-1(T1)
	CAMG	T2,.JBREL##
	JRST	ALLOC2
	CORE	T2,
	  JRST	ERR22
ALLOC2:
	HRLI	T1,TMAREA
	BLT	T1,(T2)
	MOVE	T1,CURFIL
	SETZM	TMAREA+.FXLEN
	MOVEI	T2,FSSIZE
	ADDM	T2,.JBFF##
	POPJ	P,



STORER:
	TLZ	T2,-1
	TRC	T2,-1
	TDNE	T2,TMAREA+.FXLEN
	   JRST	ERTMS
	TRC	T2,-1
	IORM	T2,TMAREA+.FXLEN
	JUMPE	N,CPOPJ
	HLRZ	T2,TMAREA+.FXLEN
	CAIL	T2,MAXMOD
	  JRST	ERROR2

	AOS	T2
	HRLM	T2,TMAREA+.FXLEN
	MOVEM	N,TMAREA+.FXLEN(T2)
	POPJ	P,



CHECK:
	SKIPN	T1,OUTBEG		;IS THERE  AN OUTPUT SPEC?
	   JRST ERROR1				;ERROR IF NONE
	SKIPN	T2,INBEG		;POINT TO INPUT AREA
	  JRST	ERROR1
	SKIPE	.FXNAM(T1)		;IS THERE A FILENAME?
	JRST	CHECK1			;YES--GOOD
	SKIPN	T3,.FXNAM(T2)		;IF THERE'S A MASTER
	   JRST	ERROR6			;ERROR IF NO MASTER
	MOVEM	T3,.FXNAM(T1)		;USE NAME OF MASTER INSTEAD
	SETOM	T3,.FXNMM(T1)		;MASK IT 'CAUSE NOT WILD
CHECK1:
	SKIPE	T3,.FXEXT(T1)		;IS THERE AN EXT SPECIFIED?
	JRST	CHECK2			;EXT ALREADY THERE GO ON
	MOVE	C,.FXMOD(T1)		;CHECK MODIFIER WORD TO SEE
	TXNN	C,FX.NUL		; IF EXPLICITLY NULL EXT
	JRST 	CHK1A
	MOVE	P1,SWIWRD		;GET THE SWITCHES
	TXNE	P1,SW.LST!SW.POI	;LIST OR POINTS SPECIFIED?
	JRST	CHK1B		;IF YES LST IS DEFAULT
	HRLOI	T3,'REL'		;IF NONE--REL IS DEFAULT
CHK1A:	MOVEM	T3,.FXEXT(T1)		;SO FILL IT IN
	JRST	CHECK2
CHK1B:	 HRLOI	T3,'LST'
	MOVEM T3,.FXEXT(T1)
CHECK2:
	SKIPE	T3,.FXLEN(T1)		;ANY SWITCH SEEN?
	  JRST	ERRSIO			;SWITCHES ILLEGAL ON OUTPUT
	SKIPN	T3,.FXNAM(T2)		;MASTER FILENAME THERE?
	   JRST	ERROR6			;NOT ENOUGH ARGUMENTS
	SKIPE	T3,.FXEXT(T2)		;NO EXT SPECIFIED?
	JRST	CHECK4			;EXT ALREADY THERE
	MOVE	C,.FXMOD(T2)		;CHECK MODIFIER WORD TO SEE
	TXNE	C,FX.NUL		;IF NULL EXT SPECIFIED
	HRLOI	T3,'REL'		;IF NONE .REL IS DEFAULT
	MOVEM	T3,.FXEXT(T2)		;SO FILL IN DEFAULT
CHECK4:
	MOVE	T3,.FXLEN(T2)		;ANY SWITCH THERE?
	JUMPE	T3,CHECK6		;NO SWITCH,SEE IF THAT'S OK
	TRNE	T3,SW.INS+SW.REP	;INSERT OR REPLACE?
	  JRST	ERIRT			;NOT ALLOWED ON MASTER
	TXNN	T3,SW.APP		;APPEND SPECIFIED?
	JRST	CHECKE			;NO-DON'T WORRY ABOUT IT
	CAIE	 T3,400000		;IF NO COUNT WE'RE O.K.
	OUTSTR	[ASCIZ/%WARNING-ENTIRE MASTER FILE WILL BE APPENDED
/]					;YES-GIVE WARNING
	JRST	CHECKE			;AND CONTINUE
CHECK5:
	MOVE	T3,.FXLEN(T2)		;POINT TO SWITCHES
	JUMPE	T3,CHECK6		;NONE THERE
	TRNE	T3,SW.MAS		;MASTER?
	  JRST	ERMTF			;NOT ALLOWED ON TRANSACTION
	SKIPE	T3,.FXEXT(T2)		;IS AN EXT SPECIFIED?
	JRST	CHECKE			;EXT ALREADY THERE
	MOVE	C,.FXMOD(T2)		;SEE IF NULL EXT
	TXNE	C,FX.NUL		;ALREADY SPECIFIED
	HRLOI	T3,'REL'		;IF NONE REL IS DEFAULT
	MOVEM	T3,.FXEXT(T2)		;SO FILL IT IN
	JRST	CHECKE			;AND FINISH UP
CHECK6:
	CAME	T2,INBEG		;IS THIS THE MASTER FILE?
	JRST 	ERR1A			;NO--THEN SWITCH REQUIRED
	CAME	T2,INEND		;SEE IF ANY TRANS FILES
	JRST	CHECKE			;YES THEN CONTINUE
	MOVE	T1,SWIWRD		;GET SWITCHES
	JUMPE	T1,ERR1A		;ERROR IF NONE
	JRST	CHECKE			;CONTINUE IF NO ERROR

CHECKE:
	ADDI	T2,FSSIZE	;INCREMENT THE POINTER
	CAMG	T2,INEND	;RUN OUT OF ROOM OR TRANS FILES YET?
	JRST	CHECK5		;MORE TRANS	FILES
	POPJ	P,
;ROUTINE TO OPEN AND LOOKUP FILES AND DISPATCH SWITCHES
SWTPRC:
	MOVE	T2,SWIWRD		;GET SWITCH BITS
	TXNN	T2,SW.LST!SW.POI	;WANT LISTING?
	JRST IDXCHK			;SEE IF WANT INDEXING
	MOVE T1,INBEG		;GET POINTER TO INPPUT FILE
	SKIPE	.FXLEN(T1)		;IS THERE ANOTHER SWITCH?
	   JRST	ERTMS			;LIST AND POINTS MUST BE ALONE
	TLZ	F,LSTENT		;CLEAR ENTRY POINT LIST FLAG
	TXNE	T2,SW.POI		;LIST ENTRY POINTS?
	TLO	F,LSTENT		;SET FLAG TO LIST ENTRIES
	MOVE	T1,OUTBEG		;POINT  TO THE OUTPUT SPEC
	MOVE	T1,.FXDEV(T1)		;PUT THE OUTPUT DEVICE IN T1
	CAIE	T1,'TTY'		;IS IT THE TTY?
	TRO	F,TTYOB			;NO--SET FLAG FOR NON-TTY OUTPUT
	PUSHJ	P,OPNLKO		;YES--OPEN INPUT&OUTPUT
	PUSHJ	P,LIST			;CALL LISTING ROUTINE
	JRST	INDCLS			;CLOSE AND GO BACK TO START
IDXCHK:
	TXNN	T2,SW.IND		;WANT INDEXING?
	JRST	NOLCHK			;NO--OTHER THINGS
	MOVE 	T1,INBEG	;GET POINTER TO INPUT SPEC
	SKIPE	.FXLEN(T1)		;ANOTHER SWITCH THERE?
	   JRST	ERTMS			;INDEX MUST BE ALONE
	TRO	F,TTYOB			;NON-TTY OUTPUT
	PUSHJ	P,INDOPN		;OPEN I/O STUFF
	PUSHJ	P,INDEX			;DO THE INDEXING
	PUSHJ	P,INDCLS		;FINISHED  SO CLOSE
	JRST	MAKSCN			;AND BEGIN AGAIN
NOLCHK:
	TXNN	T2,SW.NOL		;DELETE LOCAL SYMBOLS?
	JRST	SWTDIS			;NO--OTHER THINGS
	MOVE	T1,INBEG		;POINTER TO INPUT SPEC
	SKIPE	.FXLEN(T1)		;NOLOCALS MUST BE ALONE
	   JRST	ERTMS			;TELL HER TOO MANY SWITCHES
	TRO	F,TTYOB			;NON-TTY OUTPUT
	PUSHJ	P,INDOPN		;OPEN BINARY OUTPUT
	PUSHJ	P,DELCPY		;GO DELETE AND COPY
	JRST	MAKSCN			; BEGIN AGAIN


;
;SUBROUTINES FOR OPEN AND CLOSE CONNECTED WITH /LIST /INDEX /NOLOCAL
;

OPNLKO:
	MOVX	T1,.IOASC		;ASCII OUTPUT FOR LISTING
	IORM	T1,OPNBLK+.OPMOD	
	MOVSI	T1,OBUF+<LSTO*3>	;CALCULATE BUFFER HEADER PTR
	MOVEM	T1,OPNBLK+2		; FOR OPEN BLOCK
	TRNE	F,TTYOB			;TEST FOR NON-TTY OUTPUT
	JRST	OPNLK1			;YES THEN USE OTHER CHANNEL
	OPEN	LSTO,OPNBLK		;OPEN OUTPUT FOR LISTING
	   JRST	OPNFAI				;NO CAN DO
	ENTER	LSTO,LKPBLK		;ENTER THE OUTPUT FILE

	  JRST   LKPFAI				;CAN'T
OPNLK1:
	MOVSI	T1,OBUF+<OBIN*3>
	MOVEM	T1,OPNBLK+2
	OPEN	OBIN,OPNBLK
	   JRST	OPNFAI
	ENTER	OBIN,LKPBLK
	  JRST   LKPFAI
	MOVE	T1,[4,,[INBEG,,INEND	;POINTERS TO INPUT AREA
			OPNBLK,,LKPBLK	;OPEN & LOOKUP BLOCKS
			FSSIZE,,.RBSIZ+1;SIZE OF INSPEC&LKPBLK
			WLDTMP+1B0]]	;ALL FOR LKWLD
	PUSHJ	P,.LKWLD##		;WILD LOOKS FOR MASTER FILE
	   JRST	OPNLKE			;DONE LOOKING GO TO END
	SETZM	NAMCTR			;CLEAR PROG NAME COUNTER
	MOVX	T1,.IOBIN		;BINARY FOR MASTER INPUT
	IORM	T1,OPNBLK+.OPMOD
	MOVEI	T1,IBUF+<MIN*3>		;CALCULATE BUFFER HEADER POINTER
	MOVEM	T1,OPNBLK+2
	OPEN	MIN,OPNBLK		;MASTER INPUT ON CHANNEL MIN
	   JRST	OPNFAI			;CAN'T DO IT
	LOOKUP	MIN,LKPBLK		;DO THE LOOKUP
	   JRST	LKPFAI			;CAN'T
	INBUF	MIN,1			;SET UP BUFFER FOR MASTER
OPNLKE:
	POPJ	P,			;READY TO GO



LIOCLS:
	CLOSE	LSTO,			;DONE WITH THIS CHANNEL
	STATZ	LSTO,760000		;CHECK FOR ERROR
	   JRST  ERR999			;ERROR
	CLOSE	MIN,			;INPUT CHANNEL TOO
	STATZ	MIN,760000		;CHECK
	   JRST	ERR999			;ERROR
	POPJ	P,			;GO BACK



INDOPN:
	MOVX	T1,.IOBIN		; FOR TRANSACTION OUTPUT TOO
	IORM	T1,OPNBLK+.OPMOD
	MOVSI	T1,OBUF+<OBIN*3>	;CALCULATE BUFFER HEADER POINTER
	MOVEM	T1,OPNBLK+2		;PUT POINTER IN THE OPEN BLOCK
	OPEN	OBIN,OPNBLK		;BINARY OUTPUT ON CH. OBIN
	   HALT  			;CAN'T OPEN
	ENTER	OBIN,LKPBLK		;ENTER THE FILE
	   JRST   LKPFAI 			;CAN'T
	MOVE	T1,[4,,[INBEG,,INEND	;INFO FOR WILD
			OPNBLK,,LKPBLK
			FSSIZE,,.RBSIZ+1
			WLDTMP+1B0]]
	PUSHJ	P,.LKWLD##		;WILD
	    JRST	INDOPE		;END
	SETZM	NAMCTR			;CLEAR PROGRAM NAME COUNTER
	MOVX	T1,.IOBIN
	IORM	T1,OPNBLK+.OPMOD
	MOVEI	T1,IBUF+<MIN*3>		;CALCULATE BUFFER HEADER POINTER
	MOVEM	T1,OPNBLK+2		;AND PUT IT IN THE OPEN BLOCK
	OPEN	MIN,OPNBLK		;OPEN
	      JRST	OPNFAI		;CAN'T
	LOOKUP	MIN,LKPBLK		;LOOKUP
	      JRST	LKPFAI		;CAN'T
	INBUF	MIN,
INDOPE:
	POPJ	P,



INDCLS:
	TRNN	F,TTYOB			;WAS OUTPUT ON TTY?
	JRST	MAKSCN			;THEN CHANNEL WAS NOT OPEN
	CLOSE	OBIN,			;DO LAST BLOCK
	STATZ	OBIN,760000		;CHECK FOR ERROR
	  JRST	ERR999			;ERROR
	CLOSE	MIN,			;DONE WITH INPUT TOO
	STATZ	MIN,760000		;CHECK FOR ERROR
	  JRST	ERR999			;ERROR
	JRST	 MAKSCN
TRNCLS:
	CLOSE	TRIN,
	STATZ	TRIN,760000
	   JRST ERR999
	POPJ	P,
SWTDIS:
	TRO	F,TTYOB		;NON-TTY OUTPUT
	MOVE	T1,OUTBEG		;GET OUTPUT SPEC
	MOVS	T1,.FXDEV(T1)		;WHAT DEVICE?
	CAIN	T1,'TTY'		;TTY LOSES
	   JRST	ERR23	
	MOVX	T1,.IOBIN		;BINARY OUTPUT
	IORM	T1,OPNBLK+.OPMOD
	MOVSI	T1,OBUF+<OBIN*3>	;CALCULATE BUFFER HEADER POINTER
	MOVEM	T1,OPNBLK+2		;AND PUT IT IN THE OPEN BLOCK
	OPEN	OBIN,OPNBLK
	   JRST	OPNFAI
	ENTER	OBIN,LKPBLK
	   JRST   LKPFAI
	MOVE	T1,[4,,[INBEG,,INEND
			OPNBLK,,LKPBLK
			FSSIZE,,.RBSIZ+1
			WLDTMP+1B0]]
	PUSHJ	P,.LKWLD##
	  HALT
	SETZM	NAMCTR			;CLEAR PROG NAME COUNTER
	MOVX	T1,.IOBIN
	IORM	T1,OPNBLK+.OPMOD
	MOVEI	T1,IBUF+<MIN*3>		;GET BUFFER HEADER POINTER
	MOVEM	T1,OPNBLK+2		;  FOR THE OPEN BLOCK
	OPEN	MIN,OPNBLK
	   JRST	OPNFAI
	LOOKUP	MIN,LKPBLK
	    JRST	LKPFAI
	MOVE	T1,[LKPBLK,,SVEBLK]
	BLT	T1,SVEBLK+5
	INBUF	MIN,
	JRST	SWT2
SWT1:
	MOVE	T1,[4,,[INBEG,,INEND
			OPNBLK,,LKPBLK
			FSSIZE,,.RBSIZ+1
			WLDTMP+1B0]]
	PUSHJ	P,.LKWLD##
	  JRST	INDCLS
	SETZM	TNMCTR			;CLEAR TRANS PROG NAME COUNTER
	MOVX	T1,.IOBIN
	IORM	T1,OPNBLK+.OPMOD
	MOVEI	T1,IBUF+<TRIN*3>	;GET BUFFER HEADER POINTER
	MOVEM	T1,OPNBLK+2		;  FOR THE OPEN BLOCK
	OPEN	TRIN,OPNBLK
	   JRST	OPNFAI
	LOOKUP	TRIN,LKPBLK
	   JRST	LKPFAI
	INBUF	TRIN,
SWT2:
	MOVE	PTR,WLDTMP
	HRLZ	T1,.FXLEN(PTR)
	JFFO	T1,.+2
	PUSHJ	P,MSTCHK		; SEE IF SPECIAL CASE FOR MASTER
	PUSHJ	P,@SWTBL(T2)		;PROCESS THE SWITCH
	JRST	SWT1
	  HALT
MSTCHK:
	CAME	PTR,INBEG		;IS THIS THE MASTER FILE?
	JRST	ERR1A			;NO-COMMAND SWITCH REQUIRED
	CAME	PTR,INEND		;ARE THERE ANY TRANS FILES?
	POPJ	P,			;YES-O.K. TO CONTINUE
	JRST	ERR1A			;NO-COMMAND SWITCH REQUIRED

ERR999:	EXIT	1,
SWTBL:
	APPEND
	DELETE
	EXTRCT
	INSERT
	MASTER
	REPLCE
SUBTTL	FLAGS
;FLAG DEFINITIONS (RIGHT HALF OF ACCUMULATOR F)

	TTYOB==	20		;1-NON-TTY OUTPUT;USED BY IO
	NOLOCB==200		;1-DELETE LOCAL SYMBOLS ***VJC
	ERRB==	2000		;1-ERROR IN ENTRY BLOCK CHECK
	F4IB==	20000		;1-IGNORE F4 OUTPUT
	CRLFTY==40000		;1-CR,LF TYPED (FOR ERROR MSG)
	XFLG==	200000		;1-INDEX THIS FILE
	DTAFLG==400000		;1-OUTPUT DEVICE IS DTA (SPECIAL INDEX)

;MORE FLAGS (LEFT HALF OF F)

	NOWARN==1		;1-DON'T TYPE WARNING ABOUT INDEX DELETED
	LSTENT==10		;1-LIST ENTRY BLOCK
	MSTMOD==100		;1-BEEN HERE BEFORE(REPLACE OR INSERT)



;OTHER USEFUL PARAMETER ASSIGNMENTS
	N==	200		;SIZE OF MASTER AND TRAN BUFFERS
	SIZE==	200		;SIZE OF PURE ENTRY BLOCK
	X==	SIZE+5		;SIZE OF ENTRY AND SAVE BLOCKS

	DEVNO==16		;NUMBER OF DEVICES ALLOWED

;JOBDAT SYMBOLS
EXTERN	.JBFF,.JBREL

TABS1==<^D120/7>-1		;NO OF TABS FOR OTHER THAN TTY
TABS2==<^D72/7>-1		;NO OF TABS FOR TTY


SUBTTL	MAKLIB COMMAND PROCESSORS

;LIST PROCESSOR
;THIS ROUTINE PROCESSES THE L COMMAND IN MAKLIB. BINARY
;PROGRAMS ARE READ, AND THEIR NAMES OUTPUT, UNTIL AN END
;OF FILE IS REACHED.


LIST:
	MOVE	A,INBEG		;POINT TO INPUT AREA
	MOVE	T,.FXNAM(A)	;GET MASTER FILE NAME
	SETOM	END2		;SIGNAL FIRST TIME THROUGH
	PUSHJ	P, MSTGET	;GET THE MASTER DEVICE
	JRST	ERROR6		;NOT ENOUGH ARGUMENTS
	TLO	F,NOWARN	;DON'T GIVE WARNING MESSAGE IF INDEX SEEN
LIST2:	PUSHJ	P, READ		;READ A PROGRAM NAME
	JRST	[TLNN	F,LSTENT	;LISTED ENTRIES?
		PUSHJ	P,LIST5	;NO, SO LIST RELOCATION
		JRST	EXIT]	;FINISHED
	TLNE	F,LSTENT	;LIST ENTRIES
	JRST	LIST4		;YES, SO NO SIZE
	SKIPL	END2		;BUT NOT FIRST TIME (NOT SET UP YET)
	PUSHJ	P,LIST5		;LIST RELOCATION WORDS
LIST4:	MOVE	B, A		;GET THE PROGRAM NAME IN B
	PUSHJ	P, PTYPO	;TYPE IT OUT
	TLNE	F,LSTENT	;ENTRY BLOCK AS WELL?
	JRST	LISTE		;YES
	JRST	LIST2		;RETURN FOR MORE PROGRAM NAMES

LISTE:	HRRZ	C,ENTBLK	;GET NUMBER OF ENTRIES
	JUMPE	C,LIST3		;NONE IN THIS PROGRAM
	MOVNS	C		;NEGATE
	MOVSS	C		;PUT IN LEFT HALF
	HRRI	C,ENTBLK+2	;START OF ENTRIES
	MOVEI	E,TABS1		;ASSUME NOT TTY
	TRNN	F,TTYOB		;WAS IT?
	MOVEI	E,TABS2		;TTY HAS SHORTER LINE
LISTE1:	SKIPN	B,(C)		;GET AN ENTRY
	AOJA	C,.-1		;IGNORE RELOCATION WORD
	PUSHJ	P,TYPTAB	;OUTPUT A TAB
	PUSHJ	P,PTYPO		;FOLLOWED BY SYMBOL
	AOBJN	C,LISTE1	;FOR ALL OF BLOCK
LIST3:	PUSHJ	P, CRLF		;TYPE A CRLF
	JRST	LIST2		;RETURN FOR MORE PROGRAM NAMES

LIST5:	PUSH	P,A		;SAVE NAME
	MOVE	B,END1		;GET FIRST END WORD
	TRNE	B,-1		;KLUDGE FOR FORTRAN
	JRST	LISTF		;YES, IT WAS
	PUSHJ	P,OCTOUT	;OUTPUT OCTAL NUMBER
	SKIPE	B,END2		;ONLY IF NOT ZERO
	PUSHJ	P,OCTOUT	;OUTPUT SECOND WORD
LISTF:	PUSHJ	P,CRLF		;T YPE CRLF AND RETURN
	POP	P,A		;RESTOR NAME
	TLZ	F,LSTENT	;CLEAR ENTRY POINT FLAG
	POPJ	P,

;MASTER IS A POPJ BACK TO THE SWITCH PROCESSING ROUTINE.
MASTER:	POPJ	P,
;REPLACE PROCESSOR
;THIS ROUTINE PROCESSES THE R COMMAND IN MAKLIB. THE TOTAL
;COMMAND STRING IS BROKEN INTO A LIST OF PROGRAMS FOR THE MASTER
;DEVICE, AND A LIST OF PROGRAMS FOR THE TRANSACTION DEVICES.
;THE ROUTINE READS THE MASTER FILE UNTIL ONE OF THE DESIRED
;REPLACEMENT PROGRAMS IS REACHED, THEN SWITCHES TO THE 
;TRANSACTION DEVICE TO FIND THE PROGRAM WHICH IS TO REPLACE THE
;PROGRAM IN THE MASTER FILE. AFTER THE REPLACEMENT HAS BEEN
;EFFECTED, RESET IS CALLED TO RESTORE THE MASTER DEVICE TO ITS
;OLD POSITION.

REPLCE:
	TLNE	F,MSTMOD	;SEE IF MASTER BEEN DIDDLED
	PUSHJ	P,RESET		;YES--RESET IT
	TLNE	F,MSTMOD	;ONCE AGAIN
	JRST REPLC2
	PUSHJ	P, MSTGET	;GET A PROGRAM FROM MASTER DEVICE
	JRST	IPROC7		;NO MORE, COPY REST OF MASTER
REPLC2:	PUSHJ	P, COPYTO	;COPY UP TO THE PROGRAM NAME
	PUSHJ	P, TRNGET	;GET A PROGRAM FROM TRANSACTION
	JRST	ERROR5		;USER DID NOT SUPPLY ENOUGH?
	PUSHJ	P, FINDCP	;FIND THE PROGRAM AND COPY IT
	JRST	REPLCE		;LOOK FOR MORE REPLACEMENTS

SUBTTL INSERT PROCESSOR
;THIS SUBROUTINE PROCESSES THE I COMMAND IN FUDGE. IT READS AND
;WRITES PROGRAMS FROM THE MASTER FILE UNTIL IT FINDS THE
;PROGRAM NAME CURRENTLY POINTED TO, AT WHICH TIME IT STARTS READING
;FROM THE TRANSACTION DEVICE, MAKING AN INSERTION AT THE
;PROPER PLACE.

INSERT:
	PUSHJ	P, MSTGET	;GET A PROGRAM FROM MASTER FILE
	JRST	IPROC7		;NO MORE, COPY REST OF MASTER
	PUSHJ	P, COPYTO	;COPY UP TO A PROGRAM NAME
	MOVEM	C, SAVEAC	;SAVE SPECIAL ACCUMULATOR
	MOVE	D, [XWD ENTBLK,SVEBLK]
	BLT	D, X+1(C)	;MOVE ENTRY BLOCK INTO SAFE PLACE
	PUSHJ	P, TRNGET	;GET NEXT TRANSACTION FILE
	JRST	ERROR5		;NOT ENOUGH TRANSACTION FILES
	PUSHJ	P, FINDCP	;FIND TRANSACTION FILE AND COPY
	CAIE	D, 2		;HAS MASTER FILE BEEN JIGGLED?
	JRST	FIXUP		;NO, RESTORE THE ENTRY BLOCK
	PUSHJ	P, RESET	;YES, RESET IT
	JRST	INSER1		;WRITE OUTGO BACK FOR MORE INSERTIONS

FIXUP:	MOVE	C, SAVEAC	;RESTORE SPECIAL AC
	MOVS	D, [XWD ENTBLK,SVEBLK]
	BLT	D, (C)		;RESTORE ENTRY BLOCK
	MOVEI	D, 2		;SET UP CHANNEL AC
	MOVEI	DIS, 6		;SET UP BUFFER HEADER INDEX
INSER1:	PUSHJ	P, WRITE	;WRITE OUT THE CURRENT FILE
	JRST	INSERT		;GO BACK FOR MORE INSERTIONS

IPROC7:	PUSHJ	P, COPY		;COPY REST OF MASTER FILE
	JRST	INDCLS		;EXIT
 SUBTTL EXTRACT PROCESSOR
;THIS ROUTINE PROCESSES THE E COMMAND IN FUDGE. RATHER THAN
;ONE MASTER AND SEVERAL TRANSACTION FILES, ALL FILES ARE
;TREATED THE SAME. AFTER A CALL TO EITHER MSTGET OR TRNGET
;PROGRAMS ARE SEARCHED FOR AND WRITTEN ON THE OUTPUT DEVICE.

EXTRCT:	TLO	F,NOWARN	;NO WARNING MESSAGE
	PUSHJ	P, MSTGET	;GET A PROGRAM FROM MASTER DEVICE
	JRST	EPROC1		;ALL DONE WITH MASTER DEVICE
	JUMPN	R,.+3		;ANY PROGRAMS THIS FILE? **VJC
	PUSHJ	P,COPY		;NO, COPY ENTIRE FILE ***VJC
	JRST	EPROC1		; ***VJC
	PUSHJ	P, FINDCP	;FIND THE PROGRAM AND COPY IT
	JRST	EXTRCT		;RETURN FOR MORE MASTER PROGRAMS
EPROC1:
	PUSHJ	P, TRNGET	;GET PROGRAM FROM TRANS FILES
	POPJ	P,		;ALL DONE
	JUMPN	R,.+3		;ANY PROGRAMS THIS FILE?  ***VJC
	PUSHJ	P,COPY		;NO, COPY ENTIRE FILE ***VJC
	JRST	EPROC1		; ***VJC
	PUSHJ	P, FINDCP	;FIND THE PROGRAM AND COPY IT
	JRST	EPROC1		;RETURN FOR MORE TRANS FILES
SUBTTL DELETE PROCESSOR
;THIS ROUTINE PROCESSES THE DELETE COMMAND IN MAKLIB.  
;***ONLY ONE INPUT FILE WILL BE READ, AND THE PROGRAM NAMES ASSOCIATED
;WITH ITS LIST WILL BE DELETED.

DELETE:
	MOVEI	T1,INDCLS	; RESET RETURN ADDRESS
	HRRM	T1,(P)		;BECAUSE DELETE IS ONE TIME ONLY
DELET1:
	PUSHJ	P,MSTGET	; GET A PROGRAM FROM MASTER FILE
	  JRST	DELET3		; NO MORE SPECIFIED-FINISH OFF MASTER
	PUSHJ	P,RAD50		;CONVERT R TO RADIX 50
DELET2:
	PUSHJ	P,READ		; READ A PROGRAM
	  JRST	ERROR7		; EOF - PROGRAM NOT IN FILE
	CAMN	R,A		; IS THIS THE RIGHT PROGRAM
	JRST	DELET1		; YES - DELETE IT AND CONTINUE
	PUSHJ	P,WRITE		; NO - COPY THIS ONE
	JRST	DELET2		; AND CONTINUE LOOKING
DELET3:
	PUSHJ	P,COPY		; COPY OUT REST OF MASTER FILE
	POPJ	P,		; AND GO HOME

;APPEND PROCESSOR
;THIS ROUTINE HANDLES THE APPEND COMMAND IN MAKLIB.
;IT WILL COPY THE ENTIRE MASTER FILE, THEN START OBTAINING TRANSACTION
;FILES WITH CALLS TO TRNGET, APPENDING ONE OR MORE
;PROGRAMS FROM EACH FILE.

APPEND:
	MOVE	T1,WLDTMP	;CHECK FOR MASTER OR
	CAME	T1,INBEG	;  TRANSACTION FILE
	JRST	APPND1		;JUMP IF TRANSACTION FILE
	PUSHJ	P,MSTGET	;GET A PROGRAM  FROM MASTER FILE
	  HALT
	PJRST	COPY		;COPY ENTIRE FILE
APPND1:
	PUSHJ	P,TRNGET	;GET A PROGRAM NAME FROM TRANSACTION 
	  POPJ	P,		;NO MORE PROG NAMES IN THIS FILE
	PUSHJ	P,FINDCP	;FIND PROGRAM AND COPY IT
	JUMPE	R,CPOPJ		;ZERO NAME DON'T LOOP
	JRST	APPND1		;LOOP FOR MORE PROGRAMS

;THIS ROUTINE PROCESSES THE X COMMAND (INDEX LIBRARY)
;AND CAN FALL INTO DELETE LOCAL SYMBOLS CODE,IF DESIRED
;BY NOT SKIPPING TO DELCPY+1

INDEX:
	MOVE	A,OUTBEG	;GET OUTPUT DEVICE
	MOVE	A,.FXDEV(A)	
	DEVCHR	A,		;GET ITS CHARACTERISTICS
	TXNN	A,DV.DSK!DV.DTA ;ONLY ALLOW DSK AND DTA
	JRST	ERR23		;GIVE ERROR MESSAGE
	TLO	F,NOWARN	;NO WARNING MESSAGE IF /X
;	TRO	F,XFLG		;SET INDEX FLAG
	TROA	F,XFLG		;INDEX FLAG YES, DELETE LOCALS NO ***JIE
;DELETE LOCAL SYMBOLS AND COPY PROCESSOR
;THIS ROUTINE PROCESSES THE C COMMAND
;ONLY THE MASTER FILE IS HANDLED

DELCPY:	TRO	F, NOLOCB	;SET FLAG TO DELETE LOCAL SYMBOLS
	PUSHJ	P, MSTGET	;GET A PROGRAM FROM MASTER FILE
	JRST	ERROR6		;NOT ENOUGH ARGUMENTS
	PUSHJ	P,INDEX0	;SET UP POINTERS FOR INDEXING
	PUSHJ	P, COPY		;COPY ENTIRE FILE
	TRNN	F,XFLG		;INDEX FLAG ON?
	JRST	EXIT		;ALL DONE
	JRST	INDEX3		;YES DO PASS 2
SUBTTL	MAKLIB IO SUBROUTINES

;ROUTINES TO COPY FILES, COPY UP TO A GIVEN PROGRAM IN A FILE
;AND TO FIND A GIVEN PROGRAM IN A FILE AND COPY IT.

;THE COPY ROUTINE WILL COPY BINARY PROGRAMS FROM WHEREVER THE
;INPUT DEVICE HAPPENS TO BE WHEN IT IS CALLED, UP TO THE
;END OF FILE. SINCE COPY IS CALLED WITH A PUSHJ, THE END-OF-
;FILE EXIT IN INGET WILL EXIT TO THE PLACE THAT CALLED COPY.

COPY:	PUSHJ	P, READ		;READ A PROGRAM
	POPJ	P,		;EXIT WHEN ALL THROUGH FILE
	PUSHJ	P, WRITE	;WRITE OUT THE PROGRAM
	JRST	COPY		;RETURN FOR MORE PROGRAMS

;THE COPYTO ROUTINE WILL READ AND WRITE PROGRAMS FROM THE
;INPUT DEVICE UNTIL THE PROGRAM WHOSE NAME IS IN ACCUMULATOR
;R IS FOUND, AT WHICH TIME IT EXITS

COPYTO:
	TLNN	F,MSTMOD	;2ND TIME SO NAME ALREADY RAD50
	PUSHJ	P,RAD50		;CHANGE NAME TO RADIX 50
COPYT1:
	PUSHJ	P, READ		;READ A PROGRAM
	JRST	ERROR7		;EOF - CANT FIND IT
	CAMN	R, A		;IS IT THE CORRECT PROGRAM?
	POPJ	P,		;YES, EXIT
	PUSHJ	P, WRITE	;NO, WRITE IT OUT
	JRST	COPYT1		;READ SOME MORE PROGRAMS

;THE FINDCP ROUTINE WILL SEARCH THE INPUT FILE FOR A PROGRAM
;WHOSE NAME IS IN ACCUMULATOR R, AND HAVING FOUND IT, WILL
;WRITE IT OUT. IF THE CONTENTS OF AC R ARE ZERO, THE ENTIRE
;FILE IS COPIED.

FINDCP:	JUMPE	R, COPY		;COPY ENTIRE FILE?
	PUSHJ	P,RAD50		;CONVERT NAME TO RADIX 50
FIND1:	PUSHJ	P, READ		;READ A PROGRAM FROM INPUT FILE
	JRST	FIND2		;EOF, TRY REWINDING AND TRYING AGAIN
	CAME	R, A		;IS THIS THE RIGHT ONE?
	JRST	FIND1		;NO, TRY AGAIN
	JRST	WRITE		;YES, WRITE IT OUT AND EXIT

FIND2:	JUMPE	A,ERROR7	;V3 IF EOF OUTPUT ERROR MESSAGE
	PUSHJ	P, BACKSP	;BACKSPACE THE MAG TAPE
	HRRZ	A, FILBUF	;PICK UP THE FILE POINTER
	HLLM	A, 3(A)		;CLEAR THE LOOKUP FLAG FOR DECTAPE
	PUSHJ	P, GETDEV	;SET UP THE PROGRAM AGAIN
	JRST	ERROR3		;IMPOSSIBLE ERROR RETURN
FIND3:	PUSHJ	P, READ		;READ A PROGRAM FROM INPUT FILE
	JRST	ERROR7		;EOF - REALLY CANT FIND IT
	CAME	R, A		;IS THIS THE RIGHT ONE?
	JRST	FIND3		;NO, TRY AGAIN
	JRST	WRITE		;YES, WRITE IT OUT AND EXIT
;ROUTINE MSTGET RETRIEVES A PROGRAM NAME FROM THE MASTER
;DEVICE SPECIFICATIONS. IT SAVES THE POINTER IN FILBUF, 
;CHANGES IT TO POINT TO ITS OWN BLOCK, THEN CALLS GETDEV

MSTGET:
	MOVE	FPT, INBEG	;GET THE POINTER TO CURRENT FILE
	MOVEI	D,MIN		;BINARY     INPUT
	DPB	D,[POINT  4,INGET2,12]
	JRST	GETDEV		;CALL COMMON ROUTINE


;ROUTINE TRNGET RETRIEVES A PROGRAM NAME FROM THE TRANSACTION
;FILES. IT RESETS THE POINTER THAT MSTGET WIPED OUT, AND CALLS
;THE COMMON PROGRAM RETRIEVAL PROGRAM GETDEV.

TRNGET:
	MOVE	FPT, WLDTMP	;GET SAVED POINTER
	CAMN	FPT,INBEG	;IS THIS REALLY THE MASTER FILE?
	JRST	CPOPJ		;YES-LOSE NOW
	MOVEI	D,TRIN		;BINARY INPUT
	DPB	D,[POINT 4,INGET2,12]
	TLNN	F,MSTMOD	;HAVE WE BEEN HERE BEFORE?
	MOVEM	R,NAMSAV	;SAVE NAME IN CASE NOT IN CURRENT FILE
	JRST	GETDEV		;CALL COMMON ROUTINE

;ROUTINE RESET RESTORES THE STATE OF THE MASTER DEVICE TO
;WHAT IT WAS JUST AFTER THE LAST TIME MSTGET WAS CALLED. IT
;SETS THE POINTER OF THE MASTER FILE BACK TO THE PREVIOUS
;PROGRAM, CALLS MSTGET, AND FINDS THE PROGRAM AGAIN

RESET:
	MOVE	T1,[SVEBLK,,LKPBLK]	;GET THE LKPBLK BACK
	BLT	T1,LKPBLK+5	;FROM STORAGE FOR THE MASTER
	LOOKUP	MIN,LKPBLK	;DO THE LOOKUP ON MASTER
	   JRST LKPFAI		;LOOKUP FAILURE
RESET2:	SKIPN	(FPT)	;ANY TRANSACTION FILES ?    ***DMN
	JRST	RESET3		;NO-ALL DONE		    ***DMN
RESET3:
	PUSHJ	P, MSTGET	;SET UP THE MASTER DEVICE
	JRST	RESET1
	PUSHJ	P, BACKSP	;BACKSPACE IN CASE ITS A MAG TAPE
	PUSHJ	P,RAD50		;CONVERT NAME TO RADIX 50
RESET1:	PUSHJ	P, READ		;READ A PROGRAM FROM MASTER FILE
	JRST	ERROR3		;FUDGE ERROR-CANT FIND PROGRAM
	CAME	R,T1		;IS IT THE RIGHT PROGRAM NAME?
	JRST	RESET1		;NO, LOOK AGAIN
	POPJ	P,		;YES, EXIT
BACKSP:	;*** BACKSPACE MAG TAPE HERE
	POPJ	P,
GETDEV:
	MOVE	DIS,D		;CALCULATE 3 TIMES D
	IMULI	DIS,3
	SETZ	R,		;IN CASE OF NO PROGRAM NAMES
	HLRZ	T2,.FXLEN(FPT)	;GET COUNT OF PROG NAMES
	JUMPE	T2,CPOPJ1	;RETURN WITH R=0 IF NONE
	CAIN	D,TRIN		;DID WE COME HERE FROM TRNGET?
	JRST	GET1		;YES SO USE DIFFERENT COUNTER
	CAMG	T2,NAMCTR	;ANY MORE NAMES TO RETURN?
	POPJ	P,		;NO MORE
	MOVEI	T2,.FXPRG(FPT)	;GET POINTER TO BASE OF NAMES
	ADD	T2,NAMCTR	;INDEX TO CURRENT NAME
	MOVE	R,(T2)		;RETURN NAME IN R
	AOS	NAMCTR		;INCREMENT COUNTER
	JRST 	CPOPJ1		;GOOD RETURN
GET1:
	CAMG	T2,TNMCTR	;MORE TRANS NAMES TO RETURN?
	PUSHJ	P,GET2		;MAYBE SOME IN ANOTHER FILE
	MOVEI	T2,.FXPRG(FPT)	;GET POINTER TO BASE OF TRN NAMES
	ADD	T2,TNMCTR	;INDEX TO CURRENT NAME
	MOVE	R,(T2)		;RETURN THE NAME IN R
	AOS	TNMCTR		;INCREMENT THE COUNTER
	JRST	CPOPJ1		;SKIP RETURN
GET2:
	CAMN	FPT,INEND	;ARE THERE MORE TRANS FILES?
	JRST	POPOUT		;NO MORE--NON SKIP RETURN
	PUSHJ	P,TRNCLS	;CLOSE CURRENT TRANS FILE
	MOVE	T1,[4,,[INBEG,,INEND
			OPNBLK,,LKPBLK
			FSSIZE,,.RBSIZ+1
			WLDTMP+1B0]]
	PUSHJ	P,.LKWLD##	;WILD LOOKUP FOR NEXT TRANS FILE
	JFCL
	SETZM	TNMCTR		;CLEAR COUNTER
	MOVX	T1,.IOBIN	;BINARY INPUT
	IORM	T1,OPNBLK+.OPMOD
	MOVEI	T1,IBUF+<TRIN*3>	;BUFFER HEADER POINTER
	MOVEM	T1,OPNBLK+2	;PUT THIS STUFF IN THE OPEN BLOCK
	OPEN	TRIN,OPNBLK	;OPEN A NEW TRANS FILE CHANNEL
	   JRST  OPNFAI
	LOOKUP	TRIN,LKPBLK	;LOOKUP THE NEW TRANS FILE
	   JRST  LKPFAI		;LOOKUP FAILED
	INBUF	TRIN,		;SET UP BUFFER
	MOVE	FPT,WLDTMP	;SET UP FILE POINTER
	JRST	CPOPJ		;GO BACK TO GETDEV CODE
	SOS 	NAMCTR		;FIDDLE WITH THE COUNT
	JRST	SWT1		;GO GET ANOTHER TRANSACTION FILE
CPOPJ1:	AOSA	(P)		;GOOD RETURN
POPOUT:	POP	P,(P)		;POP UP ONE LEVEL
CPOPJ:	POPJ	P,		;EXIT
SUBTTL ROUTINE TO INPUT ONE PROGRAM AT A TIME
;THE FIRST WORD THAT THE PROGRAM READS WILL BE A BLOCK HEADER.
;BLOCKS ARE READ UNTIL AN ENTRY BLOCK IS FOUND, AND THE ENTIRE
;ENTRY BLOCK IS STORED IN AN INTERNAL BUFFER,SIZE PERMITTING.
;FOLLOWING THAT, THE NAME BLOCK IS READ, AND THE NAME OF THE 
;PROGRAM IS RETURNED IN ACCUMULATOR A. PROVISION IS MADE FOR
;BLOCKS OF WORD COUNT ZERO. THE SECTION OF CODING AROUND READ2
;DELIBERATELY OMITS THIS CHECK IN ORDER TO READ IN THE NEXT
;BLOCK HEADER WITH A MINIMUM OF INSTRUCTIONS. ORDINARILY, EACH
;PROGRAM WILL BEGIN WITH AN ENTRY BLOCK, BUT THE ROUTINE WILL
;ALSO ALLOW THE PROGRAM TO BEGIN WITH A NAME BLOCK IF NO
;ENTRY BLOCK IS SEEN.

READ:	MOVEI	C,ENTBLK	;SET UP POINTER TO BUFFER

READ1:	PUSHJ	P,GETIN		;GET A BLOCK HEADER
	HLRZ	B, A		;GET THE BLOCK CODE
	MOVSI	T,-BLKTYL	;MAKE UP AOBJN POINTER
READ2B:	CAMN	B,BLKTYP(T)	;SEARCH THE TABLE OF BLOCKTYPES AND COMPARE**JIE
	JRST	@RTABLE(T)	;FOUND A MATCH--GO PROCESS IT***JIE
	AOBJN	T,READ2B	;NOT  END YET--KEEP SEARCHING***JIE
	CAIL	B,100		;TEST FOR LEGAL BLOCKTYPES
	JRST	READ2D		; THESE ARE CLEARLY NOT
READ2F:	PUSHJ	P, COUNT	;CALCULATE SIZE OF BLOCK
	JUMPE	B, READ1	;WORD COUNT OF ZERO?
	JUMPA	READ2		;CONTINUE
READ2D:	CAIL	B,1000		;IS IT A NEW BLOCKTYPE?**JIE
	CAIL	B,1777		;BLOCKTYPES 1000 TO 1777 ARE LEGAL**JIE
	JRST	READ2G		;NO--MAYBE IT'S ASCII**JIE
	JRST	READ2F		;YES--THEN GO PROCESS IT**JIE
READ2G:	CAIGE	B,3777		;IS IT ASCII?**JIE
	JRST	ERR26		;MUST BE ILLEGAL
	JRST	READ17		;GO PROCESS ASCII BLOCKS**JIE
READ2:	CAML	B, IBUF+2(DIS)	;DOES BLOCK OVERLAP IO BUFFERS?
	JRST	READ3		;ADJUST B AND GET ANOTHER BUFFER
	MOVE	A, IBUF+2(DIS)	;NO, DIDDLE BUFFER HEADER COUNT
	SUB	A, B		;ELIMINATE BLOCK OF LENGTH C(B)
	MOVEM	A, IBUF+2(DIS)	;PUT NEW WORD COUNT BACK
	ADDM	B, IBUF+1(DIS)	;MOVE BYTE POINTER PAST BLOCK
	JRST	READ1		;GET NEXT BLOCK
READ3:	SUB	B, IBUF+2(DIS)	;ACCOUNT FOR REST OF THIS BUFFER
	SETZM	IBUF+2(DIS)	;FORCE ANOTHER INBUF
	PUSHJ	P,GETIN		;GET ANOTHER BUFFER OF INPUT
	JRST	READ2		;CHECK AGAIN

;CODE MODIFIED TO HANDLE MORE THAN ONE ENTRY BLOCK.
;FAIL AND SAIL BOTH ISSUE MULTIPLE ENTRY BLOCKS.

SIZZ==SIZE-<<SIZE+21>/22>-4	;ACCOUNT FOR HDR BLKS, RELOC WDRS, PROGNAME
READ4:	SETZM	ENTBLK		;SAME AS (C) AT PRESENT
	HRLI	C,-1		;AOBJN WILL OVERFLOW FIRST TIME
	TRNE	A,-1		;TEST FOR ZERO WORD COUNT
	JRST	READ5		;NO
	PUSHJ	P,GETIN		;YES, THROW AWAY RELOCATION WORD
	ADDI	C,1		;UPDATE INSERT COUNTER
	SETZB	A,(C)		;ENTRY BLOCK RELOCATION IS ALWAYS ZERO

;BACK HERE FOR EACH NEW BLOCK

READ5:	MOVNI	B,400000(A)	;-1 IN LH, 377777-CT IN RH
	HRRZS	A
	ADD	A,ENTBLK	;NEW COUNT IF IT FITS
	CAILE	A,SIZZ		;TOO MUCH NOW?
	TROA	F,ERRB		;YES, MARK ENTRY BLOCK TOO BIG
	MOVEM	A,ENTBLK	;NO, UPDATE USED COUNT
;HERE FOR EACH NEW WORD
READ6:	TRNN	B,377777	;END OF LOADER BLOCK?
	JRST	READ8		;YES, CHECK NEXT
	AOBJN	B,NXTWRD	;TIME FOR SOME RELOC BITS?
	PUSHJ	P,GETIN		;YES, GET THEN AND TOSS THEM AWAY
	HRLI	B,-22		;AND RESET COUNT
NXTWRD:	PUSHJ	P,GETIN		;GET A DATA WORD
;ROUTINE TAKEN FROM LOADER
	AOBJN	C,READ7		;NEED TO INSERT RELOC WORD?
	TRNN	F,ERRB		;YES, UNLESS NOT INSERTING
	SETZM	(C)		;ALL ENTRY RELOCS ARE 0
	ADD	C,[-22,,1]	;LH 0 BEFORE ADD, SET UP NEXT
READ7:	TRNN	F,ERRB		;ARE WE INSERTING?
	MOVEM	A,(C)		;YES, PUT IT AWAY
	JRST	READ6		;LOOP

READ8:	PUSHJ	P,GETIN		;GET NEXT HEADER WORD
	HLRZ	B,A		;TYPE
	CAIN	B,4		;ANOTHER ENTRY?
	JRST	READ5		;YES, STORE IT

;PROGRAM NAME - FINISH ENTRY OUT
	MOVEI	B,4		;ENTRY BLOCK TYPE
	HRLM	B,ENTBLK	;NOW CORRECT TYPE,,COUNT
	HRLI	C,0		;CLEAR LH COUNT
	AOJA	C,READ9		;STORE NAME BLOCK HEADER AND CONTINUE
READ9:	MOVEM	A, (C)		;STORE NAME BLOCK HEADER
	ADDI	C,1
	PUSHJ	P, COUNT	;CALCULATE SIZE OF BLOCK
	JUMPE	B, READ13	;WORD COUNT OF ZERO?
READ11:	PUSHJ	P,GETIN		;GET A WORD
	MOVEM	A, (C)		;STORE IT
	AOJ	C,		;INCREMENT BUFFER POINTER
	SOJG	B, READ11	;DONE READING YET?
	CAIN	G+1, 2		;IS THERE A COMMON WORD?
	MOVE	A, -2(C)	;GET PROGRAM NAME IN A
	JUMPE	A, READ13	;IGNORE WORD OF ZERO
	MOVE	B, A		;GET RID OF EXTRA BLANKS
READ12:	IDIVI	B, 50		;TRY DIVIDING IT BY 50
	JUMPN	B+1, READ13	;FILTERED OUT ALL THE BLANKS?
	MOVE	A, B		;NO, STORE SYMBOL AGAIN
	JRST	READ12		;TRY ANOTHER DIVISION

READ13:	TRNE	F, ERRB		;ERROR CONDITION?
	JRST	ERR10		;YES
	TRNN	F,XFLG		;INDEX FLAG ON?
	JRST	CPOPJ1		;NO, SKIP EXIT
	JRST	INDEX1		;YES SAVE ENTRIES

READ14:	TRO	F,F4IB		;DONT OUTPUT DURING F4 SEARCH
	PUSH	P,C		;SAVE ENTRY BLOCK
	PUSHJ	P,F4		;PASS F4 BLOCKS
	POP	P,C		;RESTORE ENTRY BLOCK
	TRZ	F,F4IB		;TURN OFF IGNORE BIT
	HRRZM	C,END1		;FORTRAN CANNOT DO ANY BETTER
	SETZM	END2		;CLEAR FIRST TIME FLAG
	JRST	READ1		;GO PROCESS NEXT PROGRAM

READ15:	PUSHJ	P,COUNT		;GET SIZE OF BLOCK
	SETZM	END1		;CLEAR STORAGE
	SETZM	END2
	SOJE	B,READ1		;SHOULD N'T BE
	PUSHJ	P,GETIN		;GET RID OF BYTE WORD
	PUSHJ	P,GETIN		;GET FIRST END WORD
	HRLZM	A,END1		;STORE IT
	SOJE	B,READ1		;ONLY ONE WORD?
	PUSHJ	P,GETIN		;NO
	HRLZM	A,END2		;STORE 2ND
	SOJE	B,READ1		;SHOULD BE END
	JRST	READ2		;JUST IN CASE

READ16:	TLON	F,NOWARN	;DO WE WANT A MESSAGE?
	TTCALL	3,[ASCIZ /%WARNING! NO INDEX ON OUTPUT FILE - CONTINUING
/]
	SETZM	IBUF+2(DIS)	;FORCE ANOTHER INBUF
	PUSHJ	P,GETIN		;INPUT THE NEXT BLOCK
	JRST	READ1+1		;AND RETURN TO CODE
READ17:
	PUSHJ	P,GETIN		;GET A WORD **JIE
	PUSHJ	P,OUT		;OUTPUT ASCII TEXT WORD **JIE
	JUMPE	A,READ1		;ASCII ALL GONE?--GET NEXT BLOCK HEADER**JIE
	JUMPA	READ17		;MORE ASCII LEFT--GO GET IT**JIE

;BLKTYP IS A TABLE OF LEGAL BLOCKTYPES RECOGNIZED BY FUDGE.
;WHEN A MATCH BETWEEN THE CODE IN THE LEFT HALF OF THE BLOCK
;HEADER AND A VALUE IN THE TABLE IS FOUND THE 
;CORRESPONDING PART OF THE READ ROUTINE IS JUMPED TO.
;RTABLE IS A TABLE OF LABELS FOR THE APPROPRIATE SECTIONS OF CODE
;IN THE READ ROUTINE. THESE SECTIONS OF CODE ARE ACCESSED BY A
;JRST @RTABLE(T) WHERE T IS USED AS AN INDEX.

BLKTYP:
	EXP	14		;INDEX BLOCK
	EXP	4		;ENTRY BLOCK
	EXP	1001		;ENTRY BLOCK
	EXP	1002		;LONG ENTRY BLOCK
	EXP	6		;NAME BLOCK
	EXP	1003		;NAME BLOCK
	EXP	401		;SPECIAL MANTIS(F40)DEBUGGER
	EXP	400		;FORTRAN 4 SIGNAL WORD
	EXP	5		;END BLOCK
	EXP	1040		;END BLOCK
BLKTYL=	.-BLKTYP		; TABLE LENGTH

RTABLE:
	READ16
	READ4
	READ4
	READ4
	READ9
	READ9
	READ14
	READ14
	READ15
	READ15
SUBTTL ROUTINE TO OUTPUT ONE PROGRAM AT A TIME
;THE WRITE SUBROUTINE WILL OUTPUT AN ENTIRE BINARY RE-
;LOCATABLE PROGRAM AS WRITTEN BY MACRO6. IT ASSUMES THAT THE
;ENTRY BLOCK AND NAME BLOCK FOR THE PROGRAM ARE IN THE
;INTERNAL BUFFER ENTBLK, AND OUTPUTS THESE BEFORE PICKING UP
;MORE BLOCKS FROM THE CURRENT INPUT DEVICE. BLOCKS ARE READ
;AND WRITTEN UNTIL THE END BLOCK HAS BEEN PROCESSED. PROVISION I
;IS MADE FOR BLOCKS WITH A WORD COUNT OF ZERO.

WRITE:	SUBI	C, ENTBLK	;GET COUNT OF ENTRY BLOCK
	JUMPE	C, WRITE3	;NOTHING TO OUTPUT?
	MOVEI	B, ENTBLK	;GET A POINTER IN B
WRITE2:	MOVE	A, (B)		;GET A BINARY WORD
	PUSHJ	P, OUT		;OUTPUT IT
	AOJ	B,		;INCREMENT POINTER
	SOJG	C, WRITE2	;KEEP GOING UNTIL BUFFER EMPTY
WRITE3:	PUSHJ	P,GETIN		;GET A BLOCK HEADER
	HLRZ	B,A		;GET THE BLOCK TYPE CODE ***VJC
	TRNN	F,NOLOCB	;DELETE LOCAL SYMBOLS? ***VJC
	JRST	.+3		;NO
	CAIN	B,2		;IS IT A SYMBOL BLOCK? ***VJC
	JRST	DELLOC		;GO DELETE LOCAL SYMBOL ***VJC
				;COME BACK TO WRITE3 ***VJC
				;UNLESS EXIT ON END-OF-FILE ***VJC

	PUSHJ	P, OUT		;OUTPUT IT
	CAIE	B, 401		;SPECIAL MANTIS F4?
	CAIN	B, 400		;IS THIS A FORTRAN IV SIGNAL WORD?
	JRST	F4		;YES, PROCESS F4 OUTPUT
	MOVEM	B, SAVEBT	;SAVE THE BLOCK TYPE
	PUSHJ	P, COUNT	;NO, GET SIZE OF BLOCK
	JUMPE	B, WRITE3	;WORD COUNT OF ZERO?
WRITE4:	PUSHJ	P,GETIN		;OUTPUT THE BLOCK
	PUSHJ	P, OUT		;...
	SOJG	B, WRITE4	;LOOP BACK UNTIL DONE
	MOVE	A, SAVEBT	;RETRIEVE THE BLOCK TYPE
	CAIE	A,1040		;WAS IT AN END BLOCK?***JIE
	CAIN	A, 5		;WAS IT AN END BLOCK?
	POPJ	P,		;EXIT***JIE
	JRST	WRITE3		;NO, RETURN FOR MORE BLOCKS***JIE

;THE COUNT SUBROUTINE CALCULATES THE LENGTH OF THE VARIOUS 
;BLOCKS READ BY THE WRITE AND READ SUBROUTINES. THE POSITIVE
;WORD COUNT IS FOUND IN THE RIGHT HALF OF THE ENTRY BLOCK 
;HEADER, WHICH IS ASSUMED TO BE IN AC A UPON ENTERING. THE
;LENGTH WILL BE RETURNED IN AC B, AND INCLUDES THE DATA WORDS
;(SYMBOLS, ENTRY WORDS, ETC.) AND THE SUBHEADERS, OF WHICH
;THERE IS ONE FOR EVERY 18 (DECIMIAL) DATA WORDS. THE BLOCK
;HEADER IS DESTROYED, AND IS NOT INCLUDED IN THE LENGTH.

COUNT:	HRRZ	G, A		;GET NUMBER OF WORDS
	IDIVI	G, 22		;1SUBHEADER/18 DATA WORDS
	ADDI	G,(A)		;ADD INTO WORD COUNT
	JUMPE	G+1,.+2		;1 EXTRA SUBHEADER FOR
	AOJ	G,		;STRAY ONES
	MOVE	B, G		;RESULTS IN AC B
	POPJ	P,		;EXIT
SUBTTL ROUTINE TO HANDLE FORTRAN OUTPUT

;SUBSECTION OF THE WRITE ROUTINE TO HANDLE OUTPUT FROM THE
;FORTRAN IV COMPILER. THE MAIN OBJECT OF THE ROUTINE IS TO
;LOOK FOR THE END BLOCK. OTHER BLOCKS ARE MERELY COPIED OUT.
;THE BLOCK TYPES ARE GIVEN BY THE FOLLOWING TABLE
;----------------------------------------------------------------
	;BITS 0-17	BITS18-23	BITS 24-35		TYPE

;777777		70		N	   DATA STATEMENT
;777777		50		N	    ABSOLUTE MACHINE CODE
;777777		77		N	   MANTIS DATA
;777777		0		-	    PROGRAMMER LABELS
;777777		31		-	    MADE LABELS
;777777		60		-	    ENTRY LABELS
;777777			777776		    END BLOCK
;-----------------------------------------------------------------
F4:	PUSHJ	P,GETIN		;GET A FORTRAN IV BLOCK HEADER
	PUSHJ	P, OUT4		;OUTPUT IT
	TLC	A, -1		;TURN ONES TO ZEROES IN LEFT HALF
	TLNE	A, -1		;NO, WAS LEFT HALF ALL ONES?
	JRST	F4		;NO, IT WAS CALCULATED MACHINE CODE
	CAIN	A, -2		;YES, IS RIGHT HALF = 777776?
	JRST	ENDST		;YES, PROCESS F4 END BLOCK
	LDB	B, [POINT 6,A,23];GET CODE BITS FROM BITS 18-23
	TRZ	A, 770000	;THEN WIPE THEM OUT
	CAIE	B, 70		;IS IT A DATA STATEMENT?
	CAIN	B, 50		;IS IT ABSOLUTE MACHINE CODE?
	JRST	MACHCD		;YES, TREAT IT LIKE DATA STATEMENTS
	CAIN	B, 77		;SPECIAL MANTIS DEBUGGER DATA?
	JRST	MACHCD		;YES, TREAT IT LIKE DATA
	PUSHJ	P,GETIN		;NO, ITS A LABEL OF SOME SORT
	PUSHJ	P, OUT4		;WHICH CONSISTS OF ONE WORD
	JRST	F4		;LOOK FOR NEXT BLOCK HEADER

MACHCD:	HRRZ	B, A		;GET THE WORD COUNT IN AC B
	PUSHJ	P,GETIN		;INPUT A WORD
	PUSHJ	P, OUT4		;OUTPUT IT

;** EDIT 50	MACHCD+3	JNT	18-OCT-74
;** EDIT 50	MACHCD CHANGED TO MACHCD+1
	SOJG	B, MACHCD+1	;[50] LOOP BACK FOR REST OF THE BLOCK
	JRST	F4		;GO LOOK FOR NEXT BLOCK

ENDST:	MOVEI	B,1		;TWO WORDS, FIVE TABLES, ONE WORD, ONE TABLE
	MOVEI	C,6		;TO GO
F4LUP1:	PUSHJ	P,GETIN		;GET TABLE MEMBER
F4LUP3:	PUSHJ	P,OUT4		;OUTPUT WORD
	SOJGE	B,F4LUP1	;LOOP WITHIN A TABLE
	JUMPL	C,CPOPJ		;LAST TABLE - RETURN
	SOJG	C,F4LUP2	;FIRST TWO WORDS AND FIVE TABLES
	JUMPE	C,F4LUP1	;COMMON LENGTH WORD
F4LUP2:	PUSHJ	P,GETIN		;READ HEADER WORD
	MOVE	B,A		;COUNT TO COUNTER
	JRST	F4LUP3		;STASH

OUT4:	TRNN	F,F4IB		;DONT DO OUTPUT?
	PUSHJ	P,OUT		;YES, DO OUTPUT
	POPJ	P,		;RETURN
SUBTTL ROUTINE TO DELETE LOCAL SYMBOLS FROM SYMBOL BLOCK

;ALL LOCAL AND SUPPRESSED LOCAL SYMBOLS ARE DELETED
;EXTERNALS,INTERNAL AND SUPPRESSED INTERNALS ARE NOT DELETED.

DELLOC:	HRRZM	A,BSZ		;SIZE OF SYMBOL BBLE
	PUSHJ	P,DELINI	;CLEAR NEW HEADER & RELOC WORDS
				;SET PB = SYMBLK+2
DELGTR:	PUSHJ	P,GETIN		;GET RELOCATION WORD
	MOVEM	A,RELOCS	;SAVE IT
	MOVE	A,PTGR		;INIT POINTER TO GET
	MOVEM	A,PTGRS		;RELOCATION WORD

DELGT1:	PUSHJ	P,GETIN		;GET FIRST WORD OF PAIR
	ILDB	E,PTGRS		;GET RELOCATION BITS & HOLD
	TLNE	A,(1B2)		;IS SYMBOL  LOCAL?
	JRST	DELDEC		;YES, DON'T COPY
	MOVEM	A,0(T)		;STORE FIRST WORD
	PUSHJ	P,GETIN		;GET SECOND WORD INTO A
	MOVEM	A,1(T)		;STORE SECOND WORD
	IDPB	E,PTSRS		;STORE RELOCATION BITS
	MOVEI	A,2		;COUNT WORDS STORED
	ADDM	A,SYMBLK	;I.E. UPDATE WORD COUNT
	ADDI	T,2		;UPDATE NEXT LOCATION TO STORE
	MOVE	A,PTSRS		;HAVE WE STORED 9
	TLNN	A,770000	;SYMBOL PAIRS?
	PUSHJ	P,DELWRT	;YES, WRITE IT OUT
	JRST	DELDEC+1	;ALREADY HAVE 2ND WORD

DELDEC:	PUSHJ	P,GETIN		;GET SECOND WORD INTO A
	SOS	BSZ		;HAVE WE EXHAUSTED
	SOSG	BSZ		;ALL WORDS IN BLOCK?
	JRST	DELFIN		;YES, NONE LEFT
	MOVE	A,PTGRS		;HAVE WE GOT 9
	TLNE	A,770000	;SYMBOL PAIRS YET?
	JRST	DELGT1		;NO, GET NEXT PAIR
	JRST	DELGTR		;YES, GET RELOCATION

DELFIN:	PUSHJ	P,DELWRT	;ORIGINAL BLOCK EMPTY NOW
	JRST	WRITE3		;GET NEXT BLOCK


SUBTTL ROUTINE TO WRITE OUT NEW SYMBOL TABLE

DELWRT:	SKIPN	A,SYMBLK	;ANYTHING TO WRITE
	JRST	DELINI		;NO, CAN LEAVE
	HRRZ	E,A		;GET WORD COUNT
	HRLI	A,2		;PUT IN BLOCK TYPE
	PUSHJ	P,OUT		;WRITE BLOCK HEADER
	MOVEI	B,SYMBLK	;LOC OF FIRST WORD
DELWRU:	ADDI	B,1		;LOC OF RELOC WORD
	MOVE	A,0(B)		;GET WORD
	PUSHJ	P,OUT		;OUTPUT
	SOJGE	E,DELWRU	;ALL THROUGH?

;ROUTINE TO INITIALIZE NEW SYMBOL TABLE
DELINI:	SETZM	SYMBLK		;YES, CLEAR COUNT
	SETZM	SYMBLK+1	;CLEAR RELOCATION
	MOVE	A,PTSR		;INIT POINTER
	MOVEM	A,PTSRS		;FOR STORING NEW RELOC
	MOVEI	T,SYMBLK+2	;SET TO STORE FIRST GLOBAL
	POPJ	P,
SUBTTL ROUTINES TO INDEX THE LIBRARY

COMMENT	*	THE INDEXING OF LIBRARY FILES IS DONE IN TWO PASSES.
	ON PASS 1 THE LIBRARY FILE IS COPIED AND ALL ENTRIES STORED
	IN CORE ALLONG WITH A POINTER TO THE BEGINING OF THE BLOCK.
	A DUMMY INDEX BLOCK (TYPE 14) IS OUTPUT AT THE BEGINING OF THE
	NEW LIBRARY AND ONE IS OUTPUT WHENEVER THE CURRENT INDEX BLOCK
	FILLS A BUFFER.
	ON PASS 2 THE DUMMY INDEX BLOCKS ARE REPLACED BY REAL ONES.
	MAKLIB USED USETO'S AND DUMP MODE.
	IF THE OUTPUT DEVICE IS DTA MAKLIB USES UGETF UUO'S TO FIND
	THE NEXT BLOCK AND NON-STANDARD DUMP MODE TO WRITE THE INDICES.
	DESIGN AND CODING BY D.M.NIXON JULY 1970
*

INDEX0:	MOVE	A,INDEXH	;BLOCK HEADER
	TRNE	F,DTAFLG	;DTA IS 1 WORD LESS
	SUBI	A,1
	TRNE	F,DTAFLG	;DTA IS 1 WORD LESS
	SUBI	A,1
	AOS	BLKCNT		;START ON BLOCK #1
	PUSHJ	P,OUT1		;OUTPUT IT
	OUTPUT	1,		;FORCE OUTPUT
	MOVE	T,OBUF+5	;BUFFER SIZE
	MOVEM	T,XCOUNT
	MOVEM	T,BUFSIZ	;SAVE IT AWAY
	AOS	OBUF+5		;COUNT IS OUT BY ONE BECAUSE OF OUTPUT UUO
	AOS	T,.JBREL	;TO GET 1K MORE
	MOVEM	T,XPNTR
	MOVEM	T,XBEG		;START OF INDEX BUFFERS
	CORE	T,
	JRST	ERR22		;NOT ENUF CORE
	MOVEI	A,1		;START ON BLOCK #1 (IF DSK)
	MOVEM	A,@XPNTR	;STORE FIRST BLOCK #
	AOS	XPNTR
	MOVE	A,INDEXH
	MOVEM	A,@XPNTR
	AOS	XPNTR
	SOS	XCOUNT
	SOS	XCOUNT		;RESERVE SPACE FOR NEXT LINK WORD
	POPJ	P,		;RETURN
;HERE ON PASS 1 TO STORE ENTRIES AND POINTERS.

INDEX1:	AOS	(P)		;SET SKIP RETURN
	HRRZ	T,ENTBLK	;GET SIZE OF BLOCK
	MOVN	A,T
	ADDI	T,1		;WORD OF INFO
	CAML	T,XCOUNT	;ENUF ROOM IN BLOCK?
	JRST	NOROOM		;NO
	MOVE	T,ENTBLK	;GET HEADER WORD
	MOVEM	T,@XPNTR
	AOS	XPNTR
	SOS	XCOUNT
	HRLS	A
	HRRI	A,ENTBLK+1
INDEXA:	SKIPN	T,(A)
	AOJA	A,.-1
	MOVEM	T,@XPNTR
	SOS	XCOUNT
	AOS	XPNTR
	AOBJN	A,INDEXA
INDEX2:	MOVE	T,BUFSIZ
	SUB	T,OBUF+5
	HRLI	T,1(T)		;WORD COUNT IS CORRECT FOR LOADER
	HRR	T,BLKCNT
	MOVEM	T,@XPNTR
	SOS	XCOUNT
	AOS	XPNTR
	POPJ	P,

;HERE WHEN CURRENT INDEX BLOCK IS FULL.

NOROOM:	MOVE	A,INDEXH	;HEADER BLOCK OF INDEX FOR LOADER
	TRNE	F,DTAFLG	;DTA IS 1 WORD LESS
	SUBI	A,1
	PUSHJ	P,OUTGO
	OUTPUT	1,
	AOS	OBUF+5		;COUNT IS OUT BY ONE BECAUSE OF OUTPUT UUO
	MOVE	T,BLKCNT	;GET INDEX BLOCK #
	HRROM	T,@XPNTR	;STORE IT WITH -1 IN LEFT HALF
	MOVE	A,XCOUNT	;PART OF BLOCK NOT FILLED
	ADDB	A,XPNTR		;START OF NEW BLOCK
	ADD	A,BUFSIZ	;ENSURE NEXT BUFFER WILL FIT IN CORE
	CAMG	A,.JBREL	;WILL IT?
	JRST	.+3		;YES
	CORE	A,		;GET ENOUGH CORE
	JRST	ERR22		;NOT ENOUGH CORE
	MOVE	A,BUFSIZ
	MOVEM	A,XCOUNT
				;MARK IT AS AN INDEX INCASE BLOCK FULL
	HRROM	T,@XPNTR	;SAVE BLOCK # FOR PASS 2
	AOS	XPNTR
	TRNN	F,DTAFLG	;NOT IF DTA
	AOS	BLKCNT		;ONE FOR OUTPUT
	MOVE	A,INDEXH
	TRNE	F,DTAFLG	;DTA IS 1 WORD LESS
	SUBI	A,1
	MOVEM	A,@XPNTR
	AOS	XPNTR
	SOS	XCOUNT
	SOS	XCOUNT		;SPACE FOR LINK WORD TO NEXT INDEX
	JRST	INDEX1+1

;HERE FOR PASS 2. WRITE OUT THE INDEX BLOCKS

INDEX3:	SETOM	@XPNTR		;TERMINATE WITH END OF INDEX MARKER
	OUTPUT	1,		;SO LAST BLOCK IS WRITTEN
	TRNE	F,DTAFLG	;IS IT DTA?
	JRST	INDEX5		;YES, TREAT DIFFERENTLY
	SETSTS	1,16
	MOVNI	A,200
	HRLM	A,XBEG
INDEX4:	SETZM	XBEG+1
	MOVE	A,@XBEG
	USETO	1,(A)
	OUTPUT	1,XBEG
	STATZ	1,760000
	JRST	ERR15
	MOVEI	A,200
	ADDB	A,XBEG
	HRRZS	A
	CAMG	A,XPNTR
	JRST	INDEX4
	JRST	EXIT

INDEX5:	CLOSE	1,		;AND A SEPARATE EOF BLOCK
	SETSTS	1,116		;NONE STANDARD MODE
	MOVNI	A,200		;IOWD COUNT
	HRLM	A,XBEG		;SET IT UP FOR OUTPUT
	USETI	1,@BLKCNT	;SET ON LAST BLOCK
	INPUT	1,DIRIOW	;READ IT IN
	LDB	A,[POINT 10,DIRBLK,27]	;GET FIRST BLOCK #
	HRRM	A,@XBEG		;STORE IT FOR COMMON LOOP
	SETZM	XBEG+1		;MAKE SURE IT'S ZERO
INDEX6:	MOVE	A,@XBEG		;GET BLOCK NUMBER
	USETI	1,(A)		;SET FOR INPUT
	INPUT	1,DIRIOW	;INPUT BLOCK
	MOVE	T,DIRBLK	;TO FIND LINK WORD
	EXCH	T,@XBEG		;PUT IT IN OUTPUT BLOCK
	SOS	XBEG		;BACK UP POINTER
	USETO	1,(A)		;NOW FOR OUTPUT
	OUTPUT	1,XBEG		;OUT IT GOES
	STATZ	1,760000	;UNLESS IN ERROR
	JRST	ERR15		;DEVICE ERROR
	MOVEI	A,200		;GET TO NEXT DUMP BLOCK
	ADDB	A,XBEG		;ADVANCE POINTER
	HRRZS	A		;JUST WORD LOCATION
	CAMG	A,XPNTR		;ALL DONE?
	JRST	INDEX6		;NO, LOOP
	SETSTS	1,16		;BACK TO STANDARD MODE TO UPDATE DIR.
	JRST	EXIT		;YES, FINISH UP

INDEXH:	XWD	14,177		;USED TO SIGNAL INDEX BLOCK TO LOADER

SUBTTL INPUT SERVICE ROUTINE
;THE INPUT ROUTINE GETS CHARACTERS FROM THE DEVICE WHOSE
;CHANNEL NUMBER IS IN ACCUMULATOR D. IT CALCULATES THE POSITION
;OF THE BUFFER HEADER OF THE DEVICE, THEN EITHER LOADS AC A
;FROM THE BYTE POINTER, OR DOES AN INPUT. IF AN END OF FILE
;IS FOUND, THE ROUTINE EXITS WITH A POPJ, SINCE THE READ ROUTINE
;IS CALLED WITH A PUSHJ, FOLLOWED BY AN EOF RETURN. THE NORMAL
;EXIT FROM GETIN IS BY A JRST @GETIN.

GETIN:	SOSG	IBUF+2(DIS)	;IS APPROPRIATE BUFFER EMPTY?
	JRST	INGET		;YES, GET ANOTHER BUFFER
GETIN1:	ILDB	A, IBUF+1(DIS)		;LOAD AC A WITH A CHARACTER
	POPJ	P,

INGET:	DPB	D,[POINT 4,INGET2,12]
	DPB	D,[POINT 4,INGET3,12]
	JRST	INGET2		;INPUT A BUFFER OF DATA


;OUTPUT SERVICE ROUTINE
;THE OUT ROUTINE CHECKS THE TTYOB FLAG TO SEE IF THE OUTPUT
;SHOULD BE ON THE TTY. IF SO, IT TRANSFERS CONTROL IMMEDIATELY.
;OTHERWISE, IT ASSUMES OUTPUT IS ON DEVICE #1.

OUT:	TRNN	F, TTYOB	;SHOULD OUTPUT BE ON TTY?
	JRST	TYPO		;YES
OUT1:	SOSG	OBUF+5		;IS OUTPUT BUFFER EMPTY?
	JRST	OUTGO		;YES, OUTPUT A BUFFER
OUT2:	IDPB	A, OBUF+4	;DEPOSIT CHARACTER
	POPJ	P,		;EXIT

OUTGO:	TRNN	F,XFLG		;IF NOT INDEXING
	JRST	OUTG		;DON'T WASTE TIME
	TRNN	F,DTAFLG	;IF DTA SKIP
	AOSA	BLKCNT		;INCR. COUNT IF DSK
	UGETF	1,BLKCNT	;GET NEXT BLOCK IF DTA
OUTG:	OUT	OBIN,		;OUTPUT A BUFFER
	  JRST	OUT2		;NO ERRORS
	JRST	ERR15		;GO TO ERROR ROUTINE
	SUBTTL  RADIX50 CONVERSION ROUTINE

RAD50:
	MOVE	E,SYMPTR	;SET UP A BYTE POINTER TO R
	MOVEI	T2,6		;SET COUNTER TO SIX
	MOVEI	T4,0
	JUMPE	R,RAD502	;NULL SYMBOL?
RAD501:
	TRNE	R,77		;RIGHT-JUSTIFIED?
	JRST	RAD502		;YES-CONVERT TO RADIX50
	ROT	R,-6		;NO-SHIFT IT ONE PLACE RIGHT
	JRST	RAD501		;CHECK	AGAIN
RAD502:
	IMULI	T4,50		;CONVERT TO RADIX50
	ILDB	T1,E		;PICK UP NEXT CHARACTER IN R
	JUMPE	T1,RAD503	;A BLANK IS A BLANK IN ANY RADIX
	CAIE	T1,'%'		;IS IT A '%'?
	CAIN	T1,'$'		;IS IT A $ ?
	ADDI	T1,70		;YES-COMPENSATE FOR SUBTRACTION
	CAIN	T1,'.'		;IS IT A '.' ?
	ADDI	T1,55		;YES-COMPENSATE
	CAILE	T1,31		;TRANSLATE RADIX50 CODE
	SUBI	T1,7		;LETTER-SUBTRACT 26
	SUBI	T1,17		;NUMBER-SUBTRACT 17
	ADD	T4,T1		;COMBINE WITH PARTIAL WORD
RAD503:
	SOJG	T2,RAD502	;LOOP FOR SIX CHARACTERS
	MOVE	R,T4		;PUT SYMBOL BACK IN R
	POPJ	P,		;GIVE IT TO WHOEVER WANTED IT
	
SUBTTL ERROR ROUTINES

ERROR1:
	MOVEI	B,EMES1			;SYNTAX ERROR
	JRST	ERROR
ERR1A:	MOVEI	B, EMES1A
	JRST	ERROR

ERROR2:
	MOVEI	B,EMES2
	JRST	ERROR

ERIRT:
	MOVEI	B,MKLIRT		;INS OR REP ON MASTER FILE
	JRST	ERROR

ERMTF:
	MOVEI	B,MKLMTF	;/MASTER ON TRANSACTION FILE
	JRST	ERROR
ERTMS:
	MOVEI	B,MKLTMS	;TOO MANY SWITCHES
	JRST	ERROR

ERRSIO:
	MOVEI	B,MKLSIO	;SWITCHES ILLEGAL ON OUTPUT
	JRST	ERROR
ERROR3:	MOVEI	B, EMES3	;FUDGE SYSTEM ERROR
	JRST	ERROR		;TYPE A MESSAGE AND EXIT

ERROR5:	MOVEI	B, EMES5	;UNEQUAL NUMBER OF MASTER AND TR.
	JRST	ERROR		;TYPE IT AND EXIT

ERROR6:	MOVEI	B, EMES6	;NOT ENOUGH ARGUMENTS
	JRST	ERROR		;TYPE IT AND EXIT

ERROR7:	PUSHJ	P, DTYPOQ	;TYPE OUT THE DEVICE NAME
	MOVEI	A, 72		;ASCII COLON
	PUSHJ	P, TYPO		;TYPE IT OUT
	JUMPN	R,.+3		;IF PROG NAME IS 0
	MOVNI	A,3		;FILBUF HAS BEEN ADVANCED TOO FAR
	ADDM	A,FILBUF	;SO BACK IT UP
	PUSHJ	P, FTYPO	;TYPE  OUT THE FILE NAME
	MOVEI	A, 56		;ASCII PERIOD
	PUSHJ	P, TYPO		;TYPE IT OUT
	MOVE	S, .FXEXT(FPT)	;GET FILE NAME EXTENSION
	PUSHJ	P, DTYPO1	;TYPE IT OUT
	MOVEI	A, 74		;ASCII LEFT ANGLE BRACKET
	PUSHJ	P, TYPO		;TYPE IT  OUT
	MOVE	B, R		;GET PROGRAM NAME
	TRZ	F, TTYOB	;SET IO BACK TO TTY
	PUSHJ	P, PTYPO	;TYPE  OUT THE PROGRAM NAME
	MOVEI	A, 76		;ASCII RIGHT ANGLE BRACKET
	PUSHJ	P, TYPO		;TYPE IT OUT
	MOVEI	B, EMES7	;GET AN ERROR MESSAGE
	JUMPN	R,ERROR		;CAN NOT FIND PROG
	MOVEI	B, EMES7A	;ZERO PROG SPECIFIED
	JRST	ERROR		;TYPE IT OUT AND EXIT
ERR10:	MOVE	C, A		;SAVE PROGRAM NAME IN C
	MOVEI	B, EMES10	;"ENTRY BLOCK TOO LARGE, PROGRAM"
	PUSHJ	P, ETYPO	;TYPE BEGINNING OF MESSAGE
	MOVE	B, C		;GET PROGRAM NAME IN B
	PUSHJ	P, PTYPO	;TYPE IT OUT
	JRST	EXIT1		;EXIT

ERR11:	MOVEI	B, EMES11	;TRANSMISSION ERROR ON INPUT
	PUSHJ	P, ETYPO	;TYPE THE MESSAGE
	PUSHJ	P, DTYPO	;TYPE NAME OF OFFENDIN DEVICE
	MOVEI	A,":"
	PUSHJ	P,TYPO
	MOVEI	B,EMS15A	;REST OF MESSAGE
	PUSHJ	P,ETYPO
	MOVE	B,[GETSTS ,B]
	DPB	D,[POINT 4,B,12]	;SETUP CHAN #
	XCT	B		;GET STATUS INTO B
	HRLZS	B		;LEFT HALF
	PUSHJ	P,OTYPO
	MOVEI	A,")"
	PUSHJ	P,TYPO
	JRST	EXIT1		;EXIT
ERR15:	MOVEI	D, 1		;SET TO OUTPUT DEVICE
	MOVEI	B, EMES15	;DEVICE ERROR ON OUTPUT
	PUSHJ	P, ETYPO	;TYPE THE MESSAGE
	PUSHJ	P, DTYPO	;TYPE NAME OF OFFENDING DEVICE
	MOVEI	A,":"
	PUSHJ	P,TYPO
	MOVEI	B,EMS15A
	PUSHJ	P,ETYPO
	GETSTS	1,B		;GET THE STATUS
	HRLZS	B		;LEFT HALF
	PUSHJ	P,OTYPO		;OUTPUT IT
	MOVEI	A,")"
	PUSHJ	P,TYPO
	JRST	EXIT1		;GO AWAY

ERR22:	MOVEI	B,EMES22
	JRST	ERROR

ERR23:	MOVEI	B,EMES23
	JRST	ERROR

ERR26:	PUSH	P,B		;SAVE BLOCK TYPE
	PUSHJ	P, DTYPOQ	;TYPE OUT THE DEVICE NAME
	MOVEI	A, 72		;ASCII COLON
	PUSHJ	P, TYPO		;TYPE IT OUT
	MOVNI	A,3		;FILBUF HAS BEEN ADVANCED TOO FAR
	ADDM	A,FILBUF	;SO BACK IT UP
	PUSHJ	P, FTYPO	;TYPE  OUT THE FILE NAME
	MOVEI	A, 56		;ASCII PERIOD
	PUSHJ	P, TYPO		;TYPE IT OUT
	HRRZ	A, FILBUF	;GET THE POINTER TO CURRENT FILE
	HLRZ	S, 1(A)		;GET FILE NAME EXTENSION
	PUSHJ	P, DTYPO1	;TYPE IT OUT
	POP	P,B		;GET BLOCK TYPE
	HRLZS	B		;INTO LEFT HALF
	MOVEI	A," "		;NEED SPACE
	PUSHJ	P,TYPO
	PUSHJ	P,OTYPO		;OUTPUT IN OCTAL
	MOVEI	B,EMES26	;GET MESSAGE
	PUSHJ	P,ETYPO
	JRST	EXIT1		;AND GIVE UP
SUBTTL VARIOUS ERROR ROUTINES AND SMALL TYPE-OUT ROUTINES

ETYPO:	HRLI	B, 440700	;MAKE A BYTE POINTER
ETYPO2:	ILDB	A, B		;GET A CHARACTER
	JUMPE	A,CPOPJ		;EXIT IF NULL
	PUSHJ	P, TYPO		;NO, TYPE IT
	JRST	ETYPO2		;RETURN FOR MORE CHARACTERS

DTYPOQ:	TRON	F,CRLFTY	;IS CR,LF TYPED OUT?
	PUSHJ	P,CRLF		;YES
	MOVEI	A,77		;TYPE OUT ? FOR BATCH
	PUSHJ	P,TYPO

DTYPO:	MOVE	S, .FXDEV(FPT)	;GET DEVICE NAME FROM BUFFER
DTYPO1:	MOVE	C, [POINT 6,S]	;BYTE POINTER TO SYMBOL NAME
	MOVEI	B, 6		;LOOP COUNTER FOR 6 CHARACTERS
DTYPO2:	ILDB	A, C		;GET A CHARACTER
	JUMPE	A, DTYPO3	;IGNORE BLANKS
	ADDI	A, 40		;CONVERT TO 7-BIT ASCII
	PUSHJ	P, TYPO		;TYPE IT
DTYPO3:	SOJG	B, DTYPO2	;ALL DONE?
	POPJ	P,		;EXIT

FTYPO:	MOVE	S, .FXNAM(FPT)	;PICK UP THE FILE NAME
	JRST	DTYPO1		;JUMP INTO DTYPO ROUTINE

PTYPO:	MOVEI	A, 6		;SIX CHARACTERS TO GET
	TLZ	B,740000	;CLEAR CODE BITS
PTYPO2:	IDIVI	B, 50		;CONVERT TO SIXBIT CODE
	HRLM	B+1, (P)	;STORE CHARACTER ON PD LIST
	SOJLE	A,.+2		;ALL DONE?
	PUSHJ	P, PTYPO2	;NO, DIVIDE SOME MORE
	HLRZ	A, (P)		;POP CHARACTERS OFF STACK
	JUMPE	A, CPOPJ	;IGNORE BLANKS
	CAILE	A, 12		;LETTER OR NUMBER?
	ADDI	A, 7		;LETTER - ADD 66
	ADDI	A, 57		;NUMBER - ADD 57
	CAIE	A, 135		;PERCENT SIGN?
	CAIN	A, 134		;DOLLAR SIGN?
	SUBI	A, 70		;YES, SPECIAL CASE
	CAIN	A, 133		;PERIOD?
	SUBI	A, 55		;YES, SPECIAL CASE
	JRST	OUT		;RECURSIVE EXIT FOR MORE CHARS

TYPO:	OUTCHR	A
	POPJ	P,		;EXIT
OTYPO:	HRRI	B,1		;MARKER FOR WHEN DONE
OTYPO1:	LSH	A,7		;MAKE SPACE FOR NEW NUMBER
	LSHC	A,3		;GET NUMBER FROM B
	ADDI	A,"0"		;FORM ASCII
	PUSHJ	P,TYPO		;OUTPUT IT
	TRNE	B,-1		;RIGHT HALF ZERO WHEN DONE
	JRST	OTYPO1		;NOT YEYT
	POPJ	P,		;RETURN

CRLF:	MOVEI	A, 15		;CARRIAGE RETURN
	PUSHJ	P, OUT		;OUTPUT IT
	MOVEI	A, 12		;LINE FEED
	JRST	OUT		;OUTPUT IT AND EXIT

OCTOUT:	PUSHJ	P,TYPTB1	;ALEAYS NEED A TAB
	HRRI	B,1		;MARKER FOR WHEN DONE
OCTOU1:	LSH	A,7		;MAKE SPACE FOR NEW NUMBER
	LSHC	A,3		;GET NUMBER FROM B
	ADDI	A,"0"		;FORM ASCII
	PUSHJ	P,OUT		;OUTPUT IT
	TRNE	B,-1		;RIGHT HALF ZERO WHEN DONE
	JRST	OCTOU1		;NOT YET
	POPJ	P,		;RETURN

TYPTAB:	SOJG	E,TYPTB1	;NEED A NEW LINE?
	PUSHJ	P,CRLF		;YES, OUTPUT ONE FIRST
	MOVEI	E,TABS1-1	;RESET TAB COUNT
	TRNN	F,TTYOB
	MOVEI	E,TABS2-1	;TTY
TYPTB1:	MOVEI	A,11		;A TAB
	JRST	OUT		;OUTPUT AND RETURN (POPJ P,)
ERROR:	TRZ	F,TTYOB		;JUST IN CASE , SET OUTPUT TO TTY
	TRON	F,CRLFTY
	PUSHJ	P,CRLF
	PUSHJ	P, ETYPO	;TYPE LAST MESSAGE OF ERROR
EXIT1:	TRZ	F,TTYOB		;ENSURE TTY OUTPUT OF CR-LF
	PUSHJ	P,CRLF		;FINISH WITH CR-LF
	CLOSE	0,		;FORCE OUTPUT OF LAST LINE
	JRST	MAKSCN		;START AGAIN

EXIT:	CLOSE	1,		;CLOSE OUT THE OUTPUT CHANNEL
	JRST	MAKLIB		;RESTART

SUBTTL ERROR MESSAGES
EMES1:	ASCIZ	"?MKLMSE	MAKLIB SYNTAX ERROR"
EMES1A:	ASCIZ	"?MKLCSR	COMMAND SWITCH REQUIRED"
EMES2:	ASCIZ	"%MKLTMN    TOO MANY FILE NAMES OR PROGRAM NAMES"
EMES3:	ASCIZ	"?MKLMNO MODULE NAMES OUT OF ORDER IN MASTER "
EMES5:	ASCIZ	"%MKLUMT   UNEQUAL NUMBER OF MASTER AND TRANSACTION PROGRAMS"
EMES6:	ASCIZ	"%MKLNEA	NOT ENOUGH ARGUMENTS"
MKLIRT:	ASCIZ	"?MKLIRT	INSERT AND REPLAC NOT ALLOWED ON MASTER"
MKLMTF:	ASCIZ	"?MKLMTF	/MASTER NOT ALLOWED ON TRANSACTION FILE"
MKLSIO:	ASCIZ	"?MKLSIO   SWITCHES ILLEGAL ON OUTPUT"
MKLTMS:	ASCIZ	"?MKLTMS	TOO MANY SWITCHES"
EMES7:	ASCIZ	" NOT FOUND OR MODULE NAMES NOT IN SEQUENCE"
EMES7A:	ASCIZ	"%MKLNPS   NO PROGRAM NAMES SPECIFIED"
EMES10:	ASCIZ	"?ENTRY BLOCK TOO LARGE, PROGRAM "
EMES11:	ASCIZ	"?INPUT ERROR ON DEVICE "
EMES15:	ASCIZ	"?OUTPUT ERROR ON DEVICE "
EMS15A:	ASCIZ	" STATUS ("
EMES22: ASCIZ "?NOT ENOUGH CORE AVAILABLE "
EMES23:	ASCIZ	"?OUTPUT DEVICE MUST BE DSK OR DTA"
EMES26:	ASCIZ	" IS AN ILLEGAL BLOCK TYPE"
SUBTTL IMPURE CODE

IFN PURESW,<
HIGH:	PHASE	LOW>

INGET2:	IN	0,		;INPUT A BUFFER OF DATA
	JRST	GETIN1		;NO ERRORS
INGET3:	STATZ	, IO.EOF		;END OF FILE?
	JRST	POPOUT		;YES, HIGH LEVEL EXIT
	JRST	ERR11		;ERROR

DIRIOW:	IOWD	200,DIRBLK	;IOWD FOR DIRECTORY INPUT
	0			;MUST BE IN LOW SEGMENT
IFN PURESW,<
LOWBLK:
	DEPHASE>
SUBTTL STORAGE AND BUFFERS

IFN PURESW,<	RELOC LOW>
LOW:
IFN PURESW,<	BLOCK	LOWBLK-LOW>

PDLIST:	BLOCK	200
TMAREA:	BLOCK	FSSIZE
OFFSET:	BLOCK	1
ORGFF:	BLOCK	1
SWIWRD:	BLOCK	2
INBEG:	BLOCK	1
INEND:	BLOCK	1
OUTBEG:	BLOCK	1
OUTEND:	BLOCK	1
CURFIL:	BLOCK	1
OPNBLK:	BLOCK	3
LKPBLK:	BLOCK	.RBSIZ+1
WLDTMP:	BLOCK	1
NAMCTR:	BLOCK	1
TNMCTR: BLOCK	1

FILSAV:	BLOCK	1
BLKCNT:	BLOCK	1		;NUMBER OF BUFFERS OUTPUT
SAVEAC:	BLOCK	1
SAVEBT:	BLOCK	1
FILBUF:	BLOCK	N
DEVBUF:	BLOCK	DEVNO
ENTBLK:	BLOCK	X+1
SVEBLK:	BLOCK	X+1
	BLOCK	2		;FOR EXTENDED LOOKUP AND ENTERS
OBUF:	BLOCK	6		;TTY:, OUTPUT DEV:
IBUF:	BLOCK	30		;INPUT DEVICES (10)

DSKHDR:	BLOCK N+2	;TWO WORDS OF OVERHEAD [P,P]+EXT
DIRBLK=DSKHDR+2
DIRNAM=DIRBLK+123	;FILENAMES IN DTA DIRECTORY START HERE

BSZ:	BLOCK	1		;SIZE OF OLD SYMBOL BLOCK
PTGRS:	BLOCK	1		;PTGR SAVED
PTSRS:	BLOCK	1		;PTSR SAVED
RELOCS:	BLOCK	1		;ORIGINAL RELOC
SYMBLK:	BLOCK	^D20		;NEW SYMBOL BLOCK

XCOUNT:	BLOCK	1
XPNTR:	BLOCK	1
BUFSIZ:	BLOCK	1
XBEG:	BLOCK	2
END1:	BLOCK	1	;FIRST WORD OF END BLOCK
END2:	BLOCK	2	;SECOND WORD OF END BLOCK
NAMSAV:	BLOCK	1
	VAR		;JUST IN CASE

LOWTOP:
IFN PURESW,<	RELOC>
SUBTTL CONSTANTS,POINTERS AND LITERALS

SYMPTR:	POINT	6, R
PTSR:	POINT	4,SYMBLK+1	;TO STORE RELOCATION
PTGR:	POINT	4,RELOCS	;TO GET RELOCATION

	LIT

	END	MAKLIB


