TITLE	MACRO %50(272)	
SUBTTL	 RPG/CMF/JF/PMH/DMN	10-OCT-74
;COPYRIGHT 1968,1969,1970,1971,1972,1973,1974,  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

	VMACRO==50		;VERSION NUMBER
	VUPDATE==0		;DEC UPDATE LEVEL
	VEDIT==272		;EDIT NUMBER
	VCUSTOM==0		;NON-DEC UPDATE LEVEL


	LOC	<.JBVER==137>
	<VCUSTOM>B2+<VMACRO>B11+<VUPDATE>B17+VEDIT
	RELOC

COMMENT	*	ASSEMBLY FEATURE SWITCHES (ACTION WHEN NON-ZERO)

	SWITCHES ON (NON-ZERO) IN DEC VERSION
PURESW		GIVES TWO SEGMENT MACRO
CCLSW		GIVES RAPID PROGRAM GENERATION FEATURE
TEMP		TMPCOR UUO IS TO BE USED
FORMSW		USE MORE READABLE FORMATS FOR LISTING (ICCSW)
DFRMSW		DEFAULT CONDITION OF FORMAT PRINTING (MULTI-FORM IF ON)
KI10		GIVES KI10 OP-CODES

	SWITCHES OFF (ZERO) IN DEC VERSION
STANSW		GIVES STANFORD FEATURES
LNSSW		GIVES LNS VERSION
IIISW		GIVES III FEATURES
OPHSH		GIVES HASH SEARCH OF OPCODES
TENEX		GIVES BBN TENEX FEATURES
POLISH		GIVES EXTERNAL ARITHMETIC EXPRESSIONS
		AND PSECT MULTIPLE RELOCATION COUNTERS
*
SUBTTL	DEFAULT ASSEMBLY SWITCH SETTINGS
TENEX==1

IFNDEF PURESW,<PURESW==1>

IFNDEF STANSW,<STANSW==0>
IFN STANSW,<CCLSW==1>

IFNDEF LNSSW,<LNSSW==0>

IFNDEF CCLSW,<CCLSW==1>

IFNDEF TEMP,<TEMP==1>


IFNDEF IIISW,<IIISW==0>
IFN IIISW,<
IFNDEF DFRMSW,<DFRMSW==0>>

IFNDEF DFRMSW,<DFRMSW==1>
IFN DFRMSW,<FORMSW==1>

IFNDEF FORMSW,<FORMSW==1>

IFNDEF OPHSH,<OPHSH==0>

IFNDEF KI10,<KI10==1>

IFNDEF TENEX,<TENEX==0>

IFNDEF POLISH,<POLISH==0>
SUBTTL	REVISION HISTORY

;START OF 50
;114	(6113)	TIDY UP SYMBOL TABLE LISTING
;115		IMPLEMENT BINARY UNIVERSAL FILES
;116	(6272)	CORRECT LISTING OF CERTAIN BYTE FIELDS
;117	(6321)	MINOR FIX FOR I.S.C.
;120	(6245)	LABEL IN LITERAL
;121		ADD PSEUDO-OP .COMMON
;122		ADD PSEUDO-OPS .REQUIRE AND .REQUEST
;123		ADD ^! (XOR) AND ^- (NOT) OPERATORS
;124	(6350)	V ERRORS ON PASS 1
;125	(6483)	X ERRORS ON PASS 1
;126		SOME SLIGHT SPEEDUPS IN BYPASS ROUTINE (NOW A MACRO)
;127		FREE A FLAG BIT FOR POLISH FIXUPS (FUTURE)
;130	(6482)	GENERATE MULTIPLE CREF NO. FOR EXP 1,2,3,,ETC.
;131	(6476)	REMOVE BLANKS AT END OF COMMAND STRING
;132	(6477)	INCORRECT DEFAULT EXT FOR @ FILES
;133	(6475)	MISSING MACRO LISTING WITH SALL
;134	(6506)	FIX BUG IN HASHED OPCODES
;135	(6764)	MAKE OPDEF PRINT VALUE LIKE =
;136	(6803)	ADD SYMBOL .CPU. FOR HOST CPU TYPE
;137	(6765)	BETTER HANDLING OF () IN MACRO CALLS
;140	(6708)	DON'T NEED <> FOR SINGLE LINE CONDITIONALS
;141	(6629)	DON'T CREF .XCREF
;142	(6509)	COUNT PAGES CORRECTLY ON PRGEND
;143	(6698)	GIVE "Q" ERROR  IF MORE THAN 18 BIT VALUES IN XWD
;144		CHANGE EOL CHAR TO LF, QIVE "Q" ERROR ON FREE CR
;145		MAKE "Q" ERRORS PRINT AS WARNINGS INSTEAD OF ERRORS
;146		CALL HELPER TO PRINT HELP TEXT
;147		ADD NEW I/O DEVICE CODES AND NEW UUOS
;150	(6894)	FIX LOCATION COUNTER IN PHASE CODE
;151		ADD FAIL COMPATIBLE PSEUDO-OP .LINK (LINK), .LNKEND (LNKEND), .ORG (ORG)
;152	(7063)	COUNT <> IN CHARACTER LOOKAHEAD
;153	(6981)	VERY LONG SEQUENCED LINES DON'T PRINT CORRECTLY
;154	(7018)	87 CHAR LONG LINE GET EXTRA CR-LF IN LISTING
;155	(7005)	LABEL IN LITERALS AGAIN
;156	(7116)	SUPERSEDED BY 225
;157	(7027)	PRINT SEQUENCED BLANK LINE
;160	(7078)	GARBAGE IN BITS 0-3 OF RADIX-50 IN SOME MACROS
;161	(7373)	MAKE PAGE PSEUDO-OP INCREASE PAGE INCREMENT NO. ONLY
;162		ADD SFD LOGIC
;163	(7435)	SUPERSEDED BY 204
;164		ADD POLISH EXPRESSIONS (NOT SUPPORTED)
;165		REMOVE 0 LISTED ON FIRST LINE AFTER PRGEND
;167	(7462)	ADD ! TO SUPPRESS SYMBOLS
;170	(7638)	FIX ILL MEM REFS ON PRGEND
;171	(8374)	TEST AND GIVE ERROR IF EXP AFTER \ IN MACRO CALL IS A MACRO
;173	(8264)	SAVE AND RESTORE ACCS IN SYN ROUTINE IF CORE EXPANSION IS REQUIRED
;175	(8606)	ONLY USE ASCII 37 AS CONTINUATION CHARACTER IF AT END OF LINE
;176	(8633)	CORRECTLY HANDLE <> IN COMMENTS IN MACROS AFTER ;;
;200		MAKE DEFAULT NUMBER OF BUFFERS BE 5
;201		ADD DATE75 HACK
;202		ADD PSEUDO-OP .DIRECTIVE
;203	(10071)	FIX TWOSEG & PRGEND INTERACTION SO LOAD FORLIB IN LOW SEG
;204	(11044)	CLEAR PNTF IF 18 BIT VALUE (UNLESS EXTERN) AT INSRT4
;205	(10820)	FIX #154 INCASE IN MACROS
;206		ADD TENEX FEATURES
;207		FORCE END STATEMENT IF END NOT SEEN
;210		ADD EXTERNAL START ADDRESS ON END STATEMENT
;211		ALLOW <> IN COMMAND TO BE SAME AS []
;212		PUT ERROR MESSAGES IN STANDARD FORM
;213		PUT ASSEMBLY ERRORS IN CREF TABLE
;214		OUTPUT COMPILER TYPE IN HEADER BLOCK (TYPE 6)
;215	(9810)	DON'T LIST COMMENT BEFORE MACRO EXPANSION IF IN REPEAT
;216		MAKE DEFAULT [DIRECTORY] WORK
;217	(9996)	TURN ON SALL IN LITERALS SO MACRO CALLS DON'T EXPAND
;220	(9633)	MAKE .XCREF APPLY TO SPECIFIC SYMBOLS
;221	(9508)	IF NEXT LINE AFTER TAPE PSEUDO-OP IS FF OR VT LIST IT
;222	(9499)	MORE OF #124
;223	(10393)	FIX ILL MEM REF ON END MACRO
;224	(S-033)	MINOR VERSION NUMBER DECODE LOGIC WRONG
;225	(11907)	REDEFINING MACROS IN PRGENDS
;226	(11929)	MORE OF ABOVE, WHEN A UNIVERSAL FILE HAS BEEN READ
;227	(S-034)	ADD SWITCH /nnL TO GIVE LINES/PAGE, ALSO MAKE 2 LARGER
;230		DON'T SEARCH UNIVERSAL FILE ON LABEL & ASSIGNMENT DEFINITIONS
;231		EXPAND CORE TO HOLD BOTH COPIES IN UNIVERSAL AND PRGEND
;232		ADD .TEXT PSEUDO-OP TO GENERATE ASCIZ BLOCK TYPE FOR LINK-10
;233		CHECK FOR INVALID ARG TO BLOCK PSEUDO-OP
;234		OUTPUT CPU TIME TAKEN FOR ASSEMBLY
;235		ADD .DIRECTIVE KA10,KI10 TO SET BIT IN BLOCK TYPE 6
;236		FIX SALL/XLIST BUG, MAKE XALL ONLY TURN OFF SALL
;237	(12493)	GIVE U ERROR ON LABEL DEFINED AND USED IN SAME LITERAL
;240	(12631)	ENHANCEMENTS TO BINARY UNIVERSALS
;241	(13033) INCORRECT CHECKING OF ACC "C" AGAINST ASCII AT STMNT2+13
;242	(13034) SAVE AC0 (AND SOME OTHERS) AT OUTPL1
;243	(13402) MAKE LOWER CASE WORK WITH SINGLE QUOTES
;244		EXTEND EDIT #210 TO ALLOW EXTERNAL + CONSTANT
;245	(13047)	FLAG QUESTIONABLE USE OF SINGLE QUOTE WITH "Q" ERROR
;246	(13119)	WRITE CREF FILE IN DEFAULT PATH
;247	(12803)	FLAG QUESTIONABLE USE OF # AND ## ON SAME SYMBOL
;250	(13032)	CLEAR MORE ERROR BITS ON PASS1 IN MULTI-LINE LITERAL
;251		FIX PROGRAM BREAK IF LIT STATEMENT IN PRGEND
;252		DON'T GIVE "Q" ERROR ON EXTRA "CR" (SEE EDIT #144)
;253		DON'T PRINT GARBAGE ON PASS1 ERROR IN MULTI-LINE LIT
;254		USE ALL AVAILABLE PRINTING SPACES FOR LONG LINES
;255		FIX UNARY MINUS BUG IN EDIT #164
;256	(13664)	HANDLE SPECIAL EXTERN IN UNIVERSAL CORRECTLY
;257		HANDLE VERTICAL TABS CORRECTLY
;260		FIX BUG IN #140, THROW AWAY JUNK BEFORE COMMA
;261		HANDLE SOS PAGE MARK CORRECTLY
;262		TRAP ILL MEM REF CAUSED BY MISSING CLOSE PAREN IN MACRO ARG LIST (#137)
;263		DON'T DESTROY ACC RC IN LONG LINE OF ASCIZ TEXT
;264		FIX BUG IN #175 CAUSING EXTRA CR-LF
;265		ADD PSECT CODE UNDER POLISH SWITCH, THIS IS VERSION 51 ONLY
;266		FIX LOOP CAUSED BY MISSING ")" IN SEARCH MODS (#240)
;267		DON'T PASS DEFINITION FLAG TO CREF ON ##
;270		DOUBLE SIZE OF BASIC PUSHDOWN STACK
;271		ADD .IF PSEUDO-OP
;272		FIX LOOP CAUSED BY #260 IF EOL ENCOUNTERED
SUBTTL	OTHER PARAMETERS

.PDP==	^D100		;[270] BASIC PUSH-DOWN POINTER
IFNDEF LPTWID,<LPTWID==^D132>	;DEFAULT WIDTH OF PRINTER
.LPTWD==8*<LPTWID/8>		;USEFUL WIDTH IN MAIN LISTING
.CPL==	.LPTWD-^D32		;WIDTH AVAILABLE FOR TEXT WHEN
				;BINARY IS IN HALFWORD FORMAT
.CPLX==LPTWID-.LPTWD		;[254] EXCESS SPACE IN LAST TAB STOP
IFNDEF .LPP,<			;[227]
	IFE STANSW,<.LPP==^D57	;LINES/PAGE>
	IFN STANSW,<.LPP==^D52	;LINES/PAGE>
>
.STP==	^D40		;STOW SIZE
.TBUF==	^D80		;TITLE BUFFER
.SBUF==	^D80		;SUB-TITLE BUFFER
.IFBLK==^D20		;IFIDN COMPARISON BLOCK SIZE
.R1B==^D18
.UNIV==^D10		;NUMBER OF UNIVERSAL SYMBOL TABLES ALLOWED
.LEAF==4		;SIZE OF BLOCKS IN MACRO TREE
.UVER==4		;[115] VERSION # OF UNV FILE
.SFDLN==5		;[162] NUMBER OF SFD'S ALLOWED

NCOLS==LPTWID/^D32		;NUMBER OF COLUMNS IN SYMBOL TABLE
SGNSGS==^D64			;MAX # OF DISTINCT PSECTS ALLOWED
				;IN ONE ASSEMBLY
SGNDEP==^D16			;MAX PSECT DEPTH ALLOWED
IFN CCLSW,<IFNDEF CTLSIZ,<CTLSIZ==^D200>>
IFN OPHSH,<IFNDEF PRIME,<PRIME==^D701>>
IFNDEF NUMBUF,<NUMBUF==5>	;[200] NUMBER OF INPUT BUFFERS

EXTERN	.JBREL,.JBFF,.JBAPR,.JBSA,.JBERR
EXTERN	.HELPR
IFDEF .REQUEST,<.REQUEST REL:HELPER  >	;[122]

LOWL:!				;START OF LOW SEGMENT
IFN PURESW,<TWOSEGMENTS
	RELOC 400000>

	SALL		;SUPPRESS ALL MACROS

;SOME ASCII CHARACTERS

HT==11
LF==12
VT==13
FF==14
CR==15
CZ==32
EOL==33
CLA==37
			;ACCUMULATORS
AC0==	0
AC1=	AC0+1
AC2=	AC1+1
SDEL=	3		;SEARCH INCREMENT
SX=	SDEL+1		;SEARCH INDEX
ARG=	5		;ARGUMENT
V=	6		;VALUE
C=	7		;CURRENT CHARACTER
CS=	C+1		;CHARACTER STATUS BITS
RC=	11		;RELOCATION BITS
MWP=	12		;MACRO WRITE POINTER
MRP=	13		;MACRO READ POINTER
IO=	14		;IO REGISTER (LEFT)
ER==	IO		;ERROR REGISTER (RIGHT)
FR=	15		;FLAG REGISTER (LEFT)
RX==	FR		;CURRENT RADIX (RIGHT)
MP=	16		;MACRO PUSHDOWN POINTER
PP=	17		;BASIC PUSHDOWN POINTER

%OP==	3
%MAC==	5
%DSYM==	2
%SYM==	1
%DMAC==	%MAC+1
%ERR==%MAC

OPDEF	RESET	[CALLI	 0]
OPDEF	SETDDT	[CALLI   2]
OPDEF	DDTOUT	[CALLI	 3]
OPDEF	DEVCHR	[CALLI	 4]
OPDEF	CORE	[CALLI	11]
OPDEF	EXIT	[CALLI	12]
OPDEF	UTPCLR	[CALLI	13]
OPDEF	DATE	[CALLI	14]
OPDEF	APRENB	[CALLI	16]
OPDEF	MSTIME	[CALLI	23]
OPDEF	PJOB	[CALLI	30]
OPDEF	RUN	[CALLI	35]
OPDEF	TMPCOR	[CALLI	44]
OPDEF	MTWAT.	[MTAPE	 0]
OPDEF	MTREW.	[MTAPE	 1]
OPDEF	MTEOT.	[MTAPE	10]
OPDEF	MTSKF.	[MTAPE	16]
OPDEF	MTBSF.	[MTAPE	17]


			;FR  FLAG REGISTER (FR/RX)
IOSCR== 000001		;NO CR AFTER LINE
POLSW== 000002		;[164] DOING POLISH ON GLOBALS
MTAPSW==000004		;MAG TAPE
ERRQSW==000010		;IGNORE Q ERRORS
LOADSW==000020		;END OF PASS1 & NO EOF YET
DCFSW==	000040		;DECIMAL FRACTION
RIM1SW==000100		;RIM10 MODE
NEGSW==	000200		;NEGATIVE ATOM
RIMSW==	000400		;RIM OUTPUT
PNCHSW==001000		;RIM/BIN OUTPUT WANTED
CREFSW==002000
R1BSW== 004000		;RIM10 BINARY OUTPUT
TMPSW==	010000		;EVALUATE CURRENT ATOM
INDSW==	020000		;INDIRECT ADDRESSING WANTED
RADXSW==040000		;RADIX ERROR SWITCH
FSNSW== 100000		;NON BLANK FIELD SEEN
MWLFLG==200000		;ON FOR DON'T ALLOW MULTI-WORD LITERALS
P1==	400000		;PASS1

			;IO FLAG REGISTER (IO/ER)
FLDSW==	400000		;ADDRESS FIELD
IOMSTR==200000
ARPGSW==100000		;ALLOW RAPID PROGRAM GENERATION
IOPROG==040000		;SUPRESS LISTING (LIST/XLIST PSEUDO OP)
NUMSW==	020000
IOMAC==	010000		;MACRO EXPANSION IN PROGRESS
IOPALL==004000		;SUPRESS LISTING OF MACRO EXPANSIONS
IONCRF==002000		;SUPRESS OUTPUT OF CREF INFORMATION
CRPGSW==001000		;CURRENTLY IN PROGRESS ON RPG
IOCREF==000400		;WE ARE NOW OUTPUTTING CREF INFO
IOENDL==000200		;BEEN TO STOUT
IOPAGE==000100
DEFCRS==000040		;THIS IS A DEFINING OCCURANCE (MACROS)
IOIOPF==000020		;IOP INSTRUCTION SEEN
MFLSW== 000010		;MULTI-FILE MODE,PRGEND SEEN
IORPTC==000004		;REPEAT CURRENT CHARACTER
RSASSW==000002		;[265] REFERENCE IS TO A SYMBOL IN ANOTHER PSECT
IOSALL==000001		;SUPPRESS MACRO LISTING EVEN IF BINARY IS GENERATED

OPDEF	JUMP1	[JUMPL	FR,  ]	;JUMP IF PASS 1
OPDEF	JUMP2	[JUMPGE	FR,  ]	;JUMP IF PASS 2

OPDEF	JUMPOC	[JUMPGE	IO,  ]	;JUMP IF IN OP-CODE FIELD
OPDEF	JUMPAD	[JUMPL	IO,  ]	;JUMP IF IN ADDRESS FIELD

OPDEF	JUMPCM	[JUMPL	CS,  ]	;JUMP IF CURRENT CHAR IS COMMA
OPDEF	JUMPNC	[JUMPGE	CS,  ]	;JUMP IF CURRENT CHAR IS NON-COMMA

OPDEF	PJRST	[JRST]		;JUMP TO POPJ PP,	;RETURN
OPDEF	HALT	[HALT]		;TO PUT IN CREF TABLE

			;ER ERROR REGISTERS (IO/ER)
ERRS==	000010		;[265] ILLEGAL PSECT USAGE
ERRM==	000020		;MULTIPLY DEFINED SYMBOL
ERRE==	000040		;ILLEGAL USE OF EXTERNAL
ERRP==	000100		;PHASE DISCREPANCY
ERRO==	000200		;UNDEFINED OP CODE
ERRN==	000400		;NUMBER ERROR
ERRV==	001000		;VALUE PREVIOUSLY UNDEFINED
ERRU==	002000		;UNDEFINED SYMBOL
ERRR==	004000		;RELOCATION ERROR
ERRL==	010000		;LITERAL ERROR
ERRD==	020000		;REFERENCE TO MULTIPLY DEFINED SYMBOL
ERRA==	040000		;PECULIAR ARGUMENT
ERRX==	100000		;MACRO DEFINITION ERROR
ERRQ==	200000		;QUESTIONABLE, NON-FATAL ERROR
ERROR1==ERRP!ERRM!ERRV!ERRX	;[125] ERRORS THAT PRINT ON PASS 1
ERRORS==777760
LPTSW==	000002
TTYSW==	000001

			;SYMBOL TABLE FLAGS
SYMF==	400000		;SYMBOL
TAGF==	200000		;TAG
NOOUTF==100000		;NO DDT OUTPUT WFW
SYNF==	040000		;SYNONYM
MACF==	SYNF_-1		;MACRO
OPDF==	SYNF_-2		;OPDEF
PNTF==	004000		;"VALUE" IN SYMBOL TBL IS PNTR TO 36BIT VALUE
UNDF==	002000		;UNDEFINED
EXTF==	001000		;EXTERNAL
INTF==	000400		;INTERNAL
ENTF==	000200		;ENTRY
VARF==	000100		;VARIABLE
NCRF==  000040		;[220] DO NOT CREF THIS SYMBOL
MDFF==	000020		;MULTIPLY DEFINED
SPTR==	000010		;SPECIAL EXTERNAL POINTER
SUPRBT==000004		;SUPRESS OUTPUT TO REL AND LISTING
LELF==	000002		;LEFT HAND RELOCATABLE
RELF==	000001		;RIGHT HAND RELOCATABLE

LITF==  200000		;FLAG FOR PSEUDO-OPS INVALID IN LIT'S
ADDF==  100000		;FLAG FOR PSEUDO-OPS INVALID IN ADDRESSES

TNODE==	200000		;TERMINAL NODE FOR EVALEX

;USEFUL MACROS

DEFINE FORERR(AC,ABC)<
	MOVE	AC,[PAGENO,,ABC'PG]
	BLT	AC,ABC'PG+3
>

;MACRO TO BYPASS LEADING TABS AND SPACES
DEFINE BYPASS <
	PUSHJ	PP,GETCHR
	JUMPE	C,.-1
>

SUBTTL	START ASSEMBLING

ASSEMB:	PUSHJ	PP,INZ		;INITIALIZE FOR PASS
	SKIPA	AC1,.+1		;LOCALIZED CODE
	ASCII	/.MAIN/
	MOVEM	AC1,TBUF
	SETZM	TBUF+1		;SIGNAL NOT YET SEEN A TITLE
	MOVEI	SBUF
	HRRM	SUBTTX

ASSEM1:	PUSHJ	PP,CHARAC	;TEST FOR FORM FEED
	SKIPGE	LIMBO		;CRLF FLAG?
	JRST	ASSEM1		;YES ,IGNORE LF
	CAIN	C,14
	SKIPE	SEQNO
	JRST	ASSEM2
	PUSHJ	PP,OUTFF1
	PUSHJ	PP,OUTLI
	JRST	ASSEM1

ASSEM2:	AOS	TAGINC
	CAIN	C,"\"		;BACK-SLASH?
	TLZA	IO,IOMAC	;YES, LIST IF IN MACRO
	TLO	IO,IORPTC
	PUSHJ	PP,STMNT	;OFF WE GO
	TLZN	IO,IOENDL	;WAS STOUT PRE-EMPTED?
	PUSHJ	PP,STOUT	;NO, POLISH OFF LINE
	JRST	ASSEM1

SUBTTL	STATEMENT PROCESSOR

STMNT:	TLZ	FR,INDSW!FSNSW
	TLZA	IO,FLDSW
STMNT1:	PUSHJ	PP,LABEL
STMNT2:	PUSHJ	PP,ATOM		;GET THE FIRST ATOM
	CAIN	C,'='		;"="?
	JRST	ASSIGN		;YES
	CAIN	C,':'		;":"?
	JRST	STMNT1		;YES
	JUMPAD	STMNT7		;NUMERIC EXPRESSION
	JUMPN	AC0,STMN2A	;JUMP IF NON NULL FIELD
	SKIPN	LITLVL		;ALLOW COMMA IN LITERALS
	CAIE	C,','		;NULL, COMMA?
	CAIN	C,EOL		;OR END OF LINE?
	POPJ	PP,		;YES,EXIT
	CAIN	C,']'		;[241] CLOSING LITERAL?
	POPJ	PP,		;YES
	JRST	STMNT9		;NO,AT LEAST SKIP ALL THIS NONSENSE

STMN2A:	JUMPE	C,.+2
	TLO	IO,IORPTC
	PUSHJ	PP,MSRCH	;SEARCH FOR MACRO/OPDEF/SYN
	  JRST	STMNT3		;NOT FOUND, TRY OP CODE
	LDB	SDEL,[POINT 3,ARG,5]
	JUMPE	SDEL,ERRAX	;ERROR IF NO FLAGS
	SOJE	SDEL,OPD1	;OPDEF IF 1
	SOJE	SDEL,CALLM	;MACRO IF 2
	JRST	STMNT4		;SYNONYM, PROCESS WITH OP-CODES

STMNT3:	PUSHJ	PP,OPTSCH	;SEARCH OP CODE TABLE
	  JRST	STMNT5		;NOT FOUND
STMNT4:	HLLZ	AC0,V		;PUT CODE IN AC0
	TRZ	V,ADDF		;CLEAR ADDRESS NON-VALID FLAG
	TRZE	V,LITF		;VALID IN LITERAL?
	SKIPN	LITLVL		;NO, ARE WE IN A LITERAL?
	JRST	0(V)		;NO, GO TO APPROPRIATE PROCESSOR
	POPJ	PP,		;YES,EXIT

STMNT5:	PUSHJ	PP,SSRCH	;TRY SYMBOLS
	  JRST	STMNT8		;NOT FOUND
	TLNN	ARG,EXTF!UNDF	;EXTERNAL OR UNDEFINED?
	TDNE	RC,[-2,,-2]	;CHECK FOR EXTERNAL
	JRST	STMNT7		;YES, PROCESS IN EVALEX
	MOVE	AC0,V		;FOUND, PUT VALUE IN AC0
	TLO	IO,NUMSW	;FLAG AS NUMERIC
STMNT7:	TLZ	IO,IORPTC
STMNT9:	PUSHJ	PP,EVALHA	;EVALUATE EXPRESSION
IFN FORMSW,<	MOVE	AC1,HWFORM	;USE STANDARD FORM>
	TLNE	FR,FSNSW	;FIELD SEEN?
	JRST	STOW		;YES,STOW THE CODE AND EXIT
	CAIE	C,']'		;CLOSING LITERAL?
	TRO	ER,ERRQ		;NO, GIVE "Q" ERROR
	POPJ	PP,		;EXIT

STMNT8:	MOVEI	V,0		;ALWAYS START SCAN WITH 0
	CAIL	V,CALNTH	;END OF TABLE?
	JRST	STMN8C		;YES, TRY TTCALLS
	CAME	AC0,CALTBL(V)	;FOUND IT?
	AOJA	V,.-3		;NO,TRY AGAIN
	SUBI	V,NEGCAL	;CALLI'S START AT -1
	HRLI	V,(CALLI)	;PUT IN UUO
STMN8D:	MOVSI	ARG,OPDF	;SET FLAG FOR OPDEF
STMN8B:	PUSHJ	PP,INSERT	;PUT OPDEF IN TABLE
	JRST	OPD		;AND TREAT AS OPDEF

STMN8C:	SETZ	V,		;START WITH ZERO
	CAIL	V,TTCLTH	;END OF TABLE?
	JRST	STMN8E		;TRY MTAPES
	CAME	AC0,TTCTBL(V)	;MATCH?
	AOJA	V,.-3		;NO, KEEP TRYING
	LSH	V,5		;PUT IN AC FIELD (RIGHT HALF)
	HRLZI	V,<(TTCALL)>(V)	;PUT UUO IN LEFT HALF
	JRST	STMN8D		;SET OPDEF FLAG

STMN8E:	SETZ	V,		;START AT ZERO
	CAIL	V,MTALTH	;END OF TABLE?
	JRST	STMN8A		;YES, ERROR
	CAME	AC0,MTATBL(V)	;MATCH
	AOJA	V,.-3		;NOT YET
	PUSH	PP,AC0		;SAVE IT
	MOVE	AC0,[POINT 9,MTACOD]
	IBP	AC0		;GET TO RIGHT ONE
	SOJGE	V,.-1		;EVENTUALLY
	LDB	V,AC0		;GET FUNCTION
	HRLI	V,(MTAPE)	;FILL IN OPCODE
	POP	PP,AC0
	JRST	STMN8D

STMN8A:	SETZB	V,RC		;CLEAR VALUE AND RELOCATION
	TRO	ER,ERRO		;FLAG AS UNDEFINED OP-CODE
	JUMP1	OPD		;TREAT AS STANDARD OP ON PASS1
	MOVSI	ARG,OPDF!UNDF!EXTF	;SET A FEW FLAGS
	JRST	STMN8B		;TO FORCE OUT A MESSAGE

	SUBTTL	LABEL PROCESSOR
	
LABEL:	JUMPAD	LABEL4		;COMPARE IF NON-SYMBOLIC
	JUMPE	AC0,LABEL5	;ERROR IF BLANK
	TLO	IO,DEFCRS	;THIS IS A DEFINITION
	PUSH	PP,UNISCH+1	;SAVE SEARCH LIST
	SETZM	UNISCH+1	;BUT DISALLOW
	PUSHJ	PP,SSRCH	;SEARCH FOR OPERAND
	  MOVSI	ARG,SYMF!UNDF!TAGF	;NOT FOUND
	POP	PP,UNISCH+1	;RESTORE STATUS
	TLNN	ARG,EXTF	;OPERAND FOUND (SKIP EXIT)
	JRST	LABEL0
	JUMP1	LABEL3		;ERROR ON PASS1
	TLNN	ARG,UNDF	;UNDEFINED ON PASS1
	JRST	LABEL3		;NO, FLAG ERROR
	TLZ	ARG,EXTF!PNTF	;TURN OFF EXT FLAG NOW
	JUMPE	V,LABEL0	;NOTHING TO CHAIN IF 0
	MOVE	RC,LOCAL	;GET CURENT POINTER
	MOVEM	RC,1(ARG)	;STORE OVER NAME
	HRRM	ARG,LOCAL	;LINK INTO CHAIN
	MOVE	RC,LOCA		;GET CURRENT LOCATION
	HRLM	RC,(ARG)	;STORE BUT SWAPPED
	LSH	V,-^D17		;SHIFT RELOCATION TO BIT 34
	IOR	V,MODA		;CURRENT RELOCATION
	HRLM	V,1(ARG)	;STORE IT
LABEL0:	TLZN	ARG,UNDF!VARF	;WAS IT PREVIOUSLY DEFINED?
	JRST	LABEL2		;YES, CHECK EQUALITY
	MOVE	V,LOCA		;WFW
	MOVE	RC,MODA
	TLO	ARG,TAGF
	PUSHJ	PP,PEEK		;GET NEXT CHAR.
	CAIE	C,":"		;SPECIAL CHECK FOR  ::
	JRST	LABEL1		;NO MATCH
	TLO	ARG,INTF	;MAKE IT INTERNAL
	PUSHJ	PP,GETCHR	;PROCESS NEXT CHAR.
	PUSHJ	PP,PEEK		;PREVIEW NEXT CHAR.
LABEL1:	CAIE	C,"!"		;HALF-KILL SIGN
	JRST	LABEL6		;NO
	TLO	ARG,NOOUTF	;YES, SUPPRESS IT
	PUSHJ	PP,GETCHR	;AND GET RID OF IT
LABEL6:	MOVEM	AC0,TAG		;SAVE FOR PASS 1 ERRORS
	HLLZS	TAGINC		;ZERO INCREMENT
	JRST	INSERT		;INSERT/UPDATE AND EXIT

LABEL2:	HRLOM	V,LOCBLK	;SAVE LIST LOCATION
IFN POLISH,<
	CAMLE	SX,SGSBOT	;IS IT IN THE
	CAMLE	SX,SGSTOP	; CURRENT PSECT
	JRST	LABEL3>		;NO, FLAG ERROR
	CAMN	V,LOCA		;DOES IT COMPARE WITH PREVIOUS? WFW
	CAME	RC,MODA
LABEL3:	TLOA	ARG,MDFF	;NO, FLAG MULTIPLY DEFINED AND SKIP
	JRST	LABEL7		;YES, GET RID OF EXTRA CHARS.
	TRO	ER,ERRM		;FLAG MULTIPLY DEFINED ERROR 
	JRST	UPDATE		;UPDATE AND EXIT
LABEL4:	CAMN	AC0,LOCA	;DO THEY COMPARE?
	CAME	RC,MODA
LABEL5:	TRO	ER,ERRP		;NO, FLAG PHASE ERROR
	POPJ	PP,

LABEL7:	SKIPN	LITLVL		;[155] LABEL IN A LITERAL?
	JRST	LABEL8		;[155] NO
	MOVEM	AC0,LITLBL	;[155] YES, SAVE LABEL NAME FOR LATER
	MOVE	AC0,STPX	;[155] CURRENT DEPTH
	SUB	AC0,STPY	;[155] MINUS START
	MOVEM	AC0,LITLBL+1	;[155] STORE DEPTH IN LIT
	MOVE	AC0,LITLBL	;[155] RESTORE 0
	TLO	ARG,UNDF	;[237] PUT BACK U FLAG
	IORM	ARG,0(SX)	;[237] INCASE REFERENCED IN SAME LITERAL
	JRST	LABEL9		;DON'T STORE LABEL IN LIT
LABEL8:	MOVEM	AC0,TAG		;SAVE FOR ERRORS
	HLLZS	TAGINC
LABEL9:	PUSHJ	PP,PEEK		;INSPECT A CHAR.
	CAIN	C,":"		;COLON?
	PUSHJ	PP,GETCHR	;YES, DISPOSE OF IT
	PUSHJ	PP,PEEK		;EXAMINE ONE MORE CHAR.
	CAIN	C,"!"		;EXCLAMATION?
	JRST	GETCHR		;YES, INDEED
	POPJ	PP,
SUBTTL	ATOM PROCESSOR
ATOM:	PUSHJ	PP,CELL		;GET FIRST CELL
	TLNE	IO,NUMSW	;IF NON-NUMERIC
ATOM1:	CAIE	C,42		;OR NOT A BINARY SHIFT,
	POPJ	PP,		;EXIT

	PUSH	PP,AC0		;STACK REGISTERS, ITS A BINARY SHIFT
	PUSH	PP,AC1
	PUSH	PP,RC
	PUSH	PP,RX
	HRRI	RX,^D10		;COMPUTE SHIFT RADIX 10
	PUSHJ	PP,CELLSF	;GET SHIFT
	MOVE	ARG,RC		;SAVE RELOCATION
	POP	PP,RX		;RESTORE REGISTERS
	POP	PP,RC
	POP	PP,AC1
	MOVN	SX,AC0		;USE NEGATIVE OF SHIFT
	POP	PP,AC0
	JUMPN	ARG,NUMER2	;IF NOT ABSOLUTE
	TLNN	IO,NUMSW	;AND NUMERIC,
	JRST	NUMER2		;FLAG ERROR
	LSHC	AC0,^D35(SX)
	LSH	RC,^D35(SX)
	JRST	ATOM1		;TEST FOR ANOTHER

CELLSF:	TLO	IO,FLDSW
CELL:	SETZB	AC0,RC		;CLEAR RESULT AND RELOCATION
	SETZB	AC1,AC2		;CLEAR WORK REGISTERS
	MOVEM	PP,PPTEMP	;SAVE PUSHDOWN POINTER
	TLZ	IO,NUMSW
	TLZA	FR,NEGSW!DCFSW!RADXSW

CELL1:	TLO	IO,FLDSW
	BYPASS
	LDB	V,[POINT 4,CSTAT(C),14]	;GET CODE
	XCT	.+1(V)		;EXECUTE, INDEX VIA BITS 11,12,13,14 OF CSTAT TABLE
	JRST	CELL1		;0; BLANK, (TAB OR "+")
	JRST	LETTER		;1; LETTER  ] $ % ( ) , ; >
	TLC	FR,NEGSW	;2; "-"
	TLO	FR,INDSW	;3; "@"
	JRST	NUM1		;4; NUMERIC   0 - 9
	JRST	ANGLB		;5; "<"
	JRST	SQBRK		;6; "["
	JRST	QUOTES		;7; ""","'" 
	JRST	QUAL		;10; "^"
	JRST	PERIOD		;11; "."
	TROA	ER,ERRQ		;12; ERROR, FLAG AND TREAT AS DELIMITER
				;12;	! # & * / : = ? \ _

LETTER:	TLOA	AC2,(POINT 6,AC0,)	;SET BYTE POINTER
LETTE1:	PUSHJ	PP,GETCHR	;GET CHARACTER
	TLNN	CS,6		;ALPHA-NUMERIC?
	JRST	LETTE3		;NO,TEST FOR VARIABLE
	TLNE	AC2,770000	;STORE ONLY SIX BYTES
LETTE2:	IDPB	C,AC2		;RETURN FROM PERIOD
	JRST	LETTE1

LETTE3:	CAIE	C,03		;"#"?
	POPJ	PP,
	JUMPE	AC0,POPOUT	;TEST FOR NULL
	PUSHJ	PP,PEEK		;PEEK AT NEXT CHAR.
	CAIN	C,"#"		;IS IT 2ND #?
	JRST	LETTE4		;YES, THEN IT'S AN EXTERN
	TLO	IO,DEFCRS
	PUSHJ	PP,SSRCH	;YES, SEARCH FOR SYMBOL (OPERAND)
	  MOVSI	ARG,SYMF!UNDF	;NOT FOUND, FLAG AS UNDEFINED SYM.
	TLNN	ARG,UNDF	;UNDEFINED?
	JRST	LETTE5		;[247] NO, BUT SEE IF ALREADY DEFINED AS EXTERNAL
	TLO	ARG,VARF	;YES, FLAG AS A VARIABLE
	TRO	ER,ERRU		;SET UNDEFINED ERROR FLAG
	PUSHJ	PP,INSERZ	;INSERT IT WITH A ZERO VALUE
	JRST	GETDEL

LETTE4:	PUSHJ	PP,GETCHR	;AND SCAN PAST IT
	TLZ	IO,DEFCRS	;[267] MAKE SURE NOT A DEFINITION
	PUSHJ	PP,EXTER5	;[267] PUT IN SYMBOL TABLE
	JRST	GETCHR		;GET RID OF #

LETTE5:	TLNE	ARG,EXTF	;[247] EXTERNAL
	TRO	ER,ERRQ		;[247] YES, FLAG WITH "Q" ERROR
	JRST	GETCHR		;[247] GET NEXT CHAR AND RETURN

NUMER1:	SETZB	AC0,RC		;RETURN ZERO
NUMER2:	TRO	ER,ERRN		;FLAG ERROR

GETDEL:	PUSHJ	PP,GETCHR
GETDE1:	JUMPE	C,.-1
	MOVEI	AC1,0
GETDE3:	TLO	IO,NUMSW!FLDSW	;FLAG NUMERIC
	TLNN	FR,NEGSW	;IS ATOM NEGATIVE?
	POPJ	PP,		;NO, EXIT
	JUMPE	AC1,GETDE2
	MOVNS	AC1
	TDCA	AC0,[-1]
GETDE2:	MOVNS	AC0		;YES, NEGATE VALUE
	MOVNS	RC		;AND RELOCATION
POPOUT:	POPJ	PP,		;EXIT

QUOTES:	CAIE	C,"'"-40	;IS IT  "'"
	JRST	QUOTE		;NO MUST BE """
	JRST	SQUOTE		;YES

QUOTE0:	TLNE	AC0,376000	;5 CHARACTERS STORED ALREADY?
	TRO	ER,ERRQ		;YES, GIVE WARNING
	ASH	AC0,7
	IOR	AC0,C
QUOTE:	PUSHJ	PP,CHARAC	;GET 7-BIT ASCII
	CAIG	C,15		;TEST FOR LF, VT, FF OR CR
	CAIGE	C,12
	JRST	.+2		;NO, SO ALL IS WELL
	JRST	QUOTE2		;ESCAPE WITH Q ERROR
	CAIE	C,42
	JRST	QUOTE0
	PUSHJ	PP,PEEK		;LOOK AT NEXT CHAR.
	CAIE	C,42
	JRST	QUOTE1		;RESTORE REPEAT LEVEL AND QUIT
	PUSHJ	PP,CHARAC	;GET NEXT CHAR.
	JRST	QUOTE0		;USE IT

QUOTE2:	TRO	ER,ERRQ		;SET Q ERROR
QUOTE1:	JRST	GETDEL

SQUOT0:	CAIL	C,"a"		;[243] TEST FOR LOWER CASE
	CAILE	C,"z"		;[243] ...
	JRST	.+2		;[243] NO
	SUBI	C," "		;[243]
	TLNE	AC0,770000	;SIX CHARS. STORED ALREADY ?
	TRO	ER,ERRQ		;YES
	LSH	AC0,6
	IORI	AC0,-40(C)	;OR IN SIXBIT CHAR.

SQUOTE:	PUSHJ	PP,CHARAC
	CAIG	C,CR
	CAIGE	C,LF
	JRST	.+2
	JRST	QUOTE2		;[245] FLAG WITH "Q" ERROR
	CAIE	C,"'"
	JRST	SQUOT0
	PUSHJ	PP,PEEK
	CAIE	C,"'"
	JRST	QUOTE1
	PUSHJ	PP,CHARAC
	JRST	SQUOT0

QUAL:	BYPASS			;SKIP BLANKS, GET NEXT CHARACTER
	CAIN	C,'B'		;"B"?
	JRST	QUAL2		;YES, RADIX=D2
	CAIN	C,'O'		;"O"?
	JRST	QUAL8		;YES, RADIX=D8
	CAIN	C,'F'		;"F"?
	JRST	NUMDF		;YES, PROCESS DECIMAL FRACTION
	CAIN	C,'L'		;"L"?
	JRST	QUALL		;YES
	CAIN	C,'-'		;[123] "^-" IS NOT
	JRST	QUALN		;[123]
	CAIN	C,'!'		;[123] "^!" IS XOR
	JRST	QUALX		;[123]
	CAIE	C,'D'		;"D"?
	JRST	NUMER1		;NO, FLAG NUMERIC ERROR
	ADDI	AC2,2
QUAL8:	ADDI	AC2,6
QUAL2:	ADDI	AC2,2
	PUSH	PP,RX
	HRR	RX,AC2
	PUSHJ	PP,CELLSF
QUAL2A:	POP	PP,RX
	TLNN	IO,NUMSW
	JRST	NUMER1
	JRST	GETDE1

QUALL:	PUSH	PP,FR
	PUSHJ	PP,CELLSF
	MOVE	AC2,AC0
	MOVEI	AC0,^D36
	JUMPE	AC2,QUAL2A
	LSH	AC2,-1
	SOJA	AC0,.-2

QUALN:	SKIPA	CS,CSTATN	;[123]
QUALX:	MOVE	CS,CSTATX	;[123]
	JRST	GETDE1		;[123]


SUBTTL	LITERAL PROCESSOR

SQBRK:	PUSH	PP,FR
	PUSH	PP,EXTPNT	;ALLOW EXTERN TO PRECEDE LIT IN XWD
	SETZM	EXTPNT
	SKIPE	LITLVL		;SAVE SEQNO AND PAGE IF NOT IN LIT ALREADY
	JRST	SQB5
	FORERR	(C,LIT)
SQB5:	JSP	AC2,SVSTOW
	PUSH	PP,[0]		;[217] STACK A ZERO
	TLNE	IO,IOPALL	;[217] LEAVE ALONE IF LALL ON
	TLON	IO,IOSALL	;[217] TEST IF SALL ALREADY ON
	SETOM	(PP)		;[217] SIGNAL NOT BY -1
SQB3:	PUSHJ	PP,STMNT
	CAIN	C,75		;CHECK FOR ]
	JRST	SQB1
	TLO	IO,IORPTC
	TLNE	FR,MWLFLG	;CALL IT ] IF NOT MULTI-WORD FLAG
	JRST	SQB2		;BUT REPEAT LAST CHARACTER
	BYPASS
	CAIN	C,EOL
	TLOA	IO,IORPTC
	TRO	ER,ERRQ
SQB4:	PUSHJ	PP,CHARAC
	CAIN	C,";"		;COMMENT?
	JRST	SQB6		;YES, IGNORE SQUARE BRACKETS
	CAIN	C,"]"		;LOOK FOR TERMINAL SQB
	TRNN	ER,ERRORS	;IN CASE OF ERROR IN LITERAL
	JRST	.+2		;NO ALL IS WELL
	JRST	SQB1		;FINISH THE LITERAL NOW!!
	CAIG	C,FF		;LOOK FOR END OF LINE
	CAIN	C,HT
	JRST	SQB4
SQB4A:	PUSHJ	PP,OUTIML	;DUMP
	PUSHJ	PP,CHARAC	;GET ANOTHER CHAR.
	SKIPL	LIMBO		;CRLF FLAG
	TLO	IO,IORPTC	;NO REPEAT
	JRST	SQB3

SQB6:	PUSHJ	PP,CHARAC	;GET A CHARACTER
	CAIG	C,CR
	CAIN	C,HT		;LOOK FOR END OF LINE CHAR.
	JRST	SQB6		;NOT YET
	JRST	SQB4A		;GOT IT

SQB1:	TLZ	IO,IORPTC
SQB2:	PUSHJ	PP,STOLIT
	SKIPE	(PP)		;[217] WAS SALL ORIGINALLY ON?
	TLZ	IO,IOSALL	;[217] NO, SO TURN IT OFF
	POP	PP,(PP)		;[217] GET STACK RIGHT
	JSP	AC2,GTSTOW
	SKIPE	LITLBL		;NEED TO FIXUP A LABEL?
	PUSHJ	PP,RELBLE	;YES, USE LOC OF LITERAL
IFN POLISH,<
	SKIPE	POLITS		;[265] NEED TO FIXUP ANY POLISH?
	PUSHJ	PP,SQBPOL	;[265] YES
>
	POP	PP,EXTPNT
	POP	PP,FR
	SKIPE	LITLVL		;WERE WE NESTED?
	JUMP1	NUMER2		;YES, FORCE ERROR IF PASS 1
	JUMP2	GETDEL		;[120] USE VALUE GIVEN IF PASS 2
	TRO	ER,ERRU		;[120] VALUE IS UNDEFINED ON PASS 1
	SETZ	AC0,		;[120] SO SET IT TO 0
	JRST	GETDEL		;[120]

RELBLE:	PUSH	PP,AC0		;SAVE LOCATION COUNTER
	PUSH	PP,RC		;AND RELOCATION
	MOVE	AC0,LITLBL	;SYMBOL WE NEED
	SETZM	LITLBL		;ZERO INDICATOR
	PUSHJ	PP,SSRCH	;SEARCH FOR OPERAND
	JRST	RELBL1		;SHOULD NEVER HAPPEN
	TLNN	ARG,TAGF	;IT BETTER BE A LABEL
	JRST	RELBL1		;IT WASN'T , GIVE UP BEFORE SOME HARM IS DONE
	TLZ	ARG,UNDF!EXTF!PNTF	;CLEAR FLAGS NOW
	POP	PP,RC		;GET LITERAL RELOCATION
	MOVE	V,(PP)		;GET VALUE (LOC COUNTER)
	ADD	V,LITLBL+1	;[155] PLUS DEPTH IN LITERAL
	PUSHJ	PP,UPDATE	;UPDATE VALUE
	POP	PP,AC0		;RESTORE LITERAL COUNT
	POPJ	PP,		;RETURN
	
RELBL1:	POP	PP,RC		;RESTORE RC
	POP	PP,AC0		;AND AC0
	POPJ	PP,		;JUST RETURN
IFN POLISH,<			;[265]
;HERE TO FIXUP POLISH EXPRESSIONS INSIDE CURRENT LIT
;AS EACH ONE IS FIXED MOVE IT TO POLIST
SQBPOL:	PUSH	PP,CS		;GET SOME FREE ACCS
	PUSH	PP,AC0		;SAVE LOC
SQBPL1:	MOVE	CS,@POLITS	;GET A BLOCK POINTER
	EXCH	CS,POLITS	;SET FOR NEXT TIME
	MOVE	AC0,CS		;GET A COPY
	EXCH	AC0,POLIST	;STORE IN LIST OF "GOOD" POLISH
	MOVEM	AC0,(CS)	;LINK IN
SQBPL2:	ADDI	CS,1		;FIRST WORD
	MOVE	AC0,(CS)	;GET SOMETHING
	JUMPL	AC0,SQBPL5	;THIS IS AN OPERATOR
	JUMPE	AC0,SQBPL4	;18 BIT VALUE
	SOJE	AC0,SQBPL3	;36 BIT VALUE
	AOJA	CS,SQBPL2	;SYMBOL

SQBPL3:	ADDI	CS,1		;SKIP OVER 2 WORDS
SQBPL4:	AOJA	CS,SQBPL2	;GET NEXT

SQBPL5:	HRRZ	AC0,AC0		;GET OPERATOR ONLY
	CAIGE	AC0,-6		;[265] CHECK FOR STORE OP
	JRST	SQBPL2		;ITS NOT
	MOVE	AC0,0(PP)	;GET ADDRESS
	ADDM	AC0,1(CS)	;ADD TO OFFSET
	HRLM	RC,1(CS)	;SET RELOCATION
	SKIPE	POLITS		;MORE TO DO?
	JRST	SQBPL1		;YES
	POP	PP,AC0		;RESTORE LOC
	POP	PP,CS		;AND SAVED AC
	POPJ	PP,
>
SUBTTL	NUMBER PROCESSOR

ANGLB:	PUSH	PP,FR
	TLZ	FR,INDSW
	PUSHJ	PP,ATOM
	TLNN	IO,NUMSW
	CAIE	C,35
	JRST	ANGLB1
	PUSHJ	PP,ASSIG1
	MOVE	AC0,V
	JRST	ANGLB2

ANGLB1:	PUSHJ	PP,EVALHA
ANGLB2:	POP	PP,FR
	CAIE	C,36
	TRO	ER,ERRN
	JRST	GETDEL

PERIOD:	PUSHJ	PP,GETCHR	;LOOK AT NEXT CHARACTER
	TLNN	CS,2		;ALPHABETIC?
	JRST	PERNUM		;NO, TEST NUMERIC
	MOVSI	AC0,'.  '	;YES, PUT PERIOD IN AC0
	MOVSI	AC2,(POINT 6,AC0,5)	;SET BYTE POINTER
	JRST	LETTE2		;AND TREAT AS SYMBOL

PERNUM:	TLNE	CS,4		;IS IT A NUMBER
	JRST	NUM32		;YES
	MOVE	AC0,LOCA	;NO. CURRENT LOC SYMBOL (.)
	MOVE	RC,MODA		;SET TO CURRENT ASSEMBLY MODE
	JRST	GETDE1		;GET DELIMITER
NUMDF:	TLO	FR,DCFSW	;SET DECIMAL FRACTION FLAG
NUM:	PUSHJ	PP,GETCHR	;GET A CHARACTER
	TLNN	CS,4		;NUMERIC?
	JRST	NUM10		;NO
NUM1:	SUBI	C,20		;CONVERT TO OCTAL
	PUSH	PP,C		;STACK FOR FLOATING POINT
	SKIPE	AC0		;ARE WE ABOUT TO LOSE SOME DATA?
	TRO	ER,ERRQ		;YES, AT LEAST WARN USER
	MOVE	AC0,AC1
	MULI	AC0,0(RX)
	ADD	AC1,C		;ADD IN LAST VALUE
	CAIL	C,0(RX)		;IS NUMBER LESS THAN CURRENT RADIX?
	TLO	FR,RADXSW	;NO, SET FLAG
	AOJA	AC2,NUM		;YES, AC2=NO. OF DECIMAL PLACES

NUM10:	CAIE	C,'.'		;PERIOD?
	TLNE	FR,DCFSW	;OR DECIMAL FRACTION?
	JRST	NUM30		;YES, PROCESS FLOATING POINT
	SETZ	CS,		;AND CLEAR IT
	CAIN	C,'K'		;SEE IF SUFFIX THERE
	MOVEI	CS,3
	CAIN	C,'M'
	MOVEI	CS,6
	CAIN	C,'G'
	MOVEI	CS,9
	JUMPE	CS,NUM12	;NO SUFFIX?
	MOVE	AC0,AC1		;SCALE THE NUMBER
	MULI	AC0,(RX)
	SOJG	CS,.-2
	PUSHJ	PP,GETCHR	;SKIP THE SUFFIX
NUM12:	MOVE	CS,CSTAT(C)	;RESTORE STATUS
	LSH	AC1,1		;NO, CLEAR THE SIGN BIT
	LSHC	AC0,^D35	;AND SHIFT INTO AC0
	MOVE	PP,PPTEMP	;RESTORE PP
	SOJE	AC2,GETDE1	;NO RADIX ERROR TEST IF ONE DIGIT
	TLNE	FR,RADXSW	;WAS ILLEGAL NUMBER ENCOUNTERED?
	TRO	ER,ERRN		;YES, FLAG N ERROR
	JRST	GETDE1

NUM30:	CAIE	C,'B'		;IF "B" THEN MISSING  "."
NUM31:	PUSHJ	PP,GETCHR
	TLNN	CS,4		;NUMERIC?
	JRST	NUM40		;NO
NUM32:	SUBI	C,20
	PUSH	PP,C
	JRST	NUM31

NUM40:	PUSH	PP,FR		;STACK VALUES
	HRRI	RX,^D10
	PUSH	PP,AC2
	PUSH	PP,PPTEMP
	CAIN	C,45		;"E"?
	JRST	[PUSHJ PP,PEEK		;GET NEXT CHAR
		PUSH	PP,C		;SAVE NEXT CHAR
		PUSHJ	PP,CELL		;YES, GET EXPONENT
		POP	PP,C		;GET FIRST CHAR. AFTER E
		CAIN	V,4		;MUST HAVE NUMERICAL STATUS
		JRST	.+2		;SKIP RETURN
		CAIN	C,"<"		;ALLOW <EXP>
		JRST	.+2		;SKIP RETURN
		SKIPN	AC0		;ERROR IF NON-ZERO EXPRESSION
		TROA	ER,ERRQ		;ALLOW E+,E-
		SETOM	RC		;FORCE NUMERICAL ERROR
		JRST	.+2]		;SKIP RETURN
	MOVEI	AC0,0		;NO, ZERO EXPONENT
	POP	PP,PPTEMP
	POP	PP,SX
	POP	PP,FR
	HRRZ	V,PP
	MOVE	PP,PPTEMP
	JUMPN	RC,NUMER1	;EXPONENT MUST BE ABSOLUTE
	ADD	SX,AC0
	HRRZ	ARG,PP
	ADD	SX,ARG
	SETZB	AC0,AC2
	TLNE	FR,DCFSW
	JRST	NUM60
	JOV	NUM50		;CLEAR OVERFLOW FLAG


NUM50:	JSP	SDEL,NUMUP	;FLOATING POINT
	JRST	NUM52		;END OF WHOLE NUMBERS
	FMPR	AC0,[10.0]	;MULTIPLY BY 10
	TLO	AC1,233000	;CONVERT TO FLOATING POINT
	FADR	AC0,AC1		;ADD IT IN
	JRST	NUM50

NUM52:	JSP	SDEL,NUMDN	;PROCESS FRACTION
	FADR	AC0,AC2
	JOV	NUMER1		;TEST FOR OVERFLOW
	JRST	GETDE1

	TLO	AC1,233000
	TRNE	AC1,-1
	FADR	AC2,AC1		;ACCUMULATE FRACTION
	FDVR	AC2,[10.0]
	JRST	NUM52

NUM60:	JSP	SDEL,NUMUP
	JRST	NUM62
	IMULI	AC0,^D10
	ADD	AC0,AC1
	JRST	NUM60

NUM62:	LSHC	AC1,-^D36
	JSP	SDEL,NUMDN
	LSHC	AC1,^D37
	PUSHJ	PP,BYPAS2
	JRST	GETDE3

	DIVI	AC1,^D10
	JRST	NUM62

NUMUP:	MOVEI	AC1,0
	CAML	ARG,SX
	JRST	0(SDEL)
	CAMGE	ARG,V
	MOVE	AC1,1(ARG)
	AOJA	ARG,1(SDEL)

NUMDN:	MOVEI	AC1,0
	CAMG	V,SX
	JRST	0(SDEL)
	CAMLE	V,ARG
	MOVE	AC1,0(V)
	SOJA	V,3(SDEL)

SUBTTL	GETSYM
GETSYM:	MOVEI	AC0,0		;CLEAR AC0
	MOVSI	AC1,(POINT 6,AC0)	;PUT POINTER IN AC1
	BYPASS			;SKIP LEADING BLANKS
	TLNN	CS,2		;ALPHABETIC?
	JRST	GETSY1		;NO, ERROR
	CAIE	C,16		;PERIOD?
	JRST	GETSY2		;NO, A VALID SYMBOL
	IDPB	C,AC1		;STORE THE CHARACTER
	PUSHJ	PP,GETCHR	;YES, TEST NEXT CHARACTER
	TLNN	CS,2		;ALPHABETIC?
GETSY1:	TROA	ER,ERRA
GETSY2:	AOS	0(PP)		;YES, SET SKIP EXIT
GETSY3:	TLNN	CS,6		;ALPHA-NUMERIC?
	JRST	BYPAS2		;NO, GET DELIMITER
	TLNE	AC1,770000	;YES, HAVE WE STORED SIX?
	IDPB	C,AC1		;NO, STORE IT
	PUSHJ	PP,GETCHR
	JRST	GETSY3


SUBTTL	EXPRESSION EVALUATOR
CV==	AC0			;CURRENT VALUE
PV==	AC1			;PREVIOUS VALUE
RC==	RC			;CURRENT RELOCATABILITY
PR==	AC2			;PREVIOUS RELOCATABILITY
CS=	CS			;CURRENT STATUS
PS==	SDEL			;PREVIOUS STATUS

EVALHA:	TLO	FR,TMPSW
EVALCM:	PUSHJ	PP,EVALEX	;EVALUATE FIRST EXPRESSION
	PUSH	PP,[0]		;MARK PDL
	JUMPCM	EVALC3		;JUMP IF COMMA
	TLO	IO,IORPTC	;IT'S NOT,SO REPEAT
	JRST	OP		;PROCESS IN OP
EVALC3:
IFN FORMSW,<PUSH PP,INFORM	;PUT FORM WORD ON STACK>
	PUSH	PP,[0]		;STORE ZERO'S ON PDL
	PUSH	PP,[0]		;.......
	MOVSI	AC2,(POINT 4,(PP),12)
	JRST	OP1B		;PROCESS IN OP

EVALEX:	TLO	IO,FLDSW
IFN POLISH,<
	TLZ	FR,POLSW	;[164] CLEAR EVALUATING POLISH FLAG
>
	PUSH	PP,[TNODE,,0]	;MARK THE LIST 200000,,0
	TLZN	FR,TMPSW
EVATOM:	PUSHJ	PP,ATOM		;GET THE NEXT ATOM
	JUMPE	AC0,EVGETD	;TEST FOR NULL/ZERO
	TLOE	IO,NUMSW	;SET NUMERIC, WAS IT PREVIOUSLY?
	JRST	EVGETD+1	;YES, TREAT ACCORDINGLY
	PUSHJ	PP,SEARCH	;SEARCH FOR MACRO OR SYMBOL
	  JRST	EVOP		;NOT FOUND, TRY FOR OP-CODE
	JUMPL	ARG,.+2		;SKIP IF OPERAND
	PUSHJ	PP,SSRCH1	;OPERATOR, TRY FOR SYMBOL (OPERAND)
	PUSHJ	PP,QSRCH	;PERFORM CROSS-REFERENCE
	JUMPG	ARG,EVMAC	;BRANCH IF OPERATOR
	MOVE	AC0,V		;SYMBOL, SET VALUE
	JRST	EVTSTS		;TEST STATUS

EVMAC:	TLNE	FR,NEGSW	;UNARY MINUS?
	JRST	EVERRZ		;YES, INVALID BEFORE OPERATOR
	LDB	SDEL,[POINT 3,ARG,5]	;GET MACF/OPDF/SYNF
	SOJL	SDEL,EVERRZ	;ERROR IF NO FLAGS

	JUMPE	C,.+2		;NON-BLANK?
	TLO	IO,IORPTC	;YES, REPEAT CHARACTER
	SOJE	SDEL,EVMAC1	;MACRO IF 2
	JUMPG	SDEL,EVOPS	;SYNONYM IF 4

	MOVE	AC0,V		;OPDEF
	MOVEI	V,OP		;SET TRANSFER VECTOR
	JRST	EVOPD

EVMAC1:	SKIPL	MACENL		;ALREADY IN CALLM?
	JRST	CALLM		;NO, EVALUATE MACRO
	SETZB	RC,AC0		;ZERO VALUE
	TRO	ER,ERRA		;SET "A" ERROR
	JRST	EVGETD		;CONTINUE EVALUATION

EVOP:	TLNE	FR,NEGSW	;OPCODE, UNARY MINUS?
	JRST	EVERRZ		;YES, ERROR

	PUSHJ	PP,OPTSCH	;SEARCH SYMBOL TABLE
	  JRST	EVOPX		;NOT FOUND
EVOPS:	TRZ	V,LITF		;CLEAR LIT INVALID FLAG
	TRZE	V,ADDF		;SYNONYM
	JRST	EVOPX		;PSEUDO-OP THAT GENERATES NO DATA JUMPS
	HLLZ	AC0,V
EVOPD:	JUMPE	C,.+2		;OPDEF, NON-BLANK DELIMITER?
	TLO	IO,IORPTC	;YES, REPEAT CHARACTER
	JSP	AC2,SVSTOW
	PUSHJ	PP,0(V)
	PUSHJ	PP,DSTOW
	JSP	AC2,GTSTOW
	TRNE	RC,-2
	HRRM	RC,EXTPNT
	TLNE	RC,-2
	HLLM	RC,EXTPNT
	JRST	EVNUM

EVOPX:	MOVSI	ARG,SYMF!UNDF
	PUSHJ	PP,INSERZ
EVERRZ:	SETZB	AC0,RC		;CLEAR CODE AND RELOCATION
EVERRU:	TRO	ER,ERRU
	JRST	EVGETD

EVTSTS:	TLNE	ARG,UNDF
	JRST	[TRO	ER,ERRU	;SET UNDEF ERROR
		JUMP1	EVGETD	;TREAT AS UNDF ON PASS1
		JRST	.+1]	;TREAT AS EXTERNAL ON PASS2
	TLNN	ARG,EXTF
	JRST	EVTSTR
	HRRZ	RC,ARG		;GET ADRES WFW
	HRRZ	ARG,EXTPNT	;SAVE IT WFW
	HRRM	RC,EXTPNT	;WFW
IFE POLISH,<			;[164] NOT NEEDED SINCE POLISH WILL TAKE CARE OF EXTERNS
	TRNE	ARG,-1		;WFW
	TRO	ER,ERRE
>
	SETZB	AC0,ARG

EVTSTR:	TLNE	ARG,MDFF	;MULTIPLY DEFINED?
	TRO	ER,ERRD		;YES, FLAG IT
	TLNN	FR,NEGSW	;[255] NEGATIVE ATOM?
	JRST	EVGETD		;[255] NO
IFN POLISH,<
	TDNE	RC,[-2,,-2]	;[255] EXTERNALS?
	JRST	NEGEXT		;[255] YES, MUST BE UNARY MINUS
>
	PUSHJ	PP,GETDE2	;[255] NO, JUST NEGATE
EVGETD:	TLNE	IO,NUMSW	;NON BLANK FIELD
	TLO	FR,FSNSW	;YES,SET FLAG
	PUSHJ	PP,BYPAS2
	TLNE	CS,6		;ALPHA-NUMERIC?
	TLO	IO,IORPTC	;YES, REPEAT IT
	CAIN	C,'^'		;[123] IS THIS THE SPECIAL ESCAPE CHAR?
	JRST	EVUPAR		;[123] YES, SEE WHAT FOLLOWS
IFN POLISH,<
	TLZN	IO,RSASSW	;INTER-PSECT REFERENCE?
	JRST	EVNUM		;NO
	PUSH	PP,SGWFND	;INX OF PSECT REFERRED TO
	PUSH	PP,[-1]		;DUMMY RELOCATION
	PUSH	PP,CSTATP>	;ADDITIVE PSECT OPERATION
EVNUM:	POP	PP,PS		;POP THE PREVIOUS DELIMITER/TNODE
	TLO	PS,4000
IFN POLISH,<
	TLC	PS,110000	;TEST FOR BITS 2 AND 5
	TLCN	PS,110000	; BOTH ON - MEANS ADDITIVE
	JRST	EVXCT>		; PSECT OPERATION
	CAMGE	PS,CS		;OPERATION REQUIRED?
	JRST	EVPUSH		;NO, PUT VALUES BACK ON STACK
	TLNN	PS,TNODE	;YES, HAVE WE REACHED TERMINAL NODE?
	JRST	EVXCT		;NO, EXECUTION REQUIRED
	TLNE	CS,170000	;[123] YES, ARE WE POINTING AT DEL? (& ! * / + - _)
	JRST	EVPUSH		;[123] NO,FALL INTO EVPUSH
IFN POLISH,<
	TLNE	FR,POLSW	;[164] BEEN RESOLVING POLISH?
	JRST	POLPOP		;[164] YES, OUTPUT IT
>
	POPJ	PP,		;NO, EXIT

;HERE TO HANDLE "^!" AND "^-"
EVUPAR:	PUSHJ	PP,GETCHR	;[123] GET CHARACTER
	CAIN	C,'!'		;[123] IOR
	MOVE	CS,CSTATX	;[123] MAKE IT XOR
	CAIN	C,'-'		;[123] NEGATE?
	MOVE	CS,CSTATN	;[123] MAKE NOT (ONE'S COMPLIMENT)
	JRST	EVNUM		;[123] EVALUATE NOW

EVPUSH:	PUSH	PP,PS		;STACK VALUES
	PUSH	PP,CV
	PUSH	PP,RC
	PUSH	PP,CS
	JRST	EVATOM		;GET NEXT ATOM

EVXCT:	POP	PP,PR		;POP PREVIOUS RELOCATABILITY
	POP	PP,PV		;AND PREVIOUS VALUE
	LDB	PS,[POINT 4,PS,29]	;[123] TYPE OF OPERATION TO PS
IFE POLISH,<
	XCT	EVTAB(PS)	;[123] PERFORM PROPER OPERATION
	JUMPN	RC,.+2		;COMMON RELOCATION TEST
EVXCT1:	JUMPE	PR,EVNUM
	TRO	ER,ERRR		;BOTH MUST BE FIXED
	JRST	EVNUM		;GO TRY AGAIN

EVTAB:	JRST	ASSEM1		;0; SHOULD NEVER GET HERE ;DMN
	JRST	XMUL		;1;
	JRST	XDIV		;2;
	JRST	XADD		;3;
	JRST	XSUB		;4;
	JRST	XLRW		;5; "_"
	IOR	CV,PV		;6; MERGE PV INTO CV
	AND	CV,PV		;7; AND PV INTO CV
	XOR	CV,PV		;10; XOR PV INTO CV
	SETCM	CV,CV		;11; NOT (ONE'S COMPLIMENT)
REPEAT 6,<HALT>			;12-17; JUST INCASE
>
IFN POLISH,<
	CAILE	PS,11		;[265] OPS 12 AND 13
	JRST	POLPSH		;[265]  REQUIRE POLISH FIXUPS
	TDNN	RC,[-2,,-2]	;CHECK FOR EXTERNALS
	TDNE	PR,[-2,,-2]	;IN EITHER OPERAND
	JUMP2	POLPSH		;CAN NOT DO IT HERE
	XCT	PRTAB(PS)	;TEST PREVIOUS RELOCATION
	XCT	RCTAB(PS)	;AND THIS RELOCATION
EVXCT1:	XCT	EVTAB(PS)	;[123] PERFORM PROPER OPERATION
	JRST	EVNUM		;GO TRY AGAIN

EVTAB:	JRST	ASSEM1		;0; SHOULD NEVER GET HERE ;DMN
	IMULM	PV,CV		;1;
	IDIVM	PV,CV		;2;
	JRST	XADD		;3;
	JRST	XSUB		;4;
	JRST	XLRW		;5; "_"
	IOR	CV,PV		;6; MERGE PV INTO CV
	AND	CV,PV		;7; AND PV INTO CV
	XOR	CV,PV		;10; XOR PV INTO CV
	SETCM	CV,CV		;11; NOT (ONE'S COMPLIMENT)
	MOVN	CV,CV		;12; NEGATE (TWO'S COMPLEMENT)
	JFCL			;13;[265] ADDITIVE PSECT OPERATION
REPEAT 4,<HALT>			;14-17; JUST INCASE

NEGEXT:	MOVE	PS,(PP)		;[255] GET DELIMITER OFF STACK
	CAME	PS,[TNODE,,0]	;[255] NOTHING ON YET?
	JRST	EVGETD		;[255] NO?
	MOVSI	PS,4000		;[255] FAKE UP EVPUSH OF
	ADDM	PS,(PP)		;[255]  PS
	PUSH	PP,[0]		;[255]  CV
	PUSH	PP,[0]		;[255]  RC
	PUSH	PP,CSTAT+'-'	;[255]  CS
	TLZ	FR,NEGSW	;[255] CLEAR FLAG
	JRST	EVGETD		;[255] NOW EVALUATE

PRTAB:	JFCL			;0
	JUMPN	PR,POLPSH	;1
	JUMPN	PR,POLPSH	;2
	SKIPE	PR		;3
	SKIPE	PR		;4
REPEAT 4,<JUMPN	PR,POLPSH>	;5, 6, 7, 10
	JFCL			;11

RCTAB:	JFCL			;0
	JUMPN	RC,POLPSH	;1
	JUMPN	RC,POLPSH	;2
	JUMPN	RC,POLPSH	;3
	JUMPE	RC,POLPSH	;4
REPEAT 4,<JUMPN	RC,POLPSH>	;5, 6, 7, 10
	JFCL			;11
>

XSUB:	SUBM	PV,CV
	SUBM	PR,RC
	JRST	EVNUM

XADD:	ADDM	PV,CV
	ADDM	PR,RC
	JRST	EVNUM

IFE POLISH,<
XDIV:	IDIV	PR,CV		;CORRECT RELOCATABILITY
	IDIVM	PV,CV
XDIV1:	EXCH	PR,RC		;TAKE RELOCATION OF NUMERATOR
	JRST	EVXCT1

XMUL:	JUMPE	PR,XMUL1	;AT LEAST ONE OPERAND
	JUMPE	RC,XMUL1	;MUST BE FIXED
	TRO	ER,ERRR
XMUL1:	IORM	PR,RC		;GET RELOCATION TO RC
	CAMGE	PV,CV		;FIND THE GREATER
	EXCH	PV,CV		;FIX IN CASE CV=0,OR 1
	IMULM	PV,RC
	IMULM	PV,CV
	JRST	EVNUM
XLRW:	EXCH	PV,CV
	LSH	CV,0(PV)
	LSH	PR,0(PV)
	JRST	XDIV1
>
IFN POLISH,<
XLRW:	EXCH	PV,CV
	LSH	CV,0(PV)
	JRST	EVNUM
>

IFN POLISH,<			;[164]
;HERE FOR EXTERNAL ARITHMETIC
;CONVERS TO POLISH BLOCK TYPE 11

POLPSH:	JUMP1	EVXCT1		;ONLY SAVE POLISH ON PASS2
	PUSH	PP,POLSTK	;SAVE STACK POINTER
	EXCH	PP,POLSTK	;SAVE PP AND SET UP POLISH STACK
	TLO	FR,POLSW	;SIGNAL STORING POLISH
	PUSH	PP,POLTBL-1(PS)	;STACK OPERATOR
	PUSH	PP,PR		;STACK PREVIOUS RELOCATION
	PUSH	PP,PV		;AND VALUE
	PUSH	PP,RC		;STACK CURRENT
	PUSH	PP,CV
	EXCH	PP,POLSTK	;GET PP BACK
	POP	PP,CV		;USE STACK POINTER FOR VALUE
	MOVE	RC,CV		;AND RELOCATION (ENSURES EXTERNAL)
	JRST	EVNUM		;TRY NEXT ITEM

;HERE TO STORE THE POLISH LIST
;RC  (AND CV) HAVE POINTER TO TOP ITEM IN PUSHDOWN STACK
POLPOP:	MOVE	PV,FREE		;GET NEXT FREE LOCATION
	EXCH	PV,POLIST	;SWAP STACK POINTER
	PUSHJ	PP,POLSTR	;STORE POINTER TO NEXT POLISH BLOCK
	PUSHJ	PP,POLOPF	;STORE FIRST OPERATOR
	PUSHJ	PP,POLFST	;STORE FIRST PART
	PUSHJ	PP,POLSND	;STORE SECOND PART
	SKIPE	PV,POLTYP	;USE PRESET TYPE
	JRST	POLOCT		;IF SET
	SETO	PV,		;STORE OPERATOR OF -1
	JUMPNC	POLOCT		;FOR RIGHT HALF FIXUP
	SUBI	PV,1		;-2 FOR LEFT HALF
POLOCT:	XCT	3+[SETZM EXTPNT		;FULL WORD
		HRRZS	EXTPNT		;LEFT HALF
		HLLZS	EXTPNT](PV)	;RIGHT HALF
	SKIPE	INASGN		;DEFINING A SYMBOL?
	JRST	[SUBI	PV,3		;DIFFERENT STORE OPERATOR
		PUSHJ	PP,POLSTR	;STORE IT
		MOVE	CV,HDAS		;GET FLAGS
		MOVEI	ARG,10		;ASSUME LOCAL
		TLNE	CV,INTF		;IS IT GLOBAL?
		MOVEI	ARG,4		;YES, MAKE GLOBAL
		MOVE	CV,INASGN	;GET SIXBIT SYMBOL
		PUSHJ	PP,SQOZE	;RADIX50
		MOVE	PV,AC0		;CORRECT ACC
		JRST	POLPOR]		;STORE IT
	PUSHJ	PP,POLSTR	;[265] STORE IT
	MOVE	PV,LOCA		;LOCATION
	HRL	PV,MODA		;AND MODE
	SKIPN	LITLVL		;[265] HOWEVER IF IN A LITERAL?
	JRST	POLPOR		;[265] NOT
	MOVE	PV,POLIST	;[265] WE CAN NOT SUPPLY THE STORE ADDRESS YET
	MOVE	CV,(PV)		;[265] SO PUT IN A SPECIAL LIST
	MOVEM	CV,POLIST	;[265] REMOVE FROM REGULAR LIST
	EXCH	PV,POLITS	;[265] STORE IN POLIST LIT LIST
	MOVEM	PV,@POLITS	;[265] LINK TOGETHER
	MOVE	PV,STPX		;[265] STORE DEPTH IN THIS LIT
	SUB	PV,STPY		;[265] WITH NO RELOCATION YET
POLPOR:	PUSHJ	PP,POLSTR
	SETZB	RC,CV		;USE ZERO VALUE AND RELOCATION
POLRET:	MOVE	PV,POLPTR	;RESET INITIAL POLISH POINTER
	MOVEM	PV,POLSTK
	POPJ	PP,		;RETURN

;THIS IS A KLUDGE TO PRODUCE ADDITIVE GLOBALS FOR THE FEW CASES THAT THEY
;CAN HANDLE. I.E. K+GLOBAL, GLOBAL+K, GLOBAL-K
;SO THAT OLD PROGRAMS WILL COMPIL THE SAME WAY AND LOAD WITH THE
;OLD LOADER WITHOUT THE FAILSW CODE
;APART FROM ADDITIVE SYMBOL FIXUPS POLISH BLOCKS ARE MORE POWERFULL
;***** REMOVE SOMEDAY
POLOPF:	HRRZ	PS,1(RC)	;GET FIRST OPERATOR
	CAIE	PS,3		;CAN ONLY HANDLE ADD
	CAIN	PS,4		;AND SUBTRACT
	JRST	POLOP2		;ITS ONE OF THOSE  GIVE IT A TRY
;*****
POLOPX:	SKIPN	SGNMAX		;[265] PSECTS USED?
	JRST	POLOPR		;[265] NO
	PUSH	PP,PV		;[265] SAVE FIRST OP
	HRRO	PV,SGNCUR	;[265] GET CUR PSECT INX
	TRO	PV,400000	;[265] MAKE POLISH OP
	PUSHJ	PP,POLSTR	;[265] STORE IT
	POP	PP,PV		;[265] GET FIRST OP
POLOPR:	HRRZ	PV,1(RC)	;[265] GET OPERATOR
	CAIE	PV,15		;[265] ADDITIVE PSECT OPERATION?
	JRST	POLOPS		;[265] NO
	AOS	0(PP)		;[265] SKIP FIRST OPERAND
	HRRO	PV,3(RC)	;[265] GET PSECT INX
	TROA	PV,400000	;[265] MAKE POLISH OP
POLOPS:	HRRO	PV,1(RC)	;[265] GET OPERATOR AND FLAG IT
	JRST	POLSTR		;STORE IT AND EXIT

;***** MORE OF THIS KLUDGE
POLOP2:	SUBI	PS,3		;MAKES LIFE EASIER
	MOVE	CV,4(RC)	;GET 2ND OPERAND
	JUMPL	CV,POLOPX	;ITS A POINTER, THEREFORE TOO COMPLEX
	MOVE	PV,2(RC)	;AND 1ST OPERAND
	JUMPL	PV,POLOPX	;THIS IS A POINTER
	TDNN	CV,[-2,,-2]	;TEST FOR EXTERN
	JRST	[TRNE	CV,1		;TEST FOR BOTH RELOCATABLE
		TRNN	PV,1
		JRST	POLOP3		;THIS IS NOT EXTERN SO OTHER CAN BE
		JRST	POLOPX]		;CANNOT HANDLE HERE, USE POLISH
	JUMPN	PS,POLOPX	;CAN NOT HANDLE -GLOBAL
	TDNE	PV,[-2,,-2]	;TEST FOR EXTERN HERE
	JRST	POLOPX		;GLOBAL+GLOBAL TOO COMPLEX
POLOP3:	SOS	FREE		;BACKUP FREE COUNTER
	MOVE	PV,@FREE	;GET LAST POINTER
	MOVEM	PV,POLIST	;SET POINTER BACK
	POP	PP,PV		;POP RETURN OFF STACK
	TLZ	FR,POLSW	;CLEAR FLAG JUST IN CASE
;RELOAD RC, CV, PV, AND PR FROM STACK
;AND EXECUTE OPERATOR
	MOVE	PR,2(RC)	;
	MOVE	PV,3(RC)
	MOVE	CV,5(RC)
	MOVE	RC,4(RC)	;THIS ONE LAST OF COURSE
	JUMPN	PS,POLOP5	;DO MINUS
	ADDM	PV,CV
	ADDM	PR,RC
	JRST	POLRET		;RESTORE STACK AND RETURN

POLOP5:	SUBM	PV,CV
	SUBM	PR,RC
	JRST	POLRET
;***** END OF THIS KLUDGE

;HERE TO HANDLE FIRST OPERAND
;HIGHLY RECURSIVE

POLFST:	MOVE	PV,2(RC)	;GET RELOCATION
	JUMPL	PV,POLFSR	;THIS IS ANOTHER POINTER
	TDNE	PV,[-2,,-2]	;IS IT EXTERNAL?
	JRST	POLFS2		;YES
	MOVE	CV,3(RC)	;GET VALUE
POLFS4:	TLNN	PV,-1		;CHECK FOR LEFT HALF VALUE
	TLNE	CV,-1
	JRST	POLFS1		;YES, NEED FULL WORD
	HRL	CV,PV		;XWD RELOC ,, VALUE
	SETZ	PV,		;OPERAND IS 0 FOR 18 BIT VALUE
	PUSHJ	PP,POLSTR
	MOVE	PV,CV
	JRST	POLSTR		;STORE AND EXIT

POLFS1:	MOVEI	PV,1		;OPERAND IS 1 FOR 36 BIT VALUE
	PUSHJ	PP,POLSTR
	MOVE	PV,2(RC)	;RELOCATION
	PUSHJ	PP,POLSTR
	MOVE	PV,CV		;VALUE
	JRST	POLSTR

POLSN2:
POLFS2:	MOVE	CV,1(PV)	;GET SIXBIT SYMBOL INTO AC0
	MOVEI	PV,2		;OPERAND IN 2 FOR SYMBOL
	PUSHJ	PP,POLSTR
	MOVEI	ARG,4		;MAKE GLOBAL REQUEST
	PUSHJ	PP,SQOZE	;TO RADIX-50
	MOVE	PV,CV		;PUT IN RIGHT ACC
	JRST	POLSTR		;STORE IT

POLFSR:	CAME	PV,3(RC)	;CHECK TO MAKE SURE IT REALLY IS A POINTER
	JRST	POLFSN		;NO, ITS A NEGATIVE GLOBAL
	PUSH	PP,RC		;SAVE THIS POINTER
	MOVE	RC,PV		;GET NEXT POINTER
	PUSHJ	PP,POLOPR	;GET OPERATOR
	PUSHJ	PP,POLFST	;GET FIRST OPERAND
	PUSHJ	PP,POLSND	;GET SECOND OPERAND
	POP	PP,RC		;GET BACK PREVIOUS POINTER
	POPJ	PP,		;RETURN TO PREVIOUS LEVEL


POLFSN:	HRROI	PV,14		;TWO'S COMPLIMENT NEGATIVE
	PUSHJ	PP,POLSTR	;STORE OPERATOR
	MOVN	PV,2(RC)	;GET RELOCATION
	TDNE	PV,[-2,,-2]	;CHECK FOR EXTERN
	JRST	POLFS2		;IT IS, CONVERT TO RADIX-50
	MOVN	CV,3(RC)	;GET VALUE
	JRST	POLFS4		;AND STORE IT
;HERE TO HANDLE 2ND OPERAND, ALSO RECURSIVE

POLSNR:	CAME	PV,5(RC)	;MAKE SURE IT REALLY IS
	JRST	POLSNN		;ITS A NEGATIVE GLOBAL
	MOVE	RC,PV		;GET NEXT POINTER
	PUSHJ	PP,POLOPR	;STORE OPERATOR
	PUSHJ	PP,POLFST	;GET 1ST OPERAND
				;AND GET SECOND OPERAND

POLSND:	MOVE	PV,4(RC)	;GET RELOCATION
	JUMPL	PV,POLSNR	;THIS IS A POINTER
	TDNE	PV,[-2,,-2]	;IS IT EXTERNAL?
	JRST	POLSN2		;YES
	MOVE	CV,5(RC)	;GET VALUE
POLSN4:	TLNN	PV,-1		;CHECK FOR LEFT HALF VALUE
	TLNE	CV,-1
	JRST	POLSN1		;YES, NEED FULL WORD
	HRL	CV,PV		;XWD RELOC ,, VALUE
	SETZ	PV,		;OPERAND IS 0 FOR 18 BIT VALUE
	PUSHJ	PP,POLSTR
	MOVE	PV,CV
	JRST	POLSTR		;STORE AND EXIT

POLSNN:	HRROI	PV,14		;TWO'S COMPLIMENT NEGATIVE
	PUSHJ	PP,POLSTR	;STORE OPERATOR
	MOVN	PV,4(RC)	;GET RELOCATION
	TDNE	PV,[-2,,-2]	;CHECK FOR EXTERN
	JRST	POLSN2		;IT IS, CONVERT TO RADIX-50
	MOVN	CV,5(RC)	;GET VALUE
	JRST	POLSN4		;AND STORE IT

POLSN1:	MOVEI	PV,1		;OPERAND IS 1 FOR 36 BIT VALUE
	PUSHJ	PP,POLSTR
	MOVE	PV,4(RC)	;RELOCATION
	PUSHJ	PP,POLSTR
	MOVE	PV,CV		;VALUE
;	JRST	POLSTR

POLSTR:	AOS	SDEL,FREE	;GET A FREE WORD
	CAML	SDEL,SYMBOL	;ENOUGH?
	PUSHJ	PP,XCEED	;NO
	MOVEM	PV,-1(SDEL)	;STORE ONE WORD
	POPJ	PP,

;TABLE OF CORRESPONDENCE BETWEEN MACRO-10 OPERATORS AND BLOCK 11 OPERATORS
POLTBL:	;POLISH VALUE	MACRO-10	OPERATOR
	5		;1		MULTIPLY
	6		;2		DIVIDE
	3		;3		ADD
	4		;4		SUBTRACT
	11		;5		LEFT SHIFT
	10		;6		LOGICAL IOR
	7		;7		LOGICAL AND
	12		;10		LOGICAL XOR
	13		;11		NOT
	14		;12		NEGATE
	15		;13		ADDITIVE PSECT OPERATION

>;END OF IFN POLISH

	SUBTTL	LITERAL STORAGE HANDLER
	
STOLER:
IFE FORMSW,<	SETZB	AC0,RC	;ERROR, NO CODE STORED
	PUSHJ	PP,STOW		;STOW ZERO>
IFN FORMSW,<	MOVEI	AC0,0
	PUSHJ	PP,STOWZ1>
	TRO	ER,ERRL		;AND FLAG THE ERROR

STOLIT:	MOVE	SDEL,STPX
	SUB	SDEL,STPY	;COMPUTE NUMBER OF WORDS
	JUMPE	SDEL,STOLER	;ERROR IF NONE STORED
	TRNN	ER,ERRORS	;ANY ERRORS?
	JRST	STOL06		;NO
	JUMP2	STOL22		;YES, NO SEARCH.  BRANCH IF PASS2
	ADDM	SDEL,LITCNT	;PASS ONE, UPDATE COUNT
	JRST	STOWI		;INITIALIZE STOW

STOL06:	MOVEI	SX,LITAB	;PREPARE FOR SEARCH
	MOVE	ARG,STPX	;SAVE IN THE EVENT OF MULTIPLE-WORD
	HRL	ARG,STPY
	MOVE	AC2,LITNUM
	MOVEI	SDEL,0
STOL08:	PUSHJ	PP,DSTOW	;GET VALUE WFW

STOL10:	SOJL	AC2,STOL24	;TEST FOR END
	MOVE	SX,0(SX)	;NO, GET NEXT STORAGE CELL
	MOVE	V,-1(SX)		;GET RELOCATION BITS WFW
	CAMN	AC0,-2(SX)	;DO CODES COMPARE? WFW
	CAME	RC,V		;YES, HOW ABOUT RELOCATION?
	AOJA	SDEL,STOL10	;NO, TRY AGAIN
	SKIPGE	STPX		;YES, MULTI-WORD?
	JRST	STOL13		;NO, JUST RETURN LOCATION
	MOVEM	AC2,SAVBLK+AC2	;YES, SAVE STARTING INFO
	MOVEM	SX,SAVBLK+SX

STOL12:	SOJL	AC2,STOL23	;TEST FOR END
	PUSHJ	PP,DSTOW	;GET NEXT WORD WFW
	MOVE	SX,0(SX)	;UPDATE POINTER
	MOVE	V,-1(SX)		;GET RELOCATION WFW
	CAMN	AC0,-2(SX)	;COMPARE VALUE WFW
	CAME	RC,V		;AND RELOCATION
	JRST	STOL14		;NO MATCH, TRY AGAIN
	SKIPL	STPX		;MATCH, HAVE WE FINISHED SEARCH?
	JRST	STOL12		;NO, TRY NEXT WORD
STOL13:				;YES, RETURN LOCATION
IFN POLISH,<
	SETZM	POLITS		;CLEAR ANY POLISH PENDING
>
	JRST	STOL26

STOL14:	MOVE	AC2,SAVBLK+AC2	;RESTORE STOW POINTERS
	MOVE	SX,SAVBLK+SX
	HRREM	ARG,STPX
	HLREM	ARG,STPY
	AOJA	SDEL,STOL08	;BETTER LUCK NEXT TIME


STOL22:	MOVE	SDEL,LITNUM
STOL23:	PUSHJ	PP,DSTOW	;DSTOW AND CONVERT
STOL24:	MOVE	SX,LITABX	;GET CURRENT STORAGE
	PUSHJ	PP,GETTOP	;GET NEXT CELL
	MOVEM	AC0,-2(SX)	;STORE CODE WFW
	MOVEM	RC,-1(SX)	;WFW
IFN FORMSW,<
	MOVE	AC0,FORM
	MOVEM	AC0,-3(SX)>
	MOVEM	SX,LITABX	;SET POINTER TO CURRENT CELL
	AOS	LITNUM		;INCREMENT NUMBER STORED
	AOS	LITCNT		;INCREMENT NUMBER RESERVED
	SKIPL	STPX		;ANY MORE CODE?
	JRST	STOL23		;YES
STOL26:	JUMP1	POPOUT		;EXIT IF PASS ONE
	MOVE	SX,LITHDX	;GET HEADER BLOCK
	HLRZ	RC,-1(SX)	;GET BLOCK RELOCATION
	HRRZ	AC0,-1(SX)
	ADDI	AC0,0(SDEL)	;COMPUTE ACTUAL LOCATION
	POPJ	PP,		;EXIT


SUBTTL	INPUT ROUTINES

GETCHR:	PUSHJ	PP,CHARAC	;GET ASCII CHARACTER
	CAIL	C,"A"+40	;CHECK FOR LOWER CASE
	CAILE	C,"Z"+40
	JRST	.+2		;NOT LOWER CASE
IFN STANSW,<
	SUBI C,40
	CAIN C,32
	MOVEI C,136		;^
	CAIN C,30
	MOVEI C,137		;_
	CAIN C,176
	MOVEI C,134		;~
	CAIN C,140
	MOVEI C,100		;@>
IFE STANSW,<
	TRZA	C,100		;CONVERT LOWER CASE TO SIXBIT>
	SUBI	C,40		;CONVERT TO SIXBIT
	CAIG	C,77		;CHAR GREATER THAN SIXBIT?
	JUMPGE	C,GETCS		;TEST FOR VALID SIXBIT
	ADDI	C,40		;BACK TO ASCII
	CAIN	C,HT		;CHECK FOR TAB
	JRST	GETCS2		;MAKE IT LOOK LIKE SPACE
	CAIG	C,CR		;GREATER THAN CR
	CAIG	C,HT		;GREATER THAN TAB
	JRST	GETCS1		;IS NOT FF,VT,LF OR CR
	MOVEI	C,EOL		;LINE OR FORM FEED OR V TAB
	TLOA	IO,IORPTC	;REPEAT CHARACTER
GETCS2:	MOVEI	C,0		;BUT TREAT AS BLANK
GETCS:	MOVE	CS,CSTAT(C)	;GET STATUS BITS
	POPJ	PP,		;EXIT

GETCS1:	JUMPE	C,GETCS		;IGNORE NULS
	TRC	C,100		;MAKE CHAR. VISIBLE
	MOVEI	CS,"^"
	DPB	CS,LBUFP	;PUT ^ IN OUTPUT
	PUSHJ	PP,RSW2		;ALSO MODIFIED CHAR.
	TRO	ER,ERRQ		;FLAG Q ERROR
	JRST	GETCHR		;BUT IGNORE CHAR.
CHARAC:	TLZE	IO,IORPTC	;REPEAT REQUESTED?
	JRST	CHARAX		;YES
RSW0:	JUMPN	MRP,MREAD	;BRANCH IF TREE POINTER SET
	PUSHJ	PP,READ
RSW1:	SKIPE	RPOLVL		;ARE WE IN "REPEAT ONCE"?
	JRST	REPO1		;YES
RSW2:	CAIN	C,LF		;LF?
	JRST	RSW4		;YES, SEE IF LAST CHAR WAS A CR
	MOVEM	C,LIMBO		;STORE THIS CHAR. FOR RPTC
RSW3:	TLNE	IO,IOSALL	;MACRO SUPPRESS ALL?
	JUMPN	MRP,CPOPJ	;YES,DON'T LIST IN MACRO
	SOSG	CPL		;ANY ROOM IN THE IMAGE BUFFER?
	PUSHJ	PP,RSW5		;[254] NO, BUT SEE IF ANY EXCESS WE CAN USE
	IDPB	C,LBUFP		;YES, STORE IN PRINT AREA
	CAIE	C,HT		;TAB?
	POPJ	PP,		;NO, EXIT
	MOVEI	CS,7		;TAB COUNT MASK
	ANDCAM	CS,CPL		;MASK TO TAB STOP
	POPJ	PP,

RSW4:	MOVE	CS,LIMBO	;GET LAST CHAR.
	MOVEM	C,LIMBO		;STORE THIS CHAR. FOR RPTC
	CAIE	CS,CR		;LAST CHAR. A CR?
	JRST	RSW3		;NO
	HRROS	LIMBO		;YES,FLAG
	POPJ	PP,		;AND EXIT

RSW5:	PUSH	PP,C		;[254] NEED AN ACC
	MOVNI	C,.CPLX		;[254] GET EXCESS SPACE
	CAMGE	C,CPL		;[254] ANY ROOM?
	JRST	[POP	PP,C		;[254] YES
		POPJ	PP,]		;[254] JUST RETURN
	POP	PP,C		;[254] NO
	JRST	OUTPL		;[254] OUTPUT THE PARTIAL LINE
CHARAX:	HRRZ	C,LIMBO		;GET LAST CHARACTER
	POPJ	PP,		;EXIT

CHARL:	PUSHJ	PP,CHARAC	;GET AND TEST 7-BIT ASCII
	CAIG	C,FF		;LINE OR FORM FEED OR VT?
	CAIGE	C,LF
	POPJ	PP,		;NO,EXIT
	SKIPE	LITLVL		;IN LITERAL?
	JRST	OUTIML		;YES
CHARL1:	PUSHJ	PP,SAVEXS	;SAVE REGISTERS
	PUSHJ	PP,OUTLIN	;DUMP THE LINE
	JRST	RSTRXS		;RESTORE REGISTERS AND EXIT

;STATEMENT OUT PASSES REMAINDER OF LINE (CMNT)
;UNTIL A LINE TERMINATOR IS SEEN.
STOUTS:	TLOA	IO,IOENDL!IORPTC
STOUT:	TLO	IO,IORPTC
	BYPASS
	CAIE	C,EOL		;MOST LIKELY A ; OR EOL CH
	JRST	STOUT2		;IT WASN'T, SEE WHY!
	HRRZ	C,LIMBO		;GET CHARACTER INCASE EOL
	TLZN	IO,IORPTC	;IT WAS , SKIP NEXT GET
STOUT1:	PUSHJ	PP,RSW0
	CAIN	C,CR		;NEED SPECIAL TEST FOR CR
	JRST	STOUT3		;INCASE NOT FOLLOWED BY LF
	CAIG	C,FF
	CAIGE	C,LF
	JRST	STOUT1
	JRST	OUTLIN		;OUTPUT THE LINE (BIN AND LST)

STOUT2:	CAIN	C,14		;COMMA?
	SKIPL	STPX		;YES, ERROR IF CODE STORED
	TRO	ER,ERRQ
	JRST	STOUT1		;PASS OUT TIL END OF LINE

STOUT3:	PUSHJ	PP,RSW0		;GET NEXT CHAR.
	CAIG	C,FF		;GENUINE EOL CHARACTER?
	CAIGE	C,LF
	TLOA	IO,IORPTC	;NO, SO REPEAT IT
	JRST	OUTLIN		;AND DUMP LINE IN ANY CASE
REPEAT 0,<			;[252] DON'T FLAG IT
	TRO	ER,ERRQ		;[144] FLAG EXTRA <CR> WITH "Q" ERROR
>
	SETZ	C,
	DPB	C,LBUFP		;CLEAR LOOK-AHEAD CHAR OUT OF BUFFER
	PUSHJ	PP,OUTLIN	;DUMP UPTO CR AS LINE
	HRRZ	C,LIMBO		;GET C BACK
	JRST	RSW3		;AND PUT CHAR IN NEW  BUFFER
SUBTTL	CHARACTER STATUS TABLE

	DEFINE	GENCS	(OPLVL,ATOM,AN,SQUOZ,OPTYPE,SEQNO)
<BYTE (6)OPLVL (9)ATOM (3)AN (6)SQUOZ,OPTYPE,SEQNO>

	;OPLVL	PRIORITY OF BINARY OPERATORS
	;ATOM	INDEX TO JUMP TABLE AT CELL1
	;AN	TYPE OF CHARACTER
	;	1=OTHER, 2=ALPHA, 4=NUMERIC
	;SQUOZ	VALUE IN RADIX 50
	;OPTYPE	INDEX TO JUMP TABLE AT EVXCT
	;SEQNO	VALUE IN SIXBIT
CSTAT:
	GENCS	00,00,1,00,00,00	; ' '
	GENCS	04,12,1,00,06,01	; '!'
	GENCS	00,07,1,00,00,02	; '"'
	GENCS	00,12,1,00,00,03	; '#'
	GENCS	00,01,2,46,00,04	; '$'
	GENCS	00,01,2,47,00,05	; '%'
	GENCS	04,12,1,00,07,06	; '&'
	GENCS	00,07,1,00,00,07	; '''

	GENCS	00,01,1,00,00,10	; '('
	GENCS	00,01,1,00,00,11	; ')'
	GENCS	02,12,1,00,01,12	; '*'
	GENCS	01,00,1,00,03,13	; '+'
	GENCS	40,01,1,00,00,14	; ','
	GENCS	01,02,1,00,04,15	; '-'
	GENCS	00,11,2,45,00,16	; '.'
	GENCS	02,12,1,00,02,17	; '/'

	GENCS	00,04,4,01,00,20	; '0'
	GENCS	00,04,4,02,00,21	; '1'
	GENCS	00,04,4,03,00,22	; '2'
	GENCS	00,04,4,04,00,23	; '3'
	GENCS	00,04,4,05,00,24	; '4'
	GENCS	00,04,4,06,00,25	; '5'
	GENCS	00,04,4,07,00,26	; '6'
	GENCS	00,04,4,10,00,27	; '7'

	GENCS	00,04,4,11,00,30	; '8'
	GENCS	00,04,4,12,00,31	; '9'
	GENCS	00,12,1,00,00,32	; ':'
	GENCS	00,01,1,00,00,33	; ';'
	GENCS	00,05,1,00,00,34	; '<'
	GENCS	00,12,1,00,00,35	; '='
	GENCS	00,01,1,00,00,36	; '>'
	GENCS	00,12,1,00,00,37	; '?'

	GENCS	00,03,1,00,00,40	; '@'
	GENCS	00,01,2,13,00,41	; 'A'
	GENCS	00,01,2,14,00,42	; 'B'
	GENCS	00,01,2,15,00,43	; 'C'
	GENCS	00,01,2,16,00,44	; 'D'
	GENCS	00,01,2,17,00,45	; 'E'
	GENCS	00,01,2,20,00,46	; 'F'
	GENCS	00,01,2,21,00,47	; 'G'

	GENCS	00,01,2,22,00,50	; 'H'
	GENCS	00,01,2,23,00,51	; 'I'
	GENCS	00,01,2,24,00,52	; 'J'
	GENCS	00,01,2,25,00,53	; 'K'
	GENCS	00,01,2,26,00,54	; 'L'
	GENCS	00,01,2,27,00,55	; 'M'
	GENCS	00,01,2,30,00,56	; 'N'
	GENCS	00,01,2,31,00,57	; 'O'

	GENCS	00,01,2,32,00,60	; 'P'
	GENCS	00,01,2,33,00,61	; 'Q'
	GENCS	00,01,2,34,00,62	; 'R'
	GENCS	00,01,2,35,00,63	; 'S'
	GENCS	00,01,2,36,00,64	; 'T'
	GENCS	00,01,2,37,00,65	; 'U'
	GENCS	00,01,2,40,00,66	; 'V'
	GENCS	00,01,2,41,00,67	; 'W'

	GENCS	00,01,2,42,00,70	; 'X'
	GENCS	00,01,2,43,00,71	; 'Y'
	GENCS	00,01,2,44,00,72	; 'Z'
	GENCS	00,06,1,00,00,73	; '['
	GENCS	00,12,1,00,00,74	; '\'
	GENCS	00,01,1,00,00,75	; ']'
	GENCS	00,10,1,00,00,76	; '^'
	GENCS	10,12,1,00,05,77	; '_'

CSTATX:	GENCS	04,12,1,00,10,01	;[123]  '^!'
CSTATN:	GENCS	04,12,1,00,11,15	;[123]  '^-'
IFN POLISH,<
CSTATP:	GENCS	11,12,1,00,13,13	;ADDITIVE PSECT OPERATION
>
SUBTTL	LISTING ROUTINES

OUTLIN:	TRNN	ER,ERRORS-ERRQ	;ANY ERRORS?
	TLNE	FR,ERRQSW	;NO, IGNORE Q ERRORS?
	TRZ	ER,ERRQ		;YES, YES, ZERO THE Q ERROR
	HRLZ	AC0,ER		;PUT ERROR FLAGS IN AC0 LEFT
	TDZ	ER,TYPERR
	JUMP1	OUTL30		;BRANCH IF PASS ONE
	JUMPN	AC0,OUTL02	;JUMP IF ANY ERRORS TO FORCE PRINTING
	SKIPL	STPX		;SKIP IF NO CODE, OTHERWISE
	JRST	OUTL01		;NO
	TLNN	IO,IOSALL	;YES,SUPPRESS ALL?
	JRST	OUTL03		;NO
	JUMPN	MRP,CPOPJ	;YES,EXIT IF IN MACRO
	LDB	C,[XWD 350700,LBUF]
	CAIE	C,15		;FIRST CHAR CR?
OUTL01:	TLZ	IO,IOMAC	;FORCE MACRO PRINTING
OUTL03:	TLNN	IO,IOMSTR!IOPROG!IOMAC
OUTL02:	IOR	ER,OUTSW	;FORCE IT.
	IDPB	AC0,LBUFP	;STORE ZERO TERMINATOR AFTER ASCII SRC LINE
	TLNN	FR,CREFSW	;CREF?
	PUSHJ	PP,CLSCRF	;YES, WRITE END OF CREF DATA (177,003)
	JUMPE	AC0,OUTL20	;BRANCH IF NO ERRORS
	TLZE	AC0,ERRM	;M ERROR?
	TLO	AC0,ERRP	;M ERROR SET - SET P ERROR.
	PUSHJ	PP,OUTLER	;PROCESS ERRORS

OUTL20:	SKIPN	C,ASGBLK	;[263]
	SKIPE	CS,LOCBLK	;
	SKIPL	STPX		;ANY BINARY?
	JRST	OUTL23		;YES, JUMP
	JUMPE	C,OUTL22	;[263] SEQUENCE BREAK AND NO BINARY JUMPS
	ILDB	C,TABP		;ASSIGNMENT FALLS THROUGH
	PUSHJ	PP,OUTL		;OUTPUT A TAB.
	ILDB	C,TABP		;OUTPUT 2ND TAB, LOCATION FIELD
	PUSHJ	PP,OUTC		;NEXT IS BINARY LISTING FIELD
	HLLO	CS,LOCBLK	;LEFT HALF OF A 36BIT VALUE
	SKIPL	ASGBLK		;[263] SKIP IF LEFT HALF IS NOT RELOC
	TRZA	CS,1		;IT IS, SET THE FLAG
	TLNE	CS,-1		;SKIP IF ITS A 18BIT VALUE, OTHERWISE
	PUSHJ	PP,ONC1		;PRINT LH OF A 36 BIT VALUE IN CS
	HRLO	CS,LOCBLK	;PICK UP THE RIGHT HALF (18BIT VALUE)
	MOVE	C,ASGBLK	;[263] GET RIGHT HALF RELOCATION
	TRZ	CS,0(C)		;[263] 
	PUSHJ	PP,ONC		;PRINT IT
	JRST	OUTL23		;SKIP SINGLE QUOTE TEST
OUTL22:	PUSHJ	PP,ONC		;TAB TO RH AND PRINT IT
	MOVEI	C,"'"
	SKIPE	MODA
	PUSHJ	PP,OUTC
OUTL23:	SKIPL	STPX		;ANY BINARY?
	PUSHJ	PP,BOUT		;YES, DUMP IT
	MOVE	CS,@OUTLI2	;[POINT 7,LBUF]
OUTL24:	ILDB	C,CS
	CAILE	C," "		;[157]
	JRST	OUTL28		;[157] FOUND A PRINTING CHARACTER
	JUMPN	C,OUTL24	;[157] TRY AGAIN UNLESS TERMINAL 0
	SKIPN	SEQNO		;[157] SEQUENCE NO. ARE WORTH PRINTING
	JRST	OUTL25		;[157] BUT JUST TABS AREN'T
OUTL28:	MOVE	CS,TABP
	PUSHJ	PP,OUTASC	;OUTPUT TABS & SEQ. NO.
OUTL25:	MOVEI	CS,LBUF
	PUSHJ	PP,OUTAS0	;DUMP THE LINE
	TLNE	IO,IOSALL	;SUPPRESSING ALL
	JUMPN	MRP,OUTL27	;YES,EXTRA CR IF IN MACRO
OUTL26:	SKIPGE	STPX		;ANY BINARY?
	JRST	OUTLI		;NO, CLEAN UP AND EXIT
	PUSHJ	PP,OUTLI2	;YES, INITIALIZE FOR NEXT LINE
	TLNN	FR,CREFSW	;[130] CREF REQUESTED?
	TLNE	IO,IOPROG	;[130] YES, THEN IS XLIST ON?
	JRST	.+2		;[130] CREF NOT BEING PRINTED
	PUSHJ	PP,CLSCRF	;[130] CLOSE OUT THIS CREF LINE
	PUSHJ	PP,BOUT		;YES, DUMP IT
OUTL27:	PUSHJ	PP,OUTCR	;OUTPUT CARRIAGE RETURN
	JRST	OUTL26		;TEST FOR MORE BINARY

OUTPL:	SKIPN	LITLVL		;IF IN LITERAL
	SKIPL	STPX		;OR CODE GENERATED
	JRST	OUTIM		;JUST OUTPUT THE IMAGE
	SKIPE	ASGBLK		;[205]
	JRST	OUTPL1		;[205] JUMP IF AN ASSIGNMENT
	SKIPE	LOCBLK		;[205] OR A BLOCK RESERVATION
	SKIPE	MACENL		;[205] STILL IN "CALLM"?
	JRST	OUTIM		;[205] OTHERWISE OUTPUT IMAGE
	JUMPN	MRP,OUTIM	;[205] ALSO IF IN A MACRO
OUTPL1:	PUSHJ	PP,SAVEXS	;[242] SAVE AC0 AND C
	MOVEI	C,CR
	IDPB	C,LBUFP
	MOVEI	C,LF
	IDPB	C,LBUFP		;FINISH WITH CRLF
	PUSHJ	PP,OUTLIN	;OUTPUT PARTIAL LINE
	PUSHJ	PP,RSTRXS	;[242] RESTORE ACS
	JRST	OUTLI2		;INITIALISE REST OF LINE
OUTL30:	AOS	CS,STPX		;PASS ONE
	CAIN	C,FF		;FORM FEED?
	PUSHJ	PP,OUTFF2	;YES, COUNT PAGES FOR PASS1 ERROR
	ADDM	CS,LOCO		;INCREMENT OUTPUT LOCATION
	PUSHJ	PP,STOWI	;INITIALIZE STOW
	TLZ	AC0,ERRORS-ERROR1	;[125]
	JUMPN	AC0,OUTL32	;JUMP IF ERRORS
	TLNE	IO,IOSALL	;SUPPRESSING ALL
	JUMPN	MRP,CPOPJ	;YES,EXIT
	JRST	OUTLI1		;NO,INIT LINE

OUTL32:	IDPB	AC0,LBUFP	;ZERO TERNIMATOR
	IOR	ER,OUTSW	;LIST ERRORS
	MOVE	CS,TAG
	PUSHJ	PP,OUTSY1
	MOVEI	CS,[SIXBIT / +@/]
	PUSHJ	PP,OUTSIX	;OUTPUT TAG
	HRRZ	C,TAGINC
	PUSHJ	PP,DNC		;CONVERT INCREMENT TO DECIMAL
	PUSHJ	PP,OUTTAB	;OUTPUT TAB
	PUSHJ	PP,OUTLER	;OUTPUT ERROR FLAGS
	PUSHJ	PP,OUTTAB
	MOVEI	CS,SEQNO	;ADDRESS OF SEQUENCE NO.
	SKIPE	SEQNO		;FILE NOT SEQUENCED
	PUSHJ	PP,OUTAS0	;OUTPUT IT
	JRST	OUTL25		;OUTPUT BASIC LINE

OUTLER:	PUSH	PP,ER		;SAVE LISTING SWITCHES FOR LATER
	TRNE	ER,TTYSW	;IF THIS IS ON, LISTING IS ON TTY
	TRZ	ER,ERRORS	;SO SUPPRESS ON TTY
	TDZ	ER,OUTSW	;BUT THIS SHOULD ONLY GO TO THE TTY
	MOVE	CS,INDIR	;GET FILE NAME
	CAME	CS,LSTFIL	;AND SEE IF SAME
	JRST	[MOVEM	CS,LSTFIL	;SAVE AS LAST ONE
		MOVEI	CS,LSTFIL
		PUSHJ	PP,OUTSIX	;LIST NAME
		MOVEI	C," "
		PUSHJ	PP,OUTL
		MOVE	CS,PAGENO	;PRINT PAGE NUMBER TOO
		JRST	OUTLE8]
	MOVE	CS,PAGENO	;NOW CHECK PAGE NUMBER
	CAME	CS,LSTPGN
OUTLE8:	JRST	[MOVEM	CS,LSTPGN
		MOVEI	CS,[ASCIZ /PAGE /]
		PUSHJ	PP,OUTAS0
		MOVE	C,PAGENO
		PUSHJ	PP,DNC
		PUSHJ	PP,OUTCR	;AND NOW FOR THE ERROR LINE
		JRST	.+1]
	HLLM	ER,(PP)		;RESTORE ER BUT NOT IO (LEFT HALF OF AC)
	POP	PP,ER
	MOVE	CS,[POINT 7,[ASCII / QXADLRUVNOPEMS/]]
OUTLE2:	ILDB	C,CS		;GET ERROR MNEMONIC
	JUMPGE	AC0,OUTLE4	;BRANCH IF NOT FLAGGED
	CAIN	C,"Q"		;"Q" ERROR?
	AOSA	QERRS		;YES, JUST COUNT AS WARNING
	AOS	ERRCNT		;INCREMENT ERROR COUNT
	PUSHJ	PP,OUTL		;OUTPUT THE CHARACTER
OUTLE4:	LSH	AC0,1		;SHIFT NEXT FLAG INTO SIGN BIT
	JUMPN	AC0,OUTLE2	;TEST FOR END
	POPJ	PP,		;EXIT

OUTIM1:	TLOA	FR,IOSCR	;SUPPRESS CRLF AFTER LINE
OUTIM:	TLZ	FR,IOSCR	;DON'T FOR PARTIAL LINE
	TLNE	IO,IOSALL	;SUPPRESSING ALL?
	JUMPN	MRP,CPOPJ	;YES ,EXIT IF IN MACRO
	JUMP1	OUTLI1		;BYPASS IF PASS ONE
	PUSH	PP,ER
	TDZ	ER,TYPERR
	TLNN	IO,IOMSTR!IOPROG!IOMAC
	IOR	ER,OUTSW
	PUSH	PP,C		;OUTPUT IMAGE
	TLNN	FR,CREFSW
	PUSHJ	PP,CLSCRF
OUTIM2:	MOVE	CS,TABP
	PUSHJ	PP,OUTASC	;OUTPUT TABS
	IDPB	C,LBUFP		;STORE ZERO TERMINATOR
	MOVEI	CS,LBUF
	PUSHJ	PP,OUTAS0	;OUTPUT THE IMAGE
	TLZN	FR,IOSCR	;CRLF SUPPRESS?
	PUSHJ	PP,OUTCR	;NO,OUTPUT
	POP	PP,C
	HLLM	ER,0(PP)
	POP	PP,ER
	JRST	OUTLI2

OUTLI:	TLNE	IO,IOSALL	;SUPPRESSING ALL
	JUMPN	MRP,OUTLI3	;YES,SET FLAG IN REPEATS ALSO
	TLNE	IO,IOPALL	;MACRO EXPANSION SUPRESS REQUESTED?
	SKIPN	MACLVL		;YES, ARE WE IN MACRO?
	TLZA	IO,IOMAC	;NO, CLEAR MAC FLAG
OUTLI3:	TLO	IO,IOMAC	;YES, SET FLAG

OUTLI1:	TRZ	ER,ERRORS!LPTSW!TTYSW
OUTLI2:	MOVE	CS,[POINT 7,LBUF]	;INITIALIZE BUFFERS
	MOVEM	CS,LBUFP
IFN FORMSW,<MOVE CS,[POINT 7,TABI]
	MOVSS	HWFMT		;PUT FLAG IN LEFT HALF
	SKIPGE	HWFMT		;BUT IF ONLY HALF-WORD FORMAT>
	MOVE	CS,[POINT 7,TABI,6]
	MOVEM	CS,TABP
	MOVEI	CS,.CPL
IFN FORMSW,<SKIPL HWFMT		;IF MULTI-FORMAT
	SUBI	CS,8		;LINE IS ONE TAB SHORTER
	MOVSS	HWFMT		;BACK AS IT WAS>
	SKIPE	SEQNO		;[153] A SEQUENCED FILE?
	SUBI	CS,8		;[153] YES, SEQ NO TAKES UP SPACE
	MOVEM	CS,CPL
	MOVSI	CS,(ASCII /	/)
	SKIPE	SEQNO		;HAVE WE SEQUENCE NUMBERS?
	MOVEM	CS,SEQNO	;YES, STORE TAB IN CASE OF MACRO
	MOVEM	CS,SEQNO+1	;STORE TAB AND TERMINATOR
	SETZM	ASGBLK
	SETZM	LOCBLK
	POPJ	PP,

OUTIML:	TLNE	IO,IOSALL	;SUPPRESSING ALL?
	JUMPN	MRP,CPOPJ	;YES,EXIT IF IN MACRO
	TRNN	ER,ERRORS-ERRQ		;FOR LITERALS (MULIT-LINE) OUTPUT ERRORS
	TLNE	FR,ERRQSW
	TRZ	ER,ERRQ
	HRLZ	CS,ER
	JUMP1	OUTML1		;CHECK PASS1 ERRORS
	TDZ	ER,TYPERR
	JUMPE	CS,OUTIM1
	PUSH	PP,[0]		;ERRORS SHOULD BE ZEROED
	PUSH	PP,C
	PUSH	PP,AC0		;SAVE AC0 IN CASE CALLED FROM ASCII
	MOVE	AC0,CS		;ERROR ROUTINE WANTS FLAGS IN AC0
	IOR	ER,OUTSW
	TLNN	 FR,CREFSW
	PUSHJ	PP,CLSCRF	;FIX CREF
	TLZE	AC0,ERRM
	TLO	AC0,ERRP
	PUSHJ	PP,OUTLER	;OUTPUT THEM
	POP	PP,AC0
	JRST	OUTIM2		;AND LINE
	
OUTML1:	TLZ	CS,ERRORS-ERROR1-ERRL	;[250] ANY ERRORS TO PRINT ON PASS1?
	JUMPE	CS,[TRZ	ER,ERRORS!LPTSW!TTYSW-ERRN	;[250] NONE
		JRST	OUTLI2]		;[250] BUT "N" IS FOR MULTI-LINE LITS
	TRZ	ER,ERRORS!LPTSW!TTYSW	;[250]
	TRO	ER,ERRL
	PUSH	PP,ER		;SAVE
	PUSH	PP,C		;SAVE THIS
	PUSH	PP,AC0		;AS ABOVE
	MOVE	AC0,CS		;...
	TDZ	ER,TYPERR
	IOR	ER,OUTSW
	MOVE	CS,TAG
	PUSHJ	PP,OUTSY1
	MOVEI	CS,[SIXBIT / +@/]
	PUSHJ	PP,OUTSIX
	HRRZ	C,TAGINC
	PUSHJ	PP,DNC
	PUSHJ	PP,OUTTAB
	PUSHJ	PP,OUTLER	;DO NOT FORGET ERRORS
	PUSHJ	PP,OUTTAB
	SETZ	AC0,		;[253] SET A ZERO TERMINATOR
	IDPB	AC0,LBUFP	;[253] IN THE OUTPUT BUFFER
	MOVEI	CS,LBUF		;PRINT REST OF LINE
	PUSHJ	PP,SOUT20
	POP	PP,AC0
	POP	PP,C
	POP	PP,ER
	JRST	OUTLI2

SUBTTL	OUTPUT ROUTINES
UOUT:	PUSHJ	PP,LOOKUP	;SET FOR TABLE SCAN
	TRNN	ARG,PNTF	;WFW
	TRNN	ARG,UNDF
	JRST	UOUT13		;TEST FOR UNDF!EXTF!PNTF ON PASS2
	JUMP2	UOUT10
	TLNN	IO,IOIOPF	;ANY IOP'S SEEN
	JRST	UOUT12		;NO,MAKE EXTERNAL
	MOVSI	CS,PRMTBL-PRMEND;YES LOOKUP IN TABLE
UOUT1:	CAME	AC0,PRMTBL(CS)	;HAVE WE A MATCH?
	AOBJN	CS,UOUT2	;NO,INCREMENT AND JUMP
	MOVE	ARG,PRMTBL+1(CS);YES,GET VALUE
	MOVEM	ARG,(SX)	;UPDATE SYMBOL TABLE
	POPJ	PP,		;EXIT
UOUT2:	AOBJN	CS,UOUT1	;TEST FOR END

UOUT12:	PUSHJ	PP,EXTER2	;MAKE IT EXTERNAL
	MOVSI	ARG,UNDF	;BUT PUT UNDF BACK ON
	IORM	ARG,(SX)	;SO MESSAGE WILL COME OUT
	POPJ	PP,		;GET NEXT SYMBOL

UOUT13:	JUMP1	CPOPJ		;RECYCLE ON PASS1
	TRC	ARG,UNDF!EXTF!PNTF	;CHECK FOR ALL THREE ON
	TRCE	ARG,UNDF!EXTF!PNTF	;ARE THEY?
	POPJ	PP,		;NO, RECYCLE
UOUT10:	PUSHJ	PP,OUTCR
	PUSHJ	PP,OUTSYM	;OUTPUT THE SYMBOL
	MOVEI	CS,[SIXBIT /UNASSIGNED, DEFINED AS IF EXTERNAL @/]
	JRST	OUTSIX		;POPJ FOR NEXT SYMBOL

				;OUTPUT THE ENTRIES

EOUT:	MOVEI	C,0		;INITIALIZE THE COUNT
	MOVE	SX,SYMBOL
	MOVE	SDEL,0(SX)
EOUT1:	SOJL	SDEL,EOUT2	;TEST FOR END
	ADDI	SX,2
	HLRZ	ARG,0(SX)
	ANDCAI	ARG,SYMF!INTF!ENTF
	JUMPN	ARG,EOUT1	;IF INVALID, DON'T COUNT
	AOJA	C,EOUT1		;BUMP COUNT

EOUT2:	HRLI	C,4		;BLOCK TYPE 4
	PUSHJ	PP,OUTBIN
	SETZB	C,ARG
	PUSHJ	PP,OUTBIN
	MOVE	SX,SYMBOL
	MOVE	SDEL,0(SX)
	MOVEI	V,^D18

EOUT3:	SOJL	SDEL,POPOUT
	ADDI	SX,2
	HLRZ	C,0(SX)
	ANDCAI	C,SYMF!INTF!ENTF
	JUMPN	C,EOUT3
	SOJGE	V,EOUT4		;TEST END OF BLOCK
	PUSHJ	PP,OUTBIN
	MOVEI	V,^D17	;WFW
EOUT4:	MOVE	AC0,-1(SX)
	PUSHJ	PP,SQOZE
	MOVE	C,AC0
	PUSHJ	PP,OUTBIN
	JRST	EOUT3

LSOUT:	SKIPN	C,LOCAL		;ANY LOCAL FIXUPS REQUIRED?
	POPJ	PP,		;NO
	MOVS	AC0,(C)		;GET VALUE RIGHT WAY ROUND
	MOVS	RC,1(C)		;AND RELOCATION
	HLRZM	RC,LOCAL	;STORE NEXT POINTER
	PUSHJ	PP,COUT		;OUTPUT THIS WORD
	JRST	LSOUT		;LOOK FOR MORE

				;OUTPUT THE SYMBOLS
SOUT:	SKIPN	IONSYM		;SKIP IF NOSYM SEEN
	TRNN	ER,LPTSW!TTYSW	;A LISTING REQUIRED?
	JRST	SOUT2		;NO
	MOVEI	[ASCIZ /SYMBOL TABLE/]
	HRRM	SUBTTX		;SET NEW SUB-TITLE
	MOVEI	ARG,NCOLS	;SET UP FOR NCOLS ACROSS SYMBOL TABLE
	TRNE	ER,TTYSW	;IS TTY LISTING DEVICE?
	MOVEI	ARG,2		;YES,ONLY 2 COLLUMNS
	MOVEM	ARG,NCOLLS	;STORE ANSWER
IFE POLISH,<
	MOVE	SX,SYMBOL	;START OF TABLE
	MOVE	SDEL,(SX)	;COUNT OF SYMBOLS
>
IFN POLISH,<
	MOVE	SX,SGSBOT	;START OF TABLE
	MOVE	SDEL,SGNCUR	;CUR PSECT INX
	JUMPE	SDEL,SOUTBS	;IS THIS THE BLANK PSECT?
	MOVE	ARG,[XWD SGTTLB,SGLIST]
	BLT	ARG,SGTTLE-SGTTLB+SGLIST-1	;MOVE SUBTTL
	MOVE	AC1,SGTTLE	;'TO' POINTER
	MOVE	AC2,SGTTLF	;'FROM' POINTER
SGTTLL:	ILDB	AC0,AC2		;GET A SIXBIT CHAR
	ADDI	AC0,40		;FORM ASCII
	IDPB	AC0,AC1		;PUT IN SUBTTL
	TLNE	AC2,770000	;DONE SIX CHARS?
	JRST	SGTTLL		;NOT DONE YET
	SETZ	AC0,		;TERMINATE SUBTTL
	IDPB	AC0,AC1		; WITH NULL BYTE
	MOVEI	AC0,SGLIST	;POINTER TO
	HRRM	AC0,SUBTTX	; NEW SUBTTL
SOUTBS:	HRRZ	SDEL,SGSCNT(SDEL)	;COUNT OF SYMBOLS
>
	ADDI	SX,2		;SKIP COUNT
	MOVEM	SX,SXSV		;SAVE PLACE
	MOVEM	SDEL,SDELSV
	MOVE	SX,SPAGNO	;GET LAST SYMBOL PAGE NUMBER
	EXCH	SX,PAGENO	;SWAP WITH OUTPUT PAGE NUMBER
	MOVEM	SX,SPAGNO	;AND STORE IT
	MOVE	SX,[BYTE (7) 0,0,<"S">,<"-">,0]
	IORM	SX,DBUF+4	;FIXUP TITLE

SOUT0:	PUSHJ	PP,SOUTP	;GET PAGE SET UP
	  JRST	SOUT1		;NOTHING TO OUTPUT
	PUSHJ	PP,SOUTF	;DUMP ONE PAGE
	  JRST	SOUT1		;DIDN'T FILL PAGE-DONE
	JRST	SOUT0

IFN POLISH,<
SGTTLB:	ASCII	/SYMBOL TABLE FOR PSECT   /
SGTTLE:	POINT	7,SGTTLE-SGTTLB+SGLIST
SGTTLF:	POINT	6,SGNAME(SDEL)
>
SOUTT:	MOVE	ARG,(SX)	;GET FLAGS
	TLNE	ARG,SUPRBT	;SURPRESSED?
	POPJ	PP,		;YES
	TLNN	ARG,SYMF	;SYMBOL IS OK
	TLNN	ARG,SYNF!MACF	;BUT MACRO OR SYNONYM AREN'T
	AOS	(PP)
	POPJ	PP,
SOUTP:	MOVE	AC1,NCOLLS	;GET COLUMN COUNT
	MOVE	SX,SXSV		;GET POSITION
	MOVE	SDEL,SDELSV	;AND COUNT

SOUTP0:	MOVEM	SX,SYMBLK(AC1)
	HRLM	SDEL,SYMBLK(AC1)	;SAVE IN TABLE
	MOVE	AC0,..LPP	;[227] LINE COUNT

SOUTP1:	JUMPE	SDEL,SOUTP2	;IF NONE LEFT, GO ELSEWHERE
	PUSHJ	PP,SOUTT	;SYMBOL OK?
	  TDZA	RC,RC		;NO
	SETO	RC,		;YES
	ADDI	SX,2		;SET UP FOR NEXT NOW
	SUBI	SDEL,1
	JUMPGE	RC,SOUTP1	;SKIP SYMBOL
	SOJG	AC0,SOUTP1	;COUNT IN SYMBOL
	SOJG	AC1,SOUTP0	;START NEXT COLUMN
	MOVEM	SX,SXSV		;SAVE POSITION
	MOVEM	SDEL,SDELSV
	AOS	(PP)
	POPJ	PP,
SOUTP2:	CLEARM	SDELSV		;FLAG DONE
	CAME	AC1,NCOLLS	;IF ON 1ST COLUMN
	JRST	.+3
	CAMN	AC0,..LPP	;[227] AND FIRST LINE
	POPJ	PP,		;THEN SKIP PRINTING
	SOJLE	AC1,CPOPJ1	;ALREADY GOT THIS LINE
	CLEARM	SYMBLK(AC1)
	SOJG	AC1,.-1		;ZERO ALL OTHERS
	JRST	CPOPJ1
SOUTF:	PUSHJ	PP,OUTFF	;GET TO TOP OF PAGE
	MOVE	AC1,..LPP	;[227]
	MOVEM	AC1,COLSIZ

SOUTF1:	PUSHJ	PP,SOUTL	;DUMP ONE LINE
	  JRST	CPOPJ		;WAS BLANK
	SOSLE	COLSIZ		;ONE MORE DONE
	JRST	SOUTF1		;MORE TO GO
SOUTF2:	JRST	CPOPJ1

SOUTL:	MOVE	AC1,NCOLLS	;SET COLUME COUNT
SOUTL0:	HRRZ	SX,SYMBLK(AC1)
	HLRZ	SDEL,SYMBLK(AC1);GET POSITION IN TABLE
	JUMPE	SDEL,SOUTL3	;NOTHING THERE

SOUTL1:	PUSHJ	PP,SOUTT	;SYMBLE PRINTABLE?
	  JRST	SOUTL2		;CENCOR!!
	PUSHJ	PP,SOUTE	;DUMP OUT ENTRY
	ADDI	SX,2
	SUBI	SDEL,1		;UP TP NEXT ONE
	HRL	SX,SDEL		;SAVE OUR PLACE
	MOVEM	SX,SYMBLK(AC1)
	SOJG	AC1,SOUTL0	;NEXT!
	AOS	(PP)
	JRST	OUTCR		;POLISH OFF LINE

SOUTL2:	ADDI	SX,2
	SOJG	SDEL,SOUTL1	;KEEP SEARCHING
SOUTL3:	CAME	AC1,NCOLLS	;BLANK LINE?
	AOS	(PP)		;NO
	JRST	OUTCR
SOUTE:	MOVE	AC0,-1(SX)
	PUSHJ	PP,OUTSYM	;DUMP SYMBOL OUT
	PUSHJ	PP,SRCH7	;GET VALUE
	TLNN	ARG,EXTF	;EXTERNAL?
	JRST	.+5
	HLRZ	RC,V		;YES, NEED FIXUP
	TRNE	RC,-2
	MOVS	RC,(RC)
	HLL	V,RC

	HLLO	CS,V
	TLNE	RC,-1
	TRZ	CS,1
	TLNE	RC,-2
	TRZ	CS,EXTF
	TLNN	V,-1
	TLNE	RC,-1
	PUSHJ	PP,ONC1
	PUSHJ	PP,OUTTAB
	HRLO	CS,V
	TRNE	RC,-1
	TRZ	CS,1
	TRNE	RC,-2
	TRZ	CS,EXTF
	PUSHJ	PP,ONC1
	PUSHJ	PP,OUTTAB	;AND TAB, OF COURSE
	PUSHJ	PP,SOUTE8	;ABBREVIATION FOR TYPE
	JRST	OUTTAB		;FINAL TAB

SOUTE8:	TLNN	ARG,INTF!EXTF!ENTF!UNDF!NOOUTF
	 POPJ	PP,		;SKIP JUNK FOR SIMPLE STUFF
	SETZ	CS,
	TLNE	ARG,INTF	;INTERNAL
	MOVEI	CS,1
	TLNE	ARG,EXTF	;EXTERNAL
	MOVEI	CS,-1
	TLNE	ARG,ENTF	;ENTRY
	MOVEI	CS,-5
	TLNE	ARG,NOOUTF	;DDT SURPRESSED
	ADDI	CS,3
	TLNE	ARG,UNDF	;UNDEFINED
	MOVEI	CS,-3		;SET FOR UDF
	MOVEI	CS,SOUTC(CS)	;GET ABREVIATION
	JRST	OUTAS0
SOUT1:	MOVE	SX,PAGENO	;GET LAST SYMBOL PAGE NUMBER
	EXCH	SX,SPAGNO	;SWAP WITH OUTPUT PAGE NUMBER
	MOVEM	SX,PAGENO	;AND STORE IT
	MOVE	SX,[BYTE (7) 0,0,<"S">,<"-">,0]
	ANDCAM	SX,DBUF+4	;FIXUP TITLE
SOUT2:	PUSHJ	PP,SGLKUP	;[265] SET FOR TABLE SCAN
	TRNN	ARG,SYMF
	TRNN	ARG,MACF!SYNF
	TDZA	MRP,MRP		;SKIP AND CLEAR MRP
	POPJ	PP,		;NO, TRY AGAIN
	TRNE	ARG,INTF
	MOVEI	MRP,1
	TRNE	ARG,EXTF
	MOVNI	MRP,1		;MRP=-1 FOR EXTERNAL
	TRNE	ARG,SYNF	;SYNONYM?
	JUMPL	MRP,POPOUT	;YES, DON'T OUTPUT IF EXTERNAL
	TRNE	ARG,SUPRBT	;IF SUPRESSED
	POPJ	PP,		;DO NOT OUTPUT
	JUMPGE	MRP,SOUT10	;BRANCH IF NOT EXTERNAL
	HLRZ	RC,V		;PUT POINTER/FLAGS IN RC
	TRNE	RC,-2		;POINTER?
	MOVS	RC,0(RC)	;YES
	HLL	V,RC		;STORE LEFT VALUE

SOUT10:	PUSH	PP,RC		;SAVE FOR LATER
	MOVEI	AC1,0
	JUMPLE	MRP,SOUT15	;SET DEFFERRED BITS IF INTERN=EXTERN
	TDNE	RC,[-2,,-2]	;CHECK FOR INTERN=EXTERN
	TRZ	ARG,NOOUTF	;YES, SO CLEAR SUPPRESS FLAG
	TLNE	RC,-2		;CHECK FOR LEFT FIXUP
	IORI	AC1,40		;AND SET BITS
	TRNE	RC,-2		;CHECK FOR RIGHT FIXUP
	IORI	AC1,20		;AND SET BITS
SOUT15:	TLNE	RC,-2		;FIX RELOC AS 0 IF EXTERNAL
	HRRZS	RC
	TRNE	RC,-2
	HLLZS	RC
	TLZE	RC,-1
	TRO	RC,2
	HRL	MRP,RC
	MOVEI	RC,0
	TRNE	ARG,ENTF	;ENTRY DMN
	HRRI	MRP,-5
	TRNE	ARG,NOOUTF	;SUPRESS OUTPUT? WFW
	ADDI	MRP,3		;YES WFW
	TRNE	ARG,UNDF	;UNDEFINED IS EXTERNAL
	HRRI	MRP,2		;SO FLAG AS UDF
	IOR	AC1,SOUTC(MRP)
	MOVE	ARG,AC1
	PUSHJ	PP,NOUT2	;SQUOZE AND DUMP THE SYMBOL
	MOVEM	AC0,SVSYM	;SAVE IT
	MOVE	AC0,V		;GET THE VALUE
	HLRZ	RC,MRP		;AND THE RELOCATION
	PUSHJ	PP,COUT
	POP	PP,RC		;GET BACK RELOC AND CHECK EXTERNAL
	TRNN	RC,-2		;IS IT?
	JRST	SOUT50		;NO
	MOVE	AC0,1(RC)	;GET NAME
	MOVEI	ARG,60		;EXTERNAL REQ
	PUSHJ	PP,SQOZE
	HLLZS	RC		;NO RELOC
	PUSHJ	PP,COUT		;OUTPUT IT
	MOVE	AC0,SVSYM	;GET SYMBOL NAME
	TLO	AC0,500000	;SET AS ADDITIVE SYMBOL
	TLZ	AC0,200000	;BUT NOT LEFT HALF ETC
	PUSHJ	PP,COUT
SOUT50:	MOVSS	RC		;CHECK LEFT HALF
	TRNN	RC,-2
	POPJ	PP,
	MOVE	AC0,1(RC)
	MOVEI	ARG,60
	PUSHJ	PP,SQOZE
	MOVEI	RC,0
	PUSHJ	PP,COUT
	MOVE	AC0,SVSYM
	TLO	AC0,700000
	JRST	COUT

SOUT20:	PUSHJ	PP,OUTAS0
	JRST	OUTCR

	<ASCII /ENT/>!04	;DMN
	0
	<ASCII /UDF/>!60	;UNDEFINED EXTERNAL
	<ASCII /SEN/>!44	;SUPRESSED ENTRY
	<ASCII /EXT/>!60
SOUTC:	EXP	10
	<ASCII /INT/>!04
	<ASCII /SEX/>!60	;SUPPRESSED EXTERNAL (NOT USED YET)
	<ASCII /SPD/>!50
	<ASCII /SIN/>!44	;DMN
				;OUTPUT THE BINARY

BOUT:	HRRZ	CS,LOCA		;[150] PICKUP THE LOCATION
	SUB	CS,STPX		;[150] MINUS START
	ADD	CS,STPY		;[150] PLUS END
	HRLO	CS,CS		;[150] TO GET ASSEMBLY LOCATION
	PUSHJ	PP,ONC		;OUTPUT IT TO THE LISTING FILE
	MOVEI	C,"'"
	SKIPE	MODA		;[150] IF MODE IS NOT ABSOLUTE
	PUSHJ	PP,OUTC		;PRINT A SINGLE QUOTE
	PUSHJ	PP,DSTOW	;GET THE CODE
	PUSH	PP,RC		;SAVE RELOC
	PUSH	PP,RC		;AND AGAIN
	TLNE	RC,-2		;CHECK LEFT EXTERNAL
	HRRZS	RC		;MAKE LEFT NON-RELOC
	TRNN	RC,-2		;RIGHT EXT?
	JRST	BOUT30		;NO
	HRRZ	AC1,AC0		;YES
	JUMPE	AC1,BOUT20	;PROCESS IF ZERO CODE THERE
	HLLZS	RC		;MAKE NON-RELOC
	JRST	BOUT30		;PROCESS

BOUT20:	HRRM	AC1,-1(PP)	;FIX RC IN STACK SO NO CONFUSION WFW (AC1 HAS 0)
	HRR	AC0,0(RC)	;NO, SET ADDRESS LINK
	MOVE	AC1,LOCO	;GET CURRENT LOCATION
	HRRM	AC1,0(RC)	;SET NEW LINK
	HLRZ	AC1,0(RC)	;GET FLAGS/POINTER
	TRNN	AC1,-2		;POINTER?
	HRR	AC1,RC		;NO, SET TO FLAGS
	HLR	RC,0(AC1)	;PUT FLAGS IN RC
	HRL	AC1,MODO	;GET CURRENT MODE
	TRZE	RC,-2		;LEFT HALF RELOCATABLE+
	TLO	AC1,2		;YES, SET FLAG
	HLLM	AC1,0(AC1)	;STORE NEW FLAGS
BOUT30:	HLLO	CS,AC0
	TLZE	RC,1		;PACK RELOCATION BITS
	TRO	RC,2
	TRNE	RC,2		;LEFT HALF RELOCATABLE?
	TRZ	CS,1		;YES, RESET BIT
	PUSH	PP,AC0		;NEED AN AC
	HLRZ	AC0,-1(PP)	;AC0 = LEFT RELOCATION
	CAILE	AC0,1		;EXTERNAL?
	XORI	CS,EXTF!1	;YES, SET SWITCH
IFN FORMSW,<
	OR	AC0,HWFMT
	JUMPN	AC0,BOUT3H	;EDIT IN HALF WORD FORMAT IF NOT 0
	MOVE	AC0,FORM	;GET FORM WORD
	MOVEI	C,0		;ZERO FIELD SIZE
BOUT3A:	JFFO	AC0,BOUT3B	;AC1 = FIELD SIZE -1
	JRST	BOUT3C		;NO FIELDS LEFT, JUMP
BOUT3B:	LSH	AC0,1(AC1)	;SHIFT OFF FORM FIELD
	MOVEI	AC1,6(AC1)
	IDIVI	AC1,3		;AC1 = COLUMNS USED + 1
	ADDI	C,(AC1)		;INCREMENT FIELD SIZE
	CAIG	C,^D23		;IS FIELD SIZE GTR 23?
	JRST	BOUT3A		;NO.  CONTINUE
	MOVE	AC1,HWFORM	;USE STANDARD FORM
	MOVEM	AC1,FORM
	MOVEI	C,^D13		;SET FIELD SIZE TO 13
BOUT3C:	MOVEM	C,FLDSIZ	;STORE FIELD SIZE
	MOVE	AC0,FORM	;AC0 = FORM WORD
	TRNN	RC,2		;IS LEFT HALF RELOCATED?
	CAMN	AC0,HWFORM	;NO.  IS FORM HALF WORD?
	JRST	BOUT3H		;YES.  EDIT IN OLD WAY
	IBP	TABP
	CAIL	C,^D16
	IBP	TABP
	ILDB	C,TABP		;GET A TAB
	PUSHJ	PP,OUTL		;OUTPUT IT
	MOVE	AC2,(PP)	;AC2 = INFO TO BE EDITED
	PUSH	PP,CS		;SAVE CS = C+1
BOUT3D:	JFFO	AC0,BOUT3E	;AC1 = FIELD LENGTH - 1
BOUT3E:	LSH	AC0,1(AC1)	;SHIFT OFF FORM FIELD
	MOVEI	C,3(AC1)
	MOVEI	AC1,0
	LSHC	AC1,-2(C)	;AC1 = FIELD INFO
	IDIVI	C,3		;C = # OF OCTAL DIGITS
	MOVE	C+1,AC0		;SAVE AC0
	SKIPE	IOSEEN		;IS THIS A I/O INST.
	PUSHJ	PP,BOUT3J	;YES,SET FIELDS CORRECTLY
	MOVNS	C
	ROT	AC1,(C)
	ROT	AC1,(C)
	ROT	AC1,(C)
	MOVNS	C
BOUT3F:	MOVEI	AC0,6		;EDIT A DIGIT
	LSHC	AC0,3
	EXCH	AC0,C
	PUSHJ	PP,OUTC		;OUTPUT IT
	MOVE	C,AC0
	SOJG	C,BOUT3F	;IF MORE DIGITS,  GO BACK
	JUMPE	C+1,BOUT3G	;JUMP IF END OF WORD
	MOVE	AC0,C+1		;RESTORE AC0
	MOVEI	C," "
	PUSHJ	PP,OUTC		;OUTPUT A SPACE
	JRST	BOUT3D		;PROCESS NEXT FIELD

BOUT3G:	POP	PP,CS		;RESTORE CS = C+1
	MOVEI	C," "
	TRNE	RC,1		;RELOCATABLE?
	MOVEI	C,"'"		;YES
	HRRZ	AC0,-1(PP)	;AC0 = RIGHT RELOCATION
	CAILE	AC0,1		;EXTERNAL?
	MOVEI	C,"*"		;YES
	PUSHJ	PP,ONC2		;STORE POSSIBLE INDICATOR
	POP	PP,AC0
	JRST	BOUT3I		;CONTINUE

BOUT3H:	MOVEI	C,^D15		;SET SIZE TO 15
	MOVEM	C,FLDSIZ	;[116]
	SETZM	IOSEEN		;CLEAR INCASE HWFMT WAS SET
>
	POP	PP,AC0		;RESTORE
	PUSHJ	PP,ONC
	HRLO	CS,AC0
	TDZ	CS,RC		;SET RELOCATION
	HRRZ	C,(PP)		;C = RIGHT RELOCATION
	CAILE	C,1		;EXTERNAL
	XORI	CS,EXTF!1	;YES, SET SWITCH
	PUSHJ	PP,ONC
BOUT3I:	POP	PP,CS		;GET RID OF ENTRY ON STACK
	HRRZ	CS,LOCO
	TLNE	FR,RIMSW!RIM1SW!R1BSW	;RIM OUTPUT?
	JRST	ROUT		;YES, GO PROCESS

	HRL	CS,MODO
	CAME	CS,MODLOC	;SEQUENCE OR RELOCATION BREAK?
	PUSHJ	PP,COUTD	;YES, DUMP THE BUFFER
	SKIPL	COUTX		;NEW BUFFER?
	JRST	BOUT40		;NO, STORE CODE AND EXIT
	MOVEM	CS,MODLOC	;YES, STORE NEW VALUES
	EXCH	AC0,LOCO
	EXCH	RC,MODO
	PUSHJ	PP,COUT		;STORE BLOCK LOCATION AND MODE
	EXCH	RC,MODO		;RESTORE CURRENT VALUES
	EXCH	AC0,LOCO

BOUT40:	PUSHJ	PP,COUT		;EMIT CODE
	POP	PP,RC		;RETRIEVE EXTERNAL BITS
	TRNN	RC,-2		;RIGHT EXTERNAL?
	JRST	BOUT50		;TRY FOR LEFT
	PUSHJ	PP,COUTD
	PUSH	PP,BLKTYP	;TERMINATE TYPE AND SAVE
	MOVEI	AC0,2		;BLOCK TYPE 2
	MOVEM	AC0,BLKTYP
	MOVE	AC0,1(RC)	;GET SYMBOL
	MOVEI	ARG,60		;CODE BITS
	PUSHJ	PP,SQOZE	;CONVERT TO RADIX 50
	HLLZS	RC		;SYMBOL HAS NO RELOCATION
	PUSHJ	PP,COUT		;EMIT
	MOVE	AC0,LOCO	;GET CURRENT LOC
	HRLI	AC0,400000	;ADDITIVE REQ
	HRR	RC,MODO		;CURRENT MODE
	PUSHJ	PP,COUT		;EMIT
	MOVSS	RC		;NOW FOR LEFT
	TRNN	RC,-2
	JRST	BOUT60
	JRST	BOUT70
BOUT50:	MOVSS	RC		;CHECK OTHER HALF
	TRNN	RC,-2		;LEFT HALF EXTERNAL?
	JRST	BOUT80		;NO, FALSE ALARM
	PUSHJ	PP,COUTD	;CHANGE MODE
	PUSH	PP,BLKTYP
	MOVEI	AC0,2
	MOVEM	AC0,BLKTYP
BOUT70:	MOVE	AC0,1(RC)
	MOVEI	ARG,60
	PUSHJ	PP,SQOZE
	HLLZS	RC
	PUSHJ	PP,COUT
	MOVE	AC0,LOCO
	HRLI	AC0,600000	;LEFT HALF ADD
	HRR	RC,MODO
	PUSHJ	PP,COUT		;EMIT
BOUT60:	PUSHJ	PP,COUTD	;CHANGE MODE
	POP	PP,BLKTYP	;TO OLD ONE
BOUT80:	AOS	LOCO
	AOS	MODLOC
	POPJ	PP,
IFN FORMSW,<
BOUT3J:	MOVSS	IOSEEN		;SWAP
	SKIPGE	IOSEEN		;SKIP IF NOT FIRST FIELD
	JRST	[HLLZS IOSEEN		;CLEAR RIGHT HALF
		POPJ	PP,]		;AND RETURN
	MOVSS	IOSEEN		;SWAP BACK
	LSH	AC1,2		;CORRECT  MNEMONIC AND OP CODE
	CAIE	C,1		;IS IT OP CODE?
	POPJ	PP,		;NO,JUST RETURN
	MOVEI	C,2		;TWO CHAR. WIDE NOW
	SETZM	IOSEEN		;DON'T COME AGAIN
	POPJ	PP,		;RETURN
>
NOUT:	MOVE	V,[POINT 7,TBUF]	;POINTER TO ASCII LINE
	MOVSI	CS,(POINT 6,AC0)	;POINTER TO SIXBIT AC0
	SETZB	ARG,AC0
NOUT1:	ILDB	C,V		;GET ASCII
	CAIL	C,"A"+40
	CAILE	C,"Z"+40
	JRST	.+2
	TRZA	C,100		;LOWER CASE TO SIXBIT
	SUBI	C,40		;CONVERT TO SIXBIT
	JUMPLE	C,NOUT3		;TEST FORM NON-SIXBIT
	CAILE	C,77		;AND NOT GREATER THAN SIXBIT
	JRST	NOUT3		;...
	IDPB	C,CS		;DEPOSIT IN AC0
	TLNE	CS,770000	;TEST FOR SIX CHARACTERS
	JRST	NOUT1		;NO, GET ANOTHER
NOUT3:	SKIPGE	UNIVSN		;IF A UNIVERSAL PROG
	POPJ	PP,		;RETURN TO PUT IT IN THE TABLE

IFN CCLSW,<SKIPN TBUF+1		;AND IF WE HAVE NOT SEEN A TITLE
	PUSHJ	PP,PRNAM	;THEN PRINT THE NAME>
	PUSHJ	PP,NOUT2	;[214] DUMP NAME
	MOVSI	AC0,11		;[214] TYPE MARKER
	IOR	AC0,CPUTYP	;[235] CPU  TYPE
	PJRST	COUT		;[214] DUMP AND EXIT

NOUT2:	PUSHJ	PP,SQOZE	;CONVERT TO SIXBIT
	JRST	COUT		;DUMP AND EXIT

HOUT:
IFN POLISH,<
	SETZ	AC0,		;[265] FORCE TO PSECT 0
	SKIPE	SGNMAX		;[265] NO PSECTS
	PUSHJ	PP,SGOUTN	;[265] PUT IT OUT
>
	MOVEI	RC,1		;RELOCATABLE
	MOVE	AC0,HHIGH	;GET HIGH SEG IF TWO SEGMENTS
	JUMPE	AC0,.+2		;NOT TWO SEGMENTS
	PUSHJ	PP,COUT		;OUTPUT IT 
	MOVE	AC0,SGATTR	;[265]
	SKIPE	HHIGH		;ANY TWOSEG HIGH STUFF
	JRST	COUT		;YES,SO NO ABS.
	PUSHJ	PP,COUT		;OUTPUT THE HIGHEST LOCATION
	MOVE	AC0,ABSHI
				;PUT OUT ABS PORTION OF PROGRAM BREAK
	SOJA	RC,COUT		;OUTPUT A WORD OF ZERO AND EXIT

IFN POLISH,<			;[164]
;HERE TO OUTPUT BLOCK TYPE 11
POUT:	SKIPN	POLIST		;ANY POLISH TO OUTPUT?
	POPJ	PP,		;NO
	TLO	FR,POLSW	;SET FLAG
	PUSHJ	PP,COUTD	;DUMP BUFFER UNLESS EMPTY
	MOVE	CS,@POLIST	;GET A BLOCK POINTER
	EXCH	CS,POLIST	;SET FOR NEXT TIME
POUTA:	ADDI	CS,1		;FIRST WORD
	MOVE	AC0,(CS)	;GET SOMETHING
	SETZ	RC,		;CLEAR RELOCATION
	JUMPL	AC0,POUTOP	;THIS IS AN OPERATOR
	PUSHJ	PP,PCOUT	;STORE THIS HALF WORD
	JUMPE	AC0,POUT0	;18 BIT VALUE
	SOJE	AC0,POUT1	;36 BIT VALUE
	HLRZ	AC0,1(CS)	;GET HALF OF SYMBOL
	PUSHJ	PP,PCOUT
	HRRZ	AC0,1(CS)	;GET OTHER HALF
	PUSHJ	PP,PCOUT
	AOJA	CS,POUTA

POUT0:	HLRZ	RC,1(CS)	;GET RELOCATION
	HRRZ	AC0,1(CS)	;AND VALUE
	PUSHJ	PP,PCOUT
	AOJA	CS,POUTA	;GET NEXT

POUT1:	HLRZ	RC,1(CS)	;GET LEFT HALF
	HLRZ	AC0,2(CS)
	PUSHJ	PP,PCOUT
	HRRZ	RC,1(CS)	;RIGHT HALF
	HRRZ	AC0,2(CS)
	PUSHJ	PP,PCOUT
	ADDI	CS,2		;SKIP OVER 2 WORDS
	JRST	POUTA

POUTOP:	HRRZ	AC0,AC0		;GET OPERATOR ONLY
	PUSHJ	PP,PCOUT	;OUTPUT
	CAIGE	AC0,-6		;[265] CHECK FOR STORE OP
	JRST	POUTA		;ITS NOT
	CAIGE	AC0,-3		;CHECK FOR SYMBOL FIXUP
	JRST	POUTSY		;IT IS
	HLRZ	RC,1(CS)	;GET RELOCATION
	HRRZ	AC0,1(CS)	;AND STORE ADDRESS
POUTOQ:	PUSHJ	PP,PCOUT
	TLZ	FR,POLSW	;CLEAR FLAG INCASE END
	JRST	POUT		;SEE IF MORE TO GO

POUTSY:	HLRZ	AC0,1(CS)	;GET LHS SYMBOL
	SETZ	RC,		;NO RELOCATION
	PUSHJ	PP,PCOUT	;OUTPUT IT
	HRRZ	AC0,1(CS)	;GET RHS
	PUSHJ	PP,COUT
	JFFO	PP,POUTOQ	;FOLLOW WITH 0 FOR BLOCK LEVEL (FAIL COMPATIBLE)

PCOUT:	MOVE	C,COUTP		;GET POINTER
	TLNE	C,010000	;LEFT OR RIGHT HALF?
	JRST	PCOUTR		;JUST THE RIGHT HALF
	AOS	C,COUTX		;INCREMENT INDEX
	HRLZM	AC0,COUTDB(C)	;STORE LEFT HALF
	IDPB	RC,COUTP	;AND RELOCATION
	POPJ	PP,

PCOUTR:	MOVE	C,COUTX		;GET CURRENT INDEX
	HRRM	AC0,COUTDB(C)	;STORE RIGHT HALF
	IDPB	RC,COUTP	;AND RELOCATION
	CAIE	C,^D17		;IS THE BUFFER FULL
	POPJ	PP,		;NO
	JRST	COUTD		;YES, DUMP IT

;HERE TO OUTPUT BLOCK TYPE 22 - PSECT NAME
SGOUTN:	PUSHJ	PP,COUTD	;FINISH OFF CURRENT BLOCK
	PUSH	PP,BLKTYP	;SAVE CURRENT BLOCK TYPE
	MOVEI	AC0,22		;BLOCK TYPE 22 IS A
	MOVEM	AC0,BLKTYP	; PSECT NAME
	MOVE	C,SGNCUR	;GET CUR PSECT INX
	MOVE	AC0,SGNAME(C)	;GET PSECT NAME
	SETZ	RC,		;CLEAR RELOCATION
	PUSHJ	PP,COUT		;OUTPUT THE BLOCK
	MOVE	C,SGNCUR	;INDEX AGAIN
	HRRZ	AC0,SGORIG(C)	;GET ORIGIN IF SPECIFIED
	SKIPE	AC0		;NOT
	PUSHJ	PP,COUT
	PUSHJ	PP,COUTD	;FINISH IT OFF
	POP	PP,BLKTYP	;RESTORE CURRENT BLOCK TYPE
	POPJ	PP,		;RETURN

;HERE TO OUTPUT BLOCK TYPE 23 - PSECT LENGTH AND ATTRIBUTES
SGOUTL:	PUSHJ	PP,COUTD	;FINISH OFF CURRENT BLOCK
	PUSH	PP,BLKTYP	;SAVE CURRENT BLOCK TYPE
	MOVEI	AC0,23		;BLOCK TYPE 23 IS A
	MOVEM	AC0,BLKTYP	; PSECT LENGTH
	MOVE	RC,SGNCUR	;GET CUR PSECT INX
	MOVE	AC0,SGNAME(RC)	;GET PSECT NAME
	SETZ	RC,		;CLEAR RELOCATION
	PUSHJ	PP,COUT		;OUTPUT THE NAME
	MOVE	RC,SGNCUR	;GET CUR PSECT INX
	MOVE	AC0,SGATTR(RC)	;GET PSECT LENGTH AND ATTRS
	MOVEI	RC,1		;BREAK IS RELOCATED
	PUSHJ	PP,COUT		;OUTPUT THE LENGTH AND ATTRS
	PUSHJ	PP,COUTD	;FINISH IT OFF
	POP	PP,BLKTYP	;RESTORE CURRENT BLOCK TYPE
	POPJ	PP,		;RETURN
>
HSOUT:	SETZM	HISNSW		;CLEAR FOR PASS2
	MOVE	AC0,SVTYP3	;GET HISEG ARG
	JUMPGE	AC0,.+4		;JUMP IF ONLY HISEG
	HRL	AC0,HIGH1	;GET BREAK FROM PASS 1
	JUMPL	AC0,.+2		;OK IF GREATER THAN 400000
	HRLS	AC0		;SIGNAL TWO SEGMENT TO LOADER
	MOVEI	RC,1		;ASSUME RELOCATABLE
	JRST	COUT		;OUTPUT THE WORD

VOUT:	SKIPN	RC,VECREL	;IS VECTOR ABSOLUTE ZERO?
	SKIPE	VECTOR		;ALSO CHECK RELOCATION
	JRST	.+3		;[244]
	SKIPN	VECSYM		;[244] SEE IF SYMBOLIC
	POPJ	PP,		;YES, EXIT
IFN POLISH,<
	MOVE	AC0,VECFND	;GET START ADR PSECT INX
	MOVEM	AC0,SGNCUR	;POINT CUR PSECT THERE
	SKIPE	SGNMAX		;IF PSECTS WERE USED
	PUSHJ	PP,SGOUTN	; THEN PUT OUT PSECT BLOCK
	MOVE	RC,VECREL>	;GET RELOCATION
	MOVE	AC0,VECTOR	;AC0 SHOULD BE FLAGS
	SKIPN	VECSYM		;[244] 2 WORDS IF SYMBOLIC
	JRST	COUT
	PUSHJ	PP,COUT		;OUTPUT CONSTANT
	MOVE	AC0,VECSYM	;[244] GET SYMBOL
	MOVEI	ARG,60		;[210] MAKE REQUEST
	PUSHJ	PP,SQOZE	;[210] IN RADIX-50
	SETZ	RC,		;[240]

COUT:	AOS	C,COUTX		;INCREMENT INDEX
	MOVEM	AC0,COUTDB(C)	;STORE CODE
	IDPB	RC,COUTP	;STORE RELOCATION BITS
	CAIE	C,^D17		;IS THE BUFFER FULL?
	POPJ	PP,		;NO, EXIT

COUTD:	AOSG	C,COUTX		;DUMP THE BUFFER
	JRST	COUTI		;BUFFER WAS EMPTY
	HRL	C,BLKTYP	;SET BLOCK TYPE
COUTT:				;[232] ENTER FROM .TEXT PSEUDO-OP
	PUSHJ	PP,OUTBIN	;OUTPUT COUNT AND TYPE
	SETOB	C,COUTY		;INITIALIZE INDEX

COUTD2:	MOVE	C,COUTDB(C)	;GET RELOCATION BITS/CODE
	PUSHJ	PP,OUTBIN	;DUMP IT
	AOS	C,COUTY		;INCREMENT INDEX
	CAMGE	C,COUTX		;TEST FOR END
	JRST	COUTD2		;NO, GET NEXT WORD

COUTI:	SETOM	COUTX		;INITIALIZE BUFFER INDEX
	SETZM	COUTRB		;ZERO RELOCATION BITS
IFN POLISH,<
	HRRZ	C,BLKTYP	;[164] IF WE ARE OUTPUTING
	CAIN	C,11		;[164] POLISH BLOCK TYPE 11
	SKIPA	C,[POINT 1,COUTRB]	;[164] USE HALF WORDS
>
	MOVE	C,[POINT 2,COUTRB]
	MOVEM	C,COUTP		;INITIALIZE BIT POINTER
	POPJ	PP,		;EXIT

STOWZ1:
IFN FORMSW,<	MOVE	AC1,HWFORM	;USE STANDARD FORM>
STOWZ:	MOVEI	RC,0
STOW:
IFN FORMSW,<	MOVEM	AC1,FORM	;STORE FORM WORD>
	JUMP1	STOW20		;SKIP TEST IF PASS ONE
	TRNE	RC,-2		;RIGHT HALF ZERO OR 1?
	PUSHJ	PP,STOWT	;NO, HANDLE EXTERNAL
	TLNN	RC,-2		;LEFT HALF ZERO OR 1? WFW
	JRST	STOW10		;YES, SKIP TEST
	MOVSS	RC		;SWAP HALVES
	PUSHJ	PP,STOWT1	;HANDLE EXTERNAL WFW
	MOVSS	RC		;RESTORE VALUES

STOW10:	SKIPE	EXTPNT		;ANY EXTERNALS REMAINING?
	TRO	ER,ERRE		;YES, SET EXTERNAL ERROR FLAG

STOW20:	AOS	AC1,STPX	;INCREMENT POINTER
	MOVEM	AC0,STCODE(AC1)	;STOW CODE
	MOVEM	RC,STOWRC(AC1)	;STOW RELOCATION BITS
IFN FORMSW,<
	PUSH	PP,FORM
	POP	PP,STFORM(AC1)	;STORE FORM WORD
>
	SKIPN	LITLVL		;ARE WE IN LITERAL?
	AOS	LOCA		;NO, INCREMENT ASSEMBLY LOCATION
	CAIGE	AC1,.STP-1	;OVERFLOW?
	POPJ	PP,		;NO, EXIT

	SKIPE	LITLVL		;ARE WE IN A LITERAL?
	TROA	ER,ERRL		;YES, FLAG ERROR BUT DON'T DUMP
	JRST	CHARL1		;NO, SAVE REGISTERS AND DUMP THE BUFFER
	JRST	STOWI		;INITIALIZE BUFFER

DSTOW:	AOS	AC1,STPY	;INCREMENT POINTER
	MOVE	AC0,STCODE(AC1)	;FETCH CODE
	MOVE	RC,STOWRC(AC1)	;FETCH RELOCATION BITS
IFN FORMSW,<
	PUSH	PP,STFORM(AC1)
	POP	PP,FORM		;GET FORM WORD
>
	CAMGE	AC1,STPX	;IS THIS THE END?
	POPJ	PP,		;NO, EXIT

STOWI:	SETOM	STPX		;INITIALIZE FOR INPUT
	SETOM	STPY		;INITIALIZE FOR OUTPUT
	SETZM	EXTPNT
	POPJ	PP,		;EXIT

SVSTOW:	AOS	LITLVL		;NESTED LITERALS
	PUSH	PP,STPX		;MAKE ROOM FOR ANOTHER
	PUSH	PP,STPY
	MOVE	AC1,STPX
	MOVEM	AC1,STPY
	JRST	0(AC2)

GTSTOW:	POP	PP,STPY		;BACK UP A LEVEL
	POP	PP,STPX
	SOS	LITLVL
	JRST	0(AC2)

	;EXTERNAL RIGHT
STOWT:	HRRZ	AC1,EXTPNT	;GET RIGHT POINTER
	CAIE	AC1,(RC)	;DOES IT MATCH 
	PUSHJ	PP,QEXT		;EXTERNAL OR RELOCATION ERROR
	HLLZS	EXTPNT
	POPJ	PP,		;EXIT

	;EXTERNAL LEFT
STOWT1:	HLRZ	AC1,EXTPNT	;GET LEFT HALF
	CAIE	AC1,(RC)	;SEE ABOVE
	PUSHJ	PP,QEXT
	HRRZS	EXTPNT
	POPJ	PP,		;EXIT

ONC:	ILDB	C,TABP		;ENTRY TO ADVANCE TAB POINTER
	PUSHJ	PP,OUTL		;OUTPUT A TAB
				;OUTPUT 6 OCT NUMBERS FROM CS LEFT
ONC1:	MOVEI	C,6		;CONVERT TO ASCII
	LSHC	C,3		;SHIFT IN OCTAL
	PUSHJ	PP,OUTL		;OUTPUT ASCII FROM C
	TRNE	CS,-1		;ARE WE THROUGH?
	JRST	ONC1		;NO, GET ANOTHER
	MOVEI	C,0		;CLEAR C
	TLNN	CS,1		;RELOCATABLE?
	MOVEI	C,"'"		;YES
	TLNN	CS,EXTF		;OR EXTERNAL
	MOVEI	C,"*"		;YES
ONC2:	JUMPN	C,OUTC		;OUTPUT IF EXTERN OR RELOCATABLE
IFN FORMSW,<	SOS	FLDSIZ	;DECREMENT FIELD SIZE>
	POPJ	PP,		;EXIT

DNC:	IDIVI	C,^D10
	HRLM	CS,0(PP)
	JUMPE	C,.+2
	PUSHJ	PP,DNC		;RECURSE IF NON-ZERO
	HLRZ	C,0(PP)
	ADDI	C,"0"		;FORM ASCII
	JRST	PRINT		;DUMP AND TEST FOR END

OUTAS0:	HRLI	CS,(POINT 7,,)	;ENTRY TO SET POINTER
OUTASC:	ILDB	C,CS		;GET NEXT BYTE
	JUMPE	C,POPOUT	;EXIT ON ZERO DELIMITER
	PUSHJ	PP,PRINT
	JRST	OUTASC

OUTSIX:	HRLI	CS,(POINT 6,,)	;OUTPUT SIXBIT
	ILDB	C,CS		;GET SIXBIT
	CAIN	C,40		;"@" DELIMITER?
	POPJ	PP,		;YES, EXIT
	ADDI	C,40		;NO, FORM ASCII
	PUSHJ	PP,OUTL		;OUTPUT ASCII CHAR FROM C
	JRST	OUTSIX+1

OUTSYM:	MOVE	CS,AC0		;PLACE NAME IN CS
OUTSY1:	MOVEI	C,0		;CLEAR C
	LSHC	C,6		;MOVE NEXT SIXBIT CHARACTER IN
	JUMPE	C,OUTTAB	;TEST FOR END
	ADDI	C,40		;CONVERT TO ASCII
	PUSHJ	PP,OUTL		;OUTPUT
	JRST	OUTSY1		;LOOP

OUTSET:	AOS	SX,0(PP)	;GET RETURN LOCATION
	MOVE	SX,-1(SX)	;GET XWD CODE
	HLRM	SX,BLKTYP	;SET BLOCK TYPE
	SETZB	ARG,RC
	PUSHJ	PP,0(SX)	;GO TO PRESCRIBED ROUTINE
	JRST	COUTD		;TERMINATE BLOCK AND EXIT

	;LOOKUP SCANS ALL THE SYMBOLS IN THE SYMBOL TABLE

LOOKUP:	POP	PP,LOOKX	;INTERCEPT RETURN POP
	MOVE	SX,SYMBOL
IFE POLISH,<
	MOVE	SDEL,0(SX)	;SET FOR TABLE SCAN
LOOKL:	SOJL	SDEL,POPOUT	;TEST FOR END
>
IFN POLISH,<
	PUSH	PP,0(SX)	;SET FOR TABLE SCAN
LOOKL:	SOSGE	0(PP)		;TEST FOR END
	JRST	LOOKXT		;DONE, EXIT
>
	ADDI	SX,2
	MOVE	AC0,-1(SX)
	PUSHJ	PP,SRCH7	;LOAD REGISTERS
	HLRZS	ARG
	PUSHJ	PP,@LOOKX	;RETURN TO CALLING ROUTINE
	JRST	LOOKL		;TRY AGAIN

IFE POLISH,<SYN LOOKUP,SGLKUP>
IFN POLISH,<
LOOKXT:	POP	PP,AC0		;THROW AWAY COUNTER
	POPJ	PP,
SGLKUP:	POP	PP,LOOKX	;INTERCEPT RETURN POP
	MOVE	SX,SGNCUR	;GET CUR PSECT INX
	PUSH	PP,SGSCNT(SX)	;SAVE SYM CNT
	HRRZS	0(PP)		;DON'T WANT LEFT HALF
	MOVE	SX,SGSBOT	;GET INIT SYM TAB PTR
	JRST	LOOKL		;REST IS SAME AS FOR FULL CASE
>

END0:
IFN POLISH,<
	HRROS	SGNCUR		;[265] FORCE EVALUATION IN ITS OWN PSECT
>
	PUSHJ	PP,EVALCM	;GET A WORD
IFN POLISH,<
	HRRZS	SGNCUR		;[265] BACK TO NORMAL
>
	SKIPN	V,AC0		;NON-ZERO?
	JUMPE	RC,.+2		;OR RELOC?
	PUSHJ	PP,ASSIG7	;YES, LIST THE VALUE
	SETZM	VECSYM		;[240] INCASE NOT SYMBOLIC
	SKIPN	EXTPNT		;[210] EXTERNAL?
	JRST	END00		;[210] NO
	CAME	RC,EXTPNT	;[210] MAKE SURE SAME
	JRST	[SETZB	AC0,VECSYM	;[244] NO, CLEAR
		TRO	ER,ERRE		;[210] FLAG ERROR
		JRST	.+3]		;[244]
	MOVE	RC,1(RC)	;[244] GET SIXBIT NAME
	MOVEM	RC,VECSYM	;[244] STORE SYMBOL NAME
	SETZB	RC,EXTPNT	;[210] AND CLEAR RELOC
END00:	MOVEM	AC0,VECTOR
	MOVEM	RC,VECREL
IFN POLISH,<
	MOVE	AC1,SGWFND	;[265] GET START ADR PSECT INX
	MOVEM	AC1,VECFND	;[265] SAVE IT
>
	PUSHJ	PP,STOUTS	;DUMP THE LINE
END01:	SETZ	MRP,		;[223] SHOULDN'T BE IN A MACRO BY NOW
IFN POLISH,<
	MOVE	AC1,SGNMAX	;[265] GET HIGHEST PSECT USED
	PUSH	PP,AC1		;[265] SAVE IT
END02:	CAME	AC1,SGNCUR	;[265] IF NOT CURRENT
	PUSHJ	PP,%SWSEG	;[265] SWAP IT
>
	PUSHJ	PP,VARA		;FILL OUT SELF-DEFINED VARIABLES
IFE IIISW,<PUSH	PP,IO		;SAVE FLAGS
	TLO	IO,IOPROG	;XLIST LITS>
	PUSHJ	PP,LIT1
IFE IIISW,<POP	PP,IO		;GET FLAG BACK>
IFN POLISH,<
	SOSL	AC1,0(PP)	;[265] DONE YET?
	JRST	END02		;[265] NO
	POP	PP,AC1		;[265] GET JUNK OFF STACK
>
	JUMP2	ENDP2

	MOVE	HHIGH		;GET HIGH SEG BREAK
	MOVEM	HIGH1		;SAVE FOR TWOSEG/HISEG BLOCK TYPE 3
	PUSHJ	PP,UOUT
	TLNN	IO,MFLSW	;SKIP IF ONLY PSEND
	PUSHJ	PP,REC2
	MOVE	INDIR		;SET UP FIRST AS LAST
	MOVEM	LSTFIL		;PRINTED
	SETZM	LSTPGN
	PUSHJ	PP,INZ1		;[234]
	TLNE	IO,MFLSW	;IF PSEND
	POPJ	PP,		;BACK TO PSEND0
	SKIPE	PRGPTR		;HAVE ANY PRGEND'S BEEN SEEN
	PUSHJ	PP,PSEND3	;YES,GO SET UP AGAIN

PASS20:	SETZM	CTLSAV
	PUSHJ	PP,COUTI
	PUSHJ	PP,EOUT		;OUTPUT THE ENTRIES
	PUSHJ	PP,OUTSET
	XWD	6,NOUT		;OUTPUT THE NAME (BLKTYP-6)
	SKIPN	HISNSW		;PUT OUT BLOCK TYPE 3?
	JRST	PASS21		;NO
	PUSHJ	PP,OUTSET
	XWD	3,HSOUT		;OUTPUT THE HISEG BLOCK
PASS21:	MOVEI	1
	HRRM	BLKTYP		;SET FOR TYPE 1 BLOCK
	TLZ	FR,P1		;SET FOR PASS 2 AND TURN OFF FLAG
	TLO	IO,IOPALL	;PUT THESE BACK
	TLZ	IO,IOPROG!IOCREF!DEFCRS!IONCRF	;[141] SO LISTINGS WILL BE THE WAY THEY SHOULD
	TLNN	FR,R1BSW
	JRST	STOWI
	MOVE	CS,[XWD $ST-1-$CKSM,R1BLDR]
	MOVE	C,0(CS)
	PUSHJ	PP,PTPBIN
	AOBJN	CS,.-2
	PUSHJ	PP,R1BI
	JRST	STOWI
	
R1BLDR:
	PHASE	0
	IOWD	$ADR,$ST
$ST:	CONO	PTR,60
	HRRI	$A,$RD+1
$RD:	CONSO	PTR,10
	JRST	.-1
	DATAI	PTR,@$TBL1-$RD+1($A)
	XCT	$TBL1-$RD+1($A)
	XCT	$TBL2-$RD+1($A)
$A:	SOJA	$A,
$TBL1:	CAME	$CKSM,$ADR
	ADD	$CKSM,1($ADR)
	SKIPL	$CKSM,$ADR
$TBL2:	JRST	4,$ST
	AOBJN	$ADR,$RD
$ADR:	JRST	$ST+1
$CKSM:	
	DEPHASE

IF2,<	PURGE	$ST,$RD,$A,$TBL1,$TBL2,$ADR,$CKSM>

ENDP2:	PUSHJ	PP,COUTD	;DUMP THE BUFFER
	MOVE	AC0,LOCO	;CHECK TO SEE IF LIT DIFFERED
	SKIPN	MODO		;AND USE SMALLER SINCE AT END
	JRST	[CAMN	AC0,ABSHI
		HRRZM	AC2,ABSHI
		JRST	ENDP2W]
	SKIPE	HHIGH		;SKIP IF NOT TWO SEGMENTS
	JRST	[CAMN	AC0,HHIGH
		HRRZM	AC2,HHIGH
		JRST	ENDP2W]
	CAMN	AC0,HIGH
	HRRZM	AC2,HIGH
ENDP2W:
IFN POLISH,<
	MOVE	AC1,SGNCUR
	CAMN	AC0,HIGH
	HRRM	AC2,SGATTR(AC1)
>
REPEAT 1,<TLNE	IO,IOCREF	;CLOSE CREF IF NECESSARY>
REPEAT 0,<TLNE	FR,CREFSW	;IF CREFFING
	JRST	ENDP2Q
	MOVEI	SDEL,0
	PUSH	PP,DBUF+3	;SO NO PAGE INFO
	DPB	SDEL,[POINT 7,DBUF+3,13]
	IOR	ER,OUTSW	;MAKE SURE OF OUTPUT
	PUSHJ	PP,CREF
	MOVEI	C,20		;CODE FOR TITLE
	PUSHJ	PP,OUTLST
	PUSH	PP,IO		;SAVE THIS
	TLZ	IO,IOPAGE	;AND PREVENT PAGE DURING TITLE
	MOVEI	CS,TBUF
	PUSHJ	PP,OUTAS0
	MOVEI	CS,VBUF
	PUSHJ	PP,OUTAS0
	POP	PP,IO		;RESTORE THE IO WORD
	POP	PP,DBUF+3>	;NEEDS FIX TO CREF
	PUSHJ	PP,CLSCR2	;CLOSE IT UP
ENDP2Q:	HRR	ER,OUTSW	;SET OUTPUT SWITCH
	SKIPN	TYPERR
	TRO	ER,TTYSW
	PUSHJ	PP,UOUT		;OUTPUT UNDEFINEDS
	TRO	ER,TTYSW
	OUTPUT	CTL,		;CLEAR JUNK OUT OF BUFFER
	SKPINC	C		;SEE IF WE CAN INPUT A CHAR.
	  JFCL			;BUT ONLY TO DEFEAT ^O
	SKIPG	C,QERRS		;ANY Q ERRORS SEEN?
	JRST	ENDPER		;NO, TRY REAL ERRORS
	PUSHJ	PP,OUTCR	;NEW LINE
	MOVEI	C,"%"		;WARNING CHARACTER
	PUSHJ	PP,OUTL
	MOVE	C,QERRS		;GET COUNT
	CAIN	C,1		;1 IS SPECIAL
	JRST	ONERQ
	PUSHJ	PP,DNC		;OUTPUT IT
	SKIPA	CS,[EXP ERRMQ2]
ONERQ:	MOVEI	CS,ERRMQ1
	PUSHJ	PP,OUTSIX
ENDPER:	SKIPG	C,ERRCNT	;GET ERROR COUNT AND CHECK FOR POSITIVE
	JRST	NOERW		;PRINT NO ERROR MESSAGE
IFN CCLSW,<ADDM C,.JBERR	;REMEMBER ERROR COUNT FOR EXECUTION DELETION>
	PUSHJ	PP,OUTCR
	MOVEI	C,"?"		;? FOR BATCH
	PUSHJ	PP,OUTL		;...
	MOVE	C,ERRCNT	;PRINT NUMBER OF ERRORS
	CAIN	C,1		;1 IS A SPECIAL CASE
	JRST	 ONERW		;PRINT MESSAGE
	PUSHJ	PP,DNC
	SKIPA	CS,[EXP ERRMS1]	;LOAD TO PRINT
ONERW:	MOVEI	CS,ERRMS2	;ONE ERROR DETECTED
ONERW1:	PUSHJ	PP,OUTSIX	;PRINT
	JRST	ENDP2A

NOERW:	SKIPE	QERRS		;IF "Q" ERRORS
	PUSHJ	PP,OUTCR	;CLOSE LINE NOW
	MOVEI	CS,ERRMS3
IFN CCLSW,<TLNE IO,CRPGSW!MFLSW	;IF RPG, DON'T PRINT MESSAGE>
IFE CCLSW,<TLNE	IO,MFLSW	;NOR IF MULTI-FILE MODE>
	TRZ	ER,TTYSW	;NO TTY OUTPUT
	IOR	ER,OUTSW	;UNLESS NEEDED FOR LISTING
	SKIPN	QERRS		;ALREADY DONE
	PUSHJ	PP,OUTCR
	JRST	ONERW1

ENDP2A:	PUSHJ	PP,OUTCR
	TLNN	IO,MFLSW	;IN A MULTI-PROG FILE?
	JRST	ENDP2D		;NO
	SKIPN	QERRS		;ANY WARNINGS?
	SKIPE	ERRCNT		;ANY ERROR?
	PUSHJ	PP,[MOVEI CS,[ASCIZ /PROGRAM	/]
		PUSHJ PP,OUTAS0		;YES,SO PRINT MESSAGE
		MOVEI	CS,TBUF		;AND TITLE
		PUSHJ PP,OUTAS0		;FOR IDENTIFICATION
		JRST	OUTCR]		;AND A CR-LF
	TRZA	ER,TTYSW	;NO MORE OUTPUT NOW
ENDP2D:
IFN CCLSW,<TLNE IO,CRPGSW	;IF RPG, DON'T PRINT PGM BREAK
	TRZ	ER,TTYSW	;...>
IFE CCLSW,<	SKIPA		;SO PRGEND CODE CAN WORK>
	IOR	ER,OUTSW	;...
	PUSHJ	PP,OUTCR
	MOVEI	CS,[SIXBIT /HI-SEG. BREAK IS @/]
	SKIPN	HHIGH		;DON'T PRINT IF ZERO
	JRST	ENDP2C		;IT WAS
	PUSHJ	PP,OUTSIX
	HRLO	CS,HHIGH	;GET THE BREAK
	PUSHJ	PP,ONC1
	PUSHJ	PP,OUTCR
ENDP2C:	MOVEI	CS,[SIXBIT /PROGRAM BREAK IS @/]
	PUSHJ	PP,OUTSIX	;OUTPUT PROGRAM BREAK
	HRLO	CS,SGATTR	;GET PROGRAM BREAK
	PUSHJ	PP,ONC1
	PUSHJ	PP,OUTCR
IFN POLISH,<
	SKIPN	AC1,SGNMAX	;GET PSECT CNT
	JRST	ENDP2E		;PSECTS NOT USED?
	MOVEI	AC2,1
ENDP2F:	MOVEI	CS,[SIXBIT /PSECT   BREAK IS @/]
	PUSHJ	PP,OUTSIX	;OUTPUT PSECT BREAK
	HRLO	CS,SGATTR(AC2)	;GET PSECT BRK
	PUSHJ	PP,ONC1
	MOVE	CS,[SIXBIT / FOR  /]
	MOVEM	CS,SGLIST
	MOVE	CS,SGNAME(AC2)	;GET PSECT NAME
	MOVEM	CS,SGLIST+1
	MOVSI	CS,SIXBIT/   @  /
	MOVEM	CS,SGLIST+2
	MOVEI	CS,SGLIST
	PUSHJ	PP,OUTSIX
	PUSHJ	PP,OUTCR
	AOS	AC2
	SOJG	AC1,ENDP2F	;LOOP THRU PSECT.S
ENDP2E:>
	HRRZ	CS,ABSHI	;GET ABS. BREAK
	CAIG	CS,140		;ANY ABS. CODE
	JRST	ENDP2B		;NO, SO DON'T PRINT
	MOVEI	CS,[SIXBIT /ABSLUTE BREAK IS @/]
	PUSHJ	PP,OUTSIX
	HRLO	CS,ABSHI
	PUSHJ	PP,ONC1
	PUSHJ	PP,OUTCR
ENDP2B:	MOVEI	CS,[SIXBIT /CPU TIME USED @/]
	PUSHJ	PP,OUTSIX	;[234] PRINT THE TIME IT TOOK TO ASSEMBLE
	SETZ	C,		;[234] SO AS TO GET THE RIGHT TIME
	RUNTIM	C,		;[234] GET THE TIME NOW
	SUB	C,RTIME		;[234] MINUS TIME WHEN STARTED
	IDIVI	C,^D1000	;[234] GET MS.
	PUSH	PP,C+1		;[234] SAVE
	IDIVI	C,^D60		;[234] GET SEC. IN C+1, MIN. IN C
	PUSH	PP,C+1		;[234] SAVE SECONDS
	IDIVI	C,^D60		;[234] GET HOURS IN C, MINS. IN C+1
	PUSH	PP,C+1		;[234] SAVE MINS
	JUMPE	C,NOHOUR	;[234] SKIP IF LESS THAN 1 HOUR
	PUSHJ	PP,DNC		;[234] PRINT HOURS
	MOVEI	C,":"		;[234] SEPARATOR
	PUSHJ	PP,OUTC		;[234]
NOHOUR:	POP	PP,CS		;[234] GET MINS
	PUSHJ	PP,DECPT2	;[234] PRINT THEM
	MOVEI	C,":"		;[234]
	PUSHJ	PP,OUTC		;[234]
	POP	PP,CS		;[234] A LITTLE DIFFERENT FOR MS
	PUSHJ	PP,DECPT2	;[234] PRINT SECONDS
	MOVEI	C,"."		;[234] A POINT FOR MS.
	PUSHJ	PP,OUTC		;[234]
	POP	PP,CS		;[234] GET MS.
	PUSHJ	PP,DECPT3	;[234] PRINT MS.
	PUSHJ	PP,OUTCR	;[234] AND A CRLF
	TLNE	FR,RIMSW!R1BSW	;RIM MODE?
	PUSHJ	PP,RIMFIN	;YES, FINISH IT
IFN CCLSW,<TLNN	IO,CRPGSW!MFLSW	;IF NOT IN CCL MODE>
IFE CCLSW,<TLNN	IO,MFLSW	;NOR IF IN MULTI-FILE MODE>
	TRO	ER,TTYSW	;PRINT SIZE
	PUSHJ	PP,OUTCR
	MOVE	C,.JBREL
IFN TENEX,<
	SUB	C,SYMBOL	;[206] ONLY COUNT WHATS REALLY IN USE
	ADD	C,FREE		;[206] EITHER SYMBOLS OR STORAGE
	LSH	C,-9		;[206] IN PAGES
>
IFE TENEX,<
	LSH	C,-^D10
>
	ADDI	C,1
	PUSHJ	PP,DNC
IFE TENEX,<
	MOVEI	CS,[SIXBIT /K CORE USED@/]
>
IFN TENEX,<
	MOVEI	CS,[SIXBIT /  PAGES USED@/]
>
	PUSHJ	PP,OUTSIX
	PUSHJ	PP,OUTCR	
	HRR	ER,OUTSW
	PUSHJ	PP,OUTSET
	XWD	10,LSOUT	;OUTPUT THE LOCALS (..-10)
IFN POLISH,<
	SETZM	SGNCUR		;SET TO BLANK PSECT
	SKIPN	SGNMAX		;WERE PSECTS USED?
	JRST	ENDP2H		;NO
ENDP2G:	PUSHJ	PP,SRCHI	;SET UP SRCHX,SGSBOT,SGSTOP
	PUSHJ	PP,SGOUTL	;OUTPUT PSECT LENGTH BLOCK
ENDP2H:
>
	PUSHJ	PP,OUTSET
	XWD	2,SOUT		;OUTPUT THE SYMBOLS (BLKTYP-2)
IFN POLISH,<
	AOS	SX,SGNCUR	;INCR PSECT INX
	CAMG	SX,SGNMAX	;LAST PSECT DONE?
	JRST	ENDP2G		;NO, DO NEXT PSECT
	SETZM	SGNCUR		;SET TO BLANK PSECT
	PUSHJ	PP,OUTSET	;[164]
	XWD	11,POUT		;[164] OUTPUT THE POLISH (..-11)
	MOVSI	SX,(POINT 2)	;[164] RESET BYTE COUNT
	HLLM	SX,COUTP	;[164] AFTER END OF POLISH
>
	PUSHJ	PP,OUTSET
	XWD	7,VOUT		;OUTPUT TRANSFER VECTOR (..-7)
	PUSHJ	PP,OUTSET
	XWD	5,HOUT		;OUTPUT HIGHEST RELOCATABLE (..-5)
	PUSHJ	PP,COUTD
	TLNN	IO,MFLSW	;IS IT PRGEND?
	JRST	FINIS		;ALAS, FINISHED
	MOVEI	CS,SBUF		;RESET SBUF POINTER
	HRRM	CS,SUBTTX	;TO SUBTTL
	SETZM	PASS2I		;CLEAR PASS2 VARIABLES
	MOVE	[XWD PASS2I,PASS2I+1]
	PUSH	PP,PAGENO	;SAVE PAGE NUMBER IN CASE PRGEND
	BLT	PASS2Z-1	;BUT NOT ALL OF VARIABLES
	POP	PP,PAGENO	;RESTORE IT
;	JRST	INZ		;RE-INITIALIZE FOR NEXT PROG
				; FALL THROUGH

SUBTTL	PASS INITIALIZE

INZ:	SETZ	C,		;[234] GET CURRENT JOB NUMBER
	RUNTIM	C,		;[234] GET RUNTIME FOR LATER
	MOVEM	C,RTIME		;[234] SAVE
INZ1:	AOS	MODA
	AOS	MODO
IFN POLISH,<
	MOVE	AC1,SGNMAX
	MOVSI	AC0,1
	MOVEM	AC0,SGRELC(AC1)
	SOJGE	AC1,.-1
	MOVE	AC1,SGNMAX	;[265] GET HIGHEST PSECT USED
	PUSH	PP,AC1		;[265] SAVE IT
INZ2:	CAME	AC1,SGNCUR	;[265] IF NOT CURRENT
	PUSHJ	PP,%SWSEG	;[265] SWAP IT
>
	MOVEI	VARHD
	MOVEM	VARHDX
	MOVEI	LITHD
	MOVEM	LITHDX
	PUSHJ	PP,LITI
IFN POLISH,<
	SOSL	AC1,0(PP)	;[265] DONE YET?
	JRST	INZ2		;[265] NO
	POP	PP,AC1		;[265] GET JUNK OFF STACK
>
	SETZM	SEQNO
	HRRI	RX,^D8
	PUSHJ	PP,STOWI
IFN FORMSW,<
	HRRES	HWFMT		;SET DEFAULT VALUE BACK>
	JRST	OUTLI

RCPNTR:	POINT	1,ARG,^L<RELF>-18	;POINT 1,ARG,22

;[234] ROUTINE TO PRINT CPU TIME USED

DECPT3:	MOVEI	C,"0"		;[234] FILL WITH ZERO
	CAIG	CS,^D99		;[234] 3 DIGITS?
	PUSHJ	PP,OUTC		;[234] NO
DECPT2:	MOVEI	C,"0"		;[234] FILL WITH ZERO
	CAIG	CS,^D9		;[234] 2 DIGITS?
	PUSHJ	PP,OUTC		;[234] NO
	MOVE	C,CS		;[234] GET VALUE
	PJRST	DNC		;[234] OUTPUT IN DECIMAL AND RETURN

RIMFIN:	TLNE	FR,R1BSW
	PUSHJ	PP,R1BDMP
	SKIPN	C,VECTOR
	MOVSI	C,(JRST 4,)
	TLNN	C,777000
	TLO	C,(JRST)
	PUSHJ	PP,PTPBIN
	MOVEI	C,0
	JRST	PTPBIN

SUBTTL	PSEUDO-OP HANDLERS

TAPE0:	PUSHJ	PP,STOUTS	;FINISH THIS LINE
	PUSHJ	PP,PEEK		;[221] LOOK AT NEXT CHARACTER
	CAIE	C,VT		;[221] PRINT IF V TAB
	CAIN	C,FF		;[221] OR FORM FEED
	PUSHJ	PP,STOUTS	;[221]
	TLZ	IO,IORPTC	;[221] CLEAR CHARACTER FROM LOOK-AHEAD
	PUSHJ	PP,OUTLI2	;[221] AND FROM LINE BUFFER
	JRST	GOTEND		;AND IGNORE THE REST OF THIS FILE

%NOBIN:	TLZE	FR,PNCHSW	;IS REL FILE OPEN?
	CLOSE	BIN,40		;YES, GET RID OF IT
	POPJ	PP,

RADIX0:	PUSHJ	PP,EVAL10	;EVALUATE RADIX D10
	CAIG	AC0,^D10	;IF GREATER THAN 10
	CAIG	AC0,1		;OR LESS THAN 2,
ERRAX:	TROA	ER,ERRA		;FLAG ERROR AND SKIP
	HRR	RX,AC0		;SET NEW RADIX
	POPJ	PP,


XALL0:	JUMP1	POPOUT		;IGNORE ON PASS 1
	TLZN	IO,IOSALL	;TURN OFF MACRO SUPPRESS ALL
	JRST	IOSET		;NOT SALL ON SO NOTHING TO WORRY ABOUT
	CAIE	C,EOL		;END OF LINE SEEN?
	JRST	XALL1		;NO
	LDB	C,LBUFP		;GET LAST CHARACTER
	CAIN	C,CR		;UNDER SPECIAL CIRCUMSTANCES IT GETS REMOVED
	JRST	XALL1		;[236] NO, ALL IS WELL
	SOSG	CPL		;ANY ROOM?
	PUSHJ	PP,RSW5		;[254] NO, SEE IF ANY EXCESS IN IT
	MOVEI	C,CR		;NOW FOR TERMINAYOR
	IDPB	C,LBUFP		;WILL GET REMOVED LATER
XALL1:	PUSHJ	PP,IOSET	;[236] FINISH OFF LINE
	TRNN	SX,IOPALL	;[236] WAS IT XALL OR XLIST?
	TLO	IO,IOSALL	;[236] IT WAS XLIST
	POPJ	PP,		;[236]

IOSET:	JUMP1	POPOUT		;NOSYM (IONSYM), XALL (IOPALL), XLIST (IOPROG)
	HLRZ	SX,AC0		;STORE FLAGS
	PUSHJ	PP,STOUTS	;POLISH OFF LINE
	TLO	IO,0(SX)	;NOW SUPRESS PRINTING
	POPJ	PP,

IORSET:	TDZ	IO,AC0		;RESET  FLAG IOPALL/IOPROG
	POPJ	PP,

BLOCK0:	PUSHJ	PP,HIGHQ
	PUSHJ	PP,EVALEX	;EVALUATE
	TLNE	AC0,-1		;[233] SEE IF VALID ARG TYPE
	JRST	ERRAX		;[233] NO, GIVE ERROR
	TRZE	RC,-1		;EXTERNAL OR RELOCATABLE?
	PUSHJ	PP,QEXT		;YES, DETERMINE TYPE
	ADDM	AC0,LOCO	;UPDATE ASSEMBLY LOCATION
BLOCK1:	EXCH	AC0,LOCA	;SAVE START OF BLOCK
	ADDM	AC0,LOCA	;UPDATE OUTPUT LOCATION
BLOCK2:	HRLOM	AC0,LOCBLK
	JUMP2	POPOUT
	TRNE	ER,ERRU
	TRO	ER,ERRV
	POPJ	PP,

PRNTX0:	TRO	ER,TTYSW	;SET OUTPUT TO TTY
	JUMP2	PRNTX2		;PASS1?
	TDOA	ER,OUTSW	;YES,OUTPUT TO LSTDEV ALSO
PRNTX2:	ANDCM	ER,OUTSW	;NO,DON'T OUTPUT TO TTY IF IT IS LSTDEV
	BYPASS			;GET FIRST CHAR.
	TLOA	IO,IORPTC	;REPEAT IT AND SKIP
PRNTX4:	PUSHJ	PP,PRINT	;PRINT THE CHAR.
	PUSHJ	PP,CHARAC	;GET ASCII CHAR.
	CAIG	C,CR		;IF GREATER THAN CR
	CAIG	C,HT		;OR LESS THAN LF
	JRST	PRNTX4		;THEN CONTINUE
	PUSHJ	PP,OUTCR	;OUTPUT A CRLF
	TRZA	ER,TTYSW!LPTSW	;TURN OF OUTPUT
CPOPJ1:	AOS	(PP)		;USEFUL TAG HAS TO GO SOMEWHERE
CPOPJ:	POPJ	PP,		;EXIT

REMAR0:	PUSHJ	PP,GETCHR	;GET A CHARACTER
REMAR1:	CAIE	C,EOL
	JRST	REMAR0
	POPJ	PP,		;EXIT

PAGE0:	PUSHJ	PP,STOUTS	;[161] PAGE PSEUDO-OP

PAGE1:	TLNE	IO,IOCREF	;[161] CURRENTLY DOING CREF?
	TLNE	IO,IOPROG	;[161] AND NOT XLISTED?
	JRST	PAGE2		;[161] NO
	HRR	ER,OUTSW	;[161]
	PUSHJ	PP,CLSCRF	;[161]
	PUSHJ	PP,OUTCR
	HRRI	ER,0		;[161]
PAGE2:	TLO	IO,IOPAGE	;[161]
	POPJ	PP,		;[161]

LIT0:	PUSHJ	PP,BLOCK1
	PUSHJ	PP,STOUTS
LIT1:	JUMP2	LIT20

;ON PASS ONE, WE JUST STEP THE LOCATION COUNTER AND CLEAR

	MOVE	AC0,LITCNT
	MOVE	SX,LITHDX
	HRLM	AC0,0(SX)
	MOVE	V,LOCA
	HRL	V,MODA
	MOVEM	V,-1(SX)
	JRST	LIT24

LIT20:	PUSH	PP,LOCA
	PUSH	PP,LOCO
	SKIPN	LITNUM
	JRST	LIT20A
	MOVE	SX,LITHDX
	HRRZ	AC0,-1(SX)
	CAME	AC0,LOCA
	TRO	ER,ERRP
LIT20A:	MOVE	SX,LITAB
LIT21:	SOSGE	LITNUM
	JRST	LIT22
IFN FORMSW,<
	MOVE	AC0,-3(SX)
	MOVEM	AC0,FORM
>
	MOVE	AC0,-2(SX)	;WFW
	MOVE	RC,-1(SX)	;WFW
	MOVE	 SX,(SX)	;WFW POINTER TO THE NEXT LIT
	PUSHJ	PP,STOW20	;STOW CODE
	MOVEI	C,12		;SET LINE FEED
	IDPB	C,LBUFP
	PUSHJ	PP,OUTLIN	;OUTPUT THE LINE
	JRST	LIT21

LIT22:	HRRZ	AC2,LOCO
	POP	PP,LOCO
	POP	PP,LOCA
	MOVE	SX,LITHDX
	HLRZ	AC0,0(SX)
	SUB	AC2,LOCO	;COMPUTE LENGTH USED
	CAMGE	AC0,AC2		;USE LARGER
	MOVE	 AC0,AC2
	ADD	AC2,LOCO
LIT24:	ADDM	AC0,LOCA
	ADDM	AC0,LOCO
	PUSHJ	PP,GETTOP
	HRRM	SX,LITHDX
LITI:	SETZM	LITCNT
	SETZM	LITNUM
	MOVEI	LITAB
	MOVEM	LITABX
	JRST	HIGHQ

GETTOP:	HRRZ	AC1,SX		;VARHD
	HRRZ	SX,0(SX)
	JUMPN	SX,POPOUT
IFE FORMSW,<	MOVEI	SX,3	;WFW>
IFN FORMSW,<	MOVEI	SX,4	;ICC>
	ADDB	SX,FREE
	CAML	SX,SYMBOL
	PUSHJ	PP,XCEED
	SUBI	SX,1		;MAKE SX POINT TO LINK
	SETZM	0(SX)		;CLEAR FORWARD LINK
	HRRM	SX,0(AC1)	;STORE ADDRESS IN LAST LINK
	POPJ	PP,

VAR0:	PUSHJ	PP,BLOCK1	;PRINT LOCATION
	PUSHJ	PP,VARA
	JRST	STOUTS

VARA:	MOVE	SX,VARHDX
	MOVE	AC0,LOCA	;GET LOCATION FOR CHECK
	JUMP1	VARB		;DO NOT CHECK START ON PASS 1
	CAME	AC0,-1(SX)	;CHECK START OF VAR AREA
	TRO	ER,ERRP		;AND GIVE ERROR
VARB:	MOVEM	AC0,-1(SX)	;SAVE START FOR PASS 2
	HLRZ	AC0,0(SX)
	ADDM	AC0,LOCA
	ADDM	AC0,LOCO
	PUSHJ	PP,GETTOP
	HRRM	SX,VARHDX
	JUMP2	POPOUT

	PUSHJ	PP,LOOKUP	;SET FOR TABLE SCAN
	TRZN	ARG,VARF
	POPJ	PP,		;NO, EXIT
	TRZ	ARG,UNDF	;TURN OFF FLAG NOW
	MOVSI	AC0,1(V)	;NUMBER TO ADD TO
	ADDM	AC0,0(AC1)	;UPDATE COUNT
VARA1:	ADDI	V,1		;GET LENGTH OF DESIRED BLOCK
	ADDM	V,LOCO
	EXCH	V,LOCA
	ADDM	V,LOCA
	HRL	ARG,V		;GET STARTING LOCATION AND UPDAT PCS

	IOR	ARG,MODA	;SET TO ASSEMBLY MODE
	MOVSM	ARG,0(SX)	;UPDATE 2ND WRD OF SYM TAB ENTRY
	JRST	HIGHQ1

IF:	PUSH	PP,AC0		;SAVE AC0
	PUSH	PP,IO
	PUSHJ	PP,EVALXQ	;EVALUATE AND TEST EXTERNAL
	POP	PP,AC1
	IORI	ER,(AC1)	;[124] RESTORE PREVIOUS ERROR FLAGS
	JUMPL	AC1,IFPOP
	TLZ	IO,FLDSW
IFPOP:	POP	PP,AC1		;RETRIEVE SKIP INSTRUCTION
IFSET:	TLO	IO,IORPTC	;REPEAT CHARACTER
IFXCT:	XCT	AC1		;EXECUTE INSTRUCTION
IFXF:	TDZA	AC0,AC0		;FALSE
IFXT:	MOVEI	AC0,1		;TRUE
IFEXIT:	SETZM	EXTPNT		;JUST IN CASE
IFN POLISH,<
	TLZ	IO,RSASSW	;[265] ...
>
	JUMPOC	IFDO		;[140] BRANCH IF IN OP-CODE FIELD
IFEX1:	PUSHJ	PP,GETCHR	;SEARCH FOR "<"
	CAIN	C,EOL		;ERROR IF END OF LINE
	JRST	ERRAX
	CAIE	C,'<'
	JRST	IFEX1
	JUMPE	AC0,IFEX2	;TEST FOR 0
	TLO	IO,IORPTC	;NO, PROCESS AS CELL
	PUSHJ	PP,CELL
IFN FORMSW,<MOVE AC1,HWFORM	;USE STANDARD FORM>
	SETZM	INCND		;NOT ANY MORE
	JRST	STOW		;STOW CODE AND EXIT

IFDO:	BYPASS			;[140] GET NEXT NON-3LANK
	CAIN	C,EOL		;[272] AT EOL?
	JRST	 REPEA1		;[272] YES, USE OLD METHOD
	CAIE	C,','		;[260] ARE WE AT THE COMMA?
	CAIN	C,'<'		;[260] OR START OF CONDITIONAL?
	CAIA			;[260] YES
	JRST	IFDO		;[260] NOT YET AT COMMA OR ANGLE BRKT
	CAIN	C,','		;[260] IGNORE THE COMMA
	PUSHJ	PP,BYPAS1	;[140] AND GET SOMETHING ELSE
	TLO	IO,IORPTC	;[140] REPEAT LAST CHAR.
	CAIE	C,'<'		;[140] OLD METHOD USED ANGLES
	CAIN	C,EOL		;[140] ALSO OLD IF NEW LINE SEEN
	JRST	REPEA1		;[140] ASSEMBLE CODE BETWEEN ANGLES
	JUMPLE	AC0,REMAR0	;[140] FALSE, TREAT AS COMMENT
	JRST	STMNT		;[140] TRUE, ASSEMBLE IT

IFPASS:	HRRI	AC0,P1		;MAKE IT TLNX IO,P1
	MOVE	AC1,AC0		;PLACE IT IN AC1
	JRST	IFSET		;EXECUTE INSTRUCTION

IFB0:	HLLO	AC1,AC0		;FORM AND STORE TEST INSTRUCTION
IFB1:	PUSHJ	PP,CHARL	;GET FIRST NON-BLANK
	CAIE	C," "
	CAIN	C,"	"
	JRST	IFB1		;SKIP BLANKS AND TABS
	CAIG	C,CR		;CHECK FOR CARRET AS DELIM.
	CAIGE	C,LF
	CAIA
	JRST	ERRAX
	FORERR	(SX,CND)
	SETOM	INCND		;SAVE INFO. FOR PASS 1 ERRORS
	CAIN	C,"<"		;LEFT BRACKET?
	SETZB	C,RC		;YES, PREPARE FOR OLD FORMAT
	SKIPA	SX,C		;SAVE FOR COMPARISON
IFB3:	TRO	AC0,1		;SET FLAG
IFB2:	PUSHJ	PP,CHARL	;GET ASCII CHARACTER AND LIST
	CAMN	C,SX		;TEST FOR DELIMITER
	JRST	IFXCT		;FOUND
	CAIE	C," "		;BLANK?
	CAIN	C,"	"	;OR TAB?
	JRST	IFB2		;YES
	JUMPN	SX,IFB3		;JUMP IF NEW FORMAT
	CAIN	C,"<"		;<?
	AOJA	RC,IFB2		;YES, INCREMENT COUNT
	CAIN	C,">"		;>?
	SOJL	RC,IFXCT	;YES, DECREMENT AND EXIT IF DONE
	JRST	IFB3		;GET NEXT CHARACTER

IFDEF0:	HRRI	AC0,UNDF	;MAKE IT TLNX ARG,UNDF
	PUSH	PP,AC0		;STACK IT
	PUSHJ	PP,GETSYM	;TAKES SKIP RETURN IF SYM NAME IS LEGAL
	TROA	ER,ERRA		;ILLEGAL!
	PUSHJ	PP,SEARCH
	JRST	[PUSHJ	PP,OPTSCH
		TLO	ARG,UNDF
		JRST	.+1]
	PUSHJ	PP,SSRCH3	;EMIT TO CREF ANYWAY
	JRST	IFPOP		;POP AND EXECUTE INSTRUCTION


IFIDN0:	HLRZS	AC0
	MOVEI	V,2*.IFBLK-1
	SETZM	IFBLK(V)	;CLEAR COMPARISON BLOCK
	SOJGE	V,.-1
	SETZM	.TEMP		;CLEAR STORED DELIMETER
	MOVEI	RC,IFBLK	;SET FOR FIRST BLOCK
	PUSHJ	PP,IFCL		;GET FIRST STRING
	MOVEI	RC,IFBLKA
	PUSHJ	PP,IFCL		;GET SECOND STRING
	MOVEI	V,.IFBLK-1
	MOVE	SX,IFBLK(V)	;GET WORD FROM FIRST STRING
	CAMN	SX,IFBLKA(V)	;COMPARE WITH SECOND STRING
	SOJGE	V,.-2		;EQUAL, TRY NEXT WORD
	JUMPL	V,IFEXIT	;DID WE FINISH STRING
	XORI	AC0,1		;NO, TOGGLE REQUEST
	JRST	IFEXIT	;DO NOT TURN ON IORPTC WFW

IFCL:	PUSHJ	PP,CHARAC	;GET AND LIST CHARACTER
	CAIE	C," "		;SKIP SPACES
	CAIG	C,CR		;ALSO SKIP CR-LF
	CAIGE	C,HT		;AND TAB
	JRST	.+2		;NOT ONE OF THEM
	JRST	IFCL		;SO LONG COMPARISONS WILL WORK
;*** A CROCK SO THAT IFIDN <X>,<X>,<INST.> WILL WORK	***
	CAIE	C,","		;IS IT A COMMA?
	JRST	.+3		;NO
	SKIPN	.TEMP		;YES, WAS PREVIOUS FIELD OLD METHOD?
	JRST	IFCL		;YES, IGNORE COMMA AND SPACES
;	***
	CAIN	C,"<"		;WAS IT LEFT BRACKET?
	SETO	C,		;SIGNAL OLD METHOD, LOOK FOR RIGHT BRACKET
	MOVEM	C,.TEMP		;STORE TERMINATOR FOR COMPARISON
	MOVEI	SX,5*.IFBLK-1	;LIMIT SEARCH
	HRLI	RC,(POINT 7,,)	;SET UP BYTE IN RC
IFCLR:	PUSHJ	PP,CHARAC
	SKIPLE	.TEMP		;NEW METHOD?
	JRST	IFCLR1		;YES, IGNORE ANGLE BRACKET COUNTING
	CAIN	C,"<"		;ANOTHER LEFT ANGLE?
	SOS	.TEMP		;YES, KEEP COUNT
	CAIN	C,">"		;CLOSING ANGLE
	AOSGE	.TEMP		;MATCHING COUNT?
IFCLR1:	CAMN	C,.TEMP		;TEST FOR DELIMITER
	POPJ	PP,		;EXIT ON RIGHT DELIMITER
	SOJG	SX,.+2		;ANY ROOM IN COMPARISON BLOCK?
	TROA	ER,ERRA		;NO, FLAG ERROR BUT KEEP ON GOING
	IDPB	C,RC		;DEPOSIT BYTE
	JRST	IFCLR


IFEX2:	PUSHJ	PP,GETCHR
	CAIN	C,EOL		;EXIT WITH ERROR IF END OF LINE
	JRST	ERRAX
	CAIN	C,34		;"<"?
	AOJA	AC0,IFEX2	;YES, INCREMENT COUNT
	CAIE	C,36		;">"?
	JRST	IFEX2		;NO, TRY AGAIN
	SOJGE	AC0,IFEX2	;YES, TEST FOR MATCH
	BYPASS			;YES, MOVE TO NEXT DELIMITER
	SETZM	INCND		;OUT OF CONDITIONAL NOW
	AOJA	AC0,STOWZ1	;STOW ZERO


INTER0:	HLLZM	AC0,INTENT	;AC0 CONTAINS INTF/ENTF FLAGS

INTER1:	PUSHJ	PP,GETSYM	;GET A SYMBOL
	JRST	INTER3		;INVALID, SKIP
	PUSHJ	PP,SSRCH	;SEARCH THE TABLE
	  MOVSI	ARG,SYMF!INTF!UNDF
	PUSHJ	PP,SUPSYM	;[167] SEE IF "!" SEEN
	TLNN	ARG,UNDF	;ALLOW FORWARD REFERENCE
	TLNN	ARG,SYNF!EXTF
	TDOA	ARG,INTENT	;SET APPROPRIATE FLAGS
INTER3:	TROA	ER,ERRA		;FLAG ARG EROR AND SKIP
	PUSHJ	PP,INSERQ	;INSERT/UPDATE
	JUMPCM	INTER1
	SETZM	EXTPNT		;JUST IN CASE, SO AS NOT TO CONFUSE WORLD
IFN POLISH,<
	TLZ	IO,RSASSW	;[265] ...
>
	POPJ	PP,		;NO, EXIT

;.IF SYMBOL ATTRIBUTE

%IF:	PUSHJ	PP,GETSYM	;[271] GET THE SYMBOL
	  JRST	%IFNUMERIC	;[271] MIGHT WANT THIS ATTRIBUTE
	PUSHJ	PP,SEARCH	;[271] GENERAL SEARCH
	  JRST	IFXF		;[271] FAILED IF NOT IN TABLE
	TLO	IO,IORPTC	;[271] GET FIRST CHAR
	PUSHJ	PP,GETSYM	;[271] GET ATTRIBUTE
	  JRST	ERRAX		;[271] MUST BE A SYMBOL
	SETO	AC1,		;[271] MASK
IFLOOP:	MOVSI	AC2,-IFLEN	;[271] AOBJN PTR
	MOVE	SDEL,IFATAB(AC2);[271] GET NAME
	AND	SDEL,AC1	;[271] MASK
	CAMN	AC0,SDEL	;[271] MATCH
	JRST	IFOUND		;[271] GOT IT
	AOBJN	AC2,IFLOOP+1	;[271] LOOP
	JUMPGE	AC1,ERRAX	;[271] NOT IN TABLE
	TDNN	AC0,AC1		;[271] SET MASK
	JRST	IFLOOP		;[271] SET
	LSH	AC1,-6		;[271] TRY NEXT CHAR
	JUMPN	AC1,.-3		;[271] TRY AGAIN
	HALT			;[271] ?

IFOUND:	XCT	@IFJTAB(AC2)	;[271] MAKE TEST
	  JRST	IFXF		;[271] FALSE
	JRST	IFXT		;[271] TRUE

DEFINE IFATRIB <
XX	SYMBOL,<TLNN	ARG,SYMF>
XX	SYNONYM,<TLNN	ARG,SYNF>
XX	MACRO,<TLNN	ARG,MACF>
XX	OPDEF,<TLNN	ARG,OPDF>
XX	EXTERNAL
XX	ENTRY,<TLNN	ARG,ENTF>
XX	INTERNAL
XX	GLOBAL
XX	LOCAL
XX	LABEL,<TLNN	ARG,TAGF>
XX	ASSIGNMENT
XX	ABSOLUTE,<TLNE	ARG,LELF!RELF>
XX	RELOCATABLE,<TLNN	ARG,LELF!RELF>
XX	LRELOCATABLE,<TLNN	ARG,LELF>
XX	RRELOCATABLE,<TLNN	ARG,RELF>
XX	NUMERIC,JFCL
>

DEFINE XX (A,B)<
	<SIXBIT /A/>
>
IFATAB:	IFATRIB
IFLEN==.-IFATAB

DEFINE XX (A,B)<
 IFB <B>,<
	PUSHJ	PP,%IF'A
>
 IFNB <B>,<
	B
>>
IFJTAB:	IFATRIB

%IFEXTERNAL:
	TLNE	ARG,EXTF	;[271] ENTERNAL?
	AOS	(PP)		;[271] YES
	POPJ	PP,

%IFINTERNAL:
	TLNN	ARG,EXTF!SPTR	;[271] EXTERN?
	AOS	(PP)
	POPJ	PP,

%IFGLOBAL:
	TLNE	ARG,EXTF!INTF!ENTF
	AOS	(PP)
	POPJ	PP,

%IFLOCAL:
	TLNN	ARG,EXTF!SPTR
	AOS	(PP)
	POPJ	PP,

%IFASSIGNMENT:
	TLNE	ARG,SYMF
	TLNE	ARG,TAGF
	POPJ	PP,
	JRST	CPOPJ1

%IFNUMERIC:
	TLNE	IO,NUMSW	;[271] MUST BE NUMERIC
	PUSHJ	PP,GETSYM	;[271] GET ATTRIBUTE
	  JRST	ERRAX		;[271] ERROR
	SETO	AC1,		;[271] MASK
	TDNN	AC0,AC1		;[271] SET IT UP
	JRST	.+3		;[271] DONE
	LSH	AC1,-6
	JRST	.-3		;[271] TRY AGAIN
	MOVE	SDEL,['NUMERI']	;[271] ONLY VALID ONE
	AND	SDEL,AC1	;[271] MASK OUT ONES WE DON'T CARE ABOUT
	CAMN	AC0,SDEL	;[271] MATCH?
	AOS	(PP)		;[271] TRUE
	POPJ	PP,
;ASSIGN PSEUDO-OP FOR TENEX
;ASSIGN SYM1,SYM2,INCR

ASGN:	PUSHJ	PP,COUTD	;DUMP BUFFER
	PUSH	PP,BLKTYP	;SAVE BLOCK TYPE
	MOVEI	AC0,100		;ASSIGN BLOCK TYPE
	MOVEM	AC0,BLKTYP

	PUSHJ	PP,GETSYM	;HERE TO ASGN6 COPIED FROM EXTERN
	JRST	ASGN2
	TLO	IO,DEFCRS	;FLAG AS DEFINITION
	PUSHJ	PP,SSRCH
	JRST	ASGN1
	TLNN	ARG,EXTF!VARF!UNDF
	JRST	ASGN2
	TLNE	ARG,EXTF
	JRST	[JUMP1	ASGN6
		TLZN	ARG,UNDF
		JRST	ASGN6
		ANDM	ARG,(SX)
		JRST	ASGN1]
ASGN1:	MOVEI	V,2
	ADDB	V,FREE
	CAML	V,SYMBOL
	PUSHJ	PP,XCEEDS
	SUBI	V,2
	SETZB	RC,0(V)
	MOVSI	ARG,SYMF!EXTF
	PUSHJ	PP,INSERT
	MOVSI	ARG,PNTF
	IORM	ARG,0(SX)
	MOVE	AC0,-1(SX)
	MOVEM	AC0,1(V)
ASGN6:	MOVE	AC0,-1(SX)
	SETZ	ARG,
	PUSHJ	PP,SQOZE	;CONVERT TO SQUOZE
	PUSHJ	PP,COUT		;OUTPUT FIRST SYMBOL
	JUMPNC	ASGN2		;MUST BE COMMA HERE
	PUSHJ	PP,GETSYM	;SECOND SYMBOL
	JRST	ASGN2
	MOVEI	SDEL,%SYM	;OUTPUT	TO CREF
	PUSHJ	PP,CREF
	SETZ	ARG,
	PUSHJ	PP,SQOZE	;CONVERT TO SQUOZE
	PUSHJ	PP,COUT
	JUMPNC	ASGN3		;COMMA?
	PUSHJ	PP,EVALXQ	;YES, EVALUATE INCREMENT
ASGN4:	PUSHJ	PP,COUT
	JUMP1	ASGN7		;DON'T OUTPUT IF PASS1
	PUSHJ	PP,COUTD	;OUTPUT 3 WORDS
ASGN5:	POP	PP,BLKTYP	;RESTORE BLOCK TYPE
	POPJ	PP,

ASGN3:	MOVEI	AC0,1		;INCREMENT IS 1 IF NOT SPECIFIED
	JRST	ASGN4

ASGN2:	TRO	ER,ERRE		;INDICATE
ASGN7:	PUSHJ	PP,COUTI	;CLEAR OUTPUT BUFFER
	JRST	ASGN5

EXTER0:	PUSHJ	PP,GETSYM	;GET A SYMBOL
	JRST	EXTER4		;INVALID, ERROR
EXTER1:	TLO	IO,DEFCRS	;FLAG THIS AS A DEFINITION
EXTER5:	PUSHJ	PP,SSRCH	;[267] OK, SEARCH SYMBOL TABLE
	JRST	EXTER2		;NOT THERE, INSERT IT
	TLNN	ARG,EXTF!VARF!UNDF
	TROA	ER,ERRE		;FLAG ERROR AND BYPASS
	TLNE	ARG,EXTF	;VALID, ALREADY DEFINED?
	JRST	[JUMP1	EXTER3		;YES, BYPASS
		TLZN	ARG,UNDF	;SKIP IF UNDEFINED ALSO
		JRST	EXTER3		;CONTINUE
		ANDM	ARG,(SX)	;CLEAR UNDF ON PASS 2
		JRST	EXTER2]		;SET UP EXTERNAL NOW
EXTER2:	MOVEI	V,2		;NO, GET 2 CELLS FROM THE TREE
	ADDB	V,FREE
	CAML	V,SYMBOL	;HAVE WE RUN OUT OF CORE?
	PUSHJ	PP,XCEEDS	;YES, TRY TO BORROW SOME MORE
	SUBI	V,2		;GET RIGHT CELL FOR POINTER
	SETZB	RC,0(V)		;ALL SET, ZERO VALUES
	MOVSI	ARG,SYMF!EXTF
	PUSHJ	PP,SUPSYM	;[167] SEE IF "!" SEEN
	PUSHJ	PP,INSERT	;INSERT/UPDATE IT
	MOVSI	ARG,PNTF
	IORM	ARG,0(SX)
	SKIPA	ARG,-1(SX)	;GET THE SIXBIT FOR THE NAME
EXTER4:	TROA	ER,ERRA		;FLAG AS ERROR
	MOVEM	ARG,1(V)	;AND STORE IT FOR ADDITIVE GLOBAL FIXUPS
EXTER3:	PUSHJ	PP,SUPSYM	;[167] SEE IF "!" SEEN
	JUMPCM	EXTER0
	POPJ	PP,		;NO, EXIT

EVAL10:	PUSH	PP,RX
	HRRI	RX,^D10
	PUSHJ	PP,EVALEX	;EVALUATE
	POP	PP,RX		;RESET RADIX
	JUMPE	RC,POPOUT	;EXIT IF ABSOLUTE

QEXT:
IFN POLISH,<
	TLNE	FR,POLSW	;[164] ANY POLISH EXTERNAL EXPRESSIONS
	JRST	QPOL		;[164] YES, REMOVE  AND FLAG ERROR
>
	SKIPE	EXTPNT		;ANY POSSIBILITIES?
	TROA	ER,ERRE		;YES, FLAG EXTERNAL ERROR
	TRO	ER,ERRR		;NO, FLAG RELOCATION ERROR
	HLLZS	RC		;CLEAR RELOCATION/EXTERNAL
	POPJ	PP,

IFN POLISH,<
QPOL:	TRO	ER,ERRE		;[164] FLAG EXTERNAL ERROR
	PUSH	PP,AC1		;[164] GET AN AC
	MOVE	AC1,POLIST	;[164] GET LAST ITEM IN LIST
	MOVEM	AC1,FREE	;[164] RESET FREE CORE POINTER
	MOVE	AC1,(AC1)	;[164] GET PREVIOUS ITEM
	MOVEM	AC1,POLIST	;[164] MAKE IT TOP OF LIST
	POP	PP,AC1		;[164]
	POPJ	PP,		;[164]
>

EVALXQ:	PUSH	PP,IO		;[222] SAVE ERROR STATUS
	TRZ	ER,-1		;[222] START AFRESH
	PUSHJ	PP,EVALQ	;[222] EVALUATE EXPRESSION
	TRNE	ER,ERRU		;[222] TEST FOR UNDEF
	TRO	ER,ERRV		;[222] FLAG "V" ERROR
	HLLM	IO,(PP)		;[222] STORE STATUS FLAGS
	IORM	ER,(PP)		;[222] COMPOUND ERRORS
	POP	PP,IO		;[222] RESTORE THEM
	POPJ	PP,		;[222]

EVALQ:	PUSHJ	PP,EVALEX	;EVALUATE EXPRESSION
	TDZE	RC,[-2,,-2]	;WAS AN EXTERNAL FOUND?
	TRO	ER,ERRE		;YES, FLAG ERROR
	POPJ	PP,		;RETURN

OPDEF0:	PUSHJ	PP,GETSYM	;GET THE FIRST SYMBOL
	POPJ	PP,		;ERROR IF INVALID SYMBOL
	CAIE	C,73		;"["?
	JRST	ERRAX		;NO, ERROR
	PUSH	PP,AC0		;STACK MNEMONIC
	AOS	LITLVL		;SHORT OUT LOCATION INCREMENT
	PUSHJ	PP,STMNT	;EVALUATE STATEMENT
	SKIPGE	STPX		;CODE STORED?
	TROA	ER,ERRA		;NO,"A" ERROR
	PUSHJ	PP,DSTOW	;GET AND DECODE VALUE
	SOS	LITLVL
	EXCH	AC0,0(PP)	;EXCHANGE VALUE FOR MNEMONIC
	PUSH	PP,RC		;STACK RELOCATION
	TLO	IO,DEFCRS	;SAY WE ARE DEFINING IT
	PUSHJ	PP,MSRCH	;SEARCH SYMBOL TABLE
	MOVSI	ARG,OPDF	;NOT FOUND
	POP	PP,RC		;RESTORE VALUES
	POP	PP,V
	TLNE	ARG,SYNF!MACF
	TRO	ER,ERRA		;YES "A" ERROR
	TRNN	ER,ERRA		;ERROR?
	PUSHJ	PP,INSERT	;NO, INSERT/UPDATE
	PUSHJ	PP,ASSIG7	;[135] LIST VALUE LIKE =
	TLZ	IO,DEFCRS	;JUST IN CASE
	BYPASS
	JRST	STOWI		;BE SURE STOW IS RESET


DEPHA0:	MOVE	AC0,LOCO
	SKIPA	RC,MODO		;SET TO OUTPUT VALUES AND SKIP
PHASE0:	PUSHJ	PP,EVALXQ	;EVALUATE AND CHECK FOR EXTERNAL
	MOVEM	AC0,LOCA	;SET ASSEMBLY LOCATION COUNTER
	MOVEM	RC,MODA
	JRST	BLOCK2

ASSIGN:	JUMPAD	ERRAX		;NO, ERROR
	PUSHJ	PP,ASSIG1
	TLNE	IO,IOSALL	;SUPPRESS ALL?
	JUMPN	MRP,CPOPJ	;IF IN MACRO
ASSIG7:	MOVEM	RC,ASGBLK
	TRNE	RC,-2		;EXTERNAL
	HLLZS	ASGBLK		;YES,CLEAR RELOCATION
	TLNE	RC,1		;LEFT HALF NOT RELOC?
	TLNE	RC,-2		;...
	HRROS	ASGBLK		;YES, SET FLAG
	MOVEM	V,LOCBLK
	POPJ	PP,

ASSIG1:	PUSH	PP,AC0		;SAVE SYMBOL
	MOVEM	AC0,INASGN	;[164] INCASE POLISH FIXUP REQUIRED
	SETZB	AC0,EXTPNT	;SPECIAL CHECK FOR == WFW
ASSIG4:	PUSHJ	PP,PEEK		;IS THE NEXT ON =
	CAIE	C,"="
	CAIN	C,"!"
	TLOA	AC0,NOOUTF	;YES, NOT OUT TO DDT
	JRST	ASSIG5
	PUSHJ	PP,GETCHR	;PROCESS THE CHAR.
	PUSHJ	PP,PEEK		;CHECK FOR ==: DMN
ASSIG5:	CAIE	C,":"		;IS IT
	JRST	ASSIG6		;NO
	TLO	AC0,INTF	;MAKE INTERNAL
	PUSHJ	PP,GETCHR	;REPEAT IT
	JRST	ASSIG4		;TRY AGAIN (MIGHT BE =:!)

ASSIG6:	MOVEM	AC0,HDAS	;STORE THESE BITS WFW
	PUSHJ	PP,EVALCM	;EVALUATE EXPRESSION
	SETZM	INASGN		;[164] FINISHED WITH POLISH BY NOW
	EXCH	AC0,0(PP)	;SWAP VALUE FOR SYMBOL
	PUSH	PP,RC
	TRNN	RC,-2		;CHECK EXTERNAL AGREEMENT
	JRST	ASSIG2
	HRRZS	RC
	HRRZ	ARG,EXTPNT
	CAME	RC,ARG
	PUSHJ	PP,QEXT		;EXTERNAL OR RELOCATION ERROR
ASSIG2:	HLRZ	RC,(PP)
	TRNN	RC,-2
	JRST	ASSIG3
	HLRZ	ARG,EXTPNT
	CAME	RC,ARG
	PUSHJ	PP,QEXT
ASSIG3:	TLO	IO,DEFCRS
	PUSH	PP,UNISCH+1	;SAVE SEARCH LIST
	SETZM	UNISCH+1	;BUT DISALLOW
	PUSHJ	PP,SSRCH
	  MOVSI	ARG,SYMF
	POP	PP,UNISCH+1	;RESTORE STATUS
	IOR	ARG,HDAS	;WFW
	TLNE	ARG,UNDF	;WAS IT UNDEFINED
	TLZ	ARG,EXTF!PNTF	;YES,CLEAR EXTF NOW
	TLZ	ARG,UNDF!VARF	;CANCEL UNDEFINED AND VARIABLE FLAGS
	SETZM	EXTPNT		;FOR REST OF WORLD
IFN POLISH,<
	TLZ	IO,RSASSW	;[265] ...
>
	POP	PP,RC
	TRNE	ER,ERRORS-ERRQ
	SETZ	RC,		;CLEAR RELOCATION
	POP	PP,V
	TRNE	ER,ERRU		;WAS VALUE UNDEFINED?
	TLO	ARG,UNDF	;YES,SO TURN UNDF ON
	TLNE	ARG,TAGF!EXTF
	JRST	ERRAX
	JRST	INSERT

;LOC, RELOC, AND ORG COME HERE

%ORG:	PUSH	PP,AC0		;SAVE TYPE
	PUSHJ	PP,HIGHQ	;GET LATEST PC
	BYPASS			;SKIP BLANKS
	TLO	IO,IORPTC	;REPEAT LAST
	CAIN	C,EOL		;USE PREVIOUS VALUE IF NULL ARGUMENT
	JRST	ORG03
	PUSHJ	PP,EVALXQ	;GET EXPRESSION AND TEST EXTERNAL
	SKIPGE	(PP)		;ORG?
	HRLM	RC,(PP)		;YES, SAVE RELOC OF ARG
ORG01:	HRRM	AC0,(PP)	;STORE NEW VALUE
IFE POLISH,<
	HLRZ	AC1,(PP)	;GET MODE
	HRRZ	AC0,LOCO	;PC OF OUTPUT
	CAMN	AC1,MODO	;MODE SAME?
	JRST	[MOVEM AC0,@REL1P(AC1)	;SAVE NEW VALUE
		JRST	ORG02]
	MOVEM	AC0,@ABS1P(AC1)	;SAVE NEW VALUE
ORG02:	MOVE	AC0,MODO	;SAVE OLD MODE
	MOVEM	AC0,ORGMOD
>
IFN POLISH,<
	HRRZ	AC0,LOCO	;PC OF OUTPUT
	MOVE	AC1,MODO	;OLD MODE
	MOVEM	AC0,@REL1P(AC1)	;SAVE OLD VALUE
	MOVE	AC0,MODO	;SAVE OLD MODE
	MOVEM	AC0,ORGMOD
	MOVE	AC1,SGNCUR	;CURRENT PSECT INDEX
	MOVE	AC0,HIGH	;SAVE PSECT BREAK
	HRRM	AC0,SGATTR(AC1)
	HRR	AC0,RELLOC	;SAVE PSECT REL PC
	HRL	AC0,ORGMOD	;SAVE PSECT MODE
	MOVEM	AC0,SGRELC(AC1)
>
	POP	PP,AC0		;GET RESULT
ORG2A:	HLRZM	AC0,MODA	;SET MODES
	HLRZM	AC0,MODO
	HRRZM	AC0,LOCA	;AND LOCATIONS
	HRRZM	AC0,LOCO
	JRST	BLOCK2

ORG03:	HRRZ	AC0,ORGMOD	;GET PREV MODE
	SKIPGE	(PP)		;ORG?
	HRLM	AC0,(PP)	;YES, SAVE IT
	HLRZ	AC1,(PP)	;NEW MODE
	MOVE	AC0,@REL1P(AC1)	;GET PREV VALUE
	JRST	ORG01

REL1P:	EXP	ABSLOC
ABS1P:	EXP	RELLOC
	EXP	ABSLOC
;	.PSECT	NAME /ATTRIB,ORIGIN

IFN POLISH,<
%SEGME:	SKIPN	HISNSW		;CAN'T HAVE PSECTS WITH
	SKIPE	UNIVSN		; HISEG, TWOSEG OR
	JRST	ERRSX		; UNIVERSAL
	MOVE	AC2,SGDMAX	;CHECK IF MAX PSECT
	CAILE	AC2,SGNDEP-1	; NESTING DEPTH EXCEEDED
	JRST	ERRSX		;YES
	PUSHJ	PP,GETSYM	;GET PSECT NAME
	  PUSHJ	PP,[SETZ AC0,		;NONE SPECIFIED, BLANK NAME
		TRZ	ER,ERRA		;UNDO GETSYM'S ERR FLAG
		POPJ	PP,]
	MOVE	AC1,SGNMAX	;GET PSECT COUNT
%SEGM1:	CAMN	AC0,SGNAME(AC1)	;SEEN THIS NAME BEFORE?
	JRST	%SEGM2		;YES
	SOJGE	AC1,%SEGM1	;LOOP THRU KNOWN NAMES
	MOVE	AC1,SGNMAX	;CHECK IF MAX DISTINCT PSECT
	CAILE	AC1,SGNSGS-1	; LIMIT EXCEEDED
	JRST	ERRSX		;YES
	AOS	AC1,SGNMAX	;INCR PSECT COUNT
	MOVEM	AC0,SGNAME(AC1)	;STORE PSECT NAME
	MOVSI	AC2,1		;SET MODE TO RELOC
	MOVEM	AC2,SGRELC(AC1)	; AND PC TO ZERO
	HRRZS	SGORIG		;INCASE NOT GIVEN
%SEGM4:	MOVE	SDEL,SYMBOL	;ROOM TO INIT
	SUBI	SDEL,LENGTH	; SYM TAB
	CAMLE	SDEL,FREE	; FOR NEW PSECT?
	JRST	%SEGM3		;YES
	PUSHJ	PP,XCEEDS	;TRY FOR MORE CORE
	JRST	%SEGM4		;START OVER
%SEGM3:	MOVEM	SDEL,SYMBOL	;NEW SYM TAB BOT
	HRLI	SDEL,LENGTH(SDEL)	;OLD SYM TAB BOT
	MOVE	SX,SYMTOP	;SYM TAB TOP
	BLT	SDEL,-LENGTH(SX)	;MOVE SYM TAB DOWN
	HRLI	SDEL,SYMNUM+1	;PTR TO PERM SYM TAB
	HRRI	SDEL,1-LENGTH(SX)	;PERM SYMS GO HERE
	BLT	SDEL,0(SX)	;MOVE PERM SYMS TO NEW PSECT
	MOVE	AC2,SYMNUM	;PERM SYM CNT
	MOVEM	AC2,SGSCNT(AC1)	;SET SYM CNT
	SETZM	SGATTR(AC1)	;ZERO PSECT BRK AND ATTRS
	ADDM	AC2,@SYMBOL	;ADJUST TOTAL SYM CNT
%SEGM2:	AOS	AC2,SGDMAX	;INCR PSECT DEPTH
	MOVEM	AC0,SGLIST(AC2)	;STORE PSECT NAME
%SEGM5:	CAIE	C,'/'		;ATTRIBUTES SPECIFIED?
	JRST	%SEGM9		;NO, TRY VALUE
	PUSH	PP,AC1		;SAVE PSECT INX
	PUSHJ	PP,GETSYM	;GET ATTRIBUTE
	  JRST	%SEGM8		;TOO BAD
; THE BELOW ATTRIBUTES ARE PAIRED; A CONFLICT IS
; FLAGGED IF BOTH OF ANY PAIR ARE SEEN (CUMMULATIVELY)
	MOVE	AC1,AC0		;ATRIB NAME
	SETO	AC2,		;MASK
	LSH	AC1,6		;SHIFT UP 1 CHAR AT A TIME
	LSH	AC2,6		;SAME FOR MASK
	JUMPN	AC1,.-2		;UNTIL CHAR ALL GONE, MASK LEFT
	MOVSI	AC1,-%SGTLN	;AOBJN WORD
%SEGM6:	CAMN	AC0,%SGTBL(AC1)	;ATTRIBUTE FOUND?
	JRST	%SEGM7		;YES, PROCESS IT
	XOR	AC0,%SGTBL(AC1)	;BUT SEE IF WHAT WE HAVE MATCHES
	TDNN	AC0,AC2		;TRUE IF MASKED BITS ARE 0
	JRST	%SEGM7		;YES, IT MATCHES
	XOR	AC0,%SGTBL(AC1)	;PUT NAME BACK
	AOBJN	AC1,%SEGM6	;NO, CHECK NEXT
	SETZ	AC2,		;CLEAR ATTR FLAG
	TRO	ER,ERRQ		;FLAG WARNING
%SEGM7:	MOVEI	AC2,1		;SET ATRIB BIT
	LSH	AC2,-1(AC1)	; IN AC2
	MOVE	AC1,0(PP)	;GET PSECT INX
	HLRZ	AC0,SGATTR(AC1)	;GET PREV ATTRS
	ANDI	AC0,525252	;SELECT LEFT OPTIONS
	LSH	AC0,-1		;SHIFT THEM RIGHT
	AND	AC0,AC2		;COMPARE NEW AND PREVIOUS
	JUMPE	AC0,.+3		;CONFLICTING ATTRIBUTE?
	TRO	ER,ERRQ		;YES, FLAG WARNING
	SETZ	AC2,		; AND IGNORE IT
	HLRZ	AC0,SGATTR(AC1)	;GET PREV ATTRS
	ANDI	AC0,252525	;SELECT RIGHT OPTIONS
	LSH	AC0,1		;SHIFT THEM LEFT
	AND	AC0,AC2		;COMPARE NEW AND PREVIOUS
	JUMPE	AC0,.+3		;CONFLICTING ATTRIBUTE?
	TRO	ER,ERRQ		;YES, FLAG WARNING
	SETZ	AC2,		; AND IGNORE IT
	HRLZS	AC2		;MOVE TO LEFT HALF
	IORM	AC2,SGATTR(AC1)	;MERGE ATTRIBUTES
%SEGM8:	POP	PP,AC1		;RESTORE PSECT INX
	JUMPCM	%SEGM5		;LOOP IF MORE ATTRS
	JRST	%SWSEG		;SWAP PC AND MODE

%SEGM9:	JUMPNC	%SWSEG		;NO VALUE
	PUSH	PP,AC1		;SAVE INDEX
	PUSHJ	PP,EVALCM	;GET IT
	POP	PP,AC1		;RESTORE INDEX
	HRRM	AC0,SGORIG(AC1)	;STORE IT
	JRST	%SWSEG		;SWAP PC AND MODE

%SGTBL:	<SIXBIT /CONCATENATED/>
	<SIXBIT /OVERLAID/>
	<SIXBIT /RWRITE/>
	<SIXBIT /RONLY/>

%SGTLN==.-%SGTBL
%ENDSE:	SKIPN	HISNSW		;CAN'T HAVE PSECTS WITH
	SKIPE	UNIVSN		; HISEG, TWOSEG OR
	JRST	ERRSX		; UNIVERSAL
	MOVE	AC2,SGDMAX	;IF DEPTH IS ALREADY ZERO
	JUMPE	AC2,ERRSX	; THEN .ENDPS IS ILLEGAL
	PUSHJ	PP,GETSYM	;GET PSECT NAME
	JRST	%ENDS1		;NONE SPECIFIED, IGNORE CHECK
	CAME	AC0,SGLIST(AC2)	;DOES IT MATCH CORRES .PSECT NAME
	TRO	ER,ERRQ		;NO, FLAG WARN AND DO IT ANYWAY
%ENDS1:	TRZ	ER,ERRA		;UNDO GETSYM'S ERR FLAG
	SOS	AC2,SGDMAX	;DECR PSECT DEPTH
	MOVE	AC0,SGLIST(AC2)	;NAME OF PSECT TO RESUME
	MOVE	AC1,SGNMAX	;GET PSECT COUNT
	CAME	AC0,SGNAME(AC1)	;NAME MATCH?
	SOJGE	AC1,.-1		;NO, TRY NEXT

;HERE TO SWAP TO NEW PSECT
;ENTER WITH OLD PSECR IN SGNCUR
;NEW PSECT IN AC1
%SWSEG:	PUSH	PP,AC1		;SAVE NEW PSECT INX
	MOVE	AC2,SGNCUR	;GET OLD PSECT INX
	HLRZ	SDEL,SGORIG(AC2)	;ALREADY SETUP LIT/VAR BLOCK
	JUMPN	SDEL,%SWSG1	;YES
	MOVEI	SDEL,.SGLVL+1	;NO
	ADDB	SDEL,FREE	;TRY TO GET IT
	CAML	SDEL,SYMBOL	;WILL IT FIT?
	PUSHJ	PP,XCEED	;NO, XPAND
	SUBI	SDEL,.SGLVL+1	;GET ORIGIN
	HRLM	SDEL,SGORIG(AC2)	;NOW STORE IT
%SWSG1:	MOVSI	AC0,.SGLVZ	;START OF LIT/VAR AREA
	HRRI	AC0,1(SDEL)	;SAVE AREA
	BLT	AC0,.SGLVL(SDEL);STORE IT
	MOVE	AC0,LITLVL	;GET LITLVL
	MOVEM	AC0,(SDEL)	;STORE IT
	HLLZ	AC0,SGORIG(AC1)	;RESTORE NEW LIT/VAR
	JUMPE	AC0,[MOVE AC0,[.SGLVZ,,.SGLVZ+1]	;NOT YET SETUP
		SETZM	.SGLVZ		;CLEAR FIRST WORD
		BLT	AC0,.SGLVZ+.SGLVL	;PLUS REST
		MOVEI	AC0,VARHD	;SET UP AREA
		MOVEM	AC0,VARHDX
		MOVEI	AC0,LITHD
		MOVEM	AC0,LITHDX
		SETZM	LITLVL
		PUSHJ	PP,LITI
		JRST	%SWSG2]		;JOIN COMMON CODE
	AOBJP	AC0,.+1		;BYPASS FIRST WORD
	HRRI	AC0,.SGLVZ	;TO LIT/VAR AREA
	BLT	AC0,.SGLVZ+.SGLVL-1
	HLRZ	SDEL,SGORIG(AC1)	;POINTER TO LIT INFO
	MOVE	AC0,(SDEL)	;GET LITLVL
	MOVEM	AC0,LITLVL	;WE ARE NOW IN
	PUSHJ	PP,HIGHQ	;SET CURRENT PROG BRK
%SWSG2:	MOVE	AC0,SGRELC(AC1)	;GET OLD MODE AND PC
	PUSH	PP,AC0		;SAVE SAME
	HLRZ	RC,AC0		;GET OLD MODE
	SKIPN	RC		;IF ABS MODE
	MOVE	AC0,ABSLOC	; THEN GET ABS PC
	HRRM	AC0,(PP)	;STORE NEW VALUE
	HRRZ	AC0,LOCO	;PC OF OUTPUT
	MOVE	AC1,MODO	;OLD MODE
	MOVEM	AC0,@REL1P(AC1)	;SAVE OLD VALUE
	MOVE	AC0,MODO	;SAVE OLD MODE
	MOVEM	AC0,ORGMOD
	MOVE	AC1,SGNCUR	;CURRENT PSECT INDEX
	MOVE	AC0,HIGH	;SAVE PSECT BREAK
	HRRM	AC0,SGATTR(AC1)
	HRR	AC0,RELLOC	;SAVE PSECT REL PC
	HRL	AC0,ORGMOD	;SAVE PSECT MODE
	MOVEM	AC0,SGRELC(AC1)
	MOVE	AC0,-1(PP)	;GET NEW PSECT INX
	MOVEM	AC0,SGNCUR	;SET SGNCUR TO IT
	JUMP1	.+2		;IF PASS 2 THEN
	PUSHJ	PP,SGOUTN	; OUTPUT PSECT NAME BLOCK
	POP	PP,AC0		;GET RESULT
	HLRZM	AC0,MODA	;SET MODES
	HLRZM	AC0,MODO
	HRRZM	AC0,LOCA	;AND LOCATIONS
	HRRZM	AC0,LOCO
	POP	PP,SGNCUR	;STORE NEW PSECT INX
	MOVE	AC1,SGNCUR	;NEW PSECT INX
	HRRZ	AC0,SGATTR(AC1)	;GET PSECT BRK
	MOVEM	AC0,HIGH	;RESTORE IT
	PUSHJ	PP,SRCHI	;SET UP SRCHX
	POPJ	PP,		;DONE

ERRSX:	TRO	ER,ERRS		;FLAG PSECT USAGE ERROR
	POPJ	PP,		;DONE
>
HISEG1:
IFN POLISH,<
	SKIPE	SGNMAX		;IF PSECTS USED THEN CAN'T USE
	JRST	ERRSX		; HISEG OR TWOSEG
>
	PUSHJ	PP,HIGHQ	;SET CURRENT PROGRAM BREAK
	PUSHJ	PP,COUTD	;DUMP CURRENT TYPE OF BLOCK
	SKIPN	HISNSW		;IF WE HAVE SEEN IT BEFORE
	SKIPE	HIGH		;OR ANY RELOC CODE PUT OUT
	TRO	ER,ERRQ		;FLAG AS AN ERROR
	BYPASS			;GO GET EXPRESSION
	TLO	IO,IORPTC
	PUSHJ	PP,EVALXQ	;CHECK FOR EXTERNAL
	ANDCMI	AC0,1777	;ONLY ALLOWED TO START ON NEW K BOUND
	HRRZM	AC0,LOCA	;SET LOC COUNTERS
	HRRZM	AC0,LOCO
	MOVEI	RC,1		;ASSUME RELOCATABLE
	POPJ	PP,

TWSEG0:	PUSHJ	PP,HISEG1	;COMMON CODE
	JUMPN	AC0,.+2		;ARGUMENT SEEN
	MOVEI	AC0,400000	;ASSUME 400000
	HRRZM	AC0,HMIN	;SET OFSET OF HIGH SEG.
	HRRZM	AC0,HHIGH	;INCASE NO HISEG CODE
	TLOA	AC0,(1B0)	;SIGNAL TWO SEGMENTS AND SKIP

HISEG0:	PUSHJ	PP,HISEG1	;COMMON CODE
HISEG2:	MOVEM	AC0,SVTYP3	;SAVE THE HISEG ARG
	MOVEM	RC,MODA		;SET MODES
	MOVEM	RC,MODO
	SETOM	HISNSW		;WE HAVE ALREADY PUT ONE OUT
	JRST	BLOCK2		;MAKE LISTING HAPPEN RIGHT


IFN FORMSW,<
ONFORM:	HRRES	HWFMT		;ALLOW MULTI-FORMAT LISTING
	POPJ	PP,
OFFORM:	HRROS	HWFMT		;HALF-WORD FORMAT ONLY
	POPJ	PP,	>

IFE FORMSW,<
	SYN	CPOPJ,ONFORM
	SYN	CPOPJ,OFFORM>
HIGHQ:
HIGHQ1:	MOVE	V,LOCO	;GET ASSEMBLY LOCATION
	SKIPN	MODO		;IF ASSEMBLY MODE IS ABSOLUTE
	JRST	[CAMLE V,ABSHI		;RECORED ABS HIGHEST ALSO
		MOVEM V,ABSHI
		POPJ PP,]
	SKIPE	HMIN		;IS IT A TWO SEGMENT PROGRAM?
	JRST	[CAMGE	V,HMIN		;YES,IS THIS HIGH SEG.?
		JRST	.+1		;NO,STORE LOW SEGMENT
		CAMLE	V,HHIGH		;YES,IS IT GREATER THAN "HHIGH"?
		MOVEM	V,HHIGH		;YES,REPLACE WITH LARGER VALUE
		POPJ	PP,]
	CAMLE	V,HIGH		;IS IT GREATER THAN "HIGH"?
	MOVEM	V,HIGH		;YES, REPLACE WITH LARGER VALUE
	POPJ	PP,
	
ONML:	TLZA	FR,MWLFLG	;MULTI-WORD LITERALS OK
OFFML:	TLO	FR,MWLFLG	;NO
	POPJ PP,

OFFSYM:	SETOM	IONSYM	;SUPRESS SYMBOL TABLE LISTING
	POPJ	PP,

SUPRE0:	PUSHJ	PP,GETSYM	;GET A SYMBOL TO SUPRES
	JRST	SUPRE1		;ERROR
	PUSHJ	PP,SSRCH	;SYMBOL ONLY
	  JRST	SUPRE1		;GIVE ERROR MESSAGE
	PUSHJ	PP,SUPSYM	;[167] SEE IF "!" SEEN
	TLOA	ARG,SUPRBT	;SET THE SUPRESS BIT
SUPRE1:	TROA	ER,ERRA
	IORM	ARG,(SX)	;PUT BACK
	JUMPCM	SUPRE0		;ANY MORE?
	JRST	SUPRS1

SUPRSA:	PUSHJ	PP,LOOKUP	;SUPRESS ALL
	MOVSI	ARG,SUPRBT
	IORM	ARG,(SX)
SUPRS1:	SETZM	EXTPNT		;JUST IN CASE WE LOOKED ONE UP
IFN POLISH,<
	TLZ	IO,RSASSW	;[265] ...
>
	POPJ	PP,

XPUNG0:	JUMP1	POPOUT
	PUSHJ	PP,LOOKUP
	MOVE	ARG,(SX)	;GET SYMBOL FLAGS
	TLNN	ARG,INTF!ENTF!EXTF!SPTR
	TLOA	ARG,SUPRBT	;LOCAL SYMBOL,SO SUPPRESS IT
	SETZM	EXTPNT
IFN POLISH,<
	TLZ	IO,RSASSW	;[265] ...
>
	MOVEM	ARG,(SX)	;RESTORE FLAGS
	POPJ	PP,

NODDT0:	PUSHJ	PP,GETSYM	;GET A SYMBOL TO SUPRES
	  JRST	NODDT1		;ERROR
	PUSHJ	PP,SSRCH	;SYMBOL ONLY
	  JRST	NODDT1		;GIVE ERROR MESSAGE
	PUSHJ	PP,SUPSYM	;SEE IF "!" SEEN
	TLOA	ARG,NOOUTF	;SET THE NO-DDT BIT
NODDT1:	TROA	ER,ERRA
	IORM	ARG,(SX)	;PUT BACK
	JUMPCM	NODDT0		;ANY MORE?
	JRST	SUPRS1


SUPSYM:	CAIE	C,"!"		;[167] WANT NO DDT OUTPUT FOR THIS SYMBOL?
	POPJ	PP,		;[167] NO
	TLO	ARG,NOOUTF	;[167] YES, SET FLAG
	PJRST	BYPAS1		;[167] SKIP "!" AND RETURN
;[220] .CREF SYMBOL,SYMBOL,ETC
ONCRF:	PUSHJ	PP,GETSYM	;SEE IF A SYMBOL SPECIFIED
	  JRST	[MOVSI	AC0,IONCRF	;NO, PUT FLAG BACK
		TRZ	ER,ERRA		;CLEAR "A" ERROR
		TLZ	IO,DEFCRS	;CLEAR ANY WAITING DEFINING OCCURENCES
		JRST	IORSET]
ONCRF0:	PUSHJ	PP,MSRCH	;TRY FOR MACRO/OPDEF
	  CAIA			;FAILED
	JRST	.+3		;FOUND IT
	PUSHJ	PP,SSRCH	;TRY SYMBOLS
	  JRST	ONCRFE		;ERROR
	TLZA	ARG,NCRF	;TURN OFF NO CREF FLAG
ONCRFE:	TROA	ER,ERRA		;SET ERROR CONDITION
	ANDM	ARG,(SX)	;PUT FLAGS BACK
	JUMPNC	SUPRS1		;GIVE UP IF NO MORE
	PUSHJ	PP,GETSYM	;GET NEXT SYMBOL
	  JRST	ONCRFE		;ERROR
	JRST	ONCRF0

;[220] .XCREF SYMBOL,SYMBOL,ETC
OFFCRF:	PUSHJ	PP,GETSYM	;SEE IF A SYMBOL SPECIFIED
	  JRST	[MOVSI	AC0,IONCRF	;PUT FLAG BACK
		TRZ	ER,ERRA		;CLEAR "A" ERROR
		JRST	IOSET]
OFCRF0:	PUSHJ	PP,MSRCH	;TRY FOR MACRO/OPDEF
	  CAIA			;FAILED
	JRST	.+3		;FOUND IT
	PUSHJ	PP,SSRCH	;TRY SYMBOL
	  JRST	OFCRFE		;ERROR
	TLOA	ARG,NCRF	;SET BIT
OFCRFE:	TROA	ER,ERRA		;FLAG ERROR
	IORM	ARG,(SX)	;PUT BACK
	JUMPNC	SUPRS1		;GIVE UP IF NO MORE SYMBOLS
	PUSHJ	PP,GETSYM	;GET NEXT SYMBOL
	  JRST	OFCRFE		;ERROR
	JRST	OFCRF0
TITLE0:	JUMP2	REMAR0
	SKIPE	TBUF+1		;IS THIS THE FIRST TITLE?
	JRST	[TRO	ER,ERRM		;NO, FLAG AS ERROR
		JRST	REMAR0]		;AND IGNORE
	MOVEI	SX,.TBUF
	HRRI	AC0,TBUF
	PUSHJ	PP,SUBTT1	;GO READ IT
	MOVEM	SX,TCNT		;SAVE COUNT OF CHARS. WRITTEN
	SKIPE	UNIVSN		;WAS IT A UNIVERSAL?
	PUSHJ	PP,ADDUNV	;YES  ADD TO TABLE
	SKIPN	TBUF+1		;2ND WORD NON-ZERO SIGNALS TITLE SEEN
	AOS	TBUF+1		;MAKE IT SO
IFN CCLSW,<JRST	PRNAM		;PRINT NAME IF FIRST ONE>
IFE CCLSW,<POPJ	PP,		;EXIT OTHERWISE>

SUBTT0:	SKIPE	SBUF		;STORE FIRST SUBTTL ON PASS1
	JUMP1	REMAR0		;OTHERWISE EXIT IF PASS ONE
	MOVEI	SX,.SBUF
	HRRI	AC0,SBUF

SUBTT1:	BYPASS			;BYPASS LEADING BLANKS
	TLO	IO,IORPTC
SUBTT3:	PUSHJ	PP,CHARAC	;GET ASCII CHARACTER
	IDPB	C,AC0		;STORE IN BLOCK
	CAIGE	C,40		;TEST FOR TERMINATOR
	CAIN	C,HT
	SOJG	SX,SUBTT3	;TEST FOR BUFFER FULL
	DPB	RC,AC0		;END, STORE TERMINATOR
	SOJA	SX,REMAR1	;COUNT NULL AND EAT UP ANY REMAINING CHARS.

IFN CCLSW,<
PRNAM:	TLNN	IO,CRPGSW	;NOT IF NOT RPG
	POPJ	PP,
	PUSH	PP,AC0		;SAVE AC0 DMN
	PUSH	PP,RC		;AND RC
	MOVE	AC0,[POINT 7,TBUF]
	MOVE	SX,[POINT 7,OTBUF]
	MOVEI	RC,6		;MAX OF SIX CHRS
	MOVEI	C,HT		;START WITH A TAB
	IDPB	C,SX
PN1:	ILDB	C,AC0
	CAILE	C," "		;CHECK FOR LEGAL
	CAILE	C,"Z"+40	;CHECK AGAINST LOWER CASE Z
	JRST	PN2
	IDPB	C,SX		;PUT IN OUTPUT BUFFER
	SOJG	RC,PN1		;GET MORE
PN2:	MOVEI	C,CR		;END WITH CR-LF
	IDPB	C,SX
	MOVEI	C,LF
	IDPB	C,SX
	SETZ	C,		;TERMINATOR
	IDPB	C,SX
	TTCALL	3,OTBUF
	POP	PP,RC
	POP	PP,AC0		;RESTORE AC0 DMN
	POPJ	PP,
>

SYN0:	PUSHJ	PP,GETSYM	;GET THE FIRST SYMBOL
	  JRST	ERRAX		;ERROR, EXIT
	PUSHJ	PP,MSRCH	;TRY FOR MACRO/OPDEF
	  JRST	SYN3		;NO, TRY FOR OPERAND
SYN1:	MOVEI	SX,MSRCH	;YES, SET FLAG
SYN2:	JUMPNC	ERRAX		;[173] ERROR IF NO COMMA
	PUSH	PP,ARG		;[173] SAVE SOME REGISTERS
	PUSH	PP,RC		;[173]
	PUSH	PP,V		;[173]
	PUSH	PP,SX		;[173] SAVE SEARCH ROUTINE
	PUSHJ	PP,GETSYM	;[173] GET THE SECOND SYMBOL
	  JRST	[SUB	PP,[4,,4]	;[173] PUT STACK BACK
		POPJ	PP,]		;[173] AND GIVE UP
	POP	PP,SX		;[173] RESTORE SEARCH ROUTINE
	PUSHJ	PP,@SX		;[173] SEARCH FOR SECOND SYMBOL
	  JFCL			;[173]
	POP	PP,V		;[173] RESTORE VALUES
	POP	PP,RC		;[173]
	POP	PP,ARG		;[173]
	TLNE	ARG,MACF	;MACRO?
	PUSHJ	PP,REFINC	;YES, INCREMENT REFERENCE
	JRST	INSERT		;INSERT AND EXIT

SYN3:	PUSHJ	PP,SSRCH	;SEARCH FOR OPERAND
	  JRST	SYN4		;NOT FOUND, TRY OP CODE
	TLO	ARG,SYNF	;FLAG AS SYNONYM
	TLNE	ARG,EXTF	;EXTERNAL?
	HRRZ	V,ARG		;YES, RELPACE WITH POINTER
	MOVEI	SX,SSRCH	;SET FLAG
	TLNN	ARG,VARF	;DO NOT LET HIM SYN A VARIABLE
	JRST	SYN2
	JRST	ERRAX

SYN4:	PUSHJ	PP,OPTSCH	;SEARCH FOR OP-CODE
	  JRST	ERRAX		;NOT FOUND, EXIT WITH ERROR
	MOVSI	ARG,SYNF	;FLAG AS SYNONYM
	JRST	SYN1

PURGE0:	PUSHJ	PP,GETSYM	;GET A MNEMONIC
	  JRST	[TRZ ER,ERRA		;CLEAR ERROR
		POPJ	PP,]		;AND RETURN
	PUSHJ	PP,MSRCH	;SEARCH MACRO SYMBOL TABLE
	  JRST	PURGE2		;NOT FOUND, TRY SYMBOLS
	PUSH	PP,CS		;SAVE CS AS IT MAY GET GARBAGED
	TLNE	ARG,MACF	;MACRO?
	PUSHJ	PP,REFDEC	;YES, DECREMENT THE REFERENCE
	POP	PP,CS
	JRST	PURGE4		;REMOVE SYMBOL FROM TABLE

PURGE2:	PUSHJ	PP,SSRCH	;TRY OPERAND SYMBOL TABLE
	  JRST	PURGE5		;NOT FOUND GET NEXT SYMBOL
	TDNE	RC,[-2,,-2]	;CHECK COMPLEX EXTERNAL
	TLNE	ARG,SYNF
	JRST	.+2
	JRST	PURGE3
	TLNE	ARG,EXTF!UNDF	;ERROR IF EXTERNAL OR UNDEFINED
	TLNE	ARG,SYNF	;BUT NOT A SYNONYM
	JRST	PURGE4
PURGE3:	TROA	ER,ERRA		;NOT FOUND, ERROR
PURGE4:	PUSHJ	PP,REMOVE	;REMOVE FROM THE SYMBOL TABLE
PURGE5:	JUMPCM	PURGE0
	POPJ	PP,		;EXIT

OPD1:	TLNE	ARG,UNDF	;IF OPDEF IS UNDEFINED
	TRO	ER,ERRO		;GIVE "O" ERROR
OPD:	MOVE	AC0,V		;PUT VALUE IN AC0
	JRST	OP
IOP:	MOVSI	AC2,(POINT 9,0(PP),11)
IFE FORMSW,<	TLOA	IO,IOIOPF	;SET "IOP SEEN" AND SKIP>
IFN FORMSW,<	PUSH	PP,IOFORM	;USE I/O FORM
	SETOM	IOSEEN		;[116] SIGNAL  FOR BOUT TO ADJUST FIELDS
	TLO	IO,IOIOPF	;SET "IOP" SEEN
	JRST	OP+2>
OP:	MOVSI	AC2,(POINT 4,0(PP),12)
IFN FORMSW,<	PUSH	PP,INFORM	;USE INST. FORM>
	PUSH	PP,RC
	PUSH	PP,AC0		;STACK CODE 
	PUSH	PP,AC2
	PUSHJ	PP,EVALEX	;EVALUATE FIRST EXPRESSION
	POP	PP,AC2
	JUMPNC	OP2
OP1B:	PUSHJ	PP,GETCHR	;GET A CHARACTER
IFE FORMSW,<JUMPCM XWD5		;PROCESS COMMA COMMA IN XWD>
IFN FORMSW,<JUMPNC .+4		;JUMP IF NO COMMA
	MOVE	AC2,HWFORM	;GET FORM WORD FOR XWD
	MOVEM	AC2,-2(PP)	;REPLACE INSTRUCTION FORM
	JRST	XWD5		;PROCESS COMMA COMMA IN XWD>
	TLO	IO,IORPTC	;NOT A COMMA,REPEAT IT
	LDB	AC1,AC2
	ADD	AC1,AC0
	DPB	AC1,AC2
IFN POLISH,<
	TLNN	FR,POLSW	;[164] DON'T ALLOW EXTERNAL ACS
>
	JUMPE	RC,OP1A		;EXTERNAL OR RELOCATABLE?
	PUSHJ	PP,QEXT		;YES, DETERMINE WHICH AND FLAG AN ERROR

OP1A:	PUSHJ	PP,EVALEX	;GET ADDRESS PART
OP2:	PUSHJ	PP,EVADR	;EVALUATE STANDARD ADDRESS
OP3:	POP	PP,AC0		;PUT IN AC0
	POP	PP,RC
IFN FORMSW,<	POP	PP,AC1	;GET FORM WORD>
	SKIPE	(PP)		;CAME FROM EVALCM?
	JRST	STOW		;NO,STOW CODE AND EXIT
	POP	PP,AC1		;YES,EXIT IMMEDIATELY
	POPJ	PP,


EVADR:				;EVALUATE STANDARD ADDRESS
IFE IIISW,<TLNN	AC0,-1		;OK IF ALL 0'S
	JRST	.+4		;IT WAS
	TLC	AC0,-1		;CHANGE ALL ONES TO ZEROS
	TLCE	AC0,-1		;OK IF ALL 1'S
	TRO	ER,ERRQ		;NO,FLAG Q ERROR>
	ADD	AC0,-1(PP)	;ADD ADDRESS PORTIONS
	HLL	AC0,-1(PP)	;GET LEFT HALF
	TLZE	FR,INDSW	;INDIRECT BIT?
	TLO	AC0,(Z @)	;YES, PUT IT IN
	MOVEM	AC0,-1(PP)	;RE-STACK CODE
	ADD	RC,-2(PP)	;UPDATE RELOCATION
	HRRM	RC,-2(PP)	;USE HALF WORD ADD
	CAIE	C,10		;"("?
	POPJ	PP,		;NO, EXIT

	MOVSS	EXTPNT		;WFW
	PUSHJ	PP,EVALCM	;EVALUATE
	MOVSS	EXTPNT		;WFW
	MOVSS	V,AC0		;SWAP HALVES
IFE IIISW,<MOVSS SX,RC
	IOR	SX,V		;MERGE RELOCATION
	TRNN	SX,-1		;RIGHT HALF ZERO?
	JRST	OP2A		;YES, DO SIMPLE ADD
	MOVE	ARG,RC		;NO, SWAP RC INTO ARG>
IFN IIISW,<MOVSS ARG,RC>
	ADD	V,-1(PP)	;ADD RIGHT HALVES
	ADD	ARG,-2(PP)
	HRRM	V,-1(PP)	;UPDATE WITHOUT CARRY
	HRRM	ARG,-2(PP)
	HLLZS	AC0		;PREPARE LEFT HALVES
	HLLZS	RC
IFE IIISW,<TLNE	SX,-1		;IS LEFT HALF ZERO?
	TRO	ER,ERRQ		;NO FLAG FORMAT ERROR
OP2A:	TLNE	RC,-1		;RELOCATION FOR LEFT HALF?
	PUSHJ	PP,OP2A1	;YES,IS IT LEGAL?
	TLNE	AC0,777000	;OP CODE FIELD USED?
	JRST	[EXCH AC0,-1(PP)	;YES, GET STORED CODE
		TLNE AC0,777000		;OP CODE FIELD BEEN SET?
		TRO ER,ERRQ		;YES, MOST LIKELY AN ERROR
		EXCH AC0,-1(PP)
		JRST	.+1]		;RETURN TO ADD >
	ADDM	AC0,-1(PP)	;MERGE WITH PREVIOUS VALUE
	ADDM	RC,-2(PP)
	CAIE	C,11		;")"?
	JRST	ERRAX		;NO, FLAG ERROR
				;YES, BYPASS PARENTHESIS
BYPAS1:	PUSHJ	PP,GETCHR
BYPAS2:	JUMPE	C,.-1		;SKIP TRAILING BLANKS
	POPJ	PP,		;EXIT

IFE IIISW,<
OP2A1:	EXCH	RC,-2(PP)	;GET STORED CODE
	TLNN	RC,-1		;OK IF ALL ZERO
	JRST	OP2A2		;OK SO RETURN
	TLC	RC,-1		;CHANGE ALL ONES TO ZEROS
	TLCE	RC,-1		;OK IF ALL ONES
	TRO	ER,ERRQ		;OTHERWISE A "Q" ERROR
OP2A2:	EXCH	RC,-2(PP)	;GET RC,BACK
	POPJ	PP,		;AND RETURN>


EXPRES:	HRLZ	AC0,RX		;FUDGE FOR OCT0

OCT0:	PUSH	PP,RX
	HLR	RX,AC0
IFN POLISH,<
	MOVNI	AC0,3		;[164] PRESET POLISH TYPE SINCE WE
	MOVEM	AC0,POLTYP	;[164] NEED FULL WORD FIXUPS IF POLISH
>
OCT1:	PUSHJ	PP,EVALEX	;EVALUATE
IFN POLISH,<
	TDNE	RC,[-2,,-2]	;[164] TEST FOR EXTERNAL
	PUSHJ	PP,OCTFW	;[164] YES, NEEDS FULL WORD FIXUP
>
IFN FORMSW,<	MOVE	AC1,HWFORM>
	PUSHJ	PP,STOW		;STOW CODE
	JUMPCM	OCT1
	POP	PP,RX		;YES, RESTORE RADIX
IFN POLISH,<
	SETZM	POLTYP		;[164] CLEAR FLAG
>
	POPJ	PP,		;EXIT

IFN POLISH,<
;HERE TO GENERATE FULL WORD FIXUPS FOR EXP EXTERN
;NOTE THIS GENERATES BLOCK TYPE 11 POLISH FIXUPS
;THESE CANNOT BE LOADER BY LOADER UNLESS FAILSW IS ON

OCTFW:	MOVE	PV,FREE		;[164] COPY CODE FROM POLPOP
	EXCH	PV,POLIST	;[164] TO SET UP A NEW BLOCK
	PUSHJ	PP,POLSTR	;[164] STORE POINTER TO LAST
	MOVE	PV,EXTPNT	;[164] GET POINTER TO EXTERNAL SYMBOL
	PUSHJ	PP,POLFS2	;[164] STORE EXTERNAL
	JRST	POLOCT		;[164] AND FIXUP ADDRESS, AND RETURN
>

SIXB10:	MOVSI	RC,(POINT 6,AC0)	;SET UP POINTER
	MOVEI	AC0,0		;CLEAR WORD

SIXB20:	PUSHJ	PP,CHARL	;GET NEXT CHARACTER
	CAMN	C,SX		;IS THIS PRESET DELIMITER?
IFE FORMSW,<	JRST	ASC60		;YES>
IFN FORMSW,<
	JRST	[PUSHJ	PP,BYPAS1
		ANDCM	RC,STPX
		MOVE	AC1,SXFORM
		JUMPGE	RC,STOWZ
		POPJ	PP,]>
	CAIL	C,"A"+40
	CAILE	C,"Z"+40
	JRST	.+2
	TRZA	C,100		;CONVERT LOWER CASE TO SIXBIT
	SUBI	C,40		;CONVERT TO SIXBIT
	JUMPL	C,ASC55		;TEST FOR INVALID CHARACTER
	IDPB	C,RC		;NO, DEPOSIT THE BYTE
	TLNE	RC,770000	;IS THE WORD FULL?
	JRST	SIXB20		;NO, GET NEXT CHARACTER
IFN FORMSW,<	MOVE	AC1,SXFORM	;SIXBIT FORM>
	PUSHJ	PP,STOWZ	;YES, STORE
	JRST	SIXB10		;GET NEXT WORD

%TEXT1:	TLC	AC0,240000	;[232] CONVERT .TEXT TO COMMENT ON PASS1
ASCII0:	HLLZ	SDEL,AC0	;STORE ASCII/ASCIZ FLAG
ASC10:	PUSHJ	PP,CHARL	;GET FIRST NON-BLANK
	CAIE	C," "
	CAIN	C,HT
	JRST	ASC10
	CAIG	C,CR		;CHECK FOR CRRET AS DELIM
	CAIGE	C,LF
	CAIA
	JRST	ERRAX
	FORERR	(SX,TXT)
	SETOM	INTXT
	MOVE	SX,C		;SAVE FOR COMPARISON
	JUMPG	SDEL,SIXB10	;BRANCH IF SIXBIT

ASC20:	MOVSI	RC,(POINT 7,AC0)	;SET UP POINTER
	TLNE	SDEL,200000	;THIS BIT (AND BIT0) IN FOR COMMENT
	MOVSI	RC,440000	;SO NOTHING WILL BE DEPOSITED
IFE IIISW,<MOVEI AC0,0		;CLEAR WORD>
IFN IIISW,<TLNE	SDEL,100000	;ASCID?
	TLZA	SDEL,400000	;YES, ZERO ASCIZ BIT
	TDZA	AC0,AC0		;NO, ZERO WORD
	MOVE	AC0,[BYTE (7) 10,10,10,10,10 (1) 1]	;YES, A WORD FULL OF BACKSPACES>
ASC30:	PUSHJ	PP,CHARL	;GET ASCII CHARACTER AND LIST
	CAMN	C,SX		;TEST FOR DELIMITER
	JRST	ASC50		;FOUND
	IDPB	C,RC		;DEPOSIT BYTE
	TLNE	RC,760000	;HAVE WE FINISHED WORD?
	JRST	ASC30		;NO,GET NEXT CHARACTER
IFN FORMSW,<	MOVE	AC1,ASCIIF	;USE ASCII FORM WORD>
	TLNE	SDEL,040000	;.TEXT ?
	JRST	[PUSHJ	PP,STOTXT	;YES, STORE IN REL FILE
		JRST	ASC20]		;CONTINUE
	PUSHJ	PP,STOWZ	;YES, STOW IT
	JRST	ASC20		;GET NEXT WORD

ASC55:	TDZA	CS,CS		;ZERO CS IN CASE NESTED
ASC50:	TDZA	RC,SDEL		;TEST FOR ASCIIZ
	TROA	ER,ERRA		;SIXBIT ERROR EXIT
ASC60:	PUSHJ	PP,BYPAS1	;POLISH OFF TERMINATOR
	SETZM	INTXT		;WE ARE OUT OF IT
IFN FORMSW,<	MOVE	AC1,ASCIIF	;USE ASCII FORM WORD>
IFN IIISW,<TLNN	SDEL,100000	;NO EXTRA WORDS FOR ASCID>
	ANDCM	RC,STPX		;STORE AT LEAST ONE WORD
	TLNN	SDEL,200000	;GET OUT WITHOUT STORING
	JUMPGE	RC,[TLNN SDEL,040000	;.TEXT?
		JRST	STOWZ		;NO, STOW
		JRST	STOTXT]		;YES, STORE IN REL FILE
	POPJ	PP,		;ASCII, NO BYTES STORED, SO EXIT

;[232] .TEXT PSEUDO-OP

%TEXT0:	JUMP1	%TEXT1		;IGNORE ON PASS1
	PUSH	PP,BLKTYP	;SAVE CURRENT TYPE
	HLLZ	SDEL,AC0	;FLAG BITS FOR ASCII
	PUSHJ	PP,COUTD	;DUMP CURRENT BLOCK
	SETZM	BLKTYP		;DON'T KNOW IT YET
	PUSHJ	PP,ASC10	;START PROCESSING
	PUSHJ	PP,STOTXD	;FINISH BLOCK
	POP	PP,BLKTYP	;RESTORE PREVIOUS
	POPJ	PP,

STOTXT:	SKIPN	BLKTYP		;FIRST WORD?
	JRST	[MOVEM	AC0,BLKTYP
		POPJ	PP,]	;SAVE AS BLOCK TYPE
	SKIPN	COUTRB		;2ND WORD
	JRST	[MOVEM	AC0,COUTRB
		POPJ	PP,]
	AOS	C,COUTX		;NO, JUST STORE AS NORMAL
	MOVEM	AC0,COUTDB(C)
	CAIE	C,^D17		;BUFFER FULL?
	POPJ	PP,		;NO

STOTXD:	AOSG	COUTX		;DUMP THE BUFFER
	JRST	COUTI		;IT WAS EMPTY
	MOVE	C,BLKTYP	;GET FIRST WORD
	JRST	COUTT		;DUMP BLOCK
POINT0:
IFN FORMSW,<	PUSH	PP,BPFORM	;USE BYTE POINTER FORM WORD>
	PUSH	PP,RC		;STACK REGISTERS
	PUSH	PP,AC0
	PUSHJ	PP,EVAL10	;EVALUATE RADIX 10
	DPB	AC0,[POINT 6,0(PP),11]	;STORE BYTE SIZE
	JUMPNC	POINT2
IFN POLISH,<
	SETOM	POLTYP		;[164] FORCE RIGHT-HALF FIXUP IF POLISH
>
	PUSHJ	PP,EVALEX	;NO, GET ADDRESS
	PUSHJ	PP,EVADR	;EVALUATE STANDARD ADDRESS
IFN POLISH,<
	SETZM	POLTYP		;[164] BACK TO NORMAL
>
	JUMPNC	POINT2
	PUSHJ	PP,EVAL10	;EVALUATE RADIX 10
	TLNE	IO,NUMSW	;IF NUMERIC
	TDCA	AC0,[-1]	;POSITION=D35-RHB
POINT2:	MOVEI	AC0,0		;OTHERWISE SET TO D36
	ADDI	AC0,^D36
	LSH	AC0,^D30
	ADDM	AC0,0(PP)	;UPDATE VALUE
	JRST	OP3

XWD0:
IFN FORMSW,<	PUSH	PP,HWFORM	;USE HALF WORD FORM>
	PUSH	PP,RC
	PUSH	PP,AC0		;STORE ZERO ON STACK
	PUSHJ	PP,EVALEX	;EVALUATE EXPRESSION
	JUMPNC	OP2
XWD5:	SKIPN	(PP)		;ANY CODE YET?
	JRST	XWD10		;NO,USE VALUE IN AC0
	JUMPE	AC0,.+2		;ANYTHING IN AC0?
	TRO	ER,ERRQ		;YES,FLAG "Q"ERROR
	MOVE	AC0,(PP)	;USE PREVIOUS VALUE
	MOVE	RC,-1(PP)	;AND RELOCATION
XWD10:	TLNN	AC0,-1		;[143] LEFT HALF SHOULD BE ZERO
	JRST	XWD11		;[143] IT IS
	TLC	AC0,-1		;[143] OR AT LEST ALL ONES
	TLCE	AC0,-1		;[143] FOR XWD -1,-2 ETC
	TRO	ER,ERRQ		;[143] NO, WARN USER
XWD11:	HRLZM	AC0,0(PP)	;SET LEFT HALF
	HRLZM	RC,-1(PP)
	MOVSS	EXTPNT		;WFW
	JRST	OP1A		;EXIT THROUGH OP

IOWD0:	PUSHJ	PP,EVALQ	;[222] EVALUATE AND TEST FOR EXTERNAL
	CAIE	C,14		;","?
	JRST	[SKIPN	AC0		;IF NZERO AND NO "," SEEN
		TRO ER,ERRQ		;TREAT AS Q ERROR
IFN FORMSW,<	MOVE	AC1,HWFORM	;USE HALF WORD FORM>
		SOJA AC0,STOW]		;NO, TREAT AS RIGHT HALF
	PUSH	PP,AC0		;YES, STACK LEFT HALF
	PUSHJ	PP,EVALEX	;WFW
	SUBI	AC0,1
	POP	PP,AC1		;RETRIEVE LEFT HALF
	MOVNS	AC1
	HRL	AC0,AC1
IFN FORMSW,<	MOVE	AC1,HWFORM	;USE HALF WORD FORM>
	JRST	STOW		;STOW CODE AND EXIT

BYTE0:	PUSHJ	PP,BYPAS1	;GET FIRST NON-BLANK
	CAIE	C,10		;"("?
	JRST	ERRAX		;NO, FLAG ERROR AND EXIT
IFN FORMSW,<
	PUSH	PP,[1]
	MOVEI	AC0,0
>
	PUSH	PP,RC
	PUSH	PP,AC0		;INITIALIZE STACK TO ZERO
	MOVSI	ARG,(POINT -1,(PP))

BYTE1:	PUSH	PP,ARG
	PUSHJ	PP,EVAL10	;EVALUATE RADIX 10
	POP	PP,ARG
	CAIG	AC0,^D36	;TEST SIZE
	JUMPGE	AC0,.+2
	TRO	ER,ERRA
	DPB	AC0,[POINT 6,ARG,11]	;STORE BYTE SIZE

BYTE2:	IBP	ARG		;INCREMENT BYTE
	TRZN	ARG,-1		;OVERFLOW?
	JRST	BYTE3		;NO
	SETZB	AC0,RC		;YES
	EXCH	AC0,0(PP)	;GET CURRENT VALUES
	EXCH	RC,-1(PP)	;AND STACK ZEROS
IFN FORMSW,<
	MOVE	AC1,HWFORM	;USE STANDARD FORM
	EXCH	AC1,-2(PP)	;GET FORM WORD
>
	PUSHJ	PP,STOW		;STOW FULL WORD

BYTE3:	PUSH	PP,ARG
	PUSHJ	PP,EVALEX	;COMPUTE NEXT BYTE
	POP	PP,ARG
	DPB	AC0,ARG		;STORE BYTE
	HLLO	AC0,ARG
	DPB	RC,AC0		;STORE RELOCATION

IFN FORMSW,<
	MOVEI	AC0,1
	HRRI	ARG,-2
	DPB	AC0,ARG		;STORE FORM BYTE
	HRRI	ARG,0
>
	JUMPCM	BYTE2
	CAIN	C,10		;"("?
	JRST	BYTE1		;YES, GET NEW BYTE SIZE
	JRST	OP3		;NO, EXIT

RADX50:	PUSHJ	PP,EVALEX	;EVALUATE CODE
	JUMPN	RC,ERRAX	;ERROR IF NOT ABSOLUTE
	JUMPNC	ERRAX
	PUSH	PP,AC0		;[160] SAVE CODE BITS
	PUSHJ	PP,GETSYM	;YES, GET SYMBOL
	TRZ	ER,ERRA		;CLEAR ERROR
	POP	PP,ARG		;[160] PUT CODE INTO ARG
	PUSHJ	PP,SQOZE	;SQUOZE SIXBIT AND ADD CODE
IFN FORMSW,<	MOVE	AC1,HWFORM	;USE STANDARD FORM>
	JRST	STOW		;STOW CODE AND EXIT


SQOZE:	MOVE	AC1+1,AC0	;PUT SIXBIT IN AC1+1
	MOVEI	AC0,0		;CLEAR RESULT
SQOZ1:	MOVEI	AC1,0
	LSHC	AC1,6		;PUT 6-BIT CHARACTER IN AC1
	LDB	AC1,[POINT 6,CSTAT(AC1),23]	;CONVERT TO RADIX50
	IMULI	AC0,50		;MULTIPLY PREVIOUS RESULT
	ADD	AC0,AC1		;ADD NEW CHARACTER
	JUMPN	AC1+1,SQOZ1	;TEST FOR END
	LSH	ARG,^D30	;LEFT-JUSTIFY CODE
	IOR	AC0,ARG		;MERGE WITH RESULT
	POPJ	PP,

%LINK:	PUSH	PP,BLKTYP	;SAVE BLOCK TYPE
	PUSH	PP,AC0
	JUMP1	LINK1		;SKIP CODE GEN IF P1
	PUSHJ	PP,COUTD
	MOVEI	AC0,12		;LINK TYPE
	MOVEM	AC0,BLKTYP
LINK1:	PUSHJ	PP,EVALEX	;EVAL CHECK EXT
	POP	PP,AC1		;GET BITS BACK
	JUMPN	RC,LNKERR	;MUST BE ABS
	JUMPNC	LNKERR		;GRNTEE COMMA
	TLNE	AC1,400000	;LNKEND?
	MOVN	AC0,AC0		;YES, NEGATE RESULT
	JUMP1	LINK2		;SKIP IF P1
	PUSHJ	PP,COUT
LINK2:	PUSHJ	PP,EVALXQ	;NO EXTERNALS
	JUMP1	LINK3
	PUSHJ	PP,COUT		;DUMP LOC
	PUSHJ	PP,COUTD	;FINISH BLOCK
LINK3:	POP	PP,BLKTYP	;RESTORE BLKTYP
	POPJ	PP,

LNKERR:	POP	PP,BLKTYP	;RESTORE BLOCK TYPE
	PJRST	ERRAX		;GIVE ERROR RETURN
%INTEG:	PUSHJ	PP,GETSYM	;GET A SYMBOL
	JRST	INTG2		;BAD SYMBOL ERROR
	TLO	IO,DEFCRS	;THIS IS A DEFINTION
	PUSHJ	PP,SSRCH	;SEE IF THERE
	MOVSI	ARG,SYMF!UNDF	;SET SYMBOL AND UNDEFINED IF NOT
	TLNN	ARG,UNDF	;IF ALREADY DEFINED
	JRST	INTG1		;JUST IGNORE
	TLOA	ARG,VARF	;SET VARIABLE FLAG
INTG2:	TROA	ER,ERRA		;SYMBOL ERROR
	PUSHJ	PP,INSERZ	;PUT IN WITH ZERO VALUE (LENGTH OF 1)
INTG1:	JUMPCM	%INTEG
	POPJ	PP,

%ARAY:	MOVEM	PP,ARAYP	;SAVE PUSHDOW POINTER
ARAY2:	PUSHJ	PP,GETSYM
	JRST	ARAY1		;BAD SYMBOL GIVE ERROR AND ABORT
	PUSH	PP,AC0		;SAVE NAME
	JUMPCM	ARAY2		;AND GO ON IF A COMMA
	CAIE	C,"["-40	;MUST BE A [
	JRST	ARAY1
	BYPASS			;OH,	WELL
	TLO	IO,IORPTC
	PUSHJ	PP,EVALXQ	;GET A SIZE
	CAIE	C,"]"-40	;MUST END RIGHT
	JRST	ARAY1
	BYPASS			;??
	HRRZ	V,AC0		;GET VALUE
	SUBI	V,1
NXTVAL:	POP	PP,AC0
	PUSH	PP,V		;SAVE OVER SEARCH
	TLO	IO,DEFCRS
	PUSHJ	PP,SSRCH	;FIND IT
	MOVSI	ARG,SYMF!UNDF
	POP	PP,V		;GET VALUE BACK
	TLNN	ARG,UNDF
	JRST	ARAY3
	TLO	ARG,VARF
	MOVEI	RC,0		;NO RELOC
	PUSHJ	PP,INSERT
ARAY3:	CAME	PP,ARAYP
	JRST	NXTVAL		;STILL NAMES STACKED
	JUMPCM	ARAY2
	POPJ	PP,

ARAY1:	TRO	ER,ERRA		;ERROR EXIT
	MOVE	PP,ARAYP
	POPJ	PP,		;RESET PDL AND GO

;[121] .COMMON SYMBOL [SIZE]
SYN	ARAYP,COMMP		;SAVE SPACE

COMM0:	JUMP1	COMM1		;WASTE OF TIME ON PASS1
	PUSHJ	PP,COUTD	;DUMP CURRENT BLOCK
	PUSH	PP,BLKTYP	;SAVE TYPE
	MOVEI	AC0,20		;COMMON BLOCK TYPE
	MOVEM	AC0,BLKTYP	;SET NEW
COMM1:	MOVEM	PP,COMMP	;SAVE PUSHDOWN POINTER
COMM2:	PUSHJ	PP,GETSYM	;GET A 6-BIT SYMBOL NAME
	  JRST	COMM7		;BAD SYMBOL, GIVE UP
	PUSH	PP,AC0		;SAVE SYMBOL NAME
	JUMPCM	COMM2		;AND GET ANOTHER IF COMMA

	CAIE	C,'['		;MUST BE A [
	JRST	COMM7		;YOU LOSE
	BYPASS			;SKIP ANY LEADING SPACES
	TLO	IO,IORPTC	;BUT NOT LAST CHAR
	PUSHJ	PP,EVALXQ	;GET SIZE OF COMMON
	CAIE	C,']'		;MUST END RIGHT
	JRST	COMM7
	HRRZ	V,AC0		;GET VALUE
				;PUSHDOWN STACK IS IN WRONG ORDER, REVERSE IT
	HRRZ	RC,PP		;TOP ITEM
	HRRZ	ARG,COMMP	;BOTTOM ITEM
	ADDI	ARG,1		;WELL ALMOST
COMM6:	CAIG	RC,(ARG)	;ANYTHING TO MOVE?
	JRST	COMM3		;NO
	MOVE	0,(RC)		;MOVE TOP
	EXCH	0,(ARG)		;TO BOTTOM
	MOVEM	0,(RC)
	SUBI	RC,1		;DECREMENT
	AOJA	ARG,COMM6	;AND TRY AGAIN

COMM3:	POP	PP,AC0		;GET SYMBOL
	JUMP1	.+2		;IGNORE V ON PASS 1
	PUSH	PP,V		;SAVE VALUE
	PUSHJ	PP,EXTER1	;DEFINE AS EXTERNAL
				;NOTE, CS IS NOT ON A COMMA, SO WILL RETURN
	JUMP1	COMM4		;ALL DONE IF PASS1
	SETZ	RC,		;NO RELOCATION
	MOVEI	ARG,4		;FORM RADIX50 04,SYMBOL
	PUSHJ	PP,SQOZE	;IN AC0
	PUSHJ	PP,COUT		;OUTPUT SYMBOL
	POP	PP,V		;GET VALUE BACK
	MOVE	AC0,V		;AND INTO AC0
	PUSHJ	PP,COUT		;SECOND PART OF PAIR
COMM4:	CAME	PP,COMMP	;FINISHED WITH STACKED SYMBOLS
	JRST	COMM3		;NO MORE TO GO
	BYPASS			;GET NEXT DELIMITER
	JUMPCM	COMM2		;MORE TO GO IF COMMA NEXT
COMM5:	JUMP1	CPOPJ
	PUSHJ	PP,COUTD	;DUMP THIS BLOCK
	POP	PP,BLKTYP	;RESTORE LAST
	POPJ	PP,


COMM7:	TRO	ER,ERRA		;FLAG ERROR
	MOVE	PP,COMMP	;RESET PUSHDOWN POINTER
	JRST	COMM5		;RESTORE BLKTYP AND EXIT

;[122] .REQUEST DEV:FILENAME[PPN]

REQUIR:	SKIPA	CS,[16]		;BLOCK TYPE 16
REQUES:	MOVEI	CS,17		;BLOCK TYPE 17
	JUMP1	REMAR0		;IGNORE ON PASS 1
	PUSHJ	PP,COUTD	;DUMP CURRENT
	PUSH	PP,BLKTYP	;SAVE LAST BLOCK TYPE
	MOVEM	CS,BLKTYP	;SET NEW
REQU0:
REPEAT 3,<PUSH	PP,[0]>		;STACK A NULL SPEC INCA