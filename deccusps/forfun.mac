	TITLE	FORFUN	%4.(333) - OVERLAY FUNCTION MODULE FOR FOROTS
	SUBTTL	H. P. WEISS/HPW/DMN/MD		27-JUN-74

;***COPYRIGHT 1973,1974, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

VERWHO==0	;EDITOR
VERVER==4	;MAJOR VERSION NUMBER
VERUPD==0	;MINOR VERSION NUMBER
VEREDT==333	;EDIT NUMBER

VERFUN==BYTE (3)VERWHO(9)VERVER(6)VERUPD(18)VEREDT

PURGE	VERWHO,VERVER,VERUPD,VEREDT
	SUBTTL	REVISION HISTORY

	SUBTTL	DEFINE SYMBOLS
SEARCH	FORPRM		;GLOBAL SYMBOLS DEFINED IN FORPRM

SEGMEN

	DEFINE FUNDIR,<
	FNCTN	ILL		;0; ILLEGAL FNCTNION
	FNCTN	GAD		;1; GET CORE AT ADDRESS
	FNCTN	COR		;2; GET CORE FROM ANY ADDRESS
	FNCTN	RAD		;3; RETURN CORE AT ADDRESS
	FNCTN	GCH		;4; GET A CHANNEL
	FNCTN	RCH		;5; RETURN A CHANNEL
	FNCTN	GOT		;6;[251] GET CORE FROM OTS LIST
	FNCTN	ROT		;7;[251] RETURN CORE TO OTS LIST
	FNCTN	RNT		;10;[302] GET RUNTIME FROM OTS
	FNCTN	IFS		;11;[311] GET DEV:FILE[PPN] FROM OTS
	FNCTN	CBC		;12;[311] CUT BACK CORE
	>

	FUN.ZZ==0
	DEFINE FNCTN(A),<
	JRST	FUN'A		;DEFINE DISPATCH TO PROCESSING ROUTINE
	FUN.ZZ==FUN.ZZ+1	;COUNT NUMBER OF ENTRIES IN TABLE
	>

FUNDSP:	FUNDIR			;DEFINE DISPATCH TABLE
	SUBTTL	FUNCTION DISPATCH

	ENTRY	FUNCT%


;CALLS TO FUNCT. CONFORM TO THE DEC STANDARD CALLING SEQUENCE
;
;THE ARG LIST HAS THE GENERAL FORM
;
;		-ARG COUNT,,0
; ARGBLK:	TYPE,,[FUNCTION]
;		TYPE,,[ERROR CODE]
;		TYPE,,[STATUS]
;		TYPE,,[ARG1]
;		TYPE,,[ARG2]
;		TYPE,,[ARG3]
;

		DEFINE FUNBLK,<
		FUNARG	FUN,IND
		FUNARG	ERR,IND
		FUNARG	STS,IND
		FUNARG	RG1,IND
		FUNARG	RG2,IND
		FUNARG	RG3,IND
		>


		FUN.YY==0
		DEFINE FUNARG(A,B)<
		FN.'A==FUN.YY		;SET INDEX INTO ARGBLK
		FUN.YY==FUN.YY+1	;COUNT ENTRIES IN ARGBLK
		>

		FUNBLK			;DEFINE ARGBLK SYMBOLS
		PURGE	FUN.YY

	SIXBIT	/FUNCT./	;FOR TRACE
FUNCT%:	PUSHJ	P,SAVE.##	;SAVE REGISTERS
	MOVEI	T2,0		;LOCATE THE FUNCTION CODE
	PUSHJ	P,FUNADR	;LOCATE THE FUNCTION CODE
	SKIPL	G1,0(G1)	;LOAD THE ARGUMENT
	CAIL	G1,FUN.ZZ	;[311] IS THE FUNCTION DEFINED?
	MOVEI	G1,0		;DEFAULT TO ILLEGAL FUNCTION
	PUSHJ	P,@FUNDSP(G1)	;DISPATCH TO FUNCTION ROUTINE
	MOVEI	T2,FN.STS	;LOCATE STATUS ARGUMENT
	PUSHJ	P,FUNADR	;LOCATE STATUS ARGUMENT
	HRREM	P3,0(G1)	;STORE STATUS ARGUMENT
	POPJ	P,		;RETURN
	SUBTTL	FUNCTION ILL - ILLEGAL FUNCTION

;FUNCTION ILL - ILLEGAL FUNCTION
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARGBLK IS IGNORED
;ALWAYS RETURNS STATUS -1

FUNILL:	MOVEI	P3,-1		;SET ILLEGAL FUNCTION
	POPJ	P,		;RETURN TO USER
	SUBTTL	FUNCTION GAD - GET CORE AT SPECIFIED ADDRESS

;FUNCTION GAD - GET CORE AT ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS TO ALLOCATE CORE AT
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 2:	CANNOT ALLOCATE AT SPECIFIED LOCATION
;STATUS 3:	ILLEGAL ARGUMENTS

FUNGAD:	MOVSS	FRE.DY(P4)	;SWAP DYNAMIC CORE POINTER
	PUSHJ	P,FUNRG1	;LOCATE FIRST ARGUMENT
	SKIPLE	P2,0(G1)	;LOAD ADDRESS WANTED
	TLNE	P2,-1		;POSITIVE 18 BITS ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	PUSHJ	P,FUNRG2	;LOCATE SECOND ARGUMENT
	SKIPLE	P3,0(G1)	;LOAD SIZE WANTED
	TLNE	P3,-1		;POSITIVE 18 BITS ADDRESS
	JRST	FUNGAI		;[333] ILLEGAL ARGUMENT
FUNGAX:	ADDI	P3,-1(P2)	;COMPUTE LAST BLOCK ADR
	TLNE	P3,-1		;GREATER THAN 256 K
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	MOVE	T1,.JBREL##	;LOCATE LAST ASSIGNED ADR
	CAIG	P3,0(T1)	;[245] ALLOCATING PAST END OF CORE
	JRST	FUNDFM		;NO - DEFRAGMENT MEMORY
				;
	MOVEI	T1,0(P3)	;ALLOCATE BLOCK FROM AVAILABLE CORE
	CORE	T1,		;ALLOCATE BLOCK FROM AVAILABLE CORE
	  JRST	FUNST3		;[333] NO CORE AVAILABLE
	MOVE	T1,.JBFF##	;LOCATE START OF BLOCK
	HRRZ	T2,FRE.DY(P4)	;[251] GET DYNAMIC CORE POINTER
	JUMPN	T2,FUNGA3	;[251] BRANCH IF NOT FIRST TIME
	MOVEI	T2,-1(P2)	;[251] HIGHEST ADDRESS WE DON'T WANT 
	SUBI	T2,-1(T1)	;[251] LENGTH TO GIVE BACK
	JUMPLE	T2,FUNGA4	;[274] ANY CORE TO RETURN?
	HRLZM	T2,0(T1)	;[251] STORE LENGTH IN FIRST WORD
	ADDB	T2,.JBFF	;[251] ACCOUNT FOR IT
	ADDI	T1,1		;[251] POINT PAST FIRST WORD
	MOVSS	FRE.DY(P4)	;[251] POINT TO OTS LIST
	PUSHJ	P,PMEM%%	;[251] RETURN CORE TO OTS LIST
	MOVSS	FRE.DY(P4)	;[251] AS IT WAS
FUNGA4:	MOVE	T1,.JBFF##	;[274] RESET START OF BLOCK
FUNGA3:	MOVE	T2,.JBREL##	;[251] LOCATE END OF CORE
	SUBI	T2,-1(T1)	;COMPUTE SIZE OF BLOCK ADDED
	HRLZM	T2,0(T1)	;STORE BLOCK SIZE
	ADDB	T2,.JBFF##	;OFFSET .JBFF
	ADDI	T1,1		;OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%##	;RETURN SPACE ALLOCATED
FUNDFM:	PUSHJ	P,DMEM%%##	;DEFRAGMENT MEMORY
				;
	MOVEI	T2,FRE.DY(P4)	;LOCATE FREE CORE LIST
	HRRZ	T1,0(T2)	;ANY HEAP LEFT
	JUMPE	T1,FUNST2	;CANNOT ALLOCATE
FUNGA0:	HLRZ	P1,0(T1)	;LOAD SIZE OF BLOCK
	ADDI	P1,-1(T1)	;COMPUTE LAST ADR OF BLOCK
	CAIL	P2,0(T1)	;BELOW OR
	CAILE	P2,0(P1)	;ABOVE CURRENT BLOCK
	SKIPA	T2,0(T2)	;YES - ADVANCE LINK
	JRST	FUNGA1		;NO - CHECK IF WHOLE BLOCK IS CONTAINED
	HRRZ	T1,0(T2)	;LOAD ADR OF NEXT BLOCK
	JUMPN	T1,FUNGA0	;CHECK IF IN NEXT BLOCK
	JRST	FUNST2		;CANNOT ALLOCATE ADR
FUNGA1:	CAILE	P3,0(P1)	;DOES BLOCK FIT IN BLOCK AVAILABLE
	JRST	FUNST2		;NO - CANNOT ALLOCATE
	HRRZ	T4,0(T1)	;SPACE FOUND
	HRRM	T4,0(T2)	;DELETE SPACE FROM CHAIN
	CAIN	P2,0(T1)	;EXTRA SPACE IN FRONT OF BLOCK?
	JRST	FUNGA2		;NO - NO NEED TO RETURN SPACE
	MOVEI	T0,0(P2)	;COMPUTE SPACE RETURNED
	SUBI	T0,0(T1)	;COMPUTE SPACE RETURNED
	HRLZM	T0,0(T1)	;SET BLOCK SIZE
	ADDI	T1,1		;OFFSET FOR PMEM%%
	PUSHJ	P,PMEM%%##	;RETURN EXTRA AT BEGINNING
FUNGA2:	CAIN	P3,0(P1)	;EXTRA SPACE AFTER BLOCK
	JRST	FUNALC		;NO - NO NEED TO RETURN SPACE
	MOVEI	T0,0(P1)	;COMPUTE SPACE RETURNED
	SUBI	T0,0(P3)	;COMPUTE SPACE RETURNED
	HRLZM	T0,1(P3)	;SET BLOCK SIZE
	MOVEI	T1,2(P3)	;SET BLOCK ADR
	PUSHJ	P,PMEM%%##	;RETURN EXTRRA SPACE
				;
FUNALC:	HRLI	T1,0(P2)	;SET UP BLT POINTER
	HRRI	T1,1(P2)	;TO CLEAR ALLOCATED BLOCK
	SETZM	0(P2)		;CLEAR FIRST WORD
	BLT	T1,0(P3)	;CLEAR ALLOCATED CORE
FUNST0:	TDZA	P3,P3		;SET STATUS 0
FUNST2:	MOVEI	P3,2		;SET STATUS 2
	MOVSS	FRE.DY(P4)	;SWAP DYNAMIC CORE POINTER
	POPJ	P,		;RETURN TO USER

;HERE IF SIZE IS ILLEGAL
;IF IT IS FIRST CALL ALLOCATE ALL OF FREE SPACE ABOVE ADDRESS
;OTHERWISE GIVE ERROR RETURN

FUNGAI:	HRRZ	T1,FRE.DY(P4)	;[333] GET FREE CORE POINTER
	JUMPN	T1,FUNGA3	;[333] NOT FIRST TIME
	MOVEI	P3,100		;[333] A RANDOM NUMBER
	MOVEM	P3,0(G1)	;[333] SET ARGUMENT BACK FOR USER
	CAML	P2,.JBREL##	;[333] IS BASE IN CORE?
	JRST	FUNGAX		;[333] NO, EXPAND AS BEFORE
	MOVE	P3,.JBREL##	;[333] HIGHEST ADDRESS WE NEED
	MOVE	T1,P3		;[333] BUT MUST CALCULATE LENGTH
	SUBI	T1,-1(P2)	;[333] THAT WE WILL ALLOCATE
	MOVEM	T1,0(G1)	;[333] AND STORE FOR USER
	MOVSS	FRE.DY(P4)	;[333] SWAP BACK TO GET SPACE FROM OTS
	PUSHJ	P,FUNDFM	;[333] GET THE TOP OF CORE
	MOVSS	FRE.DY(P4)	;[333] FUNDFM SWAPPED IT
	POPJ	P,		;[333] RETURN
	SUBTTL	FUNCTION COR - GET CORE AT ANY ADDRESS

;FUNCTION COR - GET CORE FROM ANY ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK ALLOCATED
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 3:	ILLEGAL ARGUMENT

FUNCOR:	MOVSS	FRE.DY(P4)	;SWAP DYNAMIC CORE POINTER
FUNCR1:	PUSHJ	P,FUNRG2	;[251] ENTRY POINT FOR FUNGOT
				;[251] LOCATE SECOND ARGUMENT
	SKIPLE	T1,0(G1)	;LOAD SIZE OF BLOCK
	TLNE	T1,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	MOVEI	T0,-1(T1)	;GMEM%% ADDS A WORD
	PUSHJ	P,GMEM%%##	;ALLOCATE CORE
	MOVEI	P3,-1(T1)	;REMOVE FOROTS
	SETZM	0(P3)		;CONTROL WORD
	PUSHJ	P,FUNRG1	;LOCATE FIRST ARGUMENT
	HRRZM	P3,0(G1)	;STORE ADR OF BLOCK
	PJRST	FUNST0		;SET STATUS 0 AND RETURN

FUNST1:	SKIPA	P3,FUNCO0	;SET STATUS 1
FUNST3:	MOVEI	P3,3		;SET STATUS 3
	MOVSS	FRE.DY(P4)	;SWAP DYNAMIC CORE POINTER
FUNCO0:	POPJ	P,1		;RETURN
	SUBTTL	FUNCTION RAD - RETURN CORE AT ADDRESS

;FUNCTION RAD - RETURN CORE AT ADDRESS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK TO BE RETURNED
;ARG2:	SIZE OF BLOCK TO BE RETURNED
;
;STATUS 0:	CORE DEALLOCATED
;STATUS 1:	CORE NOT DEALLOCATABLE
;STATUS 3:	ILLEGAL ARGUMENT

FUNRAD:	MOVSS	FRE.DY(P4)	;SWAP DYNAMIC CORE POINTER
FUNRA1:	PUSHJ	P,FUNRG1	;[251] ENTRY POINT FOR FUNROT
				;[251] LOCATE FIRST ARGUMENT
	SKIPLE	P2,0(G1)	;LOAD CORE ADR
	TLNE	P2,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	PUSHJ	P,FUNRG2	;LOCATE SECOND ARGUMENT
	SKIPLE	P3,0(G1)	;LOAD CORE SIZE
	TLNE	P3,-1		;POSITIVE 18 BIT ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
				;
	HRRZ	T1,.JBREL##	;LOAD LAST LEGAL ADR
	ADDI	P3,-1(P2)	;COMPUTE LAST ADR IN BLOCK
	TLNN	P3,-1		;POSITIVE 18 BIT ADDRESS
	CAILE	P3,0(T1)	;LEGAL ADDRESS
	PJRST	FUNST3		;ILLEGAL ARGUMENT
	MOVEI	T2,FRE.DY(P4)	;LOCATE FREE CORE LIST
	HRRZ	T1,0(T2)	;ANY HEAP LEFT
	JUMPE	T1,FUNRA4	;NO - VALID DEALLOCATION
FUNRA3:	HLRZ	T3,0(T1)	;LOAD SIZE OF BLOCK
	ADDI	T3,-1(T1)	;COMPUTE LAST ADR OF BLOCK
	MOVSI	T4,(CAIGE P3,0(T1))	;FREE BLOCK STARTS FIRST
	CAIL	P2,0(T1)		;WHICH BLOCK STARTS FIRST
	MOVSI	T4,(CAILE P2,0(T3))	;TEST BLOCK STARTS FIRST
	XCT	T4		;DO BLOCKS OVERLAP
	SKIPA	T2,0(T2)	;NO - TEST NEXT BLOCK
	PJRST	FUNST1		;SET STATUS 1 AND RETURN
	HRRZ	T1,0(T2)	;LOAD ADR OF NEXT BLOCK
	JUMPN	T1,FUNRA3	;TEST ALL BLOCKS
				;
FUNRA4:	MOVE	P3,0(G1)	;RELOAD CORE SIZE
	HRLZM	P3,0(P2)	;BUILD FOROTS CONTROL WORD
	MOVEI	T1,1(P2)	;BUILD BLOCK POINTER
	PUSHJ	P,PMEM%%##	;RETURN CORE BLOCK
				;CLEAR ENCODED FORMATS IN BLOCK
	ADDI	P3,-1(P2)	;LOCATE END OF BLOCK
	MOVEI	P1,FMT.DY(P4)	;LOCATE LIST OF ENCODED FORMATS
				;
	MOVSS	FRE.DY(P4)	;SWAP DYNAMIC CORE POINTER
				;
FUNRA0:	HRRZ	T1,0(P1)	;LOCATE FORMAT POINTED TO BY LINK AT P1
					;[245] AT END LIST
	JUMPE	T1,[PUSHJ P,DMEM%%##	;[245] DEFRAGMENT MEMORY
		    JRST FUNGC0]	;[245] SET STATUS 0 AND RETURN
	HRRZ	T2,1(T1)	;LOAD FORMAT ADR
	CAIL	T2,0(P2)	;BELOW OR
	CAILE	T2,0(P3)	;ABOVE DELETED BLOCK
	JRST	FUNRA2		;YES - RETAIN ENCODING
				;DELETE ENCODING
	MOVE	T2,0(T1)	;LOAD LINK WORD
	HRRM	T2,0(P1)	;LINK OVER THIS BLOCK
	ADDI	T1,1		;SET POINTER FOR PMEM%%
	HLLZS	-1(T1)		;CLEAR POINTER
	PUSHJ	P,PMEM%%##	;RETURN ENCODED LIST
	JRST	FUNRA0		;CHECK NEXT ENCODING
				;
FUNRA2:	HRRZ	P1,0(P1)	;FIND NEXT ENCODING
	JRST	FUNRA0		;REPEAT FOR NEXT ENCODING
	SUBTTL	FUNCTION GCH - GET AN I/O CHANNEL

;FUNCTION GCH - GET AN I/O CHANNEL
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	CHANNEL # ALLOCATED
;ARG2:	IGNORED
;
;STATUS 0:	CHANNEL ALLOCATED
;STATUS 1:	NO CHANNELS AVAILABLE

FUNGCH:	PUSHJ	P,FUNRG1	;LOCATE ARG1
	JSP	P1,GT.CHN##	;[265] GET A CHANNEL
	  JRST	FUNGC1		;NO CHANNELS AVAILABLE
	HRRZM	T1,0(G1)	;STORE CHANNEL #
	ADDI	T1,CHN.TB(P4)	;POINT TO THE CHANNEL TABLE
	SETOM	0(T1)		;SET CHANNEL IN USE
FUNGC0:	TDZA	P3,P3		;SET STATUS 0
FUNGC1:	MOVEI	P3,1		;SET STATUS 1
	POPJ	P,		;RETURN
	SUBTTL	FUNCTION RCH - RETURN AN I/O CHANNEL
;FUNCTION RCH - RETURN AN I/O CHANNEL
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	CHANNEL # TO BE RETURNED
;ARG2:	IGNORED
;
;STATUS 0:	CHANNEL RETURNED
;STATUS 1:	INVALID OR NON-USER CHANNEL

FUNRCH:	PUSHJ	P,FUNRG1	;LOCATE ARG1
	SKIPLE	T1,(G1)		;LOAD CHANNEL #
	CAILE	T1,17		;MUST BE BETWEEN 0 AND 20
	PJRST	FUNGC1		;CANNOT RETURN
	ADDI	T1,CHN.TB(P4)	;RELOCATE TO CHANNEL TABLE
	SETCM	T0,0(T1)	;USER CHANNEL
	JUMPN	T0,FUNGC1	;NO - CANNOT RETURN
	SETZB	P3,0(T1)	;CLEAR CHANNEL TABLE
	POPJ	P,		;SET STATUS 0 AND RETURN
	SUBTTL	FUNCTION GOT - GET CORE FROM OTS LIST

;FUNCTION GOT - GET CORE FROM OTS LIST
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK ALLOCATED
;ARG2:	SIZE OF BLOCK TO ALLOCATE
;
;STATUS 0:	CORE ALLOCATED
;STATUS 3:	ILLEGAL ARGUMENT

FUNGOT:	PUSHJ	P,FUNCR1	;[251] USE COMMON ROUTINE WITHOUT SWAPPING PTR
	MOVSS	FRE.DY(P4)	;[251] RESTORE PTR AS IT SHOULD BE
	POPJ	P,		;[251] RETURN TO USER
	SUBTTL	FUNCTION ROT  - RETURN CORE TO OTS LIST

;FUNCTION ROT - RETURN CORE TO OTS LIST
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	ADDRESS OF BLOCK TO BE RETURNED
;ARG2:	SIZE OF BLOCK TO BE RETURNED
;
;STATUS 0:	CORE DEALLOCATED
;STATUS 1:	CORE NOT DEALLOCATABLE
;STATUS 3:	ILLEGAL ARGUMENT

FUNROT:	PUSHJ	P,FUNRA1	;[251] USE COMMON ROUTINE WITHOUT SWAPPING PTR
	MOVSS	FRE.DY(P4)	;[251] RESTORE PTR AS IT SHOULD BE
	POPJ	P,		;[251] RETURN TO USER
	SUBTTL	FUNCTION RNT - RETURN INITIAL RUNTIME FROM OTS

;FUNCTION RNT - RETURN INITIAL RUNTIME FROM OTS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	RUNTIME FROM OTS
;ARG2:	IGNORED
;
;STATUS 0:	RUNTIME RETURNED
;STATUS 1:	RUNTIME NOT AVAILABLE

FUNRNT:	PUSHJ	P,FUNRG1	;[302] LOCATE FIRST ARGUMENT
	MOVE	T1,RUN.TM(P4)	;[302] GET RUNTIME FROM OTS
	MOVEM	T1,0(G1)	;[302] STORE
	PJRST	FUNGC0		;[302] OK RETURN
	SUBTTL	FUNCTION IFS - RETURN DEV:FILE[PPN] FROM OTS

;FUNCTION IFS - RETURN DEV:FILE[PPN] FROM OTS
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;ARG1:	DEVICE
;ARG2:	FILE NAME
;ARG3:	[PPN]
;
;STATUS 0:	OK
;STATUS 1:	ERROR

FUNIFS:	PUSHJ	P,FUNRG1	;[311] LOCATE FIRST ARGUMENT
	MOVE	T1,REGS.2(P4)	 ;[311] GET DEVICE
	MOVEM	T1,0(G1)	;[311] STORE
	PUSHJ	P,FUNRG2	;[311] LOCATE SECOND ARGUMENT
	MOVE	T1,REGS.0(P4)	;[311] FILE NAME
	MOVEM	T1,0(G1)	;[311] STORE
	MOVEI	T2,FN.RG3	;[311] LOCATE THIRD ARGUMENT
	PUSHJ	P,FUNADR	;[311]
	MOVE	T1,REGS.1(P4)	;[311] PPN
	MOVEM	T1,0(G1)	;[311] STORE
	PJRST	FUNGC0		;[311] OK RETURN
	SUBTTL	FUNCTION CBC - CUT BACK CORE IF POSSIBLE

;FUNCTION CBC - CUT BACK CORE IF POSSIBLE
;CALL:	MOVEI	16,[ARGBLK]
;	PUSHJ	17,FUNCT.
;
;
;STATUS 0:	ALWAYS

FUNCBC:	MOVSS	FRE.DY(P4)	;[311] SWAP DYNAMIC CORE POINTER
	PUSHJ	P,DMEM%%##	;[311] DEFRAGMENT CORE
	MOVEI	T3,FRE.DY(P4)	;[311] GET FREE CORE LIST
	MOVE	T2,T3		;[311] PREVIOUS ALSO
FUNCB0:	JUMPE	T3,FUNST0	;[311] GIVE IT IF NO FORWARD LINK
	MOVE	T1,T2		;[311] PUT PREVIOUS PREVIOUS IN T1
	MOVE	T2,T3		;[311] PUT PREVIOUS IN T2
	HRRZ	T3,(T2)		;[311] ANY LEFT
	HLRZ	P1,(T2)		;[311] GET SIZE
	CAIGE	P1,1000		;[311] DON'T WASTE TIME IF LESS THAN A PAGE
	JRST	FUNST0		;[311] SINCE WE CANNOT REDUCE BY LESS
	ADDI	P1,-1(T2)	;[311] FIND END
	CAME	P1,.JBREL##	;[311] LESS THAN TOP?
	JRST	FUNCB0		;[311] YES, IGNORE THIS BLOCK
	MOVEI	P1,-1(T2)	;[311] LAST WORD WE NEED
	CORE	P1,		;[311]
	  JRST	FUNST0		;[311] NO CHANGE IF WE FAILED
	CAMLE	T2,.JBREL##	;[311] INCASE WE GAVE IT ALL AWAY
	JRST	FUNCB1		;[311] JUST CLEAR PREVIOUS
	MOVE	P1,.JBREL	;[311] TOP OF CORE
	SUBI	P1,-1(T2)	;[333] - START
	HRLM	P1,(T2)		;[311] NEW LENGTH
	JRST	FUNCB2		;[311] SETUP .JBFF

FUNCB1:	HLLZS	(T1)		;[311] CLEAR FORWARD POINTER
FUNCB2:	MOVE	P1,.JBREL	;[311] GET TOP OF CORE
	ADDI	P1,1		;[311] MAKE SURE OUT OF BOUNDS
	MOVEM	P1,.JBFF	;[311]
	PJRST	FUNST0		;[311] OK RETURN
	SUBTTL	ARGBLK MANIPULATION ROUTINES

;FUNADR - RETURN ADR OF ARGUMENT
;CALL:	MOVEI	T2,OFFSET IN ARGBLK
;	PUSHJ	P,FUNADR
;	(RETURN)
;
; RETURN ADR IN G1
; CLOBBERS P1, AND T1
;
FUNRG2:	SKIPA	T2,FUNAD1	;LOAD ARG2 OFFSET
FUNRG1:	MOVEI	T2,FN.RG1	;LOAD ARG1 OFFSET
FUNADR:	ADDI	L,0(T2)		;OFFSET ARGBLK
	JSP	P1,EFCTV.##	;[265] COMPUTE EFFECTIVE ADDRESS
	TRNN	G1,-20		;IN AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES - RELOCATE TO AC SAVE AREA
	SUBI	L,0(T2)		;RESET ARGBLK
FUNAD1:	POPJ	P,FN.RG2	;RETURN

	END
