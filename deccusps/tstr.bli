!***COPYRIGHT 1974, DIGITAL EQUIPMENT COPR., MAYNARD, MASS***
!AUTHOR: NORMA ABEL/HPW
MODULE TSTR(RESERVE(0,1,2,3),SREG=#17,VREG=#15,FREG=#16,DREGS=4)=
BEGIN
GLOBAL BIND TSTRV = 2^24 + 0^18 + 44;	!VERSION DATE: 10-SEP-74

%(
REVISION HISTORY

25	-----	-----	REFER TO GLOBAL RDCLNK
26	-----	-----	SET A2VALFLG IN REDUCTION INITIALIZATION IF
			REQUIRED
27	-----	-----	RESET INDVAR IN SUPPLANT
28	-----	-----	FIX REDUCE TO LOOK FOR TRANSMOGRIFIED VARIABLES
			ON I/O LISTS IN THE LOOP
29	-----	-----	FIX SUPPLANT SO THAT IF RINCR IS LABELED
			WE DO NOT THROW THE LABEL AWAY
30	-----	-----	FIX REDUCE TO MOVE A LABEL ON A REDUCTION
			ASSIGNMENT BACK TO OTHER REDUCTIONS
31	-----	-----	ADD TEST ON DOTOHFLG TO REDUCE
32	-----	-----	REDUCE P2 ADN P2+1 OPS
33	-----	-----	FIX SUPPLANT TO CORRECTLY INITIALIZE AN
			INCREMENT TEMPORARY FOR A REPLACED INDEX
34	-----	-----	FIX REDUCE NOT TO REDUCE .O TEMPS WITHIN THE 
			CURRENT LOOP AND TO SAVSPACE THE REDUCED EXPRS.
35	-----	-----	MAKE LOKINDVAR A GLOBAL ROUITNE TO BE CALLED FROM
			HAULASS
36	-----	-----	MAKE REDUCE DEAL WITH THE NEG/NOT FLAGS
			WHEN MAKING THE INITIALIZATIONS.
37	-----	-----	MAKE SUPPLANT AWARE OF THE NEG/NOT FLAGS
			SET BY PATCH 36
38	-----	-----	CAUSE REDUCE TO INSERT THE .R INITILAIZATION
			AFTER OTHER OPTIMIZER STATEMENTS IF THE
			REDUCTION CONSTANT IS NOT A NUMERIC CONSTANT
39	-----	-----	[EXPLITIVE DELETED] TBLSEARCH TAKES THE VARIABLE TYPE
			OUT OF THE GLOBAL SYMTYPE. MAKE SURE THAT
			RDCTMP SETS THE GLOBAL.
40	-----	-----	REDUCTION ANDTESTREPLACEMENT ARE
			LOSING ON NEGATIVE STEP SIZES.
41	-----	-----	LOOKING AT ARGUMENT LISTS IS LOSING
			CUZ IT DOES NOT LOOK AT ANY BUT THE FIRST
			ARG.
42	-----	-----	LOKINDVAR SHOULD BE ORING RESULTS
			NOT ADDING THEM CUZ SOME TRUES ARE 1 AND SOME
			ARE -1.
43	-----	-----	DO NOT TESTREPLACE A FORMAL VARIABLE DO LOOP INDEX
			IF THE LOOP CONTAINS A RETURN
44	-----	-----	TRANSMOGRIFIED .O VARIBALES ON I/O LISTS
			THAT ARE BRANCHES OF A LOGICAL IF ARE LOSING

)%

	SWITCHES NOLIST;
	REQUIRE FIRST.BLI;
	REQUIRE TABLES.BLI;
	SWITCHES LIST;
	REQUIRE OPTMAC.BLI;


FORWARD LOKINDVAR;



EXTERNAL RDCLNK;
MAP BASE RDCLNK;
OWN RDCCNT,RDCLST[9];

EXTERNAL MAKPR1,CORMAN,TBLSEARCH,UNFLDO;
GLOBAL ROUTINE TESTREPLACE=
BEGIN
	!DRIVE ROUTINE LOKINDVAR TO EXAMINE
	!ALL SATEMENTS BETWEEN TOP AND BOTTOM FOR
	!REMAINING REFERENCES TO INDVAR
	!ONE OF THREE VALUES IS RETURNED
	!0	NO TEST REPLACEMENT IS POSSIBLE. THAT IS, REFERENCES
	!	TO THE DO LOOP INDEX REMAIN
	!1	A UNIQUE TEST REPLACEMENT IS POSSIBLE
	!2	A NON-UNIQUE TEST REPLACEMENT IS POSSIBLE


	EXTERNAL RDCCT,LPRDCCT,TOP,CSTMNT,BOTTOM,INDVAR;

	MAP BASE TOP:CSTMNT:INDVAR;

	!IF THE DO LOOP INDEX IS A FORMAL AND THE LOOP
	!CONTIANS A RETURN THAN DO NOT TESTREPLACE IT.

	IF .INDVAR[FORMLFLG] AND .TOP[HASRTRN] THEN RETURN;

	IF .INDVAR NEQ 0 THEN
	BEGIN
		CSTMNT_.TOP;
		DO
		BEGIN
			IF LOKINDVAR(.CSTMNT) NEQ 0  THEN RETURN 0;
			IF .CSTMNT[SRCID] EQL IFLID THEN
				IF LOKINDVAR(.CSTMNT[LIFSTATE]) THEN RETURN 0;

			CSTMNT_.CSTMNT[SRCLINK];
		END UNTIL .CSTMNT EQL .BOTTOM;
	END;
	!THERE ARE NO REFERENCES TO THE DO LOOP INDEX

	!SEE IF THE REDUCTION VARIABLE IS UNITQE TO THIS LOOP
	!IF THERE WAS ONLY ONE REDUCTION THE TEST REPLACEMENT IS UNIQUE
	!SO RETURN 1 ELSE RETURN 2
	IF .LPRDCCT EQL .RDCCT-1 THEN RETURN 1 ELSE RETURN 2;
END;
GLOBAL ROUTINE LOKINDVAR(STMNT)=
BEGIN

	!ROUTINE WILL DETERMINE IF STMNT CONTAINS A REFERENCE TO
	!THE DO LOOP INDEX. IT RETURNS 0 IF NOT 1 IF IT DOES

	EXTERNAL CONTVAR,INDVAR;

	MAP BASE STMNT;


	!UTILITY MACROS AND ROUTINES

	MACRO CONTUNIT=
		(CONTVAR(.STMNT[IOUNIT],.INDVAR))$;

	ROUTINE IOLOK(STMNT)=
	BEGIN

		MAP BASE STMNT;
		LOCAL SUM,TMP;
		MAP BASE TMP;

		SUM_0;
			TMP_.STMNT[IOLIST];
			WHILE .TMP NEQ 0 DO
			BEGIN
				IF .TMP[OPRCLS] EQL STATEMENT THEN
					SUM_.SUM OR LOKINDVAR(.TMP)
				ELSE
				SUM_.SUM OR CONTVAR(.TMP,.INDVAR);
				TMP_.TMP[CLINK];
			END;
			SUM_.SUM OR CONTUNIT;
			IF .STMNT[IORECORD] NEQ 0 THEN
				SUM_.SUM OR CONTVAR(.STMNT[IORECORD],.INDVAR);
		.SUM
	END;

	MACRO CONTIOVAR=
		RETURN(IOLOK(.STMNT))$;



	!START OF ROUTINE LOKINDVAR***********************
	!IF WE ARE IN THE I/O OPTIMIZATIONS WE WILL WALK DOWN
	!TO AN IOLSCLS NODE SO WE MUST MAKE A SPECIAL CHECK AND
	!DO THE CORRECT THING.

	IF .STMNT[OPRCLS] EQL IOLSCLS THEN
		RETURN(CONTVAR(.STMNT,.INDVAR));

	CASE .STMNT[SRCID] OF SET

	!ASSIGNMENT STATEMENT
		RETURN(CONTVAR(.STMNT[LHEXP],.INDVAR) OR CONTVAR(.STMNT[RHEXP],.INDVAR));

	!ASSIGN
		RETURN(CONTVAR(.STMNT[ASISYM],.INDVAR));

	!CALL STATEMENT
	BEGIN
		LOCAL ARGUMENTLIST AG;
		AG_.STMNT[CALLIST];
		IF .AG NEQ 0 THEN
				INCR I FROM 1 TO .AG[ARGCOUNT] DO
					 IF CONTVAR(.AG[.I,ARGNPTR],.INDVAR) THEN 
						RETURN 1;

	END;

	!CONTINUE
	BEGIN END;

	!DO
	BEGIN
		!!LOOK AT THE STEPSIZE
		!AND THE LOOP CONTROL
		RETURN(CONTVAR(.STMNT[DOM3],.INDVAR) OR CONTVAR(.STMNT[DOLPCTL],.INDVAR));
	END;

	!ENTRY
	BEGIN END;

	!COMNSUB
	BEGIN END;

	!GO TO
	BEGIN END;

	!ASSIGNED GO TO
		RETURN( CONTVAR(.STMNT[AGOTOLBL],.INDVAR));

	!COMPUTED GO TO
		RETURN( CONTVAR(.STMNT[CGOTOLBL], .INDVAR));

	!ARITHMETIC IF
		RETURN( CONTVAR(.STMNT[AIFEXPR],.INDVAR));

	!LOGICAL IF
		RETURN( CONTVAR(.STMNT[LIFEXPR],.INDVAR));

	!RETURN
	BEGIN
		IF .STMNT[RETEXPR] NEQ 0 THEN
			RETURN( CONTVAR(.STMNT[RETEXPR],.INDVAR))
		ELSE RETURN 0;
	END;

	!STOP
	BEGIN END;

	!READ
		CONTIOVAR;

	!WRITE
		CONTIOVAR;

	!DECODE
		CONTIOVAR;

	!ENCODE
		CONTIOVAR;

	!REREAD
		CONTIOVAR;

	!FIND
		CONTIOVAR;

	!CLOSE
	BEGIN END;

	!INPUT
	BEGIN END;

	!OUTPUT
	BEGIN END;

	!BACK SPACE
		RETURN CONTUNIT;

	!BACK FILE
		RETURN CONTUNIT;

	!REWIND
		RETURN CONTUNIT;

	!SKIP FILE
		RETURN CONTUNIT;

	!SKIP RECORD
		RETURN CONTUNIT;

	!UNLOAD
		 RETURN CONTUNIT;

	!RELEASE
		RETURN CONTUNIT;

	!END FILE
		RETURN CONTUNIT;

	!END
	BEGIN END;

	!PAUSE
	BEGIN END;

	!OPEN
	BEGIN END;

	TES;
END;

GLOBAL ROUTINE SUPPLANT=
BEGIN

	!PERFORM A TEST REPLACEMENT ON THE FIRST ELEMENT IN
	!RDCLST.
	LOCAL BASE RINIT:RINCR:PA:PB;
	EXTERNAL TOP,LEND,LENTRY,PREV,GETOPTEMP,INDVAR;
	EXTERNAL MAKCONTINUE;
	MAP BASE TOP:PREV;

	!FIRST PICK UP A POINTER TO THE REDUCTION SYMBOL

	PA_.RDCLST[1]<LEFT>;

	!EXAMINE STATEMENTS LINKED AT LENTRY UTIL WE FIND
	!THE INITIALIZATION OF THIS REDUCTION VARIABLE

	PB_RINIT_.LENTRY;

	WHILE .RINIT NEQ .TOP DO
	BEGIN
		!CHECK FOR AN ASSIGNMENT TO THIS REDUCTION VARIABLE

		IF .RINIT[OPRS] EQL ASGNOS THEN
			IF .RINIT[LHEXP] EQL .PA THEN

			BEGIN
				!IF WE ARE NOT ABOUT TO MAKE AN
				!EXPRESSION THE INITIAL VALUE IN THE
				!LOOP 
				!LINK OUT THIS INIITIALIZATION
				!ASSIGNMENT STATEMENT
				IF .RINIT[A2VALFLG] THEN
				BEGIN
					PB[SRCLINK]_.RINIT[SRCLINK];
					TOP[DOM1]_.RINIT[RHEXP];
					!IF THE NEGFLG IS INVOLVED SET
					!INITLNEG FOR CODE GENERATION
					IF .RINIT[A2NEGFLG] THEN
						TOP[INITLNEG]_1;
				END ELSE
				!MAKE THE INITIAL VALUT BE THE .R
				!VARIABLE AND LEAVE THE ASSIGNMENT IN.
				!THE BB REG ALLOC WILL MAKE HE CODE
				!PRETTY

				BEGIN
					TOP[DOM1]_.PA;
					TOP[INITLTMP]_1;
				END;

				!SET THE DO SYMBOL
				TOP[DOSYM]_INDVAR_.PA;


				!NOW LOOK AT THE END OF THE LOOP.
				!UNFORTUNATELY, WE HAVE TO START AT
				!TOP. RDCLNK POINTS TO WHERE THE REDUCTIONS
				!ARE LINKED. WE NEED TO KNOW THE STATEMENT
				!INFRONT OF THE REDUCTION IN WHICCH WE ARE
				!INTERESTED. IF IT IS THE FIRST REDUCTION
				!STARTING AT RDCLNK LOSES. SO,-------
				!WE TAKE IT FROM THE TOP.
				PREV_.TOP;

				!WE WILL SEARCH UNTIL RDCLNK
				WHILE .PREV[SRCLINK] NEQ .RDCLNK DO
					PREV_.PREV[SRCLINK];

				!PREV IS NOW THE STATEMENT IN FRONT OF 
				!RDCLNK (THE FIRST REDUCTION).

				RINCR_.PREV[SRCLINK];

				WHILE .RINCR NEQ .LEND DO
				BEGIN
					REGISTER BASE EXPR;
					IF .RINCR[OPRS] EQL ASGNOS THEN
						IF .RINCR[LHEXP] EQL .PA THEN
					BEGIN
						!IF RINCR IS LABELED MAKE
						!A CONTINUE TO HOLD THE
						!PLACE OF THE LABEL
						IF .RINCR[SRCLBL] NEQ 0 THEN
						BEGIN
							REGISTER BASE T;
							!GET THE CONTINUE
							EXPR_MAKCONTINUE();
							!MOVE THE LABEL
							T_EXPR[SRCLBL]_.RINCR[SRCLBL];
							T[SNHDR]_.EXPR;
							RINCR[SRCLBL]_0;

							!LINK CONTINUE INTO
							!TREE
							PREV[SRCLINK]_.EXPR;
							EXPR[SRCLINK]_.RINCR;

							!UPDATE PREV
							PREV_.EXPR;
						END;

						!SET STEPSIZE
						EXPR_.RINCR[RHEXP];
						IF .EXPR[OPRCLS] EQL DATAOPR THEN
						BEGIN
							TOP[DOM3]_.EXPR;
							!KILL THE ASSIGNMENT STATEMENT
							PREV[SRCLINK]_.RINCR[SRCLINK];
						END
						ELSE
						BEGIN
							EXPR_(IF .EXPR[ARG1PTR]
							EQL .PA THEN .EXPR[ARG2PTR] ELSE 
							.EXPR[ARG1PTR]);

							!IF EXPR IS STILL
							!AN EXPRESSION MUST DO
							!ELABORATE HACK
							!TO COMPUTE STEP SIZ
							IF .EXPR[OPRCLS] EQL DATAOPR THEN
							BEGIN
								TOP[DOM3]_.EXPR;
								!TURN OFF SSIZNEG FLAG
								!REDUCE HAS ALREADY TAKEN CARE 
								!OF THIS
								TOP[SSIZNEGFLG]_0;
								PREV[SRCLINK]_.RINCR[SRCLINK];
							END
							ELSE
							BEGIN
							!GET AN OPTIMIZER VARIABLE TO USE AS
							!STEPSIZE
							TOP[DOM3]_
							RINCR[LHEXP]_
							GETOPTEMP(IF .EXPR[VALTYPE] EQL
							 CONTROL THEN LOGICAL ELSE 
							.EXPR[VALTYPE]);
							!TRANSFORM RINCR
							!INTO THE STEPSIZE
							!ASSIGNMENT
							RINCR[RHEXP]_.EXPR;
							!DELINK ASSIGNMENT

							PREV[SRCLINK]_.RINCR[SRCLINK];

							!PUT IT AT PB
							!INFRONT OF THE LOOP
							RINCR[SRCLINK]_.PB[SRCLINK];
							PB[SRCLINK]_.RINCR;

							!RESET FLAGS
							RINCR[EXPFLAGS]_0;
							RINCR[A1VALFLG]_1;
							TOP[SSIZINTMP]_1;
							END;
						END;
						!RESET LOOP FLAGS
						IF .TOP[FLCWD] THEN
							UNFLDO(.TOP);
						TOP[SSIZONE]_0;

						!GET OUT
						RETURN;
					END;	!IF THIS IS THE REDUCTION WE WANT
					PREV_.RINCR;
					RINCR_.RINCR[SRCLINK];
				END;	!WHILE TO FIND INCR AT LOOP END
		END;	!IF STATEMENT ON RINIT
		PB_.RINIT;
		RINIT_.RINIT[SRCLINK];
	END;	!WHILE ON RINIT
END;	!ROUTINE
FORWARD RDCTMP,REDUCE;
EXTERNAL INDVAR,LENTRY,LEND,RDCCT;



MAP PEXPRNODE INDVAR:LENTRY:LEND;
ROUTINE ONIOLST(LSTNOD,WHO)=
BEGIN
	!IF WHO IS ON THE I/O LST POINTED TO BY
	!LSTNOD THEN RETURN THE NODE THAT POINTS TO WHO.
	!RETURN 0 AS A FLAG FOR NOT FOUND

	MAP BASE LSTNOD;

	WHILE .LSTNOD NEQ 0 DO
	BEGIN
		IF .LSTNOD[SRCLINK] EQL .WHO THEN
			RETURN(.LSTNOD);
		LSTNOD_.LSTNOD[SRCLINK];
	END;

	0
END;


GLOBAL ROUTINE REDUCE(CNODE)=
BEGIN
EXTERNAL GENLAB,ARSKOPT,DOWDP,TOP,TRANSMOGRIFY;
EXTERNAL SAVSPACE,NEGFLG,NOTFLG;
EXTERNAL FINDTHESPOT;

LABEL CHKREC,LNKOUT;
OWN TEMP;
LOCAL A1NODE,A2NODE,PA,PB,T;
MAP OBJECTCODE DOWDP;
MAP PEXPRNODE CNODE:A1NODE:A2NODE:PA:PB:T;
MAP PHAZ2 TOP;

!INDVAR IS THE INDEX VARIABLE

	!CHECK THAT TWO LEAVES AND INTEGER MULTIPLY

	IF .DOTOHFLG THEN RETURN(.CNODE);

	!IF IT IS A SPECIAL OPERATOR ITS REDUCIBILITY
	!PROPERTIES ARE ALREADY KNOWN TO BE PRESENT. WE
	!WILL SIMPLY RECONVERT TO A MULTIPLY

	IF .CNODE[OPRCLS] EQL SPECOP THEN
	BEGIN
		!PICK UP POWER OF 2
		A2NODE_.CNODE[ARG2PTR];
		!REGENERATE THE CONSTANT
		CNODE[ARG2PTR]_
			MAKECNST(INTEGER,0,(1^(.A2NODE)+(.CNODE[OPERSP] EQL P2PL1OP)));
			CNODE[OPRCLS]_ARITHMETIC;
			CNODE[OPERSP]_MULOP;
	END ELSE
	IF NOT (REDUCOP(CNODE)) THEN RETURN(.CNODE);

	!NOW WE KNOW THAT THERE IS A POTENTIAL REDUCTION

	!LOOK AT THE VARIABLES INVOLVED

	IF .CNODE[ARG2PTR] EQL .INDVAR OR
	   .CNODE[ARG1PTR] EQL .INDVAR THEN
	ELSE
		RETURN(.CNODE);

	!CHECK FOR NOT FLAGS

	IF .CNODE[A1NOTFLG] OR .CNODE[A2NOTFLG] THEN RETURN(.CNODE);

	!FIND THE NODES

	A1NODE_.CNODE[ARG1PTR]; A2NODE_.CNODE[ARG2PTR];


	!PUT THE NODES IN THE RIGHT ORDER

	IF .A1NODE EQL .INDVAR THEN
	BEGIN
		SWAPARGS(CNODE);
		A1NODE_.CNODE[ARG1PTR];
		A2NODE_.CNODE[ARG2PTR];
	END;

	!IN THE EVENT THAT THE OTHER LEAF IS
	!NOT A CONSTANT IT MUST BE A LOOP CONSTANT OR WE ARE NOT
	!INTERESTED IN IT.

CHKREC:
	IF .A1NODE[OPR1] NEQ CONSTFL THEN
	BEGIN

		!MAKE SURE THE RESULT OF THE MULTIPLICATION IS
		!POSITIVE

		IF .CNODE[A1NEGFLG] AND .CNODE[A2NEGFLG]
			THEN
			ELSE
			IF .CNODE[A1NEGFLG] OR .CNODE[A2NEGFLG] THEN
				RETURN(.CNODE);

		!IF THE VARIABLE IS A .O AND TOLENTRY (INDICATING
		!THAT THE VARIABLE MOVED OUT OF THE LOOP)
		!THEN DO *NOT* REDUCE IT

		IF .A1NODE[IDDOTO] EQL SIXBIT".O" THEN
		BEGIN
			IF NOT .A1NODE[IDATTRIBUT(TOLENTRY)] THEN
				RETURN(.CNODE)
			ELSE
				LEAVE CHKREC;
		END;

		!LOOK AT THE LIST OF VARIABLES ON THE DOCHNGL LIST
		!FOR THIS LOOP. DEFINITION POINT INFO IS NO LONGER
		!AVAILABLE, NEITHER ARE THE SYMBOL TABLE FLAGS FROM
		!FROM THE DEFINITION POINT ALGORITHM.
		!SEE DEF0, AND DEFCHANGE FOR A DESCRIPTION OF
		!THE DOCHNGL LIST.
		!IF THIS IS ON AN I/O LIST WE ARE IN TROUBLE BECAUSE THE
		!OPTIMIZERS WORDS ARE NOT PRESENT. SO CHECK FOR
		!ZERO AND QUIT. IT IS IMPOSSIBLE FOR THE CONSTANT
		!TO BE DEFINED ON THE LIST (I HOPE)

		IF .TOP[SRCOPT] EQL 0 THEN
			!ASSUME ON I/O LIST
			LEAVE CHKREC;
		PA_.TOP[DOCHNGL];
		WHILE .PA NEQ 0 DO
		BEGIN
			IF .A1NODE EQL .PA[LEFTP] THEN
				RETURN(.CNODE);
			PA_.PA[RIGHTP];
		END;

		!IF WE GOT HERE IT IS A REGION CONSTANT
		!KEEP GOING**********

	END
	ELSE
	BEGIN

		!GENERATE CONSTANT WITH THE RIGHT SIGN

		IF .CNODE[A1NEGFLG] THEN
		BEGIN
			A1NODE_MAKECNST(INTEGER,0,-.A1NODE[CONST2]);
			CNODE[A1NEGFLG]_0
		END;
		IF .CNODE[A2NEGFLG] THEN
		BEGIN
			A1NODE_MAKECNST(INTEGER,0,-.A1NODE[CONST2]);
			CNODE[A2NEGFLG]_0
		END;
	END;

!********************************************************
!
!NOW WE HAVE A REDUCTION AND IT IS IN THE ORDER CONSTANT * INDVAR
!
!*******************************************************
	!SEE IF THIS REDUCTION HAS BEEN DONE BEFORE
	TEMP_0;
	!THE FORMAT OF THE LIST IS 
	!	LEFT HALF WORD POINTS TO REDUCTION VARIBALE
	!	RIGHT HALF POINTS TO CONSTANT
	IF .RDCCNT NEQ 0 THEN
	BEGIN
		INCR I FROM 1 TO .RDCCNT DO
			IF .RDCLST[.I]<RIGHT> EQL .A1NODE THEN
				TEMP_.RDCLST[.I]<LEFT>;
	END;
	!CHECK TO SEE IF THIS REDUCTION CAN BE SUBSUMED
	!USE A2NODE (INDVAR AT THIS POINT) AS A FLAG
	A2NODE_0;
	IF .TEMP EQL 0 THEN
	BEGIN
		PA_.CNODE[PARENT];
		!SAFETY CHECK ON THE VALIDITY OF THE POINTER
		IF .PA NEQ 0 THEN
			IF .PA[OPRCLS] EQL STATEMENT THEN
				IF .PA[OPERSP] EQL ASGNID THEN
				BEGIN
					PB_.PA[LHEXP];
					!IS IT A.O VARIABLE
					IF .PB[IDDOTO] EQL SIXBIT".O" THEN
					BEGIN
						!MAKE IT EASIER FOR US TO
						!READ THE CODE BY
						!CALLING IT A .R
						TEMP_.PB;
						TRANSMOGRIFY(.PB,SIXBIT'.R'+MAKNAME(RDCCT));
						!UPDATE RDCCT
						RDCCT_.RDCCT+1;

						!LINK THE .O ASSIGNMENT
						!OUT OF THE TREE
						PB_.TOP;
						LNKOUT:
						UNTIL .PB[SRCLINK] EQL .PA DO
						BEGIN
							!SAVE PB
							A2NODE_.PB;

							!IT COULD BE ON AN I/O
							!LIST OR IN THE TREE

							IF (.PB[SRCID] GEQ READID) AND
							(.PB[SRCID] LEQ ENCOID) THEN
							BEGIN
							IF (PB_ONIOLST(.PB[IOLIST],.PA) NEQ 0) THEN
								LEAVE LNKOUT;
							END ELSE  !I/O
							!IT COULD BE ON
							!A LOGICAL IF I/O LIST
							IF .PB[SRCID] EQL IFLID THEN
							BEGIN
							PB_.PB[LIFSTATE];
							IF (.PB[SRCID] GEQ READID) AND
							(.PB[SRCID] LEQ ENCOID) THEN
								IF (PB_ONIOLST(
								.PB[IOLIST],.PA) NEQ 0)
								THEN
								LEAVE LNKOUT;
							END;
							!RESTORE PB
							PB_.A2NODE;
							PB_.PB[SRCLINK];
						END;

						PB[SRCLINK]_.PA[SRCLINK];
						A2NODE_1;
					END;
				END;

		IF .A2NODE EQL 0 THEN
		TEMP_RDCTMP();

		!NOW ADD THIS ONE TO THE LIST. IF THE LIST OVERFLOWS REINITIALIZE
		!AND START AGAIN.
		IF .RDCCNT EQL 8 THEN
		BEGIN
			RDCCNT_0;
			INCR I FROM 0 TO 8 DO
				RDCLST[.I]_0;
		END;
		!WE ARE SURE WE CAN NOW ADD
		RDCCNT_.RDCCNT+1;
		RDCLST[.RDCCNT]<LEFT>_.TEMP;
		RDCLST[.RDCCNT]<RIGHT>_.A1NODE;

		NAME<LEFT>_ASGNSIZ+SRCSIZ;
		!BUILD  A NODE OF
		!	TEMP =M1*CONSTANT
		!AND  DO PHASE 2 SKELETON

		PA_CORMAN();
		PA[OPRCLS]_STATEMENT;
		PA[SRCID]_ASGNID;
		PA[LHEXP]_.TEMP;
		PA[A1VALFLG]_1;
		NEGFLG_NOTFLG_FALSE;

		T_PA[RHEXP]_ARSKOPT(MAKPR1(.PA,ARITHMETIC,MULOP,INTEGER,
				.TOP[DOM1],.A1NODE));
		IF .T[OPRCLS] EQL DATAOPR THEN
		BEGIN
			PA[A2VALFLG]_1;
			!IF ANY OF THE %&'#" NEG/NOT FLAGS
			!GOT SET TRANSFER THIS INFO TO THE STATEMENT
			!NODE
			IF .NEGFLG THEN
				PA[A2NEGFLG]_1
			ELSE
			IF .NOTFLG THEN
				PA[A2NOTFLG]_1;
		END;


		!LINK THIS STATEMENT IN FRONT OF THE DO LOOP
		!ALSO MOVE ANY LABEL THAT IS ON THE
		!PHYSICAL SUCCESSOR OF THE PLACE WHERE THE REDUCTION
		!INITILAIZATION IS INSERTED BACK TO THE REDUCTION.

		!IF THE CONSTANT IS NOT A GENUINE NUMERIC CONSTANT
		!THEN INSERT THE REDUCTION AFTER OTHER
		!OPTIMIZER STATEMENTS AT LENTRY OTHERWISE JUST
		!STICK IT AT LENTRY (REG ALLOC. WILL BE BETTER IN THE
		!LATTER CASE 'CUZ ANY INITIAL DO
		!DO VALUE COMPUTATION WILL IMMEDIATELY PRECEDE THE
		!REDUCTION).

		IF .A1NODE[OPR1] EQL CONSTFL THEN
			T_.LENTRY
		ELSE
			T_FINDTHESPOT(.LENTRY);

		!NOW LINK IT IN
		PA[SRCLINK]_.T[SRCLINK];
		T[SRCLINK]_.PA;

		!SET UP T FOR NEXT CODE SEQUENCE
		T_.PA[SRCLINK];

		IF .T[SRCLBL] NEQ 0 THEN
		BEGIN
			PB_PA[SRCLBL]_.T[SRCLBL];
			T[SRCLBL]_0;
			PB[SNHDR]_.PA;
		END;

		!
		!BUILD A NODE FOR
		!	TEMP=TEMP+CONSTANT*M3
		!
		NAME<LEFT>_ASGNSIZ+SRCSIZ;
		PA_CORMAN();
		PA[OPRCLS]_STATEMENT;
		PA[SRCID]_ASGNID;
		PA[LHEXP]_.TEMP;
		PA[A1VALFLG]_1;

		!THIS STATEMENT IS STILL WITHIN THIS LOOP SO IT WILL BE
		!LOCALLY OPTIMIZED NOW

			NEGFLG_NOTFLG_T_0;
		PB_ARSKOPT(MAKPR1(.PA,ARITHMETIC,MULOP,INTEGER,.TOP[DOM3],.A1NODE));

		!IF THE NEGFLG IS SET THEN CHANCES ARE THE STEP SIZE
		!IS -1. MKE SURE THE PROPER NEG FLG IS SET ON THE
		!NODES TO REFLECT THIS

		IF .NEGFLG OR .TOP[SSIZNEGFLG] THEN
			IF .PB[OPRCLS] EQL DATAOPR THEN
				T_1
			ELSE
				PB[A1NEGFLG]_NOT .PB[A1NEGFLG];
		NEGFLG_NOTFLG_FALSE;
		PA[RHEXP]_ARSKOPT(MAKPR1(.PA,ARITHMETIC,ADDOP,INTEGER,.PB,.TEMP));

		!IF WE WERE QUEUING A NEGFLG MAKE THE ADD A SUBTRACT
		IF .T THEN
			PB[A1NEGFLG]_NOT .PB[A1NEGFLG];

		!LINK THIS AT LOOP END
		!WANT TO LINK IT IN FRONT OF LEND. NEED TO FIND
		!THE STATEMENT IN FRONT OF LEND. IT HAS ALREADY
		!BEEN FOUND IF RDCLNK IS NOT ZERO. OTHERWISE WE
		!WILL DO A LINEAR SEARCH FOR IT

		IF .RDCLNK EQL 0 THEN
		BEGIN
			RDCLNK_.TOP;
			WHILE .RDCLNK[SRCLINK] NEQ .LEND DO
				RDCLNK_.RDCLNK[SRCLINK];
		END;

		!RDCLNK NOW POINTS TO THE PLACE
		T_.RDCLNK[SRCLINK];
		RDCLNK[SRCLINK]_.PA;
		PA[SRCLINK]_.T;

		!IF T IS LABELED AND IS NOT LEND THEN IT
		!MUST BE A PREVIOUS REDUCTION. IF IT IS LABELED
		!IT IS BECAUSE LEND WAS LABELED AND REFERENCED AS OTHER
		!THAN THE DO TERMINATOR. WE NEED TO MOVE THE LABEL
		!BACK TO THE NEW REDUCTION TOO.

		IF .T[SRCLBL] NEQ 0 AND .T NEQ .LEND THEN
		BEGIN
			PB_PA[SRCLBL]_.T[SRCLBL];
			T[SRCLBL]_0;
			PB[SNHDR]_.PA;
		END;

		!IF LEND IS LABELED AND THE LABEL IS REFERENCED
		!AS A TRANSFER THEN MOVE THE LABEL BACK
		!TO THE REDUCTION AND MAKE A NEW ONE FOR THE LOOP
		!TERMINATOR

		IF .LEND[SRCLBL] NEQ 0 THEN
		BEGIN
			T_.LEND[SRCLBL];
			IF .T[SNDOLVL] NEQ 0 AND .T[SNREFNO] NEQ 2 THEN
			BEGIN
				PB_GENLAB();
				!MOVE LABEL
				PA[SRCLBL]_.LEND[SRCLBL];
				T[SNHDR]_.PA;
				!MAKE PB THE NEW DO LABEL
				TOP[DOLBL]_.PB;
				PB[SNHDR]_.LEND;
				LEND[SRCLBL]_.PB;
				PB[SNREFNO]_2;
				PB[SNDOLVL]_.T[SNDOLVL];
				PB[SNDOLNK]_.T[SNDOLNK];
				!ZERO DO LOOP STUFF IN OLD
				!LABEL
				T[SNREFNO]_.T[SNREFNO]-2;
				T[SNDOLVL]_T[SNDOLNK]_0;
			END;
		END;
	END;		!HAVE NOT DONE THIS ONE YET


	!FIX UP THE VALFLGAS ON THE PARENT ONCE AND FOR
	!ALL HERE.

	PA_.CNODE[PARENT];
	IF .PA[OPRCLS] EQL STATEMENT THEN
	BEGIN
		IF .PA[SRCID] EQL ASGNID THEN
			PA[A2VALFLG]_1;
	END ELSE
	IF .PA[ARG1PTR] EQL .CNODE THEN
		PA[A1VALFLG]_1
	ELSE
		PA[A2VALFLG]_1;

	!FREE THE SPACE USED BY THE REDUCED NODE
	SAVSPACE(EXSIZ-1,.CNODE);


	!LINK USE OF TEMP INTO THE TREE BY RETURNING IT
	.TEMP
END;
!
!*******************************
GLOBAL ROUTINE RDUCINIT=
BEGIN
	!INITIALIZE REDUCTION STORAGE. CALLED FROM
	!PROPAGATE. IT IS HERE WITH THE CALL IN PROPAGATE
	!TO KEEP THE STORAGE OWN.

	RDCLNK_0 ;
	RDCCNT_0;

	INCR I FROM 0 TO 8 DO
		RDCLST[.I]_0;
END;

GLOBAL ROUTINE RDCTMP=
BEGIN
!CREATE A REDUCTION IN STRENGTH TEMPORARY

EXTERNAL SYMTYPE;

	SYMTYPE_INTEGER;
	NAME _ IDTAB;
	ENTRY_SIXBIT'.R' +MAKNAME(RDCCT);
	RDCCT_.RDCCT+1;
	TBLSEARCH()
END;
END
ELUDOM
