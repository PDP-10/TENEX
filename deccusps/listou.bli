!***COPYRIGHT 1973,DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
!AUTHOR F.INFANTE
MODULE LISOUT(RESERVE(0,1,2,3),SREG=#17,FREG=#16,VREG=#15,DREGS=4,GLOROUTINES)=
BEGIN

SWITCHES NOLIST;
REQUIRE FIRST.BLI;
REQUIRE TABLES.BLI;
REQUIRE REQREL.BLI;
SWITCHES LIST;

GLOBAL BIND LISOV = 2^18+53;		!VERSION DATE: 13-SEPT-1974
%(
REVISION HISTORY
39	-----	------	GENERATE SYMBOL TABLE ENTRIES FOR FORMAT STMNTS,
			USE THE SYMBOL "STMNT-NUMBER F"
40	-----	-----	FIX BUG IN EDIT 39
41	-----	-----	ADD ROUTINE "LSTFORMATS" TO LIST ALL FORMAT STMNTS
			AT THE END OF A MACRO-EXPANDED LISTING
42	-----	-----	FIX BUG IN LSTFORMATS TO LIST RELATIVE ADDRS
			CORRECTLY
43	-----	-----	CHANGE "OUTMDA" SO THAT WHEN PSYMPTR IS THE CODE
			"PBFFORMAT" WE EXPECT THE RIGHT HALF OF THE INSTR
			IN THE PEEPHOLE BUFFER TO CONTAIN A PTR TO THE
			FORMAT STMNT (RATHER THAN THE REL ADDR OF THE FORMAT STRING)
44	-----	-----	TAKE OUT DEFINITIONS OF LOADER BLOCK TYPES - PUT
			THEM INTO A SEPARATE "REQUIRE" FILE.
			ALSO REMOVE THE ROUTINES "ZOUTBLOCK" AND 
			"ZDMPBLK". ZOUTBLOCK HAS BEEN MOVED TO THE MODULE
			RELBUF. ZDMPBLK IS NO LONGER NEEDED.
			ALSO, EDIT "ZENDALL" TO OUTPUT ANY CODE
			LEFT IN THE BUFFERS SYMRLBF,LOCRLBF, AND MAINRLBF.
			ALSO REMOVE THE ROUTINE "DATAOUT", MAKE OUTDATA CALL
			ZOUTBLOCK INSTEAD.
			ALSO REMOVE THE ROUTINE DMPRELONLST.
			ALSO REMOVE ALL REFERENCES TO "RELOCPTR" AND "RELBLOCK"
			AND DELETE THEIR DEFINITIONS.
45	-----	-----	REMOVE THE ROUTINES: ZOUTMSG,ZOUTSYM,ZOUTOCT,RADIX50,
			ZOUDECIMAL,ZOUOFFSET.
			THESE HAVE BEEN PUT INTO THE MODULE "RELBUFF"
46	-----	-----	REMOVE THE ROUTINE LSTRLWD WHICH HAS BEEN
			PUT INTO THE MODULE RELBUF
47	-----	-----	TAKE OUT DEF OF THE MACRO "CRLF" - IT IS NOW
			IN THE REQUIRE FILE "REQREL"
48	-----	-----	REMOVE THE ROUTINE OUTDATA - ITS NOT NEEDED IN
			FORTG
49	-----	-----	IN ZENDALL - MUST CALL DMPMAINRLBF (TO DUMP
			ANY CODE IN THE BUFFER) BEFORE DUMPING
			THE CONTENTS OF THE FIXUP BUFFERS
50	-----	-----	IN LSTINST  MOVE THE OUTPUT OF THE MACRO
			LISTING HEADING TO PHA3 SO THAT THE SIXBIT FUNCTION
			NAME WILL COME OUT AFTER THE HEADING

			IN OUTMDA - CHANGE IT SO THAT IT PUTS OUT
			A CRLF AT THE BEGINNING OF EACH LINE INSTEAD OF
			AT THE END.  THIS WILL MATCH THE WAY LSTINST DOES
			IT AND STRAIGHTEN OUT THE LISTING

			PUT PAGEHEADING CHECKS IN BOTH OF THE ABOVE ROUTINES

51	-----	-----	PUT OUT F LABELS AT THE END OF FORMAT STRINGS IF
			THE FLAG "DBGLABL" IS SET; OUTPUT L LABELS FOR
			THE LINES IF THE FLAG "DBGLABL" IS SET. HAVE P
			LABELS AT START OF FORMAT STMNTS.
52	-----	-----	PUT OUT THE SYMBOL '.VEND' AFTER THE END
			OF THE SCALARS AND ARRAYS
53	-----	------	DO NOT PUT OUT THE EXIT UUO (HAVE CALL TO FOROTS
			EXIT.)
)%

!THE ROUTINES IN THIS MODULE ARE FOR THE PURPOSE
!OF GENERATING THE FOLLOWING THINGS:
%	THE MACRO EXPANDED LISTING OF THE CODE GENERATED
I	.THE GENERATION OF THE RELOCATABLE BINARY INFORMATION IN THE
	 .REL FILE
%
EXTERNAL ZOUTMSG,ZOUTSYM,ZOUTOCT,RADIX50,ZOUDECIMAL,ZOUOFFSET;
EXTERNAL HEADCHK;	!CHECKS LINE COUNT AND OUTPUTS HEADINGS
EXTERNAL RDATWD,RELOUT;	!CONTAINS CURRENT REL DATA WD
EXTERNAL ZOUTBLOCK;

EXTERNAL LSTOUT,ERROUT,
	LOWLOC,	!CURRENT LOWSEG AVAILABLE LOCATION
	HILOC,	!CURRENT HISEG AVAILABLE LOCATION
	RELBLOCK,	!RELOCATABLE BINARY BLOCK
	RELDATA,	!DATA WORD <LEFT> = CURRENT BLOCK NUMBER
				   !<RIGHT> = CURRENT DATA COUNT
	RELOCWD;	!THE RELOCATION WORD FOR THE BLOCK
!
MACRO EXITUUO = #047000000012$;
!
!
ROUTINE DMPSYMTAB=	!DUMPS THE SYMBOL TABLE TO REL FILE
BEGIN
EXTERNAL SYMTBL,LABTBL,FRSTLNK,RADIX50,ZOUTBLOCK,PROGNAME;
EXTERNAL FORMPTR;	!PTR TO 1ST FORMAT STMNT IN PROGRAM
OWN LABL;
LOCAL BASE  SYMPTR;
EXTERNAL ENDSCAA;


	ROUTINE BLDLABL=
	%(***************************
		LOCAL ROUTINE TO BUILD THE SIXBIT FOR THE
		DECIMAL FORM OF THE STMNT NUMBER IN THE REG "R1".
		CALLED WITH THE VAR "LABL" CONTAINING ONE
		SIXBIT CHAR IN THE LEFTMOST SIX BITS. LEAVES "LABL" CONTAINING
		THE STMNT NUMBER FOLLOWED BY THAT CHAR.
	****************************)%
	BEGIN
			DO (
				LABL _ .LABL ^(-6);
				R2 _ .R1 MOD 10; R1 _ .R1/10;
				LABL<30,6> _ (#20[.R2]<0,0>); !MAKING ROOM FOR NEXT
				IF .R1 EQL 0 THEN EXITLOOP;
	   		   ) WHILE 1;
	END;



	%(**DUMP THE SYMBOL TABLE***)%
	DECR I FROM SSIZ-1 TO 0 DO
	BEGIN
		IF (SYMPTR _ .SYMTBL[.I]) NEQ 0
		THEN BEGIN
			DO BEGIN
				IF .FLGREG<DBGDIMN>	!IF USER SPECIFIED THE "DEBUG" SWITCH
				THEN		! THEN FOR ALL ARRAYS WE WANT TO
						! PUT A PTR IN THE SYMBOL TABLE ENTRY POINTING
						! TO THE DIMENSION INFORMATION FOR THE ARRAY
				BEGIN
					IF .SYMPTR[OPRSP1] EQL ARRAYNM1
						AND NOT .SYMPTR[IDATTRIBUT(NOALLOC)]
					THEN
					BEGIN
						%(**USE THE KLUGE OF ADDING A 2ND ENTRY
						   FOR THE SAME SYMBOL IMMEDIATELY
							FOLLOWING ITS TRUE DEFINITION, WHERE THIS ENTRY
							POINTS TO THE DIMENSION INFORMATION**)%

						REGISTER BASE T1;
						R2_.SYMPTR[IDSYMBOL];
						RDATWD_RLOCDDTSUP+RADIX50();	!SUPPRESS THIS 2ND
								! DEF FROM DDT
						ZOUTBLOCK(RSYMBOL,RELN);
						T1_.SYMPTR[IDDIM];	!PTR TO DIMENS TABLE ENT
						T1_.T1[ARADLBL];	!PTR TO LABEL TABLE ENTRY FOR
								!LABEL ON DIMENS INFO ARG BLOCK
						RDATWD_.T1[SNADDR];	!REL ADDR OF LABEL
						ZOUTBLOCK(RSYMBOL,RELRI);
					END
				END;


				IF .SYMPTR[IDATTRIBUT(INCOM)]
				THEN
				  BEGIN
					MAP BASE R2;
					R2 _ .SYMPTR[IDSYMBOL]; RDATWD _ RLOCREQ+RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);
					RDATWD _ .SYMPTR[IDADDR];	!COMMON BLOCK OFFSET
					ZOUTBLOCK(RSYMBOL,RELN);
					R2 _ .SYMPTR[IDCOMMON]; R2 _ .R2[COMNAME];
					RDATWD _ RGLOBREQ + RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);
					R2 _ .SYMPTR[IDSYMBOL]; RDATWD _ RLOCFIX + RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);

				  END
				ELSE
				IF .SYMPTR[OPRSP1] NEQ FNNAME1 AND
				NOT .SYMPTR[IDATTRIBUT(NOALLOC)] THEN
				  BEGIN
					R2 _ .SYMPTR[IDSYMBOL];
					RDATWD _ RLOCREQ + RADIX50();
					ZOUTBLOCK(RSYMBOL,RELN);
					RDATWD _ .SYMPTR[IDADDR];
					ZOUTBLOCK(RSYMBOL,RELRI);

				  END;

			   END WHILE (SYMPTR _ .SYMPTR[CLINK]) NEQ 0;
		      END;
	END;
	!

	!OUTPUT A SYMBOL FOR THE WD AFTER THE END OF THE SCALARS AND ARRAYS
	R2_SIXBIT'.VEND';
	RDATWD_RLOCREQ+RADIX50();
	ZOUTBLOCK(RSYMBOL,RELN);
	RDATWD_.ENDSCAA;	!LOC AFTER END OF ARRAYS/SCALARS
				! (SET IN ALLSCA)
	ZOUTBLOCK(RSYMBOL,RELRI);
	!
	!
	!DUMP THE LOCAL LABLES NOW
	!
	DECR I FROM LASIZ-1 TO 0 DO
	BEGIN
	  IF (SYMPTR _ .LABTBL[.I]) NEQ 0 THEN
		BEGIN
		  DO BEGIN
			LABL _ 0;
			R1 _ .SYMPTR[SNUMBER];
			LABL<30,6> _ IF .R1 GTR 99999 THEN (R1 _ .R1-99999; SIXBIT "M" ) ELSE SIXBIT "P";
			BLDLABL();	!IN "LABL" BUILD THE SIXBIT FOR
					! THE STMNT NUMBER IN R1 (FOLLOWED BY THE CHAR
					! ALREADY IN "LABL"

			R2 _ .LABL;
			RDATWD _ RLOCREQ + RADIX50();
			ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD _ .SYMPTR[SNADDR];
			ZOUTBLOCK(RSYMBOL,RELRI);
!
		     END WHILE (SYMPTR _ .SYMPTR[CLINK]) NEQ 0;
		END;
	END;
!
!DUMP THE LOCAL TEMPORARIES NAMES
!
	WHILE .FRSTLNK NEQ 0
	DO (
		MAP BASE FRSTLNK;
		R2 _ .FRSTLNK[IDSYMBOL];
			RDATWD _ RLOCREQ + RADIX50();
			ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD _ .FRSTLNK[IDADDR];
			ZOUTBLOCK(RSYMBOL,RELRI);
		FRSTLNK _ .FRSTLNK[CLINK]
	   );

	!
	!DEFINE A LABEL OF THE FORM <STMNT NUMBER>F ON THE LAST WD
	! OF EACH FORMAT SRING
	IF .FLGREG<DBGLABL>
	THEN
	!
	BEGIN
		REGISTER BASE FPTR;	!PTR TO FORMAT STMNT NODE
		FPTR_.FORMPTR<LEFT>;	!1ST FORMAT STMNT IN PROGRAM
		UNTIL .FPTR EQL 0
		DO
		BEGIN
			SYMPTR_.FPTR[SRCLBL];	!STMNT NUMBER TABLE
					! ENTRY FOR THE LABEL ON THE FORMAT
			R1_.SYMPTR[SNUMBER];	!STMNT NUMBER ON THE FORMAT STMNT
			LABL_0;
			LABL<30,6>_SIXBIT"F";
			BLDLABL();	!SET "LABL" TO THE SIXBIT FOR
					! <STMNT NUMBER>F
			R2_.LABL;
			RDATWD_RLOCREQ+RADIX50();
			ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD_.FPTR[FORADDR]+.FPTR[FORSIZ]-1;	!ADDR OF LAST WD OF STRING
			ZOUTBLOCK(RSYMBOL,RELRI);
			FPTR_.FPTR[FMTLINK]	!GO ON TO NEXT FORMAT
		END;
	END;
END;	!OF DMPSYMTAB
ROUTINE ZSIXBIT(ZVAL)=	!CONVERT ZVAL TO SIXBIT SYMBOL
BEGIN
R2 _ SIXBIT 'P';
DECR I FROM 5 TO 0 DO
BEGIN
	R2 _ .R2^(-6); R2<30,6> _ (.ZVAL MOD 10) + #40; ZVAL _ .ZVAL/10;
	IF .ZVAL EQL 0 THEN EXITLOOP;
END;
RETURN .R2
END;
!
ROUTINE ZOUTCON=
BEGIN
!LIST A CONSTANT IN OCTAL ; R2 CONTAINS VALUE
CHR _ "["; LSTOUT();
DECR I FROM 11 TO 0 DO
BEGIN
	R1 _ 0; LSHC(R1,3);
	CHR _ .R1 + #60; LSTOUT();
END;
CHR _ "]"; LSTOUT()
END;
ROUTINE COMCOM=
BEGIN
	EXTERNAL LSTOUT;
	CHR_",";LSTOUT();LSTOUT()
END;


ROUTINE LSTINST(IPTR)=
BEGIN
%
ROUTNE LISTS ON LISTING DEVICE THE MACRO -10 MNEMONICS OF THE INSTRUCTIONS BEING GENERATED
%
MACRO
	IISN	= (@IPTR)<FULL>$,	!LINENUMBER OF INSTRUCTION
	ILABEL	= (@IPTR+1)<LEFT>$,
	IADDRPTR	= (@IPTR+1)<RIGHT>$,
	IOPCODE	= (@IPTR+2)<27,9>$,
	IAC	= (@IPTR+2)<23,4>$,
	IINDIR = (@IPTR+2)<22,1>$,
	IINDEX = (@IPTR+2)<18,4>$,
	IEFFADDR = (@IPTR+2)<RIGHT>$;
EXTERNAL CODELINES;
MACRO HEADRSW = CODELINES<LEFT>$;
LOCAL OPPOINT;
EXTERNAL OPMNEM;
!
ROUTINE ZLABLMAK(ILABLPT)=
BEGIN
%R1 CONTAINS LABEL IN BINARY%
MAP BASE ILABLPT;
R1_.ILABLPT[SNUMBER];
IF .R1 GTR 99999 THEN R1 _ .R1-99999; !REDUCE TO NICE RANGE
ZOUDECIMAL(); !OUTPUT VALUE OF R1 IN DECIMAL
		  IF .ILABLPT[SNUMBER] GTR 99999
			THEN CHR _ "M" ELSE CHR _ "P";
		  LSTOUT(); .VREG
END;	!OF ROUTINE ZMAKLABL

EXTERNAL  HEADCHK;		!CHECK AND COUNT LINES ON PAGE
EXTERNAL ZOUDLB;	!ROUTINE TO ADD TO THE MACRO EXPANDED LISTING A
			! LABEL THAT IS INSERTED ON THE 1ST INSTR OF EACH STMNT WHEN
			! THE USER HAS SPECIFIED THE "DEBUG" SWITCH
IF .HEADRSW NEQ #777777
	THEN(		CODELINES _ 0;
		HEADRSW _ #777777
	    );
CRLF;
HEADCHK();
IF (R1 _ .IISN) GEQ 0
	THEN IF .R1 EQL 0 THEN ( CHR _ "*"; LSTOUT()) ELSE ZOUDECIMAL();
CHR _ #11; LSTOUT(); !TAB
IF .IADDRPTR EQL PBFENTRY
	THEN(MAP BASE R2;
		CHR _ #15; LSTOUT(); CHR _ #12; LSTOUT(); CHR _ #11; LSTOUT();
		R2 _ .IEFFADDR; R2 _ .R2[IDSYMBOL]; ZOUTSYM();
		CHR _ ":"; LSTOUT();
		RETURN
	    );
!
!GEN THE RELATIVE LOCATION (OCTAL)
!
R2<LEFT> _ .CODELINES<RIGHT>; ZOUTOCT(); CHR _ #11; LSTOUT(); %TAB%
CODELINES _ .CODELINES + 1;
IF  .ILABEL NEQ 0 	!LIST A LABEL
  THEN 	(
	 LOCAL BASE LABPT;
	 LABPT _ .ILABEL;
	 DO
	 (
	 ZLABLMAK(.LABPT);
	 CHR _ ":"; LSTOUT(); CRLF; HEADCHK();
	 CHR _ #11; LSTOUT(); LSTOUT(); !TAB
         ) WHILE (LABPT _ .LABPT[SNNXTLAB]) NEQ 0;
	);

	IF (R1_.IISN) GTR 0 AND .FLGREG<DBGLABL>	!IF THE USER SPECIFIED THE "DEBUG" SWITCH
				! THEN IFTHIS INSTR STARTS A STMNT, LIST
				! AN "L" LABEL ON THIS INSTR
	THEN ZOUDLB();


CHR _ #11; LSTOUT();	!TAB
!NOW DO THE INSTRUCTION LISTING
!
IF .IOPCODE NEQ 0
THEN(
	OPPOINT _ (OPMNEM-#111)[.IOPCODE]<0,6>;	!MNEMONIC TABLE POINTER
	INCR I FROM 0 TO 5 DO
	  (CHR _SCANI(OPPOINT,CHR);	!GET A CHARACTER
	   IF(CHR _ .CHR + #40 ) LEQ #100 THEN EXITLOOP;
	   LSTOUT()
	  )
    );
CHR _ #11;	LSTOUT();	!TAB
!AC FIELD
!
IF .IAC LEQ 7 
  THEN (CHR _ .IAC + #60; LSTOUT())
   ELSE (CHR _ "1"; LSTOUT();
	 CHR _ (.IAC + #50); LSTOUT()
 	);
CHR _ ","; LSTOUT();
!
!INDIRECT BIT
!
IF .IINDIR NEQ 0 THEN (CHR _ "@"; LSTOUT());
!
!ADDRESS
!
BEGIN BIND ZADDR = IADDRPTR; MAP BASE ZADDR;
  IF .IADDRPTR GTR PBF2LABREF
    THEN
	(IF SYMBOL(ZADDR)
	  THEN ( R2 _ .ZADDR[IDSYMBOL];
		ZOUTSYM()
		)
	  ELSE IF .ZADDR[OPERSP] EQL CONSTANT
		THEN ( IF .ZADDR[DBLFLG] OR .ZADDR[VALTYPE] EQL REAL
			THEN(IF .ZADDR[CONADDR] EQL .IEFFADDR
				THEN R2 _ .ZADDR[CONST1]
				ELSE R2 _ .ZADDR[CONST2]
			    )
			ELSE R2 _ .ZADDR[CONST2]; !ELSE INTEGER OR LOGICAL OR BYTE
			RETURN ZOUTCON()
		     )
		ELSE
			(R2_.ZADDR[IDSYMBOL]; ZOUTSYM(););
	IF (R1 _ EXTSIGN(.IEFFADDR) -.ZADDR[IDADDR]) NEQ 0 THEN ZOUOFFSET();
       )
  ELSE IF .IADDRPTR GTR 3 THEN BEGIN END
    ELSE IF .IADDRPTR GTR 2
	THEN BEGIN MAP BASE R2;
		R2_.IEFFADDR; R2 _ .R2[IDSYMBOL];
		ZOUTSYM()
	     END
	ELSE IF .IADDRPTR GTR 1
		THEN !DOTTED FUNCTION NAME
		  (R2 _@(.IEFFADDR);
		   ZOUTSYM()
		  )
		ELSE  IF .IADDRPTR GTR 0	!NO SYMBOLIC ADDR
			THEN (R2<LEFT> _ .IEFFADDR; ZOUTOCT()) !IMMEDIATE MODE VALUE
			ELSE  ZLABLMAK(.IEFFADDR);
END;
!
!INDEX FIELD
!
IF .IINDEX NEQ 0
  THEN ( CHR _ "("; LSTOUT();
	IF .IINDEX LEQ 7
		THEN (CHR _ .IINDEX +#60; LSTOUT())
		ELSE (CHR _ "1"; LSTOUT();CHR _ .IINDEX +#50; LSTOUT()
		     );
	 CHR _ ")"; LSTOUT();
	);
END;	!OF ROUTINE LSTINST
ROUTINE ROUIMFUN(FUNCPTR,FUNAME)=	!OUTPUT FUNCTION REQUEST GLOBAL
BEGIN
			RDATWD_.FUNCPTR<LEFT>^18; ZOUTBLOCK(RCODE,RELN);
			R2 _ .FUNAME; !SIXBIT SYMBOL NAME
			RDATWD_(RGLOBREQ +RADIX50()); ZOUTBLOCK(RSYMBOL,RELN);
			RDATWD_RGLOB0^18 + .HILOC;
			ZOUTBLOCK(RSYMBOL,RELRI)
END;
ROUTINE ROURLABEL(LABLPTR)=
BEGIN
MAP BASE LABLPTR;
		 RDATWD<LEFT> _ .LABLPTR<LEFT>;
		IF .LABLPTR[SNSTATUS] NEQ OUTPBUFF  THEN 
			IF .LABLPTR[SNDEFINED] NEQ #777777 THEN(LABLPTR[SNADDR]_0;LABLPTR[SNDEFINED]_#777777);
		 RDATWD<RIGHT> _ .LABLPTR[SNADDR];
!
!AT THIS POINT RDATWD<RIGHT> CONTAINS EITHER 0 (IF FIRST TIME LABEL REFERENCED)
! OR A HI-SEG CHAIN ADDRESS IF NOT FIRST REFERENCE AND STILL UNDEFINED
! OR THE HI-SEG ADDRESS OF THE INSTRUCTION THE LABEL DEFINES
! THE VALUE OUTPBUFF MEANS THE LABEL HAS BEEN DEFINED TO LOADER
!
		 ZOUTBLOCK(RCODE,IF .LABLPTR[SNADDR] EQL 0 THEN RELN ELSE RELRI);
		!RELOCATE (RELRI) ONLY IF NOT FIRST REFERENCE
		IF  .LABLPTR[SNSTATUS] NEQ OUTPBUFF  THEN LABLPTR[SNADDR] _ .HILOC; !CHAIN THE REQUEST
END;	!END OF ROURLABEL
ROUTINE ROUSYM(INSTRUCTION,INSADDR)=	!RELOCATABLE SYMBOLIC OUTPUT
BEGIN
	MACRO ADD=3$,SUBT=4$;
	MACRO POLISHREL(OP,OPER1,RELOC1,OPER2,RELOC2,SYM)=
	BEGIN
		RDATWD _ OP;	!MEANS NEXT WD IS FULL WD OPERAND
		ZOUTBLOCK(RPOLISH,RELN);
		RDATWD _ OPER1;	!FULL WORD
		ZOUTBLOCK(RPOLISH,RELOC1);
		RDATWD _ OPER2;
		ZOUTBLOCK(RPOLISH,RELOC2);
		RDATWD _ #777777^18 + .HILOC;	!RIGHT HALF CHAINED FIXUP,, ADDRESS
		ZOUTBLOCK(RPOLISH,RELRI);
	END$;
		MAP BASE R2;
		LOCAL BASE SYMPTR; SYMPTR _ .INSADDR<RIGHT>;
		!NOW CHECK FOR SUBROUTINE OR FUNCTION CALL
		IF NOT SYMBOL(SYMPTR)
		THEN (RDATWD _ .INSTRUCTION;  ZOUTBLOCK(RCODE,RELRI);
			RETURN
		     );
		IF .SYMPTR[OPRSP1] EQL FNNAME1 
		  THEN 
			IF (NOT .SYMPTR[IDATTRIBUT(FENTRYNAME)])
				THEN IF (NOT .SYMPTR[IDATTRIBUT(DUMMY)])
					THEN (ROUIMFUN(.INSTRUCTION,.SYMPTR[IDSYMBOL]);
				RETURN
			);
		!HERE IF NOT A FUNCTION CALL OR SUBROUTINE CALL
		RDATWD _ .INSTRUCTION;
		IF ( EXTSIGN(.INSTRUCTION<RIGHT>)) LSS (-#400)
		THEN
			(RDATWD<RIGHT> _ 0;
			 ZOUTBLOCK(RCODE,RELN);
				IF NOT .SYMPTR[IDATTRIBUT(INCOM)] THEN
				 POLISHREL(ADD^18+1,EXTSIGN(.INSTRUCTION<RIGHT>),
					RELN,0,RELRI,.SYMPTR)	!GENERAT A POLISH FIXUP BLOCK
	   		ELSE
			   BEGIN
				RDATWD _ ADD^18+2;	!NEXT WD IS GLOBAL REQUEST
				ZOUTBLOCK(RPOLISH,RELN);
				R2 _ .SYMPTR[IDCOMMON]; R2 _ .R2[COMNAME];
				 RDATWD _ RGLOBDEF + RADIX50();  !A GLOBAL REQUEST POLISH FIXUP
				 ZOUTBLOCK(RPOLISH,RELN);
				  RDATWD _ #1777777;	!1^18 + -1
				 ZOUTBLOCK(RPOLISH,RELN);
				 RDATWD _ .INSTRUCTION<RIGHT>^18+#777777;
				 ZOUTBLOCK(RPOLISH,RELN);
				 RDATWD _ .HILOC^18;
				  ZOUTBLOCK(RPOLISH,RELL);  !FINALLY O/P THE FIXUP ADDRESS
			   END;
			   RETURN
			)
		ELSE
		IF .SYMPTR[IDATTRIBUT(INCOM)]
		    THEN	!GENERATE INSTRUCTION
		      (
			ZOUTBLOCK(RCODE,RELN);	!OUTPUT THE INSTRUCTION
			R2 _ .SYMPTR[IDCOMMON]; R2 _ .R2[COMNAME];
			RDATWD _ (RGLOBREQ + RADIX50());
			ZOUTBLOCK(RSYMBOL,RELN);	!OUTPUT SYMBOL BLOCK
			RDATWD _ RGLOB4^18 + .HILOC;	!THE FIXUP REQUEST
			ZOUTBLOCK(RSYMBOL,RELRI);
			RETURN
		      )
			ELSE ZOUTBLOCK(RCODE,RELRI);	!OUTPUT THE INSTRUCTION
 END;
FORWARD GMULENTRY;
ROUTINE OUTMOD(CODEPTR,	!PTR TO BLOCK OF CODE TO BE GENERATED
		COUNT)=		!#OF INSTRUCTIONS TO BE GENERATED
BEGIN
%
ROUTINE GENERATES THE RLOCATABLE BINARY INSTRUCTIONS FOR THE OMPILER. ALSO
RESPONSIBLE OFR CALLING ROUTINES THAT GENERATE THE MACRO CODE LISTING
AND THE ROUTINES THAT GENERATE SYMBOL INGORMATION FOR THE LOADER
%
EXTERNAL DEFISN;	!ROUTINE CALLED FOR 1ST INSTR OF EACH LINE TO
			! PUT OUT A LABEL CORRESPONDING TO THE LINE SEQ NUMBER
REGISTER CODEBLOCK;
MAP BASE R2;
MAP PEEPHOLE CODEPTR;
!
!LOOP ON COUNT WHERE COUNT IS THE NUMBER OF INSTRUCTIONS TO BE GENERATED
!BUT ONE-HALF THE SIZE OF THE CODE BLOCK
!
CODEBLOCK _ .CODEPTR<RIGHT>;
IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE> 
THEN  INCR I FROM 0 TO .COUNT-1  DO
	LSTINST((.CODEBLOCK)[.I*3]);
!START RELOCATABLE BINARY GENERATON IF REQUESTED
IF .FLGREG<OBJECT>
THEN 
     INCR I FROM 0 TO (.COUNT-1) DO
     BEGIN
	LABEL REL1;
  REL1: IF .CODEPTR[.I,PBFSYMPTR] GTR PBFENTRY
	  THEN (ROUSYM(.CODEPTR[.I,PBFINSTR],.CODEPTR[.I,PBFSYMPTR]); LEAVE REL1)	!SYMBOLIC- IDENTIFIER,CONSTANT OR TEMP
	  ELSE		!EITHER NOT SYMBOLIC, OR LABEL OR FUNCTION CALL OR LIBRARY FUNCTION CALL "DOTTED"
	   CASE .CODEPTR[.I,PBFSYMPTR] OF SET
	%
	0 - LABEL ADDRESS - PTR TO LABEL IN RH OF INSTRUCTION
	%
		ROURLABEL(.CODEPTR[.I,PBFINSTR]);	!RELOCATABLE LABEL O/P
	%
	1- NO SYMBOLIC ADDRESS OUTPUT THE INSTRUCTION
	%
		BEGIN
			RDATWD _ .CODEPTR[.I,PBFINSTR];
			ZOUTBLOCK(RCODE,RELN);
			LEAVE REL1
		END;
	%
	2- FUNCTION CALL DOTTED
	%
		ROUIMFUN(.CODEPTR[.I,PBFINSTR],@(.CODEPTR[.I,PBFADDR]));	!RELOCATABLE  IMPLICIT FUNCTION CALL
	%3- FUNCTION CALL NOT "DOTTED"
	%
		BEGIN MAP BASE R2;
			R2_.CODEPTR[.I,PBFADDR];
			ROUIMFUN(.CODEPTR[.I,PBFINSTR],.R2[IDSYMBOL]);
		END;
	%4-USED IN OUTMDA, NOT HERE
	%
	BEGIN END;
	%5-USED IN OUTMDA, NOT HERE
	%
	BEGIN END;
	%6-USED IN OUTMOD, NOT HERE
	%
	BEGIN END;
	%7-USED IN OUTMDA, NOT HERE
	%
	BEGIN END;
	%8-PBFENTRY, A GLOBAL ENTRY SYMBOL
	%
	BEGIN
		GMULENTRY(.CODEPTR[.I,PBFADDR]); !SPECIAL CASE FOR GLOBAL ENTRY DEFINITIONS(NOT AN INSTRUCTION)
		HILOC _ .HILOC-1; !DECREMENT HILOC TO OFFSET THE INCREMENT
					!COMING AT END OF LOOP SO THAT
					!NEXT INSTRUCTION WILL HAVE SAME ADDR
					!AS THAT ASSIGNED TO ENTRY SYMBOL
	END
	TES;
!
!LEAVE REL1 EXPRESSION COMES HERE
!
	IF .CODEPTR[.I,PBFLABEL] NEQ 0
	 THEN
	(LOCAL BASE LINLABEL;
	 LINLABEL _ .CODEPTR[.I,PBFLABEL];
	 DO
	 BEGIN
	 IF .LINLABEL[SNADDR] GEQ #3000! ASSUME NO MORE THAN 3000 REFERENCES ELSE DEFINED
	 THEN (
		RDATWD _ .LINLABEL[SNADDR]^18+.HILOC;
		ZOUTBLOCK(RLOCAL,RELB);
		);
	   LINLABEL[SNSTATUS]_OUTPBUFF;	!DEFINE IT (HAS PASSED THRU PBUFF)
	   LINLABEL[SNADDR] _ .HILOC;	!DEFINING THE SYMBOL NOW
	 END WHILE (LINLABEL_.LINLABEL[SNNXTLAB]) NEQ 0;
	);

	%(***IF THIS INSTRUCTION STARTS A SOURCE LINE, THEN
		IF THE "DEBUG" SWITCH WAS SPECIFIED BY THE USER, OUPUT A LABEL FOR THIS INSTR**)%
	IF .CODEPTR[.I,PBFISN] GTR 0 AND .FLGREG<DBGLABL> THEN DEFISN(.CODEPTR[.I,PBFISN]);

	HILOC _ .HILOC + 1;	!INCREMENT HISEG AVAILABLE LOCATION
      END;	!END OF INCR LOOP
.VREG
END;	!OF ROUTINE
GLOBAL ROUTINE OUTMDA(ARPTR,ARCOUNT)=
BEGIN
%
	ROUTINE OUTPUTS TO THE REL FILE THE ARG BLOCKS
	FOR ALL STATEMENTS THAT USE THEM. THESE INCLUDE IOLISTS,
	FUNCTION OR SUBROUTINE ARGUMENTS LISTS, AND
	OTHER ARG LISTS.

	THE CALL IS MADE TO THIS ROUTINE WITH A PTR TO THE ARGUMENT
	CODE WORDS AND A COUNT OF THE NUMBER OF WORDS TO GENERATE.
	THE FORMAT OF THE BLOCK OF WORDS IS SIMILAR TO THAT USED
	IN A CAL TO OUTMOD TO OUTPUT INSTRUCTIONS.
%

EXTERNAL ZOUDECIMAL;
EXTERNAL ZOUOFFSET;
EXTERNAL CODELINES,LSTOUT,ZLABLMAK,ZOUTOCT,COMCOM,OUTMSG,ZOUTSYM;
MAP BASE R1:R2;
OWN HDRSW;
MACRO ILABEL = (@ARPTR)[.I+1]<LEFT>$,
	IADDRPTR = (@ARPTR)[.I+1]<RIGHT>$,
	ILADDR = (@ARPTR)[.I+2]<LEFT>$,
	IRADDR = (@ARPTR)[.I+2]<RIGHT>$,
	IARGWD = (@ARPTR)[.I+2]<FULL>$;

!
INCR I FROM 0 TO (.ARCOUNT-1)*3 BY 3 DO
  BEGIN
	IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE> 
	THEN
	BEGIN
		EXTERNAL HEADCHK;
		CRLF;
		HEADCHK();
		CHR _ #11;LSTOUT();
		R2<LEFT> _ .CODELINES<RIGHT>; ZOUTOCT(); CHR _ #11; LSTOUT();
		CODELINES _ .CODELINES+1;
		IF .ILABEL NEQ 0 THEN(ZLABLMAK(.ILABEL); CHR_":"; LSTOUT());
		CHR_#11; LSTOUT(); !TAB
	END;
	SELECT .IADDRPTR OF NSET
	PBFLABREF:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT>_.ILADDR; ZOUTOCT();
			 COMCOM(); ! ",,"
			 ZLABLMAK(.IRADDR); 
			END;
			IF .FLGREG<OBJECT> THEN
				ROURLABEL(.IARGWD);
			);

	PBFNOSYM:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT>_.ILADDR; ZOUTOCT();
			 COMCOM();
			 R2<LEFT>_.IRADDR; ZOUTOCT();
			END;
			IF .FLGREG<OBJECT> THEN
			 (RDATWD _ .IARGWD; ZOUTBLOCK(RCODE,RELN));
			);
	PBF2NOSYM:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT>_.ILADDR; ZOUTOCT();
			 COMCOM();
			 R2<LEFT>_.IRADDR; ZOUTOCT();
			END;
			IF .FLGREG<OBJECT> THEN
			 (RDATWD _ .IARGWD; ZOUTBLOCK(RCODE,RELN));

			);
	PBFIMFN:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT> _ .ILADDR; ZOUTOCT();
			 COMCOM();
			 R2 _ @.IRADDR; ZOUTSYM();
			END;
			IF .FLGREG<OBJECT> THEN
			  ROUIMFUN(.IARGWD,@.IRADDR);

			);
	PBFEXFN:	EXITSELECT
			(
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 R2<LEFT> _ .ILADDR; ZOUTOCT();
			 COMCOM();
			 R2 _ .IRADDR; R2 _ .R2[IDSYMBOL]; ZOUTSYM();
			END;
			IF .FLGREG<OBJECT> THEN
			 (R2_.IRADDR; ROUIMFUN(.IARGWD,.R2[IDSYMBOL]));
			);
	PBF2LABREF:	EXITSELECT
			(IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			BEGIN
			 ZLABLMAK(.ILADDR); COMCOM(); ZLABLMAK(.IRADDR);
			END;
			IF .FLGREG<OBJECT> THEN
			 (R1 _ .ILADDR; R2 _ .IRADDR;
			  RDATWD _ .R1[SNADDR]^18 +  .R2[SNADDR];
			  ZOUTBLOCK(RCODE,RELB);
			 );
			);
	PBFFORMAT:	EXITSELECT
			BEGIN
			  REGISTER BASE TPTR;	!TEMPORARY PTR
			  IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			   BEGIN
				R2<LEFT> _.ILADDR; ZOUTOCT();
				COMCOM();
				!TYPE THE F LABEL FOR THE RIGHT HALF
				TPTR_.IRADDR;	!PTR TO THE FORMAT STMNT
				TPTR_.TPTR[SRCLBL];	!STMNT NUMBER TABLE ENTRY FOR THE LABEL
				R1_.TPTR[SNUMBER]; ZOUDECIMAL();	!THE STMNT NUMBER OF THE FORMAT
				CHR_"F"; LSTOUT();	! FOLLOWED BY "F"
			   END;
			  IF .FLGREG<OBJECT> THEN
			   BEGIN
				TPTR_.IRADDR;	!PTR TO FORMAT STMNT
				RDATWD_.ILADDR^18	!LEFT HALF OF OUTPUT WD COMES DIRECTLY FROM PBUFF
					+ .TPTR[FORADDR];	!RIGHT HALF IS REL ADDR OF THE FORMAT STMNT
				 ZOUTBLOCK(RCODE,RELRI);
			   END;
			END;
	OTHERWISE:	BEGIN
			IF .FLGREG<LISTING> THEN IF .FLGREG<MACROCODE>  THEN
			(
			 R2<LEFT> _ .ILADDR; ZOUTOCT();
			 COMCOM();
			  R2 _ .IADDRPTR;
			   IF .R2[OPERSP] EQL CONSTANT
				THEN ( IF .R2[VALTYPE] EQL REAL OR .R2[DBLFLG]	!THIS DEPENDENT ON VALTYPE VALUES
					THEN R2 _ .R2[CONST1] !THEN REAL DP OR CMPLX
					ELSE R2 _ .R2[CONST2]; !ELSE INTEGER OR LOGICAL OR BYTE
					 ZOUTCON()
					)
				ELSE (R2 _ .R2[IDSYMBOL]; ZOUTSYM();
					R2 _ .IADDRPTR;
					IF (R1 _ EXTSIGN(.IRADDR) - .R2[IDADDR]) NEQ 0 THEN ZOUOFFSET();
				     );
			);
			IF .FLGREG<OBJECT> THEN ROUSYM(.IARGWD,.IADDRPTR);
			END;
	TESN;
	IF .FLGREG<OBJECT> THEN
	(IF .ILABEL NEQ 0
	THEN
	BEGIN
		REGISTER BASE LABENT;
		LABENT_.ILABEL;
		IF .LABENT[SNADDR] GTR #3000	!ARBITARY # OF REFERENCES
		THEN (
			RDATWD _ .LABENT[SNADDR]^18+.HILOC;
			ZOUTBLOCK(RLOCAL,RELB);
		     );
		LABENT[SNSTATUS] _ OUTPBUFF;	!THRU THE OUTPUT BUFFFER
		LABENT[SNADDR] _ .HILOC;	!DEFINING THE SYMBOL NOW
	END;
	HILOC _ .HILOC + 1;	!INCREMENT HISEG AVAILABLE LOCATION
	);
  END; !OF INCR I DO
END;	!OF OUTMDA
GLOBAL ROUTINE ZENDALL(STADDR)=	!FINISHES OUTPUT OF REL FILE
			!FOR CURRENT PROGRAM
			!DUMPS SYMBOL DTABLE
			!DUMPS NEWLY DEFINED SYMBOLS
			!OUTPUTS "END" BLOCK
BEGIN
EXTERNAL ENDISNRLBLK;
EXTERNAL DMPRLBLOCK;	!ROUTINE TO DUMP A BUFFERED REL-FILE BLOCK OUT
EXTERNAL ZOUTBLOCK,RADIX50,PROGNAME,DMPSYMTAB;
EXTERNAL SYMRLBF,LOCRLBF,MAINRLBF;	!REL FILE  BUFFERS
	EXTERNAL DMPMAINRLBF;	!TO DUMP THE MAIN REL-FILE BUFFER
MAP RELBUFF SYMRLBF:LOCRLBF:MAINRLBF;
	IF .FLGREG<DBGLABL> THEN ENDISNRLBLK();	!IF THE  USER SPECIFIED
					! THE "DEBUG" SWITCH, OUTPUT THE SYMBOL DEFS FOR ANY
					! LABELS REMAINING IN THE BUFFER OF LABELS TO BE INSERTED
					! ON EACH SOURCE LINE
	DMPSYMTAB();	!DUMP THE SYMBOL TABLE TO REL FILE

	%(**DUMP ANY LOCAL REQUESTS,GLOBAL REQUESTS, AND SYMBOL DEFS THAT
		ARE STILL IN THEIR BUFFERS**)%
	DMPMAINRLBF();	!MUST OUTPUT ANY CODE BLOCKS TO THE REL FILE
			! BEFORE DUMPING LOCAL AND G;LOBAL REQUESTS
	IF .SYMRLBF[RDATCNT] NEQ 0 THEN DMPRLBLOCK(SYMRLBF,.SYMRLBF[RDATCNT]+2);
	IF .LOCRLBF[RDATCNT] NEQ 0 THEN DMPRLBLOCK(LOCRLBF,.LOCRLBF[RDATCNT]+2);

	IF .FLGREG<PROGTYP> EQL MAPROG  THEN (RDATWD _ .STADDR; ZOUTBLOCK(RSTART,RELRI)); !START ADDRESS BLOCK
	 RDATWD_.HILOC; ZOUTBLOCK(REND,RELRI);
	RDATWD _ .LOWLOC; ZOUTBLOCK(REND,RELRI);
	IF .MAINRLBF[RDATCNT] NEQ 0 THEN DMPRLBLOCK(MAINRLBF,.MAINRLBF[RDATCNT]+2);
END;
ROUTINE GMULENTRY(MULSYM)=
BEGIN
!GENERATE AN ENTRY DEFINITION (GLOBAL) IN REL FILE FOR MULTIPLE ENTRY
!NAMES; OUTMOD MUST HAVE  ALREADY BEEN CALLED TO DUMP ANY CODE IN PBUFF
!
MAP BASE MULSYM;
	R2 _ .MULSYM[IDSYMBOL];
	RDATWD _ (RGLOBDEF+RADIX50());
	ZOUTBLOCK(RSYMBOL,RELN);
	RDATWD _ .HILOC<RIGHT>;
	ZOUTBLOCK(RSYMBOL,RELRI)
END;



GLOBAL ROUTINE LSTFORMATS=
%(***************************************************************************
	ROUTINE TO LIST ALL THE FORMAT STMNTS IN A PROGRAM.
	ASSUMES THAT THE GLOBAL "FORMPTR" POINTS TO THE 1ST
	FORMAT STMNT. EACH FORMAT STMNT IS LINKED TO THE
	NEXT BY THE "FMTLINK" FIELD
***************************************************************************)%
BEGIN
	EXTERNAL PAGELINE,STRNGOUT,HEADING;
	EXTERNAL ZOUDECIMAL;
	EXTERNAL FORMPTR;
	LOCAL RLOC;	!RELATIVE LOC IN LOW SEG OF THE WD BEING LISTED
	LOCAL BASE SNENTRY;	!THE STMNT NUMBER TABLE ENTRY FOR
				! THE STMNT NUMBER FOR A GIVEN FORMAT STMNT
	REGISTER BASE FPTR;	!PTR TO THE FORMAT STMNT BEING PRINTED
	REGISTER CPTR;		!BYTE PTR TO THE CHARACTER IN THE STRING
				! TO BE LISTED



	IF (FPTR_.FORMPTR<LEFT> ) EQL 0	!IF THERE ARE NO FORMAT STMNTS IN THIS PROGRAM
	THEN RETURN;

	%(**PRINT HEADER**)%
	IF ( PAGELINE_.PAGELINE-4) LEQ 0
	THEN	( HEADING();  PAGELINE_.PAGELINE-4);
	STRNGOUT(PLIT ASCIZ'?M?J?M?JFORMAT STATEMENTS (IN LOW SEGMENT):?M?J?M?J');


	%(***LIST ALL FORMAT STMNTS IN PROGRAM**)%
	UNTIL .FPTR EQL 0
	DO 
	BEGIN
		R1_.FPTR[SRCISN]; ZOUDECIMAL();	!LINE NUMBER OF THIS FORMAT STMNT
		CHR_#11; LSTOUT();	!TAB
		RLOC_.FPTR[FORADDR];	!RELATIVE ADDRESS OF THE 1ST WD OF THE
					! STRING
		R2<LEFT>_.RLOC;  ZOUTOCT();	!LIST IT
		CHR_#11; LSTOUT();	!TAB

		!LIST THE "P" LABEL
		SNENTRY_.FPTR[SRCLBL];	!LABEL TABLE ENTRY FOR THE STMNT NUMBER
		R1_.SNENTRY[SNUMBER];	!STMNT NUMBER
		ZOUDECIMAL();		!LIST IT
		CHR_"P"; LSTOUT();	! FOLLOWED BY "P"
		CHR_":"; LSTOUT();	! FOLLOWED BY ":"
		CHR_#11;  LSTOUT();	!TAB


		!LIST THE 1ST WD OF THIS FORMAT STRING
		CPTR_(.FPTR[FORSTRING]-1)<0,7>;	!BYTE PTR TO CHAR PRECEEDING
					! THE 1ST CHAR OF THE STRING
		DECR I FROM 4 TO 0	!LIST 5 CHARS
		DO
		(CHR_SCANI(CPTR); LSTOUT());	!INCR BYTE PTR TO NEXT CHAR AND LIST THAT CHAR

		CRLF;
		HEADCHK();

		!LIST ALL WDS OF THE FORMAT STRING AFTER THE 1ST,
		! PRECEEDING EACH BY ITS RELATIVE ADDRESS
		DECR I FROM .FPTR[FORSIZ]-2 TO 0	
		DO
		BEGIN
			CHR_#11;  LSTOUT();	!TAB
			RLOC_.RLOC+1;		!RELATIVE LOC OF THIS WD
			R2<LEFT>_.RLOC;
			ZOUTOCT();		!LIST IT
			CHR_#11;  LSTOUT();	!TAB
			CHR_#11;  LSTOUT();
			DECR I FROM 4 TO 0	!LIST 5 CHARS
			DO
			(CHR_SCANI(CPTR); LSTOUT());	!INCR BYTE PTR TO NEXT CHAR AND LIST IT

			CRLF;
			HEADCHK();
		END;

		FPTR_.FPTR[FMTLINK];	!GO ON TO THE NEXT FORMAT STMNT
	END;
END;	!OF ROUTINE LSTFORMATS
