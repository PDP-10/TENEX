!COPYRIGHT 1974, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS
!AUTHORS: NORMA ABEL AND SARA MURPHY/HPW
MODULE REGU(RESERVE(0,1,2,3),SREG=#17,VREG=#15,FREG=#16,DREGS=4,GLOROUTINES)=
BEGIN

GLOBAL BIND REGUV = 2^24 + 0^18 + 21;	!VERSION DATE: 27-JUNE-74


%(
REVISION HISTORY

17	-----	-----	CREATE MODULE
18	-----	-----	TAKE LASTONE OUT AND PUR IT BACK IN UTIL
19	-----	-----	MAKE ALODIMCONSTS ALLOCATE CONSTANTS FOR PROTECTED
			ARRAYS WHEN "DEBUG" SWITCH NOT SET
20	-----	-----	MODIFY ALODIMCONSTS TO ALLOCATE CONSTS FOR
			ARRAY DIMENSIONS WHEN EITHER THE "BOUNDS" SWITCH
			OR THE "DEBUG" SWITCH IS SET (WE NO LONGER PROTECT
			INDIVIDUAL ARRAYS - ONLY ALL ARRAYS)
21	-----	-----	CHANGE REF TO THE FLAG "DEBUG" TO REF TO "DBGDIMN"
)%

SWITCHES NOLIST;
REQUIRE FIRST.BLI;
REQUIRE TABLES.BLI;
SWITCHES LIST;

GLOBAL ROUTINE MAKRC0(VTYPE)=
%(***************************************************************************
	ROUTINE TO MAKE A REGCONTENTS NODE FOR REG 0 HAVING TYPE "VTYPE".
	 THESE NODES WILL BE SUBSTITUTED FOR THE LHS OF ALL STMNT
	FNS (SUBSTITUTION IS DONE DURING REG ALLOC PASS).
***************************************************************************)%
BEGIN
	EXTERNAL NAME,CORMAN;	!USED TO GET SOME FREE CORE

	OWN PEXPRNODE REGC0;

	NAME<LEFT>_EXSIZ;	!NUMBER OF WDS IN AN EXPRESSION NODE
	REGC0_CORMAN();		!GET FREE STORAGE FOR THE NODE

	REGC0[VALTYPE]_.VTYPE;
	REGC0[OPRCLS]_REGCONTENTS;
	REGC0[INREGFLG]_1;
	REGC0[TARGTAC]_RETREG;	!THE REG USED FOR RETURNING FN VALS (REG 0)
	REGC0[TARGADDR]_RETREG;
	RETURN .REGC0		!RETURN A PTR TO THE NODE
END;

GLOBAL ROUTINE ALODIMCONSTS=
%(***************************************************************************
	ROUTINE TO ALLOCATE CORE FOR ALL CONSTANTS THAT OCCUR IN
	SPECIFICATIONS OF DIMENSION INFORMATION FOR 
	ARRAYS  WHEN THE "BOUNDS" SWITCH OR THE "DEBUG" SWITCH IS SET.
***************************************************************************)%
BEGIN
	EXTERNAL SYMTBL;
	EXTERNAL ALDIM1;
	REGISTER BASE SYMPTR;

	IF NOT (.FLGREG<BOUNDS> OR .FLGREG<DBGDIMN>) THEN RETURN;	!WILL ALLOCATE THE DIM CONSTS IF
					! THE USER SPECIFIED ARRAY BOUNDS CHECKING TO BE DONE
					! OR DEBUGGING INFO TO BE PASSED TO FORDDT


	%(***WALK THRU THE SYMBOL TABLE AND FOR EACH ENTRY WHICH IS
		AN ARRAY NAME, PROCESS THE DIMENSION INFO FOR THAT ARRAY.
		THIS IS NECESSARY BECAUSE THERE IS NO WAY TO DIRECTLY WALK
		THRU THE DIMENSION TABLE
	****)%
	DECR I FROM SSIZ-1 TO 0
	DO
	BEGIN
		SYMPTR_.SYMTBL[.I];
		UNTIL .SYMPTR EQL 0	!LOOK AT EACH SYMBOL THAT HASHED
					! TO ENTRY "I"
		DO
		BEGIN
			IF .SYMPTR[OPRSP1] EQL ARRAYNM1	!IF THIS AN ENTRY FOR AN ARRAY NAME
			THEN
			 ALDIM1(.SYMPTR[IDDIM]);	! ALLOCATE ALL CONSTS IN ITS DIM TABLE ENTRY
			SYMPTR_.SYMPTR[CLINK]
		END
	END
END;


GLOBAL ROUTINE ALDIM1(DIMPTR)=
%(***************************************************************************
	ROUTINE TO GO THRU A DIMENSION TABLE ENTRY ALLOCATING CORE FOR ALL CONSTANTS
	USED IN THAT ENTRY. THIS ROUTINE IS CALLED:
		1. WHEN THE USER HAS SPECIFIED THE "DEBUG" SWITCH
			INDICATING THAT ALL DIMENSION TABLE INFORMATION
			SHOULD BE OUTPUT.
		2. WHEN THE USER HAS SPECIFIED THAT THIS PARTICULAR ARRAY
		   SHOULD BE "PROTECTED".
***************************************************************************)%
BEGIN
	EXTERNAL ALOCONST;	!ROUTINE TO SET FLAG IN CONST TABLE
				! ENTRY INDICATING THAT CORE SHOULD BE ALLOCATED
				! FOR THIS CONST
	MAP BASE DIMPTR;	!PTR TO THE DIMENSION TABLE ENTRY
	REGISTER DIMSUBENTRY DIMLSTPTR;	!PTR TO THE SUBENTRY FOR A GIVEN DIMENSION

	IF NOT .DIMPTR[ADJDIMFLG]	!IF THIS ARRAY HAS NO ADJUSTABLE DIMENSIONS
	THEN ALOCONST(.DIMPTR[ARAOFFSET]);	! THEN THE "OFFSET" WILL BE CONST - ALLOCATE CORE FOR IT


	DIMLSTPTR_DIMPTR[FIRSTDIM];	!PTR TO SUBENTRY FOR 1ST DIMENSION

	DECR CT FROM (.DIMPTR[DIMNUM] - 1) TO 0	!LOOK AT THE SUBENTRY FOR EACH DIMENSION
	DO
	BEGIN
		IF NOT .DIMLSTPTR[VARLBFLG]	!IF THE LOWER BOUND IS A CONST
		THEN ALOCONST(.DIMLSTPTR[DIMLB]);	! ALLOCATE CORE FOR IT
		IF NOT .DIMLSTPTR[VARUBFLG]	!IF THE UPPER BOUND IS A CONST
		THEN ALOCONST(.DIMLSTPTR[DIMUB]);
		IF NOT .DIMLSTPTR[VARFACTFLG]	!IF THE FACTOR FOR THIS DIMENSION IS A CONST
		THEN ALOCONST(.DIMLSTPTR[DIMFACTOR]);

		DIMLSTPTR_.DIMLSTPTR+DIMSUBSIZE
	END
END;


GLOBAL ROUTINE ALOCONST(CNODE)=
%(***************************************************************************
	ROUTINE TO SET A FLAG INDICATING THAT THIS CONSTANT SHOULD HAVE CORE
	ALLOCATED FOR IT.
	THIS SHOULD PROBABLY BE MADE A MACRO AT SOME POINT.
***************************************************************************)%
BEGIN
	MAP BASE CNODE;

	CNODE[CNTOBEALCFLG]_1;
	.CNODE
END;


EXTERNAL LSTLNK;			!USED TO LINK ENTRIES TOGETHER
EXTERNAL FRSTLNK;		!POINTER TO HEAD OF LIST OF TEMPS
EXTERNAL FTEMP;			!FIRST TEMP AVAILABLE FOR USE BY
				!SKELETON REGISTER ALLOCATOR
				!ZERO IF NONE EXISTS.
EXTERNAL ANCHOR;		!ALWAYS POINTS TO START OF LIST
MAP PEXPRNODE LSTLNK;


!MACRO TO MAKE A TEMPORARY NAME FROMA NUMBER
!THE GLOBAL CONTAINING  THE NUMBER IS THE SAME AS
!THE OPTIMIZER USES FOR REDUCTION IN STRENGTH.

MACRO MAKNAME(NUMB)=
	(.NUMB<9,3>+16)^18 + (.NUMB<6,3>+16)^12
	+ (.NUMB<3,3>+16)^6 + (.NUMB<0,3>+16)$;


GLOBAL ROUTINE MAKTEMP =
BEGIN
!CREATE A SYMBLOL TABLES LIKE ENTRY FOR A TEMPORARY FOR
!PHASE 2 SKELETON AND PHASE 2
EXTERNAL CORMAN;
REGISTER T;
EXTERNAL RDCCT;
MAP PEXPRNODE T;
	NAME<LEFT> _ IDSIZ;		!ENTRY IS 5 WORDS LONG
	T_CORMAN();		!GET CORE FOR ENTRY
	IF .LSTLNK EQL 0 THEN
		(ANCHOR_FRSTLNK_.T)
	ELSE
		 LSTLNK[CLINK] _ .T;	!LINK INTO LIST
	LSTLNK _ .T;
	T[CLINK] _ 0;		!MARKER FOR LAST IN LIST
	T[OPRCLS] _ DATAOPR;		!DATA OPERATOR
	T[OPERSP] _ TEMPORARY;		!SPERIFIC OPERATOR TEMPORARY
	T[IDSYMBOL]_SIXBIT'.Q'+MAKNAME(RDCCT);
	RDCCT_.RDCCT+1;
	.T
END;
GLOBAL ROUTINE NXTTMP(DBLWDFLAG)=
BEGIN
!GET THE NEXT AVAILABLE TEMPORARY IN SEQUENCE
OWN PEXPRNODE VTMP:RTMP;
	IF .FTEMP EQL 0 THEN
		RTMP_MAKTEMP()
	ELSE
	BEGIN
		RTMP_VTMP_.FTEMP;
		FTEMP_.VTMP[CLINK];
	END;
	IF .DBLWDFLAG THEN
	BEGIN
		IF .FTEMP EQL 0 THEN MAKTEMP()
		ELSE
		BEGIN
			VTMP_.FTEMP;
			FTEMP_.VTMP[CLINK];
		END;
	END;
	.RTMP
END;






END
ELUDOM
