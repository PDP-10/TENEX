!COPYRIGHT 1972,1973,1974, DIGITAL EQUIPMENT CORPORATION, MAYNARD MA**
!AUTHOR: S. MURPHY/HPW

GLOBAL BIND TABLV = 2^24 + 0^18 + 152;	!VERSION DATE:	7-JUNE-74

%(
REVISION HISTORY

134	-----	-----	DEFINE FIELDS FOR E1LISTCALL AND
			E2LISTCALL NODES
135	-----	-----	DEFINE DIMSUBSIZE
136	-----	-----	MODIFY DEFINITION OF DIMENSION TABLE ENTRIES
			TO MAKE ROOM FOR "ARADLBL" FIELD
137	-----	-----	COMPLETE DEFINITIONS FOR I/O OPTIMIZATIONS
138	-----	-----	DEFINE NEW OPERSP EALISTCALL UNDER OPRCLS
			IOLSCLS AND MOVE E2INCR FIELD
140	----	-----	DEFINE THE MACROS "ADDRETREG" AND "REMRETREG" TO
			ADD/REMOVE THE FN-VALUE RETURN REGISTERS TO A SET
			OF FREE REGISTERS
141	-----	-----	CHANGE RGCENTBENTRY TO MAKE REGCANDIDATES
			TABLES INTO A LINKED LIST
142	-----	-----	ADDITIONAL DEFINITIONS OF FIELDS
			FOR IOLSCLS NODES
143	-----	-----	DEFINE OPRS FOR OPRCLS AND SRCID AND
			OPERS MACRO TO DEFINE FIELDS FOR STATEMENT
			NODES
			FOR EACH STATEMENT TYPE APPROPRAITE BIND IS
			CALLED XXXOS WHERE XXXX IS ID MNEMONIC
144	-----	-----	REWRITE MACROS ILFIX AND ILF1IX TO GENERATE
			DABS IN LINE
145	-----	-----	ADDITIONAL DEFINITIONS TO GENERATE CMPLX
			IN LINE
146	-----	-----	ADDITIONAL DEFINITIONS FOR CORRECT FOLDING
			OF NESTED IMPLIED DO LOOPS WITH
			DOUBLE AND SINGLE WORD DATA ITEMS

147	-----	-----	MODIFY THE MACRO "CLBNXREG" TO CALL THE
			ROUTINE "CLOBBNX" - WE WERE NOT CATCHING
			DIVISION OF LOGICALS AS CLOBBERING THE NEXT REG
148	-----	-----	ADD DVARFLGS TO THE DIMENSION TABLE ENTRY SO
			THAT ACT1 WILL CLEAR THEM PROPERLY
149	-----	-----	REMOVE ALL REFERENCES TO "SQROP","CUBOP","P4OP"
			(SINCE THEY ARE NOW UNDER EXPCIOP) - 
			DEFINE THE MACRO "KEXPIX" TO
			DO EXPONEN OF CONSTS AT COMPILE TIME
150	-----	-----	DEFINE MACRO "POWEROF2" - TO USE IN REG
			ALLOCATION OF INTEGER EXPONEN
151	-----	-----	REMOVE REFERENCE TO "CUBOP" FROM THE
			DEFINITION OF "SPECOPIX"
152	-----	-----	RENAME THE MACRO "POWEROF2" TO "POWOF2" (HAD
			A CONFLICT WITH A ROUTINE IN P2S2)
)%

BIND DEBUGFLG=1;	!COMPILE SWITCH TO LEAVE CONSISTENCY CHECKS IN

%(****************************************
	TO OPTIMALLY TEST WHOLE-WD FLAGS FOR TRUE AND FALSE
****************************************)%
BIND	TRUE= -1,
	FALSE= 0;
MACRO	TRUTH(X)= X NEQ 0$,
	FALSITY(X)= X EQL 0$;

BIND	AOBINCR=#1000001;			!INCREMENT FOR AOBJN


%(****************************************
	DEFINE BYTES FOR WHOLE, LEFT HALF, AND RIGHT HALF
****************************************)%
MACRO 	WHOLE=0,36$ ;

		
%(**********************************************************************
	STRUCTURE FOR AN EXPRESSION NODE
************************************************************************)%



%(************************************************************
	DEFINE THE FIELDS AND SUBFIELDS IN AN EXPRESSION NODE
************************************************************)%

BIND EXOPWD=1;			!WORD IN WHICH THE OPERATOR FIELD
					! AND FLAGS FIELD
					! ARE CONTAINED (USE A MACRO ONLY BECAUSE
					! WHEN THIS NUMBER CHANGES A LARGE
					! NUMBER OF SUBFIELD DEFINITIONS
					! MUST BE CHANGED)
%(*****DEFINE MAIN FIELDS****************************)%
MACRO
	FIRSTWORD=0,0,FULL$,
	PARENT=0,0,RIGHT$,		!PTR TO PARENT-NODE
	OPERATOR=0,EXOPWD,RIGHT$,		!OPERATOR FIELD
	EXPFLAGS=0,EXOPWD,LEFT$,	
	OPERWORD=0,EXOPWD,WHOLE$,
	TARGET=0,2,WHOLE$,
	ARGWD=0,3,WHOLE$,			!WD HOLDING PTRS TO THE 2 ARGS
	ARGWDOFFSET=3$,
	ARG1PTR=0,3,LEFT$,
	ARG2PTR=0,3,RIGHT$;
MACRO
	COMPLEXITY=0,0,30,6$,		!THIS FIELD IS USED ONLY DURING REGISTER ALLOCATION
				! IT INDICATES THE NO OF REGS NEEDED TO EVAL THIS EXPR
	SONNXTUSE=0,0,18,12$;	!ISN OF THE STMNT WHERE THE VAR UNDER THIS EXPR IS NEXT
				! USED (IN THIS BASIC BLOCK) USED BY BB REG ALLOC

%(**********SUBFIELDS IN OPERATOR FIELD*************************)%
MACRO
	VALTYPE=0,EXOPWD,13,5$,		!TYPE FOR VALUE
	OPRCLS=0,EXOPWD,8,5$,		!CLASS OF OPERATOR
	OPERSP=0,EXOPWD,5,3$,		!SPECIFIC OPERATOR WITHIN CLASS


	%(***NOTE THAT OF THE 3 FREE BITS AT THE RIGHT END OF THE OPERATOR FIELD,
		BIT 35 IS USED AS A SPECIAL FLAG BIT IN
		1. TYPE-CONVERSION NODES: FLAG FOR NO CONVERSION
	*******)%

	%(***SUBFIELDS OF OPERSP FIELD*****)%
	OPRSP1=0,EXOPWD,6,2$,		!1ST 2 BITS OF OPERSP (THIS FIELD IS 00 FOR
					! ADD AND SUB, 01 FOR MUL AND DIV
	OPRSP2=0,EXOPWD,5,2$,		!LAST 2 BITS OF OPERSP FIELD -
					! USED TO DIFFERENTIATE ADD,SUB,MUL,DIV
					! ALSO USED IN TYPE CONVERSION NODES TO DIFFERENTIATE
					! FROMINT, FROMREL, FROMDBLPRC,
					! FROMCMPLX
	OPRSBIT0=0,EXOPWD,7,1$,		!1ST BIT OF OPERSP FIELD - FOR AN ARITH
					! NODE, THIS BIT IS SET ONLY FOR OPERSP EXPONEN
					! FOR A TYPE-CONVERSION NODE THIS BIT IS SET
					! FOR FROMINT,FROMREAL,FROMDBLPRC,FROMCMPLX
					!  AND NOT SET FOR FROMOCT,FROMCTL,FROMLIT,FROMDOCT
	OPRSBIT2=0,EXOPWD,5,1$,		!3RD BIT OF OPERSP FIELD - FOR AN ARITH
					! NODE, THIS BIT IS SET ONLY FOR SUB AND MUL
	OPR1=0,EXOPWD,5,8$,		!OPRCLS AND OPERSP FIELDS CONCATENATED
	OPR2=0,EXOPWD,6,7$;		!OPRCLS FIELD AND 1ST 2 BITS OF OPERSP FIELD

	%(***SUBFIELDS OF THE ABOVE "MAIN" SUBFIELDS***)%
MACRO
	VALTP1=0,EXOPWD,15,2$,		!MIDDLE 2 BITS OF VALTYPE ARE
					! ALL THATS NEEDED FOR GETA1OPIX AND ARITHOPIX
	VALTP2=0,EXOPWD,15,3$,		!FIRST 3 BITS OF VALTYPE ARE
					! IDENTICAL TO THE OPERSP FIELD FOR A TYPECNV
					! NODE TO CONVERT FROM THAT VALTYPE
	DBLFLG=0,EXOPWD,16,1$,		!THE 2ND BIT OF VALTYPE IS FLAG
					! FOR 2 WD VAL (DOUBLE PREC OR COMPLEX)
	SDBLFLG=0,EXOPWD,6,1$;		!THE 2ND BIT OF OPERSP FOR A
					!NODE OF OPRCLS "TYPECNV" IS FLAG FOR SOURCE
					!IS A 2 WD VAL

MACRO
	BOOLOPR=0,EXOPWD,5,2$,		!BOOLEAN OPERATOR IS SPECIFIED BY RIGHT
					! 2 BITS OF OPERSP FIELD
	BOOLCLS=0,EXOPWD,6,1$,		!BOOLEAN CLASS (AND/OR OR XOR/EQV) IS
					! SPECIFIED BY THE LEFTMOST OF THESE 2
	BOPRFLG=0,EXOPWD,5,1$;		!THE 2ND DIVIDES BOOLEANS INTO 2 OTHER
					! CLASSES - OR/XOR AND AND/EQV

MACRO	PARENLSTFLG=0,EXOPWD,7,1$;	!FLAG FOR NAME WHICH SHOULD HAVE
					! AN ARGLST FOLLOWING (THIS BIT IS
					! 1ST BIT OF OPERSP FIELD OF A DATA ITEM)
MACRO	FORMLFLG=0,EXOPWD,5,1$;	!IN OPERSP FIELD FOR A DATA ITEM, FLAG
					! FOR "FORMAL" (NOTE HOWEVER THAT THIS BIT
					! IS ALSO SET IN THE OPERSP FIELD OF A TEMPORARY)

	%(****MACRO TO CONSTRUCT AN "OPR1" FIELD*****)%
MACRO
	OPR1C(OPCLS,OPSP)=(OPCLS^3 OR OPSP)$;
MACRO	OPR2C(OPCLS,OPSP)=(OPCLS^2 OR OPSP^(-1))$;

	%(****TO CONSTRUCT AN OPERATOR FIELD****)%
MACRO OPERC(VTYP,OPCLS,OPSP)=(VTYP^13 OR OPCLS^8 OR OPSP^5)$;

	%(***TO GET A VALTP1 FIELD FROM A VALTYPE****)%
MACRO	VTP1(VLTP)=(VLTP^(-2) AND (#3))$;


	%(***TO GET A VALTP2 FIELD (FIRST 3 BITS) FROM A VALTYPE***)%
MACRO	VTP2(VLTP)=(VLTP^(-2))$;







%(*******FLAGS IN EXPFLAG FIELD (THESE ARE SET BY PHASE 2 SKEL AND USED BY PHASE 3*******)%
MACRO
	PARENFLG=0,EXOPWD,35,1$,		!FLAG FOR PARENS AROUND THIS NODE (IN SOURCE)
	PAIRMODEFLG=PARENFLG$,		!IN ALL STATEMENTS TO INDICATE
					!DOUBLE PRECISION
	SAVREGFLG=0,EXOPWD,34,1$,		!"SAVE THE REG CONTAINING THE VAL OF THE VAR
						! UNDER THIS NODE FOR USE LATER IN THIS BASIC BLOCK"
	RVRSFLG=0,EXOPWD,33,1$,			!"VAL OF 2ND SON SHOULD BE
						! COMPUTED BEFORE 1ST SON
	STOREFLG=0,EXOPWD,32,1$,		!RESULT MUST BE STORED AFTER IT IS COMPUTED
	RESRFFLG=0,EXOPWD,31,1$,		!FLAG FOR "UNDER THIS NODE THERE IS A
						! REFERENCE TO THE VAR INTO WHICH THE RESULT
						! OF THE WHOLE EXPRESSION WILL BE STORED
	USRFNREF=RESRFFLG$,			!STATEMENT CONTAINS A USER
						!FUNCTION REFERENCE. ONLY ON 
						!A STATEMENT NODE.
	FNCALLSFLG=0,EXOPWD,30,1$,		!FLAG FOR "FN CALLS OCCUR UNDER THIS
						! NODE
	ALCRETREGFLG=0,EXOPWD,29,1$,		!VAL OF THIS NODE IS TO BE COMPUTED
						! IN THE "FN RETURN REG" 
	A1VALFLG=0,EXOPWD,28,1$,		!FIRST ARG IS A COMMON SUBEXPR THAT 
						! WAS ALREADY COMPUTED ELSEWHERE
						! OR A LEAF
	VALINR0=A1VALFLG$,			!SET IN ENTRY STATEMENT
						!BY GLOBAL ALLOCATOR TO INDICATE
						!FUNCTION VALUE IS ALREADY IN
						!REGISTER ZERO
	LABLARGS=A1VALFLG$,			!SET ON A CALL STATEMENT
						!ONLY TO  INDICATE THERE
						!ARE LABEL ARGS
	TRUEISBR=A1VALFLG$,			!SET ONLY ON LOGICAL IF
						!TO INDICATE THE THE TRUE
						!BRANCH IS A BRANCH.
	A1NOTFLG=0,EXOPWD,27,1$,		!APPLY 'NOT' TO 1ST ARG
	A1NEGFLG=0,EXOPWD,26,1$,		!NEGATE 1ST ARG
	A1SAMEFLG=0,EXOPWD,25,1$,		!LOC OF COMPUTATION FOR PARENT EQLS
						! LOC OF VALUE OF FIRST ARG
	A1IMMEDFLG=0,EXOPWD,24,1$,		!1ST ARG IS IMMED CONSTANT
	A2VALFLG=0,EXOPWD,23,1$,		!2ND ARG IS A COMMON SUBEXPR THAT WAS ALREADY
						! COMPUTED ELSEWHERE
						! OR A LEAF
	A2NOTFLG=0,EXOPWD,22,1$,		! APPLY NOT TO 2ND ARG
	NOLBLLST=A2NOTFLG$,			!USED BY OPTIMIZER ON AN
						!ASSIGNED GO TO TO INDICATE 
						!THAT THE PROGRAMMER DID NOT
						!SUPPLY A BRANCH LIST
	A2NEGFLG=0,EXOPWD,21,1$,		!NEGATE 2ND ARG
	A2SAMEFLG=0,EXOPWD,20,1$,		!LOC OF COMPUTATION FOR PARENT EQLS 
						! LOC OF VALUE OF 2ND ARG
	OPTCONFLG=A2SAMEFLG$,		!FLAG ON THE "CONTINUE" THAT WAS INSERTED BY THE OPTIMIZER
					! AT THE END OF THE PROGRAM
	A2IMMEDFLG=0,EXOPWD,19,1$,		!2ND ARG IS AN IMMED CONSTANT
	OPTOBOTHFLG=A2IMMEDFLG$,		!IF THIS BIT IS SET **AND** MEMCMPFLG IS
						! ALSO SET, THEN PERFORM OPERATION TO "BOTH"
	MEMCMPFLG=0,EXOPWD,18,1$;		!VALUE COMPUTED TO MEMORY

MACRO	CSFULLWDFLG=RVRSFLG$;		!IN A COMMON SUBEXPR NODEWHERE THE
					! COMMON-SUBEXPR IS A SINGLE VARIABLE (EG A
					! VAR USED IN RELATIONALS OR SUBSCRIPTS)
					! THIS FLAG IS SET IF THE WHOLE VARIABLE MUST BE LOADED
					! (EG IT IS USED IN A RELATIONAL), RATHER
					! THAN THE RIGHT-HALF BEING USABLE REGARDLESS OF
					! WHATS IN THE LEFT HALF (EG IT IS USED AS A SS ONLY)
MACRO	CSSSFLG=A1NOTFLG$;	!IN A COMMON SUBEXPR NODE, THIS FLAG IS SET IF THE
				! COMMON SUB IS EVER USED AS A SUBSCRIPT


	%(***DEFINE SUBFIELDS OF THE FLAGS FIELD***)%

	%(*****FLAGS FOR EACH OF THE 2 ARGS***)%
MACRO
	A1FLGS=0,EXOPWD,24,5$,
	A2FLGS=0,EXOPWD,19,5$;

	%(****LAST 4 FLAGS - NEG, NOT, SAME, IMMED****)%
	MACRO
		A1FLG1=0,EXOPWD,24,4$,
		A2FLG1=0,EXOPWD,19,4$;
	%(***A2IMMEDFLG CONCATENATED WITH MEMCMPFLG***)%
	MACRO A2IMMEMCMPFLGS=0,EXOPWD,18,2$;

	%(***NEG AND NOT FLAGS******************)%
	MACRO
		A1NGNTFLGS=0,EXOPWD,26,2$,
		A2NGNTFLGS=0,EXOPWD,21,2$;

	%(****TO CLEAR THE FLAGS FOR ARG1, OR FOR ARG2*****)%
	MACRO CLRA1FLGS(ANODE)=
		ANODE[EXPFLAGS]_.ANODE[EXPFLAGS] AND (NOT #003700)$;

	MACRO CLRA2FLGS(ANODE)=
		ANODE[EXPFLAGS]_.ANODE[EXPFLAGS] AND (NOT  #000076)$;

	%(******TO SWAP THE FLAGS FOR ARG1 AND ARG2 (WHEN ARE ALSO SWAPPIG THE 2 ARGS******)%

	%(***VALUE FOR A1FLGS OR A2FLGS FIELD WHEN ONLY THE VAL FLG IS SET***)%
BIND	VLFLSET=#20;

MACRO
	SWAPFLGS(NODE) =
	BEGIN
		REGISTER T1;
		T1_.NODE[A1FLGS];
		NODE[A1FLGS]_.NODE[A2FLGS];
		NODE[A2FLGS]_.T1;
	END $;

	%(****TO SET THE FLAGS FOR ARG1 TO THOSE FOR ARG2 AND CLEAR THOSE FOR ARG2 ****)% 
	MACRO A2TOA1FLGS(NODE)=
	BEGIN
		NODE[A1FLGS]_.NODE[A2FLGS];
		CLRA2FLGS(NODE);
	END$;

	%(***TO MOVE FLAGS FOR A SON INTO THE FLAG FIELD OF ITS PARENT (WHEN
		LINKING THE SON DIRECTLY UP TO THE PARENT'S PARENT***)%
MACRO
	RAISEFLGS(PARFLGS,SONFLGS)=
	BEGIN
		REGISTER T1;
		T1_(PARFLGS XOR SONFLGS) AND NGNTFLGMSK;	!TAKE XOR OF NEGFLGS AND 
								! NOTFLGS OF PARENT AND SON
		.T1 OR (SONFLGS AND VLIMSMMSK)		!USE VALFLG, SAMEFLG 
								! AND IMMEDFLG FOR SON
	END$;

	%(***MASK FOR NEG AND NOT FLAGS WITHIN A1FLGS/A2FLGS FIELDS***)%
BIND	NGNTFLGMSK=#14;

	%(***MASK FOR VALFLG,SAMEFLG, AND IMMEDFLG FIELDS WITHIN A1FLG/A2FLG FIELDS***)%
BIND	VLIMSMMSK=#23;




%(*********SUBFIELDS OF TARGET FIELD***********)%
MACRO
	INREGFLG=0,2,35,1$,		!FLAG FOR VAL LEFT IN A REG
	TARGTAC=0,2,23,4$,		!AC TO BE COMPUTED IN
	TARGAUX=0,2,27,4$,		!EXTRA AC TO COMPUTE IN, USED FOR
					! RELATIONALS (WHICH ARE "COMPUTED" IN A DIFFERENT
					! REG FROM THE ONE THAT HOLDS THE VALUE)
	TARGTMEM=0,2,0,23$,		!MEMORY REF TO GET AT FINAL RESULT
	TARGADDR=0,2,0,18$,		!ADDRESS FIELD FOR RETRIEVING RESULT
	TARGXF=0,2,18,4$,		!INDEX FIELD FOR RETRIEVING RESULT
	TARGIF=0,2,22,1$,		!INDIRECT FIELD FOR RETRIEVING RESULT
	TARGIXF=0,2,18,5$;		!INDIRECT AND INDEX FIELDS
%(***TO GET TARGTAC, TARGXF,  OR TARGAUX FIELD FROM A TARGET WD INTO THE AC BITS OF AN INSTR***)%
%(****OR TO GET TARGET-REG FOR AN ASSIGNMENT-STATEMENT NODE INTO THE AC BITS OF AN INSTR***)%
MACRO	GETTAC(NODE)=(.NODE[TARGET] AND #17^23)$,
	GETTXF(NODE)=((.NODE[TARGET] AND #17^18)^5)$,
	GETTAUX(NODE)= ((.NODE[TARGET] AND #17^27)^(-4))$,
	GETASMNREG(STMNTNODE)= (.STMNTNODE[CW4] AND #17^23)$,
	GETAIFREG(AIFNODE)=(.AIFNODE[CW5] AND #17^23)$;

	%(***GET THE INDEX AND INDIRECT BITS OF A TARGET WD***)%
MACRO GETTXFI(NODE)=(.NODE[TARGET] AND #37^18)$;


MACRO	IXFLD(REG)=REG^18$;



%(************************************************************
	DEFINE THE STRUCTURE FOR AN EXPRESSION NODE
************************************************************)%
STRUCTURE PEXPRNODE[FTP,WD,POS,SIZE]=

	%(***THE ARG "FTP" SELECTS THE ACCESSING ALGORITHM***)%
	CASE .FTP OF SET

		%(****FOR MOST FIELDS****)%
		(@.PEXPRNODE+.WD)<.POS,.SIZE>


		TES;





%(********************************************************
	VALUES FOR SUBFIELDS OF OPERATOR FIELD
************************************************************)%

%(*******VALUES FOR VALTYPE FIELD*****)%
BIND
	OCTAL=0,		!00000
	LOGICAL=1,		!00001
	CONTROL=4,		!00100 - CONTROL-TYPE BOOLEAN
	DOUBLOCT=8,		!01000
	LITERAL=12,		!01100
	INTEGER=16,		!10000
	BYTE=17,		!10001
	INDEX=18,		!10010
	REAL=20,		!10100
	DOUBLPREC=24,		!11000
	COMPLEX=28;		!11100 

	%(**NOTE THAT IN THE ABOVE THE 2ND BIT IS A FLAG FOR
		DOUBLE WD***)%
	%(***NOTE ALSO THAT THE 2ND AND 3RD  BITS DETERMINE THE CODE TO BE
		GENERATED IN MANY CASES (WHERE INDEX,BYTE,LOG ARE 
		TREATED AS INTEGER); AND THAT THESE 2 BITS ARE
		REFERENCED AS THE FIELD "VALTP1" *******)%
	%(***NOTE ALSO THAT IF THE FIRST 3 BITS OF THE VALTYPES OF 2 NODES
		ARE IDENTICAL, NO TYPE-CONVERSION OPERATION IS  NECESSARY
		WHEN COMBINING THE 2 NODES ARITHMETICALLY 
	*****)%
	%(***NOTE ALSO THAT THE OPERSP FIELD FOR A TYPE CONVERSION NODE IS EQUAL
		TO THE FIRST 3 BITS OF THE ORIGINAL TYPE
	****)%


	%(***VALUES FOR VALTP1 FIELD (BITS 2 AND 3  OF VALTYPE)***)%
BIND
	INTEG1=VTP1(INTEGER);	!00

	%(***VALUES FOR VALTP2 FIELD (BITS 1,2,3 OF VALTYPE)***)%
BIND
	LOGICAL2=LOGICAL^(-2),
	REAL2=REAL^(-2);


	%(***TO TEST WHETHER A GIVEN VALTYPE IS DOUBLE-WD***)%
MACRO	DBLFROMVAL(VLTP)=
	(VLTP^(-3) AND 1)$;


	%(***TO TEST WHETHER A VALTYPE IS ONE THAT IS NEVER "CONVERTED", 
		IE IS ALWAYS USED AS A BIT PATTERN. THE TYPES THAT THIS IS TRUE
		OF  ARE:  LOGICAL,OCTAL,DOUBLE-OCTAL,LITERAL, AND CONTROL***)%
MACRO	BITPTNVALTYP(VLTP)=
	VLTP LSS INTEGER$;




%(******VALUES FOR OPRCLS FIELD********)%
BIND
	BOOLEAN=0,		!00000
	DATAOPR=1,		!00001
	RELATIONAL=2,		!00010
	FNCALL=3,		!00011
	ARITHMETIC=4,		!00100
	TYPECNV=5,		!00101
	ARRAYREF=6,		!00110
	CMNSUB=7,		!00111
	NEGNOT=8,		!01000
	SPECOP=9,		!01001		;A SPECIAL CASE TO BE OPTIMIZED
						!(P2MUL,SQUARE,...)
	FIELDREF=10,		!01010
	STORECLS=11,		!01011
	REGCONTENTS=12,		!01100
	LABOP=13,		!01101
	STATEMENT=14,		!01110
	IOLSCLS=15,		!01111		;ELEMENT IN AN IOLIST
	INLINFN=16;		!10000		;A FN TO BE GENERATED IN LINE


%(********VALUES FOR OPERSP FIELD**************)%

	%(****FOR OPRCLS BOOLEAN****)%
BIND
	ANDOP=0,		!000
	OROP=1,		!001
	EQVOP=2,		!010
	XOROP=3;		!011

	%(***BIT 35 OF EXOPWD IS USED AS A FLAG IN A BOOLEAN NODE FOR "ARG2HAS VALTYPE
		CONTROL, ARG1 IS A MASK" ****)%



	%(****FOR OPRCLS DATA ITEM****)%
BIND
	CONSTANT=0,		!000
	TEMPORARY=1,		!001
	VARIABLE=2,		!010
	FORMLVAR=3,		!011
	ARRAYNAME=4,		!100
	FORMLARRAY=5,		!101
	FNNAME=6,		!110
	FORMLFN=7;		!111

	%(***DEFINE SUBFIELD OF OPERSP FOR DATA-ITEMS THAT DIFFERENTIATES
		FN AND FORMAL FN FROM ARRAY AND FORML ARRAY FROM VAR AND FORML VAR***)%
	MACRO	DATOPS1=OPRSP1$;	!FIRST 2 BITS OF OPERSP

	%(***DEFINE VALUES OF DATOPS1 FIELD***)%
BIND	VARIABL1=1,
	ARRAYNM1=2,
	FNNAME1=3;

	%(***TO TEST FOR AN DATA ITEM AN ENTRY IN THE SYMBOL TABLE (AS OPPOSED TO A 
		CONSTANT OR TEMPORARY*****)%
MACRO	SYMBOL(NODE)=(.NODE[OPERSP] GEQ VARIABLE)$;

	%(****FOR OPRCLS RELATIONAL****)%
BIND
	L=1,			!001
	E=2,			!010
	LE=3,			!011
	GE=5,			!101
	N=6,			!110
	G=7;			!111

MACRO
	EQREL(MODE) = (MODE AND #1) EQL 0$;		!E AND N  HAVE LAST BIT=0

MACRO
	REVREL(M) = M XOR #6$;			!"REVERSE" RELATIONAL FROM M (EG FOR
						! REVREL(GE) GET LE )
MACRO
	CMREL(M)= M XOR 4$;			!TO GET "COMPLEMENT" OF A CONDITION

	%(****FOR OPRCLS FNCALL****)%
BIND
	NONLIBARY=0,		!NOT A LIBRARY FUNCTION
	LIBARY=1;		!A LIBARY FUNCTION

	%(****FOR OPRCLS ARITHMETIC****)%
BIND
	ADDOP=0,		!000
	SUBOP=1,		!001
	MULOP=2,		!010
	DIVOP=3,		!011
	EXPONOP=4;		!100

	%(***TO TRANSFORM ADD TO SUB, SUB TO ADD; MUL TO DIV, DIV TO MUL***)%
MACRO
	CMPLSP(NODE)=
		(NODE[OPERATOR]_.NODE[OPERATOR] XOR #40)$;	!CHANGE RIGHTMOST BIT OF OPERSP
								! (RIGHTMOST BIT OF OPERSP IS 
								! 5 BITS FROM RIGHT END OF
								! OPERATOR FIELD

	%(***TEST FOR OPERATOR EITHER ADD OR SUB****)%
MACRO
	ADDORSUB(NODE) = .NODE[OPR2] EQL OPR2C(ARITHMETIC,ADDOP)$;
	%(***TEST FOR OPERATOR FIELD EITHER MUL OR DIV***)%
MACRO
	MULORDIV(NODE) = .NODE[OPR2] EQL OPR2C(ARITHMETIC,MULOP)$;

	%(***TO TEST FOR OPERATOR (*KNOWN TO BE ARITH*) EQUAL TO EXPONENTIATION***)%
MACRO
	EXPONEN(NODE) = .NODE[OPRSBIT0]$;	!FIRST BIT OF OPERSP FIELD

	%(***TO TEST FOR OPERATOR (*KNOWN TO BE ARITH*) EQUAL TO SUB OR DIV****)%
MACRO
	SUBORDIV(NODE)= (.NODE[OPRSBIT2])$;	!3RD BIT OF OPERSP FIELD IS SET FOR
						! DIV AND SUB

	%(***TO TEST FOR AN OPERATOR (OF UNKNOWN OPRCLS) EQUAL TO ADD OR MUL****)%
MACRO 
	%(***OPRCLS MUST BE ARITHMETIC, OPERSP MUST HAVE ITS 1ST AND 3RD BITS 0****)%
	ADDORMUL(NODE)=((.NODE[OPERWORD] AND (#37^8 OR #5^5)) EQL (ARITHMETIC^8))$;


	%(*****TO TEST FOR A NODE OF UNKNOWN OPRCLS TO BE COMMUTATIVE - 
		VAL IS TRUE FOR ALL BOOLEANS AND FOR ADD AND MUL*********)%
MACRO	COMMUTATIVE(NODE)=
	(.NODE[OPRCLS] EQL BOOLEAN OR ADDORMUL(NODE) )$;
 


	%(****FOR OPRCLS TYPECNV****)%
BIND
	FROMOCT=0,		!000
	FROMCTL=1,		!001
	FROMDOCT=2,		!010
	FROMLIT=3,		!011
	FROMINT=4,		!100
	FROMREAL=5,		!101
	FROMDBLPRC=6,		!110
	FROMCMPLX=7;		!111

	%(***NOTE THAT THIS FIELD IS EQUAL TO THE FIRST 3 BITS OF THE VALTYPE
		FIELD FOR THE VALUE BEING CONVERTED FROM(THE VALTYPE FIELD 
		ON THIS NODE SPECIFIES THE TYPE TO CONVERT TO)****)%


MACRO
	NOCNVFLG=0,EXOPWD,0,1$;		!BIT 35 OF EXOPWD IS USED AS A FLAG FOR "NO ACTUAL
					! CONVERSION TAKES PLACE"

	%(***TEST WHETHER ANY CODE MUST BE GENERATED FOR A GIVEN TYPE-CONVERSION NODE***)%
	MACRO NOCNV(TPCNODE)=
	BEGIN
		(
		(.TPCNODE[NOCNVFLG])		!IF FLAG WAS SET TO NOT ACTUALLY CONVERT
		OR
		(.TPCNODE[VALTP2] EQL .TPCNODE[OPERSP])
		OR
		(	(.TPCNODE[OPERSP] LSS FROMINT)	!CONVERTING FROM LOGICAL/OCTAL
							! OR DOUBLE-OCTAL OR CONTROL OR LITERAL
			AND
			( (NOT .TPCNODE[DBLFLG]) OR .TPCNODE[SDBLFLG])	!AND IF THE DESTIN IS
									!DBL WD, SO IS THE SRC
		)
		)
		AND (NOT .TPCNODE[A2IMMEDFLG])	!IF THE ARG UNDER THE TYPE-CNV
						! IS THE RIGHT HALF OF AN AOBJN VAR,
						! MUST LOAD IT
	END$;



	%(***FOR OPRCLS NEGNOT***************************)%
BIND
	NEGOP=0,
	NOTOP=1;

	%(****FOR OPRCLS SPECOP (SPECIAL OPS INTRODUCED BY PHASE 2 SKEL)***)%
BIND
	P2MULOP=0,		!MULTIPLY BY A POWER OF 2
	P2DIVOP=1,		!DIVIDE BY A POWER OF 2
	P2PL1OP=2,		!MULTIPLY BY A POWER OF 2 PLUS 1
	EXPCIOP=6;		!RAISE TO A  CONSTANT INTEGER POWER
				! (NOT HANDLED IN RELEASE 1)


	%(***FOR OPRCLS STORECLS****************************)%
BIND
	STARVAL=0,		!STORE CONTENTS OF AN ARRAY ELEM
	STARADDR=1;		!STORE PTR TO AN ARRAY ELEMENT


	%(***FOR OPRCLS IOLSCLS (FOR IOLIST ELEMENTS)***)%
BIND
	DATACALL=0,		!SINGLE DATA ITEM
	SLISTCALL=1,		!ARRAY REFERENCED WITHOUT SUBSCRIPTS
	IOLSTCALL=2,		!GROUP OF OTHER IOLSTCALL NODES
	E1LISTCALL=3,		!FOLDED IMPLIED DO LOOPS CREATED
	E2LISTCALL=4,		!BY GLOBAL OPTIMIZER ONLY DURING PHASE2
	ESNGLELEM=5,		!SINGLE WORD ITEM UNDER AN ELISTCALL
	EDBLELEM=6;		!DOUBLE WORD ITEM UNDER AN ELISTCALL


	%(***FOR OPRCLS INLINFN (FNS TO BE GENERATED IN LINE)****)%
BIND
	ABSFN=0,
	CMPLXFN=1,
	SIGNFN=2,
	DIMFN=3,
	MODFN=4,
	MAXFN=5,
	MINFN=6;

	%(***MACRO TO DETERMINE FOR A GIVEN IN-LINE-FN WHETHER THE ARG SHOULD BE PUT
		INTO THE REG-FOR-COMPUTATION BEFORE THE VAL IS COMPUTED (FOR ABS,IABS
		AND SIGN, DO NOT WANT TO LOAD THE ARG IN ADVANCE) ****)%
	MACRO ILFINRFC(OPSP)=(OPSP GEQ DIMFN)$;




	%(****VALS FOR OPR1 FIELD FOR SOME OF THE OPERATORS*****)%
BIND
	ADDOPF=OPR1C(ARITHMETIC,ADDOP),
	SUBOPF=OPR1C(ARITHMETIC,SUBOP),
	MULOPF=OPR1C(ARITHMETIC,MULOP),
	DIVOPF=OPR1C(ARITHMETIC,DIVOP),
	EXPONOPF=OPR1C(ARITHMETIC,EXPONOP),
	CONSTFL=OPR1C(DATAOPR,CONSTANT),
	VARFL=OPR1C(DATAOPR,VARIABLE),
	FMLVARFL=OPR1C(DATAOPR,FORMLVAR),
	FMLARRFL=OPR1C(DATAOPR,FORMLARRAY),
	NEGFL=OPR1C(NEGNOT,NEGOP),
	MODFNFL=OPR1C(INLINFN,MODFN),
	STARVLFL=OPR1C(STORECLS,STARADDR),
	SLISTCLFL=OPR1C(IOLSCLS,SLISTCALL);


BIND
	P2MULOPF=OPR1C(SPECOP,P2MULOP),
	P2DIVOPF=OPR1C(SPECOP,P2DIVOP),
	P2PL1OPF=OPR1C(SPECOP,P2PL1OP);
BIND
	EXPCIF=OPR1C(SPECOP,EXPCIOP);


	%(***VALUES OF OPERATOR FIELD FOR SOME OF THE OPERATORS***)%
BIND	REALCONST=OPERC(REAL,DATAOPR,CONSTANT),
	INTCONST=OPERC(INTEGER,DATAOPR,CONSTANT),
	DOUBLCONST=OPERC(DOUBLPREC,DATAOPR,CONSTANT),
	CPLXCONST=OPERC(COMPLEX,DATAOPR,CONSTANT),
	LITCONST=OPERC(LITERAL,DATAOPR,CONSTANT),
	INTVAR=OPERC(INTEGER,DATAOPR,VARIABLE),
	INDEXVAR=OPERC(INDEX,DATAOPR,VARIABLE);
BIND	INTDIVIDE=OPERC(INTEGER,ARITHMETIC,DIVOP);
BIND	INTADD=OPERC(INTEGER,ARITHMETIC,ADDOP);
BIND	CMPMUL=OPERC(COMPLEX,ARITHMETIC,MULOP),
	CMPDIV=OPERC(COMPLEX,ARITHMETIC,DIVOP);

BIND	ABSFNOP=OPERC(REAL,INLINFN,ABSFN),
	IABSFNOP=OPERC(INTEGER,INLINFN,ABSFN),
	DABSFNOP=OPERC(DOUBLPREC,INLINFN,ABSFN),
	CMPLXFNOP=OPERC(COMPLEX,INLINFN,CMPLXFN),
	SIGNFNOP=OPERC(REAL,INLINFN,SIGNFN),
	ISIGNFNOP=OPERC(INTEGER,INLINFN,SIGNFN),
	DIMFNOP=OPERC(REAL,INLINFN,DIMFN),
	IDIMFNOP=OPERC(INTEGER,INLINFN,DIMFN),
	MODFNOP=OPERC(INTEGER,INLINFN,MODFN),
	MAXFNOP=OPERC(INTEGER,INLINFN,MAXFN),
	MINFNOP=OPERC(INTEGER,INLINFN,MINFN),
	AMAXFNOP=OPERC(REAL,INLINFN,MAXFN),
	AMINFNOP=OPERC(REAL,INLINFN,MINFN);

BIND	CMPLXOP=OPERC(COMPLEX,TYPECNV,FROMREAL),
	DBLEOP=OPERC(DOUBLPREC,TYPECNV,FROMREAL),
	DFLOATOP=OPERC(DOUBLPREC,TYPECNV,FROMINT),
	FLOATOP=OPERC(REAL,TYPECNV,FROMINT),
	IDINTOP=OPERC(INTEGER,TYPECNV,FROMDBLPRC),
	INTOP=OPERC(INTEGER,TYPECNV,FROMREAL),
	IFIXOP=OPERC(INTEGER,TYPECNV,FROMREAL),
	REALOP=OPERC(REAL,TYPECNV,FROMCMPLX),
	SNGLOP=OPERC(REAL,TYPECNV,FROMDBLPRC);


BIND	LTOP=OPERC(CONTROL,RELATIONAL,L),
	EQOP=OPERC(CONTROL,RELATIONAL,E),
	LEOP=OPERC(CONTROL,RELATIONAL,LE),
	GEOP=OPERC(CONTROL,RELATIONAL,GE),
	NEOP=OPERC(CONTROL,RELATIONAL,N),
	GTOP=OPERC(CONTROL,RELATIONAL,G);

BIND	FIXOP=OPERC(INTEGER,TYPECNV,FROMREAL);
BIND	IOLSTCFL=OPERC(0,IOLSCLS,IOLSTCALL),
	E1LISTCFL=OPERC(0,IOLSCLS,E1LISTCALL),
	E2LISTCFL=OPERC(0,IOLSCLS,E2LISTCALL),
	DATACLFL=OPERC(0,IOLSCLS,DATACALL);

BIND	DOSTATEMENT=STOPERC(STATEMENT,DOID);
BIND	CONTSTATEMENT=STOPERC(STATEMENT,CONTID);

%(***DEFINE OPRCLS+SRCID FOR STATEMENTS***)%

MACRO
	OPERS(OPCLS,SORCID)=(OPCLS^7+SORCID)$,	!DEFINE CONCATENATED FIELDS
	OPRS=0,EXOPWD,1,12$;			!DEFINE OPRS FIELD

BIND
	ASGNOS=OPERS(STATEMENT,ASGNID),
	ASSIOS=OPERS(STATEMENT,ASSIID),
	CALLOS=OPERS(STATEMENT,CALLID),
	CONTOS=OPERS(STATEMENT,CONTID),
	DOOS=OPERS(STATEMENT,DOID),
	ENTROS=OPERS(STATEMENT,ENTRID),
	COMNOS=OPERS(STATEMENT,COMNSUB),
	GOTOOS=OPERS(STATEMENT,GOTOID),
	AGOOS=OPERS(STATEMENT,AGOID),
	CGOOS=OPERS(STATEMENT,CGOID),
	IFAOS=OPERS(STATEMENT,IFAID),
	IFLOS=OPERS(STATEMENT,IFLID),
	RETUOS=OPERS(STATEMENT,RETUID),
	STOPOS=OPERS(STATEMENT,STOPID),
	READOS=OPERS(STATEMENT,READID),
	WRITOS=OPERS(STATEMENT,WRITID),
	DECOOS=OPERS(STATEMENT,DECOID),
	ENCOOS=OPERS(STATEMENT,ENCOID),
	REREDOS=OPERS(STATEMENT,REREDID),
	FINDOS=OPERS(STATEMENT,FINDID),
	CLOSOS=OPERS(STATEMENT,CLOSID),
	INPUOS=OPERS(STATEMENT,INPUID),
	OUTPOS=OPERS(STATEMENT,OUTPID),
	BACKOS=OPERS(STATEMENT,BACKID),
	BKFILOS=OPERS(STATEMENT,BKFILID),
	REWDOS=OPERS(STATEMENT,REWDID),
	SKFILOS=OPERS(STATEMENT,SKFILID),
	SKRECOS=OPERS(STATEMENT,SKRECID),
	UNLODOS=OPERS(STATEMENT,UNLODID),
	RELSOS=OPERS(STATEMENT,RELSID),
	ENDFOS=OPERS(STATEMENT,ENDFID),
	ENDOS=OPERS(STATEMENT,ENDID),
	PAUSOS=OPERS(STATEMENT,PAUSID),
	OPENOS=OPERS(STATEMENT,OPENID),
	SFNOS=OPERS(STATEMENT,SFNID),
	FORMOS=OPERS(STATEMENT,FORMID),
	BLTOS=OPERS(STATEMENT,BLTID),
	REGOS=OPERS(STATEMENT,REGMASK);

%(********VALUES FOR SPECIAL OPERATOR SUBFIELDS***********)%

	%(****USED FOR OPRCLS BOOLEAN*****)%
BIND
	ANDORCLS=0,		!VALUE OF BOOLCLS FOR AND/OR NODES
	ANDOPF=0,		!VALUE OF BOPRFLG FOR AND/EQV NODES
	XOROROPF=1;		!VALUE OF BOPRFLG FOR OR/XOR NODES



%(****************************************
	TO CHECK FOR VALUES THAT FIT IN SINGLE WD
****************************************)%
MACRO	SINGLWD(NODE)= NOT (.NODE[DBLFLG])$;


%(***************************************************************************
	TO TEST A CONSTANT NODE FOR BEING AN IMMEDIATE-SIZE CONSTANT
***************************************************************************)%


MACRO IMMEDCNST(NODE)=
BEGIN
	EXTERNAL KDPRL;		!THESE GLOBALS ARE USED IN CALLING THE MACRO MODULE
	EXTERNAL C1H,C1L,C2H,COPRIX;	! THAT ROUNDS REAL NUMBERS
	EXTERNAL CNSTCM;

	CASE .NODE[VALTP1] OF SET
	%(***INTEGER CONSTANTS ARE IMMED SIZE IFF LH OF ABSOLUTE VAL IS 0***)%
	((ABS(.NODE[CONST2]) AND #777777000000) EQL 0);
	%(***REAL CONSTANTS ARE IMMED SIZE IFF THE RIGHT HALF WD IS
		ALL 0'S*******)%
	BEGIN
		%(***BECAUSE WE KEEP 2 WDS OF PRECISION THRUOUT COMPILE TIME,
			WE MUST EXAMINE WHAT THE ROUNDED CONSTANT WILL BE***)%
		C1H_.NODE[CONST1]; C1L_.NODE[CONST2]; COPRIX_KDPRL;	!ROUND THE NUMBER IN C1H-C1L
		CNSTCM();						! LEAVING THE RESULT IN C2H
		(.C2H AND #777777) EQL 0
	END;
	%(***DOUBLE-PREC CONSTANTS CAN NOT BE TREATED IMMED MODE***)%
	FALSE;
	%(***COMPLEX CONSTANTS CAN BE TREATED IMMED MODE IFF THE REAL PART IS
		IMMED SIZE AND THE IMAGINARY PART IS 0***)%
	((.NODE[CONST1] AND #777777) EQL 0) AND (.NODE[CONST2] EQL 0)
	TES
END$;

%(***TO TEST FOR A CONSTANT NEGATIVE***********)%
MACRO NEGATIVC(CNNODE)=
	BEGIN
		IF .CNNODE[VALTP1] EQL INTEG1
		THEN
		.CNNODE[CONST2] LSS 0
		ELSE
		.CNNODE[CONST1] LSS 0
	END$;







%(*****************OPCODE FIELDS USED EXPLICITLY***************************)%
BIND
	JRSTOC=#254^27,
	JUMPOC=#320^27,
	SKIPOC=#330^27,
	SKIPGEOC=#335^27;
BIND
	INDBIT=1^22;		!INDIRECT BIT

BIND	
	ADDBOCD=#273,
	ADDIOCD=#271,
	ADDMOCD=#272,
	AOJAOCD=#344,
	AOSOCD=#350,
	ASHOCD=#240,
	CAIOCD=#300,
	CAMOCD=#310,
	DMOVEOCD=#120,
	DMOVEMOCD=#124,
	FADRBOCD=#147,
	FADRMOCD=#146,
	FDVRMOCD=#176,
	FIXOCD=#122,
	FLTROCD=#127,
	FSCOCD=#132,
	HRLZIOCD=#515,
	IDIVMOCD=#232,
	IMULMOCD=#222,
	JRSTOCD=#254,
	JUMPOCD=#320,
	JUMPGEOCD=#325,
	JUMPLOCD=#321,
	MOVEIOCD=#201,
	MOVEOCD=#200,
	MOVEMOCD=#202,
	MOVNOCD=#210,
	MOVNIOCD=#211,
	MOVNMOCD=#212,
	MOVNSOCD=#213,
	MOVSIOCD=#205,
	SETCAMOCD=#452,
	SETCMOCD=#460,
	SETCMBOCD=#463,
	SETZBOCD=#403,
	SETOBOCD=#477,
	SKIPOCD=#330,
	SOJAOCD=#364,
	SOSOCD=#370,
	SUBIOCD=#275,
	SUBMOCD=#276;
%(***************************************************************************	
	DEFINE THE FIELDS OF THE NODES USED FOR IOLISTS (OPRCLS=IOLSCLS)
***************************************************************************)%

%(***
A BRIEF PICTURE (DATACALL NODES HAVE ONLY 2 WORDS
		 SLISTCALL NODES HAVE 3 WORDS)

	-----------------------------------------
0	! IOLSTLBL AND	 	! CLINK		!
	! IOLCMPLX		!		!
	-----------------------------------------
1	! IOLSTPTR		! OPERATOR	!
	-----------------------------------------
2	! IOLALTCMPLX		! IOLCOMNSUB OR	!
	!			! SCALLCT	!
	-----------------------------------------
3	! E1INCR (E1LISTCALL)	! ECNTPTR	!
	-----------------------------------------

AN EALISTCALL NODE

	-----------------------------------------
0	! E2INCR (E2LISTCALL)	! CLINK		!
	-----------------------------------------
1	! E2ARREFPTR		! OPERATOR	!
	-----------------------------------------
***)%

	%(***FIELDS IN ALL IOLSCLS NODES***)%
MACRO
	IOLSTLBL=0,0,LEFT$;
	%(***FIELDS IN DATACALL NODES***)%
MACRO
	DCALLELEM=0,1,LEFT$;

	%(***FIELDS IN SLISTCALL NODES***)%
MACRO
	SCALLELEM=0,1,LEFT$,
	SCALLCT=0,2,RIGHT$;


	%(***FIELDS IN IOLSTCALL NODES***)%
MACRO
	IOLSTPTR=0,1,LEFT$,	!PTR TO LINKED LIST OF SUBNODES
	IOLCMPLX=SRCCMPLX$,	!COMPLEXITY
	IOLCOMNSUB=SRCCOMNSUB$,	!COMMON SUBEXPRESSIONS
	IOLALTCMPLX=0,2,LEFT$;	!ALTERNATE COMPLEXITY IN
				!E1LISTCALL AND E2LISTCALL NODES

	%(***FIELDS IN E1LISTCALL AND E2LISTCALL NODES***)%
MACRO
	ECNTPTR=0,3,RIGHT$,	!PTR TO EXPRESSION FOR NUMBER OF ELEMS
				! OF EACH ARRAY TO BE PROCESSED
	ELSTPTR=0,1,LEFT$;	!PTR TO LINKED LIST OF ARRAY REFS

	%(***FIELDS IN E1LISTCALL NODES***)%
MACRO
	E1INCR=0,3,LEFT$;

	%(***FIELDS OF THE ELEMENTS OF THE LINKED LIST UNDER AN E2LISTCALL***)%
MACRO
	E2INCR=0,0,LEFT$,		!PTR TO EXPRESSION FOR INCREMENT TO BE
					! USED FOR THIS ARRAY
	E2ARREFPTR=0,1,LEFT$;		!PTR TO ARRAYREF NODE

%(***************************************************************************
	DEFINE AN OBJECT-CODE WORD AS A STRUCTURE.
	DEFINE THE FIELDS OF THAT WORD FOR FOROTS ARG BLOCKS.
***************************************************************************)%

STRUCTURE OBJECTCODE[WD,POS,SIZE]=
   (.OBJECTCODE+.WD)<.POS,.SIZE> ;



	%(***DEFINE THE FIELDS OF AN INSTRUCTION***)%
MACRO
	OBJADDR=0,0,18$,	!ADDRESS FIELD
	OBJIXF=0,18,5$,		!INDIRECT AND INDEX FIELDS
	OBJREG=0,23,4$,		!REGISTER FIELD
	OBJOPCOD=0,27,9$;		!OPCODE
	%(***DEFINE THE FIELDS USED FOR FOROTS ARG BLOCKS***)%
MACRO
	OTSWHOLE=0,0,36$,
	OTSCNT=0,27,9$,
	OTSTYPE=0,23,4$,		!VALUE-TYPE ALWAYS GOES IN BITS 9-12
	OTSINX=0,18,4$,		!INDEX FIELD
	OTSIND=0,22,1$,		!INDIRECT BIT
	OTSADDR=0,0,18$,		!ADDRESS FIELD
	OTSUNIT=0,0,18$,		!UNIT NUMBER ALWAYS GOES INTO BITS 18-35
	OTSFORM=0,0,18$,		!PTR TO FORMAT 
	OTSARRFMTFLG=0,35,1$,		!FLAG FOR "FORMAT STMNT IS AN ARRAY"
	OTSFSIZ=0,18,17$,	!FORMAT SIZE
	OTSIDN=0,27,9$,		!FOR AN IOLIST ELEMENT - IDENTIFIES THE CLASS OF ELEM
	OTSMEMRF=0,0,23$;		!THE 23 BITS DESCRIBING MEMORY REFERENCE


	%(***DEFINE VALUES FOR IDN FIELD FOR IOLIST ELEMENTS***)%
BIND
	OTSZER=0,
	OTSDATA=1,
	OTSSLIST=2,
	OTSELIST=3,
	OTSFIN=4;


BIND
	OTSZERWD=OTSZER^27,
	OTSFINWD=OTSFIN^27;


	%(***DEFINE ARG TYPE CODES THAT ARE USED FOR FOROTS CALLS***)%
BIND	ADDRTYPE=#7,		!TYPE CODE FOR A LABEL
	IMMEDTYPE=0;		!TYPE CODE INDICATING TO PICK UP ARG IMMED MODE


%(***************************************************************************
	SPECIFIC VALUES FOR FIELDS IN AN ARITHMETIC-IF NODE
***************************************************************************)%

	%(***VALUES FOR AIFLBEQV FIELD****)%
BIND
	NOLBEQV=0,
	LELBEQV=1,		!LSS LABEL SAME AS EQL LABEL
	LGLBEQV=2,		!LSS LABEL SAME AS GTR LABEL
	GELBEQV=3;		!GTR LABEL SAME AS EQL LABEL

	%(***VALUES FOR AIFLBNXT FIELD*******)%
BIND
	NOLBNXT=0,
	LLBNXT=1,		!LSS LABEL IS NEXT STMNT
	ELBNXT=2,		!EQL LABEL IS NEXT STMNT
	GLBNXT=3;		!GTR LABEL IS NEXT STMNT


	%(***WHEN SWAP THE GTR AND LESS LABELS (BECAUSE MULTIPLY BY -1), USE THE
		FOLLOWING MACRO TO ADJUST THE "AIFLBNXT" AND "AIFLBEQV"  FIELDS***)%
	MACRO SWPAIFFLGS(STMNT)=
	BEGIN
		IF .STMNT[AIFLBNXT]		!IF LAST BIT OF AIFLBNXT IS ON
		THEN
		STMNT[AIFLBNXT]_.STMNT[AIFLBNXT] XOR #2;	!THEN COMPLEMENT 1ST BIT
		IF .STMNT[AIFLBEQV]				!IF LAST BIT OF AIFLBEQV ON
		THEN
		STMNT[AIFLBEQV]_.STMNT[AIFLBEQV] XOR #2;	!THEN COMPLEMENT 1ST BIT
	END$;


%(***************************************************************************
	DEFINE THE STRUCTURE OF AN ARGUMENT LIST.
	CERTAIN FIXED FIELDS ON THE LIST WILL BE REFERENCED SIMPLY BY NAME.
	FIELDS CORRESPONDING TO THE NTH ARG WILL BE REFERENCED BY [N,NAME]
	NOTE THAT THE FIRST ARG HAS N=1 (NOT!!!! 0)
	NOTE THAT THE COUNT FIELD OF THE LIST WILL BE POSITIVE AND EQUAL
	TO THE NUMBER OF ARGS.
***************************************************************************)%

STRUCTURE ARGUMENTLIST[ARGINDEX,WD,POS,SIZE]=
	(@.ARGUMENTLIST+2+(.ARGINDEX-1)+.WD)<.POS,.SIZE>;


	%(***DEFINE THE FIXED FIELDS THAT OCCUR AT THE START OF EVERY ARGUMENT LIST - 
		DEFINE ALL THESE FIELDS IN TERMS OF A NEGATIVE NUMBER OF WDS FROM THE
		ENTRY FOR THE FIRST ARGUMENT (HENCE HAVE THE ARGINDEX FIELD=1) ***)%
MACRO
	ARGLABEL=1,-2,LEFT$,
	ARGLINK=1,-2,RIGHT$,
	ARGCOUNT=1,-1,RIGHT$;

	%(***DEFINE THE FIELDS THAT ARE REPEATED FOR EACH ARGUMENT. 
		WILL ALWAYS REFERENCE THESE FIELDS BY A REF OF THE FORM:
			ALIST[N,FIELDNAME]
		WHERE N IS THE NUMBER OF THE ARGUMENT DESIRED
	*********)%
MACRO
	ARGNPTR=0,RIGHT$,		!PTR TO THE EXPRESSION NODE FOR THE ARG
	AFLGFLD=0,LEFT$,		!FLAGS
	AVALFLG=0,35,1$;		!FLAG IS SET IF ARG IS A DATA ITEM OR
					! COMMON SUBEXPR


	%(***DEFINE THE FOLLOWING FIELD SO THAT PHASE 1 CAN REFERENCE THE AVALFLG
		BY USING A "BASE" STRUCTURE ON A GIVEN WORD*****)%
MACRO	P1AVALFLG=0,0,35,1$;


	%(***DEFINE MACRO THAT DESCRIBES NUMBER OF WDS NECESSARY IN AN ARGLIST THAT
		INCLUDES "ACT" NUMBER OF ARGS***)%
MACRO	ARGLSTSIZE(ACT)=(2+ACT)$;



%(*******DEFINE FIELDS USED IN THE ARGUMENT LIST AT AN ENTRY STATEMENT*****)%
MACRO	ENTGALLOCFLG=0,35,1$,	!FLAG FOR "GLOBAL ALLOCATOR HAS ASSIGNED THIS
				! VAR TO LIVE IN A REGISTER"
	ENTSAVREGFLG=0,34,1$,	!FLAG INDICATING THAT IT WILL BE USEFUL TO

				! HAVE THIS VAR IN A REG LATER IN THIS BASIC
				! BLOCK (FLAG IS SET BY BASIC BLOCK ALLOCATOR)
	ENTNOCOPYFLG=0,33,1$,	!FLAG INDICATING THAT NO LOCAL COPY OF THE ARG
				! SHOULD BE MADE
	ENTSONNXTUSE=0,22,11$,	!BLOCK-INTERNAL-SEQ-NUMBER OF THE STMNT
				! WHERE THIS VAR IS NEXT USED (0 IF IT IS
				! NOT USED IN THE 1ST BASIC BLOCK)
	ENTAC=0,18,4$;		!AC TO BE USED WHEN PICKING
				! UP THIS ARG


%(***************************************************************************
	DEFINE THE STRUCTURE THAT WILL BE MAPPED ON THE LIBRARY FN ATTRIBUTE
	TABLE.
	FOR EACH LIBRARY-FN WILL HAVE A "LIBRARY-FN-INDEX" THAT INDICATES ITS
	POSITION IN THIS TABLE. THE FIRST ENTRY HAS INDEX =0.
***************************************************************************)%
STRUCTURE LIBATTSTR[FNINDEX,WD,POS,SIZE,CODE,ARGTYP1]=
	%(***FOR MOST FIELDS BOTH "CODE" AND "ARGTYP1" ARE 0***)%
	IF .CODE EQL 0
	THEN
	(.LIBATTSTR+2*.FNINDEX+.WD)<.POS,.SIZE>

	%(***FOR GENERIC FUNCTIONS ONLY - TO PICK UP THE NAME OF THE ACTUAL
		FUNCTION TO USE FOR A GIVEN ARG-TYPE.
		HAVE "CODE" EQUAL TO 1, "ARGTYP1" EQUAL TO THE VALTP1
		FIELD OF THE ARGUMENT.
	**********)%
	ELSE
	%(***GO INDIRECT THRU  THE "ATTGENPTR" FIELD - ADD "ARGTYP1" TO
		THE PTR IN THAT FIELD TO GET A PTR TO THE WD THAT
		INDICATES THE ACTUAL FN TO USE (THAT WD WILL ITSELF CONTAIN
		A PTR BACK TO A FUNCTION-TABLE ENTRY)
	*******)%
	(.(.LIBATTSTR+2*.FNINDEX+.WD)<.POS,.SIZE> + .ARGTYP1)<0,36>;

	%(***DEFINE MACROS THAT DESCRIBE THE FIELDS FOR A GIVEN FUNCTION INDEX***)%
MACRO
	ATTFNATTRIB=0,0,36,0,0$,	!THE FIRST WORD OF THE ENTRY WILL BE
					! COPIED INTO THE SYMBOL TABLE ENTRY
					! FOR THE FUNCTION NAME (INTO THE IDFNATTRIB FIELD)
	ATTINLINFLG=0,35,1,0,0$,	!BIT 0 OF 1ST WD IS FLAG FOR IN-LINE-FN
	ATTGENERFLG=0,33,1,0,0$,	! GENERIC FN FLAG
	ATTARGTYP=0,28,5,0,0$,	! VALTYPE FOR EXPECTED ARG
	ATTRESTYPE=0,23,5,0,0$,	! VALTYPE OF RESULT
	ATTARGCT=0,18,5,0,0$,	! NUMBER OF ARGS EXPECTED
	ATTNEWOPR=0,0,18,0,0$,	!OPERATOR TO BE SUBSTITUTED FOR FN CALL
				! IF THIS FN IS TO BE GENERATED IN LINE
	ATTGENPTR=1,0,18,0,0$,	!FOR GENERIC FNS ONLY - PTR TO SUBTABLE
				! DESCRIBING WHICH FNS TO USE FOR EACH ARG TYPE
	ATTACTFN=1,0,18,1$;	!FOR GENERIC FNS ONLY - TO GET A PTR TO
				! THE ACTUAL FN TO USE WILL GO INDIRECT THRU
				! THE "ATTGENPTR" FIELD AND THEN ADD ON THE TYPE OF THE ARG


	BIND	ILGARGTYPE=-1;	!FOR GENERIC FNS - IF A GIVEN ARG TYPE IS ILLEGAL
				! THE "ATTACTFN" FIELD FOR THAT TYPE WILL CONTAIN THIS CODE
	BIND	VARGCTFLG=#37;	!FUNCTIONS THAT CAN TAKE AN ARBITRARY NUMBER OF
				! ARGS (EG MAX,MIN) HAVE THE "ATTARGCT" SET TO THIS VAL



%(***************************************************************************
	DEFINE THE STRUCTURE TO BE MAPPED ON THE LIST OF ARG-CODES
	AND CORRESPONDING  VALUES THAT OCCURS UNDER AN OPEN STATEMENT
***************************************************************************)%

STRUCTURE OPENLIST[ARGINDEX,WD,POS,SIZE]=
	(@.OPENLIST+.ARGINDEX+.WD)<.POS,.SIZE>;


	%(***DEFINE THE FIELDS USED FOR A GIVEN INDEX***)%
MACRO	OPENLCODE=0,LEFT$,	!CODE FOR FOROTS FOR THIS ARG
	OPENLPTR=0,RIGHT$;	!PTR TO THE CONSTANT TABLE OR SYMBOLTABLE
				! ENTRY FOR THE VALUE FOR THIS ARG TO FOROTS

	%(***DEFINE VALUES FOR OPENLCODE***)%
BIND	OPNCDIALOG=01,		!DIALOG
	OPNCACCESS=02,		!ACCESS
	OPNCDEVICE=03,		!DEVICE
	OPNCBUFCOUNT=04,	!BUFFER COUNT
	OPNCBLOCKSIZE=05,	!BLOCK SIZE
	OPNCFILENAME=06,	!FILE NAME
	OPNCPROTECTION=07,	!PROTECTION
	OPNCDIRECTORY=#10,	!DIRECTORY
	OPNCLIMIT=#11,		!LIMIT
	OPNCMODE=#12,		!MODE
	OPNCFILESIZE=#13,	!FILE SIZE
	OPNCRECORDSIZE=#14,	!RECORD SIZE
	OPNCDISPOSE=#15,	!DISPOSE
	OPNCVERSION=#16,	!VERSION
	OPNCREELS=#17,		!REELS
	OPNCMOUNT=#20,		!MOUNT
	OPNCERROR=#21,		!ERROR
	OPNCASSOCIATE=#22;	!ASSOCIATE

%(***************************************************************************
	DEFINE THE STRUCTURE OF THE SYMBOL TABLE
***************************************************************************)%
STRUCTURE SYMTABENTRY[DMY,WD,POS,SIZE]=
	(@.SYMTABENTRY+.WD)<.POS,.SIZE>;





%(***************************************************************************
	DEFINE THE STRUCTURE OF THE DIMENSION TABLE
***************************************************************************)%
STRUCTURE DIMENTRY[DMY,WD,POS,SIZE]=
	(@.DIMENTRY+.WD)<.POS,.SIZE>;
MACRO DIMNUM=0,0,18,16$;			!NUMBER OF DIMENSIONS
MACRO	ADJDIMFLG=0,0,35,1$;			!FLAG FOR ADJUSTABLY DIMENSIONED
MACRO 	ARASIZ=0,0,RIGHT$;			!NUMBER OF WDS IN THE ARRAY
						!PTR TO A CONSTANT TABLE ENTRY UNLESS
						! ARRAY IS ADJ DIMENSIONED,
						! IN WHICH CASE, HAVE PTR TO A TMP
MACRO	ARAOFFSET=0,1,LEFT$;			!VALUE OF OFFSET FOR THIS
						! ARRAY IF DIMENSIONS ARE
						! CONSTANT; POINTER TO LOC
						! IN WHICH THE OFFSET WILL
						! BE STORED IF DIMENSIONS
						! ARE VARIABLE
MACRO	ARADDRVAR=0,1,RIGHT$;		!FOR FORMAL ARRAYS THAT ARE NOT ADJUSTABLY
						! DIMENSIONED, THIS FIELD POINTS 
						! TO A "PSEUDO" SYMBOL TABLE ENTRY
						! FOR THE ARRAY NAME WITH THE TYPE
						! FIELD SET TO INTEGER. IT IS THIS SYMBOL
						! THAT IS USED IN THE ADDRESS CALC
MACRO	ARADLBL=0,2,LEFT$;	!PTR TO LABEL TABLE ENTRY
				! FOR LABEL ON THE ARG-BLOCK DESCRIBING THE DIMENSIONS
				! OF THIS ARRAY THAT WILL BE OUTPUT IF THE
				! ARRAY WAS PROTECTED OR THE USER SPECIFIED THE DEBUG SWITCH
MACRO	DIMENS(X)=0,3+2*X,FULL$,		!DIMENSIONS FOR THE XTH DIMENSION
	DIMENL(X)=0,3+2*X,LEFT$,		!LOWER BOUND OF DIMENSION X
	DIMENU(X)=0,3+2*X,RIGHT$,		!UPPER BOUND OF DIMENSION X
	DVARFLGS(X)=0,4+2*X,LEFT$,		!USED TO CLEAR FLAGS
	DVARLBFLG(X)=0,4+2*X,34,1$,		!FLAG FOR LOWER BOUND A  VARIABLE
	DVARUBFLG(X)=0,4+2*X,33,1$,		! FOR UPPER BOUND A VARIABLE
	DVARFACTFLG(X)=0,4+2*X,35,1$,		! FOR FACTOR A VARIABLE
	DFACTOR(X)=0,4+2*X,RIGHT$;		!FACTOR THAT SS FOR THIS
						! DIMENSION IS MULTIPLIED BY
						! THIS IS A PTR TO A CONSTANT TABLE ENTRY
						! IF PRECEEDING DIMENSIONS WERE CONSTANT,
						! A PTR TO A SYMBOL TABLE ENTRY FOR A
						! VAR IN WHICH THE VAL IS STORED IF VARIABLE
MACRO FIRSTDIM=0,3,WHOLE$;

	%(***THE SUBENTRY FOR A GIVEN DIMENSION***)%
STRUCTURE DIMSUBENTRY[WD,POS,SIZE]=
	(@.DIMSUBENTRY+.WD)<.POS,.SIZE>;

MACRO
	DIMLB=0,LEFT$,
	DIMUB=0,RIGHT$,
	VARLBFLG=1,34,1$,			!FLAG FOR "LOWER BOUND ON THIS DIMENSION
						! A VARIABLE
	VARUBFLG=1,33,1$,			!UPPER BOUND A VARIABLE
	VARFACTFLG=1,35,1$;			!FACTOR FOR THIS DIMENSION A VARIABLE
MACRO	DIMFACTOR=1,RIGHT$;		!FACTOR TO MULTIPLY SS OF THIS DIMENSION

BIND	DIMSUBSIZE=2;	!NUMBER OF WDS IN EACH SUBENTRY



%(*********
	DEFINE VALUES OF LABEL TABLE FIELDS USED FOR PEEPHOLING
**********)%

	%(***VALUES FOR SNSTATUS FIELD***)%
BIND	OUTPBUFF=2,			!LABEL IS OUT OF THE PEEPHOLE BUFFER
	INPBUFF=1,			!LABEL IS STILL IN THE PEEPHOLE BUFFER
	UNRESOLVED=0;			!LABEL IS UNRESOLVED
BIND	LBTBENDMK=0;				!VALUE OF NXTLAB FIELD
						! FOR LAST LINK




%(**************
	DEFINE STRUCTURE FOR PEEPHOLE BUFFER
****************)%

	%(***SIZE OF PEEPHOLE BUFFER ENTRIES****)%
BIND PBFENTSIZE=3;			!NUMBER OF WORDS IN EACH PEEPHOLE BUFFER ENTRY
BIND PBFENTCT=50;			!NUMBER OF ENTRIES IN THE PEEPHOLE BUFFER
BIND PBFOUTCT=25;	!NUMBER OF ENTRIES FROM THE BUFFER THAT WE OUTPUT
			! AT A TIME. WHEN THE 50 ENTRIES ARE FULL, WE OUTPUT
			! THE 1ST 25 INSTRS, AND LEAVE THE REMAINING 25
			! TO BE PEEPHOLED WITH ANY FURTHER INSTRS THAT WIL
			! BE ENTERED
BIND PBFOUTSIZ=PBFOUTCT*PBFENTSIZE;	!SIZE OF THE BLOCK OF ENTRIES
			! AT THE TOP OF THE BUFFER THAT WE
			! OUTPUT AT A ONE TIME
BIND PBFSIZE=PBFENTCT*PBFENTSIZE + 2;		!NUMBER OF WORDS IN THE PEEPHOLE BUFFER
					! (KEEP 1 WD AFTER THE LAST ENTRY TO HOLD
					! A POSSIBLE LABEL AND A POSSIBLE ISN)


	%(****STRUCTURE FOR LOOKING AT A PEEPHOLE*******)%
	%(*******THE ARG INST INDICATES WHICH INSTRUCTION OF THE PEEPHOLE***)%
STRUCTURE	PEEPHOLE[INST,WD,POS,SIZE]=
	(@.PEEPHOLE + PBFENTSIZE*.INST +.WD)<.POS,.SIZE>;


	%(****STRUCTURE FOR A PEEPHOLE BUFFER ENTRY***)%
STRUCTURE PEEPFRAME[WD,POS,SIZE]=
	(.PEEPFRAME+.WD)<.POS,.SIZE>;

	%(***STRUCTURE FOR A PTR TO  A PEEPHOLE BUFFER ENTRY*****)%
STRUCTURE PPEEPFRAME[WD,POS,SIZE]=
	(@.PPEEPFRAME+.WD)<.POS,.SIZE>;


%(*****DEFINE FIELDS FOR PEEPHOLE BUFFER FRAME*****)%
MACRO	PBFISN=0,WHOLE$,		!ISN FOR STMNT BEGUN BY THIS INSTR
					! -1 FOR INSTRS THAT DO NOT START STMNTS
	 PBFLABEL=1,LEFT$,			!PTR TO LABEL TABLE ENTRY FOR THE 1ST
						!  LABEL ASSOCIATED WITH THIS
						! LOC
	PBFSYMPTR=1,RIGHT$,			!0 IF ADDR FIELD IS A LABEL
						!1 IF ADDR FIELD HAS NO SYMBOLIC REPR
						!2 IF ADDR FIED IS A PTR TO THE SIXBIT
						! FOR AN IMPLICITLY CALLED FUNCTION
						!3 IF ADDR IS A PTR TO A SYMBOL TABLE ENTRY
						! FOR AN EXPLICITLY CALLED FN
						! OTHERWISE A PTR TO THE SYMBOL TABLE,CONSTANT
						! TABLE OR TEMP TABLE ENTRY FOR THIS ADDR FIELD
	PBFINSTR=2,WHOLE$,
	PBFADDR=2,RIGHT$,		!ADDRESS FIELD OF THE INSTR
	PBFOPCOD=2,27,9$,		! OP-CODE
	PBFOPKEY=2,27,5$,		! LAST 5 BITS OF OPCODE, USED AS
					! KEY IN PEEPHOLE OPTIMIZER
	PBFREG=2,23,4$,			!REG FIELD
	PBFINDEX=2,18,4$,		!INDEX AND INDIRECT FIELDS
	PBFMEMREF=2,0,23$;		!ADDRESS,INDIRECT, AND INDEX FIELDS
BIND	NOLABEL=0;				!FLAG FOR "NO LABEL YET ASSOCIATED
						! WITH THIS LOC"
BIND	NOISN=-1;		!CODE FOR "NO ISN ASSOCIATED WITH THIS INSTR"
				! (IE THE INSTR IS IN THE MIDDLE OF A STMNT)

%(*******SPECIAL VALS FOR PBFSYMPTR FIELD*******)%
BIND
	PBFLABREF=0,			!ADDRESS FIELD IS A LABEL, RH IS AN INSTRUCTION
	PBFNOSYM=1,			!ADDRESS FIELD IS AN OCTAL CONSTANT, RH IS AN INSTR
	PBFIMFN=2,			!ADDR FIELD IS A PTR TO AN IMPLICITLY CALLED FN
	PBFEXFN=3,			!ADDR FIELD IS A PTR TO AN EXPLICITLY CALLED FN
	PBF2LABREF=4,			!BOTH HALVES OF WD ARE PTRS TO LABEL TABLE
					! ENTRIES
	PBF2NOSYM=5,			!BOTH HALVES OF WD ARE OCTAL CONSTANTS WITH
					! NO SYMBOLIC REPRESENTATION
	PBFFORMAT=6,			!RIGHT HALF WORD IS FORMAT ADDRESS
	PBFLLABREF=7,			!LEFT HALF IS A LABEL REFERENCE
					!USED PRIMARILY FOR ARGUMENT BLOCKS TO
					!FOROTS FOR THE END=,ERR= WORD
	PBFENTRY=8;			!FOR A GLOBAL ENTRY (AS SUBROUTINE
					!OR ENTRY NAME).


BIND	PBFCODMAX=16;		!CAN NEVER USE ANY NUMBER GTR THAN 16 AS A SPECIAL
				! CODE VALUE FOR PSYMPTR, BECAUSE ANY NUMBER GTR
				! THAN 16 MIGHT BE THE ADDRESS OF A NODE


%(***************************************************************************
	TO GENERATE A JRST INSTRUCTION
***************************************************************************)%
MACRO JRSTGEN(ADDR)=
BEGIN
	PBOPWD_JRSTOC OR ADDR;
	PSYMPTR_PBFLABREF;			!FLAG FOR "ADDRESS FIELD OF THIS INSTR IS
						! A LABEL"
	OBUFF();
END$;


	%(***TO GENERATE JRST INDIRECT***)%
MACRO JRSTIGEN(ADDR)=
BEGIN
	PBOPWD_JRSTOC OR INDBIT OR ADDR;
	PSYMPTR_PBFLABREF;
	OBUFF();
END$;
%(***************************************************************************
	DEFINE THE VARIOUS WAYS OF BUILDING INDICES INTO THE OPGENDISPATCH TABLE.
	EACH KIND OF INDEX IS COMPOSED OF SOME COMBINATION OF THE FLAG AND OPERATOR
	FIELDS OF THE NODES FOR WHICH CODE IS TO BE GENERATED.
***************************************************************************)%


	%(****TO GET THE VAL OF AN ARGNODE INTO THE REG FOR COMPUTATION OF THE PARENT (WHEN
		THE VAL OF THE SON IS WITHIN REACH OF 1 INSTR.
		DEPENDS ON THE VALS OF NEGFLG,NOTFLG,SAMEFLG,IMMEDFLG
		FOR THE ARG INVOLVED, ALSO ON THE VALUE-TYPE OF THE ARG.
	*******)%
MACRO	GETA1OPIX(PNODE,ANODE)=
	BEGIN
		(.PNODE[A1FLG1]^2 + .ANODE[VALTP1] +(IF .KA10FLG THEN OPGETA ELSE OPGETI))
	END$;

MACRO	GETA2OPIX(PNODE,ANODE)=
	BEGIN
		(.PNODE[A2FLG1]^2 + .ANODE[VALTP1] + (IF .KA10FLG THEN OPGETA ELSE OPGETI))
	END$;

	%(***FOR DO-LOOPS - DONT ACTUALLY HAVE AN EXPRESSION NODE BUT WANT TO GET VAL
		HOW TO DO SO DEPENDS ON VAL OF IMMEDFLG, VALTYPE AND NEGATE FLAG***)%
MACRO	DOGETAOPIX(IMFLG,VLTP,NEGFLAG)=
	(NEGFLAG^4+IMFLG^2 + VLTP + (IF .KA10FLG THEN OPGETA ELSE OPGETI))$;





	%(****TO COMPUTE THE VALUE OF A NON-CONTROL BOOLEAN NODE. CODE TO BE GENERATED
		DEPENDS ON A2NOTFLG, A2IMMEDFLG, AND MEMCMPFLG AND THE OPERSP***)%
MACRO	BOOLOPIX(PNODE)=
	(.PNODE[A2NOTFLG]^4 + .PNODE[A2IMMEMCMPFLGS]^2 + .PNODE[OPERSP] + OPGBOO)$;


	%(******TO SKIP THE NEXT INSTRUCTION WHEN A RELATIONAL HAS THE VAL INDICATED
		BY 'SKPCND'. CODE TO BE GENERATED DEPENDS ON WHETHER THE ARGS
		OF THE RELATIONAL ARE SINGLE OR DOUBLE WD AND WHETHER
		THE 2ND ARG IS IMMED*******)%
	%(*****(NOTE THAT IF THIS IS EVER CHANGED, THEN DPIMMRELOPIX DEFINED
		BELOW SHOULD ALSO BE CHANGED)***)%
	MACRO RELOPIX(PNODE,ANODE,SKPCND)=
	BEGIN
		REGISTER MODE;			!MODE ON WHICH TO SKIP
		MODE_.PNODE[OPERSP];		!MODE SPECIFIED IN RELATIONAL
		IF FALSITY(SKPCND)
		THEN MODE_CMREL(.MODE);		!IF WANT TO SKIP ON REL FALSE

		.ANODE[DBLFLG]^4 + .PNODE[A2IMMEDFLG]^3 + .MODE + OPGREL
	END$;


	%(****FOR A RELATIONAL BETWEEN A DOUBLE-PREC AND ZERO. CAN USE SAME
		CODE AS USE TO COMPARE A REAL TO ZERO (SEE RELOPIX ABOVE)***)%
	MACRO	DPIMMRELOPIX(PNODE,SKPCND)=
	BEGIN
		REGISTER MODE;	!MODE ON WHICH TO SKIP
		MODE_.PNODE[OPERSP];
		IF FALSITY(SKPCND)
		THEN MODE_CMREL(.MODE);	!IF WANT TO SKIP ON RELATIONAL FALSE

		1^3 + .MODE + OPGREL	!HAVE A2IMMEDFLG (SINCE COMPARE TO 0)
					! AND DO NOT HAVE DOUBLE-WD COMPARE)
	END$;



	%(*****TO COMPUTE THE VAL OF AN ARITHMETIC NODE.
		DEPENDS ON THE VALS A2IMMEDFLG,MEMCMPFLG,VALTYPE, AND OPERSP OF THE PARENT
		NOTE THAT EXPONENTIATION NODES WERE CONVERTED TO FUNCTION-CALLS DURING
		THE COMPLEXITY WALK. HENCE NEVER HAVE TO GET OPGNTA INDEX FOR EXPONEN
	********)%
MACRO	ARITHOPIX(PNODE)=
	BEGIN
		(.PNODE[A2IMMEMCMPFLGS]^4+.PNODE[OPRSP2]^2+.PNODE[VALTP1]+
			(IF .KA10FLG THEN OPGARA ELSE OPGARI))
	END$;


	%(*********FOR THE ADD TO THE INDEX FOR A DO-LOOP********)%
MACRO	DOARITHOPIX(VLTP,MCPFLG,IMFLG,NEGFLAG)=
		%(***HAVE A2IMMEDFLG=IMFLG,  MEMCMPFLG=MCPFLG,
			OPERATOR IS ADD IF NEGFLAG IS 0, SUB IF NEGFLAG IS 1***)%
	(IMFLG^5 + MCPFLG^4 + (ADDOP+NEGFLAG)^2 + VLTP + (IF .KA10FLG THEN OPGARA ELSE OPGARI))$;

	%(***FOR THE ADD TO BOTH AT THE END OF A MATERIALIZED DO LOOP
		WHEN THE INDEX IS REAL OR INTEGER***)%
MACRO	DOARBOTHOPIX(VLTP)=
	(3^4		!SET BITS FOR MEMCMPFLG AND OPTOBOTHFLG
	  +ADDOP^2	! ADD
	  +VLTP		! INTEGER OR REAL
	   +OPGARI	! BASE OF TABLE FOR CODE FOR KI10 (SINCE NO DP,
			! CAN ALWAYS USE KI10 CODE)
	)$;



	%(*****TO COMPUTE THE VAL OF A TYPE CONVERSION NODE.
		WILL BE GENERATING CODE ONLY WHEN  DESTIN  TYPE
		IS REAL,INTEGER,DOUBLEPREC,OR COMPLEX (IE NEVER HAVE
		TO DEAL WITH OCTAL,DOUBLE-OCTAL,LOGICAL,LITERAL,OR CONTROL)
		THUS ONLY NEED TO DIFFERENTIATE BETWEEN THESE 4 TYPES
		THE TYPE TO BE CONVERTED TO (SPECIFIED BY THE VALTYPE FIELD OF THE
		TYPE-CONVERION NODE).
		THE OPERSP FIELD OF THE TYPE CONVERSION NODE, INDICATES
		THE ORIGINAL TYPE BEING CONVERTED.
	*******)%
	MACRO	TPCNVIX(PNODE)= (.PNODE[OPERSP]^2 + .PNODE[VALTP1] + 
			(IF .KA10FLG THEN OPGTCA ELSE OPGTCI))$;




	%(****TO COMPUTE THE VALUE OF A NEGNOT NODE.  WHEN PHASE 2 SKELETON IS PRESENT,
		THERE WILL BE FEW OF THESE. (EG FOR F(-X), NOT(-X))*********)%

	%(***WHEN A2NEG,A2NOT, OR A2SAMEFLG IS SET, WILL USE GETA2OPIX TO GET THE ARG
		INTO A REG, AND THEN USE THE FOLLOWING INDEX*****)%
MACRO	NEGNOT1IX(PNODE)=
	(.PNODE[MEMCMPFLG]^3 + .PNODE[OPERSP]^2 + .PNODE[VALTP1] + (IF .KA10FLG THEN OPGN1A ELSE OPGN1I))$;

	%(***OTHERWISE, USE AN INDEX BASED ON A2IMMED, MEMCMP, OPERSP, VALTP1****)%
MACRO	NEGNOT2IX(PNODE)=
	(.PNODE[A2IMMEMCMPFLGS]^3 + .PNODE[OPERSP]^2 + .PNODE[VALTP1] + (IF .KA10FLG THEN OPGN2A ELSE OPGN2I))$;

	%(***TO COMPUTE THE VALUE OF A P2MUL OR P2PL1MUL  -
		CODE TO BE GENERATED DEPENDS ON VALTYPE OF THE NODE AND
		ON WHICH OP IS TO BE PERFORMED****)%
MACRO	SPECOPIX(PNODE)=
	BEGIN
		%(***IF ARG IS IMMEDIATE AND OPERATION IS P2PLUS1-MULTIPLY , HAVE A
			SPECIAL CASE***)%
		IF .PNODE[A1IMMEDFLG]
		THEN
		BEGIN
			IF .PNODE[OPERSP] EQL P2PL1OP
			THEN (.PNODE[A1NEGFLG]^2 + .PNODE[VALTP1] + OPP21I)
			ELSE
			(.PNODE[OPERSP]^3 + .PNODE[A1NEGFLG]^2 +.PNODE[VALTP1]
				+(IF .KA10FLG THEN OPGSPA ELSE OPGSPI))
		END
		ELSE
		(.PNODE[OPERSP]^3 + .PNODE[A1NEGFLG]^2 +.PNODE[VALTP1]
			+(IF .PNODE[MEMCMPFLG] THEN OPGSPM		!FOR OPS DONE TO MEMORY DONT CARE
									! WHETHER ARE KA OR KI
				ELSE IF .KA10FLG THEN OPGSPA ELSE OPGSPI))
	END$;



	%(***TO GENERATE CODE FOR AN IN-LINE FUNCTION WHEN ARG1 FOR THAT FN IS ALREADY IN REGFORC**)%
MACRO	ILFIX(PNODE)=
	BEGIN
		IF .PNODE[A2IMMEDFLG]
		THEN
		.PNODE[OPERSP] + OPGILI
		ELSE
		IF .PNODE[OPERATOR] EQL DABSFNOP
		 THEN .KA10FLG+OPGDBF ELSE .PNODE[OPERSP]+OPGILF
	END$;

	%(***TO GENERATE CODE FOR AN IN-LINE FN WHEN ARG IS NOT IN REGFORCOMP (USED FOR
		ABS,IABS (NOT IN RELEASE 1), AND SIGN ***)%
MACRO	ILF1IX(PNODE)=
	IF .PNODE[OPERATOR] EQL DABSFNOP
	 THEN .KA10FLG+OPGDB1 ELSE .PNODE[OPERSP]+OPGIL1$;


	%(*****TO PERFORM THE ACTION SPECIFIED FOR A "STORECLS" NODE (WHICH IS USED
		WHEN EITHER A PTR TO AN ARRAY ENTRY OR THE CONTENTS OF THAT
		ENTRY MUST BE STORED IN A TEMPORARY************)%
MACRO	STCLSOPIX(PNODE)=
	(IF .PNODE[DBLFLG] AND (.PNODE[OPERSP] EQL STARVAL)	!FOR STORING A DOUBL-WD VAL
	THEN (.KA10FLG^1 +.PNODE[A2SAMEFLG] + OPGSTD)
	ELSE (.PNODE[OPERSP]^1 + .PNODE[A2SAMEFLG] + OPGSTC))$;


	%(*****TO STORE A VALUE THAT HAS BEEN COMPUTED****)%
MACRO	STOROPIX(PNODE)=
	BEGIN
		.PNODE[DBLFLG] + (IF .KA10FLG THEN OPGSTA ELSE OPGSTI)
	END$;

	%(******TO STORE THE VALUE OF THE RHS OF AN ASSIGNMENT STMNT
		INTO THE LHS. CODE TO BE GENERATED DEPENDS ON WHETHER THE VAL MUST
		BE NEGATED OR COMPLEMENTED, AND ON THE VALTYPE*****)%
	MACRO ASNOPIX(PNODE,LHSNODE)=
	BEGIN
		%(***IF THIS STATEMENT HAS A2IMMEDFLG AND A2SAMEFLG BOTH SET, IT
			MUST BE THAT THE RHS IS A REGCONTENTS NODE FROM WHICH WE
			ONLY WANT TO USE THE RIGHT HALF (BECAUSE IT IS AN AOBJN WD).***)%
		IF .PNODE[A2IMMEDFLG] AND .PNODE[A2SAMEFLG]
		THEN
		OPGASR

		ELSE
		.PNODE[A1NGNTFLGS]^2 + .LHSNODE[VALTP1] + (IF .KA10FLG THEN OPGASA ELSE OPGASI)
	END$;


	%(****TO GENERATE CODE FOR AN ARITHMETIC-IF STATEMENT**********)%

MACRO
	AIFIX(STMNODE,CNEXPR)=
		(.STMNODE[AIFFLGS]^1 +
			.STMNODE[A1SAMEFLG]
			+ OPGAIF)$;

	%(***TO INIT A LOGICAL VALUE TO TRUE OR FALSE (-1 OR 0). CODE
		TO BE GENERATED DEPENDS ON WHETHER VAL IS TO BE LEFT IN A REG AND
		ON THE VAL TO BE STORED
		NOTE THAT "LOGVAL" IS EXPECTED TO BE 777777777777 FOR "TRUE"
	*****)%
MACRO	SETLOGIX(PNODE,LOGVAL)=
	((LOGVAL AND #2) + .PNODE[INREGFLG] + OPGSET)$;


	%(*****TO TRANSFER CONTROL WHEN ARG1 UNDER PNODE HAS THE SPECIFIED VAL TRUE OR FALSE.
		JMPCND WIL BE 777777777777 WHEN TRANSFER ON "TRUE" IS DESIRED, 0
		FOR TRANSFER ON FALSE.
	********)%
MACRO TSTARGTRIX(PNODE,JMPCND)=
	((JMPCND AND #2) + .PNODE[A1SAMEFLG] + OPGVTS)$;	!IF PNODE A1SAMEFLG IS SET
						! THEN THE ARG IS IN A REG

	%(*****TO TRANSFER CONTROL WHEN A SPECIFIED VAR HAS THE SPECIFIED VAL TRUE OR FALSE.
		CODE TO BE GENERATED DEPENDS ON WHICH CONDITION TRANSFER IS DESIRED
		AND ON WHETHER THE VAL IS IN A REG
		NOTE THAT "JMPCND" IS EXPECTED TO BE 777777777777 FOR "TRUE"
****)%
MACRO	CNDVTRIX(NODE,JMPCND)=
	BEGIN
		IF .NODE[OPRCLS] EQL DATAOPR
		THEN
		((JMPCND AND #2) + OPGVTS)
		ELSE
		((JMPCND AND #2) + .NODE[INREGFLG] + OPGVTS)
	END$;


	%(*******TO TRANSFER TO ONE LABEL IF A SPECIFIED VALUE IS TRUE
		AND TO ANOTHER IF THE VAL IS FALSE.
		CODE TO BE GENERATED DEPENDS ON WHETHER THE VAL TO BE GENERATED
		IS IN A REG.
	********)%
MACRO	ALTTRIX(NODE)=
	BEGIN
		IF .NODE[OPRCLS] EQL DATAOPR
		THEN
		OPGALT
		ELSE
		(.NODE[INREGFLG] + OPGALT)
	END$;



%(**************************************************
	DEFINE STRUCTURE FOR OPGENTABLE ENTRY - 
	FOR A GIVEN TYPE OF NODE, WILL HAVE A SERIES OF SUCH ENTRIES, ONE
	FOR EACH INSTRUCTION TO BE GENERATED
******************************************************)%


STRUCTURE OPGENTRY[WD,POS,SIZE]=
	(@.OPGENTRY+.WD)<.POS,.SIZE>;

%(**************FIELDS FOR AN OPGENTRY***********)%
MACRO
	REGSPEC=0,LEFT$,			!SPECIFIES WHERE TO GET
						! REG TO BE USED
	MEMSPEC=0,RIGHT$,			!SPECIFIES WHERE TO GET
						! MEMREF TO BE USED
	PATTERN=1,WHOLE$;		!PATTERN WORD FOR INSTR TO
						! BE GENERATED

%(*********DEFINE VALUES FOR REGSPEC AND MEMSPEC FIELDS*********)%
BIND
	FRPTN=0,		!REG OR MEMREF FIELD USED AS IS IN WD 1 OF OPGENTABLE ENTRY
	FRRFC=1,		!REG FIELD IN THE GLOBAL "REGFORCOMP" SHOULD BE
				! ADDED IN TO THE REG FIELD IN WD 1
				! (OR THE REG SPECIFIED BY "REGFORCOMP" 
				! SHOULD BE USED AS THE MEMREF FIELD
	IMFN=2,			!USE THE IMPLICIT FN NAME PTED TO BY TREEPTR
	WD1IMF=3,		!USE THE IMPLICIT-FN NAME POINTED TO BY THE RH OF THE PATTERN WD
	RGIMFN=4,		!USE THE IMPLICIT-FN NAME POINTED TO BY THE RH OF
				! THE PATTERN WD INDEXED BY THE "REGFORCOMP"
	A1CNST=5,		!ARG1 IS IMMED CNST
	A2CNST=6,		!ARG2 IS IMMED CNST
	A1CNNG=7,		!USE NEG OF THE IMMED CNST ARG1
	A2CNNG=10,		!USE NEG OF THE IMMED CNST ARG2
	PTRA2=#11,		!USE THE ARG2PTR FIELD IN THE PARENT
	NGPTR2=#12,		!USE THE NEG OF THE ARG2PTR FIELD OF THE PARENT
	P2PTR2=#13,		!USE 2**(VAL OF ARG2PTR) MINUS 1
				! (THIS IS USED FOR P2DIV)
	A1LAB=#14,		!USE THE LABEL INDICATED BY A1LABEL
	A2LAB=#15,		!USE THE LABEL INDICATED BY A2LABEL
	A3LAB=#16,		!USE THE LABEL INDICATED BY A3LABEL
	FROMC1H=#17,		!USE THE CONTENTS OF THE GLOBAL C1H,
				! THERE IS NO SYMBOL ASSOCIATED WITH THIS ADDR FIELD
	PARTMP=#20,		!USE THE TMP POINTED TO BY THE ADDR PART
				! OF THE TARGET WD OF THE PARENT NODE (IE THE NODE
				! POINTED TO BY TREEPTR); IGNORE THE INDIRECT BIT
				! OF THE TARGET WD
	FROMA1=#21,		!TARGET FIELD OF ARG1 IS MEMREF FIELD
	FROMA2=#22,		!TARGET FIELD OF ARG2
	FROMPAR=#23;		!TARGET FIELD OF PARENT (IE NODE PTED TO BY TREEPTR)




%(***********************************************************************
	TO GET REG OR MEMREF OR OPERATOR FIELD FROM EITHER A TARGET WD IN AN EXPRESSION
	NODE OR A PATTERN WORD IN AN OPGENTABLE ENTRY
*****************************************************************)%

MACRO
	OPFLD(WORD) = WORD AND #777^27$,
	REGFLD(WORD) = WORD AND #17^23$,

	MEMFLD(WORD) = WORD AND #37777777$;


	%(****DEFINES SPECIFIC REGS USED FOR COMPILED CODE*****)%
BIND RETREG=0;			!REG IN WHICH THE VAL OF A FN IS RETURNED
BIND STKREG=17;		!STACK REG FOR FNS/SUBRS
BIND ARGREG=16;			!CONTAINS PTR TO ARGLIST FOR FNS/SUBRS





%(*********MACROS USED FOR REGISTER ALLOCATION***********************)%



%(*****TO DETERMINE WHETHER A NODE IS EVALUATED BY MEANS OF A CALL TO A LIBRARY FN,
	(IF SO THEN IF THE 2ND ARG IS A CONSTANT WILL HAVE TO ALLOCATE CORE FOR IT)***)%
MACRO USEFNCALL(PNODE)=
BEGIN
	%(***DOUBLE-PREC OPS ON THE KA10 ARE EVALUATED BY LIBRARY FNS***)%
	(.PNODE[VALTYPE] EQL DOUBLPREC AND .KA10FLG)
	OR
	%(***COMPLEX MUL AND DIV ARE EVALUATED BY LIBRARY FNS**)%
	.PNODE[OPERATOR] EQL OPERC(COMPLEX,ARITHMETIC,MULOP) OR.PNODE[OPERATOR] EQL OPERC(COMPLEX,ARITHMETIC,DIVOP)
	OR
	%(****EXPONENTIATION IS PERFORMED BY LIBRARY FNS***)%
	(.PNODE[OPR1] EQL EXPONOPF)
END$;

%(****TO DETERMINE WHETHER THE REGISTER AFTER THE REGISTER RG IS
	FREE. BITS 0-15 OF 'BSYRS' REPRESENT REGISTERS  0-15.
	THE BIT FOR A REGISTER IS SET IFF THAT REG IS FREE*******)%
MACRO NXREGFREE(BSYRS,RG)=BITSET(BSYRS,RG+1)$;


%(****TO TEST WHETHER AN OPERATION 'CLOBBERS' THE REGISTER FOLLOWING THE ONE IN
	WHICH IS IS PERFORMED.
	THIS TEST DOES NOT INCLUDE DOUBLE-PREC (OR COMPLEX) OPERATIONS,
	WHICH THE REGISTER ALLOCATOR HANDLES BY SIMPLY NEVER 
	ASSIGNING ODD REGISTERS WHEN IN "DOUBLE-WD MODE"
********)%
MACRO CLBNXREG(NODE)=
	(CLOBBNX(.NODE))$;	!(THIS TEST GOT SO COMPILICATED WE MADE IT A ROUTINE)

%(******MACROS FOR GOING BETWEEN "DOUBLE-WD MODE" REGISTER ALLOCATION AND
	"SINGLE-WD MODE" REGISTER ALLOCATION.
	FOR DOUBLE-WORD OPERATIONS, NEVER ASSIGN ODD REGISTERS TO
	ANY COMPUTATIONS.
	THE "SET OF BUSY REGS" MAY NEED TO HAVE THESE TRANSFORMATIONS PERFORMED ON IT
		1. ACROSS A TYPE CONVERSION NODE (WHEN CONVERTING BETWEEN DOUBLE-WD
			AND SINGLE-WD VALUES
		2. ACROSS A RELATIONAL NODE THAT COMPARES DOUBLE-WD VALUES (BUT
			HAS A SINGLE-WD RESULT)
		3. ACROSS AN ARRAY-REF NODE FOR A DOUBLE-PREC ARRAY (THE ADDRESS ARITHMETIC 
			IS SINGLE-WD)
		4. ACROSS A BOOLEAN  WHOSE ARGS ARE DOUBLE-WD (RESULT IS ALWAYS SINGLE-WD
*************)%

	%(******WHEN GOING DOWN FROM SINGLE-WD CALCULATIONS TO DOUBLE-WD CALCULATIONS
		THE SET OF REGISTERS THAT CANNOT BE ASSIGNED MUST
		NOW INCLUDE
			1. ANY REGISTER THAT PRECEEDS A REGISTER HOLDING A VAL TO
				BE PRESERVED (SINCE A DOUBLE-WD COMPUTATION
				ON THE PRECEEDING REG CLOBBERS THE FOLLOWING ONE)
			2. ANY ODD REGISTER.
	***********)%

	MACRO DPBSYREGS(SPBSYRS)=
		((SPBSYRS AND SPBSYRS^1) AND #525252525252)$;



	%(*********WHEN GOING DOWN FROM DOUBLE-WD CALCULATION TO SINGLE-WD
		CALCULATIONS.
		THE SET OF REGISTERS AVAILABLE ONCE AGAIN CAN INCLUDE
		THEN ODD REGISTERS EXCEPT FOR THOSE REGISTERS CONTAINING THE RIGHT-HALF
		OF A DOUBLE-WD RESULT WHICH WAS BEING SAVED.
	************)%
	MACRO SPBSYREGS(DPBSYRS)=
		((DPBSYRS OR #252525252525) AND ((DPBSYRS OR #252525252525)^(-1) OR #400000000000))$;


	%(***TO ADD THE FN RETURN REGISTER TO THE SET OF REGS AVAILABLE***)%
	MACRO ADDRETREG(BSYR)=(BSYR OR  #600000000000)$;	!SET BITS FOR REGS 0 AND 1

	%(***TO REMOVE THE FN RETURN REG FROM THE SET OF REGS AVAILABLE**)%
	MACRO REMRETREG(BSYR)=(BSYR AND #177777777777)$;	!CLEAR BITS FOR REGS 0 AND 1

%(***TO TEST WHETHER A POSITIVE INTEGER IS A POWER OF 2***)%
MACRO POWOF2(NUM)=((NUM AND -NUM) EQL NUM)$;






%(****TO SWAP HALVES OF A WORD IN MEMORY****)%
MACHOP MOVSS=#207;
MACHOP MOVE=#200;


%(*****TO SWAP THE 2 ARGS UNDER AN EXPRESSION NODE**************)%
MACRO
	SWAPARGS(NODE)=
	BEGIN
		REGISTER T1;
		MOVE(T1,NODE);
		MOVSS(0,ARGWDOFFSET,T1);
		SWAPFLGS(NODE);
	END$;




%(****TO PERFORM A BLOCK TRANSFER *******)%
MACHOP BLT=#251;

MACRO BLOCKTR(SRCLOC,DESTIN,BLLNTH)=
BEGIN
	REGISTER T1;
	T1<LEFT>_SRCLOC;
	T1<RIGHT>_DESTIN;
	BLT(T1,(DESTIN)<0,0>+BLLNTH-1);
END$;


%(****TO PICK UP A HALF-WD VAL WITH SIGN EXTENDED****)%
MACHOP HRREI=#571;

MACRO	EXTSIGN(VAL)=
BEGIN
	REGISTER AA1;
	AA1_VAL;
	HRREI(AA1,0,AA1)
END$;


%(***TO DO AN ARITHMETIC SHIFT BY A COMPILE TIME CONSTANT***)%
MACHOP ASH=#240;

MACRO ARITHSHIFT(VAL,BITCT)=
BEGIN
	REGISTER T1;
	T1_VAL;
	ASH(T1,(BITCT AND #777777))
END$;



%(****TO COUNT THE NUMBER OF BITS THAT ARE ON IN A GIVEN WORD****)%
MACRO ONESCOUNT(WD)=
BEGIN
	REGISTER COUNT;
	REGISTER T1;
	T1_WD;
	COUNT_0;
	UNTIL .T1 EQL 0
	DO
	BEGIN
		T1_.T1 AND (NOT(-.T1));
		COUNT_.COUNT+1;
	END;
	.COUNT
END$;

%(*******TO CLEAR A GIVEN BIT IN A GIVEN WORD (THE ARG IX INDICATES THE BIT
	TO BE CLEARED, PTN1 IS THE WORD TO CLEAR IT FROM********)%
MACRO
	CLRBIT(PTN1,IX)=BEGIN
				EXTERNAL CLRWDS;
				 PTN1 AND .CLRWDS[IX]
			END $;

%(*******TO SET A GIVEN BIT IN A GIVEN WD*******)%
MACRO
	SETBIT(PTN1,IX) =BEGIN
				EXTERNAL CLRWDS;
				 PTN1 OR NOT(.CLRWDS[IX])
			END $;

%(****TO TEST A GIVEN BIT OF A GIVEN WD***********)%
MACRO
	BITSET(PTN1,IX)=BEGIN
				EXTERNAL CLRWDS;
				 ((IX GEQ 0) AND (PTN1 AND NOT(.CLRWDS[IX])) NEQ 0)
			END$;





%(*****TO MAKE AN ENTRY IN THE CONSTANT TABLE - SET UP GLOBALS FOR
	TBLSEARCH AND CALL IT ****************)%

MACRO MAKECNST(TYPE,CNH,CNL) =
BEGIN
	EXTERNAL TBLSEARCH;
	NAME_CONTAB;
	ENTRY[0]_CNH;
	ENTRY[1]_CNL;
	SYMTYPE_TYPE;
	TBLSEARCH()
END$;

%(**********TO MAKE A CONSTANT TABLE ENTRY FOR THE NEGATIVE OR THE
		COMPLEMENT("NOT") OF SOME OTHER CONSTANT TABLE ENTRY*****)%

MACRO NEGCNST(CNNODE)=
	BEGIN
		IF .CNNODE[VALTYPE] EQL  DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
		THEN
		%(***FOR DOUBLE-PREC NEG - USE ASSEMBLY LANG ROUTINE**)%
		BEGIN
			EXTERNAL C1H,C1L,C2H,C2L,COPRIX,KDNEGB,CNSTCM;
			C1H_.CNNODE[CONST1];
			C1L_.CNNODE[CONST2];
			COPRIX_KDNEGB+.CKA10FLG;
			CNSTCM();
			MAKECNST(.CNNODE[VALTYPE],.C2H,.C2L)
		END
		ELSE
		 MAKECNST(.CNNODE[VALTYPE], -.CNNODE[CONST1], -.CNNODE[CONST2])
	END$;

MACRO NOTCNST(CNNODE)= MAKECNST(.CNNODE[VALTYPE], NOT .CNNODE[CONST1], NOT .CNNODE[CONST2])$;

%(****TO MAKE CONSTANT TABLE ENTRY FOR NOT(-X) - "NTNGCNST"
	OR -(NOT X) - "NGNTCNST"*********)%
MACRO NTNGCNST(CNNODE)=
	BEGIN
		IF .CNNODE[VALTYPE] EQL DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
		THEN
		%(***FOR DOUBLE-PREC USE ASSEMBLY LANG ROUTINE TO GET NEG**)%
		BEGIN
			%(***DNEGCNST GETS ITS ARG IN THE GLOBALS C1H,C1L***)%
			C1H_ .CNNODE[CONST1];
			C1L_.CNNODE[CONST2];
			COPRIX_KDNEGB+.CKA10FLG;
			CNSTCM();
			MAKECNST(.CNNODE[VALTYPE],NOT .C2H, NOT .C2L)
		END
		ELSE
		MAKECNST(.CNNODE[VALTYPE], NOT (-.CNNODE[CONST1]), NOT (-.CNNODE[CONST2]))
	END$;

MACRO NGNTCNST(CNNODE)=
	BEGIN
		IF .CNNODE[VALTYPE] EQL DOUBLPREC OR .CNNODE[VALTYPE] EQL REAL
		THEN
		BEGIN
			%(***DNEGCNST GETS ITS ARG IN THE GLOBALS C1H,C1L***)%
			C1H_NOT .CNNODE[CONST1];
			C1L_NOT .CNNODE[CONST2];
			COPRIX_KDNEGB+.CKA10FLG;
			CNSTCM();
			MAKECNST(.CNNODE[VALTYPE],.C1H,.C1L)
		END
		ELSE
		MAKECNST(.CNNODE[VALTYPE],-(NOT .CNNODE[CONST1]), -(NOT .CNNODE[CONST2]))
	END$;



%(******************************
	MACROES TO FORM INDICES  INTO THE TABLE FOR CONSTANT FOLDING
********************************)%

	%(***TO FOLD BOOLEAN OPERATIONS***)%
MACRO	KBOOLOPIX(PNODE)=
	(.PNODE[OPERSP] + KBOOLBASE)$;

	%(***TO FOLD ARITHMETIC OPERATIONS****)%
MACRO	KARITHOPIX(PNODE)=
	(.PNODE[OPRSP2]^2 + .PNODE[VALTP1] + (IF .CKA10FLG THEN KARIAB  ELSE KARIIB) )$;

	%(*******TO FOLD AN ARITH OP, WHEN NO EXPRESSION NODE WAS BUILT (VLTP IS THE VALTP1 FIELD)***)%
MACRO	KKARITHOP(VLTP,OPSP)=
	(OPSP^2 + VLTP + (IF .CKA10FLG THEN KARIAB ELSE KARIIB))$;


	%(****TO CONVERT A CONSTANT OF ONE VALUE TYPE TO ANOTHER****)%
MACRO KTPCNVIX(TPCNODE)=
	(.TPCNODE[OPERSP]^3 + .TPCNODE[VALTP2] +KTYPCB)$;


	%(****TO CONVERT A CONSTANT FROM ONE VALTYPE TO ANOTHER WHEN NO EXPRESSION
		NODE WAS BUILT FOR THE TYPE CONVERSION. (VLTP IS THE VALTP2 FIELD)***)%
MACRO	KKTPCNVIX(VLTP,OPSP)=
	(OPSP^3 + VLTP + KTYPCB)$;


	%(***TO FOLD SPECIAL OPERATORS (P2MUL,P2DIV)  - USED ONLY BY PHASE 2***)%
MACRO	KSPECOPIX(PNODE)=
	(.PNODE[OPERSP]^2 + .PNODE[VALTP1] + KSPECB)$;

MACRO	KEXPIX(VLTP1)=		!TO FOLD AN INTEGER EXPONENTIATION
	(EXPCIOP^2 + VLTP1 + KSPECB)$;	! ("VLTP1" IS THE VALTP1 OF THE BASE)


	%(***TO FOLD IN-LINE FNS********)%
MACRO	KILFOPIX(PNODE)=
	(.PNODE[OPERSP] + (IF .PNODE[VALTP1] EQL INTEG1 THEN KILFBA ELSE KILFBR))$;

	%(*****FOR CNODE ARITHMETIC OR BOOLEAN
		CHECK TO SEE IF A SKEWED TREE IS AN NARYNODE*****)%

	MACRO NARYNODE(CNODE,AR1NODE)=
	(.CNODE[OPR1] EQL .AR1NODE[OPR1]
	AND
	.CNODE[OPR1] LSS DIVOPF
	AND
	NOT .CNODE[A1NEGFLG] AND NOT .CNODE[A1NOTFLG]
	AND
	NOT .AR1NODE[PARENFLG])$;




%(***************************************************************************
	TO GET CORE TO BUILD A NODE OF A CERTAIN TYPE.
	AT PRESENT  CALL CORMAN WITH NAME<LEFT> EQUAL TO THE SIZE
	NEEDED (SRM - AUG 18,1972)
***************************************************************************)%

MACRO	GETCORE(NDSIZ,NDTYP)=
BEGIN
	NAME<LEFT>_NDSIZ;
	CORMAN()
END$;

	%(***NODE SIZES****)%
BIND
	ELCSIZ=4,	!FOR AN ELISTCCALL NODE
	IOLCSIZ=3;	!FOR AN IOLISTCALL NODE

	%(***NODE TYPE CODES***)%
BIND	IOLCCD=1;	!FOR AN IOLISTCALL NODE

%(***************************************************************************
	MACROS USED FOR CONSISTENCY CHECKING - FOR DEBUGGING THE COMPILER
***************************************************************************)%


%(***TO CHECK WHETHER ARE WALKING DOWN ONTO A LEGAL NODE***)%
MACRO DEBGNODETST(NODE)=
BEGIN
	EXTERNAL NODERR;
	IF DEBUGFLG			!A COMPILE TIME CONSTANT 
	THEN
	BEGIN
		IF .NODE EQL 0
		THEN NODERR();
	END;
END$;




!MACROS FOR THE FLAGS ASSOCIATED WITH A DO LOOP


%******
	FLAGS ASSOCIATED WITH A DO LOOP FOR CODE GENERATION
	SAVREGFLG=0,1,34,1		!FLAG SET BY BB REG ALLOC
	INNERDOFLG=STOREFLG				!FLAG SET BY PHASE 1 ON INNER DO LOOP
	PAIRMODEFLG=PARENFLG		!FLAG IN ALL STMNTS INDICATING THAT THEY
					! REQUIRE A REG PAIR (FLAG IS IDENTICAL
					! TO FNCALLSFLG)
*****%
	MACRO
							!SET IN DOXPND OR BY THE OPTIMIZER
		SSIZONE=0,1,33,1$,			!STEP SIZE ONE
							!SET IN DOXPND OR BY OPTIMIZER
		SSIZIMMED=0,1,21,1$,			!STEP SIZE IS AN IMMEDIATE CONSTANT (INTEGER)#1
		INITLIMMED=0,1,29,1$,			!INITIAL VALUE IS IMMEDIATE
							!SET IN DOXPN OR OPTIMIZER
		!THE NEXT THREE FLAGS ARE LOOP PROPERTIES
		!SET BY THE OPTIMIZER AND USED IN GLOBAL REG ALLOC
		HASEXIT=0,1,26,1$,			!THIS LOOP HAS EXITS
		HASENT=0,1,27,1$,			!THIS LOOP HAS AN ENTRANCE
		HASRTRN=0,1,28,1$,			!THIS LOOP HAS A RETURN IN IT
		CTLSAMEFLG=0,1,25,1$,			!CONTROL EXPR WAS COMPUTED INTO
							! THE REG IN WHICH IT WILL
							! BE USED
		MATRLZCTLONLY=0,1,24,1$,	!MATERIALIZE THE CTL WORD BUT
						! NOT THE LOOP INDEX (THIS ONLY OCCURS
						! WHEN OPTIMIZIZING
		IXGALLOCFLG=0,1,23,1$,	!LP INDEX WAS ASSIGNED A
						! REG BY THE GLOBAL ALLOC
		SSIZNEGFLG=0,1,22,1$,			!STEP SIZE IS A NAGATIVE INTEGER IMMED
							! CONSTANT AND HENCE MUST BE NEGATED
							! WHEN IT IS PICKED UP (IE
							! AT LOOP END MUST DO SUBI RATHER
							! THAN ADDI)
		CTLNEG=0,1,20,1$,			!CTL VAL MUST BE NEGATED WHEN IT IS
							! PICKED UP (THIS IS ALWAYS SET IF CTL
							! VAL IS A CONSTANT BUT NOT FLCWD
		CTLIMMED=0,1,19,1$,			!CTL VAL IS AN IMMED CONST
		INITLNEG=0,1,18,1$,			!INITL VALUE MUST BE NEGATED WHEN

		!THESE FLAGS ARE NOW IN WORD 6
		FLCWD=0,6,8,1$,			!FULL CONST WORD INITIAL VALUE AND
							!LOOP CONTROL
		NOFLCWDREG=0,6,9,1$,			!IF THE DO INDEX OF THIS LOOP
							! IS NOT MATERIALIZED, THEN
							! AOBJN SHOULD NOT BE USED FOR
							! THE LOOP
		DOREMOVED=0,6,10,1$,			!OPTIMIZER HAS DELETED DO LOOP
		INITLTMP=0,6,11,1$,			!INITL VALUE NEEDS COMPUTATION
		SSIZINTMP=0,6,12,1$,			!STEP SIZE IN A TEMP
		IVARINREG=0,6,13,1$,			!DO INDUCTION VARIABLE IS IN A REGISTER
							!SET BY OPTIMIZER
		REALARITH=0,6,14,1$,			!DO SYMBOL IS REAL SO ALL ARITHMETIC MUST BE
							!REAL
							! IT IS PICKED UP
		NEDSMATRLZ =0,6,15,1$,			!MATERIALIZE THE LOOP INDEX AND THE CTL WD
		MATRLZIXONLY=0,6,16,1$,			!MATERIALIZE THE LOOP INDEX BUT NOT THE CTL WD
		EXTALLOC=0,6,17,1$;			!EXTEND GLOBAL ALLOCATION
							!TO THIS LOOP

%*****
	TO ACCESS RIGHT AND LEFT HALVES OF A WORD THROUGH A
	CASE,WD,POS,SIZ STRUCTURE.
	USED ON DOSP AND SNDOLNK LIST
*****%

MACRO
	RIGHTP = 0,0,RIGHT$,
	LEFTP =0,0,LEFT$;

%*****
	MACROS TO PICK UP COMBINATIONS OF THE FLAGS
*****%
!	FIELDS IN DOWDP USED TO DETERMINE
!	IF IT IS VALID TO KEEP THE DO INDEX VARIABLE IN A 
!	REGISTER THROUGHOUT THE LOOP
!*****

	MACRO
		DOISUBS=0,35,1$,
		DONOAOBJN=0,34,1$,	!FLAG FOR "DONT USE AOBJN FOR THIS LOOP
					! IF VAL OF INDEX IS NOT MATERIALIZED
		DOMTRLZIX=0,33,1$,	!FLAG FOR "LOOP INDEX MUST BE MATERIALIZED"
					! THIS GETS SET IF INDEX IS AN ARG TO
					! A FN OR IF LOOP HAS TRANSFERS OUT
		DOINDUC=0,0,18$,
		DOREGPTR=0,18,18$;



%(*****DEFINE THE REGISTER TO BE USED FOR THE LOOP INDEX FOR ALL INNER DO
	LOOPS****)%
BIND DOIXREG=2;

%(*****SOME FLAGS TO HELP THE GLOBAL ALLOCATOR. THESE FLAGS ARE IN THE
GLOBREG WORD OF AN ALLOCATED VARIABLE. SEE PH3G FOR DETAILS FOR THE
FLAGS)****%
MACRO
	USED4ASGND=28,1$,	!VARIABLE IS USED BEFORE ASSIGNED IN THIS LOOP
	ASGND4USED=27,1$;	!VARIABLE IS ASSIGNED BEFORE ITS FIRST USE

%(***************************************************************************
	DEFINE THE TABLES USED BY THE BASIC BLOCK REGISTER ALLOCATOR
***************************************************************************)%


%(*****DEFINE THE STRUCTURE OF  THE "REGCANDIDATES" TABLE. THIS TABLE IS USED
	IN THE FIRST PASS OVER A BASIC BLOCK TO KEEP TRACK OF VARIABLES AND CONSTANTS
	WHOSE VALUES ARE LEFT IN REGS BY RGE EVALUATION OF STMNTS IN THE BLOCK
********)%

STRUCTURE RGCTBL[ENTRIX,WD,POS,SIZE]=
	(.RGCTBL + (.ENTRIX-1) + .WD)<.POS,.SIZE>;	!1ST ENTRY HAS IX 1

MACRO
	RGBAK=0,LEFT$,
	RGFOR=0,RIGHT$,
	RGVAR=1,LEFT$,	!PTR TO THE SYMBOL/CONST TABLE ENTRY FOR A VAR/CONST
				! WHOSE VAL IS LEFT IN A REG
	RGINITUSE=1,RIGHT$;	!PTR TO THE EXPRESSION/STMNT WHOSE EVALUATION LEFT THE VAR
				! IN A REG


	%(***DEFINE THE STRUCTURE FOR A POINTER TO A GIVEN ENTRY IN THE REGCANDIDATES TABLE**)%
STRUCTURE RGCTBLENTRY[WD,POS,SIZE]=
	(@.RGCTBLENTRY+.WD)<.POS,.SIZE>;


BIND RGCENTSIZE=1;	!NUMBER OF WDS IN EACH REGCANDIDATES TABLE ENTRY




%(**********DEFINE THE STRUCTURE OF THE "REGSTATE" TABLE. THIS TABLE IS USED
	IN THE 2ND PASS OF TE BASIC BLOCK REG ALLOCATOR TO KEEP TRACK OF THE
	CONTENTS OF EACH REG WHOSE VALUE IS OF FUTURE USE IN THE BASIC BLOCK
*************)%
STRUCTURE RGSTBL[REG,WD,POS,SIZE]=
	(.RGSTBL + 2*.REG + .WD)<.POS,.SIZE>;	!ENTRIES ARE INDEXED FROM 0 (FOR REG 0)

MACRO
	RGVAR1=0,LEFT$,	!PTR TO SYMBOL/CONST TABLE ENTRY FOR THE VAR/CONST
				! WHOSE VAL IS IN THIS REG
	RGVAR2=0,RIGHT$,	!PTR TO A POSSIBLE 2ND SYMBOL/CONST TABLE ENTRY FOR A
				! 2ND VAR WHOSE VAL IS IN THIS REG (EG FOR
				! "A=B" BOTH A AND B ARE IN THE SAME REG)
	RGNXUSE=1,WHOLE$;	!THE BASIC-BLOCK SEQ NUMBER OF THE STMNT WHERE THE
				! CONTENTS OF THE REG WILL NEXT BE USED. -1 IF THERE
				! IS NO FUTURE USE
