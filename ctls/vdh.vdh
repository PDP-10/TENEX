;<MON>VDH.NEW;1	    26-MAR-75 13:30:00    EDIT BY HEATHMAN
;FIXED 32 BIT INPUT STUFFING BUG
;<MON>VDH.MAC;53    19-MAR-75 12:36:39    EDIT BY LIEB
;ELIMINATE OPRLSE CALL AT OPIDLE AND FIX OPRLSE
;<MON>VDH.MAC;52    17-MAR-75 11:28:03    EDIT BY LIEB
;ELIMINATE CONFLICTS BETWEEN PI RELEASEING BUFFERS AND PROCESS
;SENDING (SPURIOUS ACKS) AND CALL SCEDULER W/ ISB SCDCHN
;<MON>VDH.MAC;50    13-MAR-75 01:42:52    EDIT BY LIEB
;PATCH OPHH TO STEP PACKET POINTER FOR 36 BIT
;<MON>VDH.MAC;49    12-MAR-75 11:59:50    EDIT BY LIEB
;CHECK INPUT PACKET BUFERS EVERY SCHED PASS
;<MON>VDH.MAC;48     6-MAR-75 18:17:00    EDIT BY LIEB
;FIXED PAGE TRAP BUG AND FORCEING LOGIC
;<MON>VDH.MAC;46     5-MAR-75 15:48:04    EDIT BY LIEB
;MINOR BUGS IN OPRLSE, OPCTRL, AND IPCTRL
;<MON>VDH.MAC;43    27-FEB-75 13:57:57    EDIT BY LIEB
;<MON>VDH.MAC;42    26-FEB-75 17:01:31    EDIT BY LIEB
;MOVED PACKET FILLING AND STUFFING TO A SCHED CLOCK
;<MON>VDH.MAC;36    18-FEB-75 16:57:51    EDIT BY LIEB
;SAVE LOOPED PACKET CONTROL WORDS
;<MON>VDH.MAC;35    13-FEB-75 14:51:38    EDIT BY LIEB
;ADD FLUSHED PACKET COUNTER, OPRLSE RELEASES BUFFERS WHEN LINE DIES
;<MON>VDH.MAC;33    12-FEB-75 01:45:38    EDIT BY LIEB
;FIX OUTPUT BUFFER RELEASING LOGIC
;<MON>VDH.MAC;30    10-FEB-75 16:30:48    EDIT BY LIEB
;ACK DUPLICATE PACKETS
;<MON>VDH.MAC;27     8-FEB-75 00:43:28    EDIT BY LIEB
;CHANGE TO FILL PACKET WITH LAST MSG WORD
;ELIMINATE IMISRC AND IPERR STATE SINCE SPECIAL PACKETS
;ARE ONLY "LOGICALLY" ONE WORD??!!
;<MON>VDH.MAC;19     4-FEB-75 17:24:11    EDIT BY LIEB
;NEW IMPCHK ROUTINE AND INTERUPT DISPATCH PREVENTS BAD VECTORS
;<MON>VDH.MAC;15     3-FEB-75 12:39:21    EDIT BY LIEB
;SAVE AC'S IN AC BLOCK INSTEAD OF DISPATCH VECTORS
;<MON>VDH.MAC;14     1-FEB-75 18:19:16    EDIT BY LIEB
;MAKE LINE UP/DOWN WORK
;<MON>VDH.MAC;12    30-JAN-75 15:08:49    EDIT BY LIEB
;MAKE LINE INIT WORK RIGHT--LIEB
;<MON>VDH.MAC;8    27-JAN-75 11:16:25    EDIT BY LIEB
;<MON>VDH.MAC;5    26-JAN-75 20:33:34    EDIT BY LIEB
;<MON>VDH.MAC;4    26-JAN-75 20:18:07    EDIT BY LIEB
;<MON>VDH.MAC;2    26-JAN-75 18:31:52    EDIT BY LIEB
;<LIEB>VDH.MAC;43    23-JAN-75 17:35:02    EDIT BY LIEB

REPEAT 0,<


ON THE FEASABILITY OF NEW SYSTEMS:

	"LOOK AT ME, I'VE WORKED MYSELF UP FROM NOTHING
	 TO AN EXTREME CASE OF POVERTY"
					-GROCHO MARX 1951
>

	SEARCH	PROLOG
IFDEF IMPCHN,<	;THIS WHOLE FILE INCLUDED ONLY IF IMP EXISTS
IFDEF VDH,<	;AND IT IS A VERY DISTANT HOST
	SUBTTL VDH--JIM LIEB , SUMEX,STANFORD UNIV MED CENTER JAN 75


; EXTRA CONI-CONO BITS

IMIERB==1B21		; REC ERROR FROM VDH
IMICLR==1B19		; CLEAR REC ERR BIT
IMPRES==1B18		; RESET INTERFACE
IMISRC==1B20		; FORCE REC INTO SEARCH MODE
IMPPWR==1B19		; PWR ON IN INTERFACE

; HELLO, I-HEARD-YOU PARAMS

RTIME==^D1200		;1.2 SECS BETWEEN HELLOS
T==4			;MAX HELLOS CAN GET AHEAD OF I-HEARD-YOU'S
K==4			;I-HEARD-YOU'S REQUIRED TO DECLARE LINE BACK UP
DWNTIM==2*T*RTIME	;TIME TO KEEP QUIET TO MAKE IMP SAY LINE DEAD
RXMTDL==^D100		;DELAY TIME BEFORE RETRANSMISSION OF UNACKED
			;PACKETS


;VDH PACKET CONTROL WORD BIT DEFINITIONS

LSTPKT==400000		;LAST PACKET OF MSG
PKTODD==200000		;PACKET ODD/EVEN BIT
HSTIMP==1000		;HOST/IMP DIRECTION BIT
SPCPKT==400		;SPECIAL PACKET BIT
ACK1==40		;CHAN1 ACK BIT
ACK0==20		;CHAN0 ACK BIT
CHNUM==4		;CHANNEL NUMBER OF PACKET
HELLO==LSTPKT		;HELLO BIT OF SPECIAL PACKET
HERDU==HELLO		;I-HEARD-YOU BIT OF SPECIAL PACKET
WDS16B==176000		;WORD COUNT MASK



;RTP STATUS WORDBITS --FOUND IN RTSTAT

STUFRM==10		;STUFFING MSG BUFFER FROM CHAN#
STSTAT==7		;IPSTFR STUFF STATE
FLSTAT==3B23		;OPFILR FILL STATE
LNDOWN==400000		;LINE DECLARED DEAD
MOVNG0==20		;CH0 PACKET BEING SENT (DONT RELEASE BUFFER)
MOVNG1==40		;CH1 PACKET BEING SENT (BOTH BITS IN LH)
XPECT==PKTODD		;LH FOR CH1,RH FOR CH0 RCVR CHAN STATE
IBUFUL==100000		;LH FOR CH1,RH FOR CH0 PACKET BUFFER STATE
ENDMSG==40000		;LH FOR CH1,RH FOR CH0 LAST PACKET ON THIS  CHAN
XMTOD1==1B30		;XMIT CH1 ODD/EVEN BIT
XMTOD0==1B31		;XMIT CH0 ODD/EVEN BIT
LAST1==2		;CH1 THIS-IS-LAST-PACKET BIT
LAST0==1		;CH0 THIS-IS-LAST-PACKET BIT
MSGOUT==1B24		;FOR OPFILR,CURRENTLY FILLING FROM  A MSG
SENT1==1B25		;CHAN 1 HAVE-SENT-THIS
SENT0==1B26		;CHAN 0 HAVE-SENT-THIS
SNDHRD==1B27		;SEND AN I-HEARD-YOU
SNDHLO==1B28		;SEND A HELLO
SNDACK==1B29		;SEND AN ACK AT LEAST (IF NOT A BUFFER)
CURCHN==1B33		;CURRENT CHANNEL TO BE TRANSMITTED
FILNXT==1B32		;OUT PACKET BUFF TO FILL NEXT
WRK2DO==SNDHRD+SNDHLO+SNDACK ;WORK FOR OUTPUT TO DO


;LINKAGE TO SCHED

INTERN VDHCHK	;SCHED LEVEL MSG TO PACKET AND PACKET  TO MSG BUFFER ROUTINES

; VDH LOCALS

LS IMPOAC,5		;AC STORE FOR OUTPUT SIDE
LS IPENDV,1		;VECTOR STORE FOR END INTERRUPT
LS ISFTMP,1		;TEMP STORE FOR MSG BITS BETWEEN PACKETS
LS VDHFLG,1		;SCHED LEVEL SERVICE REQ FLAG (FILL OR STUFF)
LS ENDFLG,1		;FOR IPSTFR, -1= LAST PACKET
LS ISFTFG,1		;FOR IPSTFR,STUFFING ROUTINE STATE WORD
LS IMPLUP,1		;LAST LOOPED PACKET CONTROL WORD
LS IMPAKS		;ACK BITS FROM IMP
LS OMSHFT,1		;FOR OP36 SHIFT STATE WORD
LS OMSPST,1		;FOR OP36 SPECIAL STATE  ENTRY FLAG
LS IPCNT,1		;CH1,,CH0 BUFFER WORD COUNTS FOR INPUT
LS OPCNT,1		;CH1,,CH0 BUFFER WORD COUNTS FOR OUTPUT
LS OCH0DL,1		;TIMER FOR CHAN 0 RETRANSMIT
LS OCH1DL,1		;TIMER FOR CHAN 1 RETRANSMIT
LS IPBPTR,1		;BLKI AND BLKO POINTERS
LS OPBPTR,1		;FOR INPUT AND OUTPUT
LS IPBUF0,^D33		;CHAN0 INPUT BUFFER
LS IPBUF1,^D33		;CHAN1 INPUT BUFFER
LS OPBUF1,^D31		;CHAN1 OUTPUT BUFFER
LS OPBUF0,^D31		;CHAN0 OUTPUT BUFFER
LS HERDCT,1		;I-HEARD-YOU COUNTER FOR INIT
LS VDHANS,1		;0=DON'T ANSWER WHEN LINE DOWN,-1=ANSWER NO MATTER WHAT
LS RTSTAT,1		;RTP STATUS WORD
LS ICTRWD,1		;CURRENT INPUT PACKET CONTROL WORD
LS OCTRWD,1		;CURRENT OUTPUT PACKET CONTROL WORD
LS VDHLOK,1		;OPCTRL LOCK WORD
LS KILLIT,1		;REQUEST KILL-THE-IMP FLAG
LS RTPCNT,1		;HELLO,I-HEARD-YOU COUNTER
LS RVRCNT,1		;COUNT OF RECIEVED PACKETS
LS XMTCNT,1		;COUNT OF TRANSMITTED PACKETS
LS DUPCNT,1		;COUNT OF DUPLICATE  (RECVD) PACKETS
LS FLSCNT,1		;COUNT OF FLUSHED PACKETS
LS LUPCNT,1		;COUNT OF LOOPED PACKETS
LS RPTCNT,1		;COUNT OF REPEAT TRANSMISSIONS
LS RERCNT,1		;COUNT OF ERRORS FOUND BY INP INTERFACE

; PI DISPATCH VDH VERSION

IMPSV:	XWD	IMPSVX,.+1
	CONSO	IMP,7		;IF INPUT ISNT GOING
	JRST @IMPSVX		;THEN IT ISNT FOR US
	SKIPN	IMIDSP		;ARE VECTORS SET UP?
	JRST [	SETOM	KILLIT		;VECTORS SCREWY REQ MURDER
		UNBRK (IMP)]		;THEN CLEAR INTERRUPT
	CONSZ	IMP,IMPINB	;AN INPUT WORD?
	JRST @IMIDSP		;YES
	CONSZ	IMP,IMPEIB	;IS IT END OF PACKET?
	JRST [	CONSO IMP,IMPINB	;YES BUT DID LAST WD SNEEK IN?
		JRST @IPENDV		;NO
		JRST @IMIDSP]		;YES
	CONSZ	IMP,IMPOUB	;AN OUTPUT WORD?
	JRST @IMODSP		;YES
	JRST @IMPSVX		;NO SKIP CHAIN FAILED,RETURN


;HELLO AND IMPCHK CLOCK SERVICE

IMPCHK:	MOVEI	2,RTIME
	MOVEM	2,IMPTM2	;COME BACK IN R SECS
	SKIPN	NETON		;NET ALIVE?
	SKIPE	IMPRDY		;OR IMP READY?
	SKIPA			;CONTINUE ELSE
	RET
	CONSZ	IMP,IMPPWR	;POWER OFF?
	SKIPE	KILLIT		;OR A CONTRACT OUT ONTHE IMP?
	JRST [	SETZM	KILLIT	;CLEAR REQUEST AND
		JRST IMPCK0]	;GO WASTE IT
	SKIPGE	RTSTAT		;LINE DEAD?
	JRST IMPCK1		;YES
	SKIPL	RTPCNT		;NO, GET LAST REPLY IN TIME?
	JRST IMPCK2		;YES, SEND ANOTHER HELLO
IMPCK0:	CONO	IMP,IMPRES	;NO, KILL IMP
	MOVEI	2,DWNTIM	;BE QUIET
	MOVEM	2,IMPTM2	;UNTIL IMP KILLS US
	MOVEI	2,IPCTRL	;RESET VECTORS
	MOVEM	2,IMIDSP
	MOVEI	2,IPCRSH
	MOVEM	2,IPENDV
	MOVEI	2,OPIDLE
	MOVEM	2,IMODSP
	SETZM	RTPCNT		;INIT HELLO COUNTER
	SETZM	VDHANS		;DONT ANSWER WHILE
	SETOM	RTSTAT		;LINE DOWN
	CALL	IMIERR		;REPORT ERROR
	AOS	IMPFLG		;WAKE UP NCP FORK
	RET

IMPCK2:	SOS	RTPCNT		;COUNT THIS HELLO
	MOVEI	2,SNDHLO	;QUEUE UP
	IORM	2,RTSTAT	;HELLO REQUEST
	AOSE	VDHLOK		;TRY THE LOCK
	RET			;BUSY
	PUSH	P,4
	JSP	4,OPCTRL	;OUTPUT IDLE,SEND IT
	POP	P,4
	RET

;LINE DOWN

IMPCK1:	SKIPE	VDHANS		;CAN WE TALK?
	JRST IMPCK3		;YES, KEEP INIT GOING
	SETOM	VDHANS		;WAITED LONG ENOUGH, TALK NOW
	HRROI	2,SNDHLO	;INIT OUTPUT SIDE
	MOVEM	2,RTSTAT	;WITH HELLO QED
	MOVEI	2,K		;NUMBER OF TIMES
	MOVEM	2,HERDCT	;WE HAVE TO DO HANDSHAKE RIGHT
	SETZM	RTPCNT		;INIT HELLO COUNTER
	SETZM	VDHLOK		;LOCK THE TRANSMITTER
	CONO	IMP,IMICLR	;CLEAR THE ERROR BIT FROM THE RESET
	CONO	IMP,IMPION+IMPOON ;TURN ON INTERFACE
	PUSH	P,4
	JSP	4,OPCTRL	;SEND THE HELLO
	POP	P,4
	RET

;KEEP INIT GOING

IMPCK3:	SKIPGE	RTPCNT		;DID WE LOSE A HELLO?
	JRST [	SETZM RTPCNT	;YES,BUT KEEP IT FROM GETTING
		MOVEI 2,K	;IN A HOLE AND
		MOVEM 2,HERDCT	;START HANDSHAKE OVER AGAIN
		JRST .+1]
	SOSLE	HERDCT		;ARE WE FINISHED?
	JRST IMPCK4		;NO
	MOVEI	2,T		;YES,BRING IT UP
	MOVEM	2,RTPCNT	;RESET HELLO BANK ACCOUNT
	MOVEI	2,SNDHRD	;INIT LINE UP
	ANDM	2,RTSTAT	;PRESERVING Q'ED REQ
	AOS	IMPFLG		;TELL SOMEONE THE GOOD NEWS
IMPCK4:	MOVEI	2,SNDHLO	;REQUEST A HELLO
	IORM	2,RTSTAT
	SOS	RTPCNT		;COUNT IT
	AOSE	VDHLOK		;TRY THE LOCK
	RET
	PUSH	P,4
	JSP	4,OPCTRL	;OUTPUT IDLE, SEND THE HELLO
	POP	P,4
	RET

;SCHED LEVEL 8 PACKET TO MSG AND MSG TO PAKET BUFFER ROUTINES
;CALLED AT EVERY SCHEDULER PASS AND DOES FILLING OR STUFFING

VDHCHK:	CALL	IPSTFR		;MOVE ANY FULL PACKET BUFFERS
	CALL 	OPFILR		;SEE IF WE CAN MOVE SOMETHING
	RET

;IMPXOU CALLED FROM PROCESS SIDE AND SETS UP NECESSARIES FOR OPFILR

IMPXOU:	PIOFF			;FREEZE THE WORLD SO WE CAN LOOK AT IT
	SKIPN	IMPOB		;OUPUT IN PROGRESS?
	JRST IMPXO1		;NO, GET IT GOING
	PION		;NOTHING TO DO, THAW THE WORLD
	JRST (4)	;AND GO HOME

;SOMETHING TO DO
IMPXO1:	HRROS	IMPOB		;SAY WE ARE DOING SOMETHING
	PION			;THAW THE WORLD
	AOS	VDHFLG		;REQUEST FILLING SERVICE
	JRST (4)


;HERE TO STUFF A PACKET INTO A MESSAGE BUFFER
;AND SEND IT UPSTAIRS
;CALLED FROM EITHER SCHEDULER OR PROCESS LEVEL
;CALLS NEXT STATE W/ SPECIAL POINTER TO PKT BUFFER IN 3

IPSTFR:	SKIPL	1,RTSTAT	;GET STATUS
	SKIPN	IMIB		;LINE DOWN OR NO MSG BUFFER AVAIL?
	RET			;YES, DON'T GO FURTHER
	SETZM	ENDFLG		;CLEAR END OF MSG FLAG
	TLNE	1,STUFRM	;CHAN 1
	TLNN	1,IBUFUL	;AND THERE'S A BUFFER?
	JRST STFCH0		;NO
	TLNE	1,ENDMSG	;IS THIS THE END?
	SETOM	ENDFLG		;SAY SO
	HLRZ	2,IPCNT		;GET WORD COUNT
	ADDI	2,2		;PAD SO JUMP OCCURS ON EMPTY NOT LAST WD
	MOVN	2,2		;MAKE IT NEGATIVE
	MOVEI	3,IPBUF1-1	;POINT TO THE  BUFFER
	HRL	3,2		;AND PUT IN COUNT
	LDB	1,STFPTR	;GET STUFF STATE
	CALL	STFTBL(1)	;DISPATCH TO EMPTY THIS BUFFER
	MOVSI	1,IBUFUL+ENDMSG	;BITS TO MARK BUFFER FREE
	HRRZS	IPCNT		;CLEAR COUNT
	ANDCAM	1,RTSTAT	;AND MARK BUFFER FREE
	JRST IPSTFR		;GO TRY THE OTHER ONE

STFCH0:	TLNN	1,STUFRM	;CHAN 0
	TRNN	1,IBUFUL	;AND THERE'S A BUFFER?
	RET		;NO, NOTHING TO DO, RETURN
	TRNE	1,ENDMSG	;IS THIS THE END?
	SETOM	ENDFLG		;THEN SAY SO
	HRRZ	2,IPCNT		;GET WORD COUNT
	ADDI	2,2		;PAD SO JUMP OCCURS ON EMPTY NOT LAST WORD
	MOVN	2,2		;MAKE IT NEGATIVE
	MOVEI	3,IPBUF0-1	;POINT TO THE BUFFER
	HRL	3,2		;AND PUT IN COUNT
	LDB	1,STFPTR	;GET STUFF STATE
	CALL	STFTBL(1)	;DISPATCH TO EMPTY THIS BUFFER
	MOVEI	1,IBUFUL+ENDMSG	;BITS TO MARK BUFFER FREE
	HLLZS	IPCNT		;CLEAR COUNT
	ANDCAM	1,RTSTAT	;AND MARK IT FREE
	JRST IPSTFR		;GO BACK AND TRY THE OTHER ONE


;STUFFER DISPATCH TABLE

STFTBL:	JRST IPLDR	;MSG LEADER
	JRST IPHH	;HOST-HOST HEADER AND DATA
	JRST IP32	;32 BIT WORD DATA
	JRST IP36	;36 BIT WORD DATA
	JRST IPFMSG	;FLUSH MESSAGE
	JFCL
	JFCL
	BUG(HLT,<UNDEFINED STUFF STATE>)


;ALL STATES RETURN THRU HERE

IPMRTN:	MOVSI	1,STUFRM	;FINISHED W/ THIS PACKET
	XORM	1,RTSTAT	;POINT TO THE OTHER ONE
	RET


;POINTS TO STUFF STATE BYTE

STFPTR:	POINT 3,RTSTAT,17

;USE TO SIMULATE AOBJX ON 16 BIT WORDS
AOBJ16:	1,,0



;HERE TO STUFF THE MSG LEADER
;AC3 HAS THE SPECIAL BUFFER POINTER

IPLDR:	MOVE	1,IMPINP	;GET MSG BUFF POINTER
	AOBJN	1,.+2		;DO THE BLKI SKIP
	BUG(HLT,<IMPIN-BFR NOT SET UP>)
	MOVEM	1,IMPINP	;UPDATE POINTER
	ADD	3,AOBJ16	;COUNT THE EXTRA WORD
	AOBJN	3,.+1		;ADVANCE BLKI POINTER
	MOVE	2,0(3)		;MOVE THE PACKET
	MOVEM	2,0(1)		;INTO MSG BUFFER
	ADD	3,AOBJ16	;COUNT EXTRA WORD
	AOBJP	3,.+2		;END OF BUFFER?
	BUG(NTE,<IMPIN-MSG LEADER NOT 32 BITS>)
	SKIPE	ENDFLG		;IF END OF MSG
	JRST IMEND		;PROCESS IT
	MOVEI	1,1		;ELSE NEXT STATE
	DPB	1,STFPTR	;IS HOST-HOST
	JRST IPMRTN		;RETURN TO DISPATCHER


;HERE TO STUFF HOST-HOST HEADER AND DATA OF 2ND PACKET
;3 HAS THE SPECIAL PACKET BUFFER POINTER

IPHH:	PUSH	P,4		;SAVE THE RETURN ADDR
	MOVE	4,IMPINP	;GET THE MSG BUFF PTR
	AOBJN	4,.+2		;DO BLKI SKIP STUFF
	BUG(HLT,<IMPIN-BFR NOT SET UP>)
	ADD	3,AOBJ16	;COUNT THE EXTRA WORD
	AOBJN	3,.+2		;AND INC REST OF POINTER
	BUG(NTE,<HOST-HOST WORD NOT 32 BITS>)
	MOVE	0,0(3)		;GET 2 16 BIT WORDS
	LSH	0,4		;SHIFT IT TO MAKE IT LOOK LIKE OLD WAY
	MOVEM	0,0(4)		;AND PUT IT AWAY
	LDB	0,[POINT 8,0,11] ;GET MSG BYTE SIZE
	MOVE	1,-1(4)		;AND MSG LEADER
	AND	1,[FRMIMP +17B7 +377B23] ;KILL WHAT WE DONT WANT
	CAMG	1,[<LLINK>B23]	;DO SPECIAL LINKS, IRREG MSGS
	CAIN	0,^D36		;AND IMAGE MODE
	JRST IPHH36		;IN 36 BIT
	ADD	3,AOBJ16	;ELSE ASSUME 32BIT, COUNT EXTRA WORD
	AOBJP	3,IPH32X	;AND INC PTR, JUMP ON BUFFER EMPTY
	AOBJP	4,IPFMSG	;INC BLKI PTR AND FLUSH MSG ON OVFL
	MOVE	1,0(3)		;GET 2 MORE PACKET WORDS
	LSH	1,^D8		;SHIFT OUT THE M2 BYTE
	MOVEM	1,0(4)		;AND PUT IT IN MSG BUFFER
IPH32L:	ADD	3,AOBJ16	;COUNT EXTRA WORD
	AOBJP	3,IPH32X	;AND EXIT WHEN PACKET EMPTY
	MOVE	1,0(3)		;GET 2 MORE WORDS
	LSHC	0,^D8		;SHIFT SO IT FITS RIGHT
	DPB	0,[POINT 8,0(4),31] ;FILL GAP IN LAST WORD
	AOBJP	4,IPFMSG	;STEP BLKI POINTER
	MOVEM	1,0(4)		;AND STORE THIS WORD
	JRST IPH32L		;LOOP BACK FOR MORE

;HERE WHEN PACKET EMPTY

IPH32X:	MOVEM	4,IMPINP	;UPDATE MSG BUFFER PTR
	POP	P,4		;AND RESTORE THE RETURN ADR
	SKIPE	ENDFLG		;IF THIS IS LAST PACKET
	JRST IMEND		;PROCESS IT
	SETZM	ISFTFG		;SAY SHORT SHIFT
	TLNE	3,-1		;IF WE GOT ONLY ONE WORD ON LAST MOVE,
	SETOM	ISFTFG		;SAY LONG SHIFT
	MOVEI	1,2		;SAY STUFF NEXT PACKET
	DPB	1,STFPTR	;IN 32 BIT MODE
	JRST IPMRTN		;RETURN TO DISPATCHER


;HERE TO STUFF REST OF 2ND PACKET IN 36 BIT MODE

IPHH36:	MOVE	2,[-7,,2]	;SET UP STATE WE GO IN WITH
	ADD	3,AOBJ16	;COUNT EXTRA WORD
	AOBJP	3,IM36X		;AND INC PTR,EXIT WHEN EMPTY
	MOVE	1,0(3)		;GET 2 WORDS
	LSH	1,^D8		;SHIFT AWAY M2 BYTE
	JRST IM36L		;START STUFFER W/24 BITS IN 1

;THIS IS THE MAIN 32 TO 36 BIT SHIFTER

IM36L:	ROTC	0,@IPX1(2)	;SHIFT ACROSS LAST OF PREV WORD
	ADD	3,AOBJ16	;COUNT EXTRA WORD
	AOBJP	3,IM36X		;EXIT WHEN EMPTY
	MOVE	1,0(3)		;GET 2 WORDS
	ROTC	0,@IPX2(2)	;SHIFT ENOUGH FOR 36 BITS
	AOBJP	2,IM36L1	;INC STATE, NO MOVEM IN 0 STATE
	AOBJP	4,IPFMSG	;INC MSG PTR,FLUSH ON OVERFLOW
	MOVEM	0,0(4)		;PUT WORD IN MSG BUFFER
	JRST IM36L		;GO BACK AND SHIFT REST OF WORD

IM36L1:	MOVSI	2,-^D9		;RESET SHIFT STATE, NO MOVEM
	JRST IM36L		;CONTINUE SHIFTING

;HERE WHEN PACKET EMPTY

IM36X:	TLNE	3,-1		;HOW MANY WORDS IN LAST XFER?
	JRST IM36X1		;ONLY ONE,DO FUNNY THINGS TO MAKE IT WRK
	MOVEM	4,IMPINP	;2 WDS,UPDATE POINTER
	POP	P,4		;RESTORE RETURN ADDR
	SKIPE	ENDFLG		;END OF MSG?
	JRST IMEND		;THEN PROCESS IT
	HRRZ	3,IPX1(2)	;GET AMOUNT OF LAST ROTC
	MOVN	3,3		;MAKE NEG TO GO THE OTHER WAY
	ROTC	0,(3)		;BACK IT UP
	MOVEM	1,ISFTMP	;AND STORE BITS FOR NEXT PACKET
	MOVEM	2,ISFTFG	;STORE STATE
	MOVEI	1,3		;STUFF DATA PACKETS
	DPB	1,STFPTR	;IN 36 BIT
	JRST IPMRTN		;AND GO BACK TO DISPATCHER

IM36X1:	HRRZ	3,IPX1(2)	;GET AMOUNT OF LAST ROTC
	CAIG	3,^D12		;STATES 5-8?
	SUB	4,[1,,1]	;YES,BACK UP MSG PTR
	MOVEM	4,IMPINP	;UPDATE MSG POINTER
	POP	P,4		;RESTORE RETURN ADDR
	SKIPE	ENDFLG		;END OF MSG?
	JRST IMEND		;YES,GO PROCESS IT
	MOVN	3,3		;NEG TO REVERSE ROTC
	ROTC	0,(3)		;DO IT
	CAML	3,[-^D12]	;STATES 5-8?
	MOVE	1,0		;THEN WE WANT TO STORE 0 INSTEAD
	MOVEM	1,ISFTMP	;STORE AWAY FOR NEXT PACKET
	MOVE	2,IPX3(2)	;GET NEW STATE
	MOVEM	2,ISFTFG	;AND STORE
	MOVEI	1,3		;STUFF DATA PACKETS
	DPB	1,STFPTR	;IN 36 BIT
	JRST IPMRTN		;RETURN TO DISPATCHER

;BIT SHIFTING TABLES

IPX1:	XX=0
	REPEAT ^D9,<^D32-XX
		XX=XX+4>

IPX2:	XX=4
	REPEAT ^D8,<XX
		XX=XX+4>
	0

;NEXT PACKET STATE TABLE

IPX3:	-5,,4
	-4,,5
	-3,,6
	-2,,7
	-1,,^D8
	-^D9,,0
	-^D8,,1
	-7,,2
	-6,,3


;HERE TO STUFF 3RD+ DATA PACKETS IN 32BIT

IP32:	PUSH	P,4		;SAVE RETURN ADR
	MOVE	4,IMPINP	;GET MSG BUFFER POINTER
	SKIPN	ISFTFG		;LONG SHIFT?
	JRST IPH32L		;NO DO SHORT IN IPHH
IPD32L:	ADD	3,AOBJ16	;COUNT EXTRA WORD
	AOBJP	3,IPD32X	;EXIT WHEN PACKET BUFFER EMPTY
	MOVE	1,(3)		;GET 2 WORDS
	LSHC	0,^D24		;SHIFT ACROSS AN EXTRA 16BITS
	DPB	0,[POINT 24,(4),31] ;8 BITS + THE EXTRA 16
	AOBJP	4,IPFMSG	;INC MSG PTR,FLUSH ON OVFL
	MOVEM	1,(4)		;MOVE WHAT'S LEFT
	JRST IPD32L		;CONTINUE W/ NEXT WORD

;HERE FOR LONG SHIFT EXIT

IPD32X: TLNE	3,-1		;ODD # OF 16 BIT WORDS XFERED?
	JRST   [SUB 4,[1,,1]	;YES, BACK UP POINTER FOR SHORT SHIFT
		SETZM ISFTFG	;AND SAY SHORT SHIFT
		JRST .+1]
	MOVEM	4,IMPINP	;UPDATE POINTER
	POP	P,4		;RESTORE RETURN ADDR
	MOVEI	1,2		;STUFF NEXT PACKET 32BIT
	DPB	1,STFPTR	;SET IN STATUS WORD
	SKIPE	ENDFLG		;LAST PACKET
	JRST IMEND		;YES,PROCESS EOM
	JRST IPMRTN		;NO,RETURN TO DISPATCHER

;HERE TO STUFF 3RD+ PACKETS IN 36BIT

IP36:	PUSH	P,4		;SAVE RETURN ADDR
	MOVE	4,IMPINP	;GET MSG PTR
	MOVE	2,ISFTFG	;GET STATE WORD
	MOVE	1,ISFTMP	;GET RESIDUE FROM LAST PACKET
	SETZ	0,		;CLEAR TRASH IN 0
	JRST IM36L		;STUFFER IS IN IPHH

;HERE TO FLUSH REST OF MSG BECAUSE ITS TOO LONG

IPFMSG:	MOVEM	4,IMPINP	;UPDATE THE BLKI POINTER
	POP	P,4		;AND RESTORE THE RETURN ADR
	BUG(IMP,<IPSTFR-MSG TOO LONG>,X)
	MOVEI	1,4		;FLUSH REST OF PACKETS
	DPB	1,STFPTR	;OF THIS MSG
	SKIPE	ENDFLG		;PROCESS EOM
	JRST IMEND		;IF THIS IS LAST PACKET
	JRST IPMRTN		;ELSE RETURN

;PROCESS END-OF-MESSAGE

IMEND:	PUSH	P,4		;SAVE RETURN
	SKIPG	1,IMIB		;GET BUFFER ADR
	JRST IMEND2		;THERE ISNT ONE
	LDB	2,STFPTR	;GET STUFF STATE
	AOSLE	IMPFLS		;FLUSHING ON CMD FROM ABOVE?
	CAIN	2,4		;FLUSHING THIS MSG?
	JRST IMEND3		;YES, RETURN BUFFER TO FREE LIST
	MOVE	2,1(1)		;GET HEADER
	LDB	3,[POINT 4,2,7] ;AND MSG TYPE
	AND	2,[FRMIMP +377B23] ;KILL WHAT WE DONT WANT
	CAIN	3,6		;DEAD HOST STATUS?
	JRST IMEND4		;YES,PUT ON SPEC MSG Q
	CAIE	3,2		;GOING DOWN?
	CAMG	2,[<LLINK>B23]	;OR NOT SPEC LINK
	JUMPN	3,IMEND4	;AND IRREG MSG, THEN SPEC MSG Q
	HRRZS	0(1)		;CLR FWD PTR OF THIS BUFFER
	HRLM	1,@IMPIBI	;ADD BUFFER TO INPUT Q
	HRRZM	1,IMPIBI
	ADD	1,(1)	;COMPUTE TAIL WHICH IS
	MOVEI	1,-1(1)		;START + COUNT
	CALL	MULKMP		;UNLOCK IT
	MOVE	2,IMIB
	HRRZ	4,(2)		;GET ORIGINAL TAIL
	ADDI	4,-1(2)		;
	HRRZ	3,IMPINP	;GET ADDR OF LAST DATA WORD
	SUB	4,3		;HOW MUCH NOT USED?
	CAIL	4,20		;AT LEAST 20 WORDS?
	JRST [	MOVEM	4,1(3)		;YES, MAKE REST INTO NEW BLOCK
		MOVN	4,4		;REDUCE WORD COUNT OF ORIGINAL
		ADDM	4,(2)
		MOVEI	2,1(3)
		EXCH	2,IMINFB	;PUT ON LIST TO BE RELEASED
		HRLM	2,@IMINFB
		JRST .+1]
	AOS	IMPFLG
	JRST IMEND2		;REQ JOB0,GET NEW BUFF,AND EXIT

IMEND4:	MOVE	2,1(1)		;GET MSG HEADER
	CALL	IMP8XQ		;PUT ON IRREG MSG Q
	AOS	IMPFLG		;REQ JOB0 SERVICE
IMEND3:	EXCH	1,IMPFRI	;PUT MSG BUFFER BACK ON FREE LIST
	HRLM	1,@IMPFRI
	AOS	IMPNFI		;AND COUNT IT

IMEND2:	POP	P,4		;GET RETURN ADDR BACK
	SETZM	IMIB		;SAY WE DONT HAVE BUFFER
	SKIPLE	IMPNFI		;ARE THERE ANY IN FREE LIST?
	PUSHJ	P,IMISRT	;YES,GET ONE
	MOVSI	1,STSTAT	;BITS TO SAY
	ANDCAM	1,RTSTAT	;LEADER NEXT STATE
	JRST IPMRTN		;AND RETURN TO DISPATCHER
;HERE TO FILL OUTPUT PACKET BUFFERS W/ MESSAGES

;OUTPUT PACKET BUFFER FILLING FSM
;CALLED FROM OPIDLE AND IMPXOU ONLY W/ PUSHJ P,OPFILR
;CALLS OPFPIK WHICH CHOOSES A MESSAGE TO GO OUT
;FSM HAS FOLLOWING STATES
;	OPLDR	FILLS BUFFER W/HOST-IMP LEADER
;	OPHH	FILLS BUFFER W/ HOST-HOST HEADER AND DATA
;	OP32	FILLS W/ 32BIT DATA UNTIL MSG EXAUSTED
;	OP36	FILLS W/ 36BIT DATA UNTIL MSG BUFFER EXAUSTED

OPFILR:	SKIPGE	1,RTSTAT	;GET RTPSTATUS
	RET			;RETURN IF LINE DEAD
	TRNN	1,MSGOUT	;ARE WE CURRENTLY MOVING A MSG?
	CALL	OPFPIK		;NO, CHOOSE ONE
	MOVE	2,OPCNT		;GET BUFFER COUNTS
	TRNN	1,MSGOUT	;OR MSG TO GO?
	JRST [	JUMPN	2,OPFXT	;NO, JUMP IF PACKETS STILL AROUND
		RET]		;ELSE GO AWAY PEACEFULLY
	TRNE	1,FILNXT	;WHICH CHAN ARE WE FILLING?
	JRST OPFCH1		;CHAN 1
	TRNE	2,-1		;CHAN 0, IS IT EMPTY?
	JRST OPFXT		;NO COME BACK LATER
	SETZM	OPBUF0
	SETZM	OPBUF0+1
	SETZM	OPBUF0+2	;CLEAR FIRST 3 WORDS
	MOVE	2,[IOWD ^D32,OPBUF0] ;ONE EXTRA CNT TO MAKE SKIP RITE
	MOVE	3,IMPOUP	;GET MSG POINTER
	LDB	1,FILPTR	;GET FILL STATE
	CALL	@FILTAB(1)	;DISPATCH TO STATE
	MOVEM	3,IMPOUP	;UPDATE MSG POINTER
	MOVEI	1,SNDACK+FILNXT ;BITS TO MOVE PACKET AND FILL CH 1 NEXT
	PIOFF			;NOBODY MOVE UNTIL BUFFER SET UP
	HRRM	2,OPCNT		;SET BUFF CNT
	IORM	1,RTSTAT	;REQ IT  SENT
	PION			;CAN MOVE NOW
	JRST OPFILR		;GO TRY THE OTHER BUFFER

OPFCH1:	TLNE	2,-1		;CHAN 1, IS IT EMPTY?
	JRST OPFXT		;NO, COME BACK LATER
	SETZM	OPBUF1
	SETZM	OPBUF1+1
	SETZM	OPBUF1+2	;CLEAR THE FIRST 3 WORDS
	MOVE	2,[IOWD ^D32,OPBUF1] ;ONE EXTRA TO MAKE SKIP RITE
	MOVE	3,IMPOUP	;GET MSG POINTER
	LDB	1,FILPTR	;GET FILL STATE
	CALL	@FILTAB(1)	;AND DISPATCH
	MOVEM	3,IMPOUP	;UPDATE MSG POINTER
	MOVEI	1,FILNXT	;BIT TO SAY
	ANDCAM	1,RTSTAT	;FILL CHAN 0 NEXT
	MOVEI	1,SNDACK	;AND ANOTHER TO MOVE IT
	PIOFF			;FREEZE UNTIL BUFFER SET
	IORM	1,RTSTAT	;REQ PACKET TO BE SENT
	HRLM	2,OPCNT		;SET BUFFER CNT
	PION
	JRST OPFILR		;GO TRY THE OTHER BUFFER

;HERE TO RETURN, RESET FLAG AND REQ DATA SEND

OPFXT:	SKIPGE	RTSTAT		;HAS LINE GONE DOWN SINCE WE WERE HERE?
	RET			;YES,GO AWAY QUIETLY
	MOVEI	1,SNDACK	
	TDNE	1,RTSTAT	;NEW DATA OUT?
	JRST OPFXT2		;YES
	MOVE	2,OPCNT
	MOVE	3,TODCLK	;WHAT TIME IS IT?
	TRNE	2,-1		;ANYTHING IN 0?
	CAMGE	3,OCH0DL	;YES, TIMED OUT?
	SKIPA			;NO
	JRST OPFXT1
	TLNE	2,-1		;ANYTHING IN 1?
	CAMGE	3,OCH1DL	;YES, HAS IT TIMED OUT?
	RET			;NO ,GO AWAY AND DONT BUG PI
OPFXT1:	IORM	1,RTSTAT	;FORCE OLD STUFF OUT OF HERE
OPFXT2:	AOSN	VDHLOK		;OUTPUT BUSY?
	JRST [	PUSH P,4	;NO
		JSP 4,OPCTRL	;WAKE IT UP
		POP P,4
		RET ]
	RET

;DISPATCH TABLE

FILTAB:	OPLDR	;HOST-IMP LEADER
	OPHH	;HOST-HOST AND FIRST DATA
	OP32	;32 BIT DATA
	OP36	;36 BIT DATA

;POINTER INTO RTSTAT FOR FILL STATE

FILPTR:	POINT 2,RTSTAT,23

;PICK A MESSAGE TO SEND, IMPOUP POINTS TO IT
;1 RETURNS LATEST STATE OF RTSTAT, MSGOUT REFLECTS IF SOMETHING
;TO SEND

OPFPIK:	SKIPG	NOPCNT		;NOPS TO SEND?
	JRST OPFPKH		;NO, CHECK HIGH PRIORITY MSGS
	SOS	NOPCNT		;YES, COUNT IT
	MOVE	3,[IOWD 1,[BYTE (8)4,0,0,0]] ;A NOP
	JRST OPFPIR		;SEND IT AS IRREG MSG

;CHECK FOR HI PRIORITY MSGS

OPFPKH:	HLRZ	1,IMPHBO	;GET FIRST ONE
	JUMPE	1,OPFPKL	;JUMP IF NOT THERE
	HLLZ	2,0(1)		;POINT TO NEXT ONE
	JUMPN	2,.+3		;JUMP IF THERE IS ONE
	MOVEI	3,IMPHBO	;SET UP THE BUFFER
	MOVEM	3,IMPHBI	;PROPERLY AS EMPTY
	MOVEM	2,IMPHBO	;PUT THAT IN LIST HEAD
	JRST OPFPK1		;GO SEND IT

;CHECK FOR LOW PRIORITY MSGS

OPFPKL:	HLRZ	1,IMPOBO	;GET FIRST ONE
	JUMPN	1,OPFPL1	;JUMP IF THERE IS ONE
	SKIPN	HSTGDM		;NO, THEN HOST-GOING-DOWN?
	JRST [	MOVE 1,RTSTAT	;NO, NOTHING TO SEND
		SETZM	IMPOB	;SAY WE ARNT SENDING NOW
		RET]		;RETURN W/OUT MSGOUT SET
	MOVE	3,[IOWD 1,HSTGDM] ;BLKI PTR TO IT
OPFPIR:	MOVEM	3,IMPOUP	;MSG POINTER NOW TO THE IRREG MSG
	HRROS	IMPOB		;MAKE IT DO RIGHT THING ON TESTS
	MOVEI	1,MSGOUT	;SAY WE WANT IT SENT
	IORB	1,RTSTAT	;IN BOTH PLACES
	RET
OPFPL1:	HLLZ	2,0(1)		;POINT TO NEXT LO MSG
	JUMPN	2,.+3		;JUMP IF THERE IS ONE
	MOVEI	3,IMPOBO	;DO RIGHT THINGS
	MOVEM	3,IMPOBI	;FOR EMPTY BUFFER
	MOVEM	2,IMPOBO	;SET UP LIST HEAD
OPFPK1:	MOVEM	1,IMPOB		;SAY WE GOT A MSG,HI PRIORITY JOINS HERE
	MOVN	2,0(1)		;GET ITS SIZE
	HRLI	1,1(2)		;DONT CNT HEADER WD AND MAKE BLKI PTR
	MOVEM	1,IMPOUP	;PUT IN THE POINTER WORD
	MOVEI	1,MSGOUT	;SAY WE WANT IT SENT
	IORB	1,RTSTAT	;UPDATE STATE WORD AND 1
	RET

;HERE TO FILL A PACKET BUFFER W/ A MSG LEADER
;2 HAS THE PACKET BUFFER POINTER, 3 AHS THE MSG PTR
;SETS LAST0 OR LAST1 FOR 32 BIT MSGS

OPLDR:	AOBJN	3,.+1		;STEP MSG POINTER
	MOVE	1,(3)		;GET FIRST WORD
	MOVEM	1,1(2)		;AND PUT IT IN PACKET BUFFER
	JUMPGE	3,OPLDR1	;JUMP IF 1 WORD BUFFER
	MOVEI	1,1		;ELSE STEP
	DPB	1,FILPTR	;TO HOST-HOST STATE
	MOVEI	2,2		;COUNT IS 2 16BIT WORDS
	RET

OPLDR1:	MOVEI	1,LAST1		;MASK TO MARK LAST PACKET
	CAMN	2,[IOWD ^D32,OPBUF0] ;CHOOSE THE BIT FOR CH 1
	MOVEI	1,LAST0		;OR CH 0
	IORM	1,RTSTAT	;SET IT, LEAVE STATE OPLDR
	MOVEI	2,2		;COUNT IS 2 16BIT WORDS
	MOVEI	1,MSGOUT	;SAY CHOOSE ANOTHER
	ANDCAM	1,RTSTAT	;MSG FOR THE NEXT EMPT PACKET
	RET

;HERE TO FILL 2ND PACKET OF A MSG
;CHOOSES EITHER 32 OR 36 BIT DATA MODE

OPHH:	PUSH	P,4		;SAVE 4
	MOVE	1,(3)		;GET MSG LEADER
	AND	1,[FRMIMP +377B23] ;KEEP IMP BIT AND LINK FIELD
	CAMLE	1,[<LLINK>B23]	;IS IT SPEC LINK?
	SKIPA	4,[^D36]	;YES ASSUME 36BIT
	LDB	4,[POINT 8,1(3),11] ;ELSE USE CONNECTION BYTE SIZE
	MOVEI	1,3		;SAY OP36 STATE
	CAIE	4,^D36		;BYTE SIZE 36 BITS?
	MOVEI	1,2		;NO, THEN ASSUME 32BITS
	DPB	1,FILPTR	;PUT NEW STATE IN RTSTAT
	AOBJP	3,.+1		;STEP MSG PTR
	MOVE	1,(3)		;GET HOST-HOST WORD
	LSH	1,-4		;PUT IT WHERE IT BELONGS IN 32 BIT WORD
	AOBJP	2,.+1		;STEP PACKET PTR
	MOVEM	1,(2)		;AND PUT IT IN BUFFER
	CAIN	4,^D36		;WHICH STATE DID WE DECIDE?
	JRST OPHH36		;36 BITS
	POP	P,4		;WE DONT NEED 4 ANYMORE
	AOBJP	2,.+1		;STEP TO NEXT PACKET WORD
	JRST OPHH32		;JUMP INTO OP32 WHERE WE DONT WRITE FIRST 8BITS

OPHH36:	MOVE	4,[-6,,2]	;STATE TO SHIFT STARTING WORD 8 BITS
	AOBJP	2,.+1		;STEP THE PACKET POINTER
	JRST OP36HE		;JUMP INTO SHIFT LOOP IN OP36



;HERE TO FILL PACKETS 3-9 OF A MSG IN 32 BIT MODE
;ENTRY TO THIS STATE AT OP32
;OPHH32 IS ENTRY FROM OPHH FOR DATA PART OF 2ND PACKET

OP32L:	LDB	1,[POINT 24,(3),23] ;GET FIRST 24 BITS OF WORD
	DPB	1,[POINT 24,(2),31] ;PUT IT IN SHIFTED 8 BITS
OP32:	AOBJP	2,[MOVEI 2,^D62	;STEP PKT PTR,FULL BUFFER IS
		    RET]	;62 16 BIT WORDS
	LDB	1,[POINT 8,(3),31] ;GET LAST 8 BITS OF WORD
	DPB	1,[POINT 8,(2),7] ;AND PUT IN FIRST PART OF NEXT WORD
OPHH32:	AOBJN	3,OP32L		;STEP MSG PTR
	CAIG	3,777777	;BUT FALL THRU ONLY
	JRST OP32L		;AFTER ALL BITS MOVED
OMEXIT:	MOVEI	1,MSGOUT+FLSTAT	;CHOOSE NEW MSG AND START IN LDR STATE
	ANDCAB	1,RTSTAT	;CLR BITS AND GET STATE
	TRNE	1,FILNXT	;WHICH CHAN DID WE FILL?
	SKIPA	1,[LAST1]	;CHAN1
	MOVEI	1,LAST0		;OR CHAN 0
	IORM	1,RTSTAT	;SO MARK LAST PACKET BIT
	PUSH	P,2		;SAVE 2 FROM GETTING IT
	CALL	OMRLSE		;DECIDE WHAT TO DO W/ MSG BUFFER
	POP	P,2		;RESTORE 2
	HLRE	2,2		;GET COUNT OUT OF PTR
	ADDI	2,^D32		;SAY WHATS IN IT, NOT WHATS LEFT
	ASH	2,1		;*2 FOR 16 BIT WORDS
	RET

;HERE TO FILL PACKETS 3-9 IN 36 BIT MODE
;OP36HE IS ENTRY FROM OPHH FOR DATA PART OF 2ND PACKET IN 36 BIT MODE

OP36:	PUSH	P,4		;SAVE RETURN ADDR
	MOVE	4,OMSHFT	;GET SHIFT STATE
	SKIPN	OMSPST		;SKIP IF SPECIAL STATE ENTRY
	JRST OP36EN		;ENTER SHIFT LOOP NORMALLY
	SETZM	OMSPST		;RESET THE FLAG
	AOBJP	2,.+1		;STEP PKT POINTER
OP36L:	LDB	1,OSHFT1(4)	;GET BITS FROM NEW MSG WORD
	DPB	1,OSHFT2(4)	;FILL REST OF PACKET WORD
OP36EN:	AOBJP	2,OP36X1	;STEP PKT PTR, JUMP ON OVFL
	MOVE	1,(3)		;GET REST OF MSG WORD
	DPB	1,OSHFT3(4)	;AND PUT IN NEW PKT WORD
	AOBJN	4,OP36HE	;STEP STATE AND JUMP
	MOVSI	4,-^D8		;ELSE RESET STATE
	AOBJP	2,OP36X2	;AND STEP PKT PTR, JUMPING ON OVFL
OP36HE:	AOBJN	3,OP36L		;STEP MSG PTR
	CAIG	3,777777
	JRST OP36L		;AND CONTINUE IF STILL SOME BITS
	POP	P,4		;RESTORE 4
	JRST OMEXIT		;TERMINATE MSG IN OP32

OP36X2:	AOBJN	3,OP36X3	;SPEC STATE,PKT FULL,STEP MSG PTR
	CAIG	3,777777
	JRST OP36X3		;JUMP IF NEED ANOTHER PACKET
	POP	P,4		;PACKET AND MSG ENDED AT SAME TIME
	JRST OMEXIT		;TERMINATE MSG

OP36X3:	SETOM	OMSPST		;SAY WE NEED SPECIAL ENTRY
OP36X1:	MOVEM	4,OMSHFT	;SAVE STATE
	POP	P,4		;RESTORE 4
	MOVEI	2,^D62		;FULL BUFFER IS 62 16 BIT WORDS
	RET

;STATE BYTE POINTERS

XX==0
OSHFT1:	REPEAT ^D8,<POINT 32-XX,(3),32-XX-1
		XX=XX+4>

XX==0
OSHFT2:	REPEAT ^D8,<POINT 32-XX,(2),31
		XX=XX+4>

XX==4
OSHFT3:	REPEAT ^D8,<POINT XX,(2),XX-1
		XX=XX+4>

;THIS ROUTINE DECIDES WHAT TO DO WITH AN OUT MSG BUFFER
;EITHER RELEASES OR SAVES IN CASE IMP WANTS IT AGAIN, THEN RELEASE

OMRLSE:	MOVE	1,IMPOB		;POINT TO BUFFER
	MOVE	2,1(1)		;GET LEADER WORD
	AND	2,[FRMIMP+377B23] ;KILL WHAT WE DONT WANT
	CAMLE	2,[<LLINK>B23]	;SPECIAL LINK OR TO IMP?
	JRST OMRLS1		;YES,RELEASE IT
	LDB	1,[POINT 16,1(1),23] ;GET HOST AND LINK
	IORI	1,1B18
	CALL	IMPPIL		;GET LT INDEX FOR MSG
	JRST OMRLS2		;NOT THERE, BUMMER
	MOVSI	2,(RFNMC)	;BE SURE RFNM HASNT RETURNED
	TDNN	2,IMPLT2(1)	;ALREADY
	JRST OMRLS1		;YES, RELEASE IT
	HRRZ	2,IMPLT3(1)	;BE SURE NOTHING THERE
	JUMPN	2,OMRLS2	;THERE IS DO BUG THING
	MOVE	2,IMPOB		;GET BUFFER
	HRRM	2,IMPLT3(1)	;PUT IT IN TABLE
	JRST OMRLS3

OMRLS2:	BUG(NTE,<CANT FIND LT ENTRY FOR THIS OUTPUT MSG>)
OMRLS1:	MOVE	1,IMPOB		;GET BUFFER
	EXCH	1,IMINFB	;PUT ON FREE LIST
	HRLM	1,@IMINFB
	AOS	IMPFLG		;ASK FOR JOB0 SERVICE
OMRLS3:	MOVE	1,IMPOB		;UNLOCK BUFFER
	CALL	IMULKB		;TO SPRING PAGES
	RET


;PACKET INPUT PI STATES
;IPCTRL	GETS FIRST WORD (CONTROL WORD) AND DECODES TO SET UP BLKI POINTERS
;	AND STATE VECTORS
;IPDAT	INPUTS PACKET DATA 32 BITS AT A TIME
;IPSRC	HANDLES IN INTERRUPT GENERATED BY SEARCH MODE
;IPERR	CAUSES IMPBUG FOR SECOND WORD OF ONE WORD PACKETS

;INPUT PACKET CONTROL WORD STATE
;HERE FOR FIRST WORD OF PACKET
;SET UP VECTORS DEPENDING ON PACKET TYPE
;FLUSH BAD PACKETS HERE IF YOU CAN

IPCTRL:	MOVEM	1,IMPIAC+1	;SAVE AC1
	DATAI	IMP,1		;GET CONTROL WD FROM IMP
	AOS	RVRCNT		;COUNT EVERY PACKET
	TLNN	1,SPCPKT	;CHECK LINE LATER IF SPEC PKT
	SKIPL	RTSTAT		;IS LINE ALIVE/KEEP THIS PACKET?
	SKIPA			;YES
	JRST IPCL0		;NO,FLUSH IT
	TLNE	1,HSTIMP	;IS PACKET GOING THE RIGHT WAY?
	JRST IPCL4		;NO,LOOPED
	HLRZM	1,ICTRWD	;SAVE IN USEFULL WAY FOR XMITTER
	TLNE	1,SPCPKT	;SPECIAL PACKET?
	JRST IPCL1		;YES,GO SET UP SPEC PKT VECTORS
	SKIPN	IMPRDY		;FLUSH DATA PACKETS TILL IMP UP
	JRST IPCL0
	TLNN	1,WDS16B	;NULL PACKET?
	JRST IPCL2		;YES,SET UP VECTORS
	MOVEM	2,IMPIAC+2	;SAVE AC2
	TLO	1,IBUFUL	;SET BIT FOR EQV TEST OF BUFFER AVAIL
	TLNE	1,CHNUM		;WHICH CHANNEL?
	SKIPA	2,RTSTAT	;GET CH1 EXPECTED PACKET BIT
	HRL	2,RTSTAT	;GET CH0 EXPECTED PACKET BIT
	EQV	2,1		;BASH THE BIT
	TLNN	2,PKTODD	;IS IT STILL THERE?
	JRST IPCL3		;NO,FLUSH THIS DUPLICATE PACKET
	TLNE	2,IBUFUL	;IS THE BUFFER AVAIL?
	JRST IPCL5		;NO BUFFER AVAILABLE, FLUSH
	LDB	2,PKWCNT	;GET PACKET WD CNT
	ADDI	2,3		;ROUND AND ADD FOR EXTRA 32 BIT WD
	LSH	2,-1		;MAKE 32 BIT WD CNT AND
	MOVN	2,2		;NEGATIVE
	HRRI	1,IPBUF0-1	;SET UP CH0 BLKI PTR
	TLNE	1,CHNUM		;WHICH CHANNEL?
	HRRI	1,IPBUF1-1	;IT IS CH1 CHANGE PTR
	HRL	1,2		;COMPLETE BLKI PTR W/ CNT
	MOVEM	1,IPBPTR	;SET UP POINTER WORD
	MOVEI	2,IPREG		;END WILL BE REGULAR
	MOVEI	1,IPDAT		;DATA IS NEXT STATE
	MOVEM	2,IPENDV	;SET VECTOR
	MOVE	2,IMPIAC+2	;RESTORE 2
IPCLX:	MOVEM	1,IMIDSP	; SET VECTOR
	MOVE	1,IMPIAC+1	;AND RESTORE 1
	UNBRK IMP

;SET UP VECTORS FOR SPECIAL PACKET

IPCL1:	SKIPA	1,[IPSPEC]	;END OF SPECIAL PKT

;SET UP VECTORS FOR NULL PACKETS

IPCL2:	MOVEI	1,IPNULL	;END OF NULL PACKET
	MOVEM	1,IPENDV	;SET UP END VECTOR
	MOVEI	1,IPERR		;SPECIAL PACKETS ARE ONLY ONE WORD
	JRST	IPCLX
;POINT TO PACKET WORD COUNT
PKWCNT:	POINT 6,ICTRWD,25	;CONTROL WORD IS IN RH

;NOTE NO PACKET BUFFERS AVAILABLE
;CAN HAPPEN IF STUFFER ISNT FAST ENOUGH

IPCL5:	;;;BUG(NTE,<IPCTRL-NO INPUT PACKET BUFFER AVAILABLE>)
	JRST IPCL0		;PRETEND WE DIDNT EVEN SEE IT

;NOTE THE LOOPED PACKET

IPCL4:	MOVEM	1,IMPLUP	;SAVE THE CONTROL WORD
	AOS	LUPCNT		;COUNT IT
	BUG (NTE,<IPCTRL-MODEM LOOP STATE CHANGED>) ;AND REPORT IT
	JRST IPCL0 		;FLUSH REST OF PACKET


;FLUSH REST OF PACKET

IPCL3:	MOVEI	1,SNDACK	;WE WANT TO ACK THE DUPLICATE
	IORM	1,RTSTAT	;PACKET TO GET IT OUT OF OUR HAIR
	AOSN	VDHLOK		;START OUTPUT IF IDLE
	JRST [	MOVEM	3,IMPIAC+3	;SAVE EXTRA AC'S
		MOVEM	4,IMPIAC+4
		JSP	4,OPCTRL	;SEND 1ST WORD
		MOVE	4,IMPIAC+4
		MOVE	4,IMPIAC+3
		JRST .+1]
	MOVE	2,IMPIAC+2
	AOS	DUPCNT		;COUNT THE DUPLICATE PACKET
IPCL0:	MOVEI	1,IPFLSH	;SET UP END VECTOR
	MOVEM	1,IPENDV	;FOR FLUSH
	AOS	FLSCNT		;COUNT THIS FLUSHED PACKET
	CONO	IMP,IMISRC	;TELL RCVR TO SEARCH
	MOVEI	1,IPSRC		;PUT IN SEARCH NOP
	JRST	IPCLX

;

;INPUT PACKET DATA STATE
; WILL READ LAST WORD BUT EXTRA WORD CAUSES NON-SKIP WHICH 
; IMPLIES  BUFF OVERFLOW

IPDAT:	BLKI	IMP,IPBPTR	;PUT WORD IN BUFFER
	SKIPA			;PACKET TOO LONG
	UNBRK	IMP

;PROCESS BUFFER OVERFLOW
	MOVEM	1,IMPIAC+1	;SAVE AC1
	CONO	IMP,IMISRC	;TELL RCVR TO SEARCH
	BUG(NTE,<PACKET TOO LONG>)	;TELL SOMEONE ABOUT IT
	AOS	RERCNT		;COUNT IT
	MOVEI	1,IPFLSH	;SET UP END VECTOR
	MOVEM	1,IPENDV	;FOR A FLUSH
	MOVEI	1,IPSRC		;PUT IN SEARCH NOP
	MOVEM	1,IMIDSP
	MOVE	1,IMPIAC+1	;RESTORE AC1
	UNBRK	IMP

;INPUT PACKET ERROR STATE
;HANDLE EXTRA WORD THAT OCCURS ON ONE WORD PACKETS--SHOULDN'T GET HERE

IPERR:	BUG(NTE,<OVERLONG NULL OR SPECIAL PACKET>) ;REPORT IT
	AOS	RERCNT		;COUNT IT
	MOVEM	1,IMPIAC+1	;SAVE AC1
	MOVEI	1,IPFLSH	;SET UP END VECTOR
	MOVEM	1,IPENDV	;FOR FLUSH
	CONO	IMP,IMISRC	;TELL RCVR TO SEARCH
	MOVEI	1,IPSRC		;PUT IN SEARCH NOP
	MOVEM	1,IMIDSP	;SET VECTOR
	MOVE	1,IMPIAC+1	;RESTORE 1
	UNBRK IMP

;INPUT PACKET SEARCH STATE
;RCVR SEARCH TERMINATES W/ AN IN AND END. DO SOMETHING W/ THE IN

IPSRC:	MOVEM	1,IMPIAC+1	;SAVE AC1
	DATAI	IMP,1		;GET THE WORD
	MOVE	1,IMPIAC+1	;RESTORE 1
	UNBRK IMP

;PACKET END INPUT PI STATES
;IPREG	TERMINATES DATA PACKET, CHECKS FOR ERRORS,CHECKS LINE STILL
;	ACTIVE, AND PROCESSES ACKS FROM IMP AND CALLS MSG BUILDER
;IPSPEC	TERMINATES SPECIAL PACKETS,PROCESSES HELLOS AND I-HEARD-YOU'S
;	DOES SPECIAL THINGS FOR KEEPING LINE UP AND GETTING LINE BACK UP
;IPNULL	PROCESSES ACKS FROM IMP, CHECKS ERRORS BUT DOES NOT CALL MSG BUILDER
;IPFLSH	CLEARS END INTERRUPT FROM PACKET FLUSH
;IPCRSH	CAUSES A BUGCHK FOR AN END W/OUT A PRECEDING IN

;INPUT PACKET REGULAR END STATE
;HERE TO CHECK LINE ACTIVE,ERRORS,AND PROCESS ACKS TO RELEASE OUTPUT BUFFERS
;MARKS PACKET BUFFER IN USE AND SETS WORD COUNT IN IPCNT
;CALLS INPUT MSG PACKER WHICH WILL COPY CONTENTS AND RELEASE BUFFER
;INITIATE SNDACK TO TRANSMIT SIDE

IPREG:	MOVEM	4,IMPIAC+4
	MOVEI	4,IMPIAC
	BLT	4,IMPIAC+3	;SAVE ACS 0-4
	SKIPL	RTSTAT		;IS LINE ALIVE
	CONSZ	IMP,IMIERB	;AND PACKET ARRIVE ERROR FREE?
	JRST [	AOS	RERCNT	;COUNT THE ERROR
		JRST IENDXT]	;CLEAN UP AND GO AWAY (IN IPNULL)
	SKIPL	IMPRDY		;IS READY UP?
	JRST IENDXT		;NO, THEN WE DONT WANT MSGS
	SKIPE	IPCNT		;IS THE OTHER BUFFER STIL AROUND?
	ISB	SCDCHN		;YES WAKE UP THE SCHEDULER
	MOVE	1,ICTRWD	;GET PACKET CONTROL WORD
	MOVEM	1,IMPAKS	;UPDATE IMPS STATE FOR XMIT SIDE
	LDB	2,PKWCNT	;AND WORD COUNT
	TRNE	1,CHNUM		;WHICH CHANNEL IS IT?
	JRST IPRG1		;1
	MOVEI	3,IBUFUL	;MASK FOR BUFFER FULL
	TRNE	1,LSTPKT	;IS LAST PACKET BIT ON?
	TRO	3,ENDMSG	;YES,THEN THIS IS END OF MESSAGE
	MOVEI	1,XPECT		;AND EXPECTING ODD/EVEN
	HRRM	2,IPCNT		;STORE WORD COUNT
	JRST IPRG2

IPRG1:	MOVSI	3,IBUFUL	;THE OTHER MASK FOR BUFFER FULL
	TRNE	1,LSTPKT	;IS LAST PACKET BIT ON/
	TLO	3,ENDMSG	;THEN IT IS END OF MESSAGE
	MOVSI	1,XPECT		;AND EXPECTING ODD/EVEN
	HRLM	2,IPCNT		;AND STORE CHAN 1 WORD COUNT
IPRG2:	TRO	3,SNDACK	;SAY SEND AN ACK BACK TOO
	IORM	3,RTSTAT	;NOW MARK BOTH BITS
	XORM	1,RTSTAT	;AND COMPLEMENT THE EXPECTING BIT
	JSP	4,OPRLSE	;RELEASE ANY OUTPUT BUFFERS WE CAN
	AOSN	VDHLOK		;TRY THE LOCK
	JSP	4,OPCTRL	;AND INIT OUTPUT IF IT IS IDLE
	JRST IENDXT		;CLEAN UP AN UNBRK


;INPUT PACKET SPECIAL END STATE
;HERE TO CHECK FOR ERRORS AND WHETHER IT IS A HELLO OR I-HEARD-YOU
;IF HELLO INIT A SNDHRD TO TRANSMIT SIDE
;ELSE IF LINE ACTIVE COUNT IT
;	ELSE DO SPECIAL THINGS FOR THE DEAD LINE

IPSPEC:	MOVEM	4,IMPIAC+4
	MOVEI	4,IMPIAC
	BLT	4,IMPIAC+3	;SAVE AC'S
	CONSZ	IMP,IMIERB	;ANY ERRORS?
	JRST [	AOS	RERCNT		;YES,COUNT IT
		JRST IENDXT]		;CLEAN UP
	MOVE	1,ICTRWD	;GET THE CONTROL WORD
	SKIPGE	RTSTAT		;SKIP IF LINE UP
	SKIPE	VDHANS		;LINE DOWN,CAN I ANSWER?
	SKIPA			;YES
	JRST IENDXT		;NO
	TRNE	1,HERDU		;A HELLO?
	JRST IPSPC1		;NO
IPSPCH:	MOVEI	1,SNDHRD	;YES, SET A BIT
	IORM	1,RTSTAT	;TO SEND AN I-HEARD-YOU
	AOSN	VDHLOK		;TRY THE LOCK
	JSP	4,OPCTRL	;START UP TRANSMITTER
	JRST IENDXT		;AND EXIT

;AN I-HEARD-YOU
IPSPC1:	AOS	RTPCNT		;ADD ONE BACK TO THE BANK
	JRST IENDXT		;CLEAN UP AND UNBRK


;INPUT PACKET NULL END STATE
;HERE TO CHECK ERRORS AND PROCESS ACKS

IPNULL:	MOVEM	4,IMPIAC+4
	MOVEI	4,IMPIAC
	BLT	4,IMPIAC+3	;SAVE ACS 0-4
	CONSZ	IMP,IMIERB	;WAS THERE AN ERROR?
	JRST [	AOS	RERCNT	;YES,COUNT IT
		JRST IENDXT]	;QUIT, NOTHING MORE TO DO
	MOVE	1,ICTRWD	;GET HEADER WORD
	MOVEM	1,IMPAKS	;AND UPDATE IMP  STATE FOR TRANSMITTER
	JSP	4,OPRLSE	;AND TRY TO RELEASE SOME BUFFERS
IENDXT:	MOVEI	1,IPCTRL	;SET UP VECTOR FOR NEXT PACKET
	MOVEM	1,IMIDSP
	MOVEI	1,IPCRSH	;COVER ALL THE BASES
	MOVEM	1,IPENDV
	MOVSI	4,IMPIAC
	BLT	4,4		;RESTORE THE ACS
	CONO	IMP,IMICLR+IMPGEB ;CANCEL END AND ERROR NEEDED OR NOT
	UNBRK IMP

;INPUT PACKET FLUSH END STATE
;HERE TO FINISH OFF FLUSHED PACKETS
;CLEAR ERROR AND END INTERRUPTS
;SET UP VECTORS

IPFLSH:	MOVEM	1,IMPIAC+1	;SAVE AC 1
	MOVEI	1,IPCRSH	;COVER ALL
	MOVEM	1,IPENDV	;THE BASES
	MOVEI	1,IPCTRL	;SET UP FOR NEXT PACKET
	MOVEM	1,IMIDSP	;SET VECTOR
	MOVE	1,IMPIAC+1	;RESTORE 1
	CONO	IMP,IMICLR+IMPGEB ;CLEAR THE END AND ERROR BITS
	UNBRK IMP

;INPUT PACKET END WITHOUT IN STATE
;HERE IF GOT 2 ENDS W/OUT INTERVENING IN

IPCRSH:	BUG(CHK,<INPUT END PI WITHOUT IN PI>)
	SETOM	KILLIT		;DRAG LINE DOWN
	CONO	IMP,IMICLR+IMPEOB ;SET THINGS RIGHT FOR INPUT
	UNBRK IMP

;PACKET OUTPUT PI STATES
;OPCTRL	DECIDES WHAT TYPE PACKET TO SEND AND SENDS IT
;	CALLED W/ A JSP 4,OPCTRL ALL CALLS HAVE AN INTERLOCK
;	EXCEPT OPIDLE
;OPDAT	SENDS PACKET DATA WITHBLKO
;	SETS VECTOR FOR OPEND AT OVERFLOW
;OPEND	SENDS PACKET TERMINATOR, SETS VECTOR FOR OPIDLE
;OPIDLE	CALLS OPCTRL IF SOMETHING TO DO
;	IDLES TRANSMITTER AND RESETS INTERLOCK IF NOT


;OUTPUT PACKET CONTROL WORD STATE
;CALLED BY JSP 4,OPCTRL
;DECIDES TYPE OF PACKET TO SEND,SENDS CONTROL WORD
;SETS UP VECTOR FOR EITHER OPDAT (AND BLKO POINTER TOO) OR OPEND (FOR 1 WD PKTS)
;TRASHS AC'S 1-3

OPCTRL:	MOVE	1,RTSTAT	;GET RTP STATUS
	TRNE	1,SNDHRD	;SHOULD WE SEND AN I-HEARD-YOU?
	JRST OPCHRD		;YES
	TRNE	1,SNDHLO	;NO,WHAT ABOUT A HELLO?
	JRST OPCHLO		;YES
	TRNE	1,SNDACK	;NO,THEN MUST BE A REG PACKET
	JRST OPCACK		;AND IT IS
	BUG(CHK,<OUTPUT CONTROL WD CALL WITHOUT BITS SET>) ;NO IT ISN'T,YOU LOSE
	JRST (4)

;AN I-HEARD-YOU
OPCHRD:	MOVEI	1,SNDHRD	;THE BIT MASK
	MOVSI	2,HERDU+SPCPKT+HSTIMP ;AN I-HEARD-YOU PACKET
	JRST OPCHL1

;A HELLO
OPCHLO:	MOVEI	1,SNDHLO	;THE OTHER BIT MASK
	MOVSI	2,SPCPKT+HSTIMP	;A HELLO PACKET
OPCHL1:	ANDCAM	1,RTSTAT	;TURN OFF THE MASKED BIT
	MOVEI	1,OPEND		;PACKET IS ONLY ONE WORD
	JRST OPCEND		;GO SEND IT AND RETURN

;AN ACKNOWLEDGEMENT AT LEAST (IF NOT SOME DATA)
OPCACK:	HRLZI	2,HSTIMP	;THE BASIC PACKET
	TLNE	1,XPECT		;SEND THE
	TLO	2,ACK1		;RIGHT ACKS
	TRNE	1,XPECT		;FOR BOTH
	TLO	2,ACK0		;CHANNELS
	SKIPN	3,OPCNT		;GET THE WORD COUNTS AND ANY DATA TO SEND?
	JRST [	MOVEI 1,OPEND		;ONLY ONE WORD
		MOVEI 3,SNDACK		;CANCEL
		ANDCAM 3,RTSTAT		;DATA REQUEST
		JRST OPCEND]		;FINISH IT OFF
	MOVSI	1,MOVNG0+MOVNG1	;MARK BOTH BUFFERS MOVING
	IORB	1,RTSTAT	;UNTIL WE DECIDE WHICH TO SEND
	TRNE	1,CURCHN	;WHICH CHANNEL SHALL WE SEND?
	JRST OPCAK1		;1
OPCAK0:	TRNN	3,-1		;0 --ANYTHIING THERE?
	JRST OPCAK1		;NO, GO TRY 1
	MOVEI	1,CURCHN
	IORB	1,RTSTAT	;START LOOKING WITH CHN 1 NEXT TIME
	TRNN	1,SENT0		;HAVE WE SENT THIS BEFORE
	JRST OPCAK2		;NO, IGNOR TIMEOUT STUFF
	MOVE	3,OCH0DL	;GET RETRANSMIT TIME
	CAMLE	3,TODCLK	;RETRANS IF TIMED OUT ELSE NULL PACKET
	JRST [	MOVEI	1,OPEND
		MOVE 3,[MOVNG0+MOVNG1,,SNDACK] ;CANCEL MOVEMENT FLAGS
		ANDCAM 3,RTSTAT		;AND SEND REQUEST
		JRST OPCEND]
OPCAK2:	HRRZ	3,OPCNT		;GET THE WORD COUNT
	DPB	3,OPWCNT	;AND PUT IT IN HEADER
	MOVE	1,RTSTAT	;GET BACK STATUS WORD
	TRNE	1,LAST0		;LAST PACKET?
	TLO	2,LSTPKT	;YES
	TRNE	1,XMTOD0	;THE ODD PACKET?
	TLO	2,PKTODD	;YES
	TRNE	1,SENT0		;HAVE WE SENT THIS BEFORE?
	AOS	RPTCNT		;YES,COUNT IT
	MOVEI	3,SENT0		;MARK BUFFER AS
	IORM	3,RTSTAT	;SENT
	MOVEI	3,OPBUF0-1	;SET UP ADDRESS PART OF BLKO PTR
	MOVEI	1,RXMTDL	;WAIT THIS LONG
	ADD	1,TODCLK	;BEFORE RETRANSMITTING
	MOVEM	1,OCH0DL
	MOVE	1,[MOVNG1,,SNDACK] ;MARK OTHER CHAN IDLE AND CANCEL DATA REQ
	JRST OPCAK4

OPCAK1:	TLNN	3,-1		;ANYTHING THERE?
	JRST OPCAK0		;NO, GO TRY 0
	MOVEI	1,CURCHN
	ANDCAB	1,RTSTAT	;START WITH CHAN 0 NEXT TIME
	TRNN	1,SENT1		;HAVE WE SENT THIS ONE BEFORE?
	JRST OPCAK3		;NO
	MOVE	3,OCH1DL	;GET TIME
	CAMLE	3,TODCLK	;RETRANS IF TIMEOUT ELSE NULL PACKET
	JRST [	MOVEI	1,OPEND	;DO A NULL PACKET
		MOVE 3,[MOVNG0+MOVNG1,,SNDACK] ;CANCEL MOVEMENT FLAGS
		ANDCAM 3,RTSTAT		;AND SEND REQUEST FLAGS
		JRST OPCEND]
OPCAK3:	HLRZ	3,OPCNT		;GET WORD COUNT AND
	DPB	3,OPWCNT	;PUT IN PACKET HEADER
	TLO	2,CHNUM		;AND SAY THIS IS A CHAN 1 PACKET
	TRNE	1,LAST1		;DO THE SAME THING
	TLO	2,LSTPKT	;ONLY THIS TIME
	TRNE	1,XMTOD1	;DO IT
	TLO	2,PKTODD	;FOR CHANNEL 1
	TRNE	1,SENT1		;HAVE WE SENT THIS BEFORE?
	AOS	RPTCNT		;YES, COUNT IT
	MOVEI	3,SENT1		;MARK BUFFER
	IORM	3,RTSTAT	;AS SENT
	MOVEI	1,RXMTDL	;WE DONT WANT TO RETRANSMIT
	ADD	1,TODCLK	;FOR RXMTDL MILLISEC
	MOVEM	1,OCH1DL	;SINCE THERE IS LINE DELAY
	MOVEI	3,OPBUF1-1
	MOVE	1,[MOVNG0,,SNDACK] ;MARK OTHER CHAN IDLE AND CANCEL DATA REQ
OPCAK4:	ANDCAM	1,RTSTAT	;IN THE STATE WORD
	MOVEM	3,OPBPTR	;PUT IT IN THE POINTER
	LDB	3,OPWCNT	;GET THE WORD COUNT BACK
	AOS	3		;ROUND
	LSH	3,-1		;TO 32 BIT COUNT
	MOVN	3,3		;MAKE NEGATIVE
	HRLM	3,OPBPTR	;AND PUT IN THE PTR
	MOVEI	1,OPDAT		;DATA STATE NEXT
OPCEND:	MOVEM	1,IMODSP	;STORE STATE VECTOR
	AOS	XMTCNT		;COUNT THE PACKET,
	MOVEM	2,OCTRWD	;SAVE THE CONTROL WORD AND
	DATAO	IMP,2		;SEND THE WORD
	JRST (4)		;AND RETURN
 
;OUTPUT PACKET DATA STATE
;LOOP HERE UNTIL END OF BUFFER

OPDAT:	BLKO	IMP,OPBPTR	;MOVE OUT A WORD
	JRST OPDAT1		;END OF PACKET
	UNBRK IMP

OPDAT1:	MOVEM	1,IMODSP	;SAVE AC1
	MOVEI	1,OPEND		;TERMINATE THE PACKET
	EXCH	1,IMODSP	;AT NEXT INTERRUPT
	UNBRK IMP

;OUTPUT PACKET END STATE
;HERE TO TERMINATE A PACKET
;TRANSITION TO OPIDLE

OPEND:	MOVEM	1,IMODSP	;SAVE AC1
	CONO	IMP,IMPEOB	;SEND END OF PACKET
	MOVSI	1,MOVNG0+MOVNG1	;MARK BOTH BUFFERS
	ANDCAM	1,RTSTAT	;AS NOT IN TRANSIT
	MOVEI	1,OPIDLE	;DECIDE FATE
	EXCH	1,IMODSP	;AT NEXT INTERRUPT
	UNBRK IMP

;CONTROL WORD WORD COUNT POINTER
OPWCNT:	POINT 6,2,7		;POINTS TO WORD BEING BULT IN 2

;OUTPUT IDLE STATE
;HERE TO EITHER START NEXT PACKET OR GO IDLE

OPIDLE:	MOVEM	4,IMPOAC+4	;SAVE 4
	MOVEI	4,IMPOAC
	BLT	4,IMPOAC+3	;SAVE THE REST OF THEM
	AOS	VDHLOK		;SAY WE ARE BUSY
	SKIPGE	4,RTSTAT	;IF LINE DEAD
	TRNE	4,SNDHLO+SNDHRD	;AND NO HELLOS OR REPLYS GO IDLE ELSE
	TRNN	4,WRK2DO	;ANYTHING TO DO?
	JRST [	CONO	IMP,IMPSTO	;NO, KILL THE IMP
		SETOM	VDHLOK		;UNLOCK THE CONTROL WORD  ROUTINE
		JRST OPIDL1 ]
	JSP	4,OPCTRL	;YES, SET UP AND SEND FIRST WORD
OPIDL1:	MOVSI	4,IMPOAC
	BLT	4,4		;RESTORE AC'S
	UNBRK IMP


;HERE TO RELEASE OUTPUT BUFFERS AS INDICATED BY RCV'D ACK BITS
;SETS PROPER ODD/EVEN BITS IN RTSTAT
;CALLED WITH JSP 4,OPRLSE. RETURNS RTSTAT IN AC1

OPRLSE:	SKIPGE	3,RTSTAT	;IF LINE DOWN
	SETZM	OPCNT		;RELEASE THE BUFFERS
	SKIPN	OPCNT		;IF ANYTHING THERE, TRY TO RELEASE IT ELSE
	JRST (4)
	EQV	3,IMPAKS	;SEE IF ACK BITS CHANGED
	MOVE	1,RTSTAT	;GET FRESH RTP STATE
	TRNE	3,XMTOD1	;ON CHAN 1?
	JRST OPRLS1		;NO
	TLNE	1,MOVNG1	;IS THIS BUFFER BUSY?
	JRST OPRLS1		;YES, DONT DO ANYTHING WITH IT
	TRNN	1,SENT1		;IS THIS A SPURIOUS ACK?
	JRST OPRLS3		;YES, CRASH LINE
	HRRZS	OPCNT		;YES, RELEASE BY CLEARING WD CNT
	MOVEI	1,SENT1+LAST1	;CLEAR STATUS BITS
	ANDCAM	1,RTSTAT	;ON THIS BUFFER
	MOVEI	1,XMTOD1	;GET A MASK
	XORB	1,RTSTAT	;AND COMPLEMENT THE BIT
	AOS	VDHFLG		;REQUEST FILLING THIS BUFFER
OPRLS1:	TRNE	3,XMTOD0	;ON CHAN 0?
	JRST OPRLS2		;NO
	TLNE	1,MOVNG0	;IS THIS BUFFER BUSY?
	JRST OPRLS2		;YES, DONT TOUCH IT!
	TRNN	1,SENT0		;IS IT A SPURIOUS ACK?
	JRST OPRLS3		;YES, CRASH THE BUM
	HLLZS	OPCNT		;YES, RELEASE BY CLEARING WD CNT
	MOVEI	1,SENT0+LAST0	;CLEAR STATUS BITS
	ANDCAM	1,RTSTAT	;ON THIS BUFFER
	MOVEI 	1,XMTOD0	;A MASK
	XORB	1,RTSTAT	;TO COMPLEMENT THE ODD/EVEN BIT
	AOS	VDHFLG		;REQUEST FILL SERVICE
OPRLS2:	SKIPE	VDHFLG		;ANYTHING NEW?
	ISB	SCDCHN		;YES, CALL SCEDULER
	SETZM	VDHFLG		;CANCEL FLAG
	JRST (4)


OPRLS3:	BUG(NTE,<OPRLSE-SPURIOUS ACKNOWLEDGEMENT CRASH LINE>)
	SETOM	KILLIT		;ASK IMPCHK TO KILL THE LINE
	SETZM	IMPTM2		;AND HURRY UP THE IMPCHK CALL
	JRST (4)


>	;END OF VDH IFDEF
>	;END OF IMPCHN IFDEF
	END
