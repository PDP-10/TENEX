;<133-TENEX>JSYS.MAC;10    20-APR-75 15:14:46    EDIT BY LYNCH
; FIXED BUG IN ATGRP JSYS
;<133-TENEX>JSYS.MAC;9     6-FEB-75 17:36:36    EDIT BY LYNCH
;  CHANGED CHFDB CRITERIA  TO ALLOW OWNER TO  ALTER WRITE DATEEOF FILE.
;<133-TENEX>JSYS.MAC;8     6-FEB-75 11:25:55    EDIT BY UNTULIS
;ADD CHKTTY INTERN FOR BATCH
;<133-TENEX>JSYS.MAC;7     8-JAN-75 13:40:04    EDIT BY LYNCH
;<133-TENEX>JSYS.MAC;6     8-JAN-75 10:13:58    EDIT BY LYNCH
; FIX BUGGY SACTF PATCH.
;<133-TENEX>JSYS.MAC;5     7-JAN-75 21:17:14    EDIT BY LYNCH
; FIXED ETERNAL BUG IN SACTF WITH STRING ACCOUNTS.
;<133-TENEX>JSYS.MAC;4     7-JAN-75 14:13:41    EDIT BY LYNCH
; FIX BUG IN STRING ACCOUNT INSERTION IMPLEMENTATION.
;<133-TENEX>JSYS.MAC;3     5-JAN-75 17:57:37    EDIT BY LYNCH
; PUT IN TWO KLUDGES FOR DIREXL BOR OUR BSYS.  DISAPPEARS WHEN PLUMMER GETS NEW BSYS FOR US.
;<133-TENEX>JSYS.MAC;2     5-JAN-75 17:06:22    EDIT BY LYNCH
;<133-TENEX>JSYS.MAC;241     2-JAN-75 11:15:17    EDIT BY CALVIN
; Changed check for non-exsistant job in GACTJ
;<133-TENEX>JSYS.MAC;240    31-DEC-74 10:13:51    EDIT BY TOMLINSON
; ACCIN5 => ACTIN5 (TYPO)
;<133-TENEX>JSYS.MAC;239    30-DEC-74 11:20:55    EDIT BY CALVIN
; Changes to ACTINI, so disk reload startup works
;<133-TENEX>JSYS.MAC;238    29-DEC-74 20:26:39    EDIT BY CLEMENTS
; MOVE STAD MINIMUM DATE UP TO TODAY FOR DISTRIBUTION
;<133-TENEX>JSYS.MAC;237    20-DEC-74 10:57:26    EDIT BY PLUMMER
; REPAIR JOBNO RANGE CHECK AND JOBRT TEST IN GPSGN
;<133-TENEX>JSYS.MAC;236    19-DEC-74 13:14:42    EDIT BY ALLEN
; CHANGE WAY GPSGN LCHECKS FOR NON-EXISTANT JOBS
;<133-TENEX>JSYS.MAC;235    18-DEC-74 13:04:48    EDIT BY CALVIN
; Bug fixes to CACCT, GDACC & VACCT
;<133-TENEX>JSYS.MAC;234    17-DEC-74 16:04:38    EDIT BY CALVIN
; Patch to GACTJ for numeric accounts
;<133-TENEX>JSYS.MAC;232    16-DEC-74 23:20:46    EDIT BY CALVIN
; MORE CHANGES TO ACCOUNT STUFF
;<133-TENEX>JSYS.MAC;231    16-DEC-74 19:19:20    EDIT BY CALVIN
; Changes to GACTJ & GDACC, some fixes to HASH
;<133-TENEX>JSYS.MAC;228    13-DEC-74 23:45:47    EDIT BY CALVIN
; Lots of bug fixes to verify stuff
;<133-TENEX>JSYS.MAC;227    12-DEC-74 14:06:29    EDIT BY CALVIN
; Bug fixes to .LOGIN, .GACTJ & ACTINI
;<133-TENEX>JSYS.MAC;226    11-DEC-74 21:43:42    EDIT BY CLEMENTS
; FIX TO LOGIN/ATGRP
;<133-TENEX>JSYS.MAC;225    10-DEC-74 14:55:25    EDIT BY CALVIN
;  New locking scheme for accounting JSYS's
;<CALVIN>JSYS.MAC;30     9-DEC-74 18:37:28    EDIT BY CALVIN
; Merged my copy of JSYS.MAC into <133-TENEX>'s
;<133-TENEX>JSYS.MAC;223     8-DEC-74 18:27:08    EDIT BY CLEMENTS
;LET CRJOB SNEAK THRU LOGIN WITHOUT PASSWORD
;<133-TENEX>JSYS.MAC;222    11-NOV-74 14:30:23    EDIT BY BTHOMAS
; FIX ACCESS CONTROL IN RELDD FOR CONTROLLING TTY
;<133-TENEX>JSYS.MAC;221     4-NOV-74 12:56:08    EDIT BY CALVIN
;<133-TENEX>JSYS.MAC;220     6-OCT-74 10:30:04    EDIT BY TOMLINSON
; Correction o DELDF patch
;<133-TENEX>JSYS.MAC;219     5-OCT-74 10:19:56    EDIT BY TOMLINSON
; FIX TEST OF WRONG HALF WORD AT DELTS2+4
;<133-TENEX>JSYS.MAC;218     3-OCT-74 15:28:38    EDIT BY CLEMENTS
; FIX DEVST JSYS FOR DEVICE WITH 6 CHAR NAME
;<133-TENEX>JSYS.MAC;217    26-SEP-74 23:02:49    EDIT BY ALLEN
; GRPLOK NON RESIDENT AGAIN. UNDO PREVIOUS EDIT. FIX BUG IN GRPLUK WHEN
; CALLED WITH ZERO ARG.
;<133-TENEX>JSYS.MAC;216    26-SEP-74 23:00:06    EDIT BY ALLEN
;<133-TENEX>JSYS.MAC;215    25-SEP-74 15:12:05    EDIT BY ALLEN
;<133-TENEX>JSYS.MAC;214    25-SEP-74 14:07:06    EDIT BY ALLEN
;<133-TENEX>JSYS.MAC;213    25-SEP-74 13:27:20    EDIT BY TOMLINSON
; RNAMF: UNLOCK INDEXABLE FH
; DELDF: COMPUTE DEFAULT FLAGS CORRECTLY
;<133-TENEX>JSYS.MAC;212    25-SEP-74 13:08:53    EDIT BY ALLEN
; GRPLOK NOWRESIDENT SO CALL LCKTST ON FAILURE TO LOCK
;<133-TENEX>JSYS.MAC;211    20-SEP-74 21:45:02    EDIT BY ALLEN
;<133-TENEX>JSYS.MAC;210    20-SEP-74 21:16:25    EDIT BY ALLEN
;<133-TENEX>JSYS.MAC;205    17-SEP-74 00:30:37    EDIT BY ALLEN
; MORE DETAIL FIXES FOR BRINGING UP VIRGIN SYSTEM
;<133-TENEX>JSYS.MAC;204    15-SEP-74 21:32:59    EDIT BY ALLEN
; CORRECTIONS FOR STARTING PIE-SLICE SYSTEM AT SYSLOD
;<133-TENEX>JSYS.MAC;203     6-SEP-74 13:32:08    EDIT BY ALLEN
; CALL LCKTST ON FAILURE TO LOCK DEVLCK
;<133-TENEX>JSYS.MAC;202    22-AUG-74 16:44:47    EDIT BY CLEMENTS
; ADD 1B15 FLAG TO CRDIR MEANING DON'T MAKE A MESSAGE.TXT FILE.
; ALSO NEVER MAKE A MESSAGE.TXT FILE IF CRDIR IS FOR EXISTING NAME.
;<133-TENEX>JSYS.MAC;201    24-JUL-74 15:59:16    EDIT BY CLEMENTS
; FIX JFNS TO QUOTE (^V) LOWER CASE S.
;<TENEX-132>JSYS.MAC;200    24-JUN-74 08:43:20    EDIT BY CLEMENTS
; FIX CRDIR TO NON-SKIP, NOT ITRAP

	SEARCH	FILEDEF,STENEX,PROLOG
	TITLE	JSYS
	SUBTTL	R.S.Tomlinson

EXTERN	STRDTB
EXTERN	PFILPC,ZERO,MINUS1
EXTERN	PBYTSZ,PBYTPO
EXTERN	NDEV,DRWAIT
IFDEF NETN,<EXTERN NVTDET,NTSIBE,NETDTB,NETNAM>
EXTERN	CTRLTT,EDISMS
EXTERN	ACCCHK,CPYDIR,DIRCHK,DIRLUK,DIRLUU,GDIRST,GETDDB,GETFDB,HSHLUK
EXTERN	DEVCHR,DEVDSP,DEVLCK,DEVLUK,DEVNAM,DEVUNT
EXTERN	INIBLK,INSACT,MAPDIR,MDDNAM,SETDIR,SETMSK,USTDIR
EXTERN	ASGDFR,ASGJFR,ASGPAG,GCDIR,RELDFR,RELFRE,RELPAG
EXTERN	CPYFU1,CPYFUS,CPYTUS,RESAC,SAVAC,XPAND
EXTERN	DOINT,BOUTN,BYTOUA,CCSIZE,CHKJFN,CPOPJ,CPTAB,DBP,DIRIC,DISGET
EXTERN	DSKDTB,TTYDTB,DTASTS,JFNOFN,JFNOF1,OFNJFN,OFNJFX
IFDEF DTAN,<EXTERN DTADTB>
IFDEF LPTN,<EXTERN LPTDTB>
EXTERN	NEWWND,NOUTX,RELJFN,SKPRET,BHC,UNLCKF,JOBPT
EXTERN	MAXLOK,LOKPGS
EXTERN	FORKX,SETLF1,TTFRKP,MAPINF,RLJBFK,SUPERP,SKIIF
EXTERN	FFORK1,RFORK1
EXTERN GRPNM,FKJOB
EXTERN ACCIFG

	USE	SWAPPC

WHEEL==:400000
OPR==:200000
LOG==:040000

EXTERN	NXTDMP	; Zero to dump open files
EXTERN	MAPFKH	; Maps over a fork handle
EXTERN	SKIIFA	; Skips if fork(a) < fork(b)
EXTERN	ACCTPT	; Login account string pointer or number
EXTERN	ACCTSR	; Account string storage
EXTERN	LOGONM	; Dlm's logon message typer
EXTERN	LOGCJM	; Type change job number on logtty
EXTERN	LGCJM0	; Log in EFACT file, but not on LOGTTY
EXTERN	JOBRT	; Job runtime table
EXTERN	CONSTO	; Console time on word
EXTERN	MJRSTF	; Thing to execute to leave fast jsys code


LS(FACTSW)	; Fact switches

JS(ACCTSL)
	NGS ACTONF			; FLAG TO DO JSYS ACCT CHK
	NGS ACTLCK			; LOCK FOR JSYS'S
	NGS ACTLC2			; FOR LOCKING OUT UPDATES
	NGS MATORA			; ORIGIN OF MATRIX
	NGS MATBSA			; SIZE OF BYTES IN MATRIX
	NGS UHASHO			; ORIGIN OF USER TABLE
	NGS UHASHL			; LENGTH OF USER TABLE
	NGS AHASHO			; ORIGIN OF ACCOUNT TBL
	NGS AHASHL			; LENGTH OF SAME
	NGS DEFO			; ORIGIN OF DEFAULT ACCOUNTS
	NGS PRIO			; ORG OF PIE GROUP NAMES


	DEFINE	DS(X)
	<X=FH
	FH==FH+1>

	FH==0

	DS	LOCAL
	DS	MATORG
	DS	MATBSZ
	DS	RHASHO
	DS	RHASHL
	DS	CHASHO
	DS	CHASHL
	DS	DTABO
	DS	PTABO
	DS	FFREE
	DS	NFREE




EXTERN	JOBDIR
EXTERN	FKDIR
EXTERN	FKGRPS	; Groups to which user of fork group belongs
EXTERN	TODCLK	; Time since system start in msec
EXTERN	SKIIF	; Skip if forkn in a is inferior or equal to self
JS(MODES)	; Ddbmod word from login
JS(PASFCT)		; Password failure counter
EXTERN	TTBKPT	; Routine to backup tty pointer one character
EXTERN	JOBPMF	; Jfn of pmf
EXTERN	MRPT	; Read page table
EXTERN	SETPT	; Map manipulator routine
EXTERN	MSPACS	; Set access of a page
EXTERN	FKHPTN	; Converts fork handle to ptn
EXTERN	PTNFKH	; Converts ptn to fork handle
EXTERN	SETLFK,DELOFN
EXTERN	TTCIBF,TTCOBF,TTSIBE,TTDIBE,TTSOBE,TTSOBF,TTDOBE,TTGTBS,TTSTBS
EXTERN	TTRMOD,TTSMOD,TTRPOS,TTSPOS,TTRCOC,TTSCOC,TTSTI,TTILIN,TTSOBF
EXTERN	SYSIFG,LOGBUF,.LGOUT	; Logging stuff
EXTERN	SYSFK	; Table of job forks
EXTERN	NORMTF,TTICB1,TTICB2,TAB81,TAB82	; Tty modes

; Entries to this section

INTERN	CHKTTY		;***SRI-AIC***
INTERN	BOUTA,NOUTXX,CHKTTM,JFNDCR
INTERN	.GDSTS,.SDSTS
INTERN	.OPENF,.CLOSF,.RLJFN,.GTSTS,.STSTS,.DELF,.SFPTR,.RFPTR
INTERN	.DELNF,.DELDF,.CLZFF,.RESET
INTERN	.JFNS,.RNAMF,.SIZEF,.GACTF,.SACTF,.BKJFN,.RFBSZ,.SFBSZ,.SWJFN
INTERN	.STDIR,.DIRST,.PMAP,.RPACS,.SPACS,.RMAP,.FFFFP,.FFUFP,.FDFRE
INTERN	.GTFDB,.CHFDB
INTERN	.ASND,.RELD
INTERN	.DVCHR,.STDEV,.DEVST,.MOUNT,.DSMNT
INTERN	.INIDR,.RDDIR,.MTOPR,.CRDIR,.GTDIR
INTERN	.CFIBF,.CFOBF,.SIBE,.SOBE,.DIBE,.DOBE,.GTABS,.STABS
INTERN	.RFPOS,.SFPOS,.RFCOC,.SFCOC,.STI,.SOBF
INTERN	.RFMOD,.SFMOD,.ERSTR,.GETER,.STAD,.GTAD
INTERN	.LOGIN,.CNDIR,.CACCT,.EFACT,.SMON,.TMON
INTERN	DELDEL,PASSWC
INTERN .CGRP,.VACCT,.GDACC,.ATGRP,.GACTJ,.GPSGN,ACTINI,ACTIN1

; Error macro definitions

DEFINE	ERUNLK(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERUNLD]>

DEFINE	ERR(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERRD]>

DEFINE	ERABRT(ERRORN,EXTRA)<
JRST [	EXTRA
	IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
	JRST ERABRD]>

ERUNLD::PUSH P,A
	MOVEM A,LSTERR
	PUSHJ P,UNLCKF
	XCTMU [POP P,1]
	JRST MRETN

ERRD::	UMOVEM A,1
	MOVEM A,LSTERR
	JRST MRETN

ERABRD:	MOVEM A,LSTERR
	JRST ITRAP

; Open a file
; Call:	1	; Job file number
;	2(0-5)	; Byte size
;	2(6-9)	; Data mode
;	RH(2)	; Access flags (see jsys manual or filsts description)
;	OPENF
; Return
;	+1	; Cannot open file, error code in 1
;	+2	; Successful

.OPENF::JSYS MENTR		; Become slow, save ac's
	MOVE JFN,1		; Get jfn
	PUSHJ P,CHKJFN		; What kind of designator is this?
	 ERR()			; Garbage designator
	 JFCL
	 JRST OPENFZ		; Tty and byte pointer etc. are good
	TEST(NE,OPNF)
	ERUNLK OPNX1		; Already open
	TEST(NE,ASTF)
	 ERUNLK(DESX7)		; Output stars not allowed
	UMOVE B,2
		; Get access bits
	LDB A,[POINT 6,B,5]	; Get byte size
	CAILE A,^D36
	ERUNLK SFBSX2
	DPB A,PBYTSZ		; Store as byte size of pointer
	MOVNI A,NDEV		; Movsi a,-ndev the hard way...
	HRLZS A
	HRRZ B,DEVDSP(A)
	CAIE B,0(DEV)
	 AOBJN A,.-2
	MOVE C,DEVCHR(A)
	UMOVE B,2
	LDB A,[POINT 4,B,9]
	MOVN D,A
	ROT C,-1(D)
	JUMPGE C,[ERUNLK(OPNX14)]	; Illegal mode
	HRRM A,FILSTS(JFN)
	HRR STS,A
	ANDCM STS,[XWD READF!WRTF!XCTF!RNDF!ASPF!CALLF!LONGF!EOFF!ERRF!HLTF!WNDF!ENDF!SIZF,777760]
	ANDI B,774000		; Ignore bits user cant set
	TRZE B,400000		; Bit 18 = 1?
	TRO B,HLTF		; Yes, move it down to hltf
	TLO STS,(B)		; Put user's bits into sts
	UMOVE B,2
	ANDI B,17B28
	IORI STS,(B)

OPNFOK:	SETZM FILCNT(JFN)
	PUSHJ P,@OPEND(DEV)	; Call the device dependent routine
	 JRST OPENR		; Cannot open
	TEST(O,OPNF)		; Success
	MOVSI B,1
	HLLM B,FILLFW(JFN)
OPENFZ:	AOS (P)
	PUSHJ P,UNLCKF
	JRST MRETN

OPENR:	CAIE A,OPNX9
	ERUNLK()
	HRRZ B,DEV
IFDEF LPTN,<	CAIN B,LPTDTB
	TRO STS,1B26>
	TRNN STS,1B28
	TRNN STS,1B26
	ERUNLK()
	PUSHJ P,UNLCKF
	SETZM INTDF
	XCT INTDFF
	MOVEI A,"["
	PBOUT
	MOVEI A,101
	UMOVE B,1
	MOVEI C,0
	JFNS
	HRROI A,[ASCIZ / Busy-/]
	PSOUT
OPENR1:	MOVEI A,^D3000
	DISMS
	UMOVE A,A
	UMOVE 2,2
	TRO B,1B28
	JSYS 21
	JRST OPENR1
	UMOVEM 1,1
	HRROI 1,[ASCIZ /Go]
/]
	PSOUT
	JRST SKMRTN

; Close a file
; Call:	RH(1)	; Jfn
;	1(0)	; If 1 do not release jfn
;	CLOSF
; Returns
;	+1	; Cannot close
;	+2	; Ok

.CLOSF::JSYS MENTR
	CAMN 1,MINUS1		; -1 means all
	JRST CLZALL
	HRRZ JFN,1
	PUSHJ P,CLZF
	 ERR()			; Can't close, reason in a
	XCTUU [SKIPL 1]		; Don't release jfn
	TEST(NE,OPNF)		; Or still open?
	JRST SKMRTN		; Yes. all done.
	PUSHJ P,RELJFN		; No, release jfn.
	JRST SKMRTN

CLZALL:	MOVE A,[1B2+400000]
	CLZFF
	JRST SKMRTN

CLZF::	MOVEI A,CLSX2
	HRRZ B,PRIMRY
	CAME JFN,JOBPMF
	CAMN JFN,B
	POPJ P,
	HLRZ B,PRIMRY
	CAME JFN,B
	PUSHJ P,CHKJFN
	 POPJ P,		; Garbage
	 JFCL
	 JRST SKPRET		; Byte and tty always succeeds
	TEST(NN,OPNF)
	JRST [	MOVEI A,CLSX1
		JRST UNLCKF]
	CAIL JFN,RJFN
	 JRST CLZF2		; SPECIAL DESIGNATOR
	MOVSI B,1
	ANDCAB B,FILLFW(JFN)
	TLNE B,777777
	JRST CLZF2
	PUSHJ P,@CLOSD(DEV)	; Call device dependent stuff
	 JRST UNLCKF
	TEST(Z,OPNF)
CLZF2:	AOS (P)
	JRST UNLCKF

; Release jfn
; Call:	1	; Jfn
;	RLJFN
; Returns
;	+1	; Error
;	+2	; Success
; Cannot release jfn if being assigned unless this same process as
; Assigner, and not at interrupt level

.RLJFN::JSYS MENTR
	CAMN 1,MINUS1		; Release all
	JRST RLALL
	HRRZ JFN,1
	PUSHJ P,RLJF
	 ERR()
	JRST SKMRTN

RLALL:	MOVE A,[1B3+400000]	; DON'T CLOSE/THIS FORK
	CLZFF
	JRST SKMRTN

RLJF:	PUSH P,JFN
	HRRZS JFN
	PUSHJ P,CHKJFN
	 JRST RLJF1		; Garbage jfn
	 JFCL
	 JRST [	MOVEI A,DESX4	; Tty or byte illegal
		JRST RLJF3]
	TEST(NE,OPNF)
	JRST [	MOVEI A,OPNX1	; File is open
		JRST RLJF4]
RLJF2:	PUSHJ P,RELJFN		; Finally we can release it
	AOSA -1(P)
RLJF4:	PUSHJ P,UNLCKF
RLJF3:	POP P,JFN
	POPJ P,

RLJF1:	CAIE A,DESX3		; Is no name attached to this jfn?
	JRST RLJF3		; Some other error
	HLRZ B,FILVER(JFN)	; Get fork number of originator
	PUSH P,A
	HRRZ A,SYSFK(B)		; Fork still exists?
	CAIN A,-1
	JRST [	POP P,A
		JRST RLJF2 ]	; No, ok to release
	POP P,A
	CAME B,FORKN		; Is it me?
	JRST RLJF3		; No
	SKIPE PSIBIP		; Test if pi in progress
	JRST RLJF3		; Yes
	JRST RLJF2		; No pi in progress, ok to release

; Close files given fork handle
; Call:	RH(1)	; Fork handle
;	B0(1)	; Not below the fork(s) specified
;	B1(1)	; Not at the fork(s) specified
;	B2(1)	; Close only (no release)
;	B3(1)	; Release only (no close)
;	B4(1)	; Unrestrict file
;	B5(1)	; Close regardless of map count
;	CLZFF
; Return
;	+1	; Always
; Traps if fork handle is bad

.CLZFF::JSYS MENTR
	HRRZS A
	PUSHJ P,MAPFKH		; Call routine to map over the fork hdl
	PUSHJ P,CLZFF1		; Call this for each fork
	JRST MRETN

CLZFF1:	MOVN JFN,MAXJFN
	HRLZS JFN
CLZFF2:	HLRZ B,PRIMRY
	CAIN B,(JFN)
	JRST CLZFF3		; Don't affect primary files
	HRRZ B,PRIMRY
	CAIN B,(JFN)
	JRST CLZFF3
	MOVE B,JOBPMF
	CAIN B,(JFN)
	JRST CLZFF3		; Or pmf
	PUSH P,JFN
	PUSH P,1
	HRRZS 1,JFN
	LSH 1,SJFN
	SKIPL FILLCK(1)
	 JRST CLZFF4
	PUSHJ P,CHKJFN		; See if this jfn is in use
	 JRST CLZFF8		; No name check for asgf
	 JRST CLZFF4		; Should not happen
	 JRST CLZFF4
	MOVSI B,777777
	TEST(NE,OPNF)		; If file is open
	TDNE B,FILLFW(JFN)	; And map count is zero
	SKIPA
	 JRST CLZFF5		; Then it's ok to close it
	HLRZ B,FILVER(JFN)
	MOVE A,(P)
	CAMN B,A		; Was this jfn created by this fork
	JRST [	UMOVE C,1
		TLNE C,(1B1)	; Are we to close files at the fork?
		JRST CLZFF7	; No, skip this jfn
		JRST CLZFF5]	; Yes, do it
	EXCH A,B
	PUSHJ P,SKIIFA		; Skip if fork(a) < fork(b)
	JRST CLZFF7

CLZFF5:	UMOVE C,1
	TLNE C,(1B4)		; Un restrict this file?
	TEST(Z,FRKF)		; Yes
	TEST(NE,OPNF)
	TLNE C,(1B3)
	JRST CLZFF6
	MOVSI B,1
	ANDCAB B,FILLFW(JFN)
	TLNN C,(1B5)
	TLNN B,777777
CLZFFC:	PUSHJ P,@CLOSD(DEV)
	 JRST CLZFF7
	TEST(Z,OPNF)
CLZFF6:	UMOVE C,1
	TEST(NN,OPNF)
	TLNE C,(1B2)
	JRST CLZFF7
CLZFF9:	PUSHJ P,RELJFN
	JRST CLZFF4

CLZFF7:	CAIN A,IOX5		; IO error?
	 JRST [	TEST(Z,ERRF)	; IGNORE ERROR
		JRST CLZFFC]
	PUSHJ P,UNLCKF
CLZFF4:	POP P,1
	POP P,JFN
CLZFF3:	AOBJN JFN,CLZFF2
	POPJ P,

CLZFF8:	CAIE A,DESX3
	JRST CLZFF4		; ??
	HLRZ B,FILVER(JFN)
	PUSH P,A
	HRRZ A,SYSFK(B)
	CAIN A,-1		; Fork still exists?
	JRST [	POP P,A
		JRST CLZFF9 ]	; No
	POP P,A
	CAME B,FORKN
	JRST CLZFF4
	SKIPE PSIBIP
	JRST CLZFF4
	JRST CLZFF9

; Reset jsys
; Call:	RESET
; Closes all files, resets tty status etc

.RESET::JSYS MENTR
	MOVNI A,4
	KFORK			; Kill all inferior forks
	SKIPGE CTRLTT
	 JRST RSTFK		; Skip tty reset if not ctrltt
	MOVEI A,101
	MOVE B,NORMTF		; Normal modes
	SFMOD
	MOVE B,JOBNO		; GET THE CONTROLLING TTY OF THIS JOB
	HLRE B,JOBPT(B)		; ..
	JUMPL B,RSTFK		; IN CASE JUST DETACHED
	LDB D,TTYFFC##		; GET FORMFEED BITS OF TOP FORK
	MOVE B,TTICB1
	MOVE C,TTICB2		; Normal cc modes
	SKIPE FORKN		; AND UNLESS THIS IS TOP FORK,
	DPB D,[POINT 2,B,25]	; SET FF BITS IN THIS FORK
	SFCOC
	MOVE B,TAB81		; 8 chars/tab
	MOVE C,TAB82
	MOVE D,B
	STABS
RSTFK:	MOVEI A,400000
	CIS
	DIR
	MOVEI 2,0
	STIW
	MOVNI 2,1
	DIC
	MOVEI 1,400000
	CLZFF
	RWSET			;RELEASE WORKING SET
	SETZB 2,3
	SCVEC
	SETOM JTLCK		; Clear JSYS trap lock
	SETZM JTTRW		; Clear trap word
	MOVSI 1,77		; Clear JSYS trap PSI channel
	HLLM 1,JTMNW		; And JTMNOF flag
	JRST MRETN

; Get open file status
; Call:	1	; Jfn
;	GTSTS
; Return
;	+1
;	1	; Status word as in filsts

.GTSTS::NOINT
	JUMPL 1,GTST1
	CAML 1,MAXJFN
	 JRST GTST1
	LSH 1,SJFN
	AOSE FILLCK(1)
	JRST GTST2
	EXCH 2,FILSTS(1)
	TLNN 2,NAMEF
	JRST [	MOVEM 2,FILSTS(1)
		SETZ 2,
		JRST GTST0]
	MOVEM 2,FILSTS(1)
GTST0:	SETOM FILLCK(1)
	LSH 1,-SJFN
	OKINT
	XCT MJRSTF

GTST2:	LSH 1,-SJFN
GTST1:	OKINT
	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST GTSTS1		; Illegal, return 0
	 JRST GTSTS2		; Illegal, return 0
	 JRST GTSTS2		; Illegal, return 0
	PUSHJ P,UNLCKF
	UMOVEM STS,2
	JRST MRETN

GTSTS2:	PUSHJ P,UNLCKF
GTSTS1:	XCTUU [SETZM 2]
	JRST MRETN

; Set status
; Call:	1	; Jfn
;	2	; New status
;	STSTS
; Returns
;	+1	; Erro2
;	+2	; Ok (only errf, hltf, and frkf can be changed)

.STSTS::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()			; Bad jfn
	 JFCL
	 ERR(DESX4)		; Tty and byte bad
	UMOVE A,2		; Get new status
	ANDCA A,[XWD ERRF!HLTF!FRKF,0]
	TDZ STS,A
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Get device status
; Call:	1	; Jfn
;	GDSTS
; Returns
;	+1	; Error
;	+2	; Ok

.GDSTS::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	MOVE A,STS
	ANDI A,17
	PUSHJ P,@GDSTD(DEV)
	UMOVEM A,2
	JRST UNL

; Set device status
; Call:	1	; Jfn
;	SDSTS
; Returns
;	+1	; Always unless traps

.SDSTS::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	UMOVE A,2
	TEST(NE,OPNF)
	PUSHJ P,@SDSTD(DEV)
	JRST UNL

; Delete file
; Call:	1	; Jfn
;	DELF
; Return
;	+1	; Error, cannot delete
;	+2	; Success

.DELF::	JSYS MENTR		; Become slow
	HRRZ JFN,1
	PUSHJ P,CHKJFN		; Check it out
	 JRST GBGJFN
	 JFCL
	 ERUNLK DESX4		; Tty or byte illegal
	TEST(NE,ASTF)
	 ERUNLK(DESX7)		; Output stars not allowed
	PUSHJ P,@DELD(DEV)	; Call device dependent routine
	 ERUNLK()		; Couldn't delete
	UMOVE A,1
	TLNE A,777777
	JRST DELF1
	TEST(NN,OPNF)
	JRST [	PUSHJ P,RELJFN
		JRST SKMRTN]
DELF1:	PUSHJ P,UNLCKF
	JRST SKMRTN

; Rename file
; Call:	1	; Jfn 1
;	2	; Jfn 2
;	RNAMF
; Return
;	+1	; Error
;	+2	; Ok

.RNAMF::JSYS MENTR
	CAMN 1,2
	JRST SKMRTN
	HRRZ JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)		; Cannot rename tty or byte
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	TEST(NE,OPNF)
	ERUNLK(OPNX1)		; File must not be open
	PUSH P,JFN
	PUSH P,DEV
	UMOVE JFN,2
	HRRZS JFN
	PUSHJ P,CHKJFN		; Check the second jfn
	 ERUNLK(,<POP P,DEV
		POP P,JFN>)
	JFCL
	 ERUNLK(DESX4,<POP P,DEV
		POP P,JFN>)
	TEST(NE,ASTF)
	ERUNLK(DESX7,<PUSHJ P,UNLCKF
		POP P,DEV
		POP P,JFN>)
	TEST(NE,OPNF)
	ERUNLK(OPNX1,<PUSHJ P,UNLCKF
		POP P,DEV
		POP P,JFN>)
	POP P,A
	CAME A,DEV		; Can only rename on the same device
	ERUNLK(RNAMX1,<PUSHJ P,UNLCKF
		POP P,JFN>)
	MOVE A,(P)
	PUSH P,JFN
	PUSHJ P,@REND(DEV)
	 ERUNLK(,<POP P,JFN
		PUSHJ P,UNLCKF
		POP P,JFN>)
	POP P,JFN
	PUSHJ P,UNLCKF
	POP P,JFN
	UMOVE 1,1		; SOURCE DESIGNATOR
	TLNE 1,-1		; DON'T RELEASE IF INDEXABLE FH
	 JRST [	CALL UNLCKF	; JUST UNLOCK IT
		JRST SKMRTN]	; AND RETURN SUCCESS
	PUSHJ P,RELJFN
	JRST SKMRTN

; Convert jfn to string
; Call:	1	; Jfn
;	2	; String pointer
;	3	; Format specification (see jsys manual)

.JFNS::	JSYS MENTR
	HRRZ JFN,2
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	PUSHJ P,UNLCKF
	UMOVE A,1
	TLNN A,777777
	 JRST JFNSZ		; Not byte pointer
	TLC A,777777
	TLCN A,777777
	 HRLI A,440700		; -1 in lh, fill in
	SETZ B,
	XCTBU [IDPB B,A]	; Deposit initial null in case
JFNSZ:	XCTUM [HLLZ F1,2]
	XCTUU [SKIPN E,3]
	MOVE E,[BYTE (3)2,2,1,1,2,0,0(1)1(4)0(5)0,11]
	HLRZ A,FILDDN(JFN)	; Get pointer to device block
	MOVN B,(A)
	HRLI A,-2(B)
	PUSHJ P,DEVLUK
	MOVEI A,0
	TLNE A,(1B2)
	TROA E,100
	TRZ E,100
	TLNE A,(1B4)
	TROA E,200
	TRZ E,200
	HLRZ A,FILDDN(JFN)
	MOVE C,1(A)		; The first word of the device name
	ANDCMI C,377		; Get rid of low byte
	LDB D,[POINT 3,E,2]	; Get format control byte for device
	PUSHJ P,TAB4
	CAIN D,2		; If it is suppress system default
	CAME C,[ASCIZ /DSK/]	; And the device is dsk, then skip
	CAIN D,0		; Or if control is "no print"
	JRST JFNS0		; Don't print
	PUSHJ P,JFNSS		; Output the string in a
	MOVEI B,":"
	PUSHJ P,PUNCT
JFNS0:	HRRZ A,FILDDN(JFN)	; Get directory number
	LDB D,[POINT 3,E,5]	; And format control
	PUSHJ P,TAB4		; Tab before field if desired
	TEST(NE,DIRSF)
	JRST JFNS0A
	MOVE B,FORKX
	SKIPGE B,FKDIR(B)
	MOVE B,FKDIR(B)		; B=conn dir,,user dir
	HLRZS B
	CAIN D,2		; If suppressing default,
	CAME A,B		; And it is default

JFNS0A:	CAIN D,0		; Or if no print is wanted
	JRST JFNS1		; Then don't print
	MOVEI B,"<"
	PUSHJ P,PUNCT		; Print punctuation if desired
	TEST(NE,DIRSF)
	JRST [	PUSHJ P,JFSTAR
		JRST JFNS0B]
	HRRZ A,FILDDN(JFN)
	PUSHJ P,GDIRST		; Get string for this number
	BUG(HLT,<JFNS: GDIRST CANNOT FIND STRING FOR DIRECTORY.>)
	UNLOCK DIRLCK
	PUSHJ P,JFNSS		; Copy string to output
	OKINT
JFNS0B:	MOVEI B,">"
	PUSHJ P,PUNCT		; And output terminating punct

JFNS1:	HLRZ A,FILNEN(JFN)	; Get location of file name block
	LDB D,[POINT 3,E,8]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS2		; No print wanted
	TEST(NE,NAMSF)
	JRST [	PUSHJ P,JFSTAR
		JRST JFNS2]
	PUSHJ P,JFNSS		; Copy string to output
JFNS2:	HRRZ A,FILNEN(JFN)	; Get location of extension block
	LDB D,[POINT 3,E,11]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS3		; No print wanted
	MOVEI B,"."
	TRNE E,100
	PUSHJ P,PUNCT		; Output punctuation if desired
	TEST(NE,EXTSF)
	JRST [	PUSHJ P,JFSTAR
		JRST JFNS3]
	PUSHJ P,JFNSS		; Copy to output
JFNS3:	HRRZ A,FILVER(JFN)	; Get version number
	LDB D,[POINT 3,E,14]	; And output control
	PUSHJ P,TAB4		; Tab before field if required
	JUMPE D,JFNS4		; No print wanted
	TRNN E,200
	JRST JFNS4
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVE B,A
	MOVEI C,12
	TEST(NE,VERSF)
	JRST [	PUSHJ P,JFSTAR
		JRST MRETN]
	TEST(NE,RVERF)
	MOVNI B,0
	TEST(NE,HVERF)
	MOVNI B,1
	TEST(NE,LVERF)
	MOVNI B,2
	PUSHJ P,NOUTXX

JFNS4:	TEST(NE,ASTF)
	 JRST MRETN
	HRRZ A,NLUKD(DEV)
IFDEF NETN,<
	CAIN A,NETNAM
	 JRST JFNSNT>
	CAIN A,MDDNAM
	PUSHJ P,GETFDB		; Get a pointer to the fdb
	 JRST MRETN
	PUSH P,FDBREF(A)
	PUSH P,FDBWRT(A)
	PUSH P,FDBCRV(A)
	LDB B,PFILPC
	PUSH P,B
	PUSH P,FDBCTL(A)
	MOVE B,FDBACT(A)	; Get account
	SETZ C,			; 0 words of string
	TLNN B,-1		; String account?
	 JRST [	HRRZ C,DIRORG(B); Get length of string block
		SUBI C,2	; Skip header and share count
		HRL C,C		; To both halves
		MOVEI D,1(P)	; Where to put string on stack
		HRLI D,DIRORG+2(B); Where to get string from
		HRR B,P		; Point to just before string on stack
		ADD P,C		; Bump to beyond string
		JUMPGE P,MSTKOV
		BLT D,0(P)	; Blt onto stack
		JRST .+1]
	PUSH P,C		; Save size of string
	PUSH P,B		; And account or pointer
	PUSH P,DIRDPW
	PUSH P,FDBPRT(A)
	PUSHJ P,USTDIR		; Unlock directory (done with it)
	LDB D,[POINT 3,E,17]
	PUSHJ P,TAB4
	MOVE B,0(P)
	CAIN D,2
	CAME B,-1(P)
	CAIN D,0
	JRST JFNS5
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"P"
	PUSHJ P,PUNCT
	MOVE A,0(P)		; Get protection
	MOVEI C,10
	PUSHJ P,JFNSN

JFNS5:	SUB P,[XWD 2,2]		; Flush protection and def prot
	LDB D,[POINT 3,E,20]
	PUSHJ P,TAB4
	JUMPE D,JFNS6
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"A"
	PUSHJ P,PUNCT
	MOVE A,(P)		; Get account or pointer
	MOVEI C,^D10
	PUSHJ P,JFNSN

JFNS6:	SUB P,[XWD 1,1]		; Flush account or pointer
	POP P,C			; Get size of saved string
	SUB P,C			; Flush string from stack
	LDB D,[POINT 1,E,21]
	POP P,B
	TLNE B,FDBTMP
	CAIN D,0
	JRST JFNS7
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"T"
	PUSHJ P,BOUTA
JFNS7:	LDB D,[POINT 1,E,22]
	PUSHJ P,JFNCOM
	PUSHJ P,TAB4
	JUMPE D,JFNS8
	MOVE B,0(P)
	MOVEI C,^D10
	PUSHJ P,NOUTXX

JFNS8:	SUB P,[XWD 1,1]
	POP P,B
	TRNE E,1B23
	PUSHJ P,JFNDAT
	PUSHJ P,TAB4
	POP P,B
	TRNE E,1B24
	PUSHJ P,JFNDAT
	PUSHJ P,TAB4
	POP P,B
	TRNE E,1B25
	PUSHJ P,JFNDAT
	 JFCL
	JRST MRETN

IFDEF NETN,<
JFNSNT:	MOVE B,JOBNO
	ADDI B,^D100000
	HRRZ A,FILVER(JFN)
	CAME A,B
	 JRST MRETN
	MOVEI B,";"
	PUSHJ P,PUNCT
	MOVEI B,"T"
	PUSHJ P,PUNCT
	JRST MRETN>

JFNSN:	JUMPG A,JFNSS		; Copy to output
	MOVE B,A
	TLZ B,700000
NOUTXX:	PUSH P,JFN
	PUSH P,DEV
	PUSH P,STS
	PUSH P,F1
	PUSH P,E
	PUSH P,D
	PUSH P,F
	PUSH P,C
	PUSH P,B
	PUSHJ P,NOUTX
	 JFCL
	POP P,B
	POP P,C
	POP P,F
	POP P,D
	POP P,E
	POP P,F1
	POP P,STS
	POP P,DEV
	POP P,JFN
	POPJ P,
JFNDAT:	PUSH P,B
	MOVEI D,1
	PUSHJ P,JFNCOM
	PUSHJ P,TAB4
	POP P,B
	PUSH P,A
	SETZ C,
	HRROI A,1(P)
	ADD P,[XWD 4,4]
	ODTIM
	MOVEI C,-3(P)
	HRLI C,(<POINT 7,0>)
JFNDA1:	ILDB B,C
	JUMPE B,[SUB P,[XWD 4,4]
		POP P,A
		POPJ P,]
	PUSHJ P,BOUTN
	JRST JFNDA1

JFNCOM:	MOVEI B,","
	CAIE D,0
	TRNN E,10
	POPJ P,
	JRST BOUTA

JFSTAR:	MOVEI B,"*"
	JRST BOUTA

PUNCT:	TRNE E,1
	JRST BOUTA
	POPJ P,

TAB4:	MOVEI B,11
	TRNE E,2
	CAIG D,0
	TRNE E,4
	TRON E,40
	POPJ P,
BOUTA:	JRST BOUTN

JFNSS::	MOVE C,A
	HRLI C,(<POINT 7,0,35>)
JFNSS1:	ILDB B,C
	JUMPE B,CPOPJ
	PUSH P,C		; Prepare to compute char class
	PUSH P,B

;	IDIVI B,^D36/CCSIZE	; Ccsize and cptab and char type
	MOVEI B,^D36		; Have to do it the hard way cause
	IDIVI B,CCSIZE		; Macro can't divide externals
	MOVE C,B
	MOVE B,0(P)
	IDIV B,C		; And finally the real divide
	LDB B,CPTAB(B+1)	;  are found in gtjfn.fai
	JUMPE B,NTSPC		; 0 clas is normal alphas
	CAIE B,32		; CAPITAL "S" (NOT SPECIAL)?
	CAIN B,30		; Minus sign not special
	 JRST NTSPC		; NOT SPECIAL
	CAIL B,21		; Digits, CAPITAL T, P, OR A
	CAILE B,24
	 JRST [	MOVEI B,"V"-100	; Special char
		PUSHJ P,BOUTA	; Prefix with control-v
		JRST NTSPC]
NTSPC:	POP P,B
	POP P,C
	PUSHJ P,BOUTA
	JRST JFNSS1

; Get size of file
; Call:	1	; Jfn
;	SIZEF
; Return
;	+1	; Error, cannot get size of file
;	+2	; Success
;	1	; Size in bytes
;	2	; Size in pages

.SIZEF::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST GBGJFN
	 JFCL
	 ERUNLK DESX4
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	HRRZ B,DEV		; Get dispatch address
	MOVEI A,DESX8
	CAIE B,DSKDTB
	ERUNLK()
	PUSHJ P,GETFDB		; Get pointer to fdb
	 ERUNLK OPNX2
	LDB B,PFILPC		; Get number of pages
	MOVE A,FDBSIZ(A)	; And length
	UMOVEM A,2
	UMOVEM B,3
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST SKMRTN

GBGJFN:	UMOVEM A,1
	JRST MRETN

; Backup file pointer by 1 byte
; Call:	1	JFN
;	BKJFN
; Returns
;	+1	; Error, cannot backup this designator
;	+2	; Ok.

.BKJFN::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JRST BKJTTY
	 JRST BKJBYT
	HRRZ A,DEV
	CAIN A,TTYDTB		; Tty?
	JRST BKJTT1
	TEST(NN,OPNF)
	ERR(DESX5,<PUSHJ P,UNLCKF>)
	MOVE A,FILBYN(JFN)
	SOJL A,[ERR(SFPTX3,<PUSHJ P,UNLCKF>)]
	PUSHJ P,SFBNR
	 ERR(,<PUSHJ P,UNLCKF>)
	PUSHJ P,UNLCKF
	JRST SKMRTN

BKJTT1:	PUSHJ P,UNLCKF
BKJTTY:	HLRZ 2,DEV
	PUSHJ P,TTBKPT
	 ERR(BKJFX1)
	JRST SKMRTN

BKJBYT:	CAIE DEV,STRDTB
	 JRST SKMRTN
	MOVE A,JFN
	PUSHJ P,DBP
	UMOVEM A,1
SKMRTN::MOVE P,MPP
	AOS (P)
	JRST MRETN

; Read file byte number
; Call:	1	; Jfn
;	RFPTR
; Return
;	+1	; Error
; 	+2	; Success
;	2	; File byte number

.RFPTR::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)
	TEST(NN,OPNF)
	ERUNLK(DESX5)
	MOVE A,FILBYN(JFN)
	UMOVEM A,2
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Set file byte number
; Call:	1	; Job file number
;	2	; Byte number
;	SFPTR
; Return
;	+1	; Error
;	+2	; Successful

.SFPTR::JSYS MENTR		; Become slow etc.
	MOVE JFN,1
	PUSHJ P,CHKJFN		; Find out what we are dealing with
	 ERR()
	 JFCL
	 ERR(DESX4)		; Tty, byte pointer, etc. illegal
	TEST(NN,OPNF)
	ERUNLK(CLSX1)
	UMOVE A,2
	PUSHJ P,SFBNR		; Set the byte number
	 ERUNLK()
	AOS (P)			; Skip return
	PUSHJ P,UNLCKF
	JRST MRETN

; Set file byte number common code
; Call:	A	; Byte number
;	PUSHJ P,SFBNR
; Return
;	+1	; Error of some sort, error number in a
;	+2	; Success
; Clobbers most temps

SFBNR::	TEST(NN,RNDF)
	JRST [	MOVEI A,SFPTX2
		POPJ P,]	; Illegal to reset pointer for this file
	CAMN A,MINUS1
	MOVE A,FILLEN(JFN)	; Set to end of file if -1
	JUMPL A,[MOVEI A,SFPTX3
		POPJ P,]	; Illegal byte number
	MOVEM A,FILBYN(JFN)
	TEST(Z,EOFF)
	CAML A,FILLEN(JFN)
	TEST(O,EOFF)
	PUSHJ P,NEWWND		; Set window pointers
	AOS (P)
	POPJ P,

NFBSZ::	MOVEI C,^D36
	IDIVM C,A		; Number of bytes per word
	MOVEI C,^D36
	IDIV C,B		; New number of bytes per word
	PUSH P,C
	IMUL C,FILBYN(JFN)	; Adjust byte number
	IDIV C,A
	CAIE C+1,0
	AOS C
	MOVEM C,FILBYN(JFN)
	POP P,C
	IMUL C,FILLEN(JFN)	; And adjust file length
	IDIV C,A
	CAIE C+1,0
	AOS C
	MOVEM C,FILLEN(JFN)
	DPB B,PBYTSZ		; Deposit new byte size
	POPJ P,

; Read file byte size
; Call:	1	; Jfn
;	RFBSZ

.RFBSZ::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	TEST(NN,OPNF)
	ERABRT(DESX5)
	LDB A,PBYTSZ
	UMOVEM A,2
	PUSHJ P,UNLCKF
	JRST MRETN

; Set file byte size jsys
; Call:	1	; Job file number
;	2	; Byte size (1 to 36)
;	SFBSZ
; Return
;	+1	; Error number in a
;	+2	; Success

.SFBSZ::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)		; Tty, byte pointer, etc. illegal
	TEST(NN,OPNF)
	ERABRT(CLSX1,<PUSHJ P,UNLCKF>)
	XCTUU [SKIPLE B,2]
	CAILE B,^D36
	ERABRT(SFBSX2,<PUSHJ P,UNLCKF>)	; Illegal byte size
	TEST(NE,SIZF)
	ERABRT(SFBSX1,<PUSHJ P,UNLCKF>)	; Illegal to change byte size
	LDB A,PBYTSZ		; Get previous byte size
	PUSHJ P,NFBSZ
	PUSHJ P,NEWWND		; Recompute window pointers
	PUSHJ P,UNLCKF		; Unlock file
	JRST MRETN

; Swap jfn's
; Call:	1	; Jfn 1
;	2	; Jfn 2
;	SWJFN

.SWJFN::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST ERABRD
	 JFCL
	 ERABRT(DESX4)
	PUSH P,JFN
	UMOVE JFN,2
	PUSHJ P,CHKJFN
	 ERABRT(,<POP P,JFN
		MOVE DEV,FILDEV(JFN)
		PUSHJ P,UNLCKF>)
	 JFCL
	 ERABRT(DESX4,<POP P,JFN
		MOVE DEV,FILDEV(JFN)
		PUSHJ P,UNLCKF>)
	POP P,A

	MOVEI B,[FILBYT
		FILBYN
		FILLEN
		FILCNT
		FILWND
		FILSTS
		FILDEV
		FILOFN
		FILLFW
		FILDDN
		FILNEN
		FILVER]
	HRLI B,-^D12
	HRLI A,D
	HRLI JFN,D
SWJFNL:	MOVE D,(B)
	MOVE C,@JFN
	EXCH C,@A
	MOVEM C,@JFN
	AOBJN B,SWJFNL
	SETOM FILLCK(JFN)
	SETOM FILLCK(A)
	JRST MRETN

; Get fdb entry
; Call:	1	JFN
;	LH(2)	; Number of words to read
;	RH(2)	; First word to read
;	3	; Location to store words
;	GTJFN

.GTFDB::JSYS MENTR
	UMOVE A,2
	HLRZ B,A		; Get count
	HRRZS A			; Offset
	CAIL A,FDBLEN
	ERABRT(GFDBX1)		; Offset too big
	ADD A,B
	CAIE B,0		; 0 words illegal
	CAILE A,FDBLEN
	ERABRT(GFDBX2)		; Count too big
	UMOVE JFN,1
	PUSHJ P,CHKJFN		; Check the jfn
	 ERABRT()		; Garbage
	 JFCL
	 ERABRT(DESX4)		; Tty or byte illegal
	TEST(NE,ASTF)
	 ERABRT(DESX7)
	HRRZ A,NLUKD(DEV)	; Get name lookup dispatch
	CAIE A,MDDNAM		; Must be mddnam
	ERABRT(GFDBX1,<PUSHJ P,UNLCKF>)	; Cannot read fdb for device
	PUSHJ P,GETFDB		; Get pointer to the fdb
	 ERABRT(DESX3,<PUSHJ P,UNLCKF>)

	UMOVE B,2
	ADDI A,(B)		; Offset pointer to fd
	UMOVE C,3		; To address
	HRL C,A			; From address
	HLRZS B			; Count
	ADDI B,(C)		; Last address+1
	XCTMU [BLT C,-1(B)]
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST MRETN

; Change fdb
; Call:	LH(1)	; Offset
;	RH(1)	; Jfn
;	2	; Mask
;	3	; Data
;	CHFDB

.CHFDB::JSYS MENTR
	UMOVE A,1
	HRRZ JFN,A
	HLRZS A
	CAIL A,FDBLEN
	ERABRT(CFDBX1)		; Offset too big
	PUSHJ P,CHKJFN		; Check jfn
	 ERABRT()		; Garbage
	 JFCL
	 ERABRT(DESX4)		; Tty or byte illegal
	TEST(NE,ASTF)
	 ERABRT(DESX7)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERABRT(CFDBX1)		; No fdb fon non mdd devices
	PUSHJ P,GETFDB		; Get the fdb
	 ERABRT(DESX3,<PUSHJ P,UNLCKF>)
	XCTUU [HLRZ D,1]
	PUSH P,A		; Save fdb loc
	UMOVE B,2		; Mask
	ANDCM B,WRTR(D)		; Writer bits?
	JUMPN B,CHFDB1		; No, check owner and wheel
	HRLI A,100000		; Yes check for write access
	PUSHJ P,ACCCHK
	 JRST CHFDB3		; No write access, still ok if owner
	JRST CHFDB2		; Ok, go ahead

CHFDB1:	ANDCM B,OWNER(D)
	JUMPN B,CHFDB4		; Requires mor than owner status
CHFDB3:	MOVSI A,XCTF
	PUSHJ P,DIRCHK		; Check if we have owner rights
	 JRST CHFDB5
	JRST CHFDB2

CHFDB4:	ANDCM B,WOPR(D)
	JUMPN B,CHFDB6		; Can't be done
CHFDB5:	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST CHFDB2
CHFDB6:	MOVEI A,CFDBX2
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST ERABRD

CHFDB2:	POP P,A
	ADD A,D
	UMOVE C,3		; Data
	MOVE B,(A)		; Old data
	UMOVE D,2		; Mask
	AND C,D			; Retain masked bits of new data
	ANDCM B,D		; Flush bits to be replaced from old
	IOR B,C
	MOVEM B,(A)
	PUSHJ P,USTDIR
	PUSHJ P,UNLCKF
	JRST MRETN

; Access tables for chfdb

WRTR:	0
	0
	0
	0
	0
	0
	0
	0
	0
	007700000000
	777777777777
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0

OWNER:	0		; Header
	FDBTMP!FDBDEL!FDBNXF!FDBENV!FDBSUB!FDBUND!FDBEPH,,0
			; FDBCTL
	0		; Fdbext
	0		; Fdbadr
	000000,,777777	; Fdbprt
	0		; Fdbcre
	777777,,000000	; Fdbuse
	0		; Fdbver
	0		; Fdbact
	777700,,000000	; Fdbbyv (byte size and # backups)
	777777,,777777	; Fdbsiz
	0		; Fdbcrv
	777777,,777777		; Fdbwrt
	0		; Fdbref
	0		; Fdbcnt
	310000000000	; Backup (ALLOW ARCHIVE FLAGS - BSYS)
	0
	0
	0
	0
	777777777777	; Fdbusw

WOPR:	0		; Header
	FDBPRM,,0	; FDBCTL
	0
	0
	0
	777777777777	; Creation date
	0
	0
	0
	0
	0
	777777777777	; Fdbcrv
	777777777777	; Fdbwrt
	777777777777	; Fdbref
	777777777777	; Fdbcnt
	777777777777
	777777777777
	777777777777
	777777777777
	777777777777
	0

; String to directory
; Call:	1	; Positive for no recognition
;	2	; Source designato$
;	STDIR
; Return
;	+1	; No match
;	+2	; Ambiguous
;	+3	; Unique match

.STDIR::JSYS MENTR
;	UMOVE A,1		; NOT NECESSARY..BUT LOGICAL
	UMOVE B,3		; DEVICE DESIGNATOR IF ANY
	PUSHJ P,SETUNT
	 ERR()
	UMOVE A,2		; STRING POINTER
	PUSHJ P,CPYFUS
	 JRST MRETN
	PUSH P,A		; Save location of the temp block
	PUSH P,B		; Save string pointer to tail
;	MOVEI JFN,-FILOPT(P)	; Set jfn so filopt(jfn) refers to pdl
	MOVNI JFN,FILOPT	; Gotta do it the hard way
	ADD JFN,P
	HRRZS JFN
	XCTUU [SKIPL 1]
	TEST(OA,NREC)
	TEST(Z,NREC)
	PUSHJ P,DIRLUK
	SOS -2(P)		; Undo one skip
	JRST STDIR1
	XCTUU [EXCH A,1]	; Return the directory number
	SUB P,[XWD 1,1]
	JUMPGE A,STDIR4		; If no recognition, then no tail to copy
	UMOVE A,2		; Get the user's pointer
	MOVE B,(P)
	PUSHJ P,CPYTUS
STDIR4:	UMOVE A,1		; Get the directory number back
	PUSHJ P,GETDDB
	BUG(HLT,<STDIR: GETDDB FAILED WHEN DIRLUK DIDN'T.>)
	MOVE A,DDBMOD(A)
	XCTUU [HLLM A,1]
	PUSHJ P,USTDIR
	AOSA -1(P)
STDIR1:	POP P,B
	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	JRST SKMRTN

; Directory number to string conversion
; Call:	1	; Sink designator
;	2	; Directory number
;	DIRST
; Return
;	+1	; Error
;	+2	; Ok

.DIRST::JSYS MENTR
	UMOVE A,2		; DIRNUM & BIT
	UMOVE B,3
	PUSHJ P,SETUNT
	 ERR()
	XCTUU [HRRZ A,2]
	PUSHJ P,GDIRST
	 JRST MRETN
	UNLOCK DIRLCK
	PUSHJ P,JFNSS
	AOS (P)
	JRST MRETN

; Make a new fd
; Call:	1:	;STRING POINTER TO DIRECTORY NAME
;	2:	;FLAGS,,PARAMETER BLOCK ADDR.
;	3:	;DEVICE DESIGNATOR IF B17 OF AC2 IS ON
;	4:	;STRING POINTER OF OLD PASSWORD (FOR UN-ENABLED CHANGE)

;	CRDIR

; Return
;	+1	; Error
;	+2	; Success
; In parameter block
;	0	; Pointer to name string
;	1	; Pointer to password string, 0 if none
;	2-N	; Copy of ddb image

.CRDIR::JSYS MENTR
	UMOVE A,2		; BIT
	UMOVE B,3		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 ERR()
	UMOVE E,2		;FLAGS,,PARAMPTR
	MOVE A,CAPENB
	TRNN A,WHEEL!OPR	;MUST HAVE SPECIAL CAPABILITIES,
	TLNN E,577776		;OR BE CHANGING PASSWORD ONLY
	CAIA
	  ERR(CRDIX1)
	UMOVE A,1
	PUSHJ P,CPYFUS		; Copy directory name string
	 ERR CRDIX3		; No room in jsb
	MOVE B,1(A)
	TLNN B,774000
	ERR CRDIX5		; Null name illegal
	PUSHJ P,DIRLUU		; Look up the name in directory
	 JRST MAKNFD		; Non-existent, must make a new one
	TLO E,(1B15)		; NAME EXISTS. DON'T TOUCH MAIL FILE.
	PUSH P,A
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; Release free storage used for name
	TLNE E,(1B16)		; Delete wanted?
	 JRST DELDIR		; Yes
	UNLOCK DIRLCK
	POP P,A
	TLNE E,(1B6)
	XCTUU [CAMN A,6(E)]
	JRST CRDIR1
	  ERR(CRDIX2)		; Directory number disagrees

CRDIR1:	PUSHJ P,GETDDB		; Setup a pointer to the ddb
	BUG(HLT,<CRDIR: GETDDB FAILED WHEN DIRLUU DIDN'T.>)
	MOVE NUM,A		; Save pointer in num

;BACK HERE AFTER CREATING NEW DIRECTORY, FROM MAKNFD BELOW
MAKFD0:	TLNN E,(1B1)
	JRST CRDIR3		; No password change
	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	 JRST MAKF02		;NO CHECK IF SPEC. CAPS. ENABLED
MAKF01:	UMOVE B,4		;GET OLD PASSWORD PTR
	PUSHJ P,CHKPSX		;CHECK PASSWORD
	  ERR(CRDIX1,<CALL CHKPSU>)

MAKF02:	UMOVE A,1(E)		; Get pointer to NEW password
	PUSHJ P,CPYFUS		; Copy new password to free storage
	 ERR CRDIX3,<UNLOCK DIRLCK>
	PUSHJ P,SETMSK		; Store in directory
	PUSHJ P,CPYDIR		; And copy string to directory
	 ERR(CRDIX4,<MOVE B,DIRINP
		MOVEI B,1(B)
		MOVEI A,JSBFRE
		PUSHJ P,RELFRE	; Release job storage
		UNLOCK DIRLCK>)
	HLRZ B,DDBNAM(NUM)	; Get old password pointer
	HRRZS DDBNAM(NUM)	; Zero old pntr
	PUSH P,A
	JUMPE B,MAKFD1
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release storage if any
MAKFD1:	POP P,A
	SUBI A,DIRORG
	HRLM A,DDBNAM(NUM)	; Store as password
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE		; Release jsb storage

CRDIR3:
	UMOVE A,3(E)		; Get privilege bits
	TLNE E,(1B3)
	MOVEM A,DDBPRV(NUM)
	UMOVE A,4(E)
	TLNE E,(1B4)
	MOVEM A,DDBMOD(NUM)
	SETZM DDBRES(NUM)
	UMOVE A,12(E)		; GET LAST LOGIN
	TLNE E,(1B10)		; WANT TO SET IT?
	 MOVEM A,DDBDAT(NUM)	; YES, SET IT
	UMOVE A,13(E)
	TLNE E,(1B11)
	MOVEM A,DDBGRP(NUM)
	MOVE A,DDBNUM(NUM)
	UNLOCK DIRLCK
	PUSHJ P,SETDIR
	BUG(HLT,<CRDIR: SETDIR FAILED ON DIRECTORY FOUND IN INDEX.>)
	UMOVE A,2(E)		; GET MAX ALOCATION
	TLNE E,(1B2)		; SET THIS ONE ?
	HRLM A,DIRDSK		; YUP
	UMOVE A,7(E)		; Default file protection
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B7)
	MOVEM A,DIRDPW
	UMOVE A,10(E)
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B8)
	MOVEM A,DIRPRT
	UMOVE A,11(E)
	ANDI A,777777
	TLO A,500000
	TLNE E,(1B9)
	MOVEM A,DIRDBK
	UMOVE A,14(E)
	TLNE E,(1B12)
	MOVEM A,DIRGRP
	UNLOCK DIRLCK
	JUMPG UNIT,CRDIR4	; NO MESSAGE FILE IF NOT DSK:

CRDI3A:	MOVEI B,20
	TLNN E,(1B15)		;IF B15 ON, DON'T CREATE MAILBOX.
	PUSHJ P,ASGJFR
	 JRST CRDIR4
	PUSH P,A
	HRLI A,(<POINT 7,0,34>)
	HRROI B,[ASCIZ /DSK:</]
	SETZ C,
	SOUT
	PUSH P,A		;SAVE BEGINNING OF NAME
	MOVE B,DIRNUM
	DIRST
	 JRST CRDIR6
	POP P,B			;BEGINNING OF NAME
	PUSH P,A		;MESSAGE FILE NAME STRING PARTIAL PTR
	SETZ A,
	STDIR
	 JFCL
	 JRST CRDIR6
	TRNE A,777776		;DIRECTORY 1, SYSTEM, NON-STD. NO MSG
	TLNE A,(1B0)
	 JRST CRDIR6		;FILES ONLY. NO MSG FILE
	POP P,A
	HRROI B,[ASCIZ />MESSAGE.TXT;1/]
	SETZ C,
	SOUT
	MOVE B,(P)
	HRLI B,(<POINT 7,0,34>)
	MOVSI A,400001
	GTJFN
	 JRST CRDIR5
	MOVE B,[1,,FDBCTL]	;SEE IF IT'S A FRESH FILE
	MOVEI C,C
	GTFDB			;CONTROL WORD TO C
	TLNN C,FDBNXF!FDBDEL	;IF NON-EXISTENT (NEW) OR DELETED,
	JRST CRDI3B		; NO. LEAVE IT ALONE
	HRLI A,FDBCTL		;PUT IT IN STANDARD STATE
	MOVSI B,FDBPRM!FDBNXF!FDBDEL
	MOVSI C,FDBPRM!FDBDEL
	CHFDB
	HRLI A,FDBPRT		;STANDARD PROTECTION FOR MSG FILES
	MOVEI B,777777
	MOVEI C,770404		;IS APPENDABLE BY ALL
	CHFDB
CRDI3B:	HRRZS A
	RLJFN
	 JFCL
	JRST CRDIR5

CRDIR6:	SUB P,BHC+1
CRDIR5:	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
CRDIR4:	SETZM NXTDMP
	JRST SKMRTN

DELDIR:	PUSH P,DIRNUM		; Remember where we are
	MOVE JFN,-1(P)		; Get directory number to delete

	PUSHJ P,DELALL		; Try very hard to delete all files
	MOVE A,SYMBOT
	CAME A,SYMTOP		; Did we succeed?
	 JRST [	MOVE A,DIRORG(A)
		TRNE A,700000
		JRST .+1
		POP P,A
		PUSHJ P,MAPDIR
		UNLOCK(DIRLCK)
		ERR(CRDIX7)]
	POP P,A
	PUSHJ P,MAPDIR		; Return to subindex
	MOVE A,DIRLOC		; Get sym tab loc
	PUSH P,DIRORG(A)	; Save content
DELDI0:	CAMGE A,SYMBOT		; At bottom?
	 JRST DELDI1		; Yes
	MOVE B,DIRORG-1(A)	; No move symbol table up
	MOVEM B,DIRORG+0(A)
	SOJA A,DELDI0

DELDI1:	AOS SYMBOT		; Point to new bottom
	HLRZ B,0(P)		; Get pointer to string
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release free storage
	SUB P,[XWD 1,1]
	POP P,A			; Get directory number
	PUSHJ P,HSHLUK		; Find it in hash table
	 BUG(HLT,<CRDIR: HSHLUK FAILURE FOR EXISTENT USER>)
	MOVSI A,-1
	EXCH A,DIRORG(B)	; Get hash table entry, delete entry
	UNLOCK DIRLCK		; Unlock
	HLRZS A
	PUSH P,A		; Save
	LSH A,-^D12		; Get subindex number
	MOVNS A			; Negate
	PUSHJ P,MAPDIR		; Back to the subdirectory
	MOVEI A,7777
	ANDB A,0(P)		; Extract ddb location
	HLRZ B,DDBNAM+DIRORG(A)	; Get pointer to password
	ADDI B,DIRORG
	CAIE B,DIRORG
	 PUSHJ P,RELDFR		; Release free storage if any
	POP P,B
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release free storage for ddb
	UNLOCK DIRLCK
	JRST SKMRTN

MAKNFD:	MOVE A,CAPENB
	TRNN A,WHEEL!OPR
	 ERR(CRDIX1,<UNLOCK DIRLCK
		MOVE B,DIRINP
		MOVEI B,-1(B)
		MOVEI A,JSBFRE
		PUSHJ P,RELFRE>)
	MOVE A,SYMBOT
	SUBI A,2
	CAML A,FRETOP
	JRST .+3
	PUSHJ P,XPAND
	 JRST MAKNFF		; FULL
	MOVEI B,DDBLEN
	PUSHJ P,ASGDFR		; Assign space for the ddb
MAKNFF:	 ERR(CRDIX4,<UNLOCK DIRLCK
		MOVE B,DIRINP
		MOVEI B,-1(B)
		MOVEI A,JSBFRE
		PUSHJ P,RELFRE>)
	MOVEI NUM,(A)		; Point num to the ddb
	SETZM DDBNAM(NUM)	; Clear name pointers
	SETZM DDBNUM(NUM)	; Clear number
	SETZM DDBPRV(NUM)	; Default privileges
	SETZM DDBDAT(NUM)	; CLEAR LAST LOGIN
	SETZM DDBMOD(NUM)	; Default modes
	SETZM DDBGRP(NUM)
	SETZM DDBRES(NUM)
	PUSHJ P,CPYDIR		; Copy name to directory
	 ERR CRDIX4,<MOVE B,NUM
		PUSHJ P,RELDFR
		UNLOCK DIRLCK>
	SUBI A,DIRORG		; Convert to relative pointer
	HRRM A,DDBNAM(NUM)	; Save as name
	HRLZ C,A		; Right half yet to be filled in
	SOS B,DIRLOC
	SOS A,SYMBOT
	CAML A,B
	JRST MAKNFZ
	ADDI A,DIRORG
	HRLI A,1(A)
	BLT A,DIRORG-1(B)
MAKNFZ:	MOVEM C,DIRORG(B)
	MOVE B,DIRINP
	MOVEI B,-1(B)
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	MOVN A,DIRNUM		; Get subindex number
	IMULI A,10000		; Convert to position in file
	ADD NUM,A		; Of the ddb
	SUBI NUM,DIRORG
	MOVEI A,0
	PUSHJ P,SETDIR		; Look at block 0
	BUG(HLT,<CRDIR: SETDIR FAILED FOR BLOCK 0.>)
	UMOVE A,6(E)
	TLNE E,(1B6)
	JRST FNN01

FNN00:	MOVE A,LSTDNO		; HIGHEST ASSIGNED NUMBER
	AOS A			; PLUS 1
	CAIL A,NFDIB*40
	 JRST FNN05		; NO ROOM LEFT
	UNLOCK DIRLCK
	PUSHJ P,HSHLUK		; Is this number available?
	 JRST FNN2		; OK TO USE
	AOS LSTDNO
	JRST FNN00		; No, try another

FNN2:	CAIL A,1
	CAIL A,NFDIB*40
	BUG(HLT,<CRDIR: HSHLUK RETURN INVALID DIRECTORY NUMBER.>)
	CAML A,LSTDNO
	  MOVEM A,LSTDNO
	MOVEM A,DIRORG(B)	; Store directory number in rh
	HRLM NUM,DIRORG(B)	; And ddb location in left
	MOVE B,NUM
	IDIVI B,10000		; Recover block containing ddb
	ADDI B+1,DIRORG
	PUSH P,B+1
	PUSH P,A
	UNLOCK DIRLCK
	MOVN A,B
	PUSHJ P,MAPDIR		; Return to original subindex
	POP P,A
	POP P,NUM
	HRRM A,DDBNUM(NUM)
	MOVE B,DIRLOC
	HRRM A,DIRORG(B)
	HRRZS A			; Retain only directory number
	PUSH P,DIRNUM		; Save current directory number
	PUSH P,A		; And new directory number
	PUSHJ P,MAPDIR		; Map the new directory
	MOVE A,DIRNUM
	CAME A,0(P)		; See if directory looks like
	 JRST CRWIPE		; It already exists
	SETO A,
	CAMN A,DIRLCK
	CAME A,DIRFRE+1
	 JRST CRWIPE
	MOVE A,SYMTOP
	TRNN A,777
	CAMGE A,SYMBOT
	 JRST CRWIPE
	MOVE A,SYMBOT
	CAMGE A,FRETOP
	 JRST CRWIPE
	JRST CRNWIP

CRWIPE:	MOVEI A,25
	MOVEI B,1000
	MOVE C,0(P)
	PUSHJ P,INIBLK		; Initialize it
CRNWIP:	POP P,DIRNUM		; Set its directory number
	MOVEI A,^D250		; DEFAULT MAX ALOCATION = 250
	HRLM A,DIRDSK
	MOVE A,[500000,,IDRDPW]
	MOVEM A,DIRDPW		; SET DEFAULT PROTECTION
	HRRI A,IDRPRT
	MOVEM A,DIRPRT		; AND DIRECTORY PROTECTION
	MOVEI A,2
	MOVEM A,DIRDBK		; AND DEFAULT BACKUP
	SETZM DIRGRP		; AND GROUPS
	POP P,A
	SETOM DIREXL		; FOR SRI-AI BSYS LOCK STYLE.  WILL GO AWAY SOMEDAY.
	UNLOCK DIRLCK		; Unlock the new directory
	PUSHJ P,MAPDIR		; Restore to mapping current di
	JRST MAKFD0

FNN01:	CAIL A,1
	CAIL A,NFDIB*40
	JRST FNN05
	UNLOCK DIRLCK
	PUSHJ P,HSHLUK
	JRST FNN2
FNN05:	UNLOCK DIRLCK		; Number unavailable, abort
	MOVE B,NUM
	IDIVI B,10000
	MOVEI C,DIRORG(B+1)	; Location in subindex of ddb
	PUSH P,C
	MOVN A,B		; Subindex number
	PUSHJ P,MAPDIR		; Get back to it
	POP P,NUM
	HRRZ B,DDBNAM(NUM)	; Get location of name string
	ADDI B,DIRORG
	PUSHJ P,RELDFR		; Release it
	MOVE B,NUM		; Location of ddb
	PUSHJ P,RELDFR		; Release it
	MOVE B,DIRLOC		; Location where symtab entry was put
FNN03:	CAMG B,SYMBOT		; Something left to move?
	JRST FNN04		; No
	MOVE A,DIRORG-1(B)
	MOVEM A,DIRORG(B)
	SOJA B,FNN03

FNN04:	AOS SYMBOT
	UNLOCK DIRLCK
	ERR(CRDIX6)

; Get directory info
; Call:	1	; Directory number
;	2	; Pointer to parameter block
;	3	; String pointer for password
;	GTDIR

.GTDIR::JSYS MENTR
;	UMOVE A,1		; DIRNUM & BIT
	UMOVE B,4		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 ERR()
	MOVE B,CAPENB
	TRNN B,WHEEL!OPR
	ERABRT(GTDIX1)		; Not wheel or opr
	XCTUU [HRRZ A,1]
	PUSHJ P,GETDDB
	 ERABRT(GTDIX2)
	UMOVE E,2
	UMOVE C,3
	JUMPGE C,GTDIR1
	CAML C,[777777000000]
	HRLI C,(<POINT 7,0>)
GTDIR1:	HLRZ B,DDBNAM(A)
	ADDI B,DIRORG
	HRLI B,(<POINT 7,0,35>)
	UMOVEM C,1(E)
	UMOVEM C,3
	ILDB D,B
	XCTBU [IDPB D,C]
	JUMPN D,.-3
	MOVE D,DDBPRV(A)
	UMOVEM D,3(E)
	MOVE D,DDBMOD(A)
	UMOVEM D,4(E)
	MOVEI D,0
	UMOVEM D,5(E)
	MOVE D,DDBNUM(A)
	UMOVEM D,6(E)
	MOVE D,DDBDAT(A)
	UMOVEM D,12(E)

GTDIR2:	MOVE D,DDBGRP(A)
	UMOVEM D,13(E)
	MOVE A,DDBNUM(A)
	UNLOCK DIRLCK
	PUSHJ P,MAPDIR
	HLRZ D,DIRDSK		; GIVE USER MAX DISK ALOCATION
	UMOVEM D,2(E)
	MOVE D,DIRDPW
	UMOVEM D,7(E)
	MOVE D,DIRPRT
	UMOVEM D,10(E)
	MOVE D,DIRDBK
	UMOVEM D,11(E)
	MOVE D,DIRGRP
	UMOVEM D,14(E)
	JRST MRETN

; Pmap jsys
; Call:	1	; Page ident (frk.pn or jfn.pn)
;	2	; Page ident
;	3	; Bits 2,3,4 to set page table access
;	PMAP

.PMAP::	JSYS MENTR
	IOR 1,2
	JUMPGE 1,[MOVEI A,PMAPX2
		JRST PMAPER]	; Neither is fork -- error
	UMOVE A,2		; Get destination designator
	PUSHJ P,CPMAP		; Convert to ptn.pn and get access
	TLNN C,(1B3)
	ERABRT(PMAPX1)		; Must be able to write destination
	PUSH P,A		; Save destination ptn.pn
	UMOVE A,1		; Get source designator
	CAMN A,MINUS1		; Delete wanted?
	 JRST [	PUSH P,ZERO	; 0 access
		PUSH P,ZERO	; And 0 source
		JRST PMAP2]	; Then skip the following
	PUSHJ P,CPMAP		; Convert source and get it's access
	PUSH P,C		; Save access
	PUSH P,A		; And ptn.pn
	XCTUU [SKIPGE 2]	; Is "to" a file?
	 JRST PMAP2		; No, ok to do
	PUSHJ P,MRPACS		; Yes, get access
	TLNN A,(1B10)		; Better be private
	 JUMPN A,[MOVEI A,PMAPX2; Or empty
		JRST PMAPER]	; Else error
PMAP2:	XCTUU [SKIPGE A,1]	; Is from a file?
	JRST PMAP4		; No.
	HLRZS A			; Yes, get jfn
	LSH A,SJFN		; Convert to index
	MOVSI B,2
	ADDM B,FILLFW(A)	; Increment count of reasons for opening

PMAP4:	XCTUU [SKIPL A,2]	; Is "to" a file?
	JRST [	XCTUU [SKIPL B,1]
		ERABRT(PMAPX2)
		HLRZS A
		LSH A,SJFN	; Convert to index
		MOVSI C,2
		CAME B,MINUS1
		ADDM C,FILLFW(A)
		JRST PMAP3]
	MOVE A,-2(P)		; Get ptn.pn of "to"
	PUSHJ P,MRPACS		; Find out what's currently there.
	JUMPE A,PMAP3		; Jump if empty
	TLNE A,(1B10)
	JRST PMAP3		; Or if private
	MOVE A,-2(P)		; Is indirect or share
	PUSHJ P,MRPT		; Get it's id
	 JRST PMAP3		; Not file
	PUSHJ P,OFNJFX		; Convert to jfn
	JRST PMAP3		; No jfn
	MOVSI B,-2
	HLRZS A
	LSH A,SJFN		; Convert to index
	ADDB B,FILLFW(A)
	LSH A,-SJFN		; Convert back to jfn
	TLNN B,777777
	CLOSF			; Close the file if count goes to 0
	JFCL

PMAP3:	POP P,A
	POP P,C
	POP P,B
	TLO C,1407		; Retain write copy bit and disposal
	XCTUU [AND C,3]
	PUSHJ P,SETPT
	 JFCL
	JRST MRETN

PMAPER:	MOVEM A,LSTERR
	MOVEM B,ERRSAV
	JRST ITRAP

CPMAP:	JUMPL A,FRKMAP
	PUSHJ P,JFNOFN
	 ERABRT(,<MOVEM JFN,ERRSAV>)
	MOVE C,STS
	AND C,[XWD READF!WRTF!XCTF,0]
	LSH C,-1
	TEST(NN,ASPF)
	POPJ P,
	PUSH P,A
	PUSHJ P,MRPACS
	MOVE C,A
	POP P,A
	AND C,[XWD 160000,0]
	POPJ P,

FRKMAP:	PUSHJ P,FKHPTN
	MOVSI C,160000
	POPJ P,
; Rhis routine is called from write copy code in pagem to reduce the
; The map count of a page
; Call:	1	; Ofn.pn
;	PUSHJ P,JFNDCR
; Returns +1 always

JFNDCR:	PUSHJ P,OFNJFX
	POPJ P,
	HLRZS A
	LSH A,SJFN		; Convert to index
	MOVSI B,-2
	ADDB B,FILLFW(A)
	TLNE B,777777
	 POPJ P,
	MOVSI B,FRKF
	ANDCAM B,FILSTS(A)
	POPJ P,

; Read map
; Call:	LH(1)	; Fork handle
;	RH(1)	; Page number
;	RMAP
; Retrn
;	+1
;	LH(1)	; Jfn
;	RH(1)	; Page number
;	2	; Access read, write,execute,nonexistent in bits 2-5

.RMAP::	JSYS MENTR
	PUSHJ P,FRKMAP		; Convert frk.pn to ptn.pn
	PUSHJ P,MRPT		; Call map routine
	 JRST RMAPFK
	PUSH P,B
	PUSHJ P,OFNJFN
RMAP0:	 SETO A,		; Unidentifiable
RMAP1:	POP P,B
	UMOVEM A,1
	UMOVEM B,2
	JRST MRETN

RMAPFK:	PUSH P,B
	JUMPE A,RMAP0
	PUSHJ P,PTNFKH
	JRST RMAP1

; Read accessiblity of page
; Call:	LH(A)	; Fork or file handle
;	RH(A)	; Page number
;	RPACS

.RPACS::JSYS MENTR
	TRNE 1,777000
	SKIPGE 1
	JRST RPACS1
	HLRZS A
	LSH A,SJFN		; Convert to index
	MOVE A,FILSTS(A)
	TLNN A,LONGF
	JRST [	XCTUU [SETZM 2]	; File not long
		JRST MRETN]
	UMOVE 1,1
RPACS1:	PUSHJ P,CPMAP
	PUSHJ P,MRPACS
	UMOVEM 1,2
	TLNE A,USRLKB		; PAGE LOCKED?
	 UMOVEM C,3		; YES, RETURN REAL CORE ADDRESS TOO
	JRST MRETN

; Set accessibility of a page
; Call:	LH(A)	; Fork or file handle
;	RH(A)	; Page number
;	SPACS

.SPACS::JSYS MENTR
	TRNE 1,777000
	SKIPGE 1
	JRST SPACS1
	HLRZS A
	LSH A,SJFN		; Convert to index
	MOVE A,FILSTS(A)
	TLNN A,LONGF
	 JRST MRETN
	UMOVE 1,1
SPACS1:	PUSHJ P,CPMAP		; Convert to ptn.pn
	UMOVE B,1
	JUMPL B,SPACFK
	TEST(NN,WRTF)		; Must be able to write
SPACER:	JRST [	MOVEI A,SPACX1
		MOVEM A,LSTERR
		JRST ITRAP]
	MOVSI C,160000
	JRST SPAC1

SPACFK:	PUSH P,A		; Save page handle
	PUSHJ P,MRPACS		; Get access of page
	TLNN A,(1B5)
	JRST SPACER		; Non-existent page
	TLNE A,(1B10)
	JRST SPACPR		; Private page
	PUSH P,A		; Save access
	MOVE A,-1(P)		; Get back the page handle
	PUSHJ P,MRPT		; Get map contents
	 JRST SPACP1		; Indirect or shared to fork
	PUSHJ P,OFNJFN		; Convert to jfn.pn
	JRST SPACCF		; Closed file
	PUSHJ P,CPMAP		; Get allowable access
	SUB P,[XWD 1,1]
	JRST SPAC2

SPACCF:	POP P,C
	AND C,[XWD 160000,0]
	JRST SPAC2

SPACP1:	SUB P,[XWD 1,1]
SPACPR:	MOVSI C,160000		; PERMIT RWX
	MOVE A,CAPENB
	TRNE A,WHEEL+MAINT	; AND IF WHEEL OR MAINT
	 TLO C,USRLKB		; THEN USRLKB IS OK TOO
SPAC2:	TLO C,1400		; ALSO PERMIT TRAPUB AND WRITECOPY
	POP P,A
SPAC1:	UMOVE B,2
	AND B,C
	MOVE C,MAXLOK
	CAMG C,LOKPGS		; NOT TOO MANY PAGES LOCKED
	TLNN B,USRLKB		; OR NOT TRYING TO LOCK?
	 SKIPA			; IS OK
	  JRST SPACER		; IS NOT OK, GENERATE ERROR
	NOINT
	PUSHJ P,MSPACS
	JRST MRETN

; Find first free file page
; Call:	1	; Jfn
;	FFFFP
; Return
;	+1
;	1	; Jfn.pn of first free page

.FFFFP::JSYS MENTR
	HRLZS A
FFFFPL:	RPACS
	JUMPE B,FFFFP1
	AOJA A,FFFFPL

FFFFP1:	UMOVEM A,1
	JRST MRETN

; Find first used file page
; Call:	LH(1)	; Jfn
;	RH(1)	; Page number to start with
;	FFUFP
; Returns
;	+1	; Error
;	+2	; Success jfn.pn of first used page in 1

.FFUFP::JSYS MENTR
FFUF0:	HLRZ JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)		; Tty and byte no good
	TEST(NE,ASTF)
	 ERR(DESX7)
	TEST(NN,OPNF)
	ERUNLK(FFUFX1)		; Not open
	MOVEI A,@NLUKD(DEV)
	CAIE A,MDDNAM
	ERUNLK(FFUFX2)		; Not disk
	TEST(NE,LONGF)
	JRST FFUFPL
	UMOVE A,1
	TRNE A,777000
	ERUNLK(FFUFX3)		; Page beyond 777 of short can't exist
	HLL A,FILOFN(JFN)
	PUSHJ P,FFUFF
	ERUNLK(FFUFX3)		; No pages in use

FFUFPX:	XCTUU [HRRM A,1]
	PUSHJ P,UNLCKF
	UMOVE 1,1		; GET THE ARG BACK
	RPACS			; CHECK ACTUAL ACCESS
	TLNE 2,(1B5)		; EXISTS?
	 JRST SKMRTN		; YES, SUCCEED
	XCTUU [AOS 1,1]		; NO, TO NEXT PAGE
	TRNE 1,777777		; OFF THE END OF THE WORLD
	 JRST FFUF0		; NO, FIND NEXT ONE
	ERR(FFUFX3)
	JRST SKMRTN

FFUFPL:	UMOVE A,1
	HRRZS A
FFUFP1:	MOVE B,A
	LSH B,-9		; Get ptt number
	ADD B,FILLFW(JFN)
	SKIPE (B)		; Check for pt existence
	JRST FFUFP2		; Exists, scan it
FFUFP3:	ADDI A,1000
	ANDCMI A,777
	TLNN A,777777
	JRST FFUFP1
	ERUNLK(FFUFX3)

FFUFP2:	PUSH P,A
	PUSHJ P,JFNOF1		; Get ofn.pn for this page
	 JRST FFUFP9		; APPARENTLY HAS A BAD PT
	PUSHJ P,FFUFF		; Scan the pt for stuff
FFUFP9:	 JRST [	POP P,A	; None found
		JRST FFUFP3]
	POP P,B
	ANDI B,777000
	ADD A,B
	JRST FFUFPX		; Success

FFUFF:	PUSH P,A
	PUSHJ P,ASGPAG		; Get a page to map the pt
	 JRST [	POP P,A
		POPJ P,]
	MOVE B,A
	HRLI B,100000
	HLRZ A,(P)
	PUSHJ P,SETMPG		; Map the pt
	HRRZ A,(P)		; Get starting page number
	ADDI A,(B)		; Location of disc address
FFUFF0:	SKIPE (A)		; Empty?
	JRST FFUFF1		; No, found it
	CAIGE A,777(B)		; Whole pt scanned?
	AOJA A,FFUFF0		; No, try next one.
FFUFF2:	MOVEI A,0
	PUSHJ P,SETMPG		; Unmap the pt
	HRRZ A,B
	PUSHJ P,RELPAG		; Release the page
	POP P,A
	POPJ P,

FFUFF1:	ANDI A,777		; Get pn part
	MOVEM A,(P)
	AOS -1(P)		; Skip return
	JRST FFUFF2

; Check for tty designator

CHKTTM:	MOVE JFN,1
	PUSHJ P,CHKTTC
	 JRST [	PUSHJ P,UNLCKF
		ERABRT(DESX1)]
	PUSHJ P,UNLCKF
	POPJ P,

CHKTTY:	UMOVE JFN,1
CHKTTC:	PUSHJ P,CHKJFN
	 ERABRT()		;NO GOOD. THE ERROR NUMBER IS IN A
	 JRST .+2		; TTY DESIGNATOR. STS SAYS OPEN R,W
	 POPJ P,		; NOT TTY, BUT GOOD DESIGNATOR
	TEST(NE,ASTF)		;FILE, MAYBE TTY. STARS IN NAME?
	 ERABRT(DESX7)		;YES. BAD.
	TEST(NN,OPNF)		;OPEN? (MAY NOT HAVE RIGHTS TO IT IF NO)
	 POPJ P,0		;NOPE. FAIL.
	HRRZ A,DEV
	CAIE A,TTYDTB
	 POPJ P,0		; Not tty, no skip
	HLRZ 2,DEV
	JRST SKPRET

; Jsys's see jsys manual for description of calling sequences

; Clear input buffer

.CFIBF::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	PUSHJ P,TTCIBF
UNL:	PUSHJ P,UNLCKF
	JRST MRETN

; Clear file output buffer

.CFOBF::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	PUSHJ P,TTCOBF
	JRST UNL

; Skip if input buffer empty

.SIBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST SIBE1
	PUSHJ P,TTSIBE
	JRST UNL1		; Return no. of bytes in buffer
SKPUNL:	AOS (P)
	JRST UNL

SIBE1:	TEST(NE,OPNF)
	TEST(NN,READF)
	 JRST SKPUNL
	SKIPLE A,FILCNT(JFN)
	 JRST UNL1
IFDEF NETN,<HRRZ A,DEV
	CAIE A,NETDTB
	 JRST SKPUNL
	PUSHJ P,NTSIBE
	 JRST UNL1>
	JRST SKPUNL

; Dismiss until input buffer is empty

.DIBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	  JRST UNL		;GOOD JFN BUT NOT TTY. UNLOCK, RETURN.
	PUSHJ P,TTDIBE
	JRST UNL

; Skip if output buffer full

.SOBF::	JSYS MENTR
	PUSHJ P,CHKTTY
	TDZA A,A		; Return +1 with 0
	PUSHJ P,TTSOBF
	 JRST UNL1		; Return +1 with no. bytes in buffer
	AOS (P)
UNL1:	UMOVEM 1,2		; Return count of bytes in buffer
	JRST UNL

; Skip if output buffer is empty

.SOBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST SOBE1
	PUSHJ P,TTSOBE
	JRST UNL1
SOBE1:	AOS (P)
	JRST UNL

; Dismiss until output buffer is empty

.DOBE::	JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	PUSHJ P,TTDOBE
	JRST UNL

; Get tab settings

.GTABS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST [	XCTUU [SETZB A,2]
		UMOVEM A,3
		UMOVEM A,4
		JRST UNL]
	PUSHJ P,TTGTBS
	UMOVEM 1,2
	UMOVEM 3,3
	UMOVEM 4,4
	JRST UNL

; Set tab stops

.STABS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	UMOVE 3,3
	UMOVE 4,4
	PUSHJ P,TTSTBS
	JRST UNL

; Read modes

.RFMOD::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST RFMOD1
	PUSHJ P,TTRMOD
	UMOVEM 1,2
	JRST UNL

RFMOD1:	MOVE A,STS
	ANDI A,17
	ADD A,[^D66B10+^D72B17+^D7B3]
	UMOVEM A,2
	JRST UNL

; Set file modes

.SFMOD::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	PUSHJ P,TTSMOD
	JRST UNL

; Read file position

.RFPOS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST [	XCTUU [SETZM 2]
		JRST UNL]
	PUSHJ P,TTRPOS
	UMOVEM 1,2
	JRST UNL

; Set file position

.SFPOS::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	PUSHJ P,TTSPOS
	JRST UNL

; Read control character output control

.RFCOC::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST RFCOC1
	PUSHJ P,TTRCOC
	UMOVEM 1,2
	UMOVEM 3,3
	JRST UNL

RFCOC1:	MOVE A,[BYTE (2)2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
	UMOVEM A,2
	UMOVEM A,3
	JRST UNL

; Set control character output control

.SFCOC::JSYS MENTR
	PUSHJ P,CHKTTY
	 JRST UNL
	UMOVE 1,2
	UMOVE 3,3
	LDB 4,[POINT 2,1,25]	;FIELD FOR FORMFEED
	SKIPN FORKN		;IS THIS THE TOP FORK?
	DPB 4,TTYFFC##		;YES. REMEMBER THIS SETTING FOR RESET.
	PUSHJ P,TTSCOC
	JRST UNL

; Simulate teletype input

.STI::	JSYS MENTR
	PUSHJ P,CHKTTY
	 ERABRT(TTYX1)
	UMOVE 1,2
	PUSHJ P,TTSTI
	JRST UNL

; Check device designator
; Call:	A	; Device designator
;	PUSHJ P,CHKDEV
; Return
;	+1	; Error, number in a
;	+2	; Ok
;	B	; Index into device tables
;	C	; Device characteristics word
;	A	; Unit number
;	LH(DEV)	; Unit
;	RH(DEV)	; Dispatch address

CHKDEV::TLNN A,777777		; Left half zero means tty designator
	JRST TTYDEV
	TLZ A,600000		; These bits always on
	MOVNI B,NDEV		; Movsi b,-ndev the hard way...
	HRLZS B
CHKDVL:	HLLZ C,DEVCHR(B)	; Construct device designator for this dev
	TLZ C,777000
	HRR C,DEVUNT(B)
	CAME C,A		; Is it the same as user's
	AOBJN B,CHKDVL		; No, continue scan
	JUMPGE B,[MOVEI A,DEVX1
		POPJ P,]	; Illegal designator
	HLRZ A,DEVUNT(B)	; Get device assignment
	CAME A,JOBNO
	CAIN A,777777
	JRST CHKDV1		; Assigned this job or unassigned
	MOVEI A,DEVX2
	POPJ P,			; Device not available

CHKDV1:	HRRZ A,C		; Leave unit in a
	MOVEM A,UNIT
	MOVE DEV,DEVDSP(B)
	HRL DEV,A		; Dispatch in dev
	MOVE C,DEVCHR(B)	; And characteristics in c
	JRST SKPRET

TTYDEV:	CAIN A,777777
	JRST CTTYDV
	TRZ A,400000		; Convert tty designator to
	HRLI A,600000+12	; To ordinary device designator
	JRST CHKDEV		; And try again

CTTYDV:	MOVE B,JOBNO
	HRLZI A,JOBPT(B)
	HRRI A,DISGET
	SKIPGE B,JOBPT(B)
	JSYS EDISMS
	HLRZ A,B
	JRST TTYDEV

; SET UP UNIT
; CALL:	A	; BIT 17 IF NOT DEFAULT
;	B	; DEVICE DESIGNATOR
;	PUSHJ P,SETUNT
; RETURNS
;	+1	; FAIL
;	+2	; SUCCESS, UNIT LOADED

SETUNT:	EXCH A,B
	MOVE UNIT,JOBUNT
	TLNN B,(1B17)
	 JRST SKPRET
	TLNE A,177777		; MUST BE A DISK
	 POPJ P,
	PUSHJ P,CHKDEV
	 POPJ P,
	JRST SKPRET

; Assign device
; Call:	1	; Device designator
;	ASND
; Return
;	+1	; Error, not assignable or bad designator etc.
;	+2	; Ok, the device specified is now assigned to this job

.ASND::	JSYS MENTR
	NOINT
	LOCK DEVLCK,<PUSHJ P,LCKTST##>
	PUSHJ P,CHKDEV
	 ERR(,<UNLOCK DEVLCK>)
	TLNN C,(1B3)		; Is this an assignable device?
	ERR(ASNDX1,<UNLOCK DEVLCK>)
	LDB D,[POINT 9,C,17]
	CAIN D,12
	JRST [	HLRZ D,TTFORK(A)
		CAIE D,777777
		CAMN D,JOBNO
		CAMN A,CTRLTT
		ERR(DEVX2,<UNLOCK DEVLCK>)
		MOVE D,JOBNO
		HRLM D,TTFORK(A)
		MOVEI C,0(A)
		IDIVI C,2
		ADD C,TTFRKP(D)
		SETO D,
		DPB D,C		; TTY not used as a fork CTTY
		JRST .+1]
	MOVSI A,(1B6)
	IORM A,DEVCHR(B)	; Mark this device as assigned by asnd
	MOVE A,JOBNO
	HRLM A,DEVUNT(B)	; Assign to this job
	UNLOCK DEVLCK
	JRST SKMRTN

; Release device
; Call:	1	; Device designator or -1 to release all devices
;	RELD
; Returns
;	+1	; Error, bad designator or not assigned to this job
;	+2	; Ok.

.RELD::	JSYS MENTR
	NOINT
	LOCK DEVLCK,<PUSHJ P,LCKTST##>
	CAMN 1,MINUS1
	JRST RELDAL
	PUSHJ P,CHKDEV
	 ERR(,<UNLOCK DEVLCK>)
	PUSHJ P,RELDD
	UNLOCK DEVLCK
	JRST SKMRTN

RELDAL:	MOVNI B,NDEV		; Movsi b,-ndev the hard way...
	HRLZS B
RELDA1:	HLRZ A,DEVUNT(B)
	CAME A,JOBNO
	JRST RELDA2
	PUSHJ P,RELDD
RELDA2:	AOBJN B,RELDA1
	UNLOCK DEVLCK
	JRST SKMRTN

RELDD:	LDB D,[POINT 9,DEVCHR(B),17]
	CAIE D,12		; TTY?
	JRST RELDD1		; NO
	HRRZ A,DEVUNT(B)
       NOSKED	     	       	; GET CONSISTENT READING OF TTFORK...
        HLRE C,TTFORK(A)        ; OWNER OF TERMINAL IN QUESTION
        SKIPL D,C               ; COPY TO D, SKIP IF UNOWNED
        HLRE D,JOBPT(C)         ; CONTROLLING TERM OF OWNER
       OKSKED			; RESUME SCHEDULING
        CAMN D,A                ; IS TERMINAL CONTROLLING TRM OF OWNER?
        JRST RELDD1             ; YES, JUST FIX DEVUNT AND LEAVE
        JUMPL C,CPOPJ           ; NO, DONE IF NOT OWNED
        MOVEI C,0(A)            ; CONTINUE IF OWNED.
	IDIVI C,2
	ADD C,TTFRKP(D)
	LDB C,C			; C=TTFRK1 entry for line
	CAIE C,-1		; In use as a CTTY?
	POPJ P,			; yes, don't release
	HRROS TTFORK(A)
IFDEF NETN,<
	PUSH P,B
	HRRZ B,A
	CAIL B,NVTLO
	PUSHJ P,NVTDET
	POP P,B
>

RELDD1:	HRROS DEVUNT(B)
	MOVSI D,(1B6)
	ANDCAM D,DEVCHR(B)
	POPJ P,

; Get device characteristics
; Call:	1	; Device designator
;	DVCHR
; Return
;	+1	; Ok
;	2	; Device characteristics word
;	LH(3)	; Job to which device is assigned
;	RH(3)	; Unit number

.DVCHR::JSYS MENTR
	HLRZ B,1
	TRZ B,777
	CAIL 1,400000		; Is this a tty designator?
	CAIL 1,400000+NLINES
	CAIN B,600000		; Or a device designator
	JRST DVCHR1		; Yes, do directly
	UMOVE JFN,1		; No. translate first
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 JRST [	UMOVEM JFN,1
		JRST DVCHR1]
	HLRZ A,FILDDN(JFN)	; Get pointer to device name block
	HRLI A,(<POINT 7,0,35>)
	STDEV			; Convert string to device designator
	ERABRT(<(2)>,<PUSHJ P,UNLCKF>)
	PUSHJ P,UNLCKF
	UMOVEM 2,1
DVCHR1:	UMOVE A,1
	PUSHJ P,CHKDEV
	 JRST [	CAIE A,DEVX2	; Was error due to unavailablity
		JRST ERABRD	; No, abort
		MOVE C,DEVCHR(B)
		JRST .+2]
	TLO C,(1B5)
	UMOVEM C,2
	MOVE A,DEVUNT(B)
	UMOVEM A,3
	JRST MRETN

; String to device
; Call:	1	; Device designator
;	STDEV
; Return
;	+1	; Error
;	+2	; Ok
;	2	; Device designator

.STDEV::JSYS MENTR
	UMOVE A,1
	PUSHJ P,CPYFUS
	 ERR(GJFX22)
	PUSH P,A
	PUSHJ P,DEVLUK		; Look up the device name
	 JRST [	CAIE A,GJFX16
		JRST .+1
		MOVEI A,STDVX1
		UMOVEM A,2
		JRST STDEV1]	; No such device
	AOS -1(P)
	HRRZ A,DEVUNT(B)
	HLL A,DEVCHR(B)
	TLZ A,777000
	TLO A,600000
	UMOVEM A,2
STDEV1:	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
	JRST MRETN

; Device to string
; Call:	1	; Destination designator
;	2	; Device designator
;	DEVST
; Return
;	+1	; Ok

.DEVST::JSYS MENTR
	UMOVE A,2
	PUSHJ P,CHKDEV
	 JRST [	CAIE A,DEVX2
		ERR()
		JRST .+1]
	MOVE C,DEVNAM(B)
	MOVE D,[POINT 6,C]
DEVST0:	ILDB B,D
	JUMPE B,DEVST1
	ADDI B,40
	PUSHJ P,BOUTN
	TLNE D,(77B5)		;QUIT AFTER SIX CHARACTERS
	JRST DEVST0
DEVST1:	UMOVE A,1		; Preserve user 1
	PUSHJ P,BOUTN		; Write the null
	UMOVEM A,1		; Restore user 1
	AOS (P)
	JRST MRETN

; Mount device
; Call:	1	; Device designator
;	MOUNT
; Return
;	+1	; Error
;	+2	; Ok

.MOUNT::JSYS MENTR
	UMOVE A,1
	TLZN A,(1B3)		; Directory to be read?
	TDZA B,B		; Yes
	SETO B,			; No
	PUSH P,B
	PUSHJ P,CHKDEV
	 ERR()
	UMOVE 1,1
	TLZ 1,(1B3)
	TLNE C,(1B8)		; Already mounted?
	 JRST [	DSMNT		; Attempt to dismount first
		 ERR()		; Error if can't
		JRST .+1]
	TLNN C,(1B7)		; Mountable?
	ERR(MNTX3)		; No
	EXCH B,(P)		; Save b, get directory read flag
	NOINT
	PUSHJ P,@MNTD(DEV)	; Call device mount routine
	 ERR(MNTX2)		; Not mountable
	POP P,B
	MOVSI C,(1B8)
	IORB C,DEVCHR(B)	; Mark device as mounted
	JRST SKMRTN

; Dismount device
; Call:	1	; Device designator
;	DSMNT
; Return
;	+1	; Error
;	+2	; Ok

.DSMNT::JSYS MENTR
	UMOVE A,1
	PUSHJ P,CHKDEV
	 ERR()			; Illegal designator or not available
	TLNN C,(1B8)		; Mounted?
	ERR(DEVX3)		; No, can't dismount
	PUSH P,B
	NOINT
	PUSHJ P,@DSMD(DEV)	; Call device dismount
	 ERR(DSMX1)		; Files open, can't dismount
	MOVSI C,(1B8)
	POP P,B
	ANDCAM C,DEVCHR(B)	; Mark as not mounted
	AOS (P)
	JRST MRETN

; Initialize directory
; Call:	1	; Device designator
;	INIDR
; Return
;	+1	; Error
;	+2	; Ok

.INIDR::JSYS MENTR
	UMOVE A,1
	PUSHJ P,CHKDEV
	 ERR()
	TLNN C,(1B8)
	ERR(DEVX3)		; Not mounted
	PUSHJ P,@INDD(DEV)
	AOS (P)
	JRST MRETN

; Read directory

.RDDIR::JSYS MENTR
	PUSHJ P,CHKDEV
	 JRST MRETN
	MOVEI B,(DEV)
IFDEF DTAN,<CAIE B,DTADTB>
	ERR(RDDIX1)
IFDEF DTAN,<
	PUSH P,A
	PUSHJ P,DRWAIT
	POP P,A
	MOVS B,DTASTS(A)
	TRNE B,DIRIC
	TLNN B,777777
	ERR(RDDIX1)
	UMOVE A,2
	HRR B,A
	XCTMU [BLT B,177(A)]
	JRST SKMRTN>

; File directory free space
; Call:	1	; Device designator (must be dsk for now)
;	2	; User number
;	FDFRE
; Returns
;	+1	; Error
;	+2	; Success, in 2 the space left in the specified fd
.FDFRE::JSYS MENTR
	PUSHJ P,CHKDEV
	 ERR()			; Some kind of error
	MOVEM A,UNIT
	TLNN C,(1B4)
	ERR(FDFRX1)		; Don't know about non-mdd stuff
	UMOVE A,2		; Get directory number
	PUSHJ P,GETDDB
	 ERR(FDFRX2)		; No such user
	UNLOCK DIRLCK
	UMOVE A,2
	MOVEI B,-1		; Need real dsk index here
	PUSHJ P,MAPDIR
	MOVE A,DIRFRE+2
	UMOVEM A,2
	JRST SKMRTN

; Special file operation
; Call:	1	; Jfn
;	2	; Operation desired
;	MTOPR

.MTOPR::JSYS MENTR
	UMOVE JFN,1
	PUSHJ P,CHKJFN
	 ERABRT()
	 JFCL
	 ERABRT(DESX4)
	TEST(NN,OPNF)
	ERABRT(CLSX1,<PUSHJ P,UNLCKF>)
	TEST(Z,ERRF,EOFF)
	UMOVE B,2
	PUSHJ P,@MTPD(DEV)
	PUSHJ P,UNLCKF
	JRST MRETN

; Error number to string
; Call:	1	; Output designator
;	2	; FORK,,ERROR NUMBER
;	3	; -N CHARS,,BITS
;	ERSTR

.ERSTR::JSYS MENTR
	HLRZ 1,2
	PUSHJ P,SETLFK		; Map psb of the fork
	UMOVE B,3
	HRLZI C,ERRSAV(1)
	HRRI C,4
	TRNN B,1B19
	BLT C,10
	XCTUU [HRRZ C,2]
	CAIN C,777777
	MOVE C,LSTERR(1)
	ANDI C,37777
	CAIL C,10000
	JRST MRETN		; Illegal error number
; We now have error number in c, parameters in 4-10, bits and count in b
	PUSH P,B
	HRROI 2,[ASCIZ /DSK:<SYSTEM>ERROR.MNEMONICS/]
	MOVSI 1,100001
	GTJFN			; Get jfn for error mnemonics
	JRST NOFIL
	MOVE 2,[XWD 440000,200000]
	PUSH P,1
	OPENF
	JRST [	POP P,1
		RLJFN
		JFCL
		JRST NOFIL]
	POP P,1
	ANDI C,7777
	RIN			; Read byte number of message
	JUMPE 2,NOFIL2
	PUSH P,2
	MOVEI 2,7
	SFBSZ
	POP P,2
	SFPTR			; Start reading here
	JRST NOFIL2
	POP P,C
	HLRES C
	MOVMS C			;DUE TO CODE AND MANUAL DISAGREEING
	SKIPE C
	SOS C

CPYER1:	BIN
	CAIN 2,"@"
	JRST ERSTDN
	CAIN 2,"%"
	JRST EXPND
	PUSHJ P,ERST9
	 JRST [	AOS (P)
		JRST NOFIL2]
	JRST CPYER1

ERST9:	SKIPE C
	SOJLE C,CPOPJ
	PUSHJ P,SAVAC
	UMOVE JFN,1
	PUSHJ P,ERBOUT
	SOS -NSAC(P)
	TLNE JFN,-1		;ONLY IF A BYTE PTR
	UMOVEM JFN,1
	PUSHJ P,RESAC
	JRST SKPRET

ERBOUT:	PUSHJ P,CHKJFN
	POPJ P,
	JFCL
	 JFCL
	TEST(NE,ENDF)
	JRST UNLCKF
	TEST(NE,OPNF)
	TEST(NN,WRTF)
	JRST UNLCKF
	AOS (P)
	JRST BYTOUA

NOFIL:	POP P,B
	MOVE D,[POINT 7,[ASCIZ /CANNOT FIND ERROR MESSAGE FILE/]]
NOFILL:	ILDB B,D
	JUMPE B,MRETN
	PUSHJ P,ERST9
	 JRST MRETN
	JRST NOFILL

EXPND:	MOVEI D,0
	BIN
	CAIN B,"%"
	JRST CPYER1
EXPND1:	CAIG 2,"9"
	CAIGE 2,"0"
	JRST EXPNDD
	IMULI D,^D10
	ADDI D,-60(B)
	BIN
	JRST EXPND1

EXPNDD:	CAIN B,"E"
	JRST EXPEXP
	CAIL D,5
	JRST EXPND
	CAIN B,"A"
	JRST EXPASC
	CAIN B,"O"
	JRST EXPOCT
	CAIN B,"D"
	JRST EXPDEC
	CAIN B,"H"
	JRST EXPHLF
	CAIN B,"F"
	JRST EXPFLT
	CAIN B,"L"
	JRST EXPLOC
	CAIN B,"N"
	JRST EXPJFN
	CAIE B,"@"
	JRST EXPND
	JRST EXPND

EXPEXP:	JRST EXPND

EXPASC:	MOVE B,ERRSAV(D)
	PUSHJ P,ERST9
	 JRST ERSTD0
	JRST EXPND

EXPOCT:	MOVE B,ERRSAV(D)
	MOVEI D,10
	PUSHJ P,ERNOUT
	 JRST ERSTD0
	JRST EXPND

EXPDEC:	MOVE B,ERRSAV(D)
	MOVEI D,12
	PUSHJ P,ERNOUT
	 JRST ERSTD0
	JRST EXPND

ERNOUT:	PUSH P,A
	MOVE A,B
	PUSHJ P,ERNOU1
	SOS -1(P)
	POP P,A
	JRST SKPRET

ERNOU1:	IDIV A,D
	HRLM A+1,(P)
	JUMPE A,.+3
	PUSHJ P,ERNOU1
	POPJ P,
	HLRZ B,(P)
	ADDI B,"0"
	JRST ERST9

EXPHLF:	MOVE D,ERRSAV(D)
	PUSH P,D
	HLRZ B,D
	MOVEI D,10
	PUSHJ P,ERNOUT
	 JRST ERSTD1
	POP P,D
	MOVEI B,","
	PUSHJ P,ERST9
	 JRST ERSTD0
	PUSHJ P,ERST9
	JRST ERSTD0
	HRRZ B,D
	MOVEI D,10
	PUSHJ P,ERNOUT
	 JRST ERSTD0
	JRST EXPND

EXPFLT:
EXPLOC:
EXPJFN:	JRST EXPND

ERSTD1:	POP P,D
	JRST ERSTD0

ERSTDN:	AOS (P)
	AOS (P)
ERSTD0:NOFIL2:	CLOSF
	JFCL
	JRST MRETN

NOFIL1:	RLJFN
	 JFCL
	JRST MRETN

; Get last error
; Call:	1	; Fork designator
;	GETER

.GETER::JSYS MENTR
	PUSHJ P,SETLFK
	MOVE B,LSTERR(1)
	XCTUU [HRL B,1]
	UMOVEM B,2
	MOVEI B,4
	HRLI B,ERRSAV(1)
	XCTMU [BLT B,10]
	JRST MRETN


; DELETE ALL BUT N VERSIONS OF FILE

; ACCEPTS: 1) JFN
;	   2) NUMBER OF VERSIONS TO KEEP

; RETURNS: +1) ERROR
;	   +2) SUCCESS, WITH NEGATIVE NUMBER OF VERSIONS DELETED IN 2

.DELNF:
	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN	;CHECK IT
	JRST GBGJFN
	JFCL
	ERUNLK DESX4	;TTY OR BYTE ILLEGAL
	HRRZ A,NLUKD(DEV)	;CHECK IF NAME LOOKUP DISPATCH
	CAIE 1,MDDNAM		;IS MDDNAM
	ERUNLK GFDBX1
	PUSHJ P,GETFDB
	ERUNLK DESX3
	UMOVE B,2		;NO. VERSIONS TO KEEP
DELNF2:
	HLLZ C,FDBCTL(A)	;GET FLAG WORD
	TLNE C,FDBTMP		;QUIT IF TEMP FLAG
	JRST DELNF1
	TLNE C,FDBNXF+FDBDEL
	JRST DELNF1
	SOJGE B,DELNF1
	MOVSI C,FDBDEL
	IORM C,FDBCTL(A)
DELNF1:
	HRRZ A,FDBVER(A)
	JUMPE A,DELNFE
	ADDI A,DIRORG
	JRST DELNF2
DELNFE:
	UMOVEM B,2
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Delete deleted files
; LH 1/ FLAGS AS FOLLOWS:
;  B17 -- ON DEVICES SPECIFIED BY AC2
;  B16 -- TEMP (THIS JOB)
;  B15 -- SCRATCH AND TEMP (OTHER JOBS)
;  B14 -- PERMANENT FILES (FDBPRM SET)
;  B13 -- DELETED FILES (FDBDEL)
;  B12 -- NON-EXISTENT FILES ( FDBNXF AND FDBNEX)
; B11 -- ALL FILES (EVEN IF NOT DELETED)

.DELDF::JSYS MENTR
;	UMOVE A,1		; DIRNUM & BIT
;	UMOVE B,2		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 JRST MRETN
	UMOVE A,1
	HRRZS A
	MOVE C,CAPENB
	MOVE B,FORKX
	SKIPGE B,FKDIR(B)
	MOVE B,FKDIR(B)		; B=conn dir,,user dir
	HLRZS B			; B=conn dir
	CAME A,B
	TRNE C,WHEEL!OPR
	PUSHJ P,GETDDB
	 JRST MRETN
	UMOVE JFN,1
	HLRZ F,JFN
	TRZ F,(1B11!1B14!1B17)	; NEVER EXPUNGE PRM/ALL, CLEAR 1B17
	HRRZS JFN
	TRNE F,-1		; DEFAULT WANTED?
	 JRST DELDQ		; NO, GO DO WHAT IS ASKED
	MOVSI A,-NFKS
	MOVE D,FORKX
	SKIPGE FKDIR(D)		; ARE WE A TOP GROUP FORK?
	 HRRZ D,FKDIR(D)	; NO, GET OUR TOP GUY
DELDQ1:	SKIPG B,FKDIR(A)	; IS THIS A TOP FORK?
	 JRST DELDQ2		; NO, SKIP OVER HIM
	HLRZ C,B		; YES. GET CONNECTED DIRECTORY
	CAIE JFN,0(C)
	CAIN JFN,0(B)
	CAIN D,0(A)		; EXPUNGING LOGIN OR CONNECTED DIRECTORY
				;.. AND NOT OURSELVES
	JRST DELDQ2		; NOT THE SAME DIRECTORIES OR OURSELF
	MOVEI F,22	; OTHER LOGINS -- DELETED AND TEMP ONLY
	JRST DELDQ

DELDQ2:	AOBJN A,DELDQ1
	MOVEI F,66		; ELSE INCLUDE SCRATCH & NON-EX TOO
DELDQ:	UNLOCK DIRLCK
	OKINT
	PUSHJ P,DELDEL
	JRST MRETN

DELALL:	MOVEI F,777777
DELDEL:	MOVE A,JFN
	PUSHJ P,SETDIR		; Map the appropriate directory
	POPJ P,
	SKIPL DIREXL		; ARE EXPUNGES BEING INHIBITED SRI WAY???
	 JRST DELP1X		; YES, UNLOCK AND RETURN
	MOVE D,SYMBOT
DELP1:	CAMGE D,SYMTOP
	JRST DELP2
	PUSHJ P,GCDIR		; Collect remaining good stuff
DELP1X:	PUSHJ P,USTDIR
	POPJ P,

DELP2:	HRRZ A,DIRORG(D)
	TRNE A,700000
	JRST DELPC
	MOVEI B,400100
	PUSHJ P,DELCKB		; Check range and validity of block
	 JRST DELPD		; Skip if bad
	PUSH P,A		; Save
	HLRZ A,DIRORG(D)	; Get pointer to name string
	MOVEI B,400001
	PUSHJ P,DELCKB		; Check validity
	 JRST [	MOVEM D,0(P)
		JRST DELP5]	; Bad -- ignore
	EXCH D,0(P)		; Get back a to d, save d
	PUSHJ P,DELP3
	JUMPE D,DELP4		; No fdb's left?
	POP P,A
	HRRM D,DIRORG(A)
	AOS D,A
	JRST DELP1

DELPC:	ANDI A,700000
	CAIE A,100000
	 AOJA D,DELP1
	HLRZ A,DIRORG(D)
	MOVEI B,777777
	PUSHJ P,DELCKB		; Check block for validity
	 JRST DELPD		; Bad, ignore
	SKIPE DIRORG+1(A)	; Account string still used?
	 AOJA D,DELP1		; Yes
DELPD:	PUSH P,D
DELP4:	MOVE D,(P)
DELP5:	CAMG D,SYMBOT
	JRST DELP6
	MOVE A,DIRORG-1(D)
	MOVEM A,DIRORG(D)
	SOJA D,DELP5

DELP6:	AOS SYMBOT
	POP P,D
	AOJA D,DELP1

DELCKB:	PUSH P,A
	CAIL A,DIFREE-DIRORG
	CAML A,FRETOP
	 JRST DELCKF		; Bad
	HLRZ A,DIRORG(A)
	CAME A,B
	 JRST DELCKF
	POP P,A
	AOS (P)
	POPJ P,

DELCKF:	BUG(CHK,<DELDEL: BAD BLOCK TYPE IN DIRECTORY>)
	POP P,A
	POPJ P,

DELP3:	PUSH P,ZERO		; Where first extension is
	HRRZ A,P		; Initial value of ind pointer
	PUSH P,A		; Onto stack too

DELP7:	HRRZ A,DIRORG+FDBEXT(D)	; Get pointer to other extensions
	MOVEI B,400100
	SKIPE A
	PUSHJ P,DELCKB		; Check validity
	 SETZ A,		; Truncate chain if bad
	PUSH P,A		; Save for later
	PUSH P,ZERO		; Remember where first version is
	HRRZ A,P		; Initial value of ind pointer
	PUSH P,A		; Onto stack

DELPA:	HRRZ A,FDBVER+DIRORG(D)	; Get pointer to other versions
	MOVEI B,400100
	SKIPE A
	PUSHJ P,DELCKB		; Check validity
	 SETZ A,		; Truncate chain if bad
	PUSH P,A		; Save for later
	HLRZ A,DIRORG+FDBEXT(D)
	MOVSI B,FDBNEX
	TDNE B,FDBCTL+DIRORG(D)
	JUMPE A,DELPG
	MOVEI B,400002
	PUSHJ P,DELCKB		; Check if this has a valid extension
	 JRST [	MOVSI A,FDBNEX
		IORM A,FDBCTL+DIRORG(D)
		HRRZS FDBEXT+DIRORG(D)
		JRST .+1]	; Deletion assured
DELPG:	PUSHJ P,DELTST		; Do we want to delete this?
	 JRST DELP8		; No.
	PUSHJ P,DELFIL
	 JRST DELP8
	JRST DELP9

DELP8:	HRRM D,@-1(P)		; Put this pointer where it belongs
	MOVEI A,FDBVER+DIRORG(D)
	MOVEM A,-1(P)		; Save where to put next pointer
DELP9:	POP P,D			; Get next fdb
	JUMPN D,DELPA		; Loop for all versions
	HRRM D,@0(P)		; End of chain
	SUB P,[XWD 1,1]		; Flush ind pointer
	POP P,D			; Get first version
	JUMPE D,DELPB		; None
	HRRM D,@-1(P)		; Store where it needs to be
	MOVEI A,DIRORG+FDBEXT(D)
	MOVEM A,-1(P)		; Remember where to put next one
DELPB:	POP P,D			; Get loc of next ext
	JUMPN D,DELP7		; Loop thru all extensions
	HRRM D,@0(P)		; End of chain
	SUB P,[XWD 1,1]		; Flush ind pointer
	POP P,D			; Get first extension
	POPJ P,

DELTST:	MOVE A,FDBCTL+DIRORG(D)	; GET CONTROL BITS
	TLNE A,FDBPRM!FDBUND	; PERMANENT AND UNDELETABLE FILES
	TRNN F,10		; CAN ONLY BE DELETED BY CRDIR(KILL)
	 JRST DELTS1		; OTHERWISE, MAKE FURTHER CHECKS
	MOVSI A,FDBPRM		; REMOVE FDBPRM SO FDB WILL BE REMOVED
	ANDCAM A,FDBCTL+DIRORG(D)
	JRST SKPRET		; SKIP TO SAY YES, DELETE IT

DELTS1:	TRNE F,100		; ALL FILES?
	 JRST SKPRET		; YES
	TLNE A,FDBUND		; UNDELETABLE FILE?
	 POPJ P,		; YES, NEVER EXPUNGE IT
	TRNE F,40		; DELETING NON-EXISTENT TYPE FILES?
	TLNN A,FDBNXF!FDBNEX	; YES. IS THIS ONE?
	 JRST DELTS3		; NO.
	JRST SKPRET

DELTS3:	TRNE F,20
	TLNN A,FDBDEL		; YES, IS THIS ONE?
	 JRST DELTS2		; NO.
	JRST SKPRET

DELTS2:	TLNN A,FDBTMP		; TEMP OR SCRATCH FILE?
	 POPJ P,		; NO, RETURN
	HLRZ A,FDBVER+DIRORG(D)
	SUBI A,^D100000		; Get job number of temp file
	CAME A,JOBNO		; Temp file of this job?
	JRST [	TRNE F,4	; No.  Deleting scratch files?
		AOS 0(P)	; Yes. Skip.
		RET]
	TRNE F,2		; This file is temp.  Deleting temp?
	AOS 0(P)		; Yes. Skip.
	POPJ P,			; RETURN

DELFIL::PUSH P,F
	PUSH P,E
	PUSH P,D
	SKIPN A,FDBADR+DIRORG(D)
	JRST DELFI3
	TLO A,(1B1)
	PUSHJ P,ASOFN
	 JRST [	CAIN A,OPNX16
		JRST DELFI3	; Bad index block, forget it
		JRST DELFI1]	; File is open, cannot expunge
	MOVE D,(P)
	PUSH P,A
	MOVEI A,DIRORG(D)	; SET A=FDB ADDR FOR BYTE PTR
	LDB E,PFILPC		; GET PAGES THIS FILE
	POP P,A
	HRRE F,DIRDSK		; GET CURRENT COUNT
	SUB F,E			; COMPUTE NEW CURRENT COUNT
	HRRM F,DIRDSK		; AND SAVE IT
	MOVE E,FDBCTL+DIRORG(D)
	TLNE E,FDBLNG
	JRST DELFI4		; Long file
	PUSHJ P,DELPT
DELFI3:	MOVE D,(P)
	SETZM FDBADR+DIRORG(D)
	SETZM FDBSIZ+DIRORG(D)
	HRLOI B,7777
	ANDCAM B,FDBBYV+DIRORG(D)
	SKIPLE B,DIRORG+FDBACT(D)
	SOS DIRORG+1(B)
	MOVSI B,FDBLNG!FDBSHT
	ANDCAB B,FDBCTL+DIRORG(D)
	TLNN B,FDBPRM
	AOS -3(P)
DELFI1:	POP P,D
	POP P,E
	POP P,F
	POPJ P,

DELPT:	HRLZ 2,1
	MOVEI 1,0
	PUSHJ P,SETPT
	AOS 2
	TRNN 2,777000
	JRST .-3
	HLRZ 1,2
	PUSHJ P,DELOFN
	POPJ P,

DELFI4:	PUSH P,A
	PUSHJ P,ASGPAG
	 JRST [	POP P,A
		PUSHJ P,RELOFN
		JRST DELFI1]
	PUSH P,A
	MOVE B,A
	HRLI B,140000
	MOVE A,-1(P)
	PUSHJ P,SETMPG
	HRLI B,-1000
DELFI6:	SKIPN A,(B)
	JRST DELFI5
	PUSH P,B
	MOVE B,-2(P)		; Get ofn of pt table
	HLLZ B,SPTH(B)		; Get class field
	TLZ B,760017
	TLZ A,40
	IOR A,B
	PUSHJ P,ASOFN
	JRST DELFI8
	PUSHJ P,DELPT
DELFI7:	POP P,B
	SETZM (B)
DELFI5:	AOBJN B,DELFI6
	MOVE B,(P)
	MOVEI A,0
	PUSHJ P,SETMPG
	POP P,A
	PUSHJ P,RELPAG
	POP P,A
	PUSHJ P,DELOFN
	JRST DELFI3
DELFI8:
	CAIN A,OPNX16
	JRST DELFI7
	BUG(HLT,<DELFIL: ASOFN GAVE FAIL RETURN (BUSY) FOR A LONG FILE PAGE TABLE.>)

; Set time and date
; Call:	1	; Date and time in standard format
;	STAD
; Return
;	+1	; Can't set because not wheel or opr
;	+2	; Ok

.STAD::	JSYS MENTR
	HRRZ B,JOBNO		; IS THIS USER LOGGED IN?
	HRRZ B,JOBDIR(B)	; ..
	JUMPE B,STAD3		; NO. BETTER RANGE CHECK THE ANSWER
	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST STAD1		; OK, BY WHEEL OR OPR
STAD3:	SKIPGE TADSEC
	JRST STAD2		; BY ORDINARY USER, BUT NEED DATE/TIME
	MOVEI A,STADX1		; NOT ALLOWED. SET ALREADY.
	JRST ERRD

STAD2:	CAML 1,STADMN		; ORDINARY USER. RANGE CHECK DATE
	CAML 1,STADMX		; MUST BE IN THIS RANGE
	SKIPA			; NO GOOD.
	JRST STAD1		; OK.
	MOVEI A,STADX2		; "RIDICULOUS DATE" ERROR MSG
	JRST ERRD		; AND FAIL.
STAD1:	SETZ C,
	MOVE A,TODCLK
	IDIVI A,^D1000		; Convert to seconds
	XCTUU [HRRZ B,1]	; Get time
	SUB B,A			; Compute offset
	JUMPGE B,.+3
	ADDI B,^D24*^D3600	; If less than 0, augment
	AOJA C,.-2
	XCTUU [HLRZ A,1]
	SUB A,C
	MOVEM A,TADDAY
	MOVEM B,TADSEC
	NOINT			; MAKE SURE IT GETS LOGGED, SINCE IT
	PUSH P,CAPENB		; REALLY IS BEING CHANGED
	MOVEI A,OPR		; SET CAPABILITY FOR EFACT
	IORM A,CAPENB		; ..
	MOVE A,JOBNO		; This job
	HRRZ B,JOBDIR(A)	; User number
	MOVEM B,LOGBUF+1
	UMOVE B,1		; Tad as given
	MOVEM B,LOGBUF+2
	IORI A,(741B8)		; Tad reset code for fact file
	MOVSM A,LOGBUF
	MOVE A,CTRLTT
	DPB A,[POINT 12,LOGBUF,29] ; Tty
	MOVE 1,[XWD -3,LOGBUF]	; Make fact file entry for time set
	EFACT
	 JFCL
	POP P,CAPENB		; RESTORE REAL CAPABILITIES, AND NOW
	OKINT			; SAFE TO ALLOW INTERRUPTS
	JRST SKMRTN

;FOLLOWING IS RANGE OF DATES ACCEPTED IF USER IS NOT A LOGGED-IN WHEEL/OPR
STADMN:	122652,,0		;MIN NON-WHEEL DATE, 29 DEC 74
STADMX:	135424,,0		;MAX DATE IF SUSPICIOUS, 1 JAN 1990

; Read time and date
; Call:	RTAD
; Return
;	+1
;	1	; Current date and time or -1 if not set

.GTAD::	JSYS MENTR
	SKIPGE A+1,TADSEC
IFNDEF RTICLK,<	JRST GTAD1		; Not set>
IFDEF RTICLK,<	JRST [	DATAI 600,B
			CAML B,STADMN	; RANGE CHECK IN CASE PWR FAIL
			CAML B,STADMX
			 SETO B,
			JRST GTAD1]	;RETURN IT FROM CALENDAR CLK>
	MOVE A,TODCLK
	IDIVI A,^D1000
	ADD A,TADSEC
	IDIVI A,^D24*^D3600
	ADD A,TADDAY
	HRL A+1,A
GTAD1:	UMOVEM A+1,1
	JRST MRETN

LS(TADDAY)
LS(TADSEC)



IFDEF RTISW,<

;READ MICROSECOND INTERVAL TIMER

.USEC::	DATAI 610,1
	XCT MJRSTF
>;END IFDEF RTISW


; Set fact switch
;CALL:	1	; MASK OF BITS TO CHANGE
;	2	; New setting
;	SMON
; Traps if process hasn't log privilege
; CHANGED TO REQUIRE WHEEL/OPR INSTEAD OF LOG UNTIL CAPABILITIES ARE
; MORE COMPLETELY IMPLEMENTED

.SMON::JSYS MENTR
	MOVE C,CAPENB
	TRNN C,WHEEL!OPR	; TEMP CHANGED FROM TLNN C,LOG
	ERABRT(EFCTX1)
	ANDCAM 1,FACTSW
	AND 2,1
	IORM 2,FACTSW
	JRST MRETN

; Read fact switch
; Call:	TMON
; Return
;	+1	; Always
;	1	; The current fact switch setting

.TMON::	JSYS MENTR		;MAKE SLOW JSYS SO AOS CAN'T HURT THE
				; RETURN PC BY CARRYING INTO LH
	TDNE 1,FACTSW
	AOS 0(P)		;SKIP RETURN
	JRST MRETN		;RETURN TO USER.

; Enter fact file
; Call:	LH(1)	; Minus entry size
;	RH(1)	; Location of entry
;	EFACT
; Return
;	+1	; Error
;	+2	; Ok

.EFACT::JSYS MENTR
	MOVE B,CAPENB
	TRNN B,WHEEL!OPR	; TEMP CHANGED FROM TLNN B,LOG
	ERR(EFCTX1)
	MOVE B,FACTSW
	TLNN B,(FACTON)
	JRST SKMRTN		; Fact file not on
	HLRO B,A		; Get size
	CAMG B,[-^D64]
	ERR(EFCTX2)		; Too big
	NOINT
	PUSH P,CAPENB		; Save current caps
	MOVEI A,WHEEL+OPR	; Set bits to ensure access to
	IORM A,CAPENB		; Accounts directory and fact file
	MOVEI C,^D30
EFACT2:	HRROI B,[ASCIZ /DSK:<ACCOUNTS>FACT/]
	MOVSI A,1
	GTJFN
	 JRST EFACT3
	PUSH P,1
	MOVE 2,[XWD 440000,20000]
	OPENF			; Open for append
	JRST EFACT4
EFACT6:	POP P,1
	UMOVE C,1
	UMOVE B,(C)
	HLRE D,C
	MOVNS D
	DPB D,[POINT 6,B,35]
	JRST .+2
EFACT1:	UMOVE B,(C)
	BOUT
	AOBJN C,EFACT1
	CLOSF
	BUG(CHK,<EFACT: CLOSF FAILED TO CLOSE FACT FILE.>)
	POP P,CAPENB		; Restore caps
	JRST SKMRTN

EFACT4:	CAIE A,OPNX9
	SETZ C,
	POP P,1
	RLJFN
	 JFCL
	SOJLE C,EFACT3
	MOVEI A,^D4000
	DISMS
	JRST EFACT2

EFACT3:	HRROI 2,[ASCIZ /DSK:<ACCOUNTS>FACT/]
	MOVSI 1,400001
	GTJFN
	 JRST EFACT9
	MOVEI C,^D30
EFACT8:	PUSH P,1
	MOVE 2,[XWD 440000,20000]
	JSYS 21
	JRST EFACT5
	JRST EFACT6

EFACT5:	CAIE A,OPNX9
	JRST EFACT7
	SOJLE C,EFACT7
	MOVEI A,^D4000
	DISMS
	POP P,1
	JRST EFACT8

EFACT7:	POP P,1
	RLJFN
	JFCL
EFACT9:	POP P,CAPENB		; Restore caps
	ERR(EFCTX3)

; Set account for file
; Call:	1	; Jfn
;	2	; String pointer OR 500000000000+account number
;	SACTF
; Return
;	+1	; Error
;	+2	; Ok

.SACTF::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERUNLK(SACTX1)
	PUSHJ P,GETFDB
	 ERUNLK(SACTX4)
	HRLI A,40000
	PUSHJ P,DIRCHK
	 ERUNLK(SACTX4,<UNLOCK DIRLCK>)
	UNLOCK DIRLCK
	PUSH P,FILACT(JFN)	; Save current contents of this cell
	UMOVE A,2
	TLNN A,777777
	HRLI A,440700

SACTF1:	CAMG A,[577777777777]
	CAMGE A,[500000000000]
	JRST SACTF2		; Pointer
	MOVEM A,FILACT(JFN)
	PUSHJ P,INSACT
	JRST SACTF3

SACTF2:	MOVE B,MODES
	HRR B,CAPENB
	TDNN B,[1B1!WHEEL!OPR]
	ERUNLK(SACTX3)		; Alphanumeric accounts not allowed
	PUSHJ P,CPYFUS		; Copy from the user
	 ERUNLK(SACTX2)		; Cannot copy
	HRRZM A,FILACT(JFN)
	HLRE B,A		; GET -(WORD COUNT -1) FROM CPYFUS
	SUBI B,2
	PUSH P,(A)		; SAVE BLOCK HEADER FOR RELFRE
	MOVMM B,(A)		; PLANT COUNT AT HEAD OF STRING STORAGE FOR INSACT
	PUSHJ P,INSACT
	HRRZ B,FILACT(JFN)
	POP P,(B)		; RESTORE BLOCK HEADER FOR RELFRE
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
SACTF3:	POP P,FILACT(JFN)
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Get account of file
; Call:	1	; Jfn
;	2	; Core location to put string if any
;	GACTF
; Return
;	+1	; Error
;	+2
;	2	; 500000000000+number of string pointer

.GACTF::JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	 ERR()
	 JFCL
	 ERR(DESX4)
	TEST(NE,ASTF)
	 ERUNLK(DESX7)
	HRRZ A,NLUKD(DEV)
	CAIE A,MDDNAM
	ERR(GACTX1)
	PUSHJ P,GETFDB
	 ERUNLK(GACTX2)
	SKIPLE B,FDBACT(A)
	JRST GACTF1
	UMOVEM B,2
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	AOS (P)
	JRST SKMRTN

GACTF1:	UMOVE E,2
	HRLI E,440700
	UMOVEM E,2
	HRLI E,DIRORG+2(B)
	HRRZ B,DIRORG(B)
	ADDI B,-3(E)
	XCTMU [BLT E,(B)]
	UNLOCK DIRLCK
	PUSHJ P,UNLCKF
	JRST SKMRTN

; Login
; Accepts:	1/ directory #
;		2/ string pointer to password
;		3/ account designator
; Returns:
;		+1 failed, error # in 1
;		+2 success


JS LGNPAR,1			;A PARAMETER FOR EXEC0 TO FEED LOGIN

.LOGIN::JSYS MENTR
	SKIPLE 1,LGNPAR		;DID EXEC0 SAY WE SHOULD FAIL?
	JRST ERRD		;YES. SO FAIL, WITH THAT CODE.
	MOVE A,JOBNO
	MOVEI B,777777
	TDNE B,JOBDIR(A)	; Is this job currently logged in?
	ERR(LGINX5)
	UMOVE A,1
	PUSH P,A		; Save the dir #
	ADD P,BHC+11			; Allocate string space
	UMOVE B,3			; Get account descriptor
	PUSH P,B			; Save it
	CAML B,[500000,,0]		; Check for string or numeric
	CAMLE B,[577777,,-1]
	 JRST .+2			; Is a string
	JRST LOGIN3
	MOVEI A,-12(P)			; Where to put account string
	HRLI A,(<POINT 7,0,35>)		; As per CPYFU1
	MOVEM A,0(P)			; Update designator
	CALL CPYFU1			; Move from user space
	 BUG(HLT,<LOGIN: Impossible failure of CPYFU1>)
	MOVE B,0(P)			; Account designator
	MOVE A,-12(P)			; Directory #
LOGIN3:	VACCT				; Check validity
	 ERR(LGINX1)			; Nope, doesn't make it
	MOVE A,0(P)			; Designator
IFN PIESLC,<
	ATGRP				; Get pie-slice group name
	 JRST [
		CAIN 1,ACCTX1		; NO WAY TO CHECK?
		 JRST .+1		; ALLOW THE LOGIN
		JRST ERRD]		; FAIL SOME OTHER WAY
>; END OF IFN PIESLC
	EXCH B,-12(P)			; Swap for directory #
	MOVE A,B			; For GETDDB
	PUSHJ P,GETDDB		; Get directory descriptor block
	 ERR(LGINX2)
	MOVE B,DDBGRP(A)
	HLRZ C,FORKN		; C=index of top job fork
	HRRZ C,SYSFK(C)		; Get sys index
	MOVEM B,FKGRPS(C)	; Set user groups - assumes single fork
				; group in job when LOGIN executed
	MOVE B,DDBMOD(A)	; Get mode bits
	MOVEM B,MODES
	TLNE B,(1B0)
	ERR(LGINX2,<UNLOCK DIRLCK>)
	SKIPGE LGNPAR		;CRJOB SAY SKIP PASSWORD CHECK?
	 JRST LOGI0A		;YES, LOGGING IN AS CREATOR
	PUSHJ P,CHKPSW
	  JRST LOGINE		;PASSWORD WRONG
LOGI0A:	MOVE B,DDBPRV(A)
	HRRM B,CAPMSK
	HLLOS CAPENB
	PUSH P,A			; Save DDB index

IFN PIESLC,<
	SKIPN ACTONF			; CAN'T IF THIS IS ON
	SKIPN A,PIEFLG##	;PIE-SLICE DATA FILE MAPPED?
	 JRST LOGIN2		;NO
	MOVE A,-13(P)			; Get pie-slice name off stack
	CALL GRPLUK		;LOOK IT UP
	 JRST LOGI0B			; FAILED TO FIND GROUP NAME
LOGIN2:	PUSH P,A		;SAVE GROUP INDEX
	MOVE A,-2(P)			; Get account designator
> ;END PIE-SLICE SCHEDULER CONDITIONAL

IFE PIESLC,<
	MOVE A,-1(P)			; Account designator
> ; END OF IFE PIESLC
	PUSHJ P,SETACT		; Set account number/string
	 ERR(LGINX1,<UNLOCK DIRLCK>)	; Bad account number

IFN PIESLC,<
	POP P,A
	CALL CHGGRP		;PUT JOB INTO CORRECT GROUP
	CALL ASGDSH##		;RECOMPUTE DSHARE ENTRIES
> ;END PIE-SLICE SCHEDULER CONDITIONAL

	POP P,B				; DDB index
	SUB P,BHC+13			; account desig+string+group
	GTAD
	SKIPL A
	EXCH A,DDBDAT(B)
	XCTUU [EXCH A,1]
	HRLS A
	MOVE B,JOBNO
	MOVEM A,JOBDIR(B)
	HLRZ C,FORKN		; Top job fork
	HRRZ B,SYSFK(C)		; B=its sys fork index
	MOVEM A,FKDIR(B)	; Set fork directories.
	TLO B,-1		; B=FKDIR entry for inferiors
	MOVEI A,0(C)		; A=job index top job fork
	PUSHJ P, MAPINF
	 CALL LOGIN1		; Set FKDIR for inferiors, if any.
	UNLOCK DIRLCK
	PUSHJ P,LOGONM		; Type logon message
	TIME
	MOVEM A,CONSTO
	MOVE A,JOBNO
	SETZM JOBRT(A)
	SETZM CAPENB
	JRST SKMRTN

LOGIN1:	HRRZ C,SYSFK(A)
	MOVEM B,FKDIR(C)	; Set FKDIR of fork
	HRLM A,0(P)
	PUSHJ P, MAPINF
	 CALL LOGIN1
	HLRZ A,0(P)
	POPJ P,

LOGINE:	CALL CHKPSU		; UNLOCK DIRLCK AND DO PSWD THING
	ERR(LGINX4)

LOGI0B:	BUG(NTE,<LOGIN: FAILED TO FIND GROUP NAME>)
	MOVE A,[INIGP]		; DEFAULT GROUP NAME
	CALL GRPLUK
	 BUG(CHK,<LOGIN: COULDN'T FIND SYSJOB GROUP INDEX, GROUP INDICES FOULED?>)
	JRST LOGIN2

; Change account

.CACCT::JSYS MENTR
	MOVE A,JOBNO
	MOVE B,JOBDIR(A)
	TRNN B,777777
	ERR(CACTX2)
	ADD P,BHC+11		; Allocate string space
	JUMPGE P,MSTKOV		; If it overflowed
	UMOVE A,1		; Get account designator
	PUSH P,A
	CAML A,[500000000000]
	CAMLE A,[577777777777]
	 JRST .+3		; Is a string account
	MOVE B,A
	JRST CACCT2
	MOVEI B,-12(P)		; Where to put account string
	HRLI B,(<POINT 7,0,35>)		; As per CPYFU1
	MOVEM B,0(P)		; Patch acct location
	EXCH A,B			; For CPYFU1 too
	CALL CPYFU1
	 BUG(HLT,<CACCT: Impossible failure of CPYFU1>)
	MOVE B,0(P)		; Designator
CACCT2:	SETO A,			; ME
	VACCT			; Verify the pair
	 ERR(CACTX1)
IFN PIESLC,<
	MOVE A,0(P)			; ACCOUNT DESIGNATOR
	ATGRP
	 JRST [
		MOVE A,JOBNO
		MOVE A,PIEGRP(A)
		IMULI A,NWDGRP
		MOVE A,GRPNM(A)
		JRST .+1]	; Use old guy...
> ; End IFN PIESLC
	PUSH P,B		; Save the group name
	MOVE A,-1(P)
	CALL SETACT
	 ERR(CACTX1)
	POP P,A
	SUB P,BHC+11		; Release space
	PUSH P,A		; RESAVE GROUP
	UMOVE B,2		; Get user's bits
	TLNN B,200000		; Bit 1 says don't print on logtty
	 JRST CACCT3
	MOVE B,CAPENB		; Get his enabled cap's
	TRNN B,WHEEL!OPR
	 JRST CACCT3		; Ignore since not a wheel
	CALL LGCJM0		; Don't print it
	CAIA			; Skip over it..
CACCT3:	PUSHJ P,LOGCJM
	POP P,A			;GET PIE-SLICE GROUP NAME
	UMOVE B,2		; Get user bits
	TLNN B,400000		; Don't change group?
	 JRST CACCT4		; Change it
	MOVE B,CAPENB		; Make sure he's allowed
	TRNE B,WHEEL!OPR
	 JRST CACCT1
CACCT4:
IFN PIESLC,<
	SKIPN ACTONF
	SKIPN PIEFLG##		;GROUP FILE MAPPED?
	 JRST CACCT1		;NO
	CALL GRPLUK		;LOOK UP
	 JRST .+4
	CALL CHGGRP		;AND PUT HIM IN IT
	CALL ASGDSH		;RECOMPUTE DSHARE ENTRIES
	JRST CACCT1
	BUG(NTE,<CACCT: GRPLUK did't find pie slice index>)
> ; END PIE-SLICE SCHEDULER CONDITIONAL
CACCT1:
	TIME
	MOVEM A,CONSTO
	MOVE A,JOBNO
	SETZM JOBRT(A)
	JRST SKMRTN

SETACT:	CAML 1,[500000000000]
	CAMLE 1,[577777777777]
	 JRST .+2			; STRING ACCOUNT
	JRST SETACN			; NUMERIC
	MOVE 2,MODES			; CHECK, EVEN THOUGH SHOULD'T 
	TLNN 2,(1B1)			; BE NECESSARY NOW DAYS
	 RET				; STRING ACCOUNT NOT ALLOWED
	PUSH P,C			; SAVE THESE GUYS
	PUSH P,4
	HRRI 2,ACCTSR			; WHERE TO PUT ACCT STR
	HRLI 2,440700			; NICE POINTER
	TLC A,-1			; DEFAULT POINTER?
	TLCN A,-1
	 HRLI 1,440700			; WAS
	MOVEI 4,^D39			; MAXIMUM # OF CHARS
SETAC1:	ILDB 3,1			; GET A CHAR
	SOSG 4				; COUNT CHARS
	MOVEI 3,0			; END OF LINE
	JUMPE 3,SETAC2			; ?
	IDPB 3,2			; PUT DOWN A BYTE
	JRST SETAC1
SETAC2:	IDPB 3,2			; END WITH NULL
	SUBI 2,ACCTSR-2			; GET COUNT AND ADD 2 (FOR HEADER AND USE COUNT)
	HRRZM 2,ACCTSL			; SAVE LENGTH
	HRRI 1,ACCTSR-1
	HRLI 1,(<POINT 7,0,35>)		; MAKE POSITIVE POINTER FOR INSAC0+1
	POP P,4
	POP P,C
SETACN:	MOVEM A,ACCTPT
	JRST SKPRET			; RETURN SUCCESS


;
;	CGRP JSYS, Change pie slice GRouP
;
; Accepts:
;	1/ group name (SIXBIT)
; Returns:
;	+1 failure, error # in 1
;	+2 successful
;
; Requires WHEEL or OPR cap enabled
;

.CGRP::
IFE PIESLC,<
	MOVEI 1,PIEX1			; NOT A PIE SLICE SCHEDULER
	XCT MJRSTF
> ; END OF IFE PIESLC

IFN PIESLC,<
	JSYS MENTR
	MOVE 1,CAPENB			; CURRENTLY ENABLED BITS
	TRNN 1,WHEEL!OPR
	 ERR(WHELX1)			; PEON, TELL HIM SO
	UMOVE 1,1			; GET GROUP NAME
	CALL GRPLUK			; SEE IF EXISTS
	 ERR(CGRPX1)			; DOESN'T
	CALL CHGGRP			; CHANGE HIS GROUP
	CALL ASGDSH			; RE-CALULATE WINDFALL AND SUCH
	JRST SKMRTN			; AND LEAVE
> ; END IFN PIESLC


;
;	VACCT JSYS, verify user account
;
; Accepts:
;	1/ user #, -1 means self
;	2/ account designator
; Returns:
;	+1 failure, error # in 1
;	+2 successful, account/user pair ok
;

.VACCT::JSYS MENTR			; GO SLOW
	SKIPE ACTONF			; CAN WE DO THIS RIGHT?
	 JRST SKMRTN			; NO, SAY IT'S OK
	ADD P,BHC+11			; ALLOCATE STRING SPACE
	JUMPGE P,MSTKOV			; IF STACK OVERFLOWED
	UMOVE 2,1			; GET USER #
	CAMN 2,[-1]			; SELF?
	 JRST [
		MOVE A,FORKX		; US
		SKIPGE B,FKDIR(A)	; POINTER TO US?
		 MOVE B,FKDIR(B)	; YES, GET IT
		HRRZ B,B		; WANT ONLY RIGHT 1/2
		 JRST .+1]
	HRROI 1,-10(P)			; WHERE TO PUT USER NAME
	DIRST	 			; USER NAME
	 ERR(VACX1)			; NO SUCH USER
	UMOVE 3,2			; GET ACCUNT DESIGNATOR
	ADD P,BHC+11			; ALLOCATE ACCOUT SPACE
	JUMPGE P,MSTKOV
	CAML 3,[500000,,0]		; NUMERIC, OR STRING?
	CAMLE 3,[577777,,-1]
	 JRST	VACCT1			; IS A STRING
VACCT2:	MOVE 1,CAPENB
	TRNE 1,WHEEL!OPR
	 JRST SKMRTN			; BELIEVE WHEELS AND OPR'S
	CALL ACTOPN			; OPEN MATRIX AND LOCK
	PUSH P,A
	HRROI 2,-22(P)			; WHERE NAME IS
	TLO 1,400000			; REQUEST INDICES BE RETURNED
	CALL GETB
	 ERR(GBERR1,<POP P,A
			CALL ACTCLS>)	;  USER NOT IN MATRIX
	TRNN 4,2			; NAME & ACCT OK FOR LOGIN?
	 ERR(VACX2,<POP P,A
			CALL ACTCLS>)	; NO
	POP P,A				; JFN
	SUB P,BHC+11			; ACCOUNT SPACE
	SUB P,BHC+11			; NAME SPACE
	CALL ACTCLS			; CLOSE FILE AND UNLOCK
	JRST SKMRTN			; RETURN A SUCCESS

VACCT1:	 MOVE 2,3
	 HRROI 1,-11(P)		; STRING, PUT IT HERE
	 CALL CPYFU1		; COPY FROM USER SPACE
	  BUG(HLT,<VACCT: Impossible failure of CPYFU1>)
	 MOVEI 3,-11(P)
	HRLI 3,(<POINT 7,0,35>)	; WHAT CPYFU1 DID TO US
	JRST	VACCT2

;
;	GDACC JSYS, Get default user account
; Accepts:
;	1/ E for string account
;	2/ user # (-1 for self)
; Returns:
;	+1 failure, error # in 1
;	+2 Successful, account designator in 1
;

.GDACC::JSYS MENTR
	SKIPE ACTONF			; CAN WE DO THIS?
	 ERR(ACCTX1)			; NO DATA FILE
	ADD P,BHC+11			; ALLOCATE NAME SPACE
	JUMPGE P,MSTKOV			; IF STACK OVERFLOWED
	UMOVE 2,2			; USER #
	CAME 2,[-1]			; SELF?
	 JRST GDACC3
	MOVE A,FORKX			; FORK THAT RUNNIN'
	SKIPGE B,FKDIR(A)		; GET DIR #
	 MOVE B,FKDIR(B)		; WAS A POINTER, FETCH REAL GUY
	HRRZ B,B			; WANT ONLY RIGHT 1/2
GDACC3:	HRROI 1,-10(P)			; SPACE FOR NAME
	DIRST
	 ERR(VACX1)			; NO SUCH USER
	HRROI 3,-10(P)			; FOR HASHER
	CALL ACTOPN			; LOCK AND OPEN MATRIX
	PUSH P,A			; SAVE JFN
	MOVE 2,UHASHO			; USER TBL ORIGIN
	HRL 2,UHASHL			; TBL LENGTH
	CALL HASH
	 ERR(GDACX1,<POP P,A
			CALL ACTCLS>)	; USER NAME NOT IN MATRIX
	CAIGE 4,0
	 ERR(GDACX1,<POP P,A
			CALL ACTCLS>)	; NO SUCH USER NAME
	ADD 4,DEFO			; OFFSET FOR DEFAULT TBL
	MOVE 3,4
	RIN
	CAIGE 2,0
	 ERR(GDACX2,<POP P,A
			CALL ACTCLS>)	; NO POINTER?
	MOVE 3,2
	ADD 3,AHASHO			; ACCOUNT TBL ORIGIN
	RIN
	CAML B,[500000,,0]
	CAMLE B,[577777,,-1]
	 JRST .+2			; Is a string account
	JRST GDACC1
	ANDI B,777777			; Only want file position
	SFPTR
	 ERR(GDACX2,<POP P,A
			CALL ACTCLS>)
	HRROI 2,-10(P)			; Where to put the string
	HRLI 2,444400
	HRREI 3,-10			; MAX # WRDS (39 CHARS)
	SIN
	IDPB 4,2			; End it
	MOVEI B,-10(P)
	HRLI B,440700
	CALL MOVSTR			; COPY TO USER SPACE
	UMOVE B,1			; E
	HRLI B,440700
GDACC1:	UMOVEM B,1			; DESIGNATOR TO THE USER
	POP P,A				; JFN
	SUB P,BHC+11
	CALL ACTCLS			; CLOSE FILE ETC.
	JRST SKMRTN

MOVSTR:	UMOVE C,1			; GET E
	HRLI C,440700
MOVST1:	ILDB A,2			; BYTE FROM US
	JUMPE A,MOVST2			; END?
	XCTBU [IDPB A,C]		; INTO USER SPACE
	JRST MOVST1
MOVST2:	XCTBU [IDPB A,C]		; NULL
	RET



;
;	ATGRP JSYS, Account To GrouP
; Accepts:
;	1/ account designator
; Returns:
;	+1 failure, error # in 1
;	+2 success, SIXBIT group name in 2
;

.ATGRP::
IFE PIESLC,<
	MOVEI 1,PIEX1
	XCT MJRSTF> ;END PIESLC
IFN PIESLC,<
	SKIPN ACTONF
	 JRST .+3
	MOVEI 1,ACCTX1
	XCT MJRSTF			; AND RETURN
	JSYS MENTR
	ADD P,BHC+11			; IF STACK OVERFLOWED
	JUMPGE P,MSTKOV			; GO SCREAM
	UMOVE B,1			; GET ACCOUTN DESIG
	CAML B,[500000,,0]
	CAMLE B,[577777,,-1]
	 JRST .+3			; IS A STRING ACCOUNT
	MOVE 3,B
	JRST ATGRP2
	HRROI A,-11(P)			; WHERE TO PUT ACCOUNT STRING
	CALL CPYFU1			; GET IT FROM USER
	 BUG(HLT,<ATGRP: Impossible failure of CPYFU1>)
	MOVEI 3,-11(P)
	HRLI 3,(<POINT 7,0,35>)		; LIKE CPYFU1
ATGRP2: CALL ACTOPN			; LOCK AND OPEN MATRIX
	PUSH P,A			; JFN
	MOVE B,AHASHO			; ACCOUNT ORIGIN
	HRL B,AHASHL			; AND LENGTH
	CALL HASH
	 ERR(ATGPX1,<POP P,A
			CALL ACTCLS>)
	JUMPL D,.-1			; If HASH returns bad index
	ADD D,PRIO			; OFFSET TO PIE NAMES
	MOVE C,D
	RIN
ATGRP3:	UMOVEM B,2			; RETURN TO USER
	POP P,A				; JFN
	CALL ACTCLS			; CLOSE MATRIX & UNLOCK
	SUB P,BHC+11			; RELEASE STRING SPACE
	JRST SKMRTN

>; END PIESLC

;
;	GACTJ - Get ACcounT of Job
;
; Accepts:
;	1/ E for string account (if one)
;	2/ job # (-1 for self)
; Returns:
;	+1 failure, error # in 1
;	+2 Successful, account designator in 1
;

.GACTJ::JSYS MENTR			; SLOW DOWN
	SETZ 5,				; CLEAR FLAG
	UMOVE A,2			; GET JOB #
	CAMN A,[-1]			; SELF?
	 MOVE A,JOBNO			; YES, FETCH IT
	CAIL A,0			; CHECK BOUNDS
	CAILE A,NJOBS			; RANGE
	 ERR(GCTJX1)			; WASN'T ANY GOOD
	CAMN A,JOBNO			; SELF?
	 JRST GACTJ1			; YES, SKIP JSB MAPPING
	SETO 5,				; SAY WE MAPPED A JSB
	SKIPGE JOBRT(A)			; MAKE SURE JOB'S THERE
	 ERR(GCTJX2)			; NO, COMPLAIN
	HRRZ A,JOBPT(A)			; GET TOP FORK INDEX
	HRRZ A,FKJOB(A)			; GET JSB INDEX FOR TOP FORK
	MOVE B,[100000,,JSBPA]		; READ ONLY MAP
	NOINT				; DON'T BOTHER US HERE
	CALL SETMPG
GACTJ1:	MOVE A,ACCTPT			; GET ACCOUNT DESIGNATOR
	SKIPE 5				; NEED STUFF FROM OTHER JSB
	 JRST GACTJ2			; YES
	CAML A,[500000,,0]		; CHECK FOR STRING ACCT
	CAMLE A,[577777,,-1]
	 JRST GACTJ4			; PROCESS AS ONE
GACTJ3:	UMOVEM A,1			; PASS BACK TO USER
	SKIPN 5				; NEED TO UNMAP JSB?
	 JRST SKMRTN			; NO, JUST LEAVE
	MOVEI 2,JSBPA			; WHERE IT IS
	SETZ 1,				; SAY UNMAP IT
	CALL SETMPG
	OKINT				; ALLOW INTS AGAIN
	JRST SKMRTN			; AND LEAVE

GACTJ2:	MOVEI A,ACCTPT
	ANDI A,777
	MOVE A,JSBPA(A)			; GET OTHER GUY'S ACCT DESIG
	CAML A,[500000,,0]
	CAMLE A,[577777,,-1]
	 JRST .+2
	JRST GACTJ3			; IS NUMERIC
	AND A,[-1,,777]			; GET RID OF PAGE #
	IORI A,JSBPA			; POINT TO RIGHT PLACE
GACTJ4:	MOVE B,A
	CALL MOVSTR
	UMOVE A,1
	HRLI A,440700
	JRST GACTJ3



;
; GPSGN - Get Pie Slice Group Name of job
;
; Accepts:
;	1/ TENEX designator
;	2/ job # (-1 for self)
; Returns:
;	+1 error # in 1
;	+2 successful, updated string ptr in 1 (if pertinent)
;

.GPSGN::
IFE PIESLC,<
	MOVEI A,PIEX1			; NOT A PIE SLICE SCHED
	XCT MJRSTF
> ; END IFE PIESLC

IFN PIESLC,<
	SKIPN ACTONF			; VERIFICATION STUFF ON?
	 JRST .+3			; YES
	MOVEI A,ACCTX1			; NOT DOING VERIFICATION
	XCT MJRSTF
	JSYS MENTR
	UMOVE A,2			; GET JOB #
	CAMN A,[-1]			; SELF?
	 MOVE A,JOBNO			; YES, FIX THAT UP
	CAIL A,0			; CHECK JOB RANGE
	CAIL A,NJOBS
	 ERR(GCTJX1)			; OUT OF RANGE
	SKIPGE JOBRT(A)			; DOES JOB EXIST?
	 ERR(GCTJX2)			; NO, COMPLAIN ABOUTHAT
	MOVE A,PIEGRP##(A)		; GET GROUP INDEX
	IMULI A,NWDGRP			; TIMES OFFSET
	MOVE A,GRPNM(A)			; GET SIXBIT ENTRY
	ADD P,BHC+2			; SOME STRING SPACE (6 CHARS)
	MOVE B,[POINT 6,1]		; SIXBIT PTR INTO AC1
	MOVEI C,-1(P)			; WHERE TO PUT STRING
	HRLI C,440700
	MOVEI 5,6
GPSGN2:	ILDB D,B			; GET CHAR
	JUMPE D,GPSGN1			; IF WE HIT END EARLY
	ADDI D,40			; MAKE ASCII
	IDPB D,C
	SOJG 5,GPSGN2
	SETZ D,
GPSGN1:	IDPB D,C			; NULL AT THE END
	HRRZI A,-2(P)			; Where string is, but backed
					; up 1 for JFNSS
	CALL JFNSS			; TO USERS CHOICE
	SUB P,BHC+2
	JRST SKMRTN
> ; END OF IFN PIESLC


ACTINI::SETOM ACTLC2
	SETOM ACTLCK			; INIT LOCK FIRST
	NOINT
	LOCK ACTLCK
	LOCK ACTLC2
	SKIPN ACCIFG			; RELOADING DISK?
	 JRST ACTIN5			; YES, THEN WE CAN'T DO THIS
	SETZM ACTONF			; AND SET TO USABLE
	MOVSI 1,100001
	HRROI 2,ACTFIL			; POINT TO FILE NAME
	GTJFN
	 JRST	ACTIN4
ACTIN2:	MOVE 2,[440000,,203000]		; 36 BIT, RD, THAWED, WB
	OPENF
	 BUG(HLT,<ACTINI: Failed to open UACHK.FILE>)
	MOVEI 3,RHASHO			; ROW ORIGIN
	RIN
	MOVEM 2,UHASHO			; IS USER TBL ORIGIN
	MOVEI 3,RHASHL			; ROW LENGTH
	RIN
	MOVEM 2,UHASHL			; LENGTH OF USER TBL
	MOVEI 3,CHASHO			; COLUMN ORIGIN
	RIN
	MOVEM 2,AHASHO			; IS ACCOUNT ORIGIN
	MOVEI 3,CHASHL			; COLUMN TBL LENGTH
	RIN
	MOVEM 2,AHASHL			; LENGTH OF ACCT TBL
	MOVEI 3,DTABO			; DEFAULT ACCT TBL
	RIN
	MOVEM 2,DEFO			; ORIGIN OF THAT TABLE
	MOVEI 3,PTABO			; PIE SLICE GRP NAMES
	RIN
	MOVEM 2,PRIO			; ORIGIN OF THAT TABLE
	MOVEI 3,MATORG			; Get origin of table
	RIN
	MOVEM 2,MATORA			; And save
	MOVEI 3,MATBSZ			; Get size of bytes in matrix
	RIN
	MOVEM 2,MATBSA
	SETZ 2,
	CLOSF
	 JFCL
	UNLOCK ACTLC2
	UNLOCK ACTLCK
	OKINT
	AOS 0(P)
	RET

ACTIN1::NOINT
	LOCK ACTLCK
	LOCK ACTLC2
	HRROI 2,[ASCIZ/UACHK.FILE/]	; FROM CALLER'S DIR
	MOVSI 1,100001			; SHORT & READ
	GTJFN
	 JRST	ACTIN3
	MOVE 3,1			; SAVE MOMENTARILY
	MOVSI 1,400001			; FOR NEW VERSION
	HRROI 2,ACTFIL			; POINT TO FILE NAME
	GTJFN
	 JRST ACTIN3
	EXCH 3,1			; OTHER JFN
	MOVE 2,3
	RNAMF
	 JRST ACTIN3
	MOVE 1,2			; RECOVER GOOD JFN
	JRST ACTIN2			; PROCEED AS BEFORE

ACTIN4:	BUG(CHK,<ACTINI: Failed to find UACHK.FILE>)
ACTIN5:	SETOM ACTONF
ACTIN3:	UNLOCK ACTLC2
	UNLOCK ACTLCK
	OKINT
	RET	 			; RETURN FAILURE


ACTFIL:	ASCIZ/<SYSTEM>UACHK.FILE/

ACTOPN:	NOINT
	LOCK ACTLCK
	AOS ACTLC2
	UNLOCK ACTLCK
	MOVSI 1,100001			; SHORT & READ
	HRROI 2,ACTFIL
	GTJFN
	 BUG(HLT,<ACTOPN: Unable to find UACHK.FILE>)
	MOVE 2,[440000,,203000]		; 36 BIT, RD, THAWED, WB
	OPENF
	 BUG(HLT,<ACTOPN: Unable to open UACHK.FILE>)
	RET

ACTCLS:	SETZ 2,				; CLOSE UACHK.FILE
	CLOSF
	 JFCL
	SOSGE ACTLC2
	SETOM GLOCK##
	OKINT
	RET


; Definitions of internal error messages

	GRERR1==700000
	GRERR2==700001			; INVALID ROW/COLUMN INDEX
	HHERR1==700002			; HASH TABLE FULL
	PEERR1==700003			; INPUT STRING WAS NULL
	PEERR2==700004			; NOT ENOUGH FREE STORAGE SPACE

IFN 0,< ; ROUTINES NOT USED YET


;
;	This routine accepts a designator and has table descriptor
; and deletes the designator from the has table. If the entry
; points to a string, the string is deleted from the file string storage
;

;
; accepts:
;	1/ an open jfn
;	2/ length,,address of hash table
;	3/ designator
; Returns:
;	+1 failure, error # in 1
;	+2 successful
;

DELETH:	PUSH	P,B			; SAVE LENGTH
	PUSH	P,C			; DESIGNATOR
	PUSHJ	P,HASH			; CALL HASHER
	JUMPL	D,[			; WAS DESIGNATOR FOUND?
		MOVEI	A,DHERR1	; NO
		JRST	ERR1]
	MOVE	C,D			; GET HASH TABLE INDEX
	ADD	C,B			; MAKE AN ADDRESS OF IT
	RIN
	PUSH	P,B			; SAVE ENTRY
	SETO	B,			; MARK IT DELETED
	ROUT
	MOVE	B,0(P)			; RETRIEVE BYTE
	TLC	B,500000		; IS IT A STRING?
	TLNE	B,700000		; ?
	JRST	[
		POP	P,C		; YES
		PUSHJ	P,DELFRE	; RELEASE STRING SPACE
		JRST	ERR1		; RELEASE FAILED
		JRST	.+2]
	POP	P,C			; POP OFF BYTE
	POP	P,C			; RESTORE REGSISTERS
	POP	P,B
	AOS	(P)
	POPJ	P,			; RETURN SUCCESS

ERR1:	POP	P,C			; RESTORE REGS
	POP	P,B
	POPJ	P,			; FAILED



;
;	This routine accepts a pointer to a string in a file free
; storage and deletes it.
;

;
; Accepts:
;	1/ an open jfn
;	3/ pointer
; Returns:
;	+1 failure, error # in 1
;	+2 successful, hash index in 4
;

DELFRE:	PUSH	P,A			; SAVE JFN
	PUSH	P,B
	PUSH	P,C			; POINTER
	HRRZ	B,C			; ADJUST POINTER
	SUBI	B,1			; TO FREE STORAGE HEADER
	PUSH	P,B			; AND SAVE
	MOVEI	C,NFREE			; # PAGES FREE STORAGE
	RIN
	PUSH	P,B			; SAVE FOR LATER
	MOVEI	C,FFREE			; ADDRESS OF FIRST PAGE
	RIN
	PUSH	P,B
	CAMLE	C,-2(P)			; CHECK BOUNDS OF ADDRESS
	 JRST	[
		MOVEI	A,DEERR1	; OUT OF BOUNDS
		JRST	ERR2]
	MOVE	A,-1(P)			; # PAGES
	SUBI	A,1
	LSH	A,^D9			; MAKE IT AN ADDRESS
	SUBI	A,1
	ADD	A,0(P)			; ADDRESS OF FIRST FREE PAGE
	CAMGE	A,-2(P)			; CHECK OTHER BOUND
	 JRST	[
		MOVEI	A,DEERR2	; MISSED ON THE OTHER END
		JRST	ERR2]
	MOVEI	B,500000		; %%% SCRATCH PAGE
	PUSH	P,B
	HRRZ	A,-3(P)			; GET POINTER
	LSH	A,-^D9			; PAGE #
	HRL	A,-5(P)			; JFN
	LSH	B,-^D9			; PAGE #
	HRLI	B,400000		; THIS FORK
	MOVSI	C,140000		; R/W
	PMAP
	MOVE	B,-3(P)			; POINTER
	ANDI	B,777
	ADD	B,0(P)			; ABSOLUTE ADDRESS
	MOVSI	A,0(P)			;
	PUSHJ	P,RELFRE
	SUB	P,[XWD 3,3]
	POP	P,C
	POP	P,B
	SUB	P,[XWD 1,1]
	AOS	(P)
	POPJ	P,

ERR2:	SUB	P,[XWD 4,4]
	POP	P,C
	POP	P,B
	SUB	P,[XWD 1,1]
	POPJ	P,




;
;	This routine accepts a designator and a hash table descriptor
; and enters the designator in its appropriate place (as obtained
; from the hash routine) in the hash table.
;

;
; Accepts:
;	1/ open jfn
;	2/ length,,address of hash table
;	3/ designator
; Returns:
;	+1 failure, error # in 1
;	+2 success
;

ENTERH:	PUSH	P,B			; SAVE IMPORTANT STUFF
	PUSH	P,C			; DESIGNATOR
	PUSHJ	P,HASH			; CALL HASHER
	 JRST	ERR3			; WAS FULL...
	JUMPE	D,[			; FIND THE DESIGNATOR?
		MOVEI	A,EHERR1	; YES, AND 
		PUSH	P,D		; THAT'S 
		JRST	ERR3]		; WRONG
	PUSH	P,D			; SAVE INDEX FROM PUTFRE'S WRATH
	TLC	C,500000		; CHECK FOR STRING
	TLNE	C,700000
	JRST	[			; IT IS
		PUSHJ	P,PUTFRE	; PUT IT IN STRING SPACE
		JRST	ERR3		; FAILED
		JRST	.+1]
	TLC	C,500000		; REPAIR DESIGNATOR
	MOVE	B,C			; SET UP FOR ROUT
	TLC	C,500000		; CHECK FOR NUMERIC
	TLNE	C,700000
	HRR	B,D			; FILE ADDRESS OF STRING
	HRRZ	C,0(P)			; INDEX INTO HASH TABLE
	ADD	C,D			; FILE ADDRESS OF HASH TABLE
	ROUT
	AOS	-4(P)			; SKIP RETURN
ERR3:	POP	P,D
	POP	P,C
	POP	P,C
	POP	P,B
	POPJ	P,

> ; END OF ROUTINES NOT IN USE



;
;	This routine accepts row and column indicies, relative to 0,
; and returns a standard PDP10 byte pointer in 3. This pointer can
; then be used to acces the desired byte.
;

;
; Accepts:
;	1/ open jfn
;	2/ row,,column indices (rel 0)
; Returns:
;	+1 failure, error # in 1
;	+2 successful, byte pointer in 3
;

GBPTR:	PUSH	P,B			; SAVE ROW,,COLUMN
	HLRZ B,B			; ROW INDEX
	CAMLE B,UHASHL			; IN USER RANGE?
	 JRST	[
		MOVEI	A,GRERR1	; ERROR NUMBER
		JRST	ERR4]
	HRRZ	B,0(P)			; COLUMN INDEX
	CAMLE B,AHASHL			; WITHIN ACCT LIMITS?
	 JRST	[
		MOVEI	A,GRERR2	; TO BIG
		JRST	ERR4]
;  Now compute byte number in matrix
	MOVE B,AHASHL
	HLRZ	C,0(P)			; GET ROW INDEX
	IMUL	B,C			; BYTES/COLUMN
	HRRZ	C,0(P)			; GET COLUMN INDEX
	ADD	B,C			; BYTE INDEX INTO MATRIX
	PUSH	P,B			; SAVE IT FOR NOW
	MOVE	C,MATBSA		; COMPUTE BYTES/WORD
	MOVEI	B,^D36
	IDIV	B,C			; BYTES/WORD
	MOVE	C,B			; COMPUTE WORD INDEX & BYTE
	MOVE	B,0(P)			; INDEX INTO WORD
	IDIV	B,C			; B=WORD INDEX, C=BYTE INDEX
	PUSH	P,B			; SAVE THEM
	MOVE B,MATORA			; GET MATRIX ORIGIN
	ADD	B,0(P)			; ADD WORD INDEX
	MOVEM	B,0(P)			; SAVE
	ADDI	C,1			; COMPUTE "P" PORTION OF POINTER
	IMUL	C,MATBSA
	MOVEI	B,^D36
	SUB	B,C
	LSH	B,^D30			; PUT IN THE RIGHT PLACE
	MOVE	C,MATBSA		; NOW "S" PORTION
	LSH	C,^D24
	IOR	B,C
	IOR	B,0(P)			; BRING IN THE WORD PORTION
	SUB	P,[XWD 2,2]		; CLEAN UP STACK
	MOVE	C,B			; RETURN POINTER IN 3
	POP	P,B			; RESTORE 2
	AOS	(P)			; SUCCESSFUL RETURN
	POPJ	P,

ERR4:	POP	P,B
	POPJ	P,			; FAILED, ERROR # IN 1





;
;	This routine accepts a row and column index and returns
; the corresponding matrix entry.
;

;
; Accepts:
;	1/ open jfn
;	2/ row,,column (indicies rel 0)
; Returns:
;	+1 failure, error # in 1
;	+2 successful, byte in 3
;

GBYTE:	PUSHJ	P,GBPTR			; CONVERT TO POINTERS
	 POPJ	P,			; RETURN FAILURE
	PUSH	P,B			; SAVE INDICIES
	PUSH	P,C			; SAVE POINTER
	ANDI	C,777777		; SAVE ONLY WORD INDEX
	RIN				; GET THE WORD WITH THE BYTE
	MOVEI	C,B			; ADDRESS OF WORD
	HRRM	C,0(P)			; SAVE AS RH OF POINTER
	LDB	C,0(P)			; GET THE BYTE
	POP	P,B			; POINTER IS NOW GARBAGE
	POP	P,B			; INDICES
	AOS	(P)			; SUCCESSFUL
	POPJ	P,



;
;	This routine accepts row and column designators and returns
; the byte which exits at their intersection in the matrix.
;

;
; Accepts:
;	1/ open jfn, if b0=1, return hash tbl indices in 5&6
;	2/ row designator
;	3/ column designator
; Returns:
;	+1 failure, error # in 1
;	+2 successful, byte in 4
;

GETB:	PUSH	P,A			; SAVE JFN
	PUSH	P,B			; ROW DESIGNATOR
	PUSH	P,C			; COLUMN DESIGNATOR
	TLZ	A,400000		; TURN OFF B0 IF ON
	HRL	B,UHASHL		; ARRANGE AS LEN,,ORG
	HRR	B,UHASHO
	MOVE	C,-1(P)			; ROW DESIGNATOR
	PUSHJ	P,CALLH			; CALL HASH CALLER
	 JRST	ERR5			; HASH FAILED
; ROW INDEX NOW IN 4
	HRL	D,D			; SAVE IT IN LH
	PUSH	P,D
	SKIPGE	-3(D)			; SAVING INDICIES?
	HRRZ	5,D			; YES
; NOW DO ABOVE CRAP FOR COLUMN
	HRL	B,AHASHL
	HRR	B,AHASHO		; LEN,,ORG IN 2
	MOVE	C,-1(P)			; COLUMN DESIGNATOR
	PUSHJ	P,CALLH			; CALL HASH CALLER
	 JRST	[
		POP	P,B		; EXTRA STUFF
		JRST	ERR5]
; COL INDEX NOW IN D
	HRRM	D,0(P)			; ROW,,COL INDICES
	SKIPGE	-3(P)			; RETURNING INDICIES?
	MOVE	6,D
	POP	P,B
	PUSHJ	P,GBYTE
	 JRST	ERR5
	MOVE	D,C			; RETURN THE BYTE
	POP	P,C
	POP	P,B
	SUB	P,[XWD 1,1]
	AOS	(P)			; SUCCESSFUL RETURN
	POPJ	P,

ERR5:	POP	P,C
	POP	P,B
	SUB	P,[XWD 1,1]
	POPJ	P,

CALLH:	PUSHJ	P,HASH			; CALL THE HASHER
	POPJ	P,			; DIDN'T
	SKIPGE	D			; WAS IT FOUND?
	 JRST	[
		MOVEI	A,GBERR1	; NOPE
		POPJ	P,]
	AOS	(P)
	POPJ	P,



	G==7
	H==10
	I==11
	J==12
	K==13
	L==14
	M==15
	N==16

;	THIS ROUTINE ACCEPTS A HASH TABLE DESCRIPTION (ADDRESS
;	AND LENGTH) AND A DESIGNATOR. IT HASHES ON THE DESIGNATOR
;	IN AN ATTEMPT TO FIND THE CORRESPONDING ENTRY IN THE HASH
;	TABLE, IF IT EXISTS. IF IT DOES NOT EXIST, IT WILL
;	RETURN THE LOCATION OF AN ENTRY SUITABLE FOR MAKING A NEW
;	ENTRY. IF SPACE FOR THE LATTER CANNOT BE FOUND (THE TABLE
;	IS FULL), THE ROUTINE INDICATES THIS BY ITS ERROR RETURN.

;	CALLING SEQUENCE:

;	AC1=AN OPEN JFN
;	AC2=LENGTH,,ADDRESS OF HASH TABLE
;	AC3=THE DESIGNATOR

;	RETURNS:
;	+1 IF ERROR. ERROR CODE IN AC1
;	+2 IF SUCCESSFUL. INDEX INTO HASH TABLE IN AC4.
;		B0=0 -> ENTRY WAS FOUND
;		B0=1 -> ENTRY NOT FOUND. INDEX POINTS TO LOC. WHICH
;			CAN BE USED FOR NEW ENTRY.
;	NOTE THAT THE DESIGNATOR CAN BE EITHER A VALUE OR A POINTER
;	TO AN ASCIZ-TYPE STRING. THEY ARE DISTINGUISHED BY THE PRESENCE
;	OF OCTAL 5 IN THE HIGH ORDER DIGIT, INDICATING THE LOW ORDER
;	33 BITS ARE TO BE TREATED AS THE VALUE TO BE USED FOR HASHING.

;	AC USE:

;	A: CONTAINS JFN
;	B: RESERVED TO RECEIVE WORDS FROM FILE (RIN)
;	C: CONTAINS CURRENT FILE WORD INDEX
;	D: CONTAINS ADDRESS OF HASH TABLE
;	E: CONTAINS LENGTH-1 OF HASH TABLE
;	F: CONTAINS DESIGNATOR
;	G: USED TO RETAIN FIRST PROBE ADDRESS
;	H: USED TO RETAIN ADDRESS OF FIRST DELETED ENTRY
;	I: FILE WORD INDEX OF LAST ENTRY IN HASH TABLE
;	J: WORK REGISTER
;	K: WORK REGISTER
;	L: WORK REGISTER
;	M: WORK REGISTER
;	N: WORK REGISTER


HASH:	PUSH P,B			; Save b,c & d
	PUSH P,C
	PUSH P,D
	HRRZ	D,B	;ADDRESS OF HASH TABLE
	HLRZ	5,B	;LENGTH OF HASH TABLE
	SUBI	5,1	;LESS ONE

	MOVE 	6,C	;DESIGNATOR

	TLC 6,-1			; DEFAULT POINTER?
	TLCN 6,-1
	 HRLI	6,440700	;MAKE IT A VALID BYTE POINTER

	MOVE	I,D
	ADD	I,5	;POINTER TO LAST ENTRY

	SETZ	H,	;INITIALIZE

;NOW APPLY INITIAL HASH FUNCTION
	PUSHJ	P,HASH1	;RETURNS WITH PROBE ADDRESS IN C, CONTENTS IN B
	MOVE	G,C	;SAVE INITIAL PROBE ADDRESS

;TEST FOR EMPTY CELL
TESTEM:	JUMPE	B,EXITNF	;CELL IS EMPTY, EXIT

;TEST FOR DELETED CELL. SAVE ADDRESS OF DELETED CELL IF IT IS FIRST ONE
;ENCOUNTERED.
	CAMN	B,[-1]
	JRST	[JUMPE H,NEXT
		MOVE H,C
		JRST NEXT]

;TEST FOR DESIGNATOR EQUALITY
	PUSHJ	P,COMPAR
	JRST	EXITF	;THEY'RE EQUAL, EXIT.

;APPLY SUCCESSOR FUNCTION.
NEXT:	ADDI	C,1

	CAILE	C,0(I)	;HAVE WE GONE OFF THE END OF THE TABLE?
	MOVE 	C,D	;YES, RESET TO BEGINNING

	CAIN	C,0(G)	;ARE WE BACK TO INITIAL PROBE LOCATION?
	JRST	NOEMPT	;YES

	RIN		;GET THE ENTRY
	JRST	TESTEM	;GO BACK AND DO CHECKS

;EXIT, RETURNING FIRST DELETED ENTRY FOUND
NOEMPT:	JUMPE	H,[MOVEI A,HHERR1	;NO DELETED ENTRIES,TABLE IS FULL
		JRST	ERREX]

	MOVE	C,H	;GET FIRST DELETED ENTRY FOUND

;EXIT, INDICATING ENTRY NOT FOUND. RETURN LOCATION IN C.
EXITNF:	TLOA	C,400000	;SET HIGH ORDER BIT AND SKIP

;EXIT, INDICATING ENTRY FOUND. RETURN LOCATION IN C.
EXITF:	TLZ	C,400000	;RESET HIGH ORDER BIT -- NO SKIP
	SUB	C,D	;RETURN INDEX INTO HASH TABLE (NOT ADDRESS)
	MOVE D,C			; Return index
	POP P,B				; Junk
	POP P,C
	POP P,B
	AOS	0(P)	;RETURN +2
	POPJ	P,

;ERROR EXIT
ERREX:	POP P,D
	POP P,C
	POP P,B
	POPJ	P,	;RETURN+1


;COMPARISON ROUTINE FOR NUMERIC OR STRING DESIGNATORS
COMPAR:	CAML 6,[500000,,0]
	CAMLE 6,[577777,,-1]
	 JRST	COMPST		;ITS STRING

;DO COMPARISON OF NUMERIC DESIGNATORS
	CAME	6,B
	AOS	0(P)	;RETURN+2 IF UNEQUAL
	POPJ	P,

;DO STRING COMPARISON

;THE STRING POINTED TO BY THE HASH TABLE ENTRY (WHICH IS SITTING IN B)
;IS READ FROM THE FILE A WORD AT A TIME INTO B. THE BYTES ARE EXTRACTED
;FROM B TO K USING A BYTE POINTER IN M.
;THE ARGUMENT STRING IS ACCESSED VIA THE BYTE POINTER IN F (WHICH IS
;PRESERVED ACROSS THE CALL TO THIS ROUTINE ON THE STACK).
;THE BYTES ARE EXTRACTED TO L. K AND L ARE COMPARED; IF UNEQUAL, THE
;"UNEQUAL" EXIT IS TAKEN. IF EQUAL, K IS TESTED FOR ZERO WHICH
;INDICATES END-OF-STRING. IF ZERO, THE "EQUAL" EXIT IS TAKEN; ELSE
;COMPARISON PROCEEDS WITH THE NEXT BYTES.
COMPST:	PUSH	P,C	;SAVE C ON STACK
	CAML B,[500000,,0]
	CAMLE B,[577777,,-1]
	 JRST COMP3			; IS A STRING
	BUG(CHK,<HASH: UACHK.FILE is probably screwed up>)
	SETOM ACTONF			; TURN OFF IF CONTINUED
COMP3:	HRRZ	C,B	;MOVE STRING ADDRESS TO C FOR RIN.
	PUSH	P,6	;SAVE F ON THE STACK
	PUSH P,16			; SAVE THIS TOO
	RIN		;GET FIRST WORD OF STRING
	SKIPA
COMPL:	BIN		;GET NEXT WORD
	MOVE	M,[XWD 440700,B]	;SET UP BYTE POINTER
	MOVEI 16,5			; # CHARS IN A WORD
COMPL2:	SOJL 16,COMPL			; HAVE WE DONE 5 BYTES?
	ILDB	K,M	;GET BYTE FROM B
	ILDB	L,6	;GET BYTE FROM ARGUMENT STRING
	CAIE	K,0(L)	;ARE THEY EQUAL?
	 JRST	[POP P,16
		POP P,6	;NOT EQUAL
		POP P,C
		AOS 0(P)	;RETURN +2
		POPJ P,  ]

;THEY'RE EQUAL. ARE THEY ZERO?
	JUMPN	K,COMPL2	;NOT ZERO, CONTINUE COMPARISON

;TAKE "EQUAL" EXIT
	POP P,16
	POP	P,6	;RESTORE F
	POP	P,C	;RESTORE C
	POPJ	P,

;PRIMARY HASHING FUNCTION FOR NUMERIC AND STRING DESIGNATORS
HASH1:	MOVE K,6
	TLC K,500000
	TLNE K,700000
	 JRST	HASHST	;ITS A STRING

;APPLY HASH FUNCTION TO VALUE IN K
HASH2:	SETZ	B,	;PREPARE FOR DIVIDE
	MOVE	C,K
	DIV	B,5	;K MOD LENGTH
	ADD	C,D	;PLUS ORIGIN OF TABLE

	RIN		;FETCH THE ENTRY

	POPJ	P,	;AND EXIT

;PREPROCESS STRING SO WE CAN HASH ON IT
;THE WORDS CONTAINING THE STRING ARE BYTE-WISE REVERSED AND
;XOR'ED TOGETHER.
HASHST:	SETZ	K,	;CLEAR RECEIVING AC
	MOVE	J,6	;GET STRING POINTER

XLUP1:	MOVEI	N,5
	SETZ	M,

XLUP2:	ILDB	L,J	;GET A BYTE
	JUMPE	L,[XOR K,M
		JRST HASH2]

	LSHC	L,-7	;SHIFT BYTE INTO M
	SOJG	N,XLUP2	;DO ANOTHER IF M NOT FULL

	XOR	K,M	;M FULL, XOR IT INTT K
	JRST	XLUP1




IFN 0,< ; ROUTINES NOT IN USE YET


;
;	This routine accepts a row and column index and a byte
; and deposits the byte in the matirx
;

;
; Accepts:
;	1/ open jfn
;	2/ row,,column (indices rel 0)
;	3/ byte
; Returns:
;	+1 failure, error # in 1
;	+2 succesful
;

PBYTE:	PUSH	P,C	;SAVE C
	PUSHJ	P,GBPTR
	 JRST	[POP P,C
		POPJ P, ]

	PUSH	P,B	;SAVE INDICES
	PUSH	P,C	;SAVE BYTE POINTER

	ANDI	C,777777	;LEAVE ONLY THE WORD INDEX INTO FILE
	RIN		;GET THE WORD CONTAINING THE BYTE TO B
	PUSH	P,C	;SAVE WORD INDEX

;NOW FIX THE POINTER
	MOVEI	C,B
	HRRM	C,-1(P)
	MOVE	C,-3(P)	;GET THE BYTE PROVIDED BY CALLER
	DPB	C,-1(P)	;DROP IT INTO THE WORD

	POP	P,C	;RESTORE THE WORD INDEX
	ROUT		;PUT THE WHOLE THING BACK

	POP	P,C	;POP PAST SAVED BYTE POINTER
	POP	P,B	;RESTORE B
	POP	P,C	;RESTORE C
	AOS 	0(P)	;RETURN +2
	POPJ	P,	;AND LEAVE




;
;	This routine accepts row and column designators and a byte and
; desposits the byte at the designators intersection in the matrix
;

;
; Accepts:
;	1/ open jfn
;	2/ row designator
;	3/ column designator
;	4/ byte
; Returns:
;	+1 failure, error # in 1
;	+2 successful
;

PUTB:	PUSH	P,B			; SAVE ROW DESIGNATOR
	PUSH	P,C			; AND COLUMN
	PUSH	P,D			; AND OF COURSE THE BYTE
	MOVEI	C,RHASHO		; GET ROW HASH ORIGIN
	RIN
	MOVE	D,B			; SAVE FOR A MOMENT
	MOVEI	C,RHASHL		; GET HASH LENGTH
	RIN
	HRLZ	B,B			; MAKE IT LENGTH,,ORG
	HRR	B,D
	MOVE	C,-2(P)			; ROW DESIGNATOR
	PUSHJ	P,CALLH			; CALL HASH CALLER
	 JRST	ERR6			; DIDN'T WORK TOO WELL
; ROW INDEX NOW IN D
	HRL	D,D			; SET UP AS ROW,,COL
	PUSH	P,D			; AND HOLD FOR A SEC
; NOW DO ABOVE CRAP FOR COLUMN
	MOVEI	C,CHASHO		; COLUMN HASH ORG.
	RIN
	HRL	D,B			; SAVE 'DAT
	MOVEI	C,CHASHL		; COLUMN LENGTH
	RIN
	HLL	B,D			; ORG,,LEN
	MOVE	C,-2(P)			; COLUMN DESIGNATOR
	PUSHJ	P,CALLH
	 JRST	[			; DIDN'T PAN OUT TOO WELL
		POP	P,D		; GARBAGE NOW
		JRST	ERR6]		; CLEAN UP AND FAIL
; COL INDEX NOW IN D
	POP	P,B			; OTHER 1/2
	HRR	B,D			; ROW,,COL
	MOVE	C,0(P)			; BYTE
	PUSHJ	P,PBYTE			; HAVE HIM DO IT
	 JRST	ERR6			; THAT FAILED
	POP	P,D			; FIXUP EVERYTHING
	POP	P,C
	POP	P,B
	AOS	(P)
	POPJ	P,			; RETURN A SUCCESS

ERR6:	POP	P,D
	POP	P,C
	POP	P,B
	POPJ	P,			; FAILED, SO TELL'EM



; THIS ROUTINE ACCEPTS A STRING POINTER AS ARGUMENT. IT
; OBTAINS FILE FREE STORAGE LARGE ENOUGH TO HOLD THE STRING
; AND COPIES THE STRING TO THE FILE. THEEFILE ADDDRESS OF THE
; STRING IS RETURNED.

;	CALLING SEQUENCE:

;	AC1: AN OPEN JFN
;	AC3: THE DESIGNATOR

;	RETURNS:
;	+1: ERROR
;	+2: SUCCESSFUL. FILE ADDRESS OF STRING IN AC4

; AC USE:
;
;	A: ARGUMENT REGS FOR JSYS'S AND ASGFRE
;	B: SAME
;	C: SAME
;	D: SAME
;	E: THE JFN
;	F: THE DESIGNATOR
;	G: NUMBER OF PAGES OF FILE FREE STORAGE
;	H: FILE ADDRESS OF FIRST FREE STORAGE PAGE
;	I: ADDRESS OF PAGE TO BE USED TO MAP THE FILE PAGE
;	J: WORK REG
;	K: WORK  REG
;	L: WORK REG
;	M: WORK REG

LAST=M		;LAST REG TO SAVE ON STACK


PUTFRE:	PUSH	P,A			; SAVE HIM
	MOVSI	A,2			; START BLT AT 2
	HRR	A,P			; WHERE TO PUT 'EM
	AOS	A			; STACK GETS INCREMENTED LATE
	ADD	P,[XWD 14,14]		; SAVE 12. REGS
	BLT	A,(P)			; ONTO THE STACK
	MOVE	A,-14(P)		; RETRIEVE THE JFN

;DO HOUSEKEEPING
	MOVE	E,A	;MOVE TH JFN

	MOVE	F,C	;MOVE THE DESIGNATOR

	MOVEI	C,NFREE
	RIN
	MOVE 	G,B	;GET THE NUMBER OF PAGES OF FREE STOR

	MOVEI	C,FFREE
	RIN
	MOVE	H,B	;GET THE FILE ADDRESS OF THE  FREE STOR PG

;NOTE: THE FOLLOWING INSTRUCTION SHOULD BE REPLACED BY A CALL TO
;ASGPAG WHEN AND IF THESE ROUTINES GO INTO THE SYSTEM
	MOVEI	I,500000

;NOW SCAN THE INP&T STRING TO DETERMINE ITS LENGTH
	SETO	J,	;USED TO COUNT BYTES
	MOVE	K,F	;GET ADDRESS OF STRING
	HRLI	K,440700	;MAKE A LEGAL BYTE POINTER

CLOOP:	ILDB	L,K	;GET A BYTE
	ADDI	J,1	;INCREMENT COUNT

	JUMPN	L,CLOOP	;GO GET ANOTHEE IF NOT ZERO

	JUMPLE	J,[MOVEI A,PEERR1
		JRST ERR7]

	IDIVI	J,5	;5 BYTES PER WORD
	ADDI	J,2	;J=NUMBER OF WORDS NEEDED

	LSH	H,-^D9	;TRANSFORM TO PAG NUMBER

;NOW GET THE FREE STORAGE
NXTPG:	HRR	A,H	;PUT FILE PAGE INTO RH OF A
	HRL	A,E	;JFN TO LH

	HRRZ	B,I	
	LSH	B,-^D9	;CORE PABE TO RH OF B
	HRLI	B,400000	;FORK DESIGNATOR TO LH

	MOVSI	C,140000	;INDICATE READ AND WRITE ACCESS

	PMAP

;NOW CALL ASGFRE
	MOVE	B,J	;NUMBER OF WORDS NEEDED
	MOVSI	A,I	;INDEX,,0
	PUSHJ	P,ASGFRE
	 JRST	[ADDI H,1
		SOJG G,NXTPG

		MOVEI	A,PEERR2
		JRST ERR7]
	ADDI	A,1	;INCREMENT PAST HEADER

;FREE STORAGE BLOCK POINTED TO BY A. COPY STRING TO IT
	MOVE	J,F	;GET STRING DESIGNATOR
	HRLI	J,440700	;MAKE IT A BYTE POINTER

	MOVE	M,A	;SAVE POINTER TO BLOCK
	MOVE	K,A
	HRLI	K,440700

COPY:	ILDB	L,J	;GET BYTE
	IDPB	L,K	;DEPOSIT IT
	JUMPN	L,COPY	;NOT ZERO

;UNMAP THE PAGE
	SETO	A,
	HRRZ	B,I
	LSH	B,-^D9
	HRLI	B,400000
	PMAP

;RETURN
	SUB	M,I	;GET DISP INTO PAGE
	LSH	H,^D9	;RESTORE PAGE ADDRESS
	ADD	M,H

	MOVEM	M,-11(P)		; STORE VALUE ON STACKIN REG D

	SUB	P,[XWD 14,14]		; # WE'RE TAKING OFF
	MOVSI	A,(P)			; WHERE THEY ARE
	HRRI	A,2			; WHERE TO PUT THEM
	ADD	A,[1,0]			; FUDGE A LITTLE
	BLT	A,15
	POP	P,A			; AND THIS GUY TOO
	AOS	0(P)
	POPJ	P,

;ERROR EXIT
ERR7:	SUB	P,[XWD 14,14]
	MOVSI	A,(P)			; WHERE GET REGS
	HRRI	A,2			; WHERE TO PUT THEM
	ADD	A,[XWD 1,0]
	BLT	A,15			; RESTORE REGS
	SUB	P,[XWD 1,1]		; LEAVE ERROR # THERE
	POPJ	P,



;
;	This routine accepts row and column designators and row and
; column increments which define a scan pattern. it also accepts a mask
; which is applied to each byte extracted from the matrix. If all masked
; bits are set, the scan terminates, returning the byte and the current
; row and column indices.
;


;
; Accepts:
;	1/ open jfn
;	2/ row index,,col index
;	3/ row inc,,col inc
;	4/ mask
; Returns:
;	+1 failure, error # in 1
;	+2 successful, updated indices in 2, byte in 5
;

SCAN:	PUSH	P,B			; SAVE INDICES
	PUSH	P,C			; INCREMENTS
NEXT1:	ADD	B,0(P)			; ADD INCREMENT
	PUSHJ	P,GBYTE			; PICK UP A BYTE
	 JRST	SCERR			; NO SUCH BYTE
	TDC	C,D			; APPLY MASK
	TDNE	C,D
	 JRST	NEXT1			; NOGOOD
	TDC	C,D			; RETURN THIS BYTE
	MOVEM	B,-1(P)			; AND UPDATED INDICES
	MOVE	5,C			; THE BYTE
	POP	P,C
	POP	P,B
	AOS	(P)			; GOOD RETURN
	POPJ	P,

SCERR:	POP	P,C
	POP	P,B
	POPJ	P,
> ; END OF ROUTINES NOT IN USE




IFN PIESLC,<
;ROUTINE TO CONVERT PIE-SLICE GROUP NAME TO AN INDEX.
;CALLED WITH SIXBIT GROUP NAME IN AC1.
;RETURNS +1 : NO SUCH GROUP
;        +2 : GROUP INDEX IN AC1.
;ALL ACS ARE PRESERVED (EXCEPT 1).
GRPLUK:: JUMPE A,R##		;DONT SEARCH IF ARG IS ZERO
	PUSH P,B
	PUSH P,C

	MOVEI B,NGRPS		;NUMBER OF PIE-SLICE GROUPS
	SETZ C,

GRPLU1:	CAMN A,GRPNM(C)		;DOES IT MATCH THIS ENTRY?
	 JRST GRPLU2		;YES

	ADDI C,NWDGRP		;ON TO NEXT ENTRY
	SOJG B,GRPLU1		;IF THERE IS ONE

GRPLU3:	POP P,C
	POP P,B
	RET

GRPLU2:	MOVN A,B
	ADDI A,NGRPS
	AOS -2(P)
	JRST GRPLU3

;ROUTINE TO CHANGE PIE-SLICE GROUP INDEX FOR A JOB. NEW INDEX IS
;IN AC1. RETURNS +1 ALWAYS.
CHGGRP:	ADD P,BHC+7		;COVER SPACE FOR ACS
	JUMPGE P,MSTKOV##	;IF STACK OVERFLOWS
	MOVEM 2,-6(P)
	MOVEI 2,-5(P)
	HRLI 2,3
	BLT 2,0(P)		;SAVE ACS 2-10

	NOINT
	LOCK GRPLOK## ;NO DSHARE UPDATING WHILE THIS HAPPENS

	MOVE 10,JOBNO		;GET JOB NUMBER
	MOVE 2,PIEGRP(10)	;GET CURRENT GROUP
	SOS NJBGRP##(2)		;REDUCE COUNT OF JOBS PER GROUP

	MOVSI 3,-NUFKS		;GET READY TO LOOP THRU SYSFK
	MOVSI 4,RNLS##		;BIT IN FKFLGS THAT IDENTIFIES ACTIVE
				;PROCESS
	MOVSI 5,(-1.0)		;WE'LL NEED THESE LATER
	MOVSI 6,(1.0)

	SKIP SYSFK		;TOUCH BEFORE GOING NOSKED
	NOSKED
CHGGR3:	HRRZ 7,SYSFK(3)		;GET INDEX FOR FORK IN THIS JOB
	CAIN 7,-1		;THIS SLOT IN USE?
	 JRST CHGGR4		;NO
	TDNN 4,FKFLGS##(7)	;ACTIVE FORK?
	 JRST CHGGR4		;NO
	FADRM 5,NAPROC##(2)	;YES, REDUCE ACTIVE PROCESS COUNT
				;FOR OLD GROUP
	FADRM 6,NAPROC(1)	;AND INCREASE FOR NEW ONE
CHGGR4:	AOBJN 3,CHGGR3		;DO IT AGAIN IF ANY LEFT
	MOVEM 1,PIEGRP(10)	;RECORD NEW GROUP INDEX
	OKSKED
	AOS NJBGRP(1)		;INCREASE COUNT OF JOBS PER GROUP
	UNLOCK GRPLOK
	OKINT

	HRLZI 10,-6(P)		;GET READY TO RESTORE ACS
	HRRI 10,2
	BLT 10,10
	SUB P,BHC+7
	RET

> ; END PIE-SLICE SCHEDULER CONDITIONAL


;PASSWORD CHECK FOR INTERNAL USE
; 1/ directory number
; 2/ password string ptr

PASSWC:	MOVEI A,0(A)
	PUSH P,2
	PUSHJ P,GETDDB
	 JRST [	POP P,2
		POPJ P,]
	POP P,2
	PUSHJ P,CHKPSX
	 JRST CHKPSU		; UNLOCK DIRLCK, DO PSWD FAILURE THING
	AOS 0(P)
	UNLOCK DIRLCK
	POPJ P,

CHKPSW:	UMOVE B,2
CHKPSX:	PUSH P,A
	PUSH P,B
	PUSH P,[^D39]		;MAXIMUM CHARS IN PASSWORD
	HLRZ B,DDBNAM(A)	; Get pointer to password
	JUMPE B,CHKPS2		;NO PASSWORD
	MOVE C,DIRORG+1(B)
	TLNN C,774000
	JRST CHKPS2		; Null password never matches
	HRLI B,(<POINT 7,0,35>)
	ADDI B,DIRORG
	EXCH B,-1(P)		;GET BACK PTR TO USER SUPPLIED PSWD
	TLC B,777777		; IF LH -1, CHANGE TO 0
	TLCN B,777777		; AND IF IT BECAME 0
	 HRLI B,(<POINT 7,0>)
CHKPS1:	TLZ B,37		; BE SURE NO INDIRECTION/INDEXING
	XCTBU [ILDB A,B]	;GET CHR FROM STRING SUPPLIED
	ILDB C,-1(P)		;AND ONE ACTUAL PASSWORD
	CAME A,C
	 SETZM -1(P)		;INDICATE FAILURE
	SOSLE 0(P)		;QUIT IF 39 CHARS PROCESSED
	 JUMPN A,CHKPS1
	SKIPE -1(P)		;SKIP IF NO MATCH
	 AOS -3(P)		;CAUSE SKIP RETURN
CHKPS2:	SUB P,BHC+2		;ADJUST STACK POINTER
	POP P,A
	POPJ P,

; PASSWORD FAILURE ROUTINE CALLED BY ALL CALLERS OF CHKPSX AFTER
; DIRECTORY LOCKS ARE CLEARED

CHKPSU:	UNLOCK DIRLCK		; ENTER HERE TO UNLOCK DIRECTORY FIRST
CHKPSF:	MOVEI A,WHEEL+OPER
	TDNE A,CAPENB		; ENABLED WHEEL/OPERATOR?
	 POPJ P,		; YES. JUST FAIL
	TIME			; NO. GET NOW
	SUB A,CONSTO		; TIME ON CONSOLE
	IDIV A,[^D<1000*60*60>]	; IN HOURS
	ADDI A,1		; GRACE PERIOD
	IMULI A,5		; ALLOW 5 ERRORS PER HOUR
	AOS PASFCT		; COUNT PASSWORD FAILURES (THIS JOB)
	CAML A,PASFCT		; RATE EXCEEDED?
	 POPJ P,		; NO, JUST FAIL
	HRROI B,[ASCIZ /
EXCESSIVE PASSWORD FAILURE RATE.
/]
	SETZ C,
	MOVEI A,777777
	SKIPL CTRLTT
	 SOUT
	MOVE A,OPTT##		; GET THE OPERATOR CONSOLE
	CAIN A,377777		; IS NIL?
	 JRST CHKPS3		; YES, SKIP NOTIFICATION PART
	PUSH P,CAPENB
	MOVEI B,OPER
	MOVEM B,CAPENB		; INSURE ABILITY TO PRINT ON OP CONSOLE
	HRROI B,[ASCIZ /EXCESSIVE PASSWORD FAILURE RATE IN JOB /]
	SETZ C,
	SOUT
	MOVE B,JOBNO
	MOVEI C,12
	NOUT
	 JFCL
	HRROI B,[ASCIZ /, USER /]
	SETZ C,
	SOUT
	MOVE B,JOBNO
	HRRZ B,JOBDIR(B)	; GET LOGIN DIRECTORY
	JUMPE B,[		; IF NOT LOGGED IN
		HRROI B,[ASCIZ /NOT LOGGED IN /]
		SOUT
		JRST CHKPS4]
	DIRST
	 MOVE A,OPTT
CHKPS4:	HRROI B,[ASCIZ /
  TERMINAL /]
	SOUT
	SKIPGE B,CTRLTT
	 JRST [	HRROI B,[ASCIZ /DETACHED/]
		SOUT
		JRST CHKPS5]
	MOVEI C,10
	NOUT
	 MOVE A,OPTT
IFDEF IMPCHN,<
	CAIG B,NVTHI
	CAIGE B,NVTLO
	 JRST CHKPS5		; NOT NVT
	LDB B,PTNETI##		; GET NET UNIT NUMBER OF LINE
	EXCH B,UNIT
	LDB UNIT,PFHST##	; GET HOST NUMBER
	EXCH UNIT,B
	PUSH P,B
	HRROI B,[ASCIZ /, HOST /]
	SETZ C,
	SOUT
	POP P,B
	CVHST
	 NOUT
	  MOVE A,OPTT
>
CHKPS5:	HRROI B,[ASCIZ /
/]
	SETZ C,
	SOUT
	HRROI B,[ASCIZ /OPERATOR NOTIFIED.
/]
	MOVEI A,777777
	SKIPL CTRLTT
	 SOUT
CHKPS3:	MOVE A,JOBNO
	HRRZ A,JOBPT(A)		; GET FORKX OF TOP FORK
	MOVSI B,400000+PSILOB##
	IORM B,FKINT##(A)	; SET LGOUT PSI BIT
	POP P,CAPENB
	POPJ P,

; Connect to directory
; Call:	1	; Directory number (b0 for check of pswd only
;				    b1 proxy conn - change "login" dir
;				    b2 connect fork in 4 as spec'd
;				    by other bits)
;	2	; String pointer to password
;	CNDIR
; Return
;	+1	; Error
;	+2	; Ok

.CNDIR::JSYS MENTR
;	UMOVE A,1		; DIRNUM + BITS
	UMOVE B,3		; DEVICE DESIGNATOR
	PUSHJ P,SETUNT
	 ERR()
	MOVE A,JOBNO
	HRRZ B,JOBDIR(A)	; Get directory of login
	UMOVE A,1
	HLLZ D,A		; D=function bits
	TLZ A,-1
	JUMPL D,CNCHK		; Check only wanted
	CAIN B,0		; Must be logged in to connect
	ERR(CNDIX5)
	TLNE D,(1B2)		; Connecting other fork?
	JRST CNDIRA		; Yes, check handles, etc.
CNDIR0:	MOVE B,FORKX
	SKIPGE B,FKDIR(B)
	JRST [	TLNE D,(1B1)	; Proxy?
		ERR(CNDIX6)	; Yes, only legal in top fork of group
		MOVE B,FKDIR(B)
		JRST .+1 ]
CNDIR1:	CAIN A,0(B)
	JRST CNDIR5		; Can always connect to login directory
	PUSH P,D		; Save D smashed by GETDDB
	PUSHJ P,GETDDB
	 JRST [	POP P,D
		TLNE D,(1B2)	; Other fork?
		CALL CNDIRR	; Yes, resume forks
		ERR(CNDIX3) ]	; No such directory
	MOVE B,CAPENB
	TRNE B,WHEEL!OPR
	JRST CNDIR2		; Bypass checks for wheels and oprs
	HLRZ B,DDBNAM(A)	; Does this directory have a password
	JUMPE B,CNDIR3		; No
	PUSHJ P,CHKPSW		; Yes, check it
	 JRST CNDIR3		; Wrong password, still ok if access
CNDIR2:	POP P,D			; Restore function flags
	TLNN D,(1B1)		; Correct password - proxy?
	JRST CNDIR4		; No
	JRST CNDIR6		; Yes, reset groups and capabilities

CNDIR3:	POP P,D
	TLNE D,(1B1)		; Proxy?
	JRST CNDIEE		; Yes, password required
	UNLOCK DIRLCK
	UMOVE A,1
	HRRZS A
	MOVEI B,-1		; Need to pick up real dsk unit
	PUSH P,D		; Save flags
	PUSHJ P,SETDIR		; Map the directory
	 JRST CNDIRQ
	MOVSI A,XCTF
	PUSHJ P,DIRCHK		; Do we have the proper access to this
	JRST CNDIRE
	POP P,D
CNDIR4:	UNLOCK DIRLCK
CNDIR5:	UMOVE A,1
	NOINT			; Prevent CFGRP by superiors
	TLNE D,(1B2)		; Other fork?
	JRST [	HRRZ B,0(P)
		JRST CNDI55]	; B=FORKX of top fork in group
	MOVE B,FORKX
	SKIPGE C,FKDIR(B)
	MOVEI B,(C)		; B=FORKX of top fork in group
CNDI55:	HRLM A,FKDIR(B)		; Set connected dir
	MOVE C,JOBNO
	HRRZ E,JOBPT(C)
	CAIN E,0(B)		; Top fork in group=top fork in job?
	HRLM A,JOBDIR(C)	; Yes, change JOBDIR
	TLNE D,(1B1)
	HRRM A,FKDIR(B)		; For proxy change user/login dir
	TLNN D,(1B2)
	 JRST SKMRTN
	CALL CNDIRR		; For other fork connect, resume frozen
	SUB P,BHC+2
	JRST SKMRTN

CNCHK:	HRRZS A
	PUSH P,D
	PUSHJ P,GETDDB
	 ERR(CNDIX3)
	PUSHJ P,CHKPSW
	JRST CNDIRE
	UNLOCK DIRLCK
	JRST SKMRTN

CNDIRQ:	BUG(CHK,<CNDIR - SETDIR FAILED>)
	POP P,D
	TLNE D,(1B2)
	CALL CNDIRR
	MOVEI 1,CNDIX3
	JRST ERRD

CNDIRE:	POP P,D
CNDIEE:	JUMPL D,.+3
	TLNE D,(1B2)
	CALL CNDIRR
	CALL CHKPSU		; UNLOCK DIRLCK AND DO PSWD THING
	MOVEI 1,CNDIX1
	JRST ERRD

CNDIR6:	MOVE B,DDBGRP(A)	; B=user groups
	TLNE D,(1B2)		; Connecting other forks?
	JRST CNDIR9
	MOVE C,FORKX		; Proxy request legal only in top fork
	MOVEM B,FKGRPS(C)
	HRRO B,DDBPRV(A)	; B=user capabilities
	HRRZ C,FORKN
	SETZ A,
	CALL CNDIR8		; Reset capabilities
	JRST CNDIR4

CNDIR7:	HRRZ C,SYSFK(A)		; C=SYSFK index
	SKIPL FKDIR(C)		; Fork top fork in group
	RET			; Yes, return
CNDIRG:	MOVEI C,0(A)
	PUSHJ P,SETLF1		; map fork's PSB
CNDIR8:	HRRM B,CAPMSK(A)	; Set possible mask
	ANDM B,CAPENB(A)	; Set enabled mask
	MOVEI A,0(C)
	HRLM A,0(P)
	PUSHJ P, MAPINF
	 CALL CNDIR7
	HLRZ A,0(P)
	POPJ P,

CNDIR9:	MOVE C,0(P)		; C=FORKX of top fork in group
	MOVEM B,FKGRPS(C)	; Set group bits
	HRRO B,DDBPRV(A)
	HLRZ A,C		; A=Sys index of top fork in group
	CALL CNDIRG
	JRST CNDIR4

CNDIRR:	MOVE A,-2(P)		; A=index of frozen fork
	CALL RFORK1
	RET


CNDIRA:	UMOVE A,4		; A=USER FORK
	CALL RLJBFK		; GET JOB INDEX
CNDIRB:	ERR(FRKHX1)		; NO SUCH FORK
	HRRZ B,SYSFK(A)		; B=FORKX OF FORK
	CAMN B,FORKX		; THIS FORK?
	JRST CNDIRF		; YES, TREAT AS ORDINARY CNDIR
	MOVEI C,0(A)		; C=JOB INDEX OF FORK
	HRRZ E,FORKN		; FIND IMMED INF OF EXECUTING FORK THAT
	CAIA			; IS SUPERIOR TO FORK SPEC'D BY USER
CNDIRC:	MOVEI A,0(C)		; A=FORK
	ADD C,SUPERP
	LDB C,C			; C=FORK'S SUPERIOR
	CAIN C,0(E)		; SUPERIOR OF FORK IN A = THIS FORK?
	JRST .+3		; YES, FORK IN 1 IS DESIRED FORK
	JUMPN C,CNDIRC
	ERR(FRKHX2)		; ATTEMPT TO MANIPULATE SUPERIOR
	PUSH P,A		; SAVE FORK TO FREEZE
	PUSH P,B		; SAVE FORKX OF FORK SPEC'D BY USER
	PUSH P,D
	NOINT			; PREVENT SUPERIORS FROM INTERFERING
	CALL FFORK1		; FREEZE FORKS TO PREVENT POSSIBLE
	POP P,D			; RACES WITH CNDIRS, CFGRPS
	POP P,B
	SKIPGE FKDIR(B)
	HRRZ B,FKDIR(B)		; B=FORKX OF TOP FORK IN GROUP
	CAMN B,FORKX		; EXECUTING FORK=TOP FORK IN GROUP?
	JRST CNDIRD		; YES, TREAT AS ORDINARY CNDIR
	MOVSI A,-NUFKS		; FIND JOB FORK INDEX OF TOP FORK
	HRRZ C,SYSFK(A)		; IN GROUP
	CAIN B,0(C)
	JRST .+3
	AOBJN A,.-3
	JRST [	POP P,A		; Can't find fork
		CALL RFORK1	; RESUME FROZEN FORKS
		JRST CNDIRB ]	; ERROR RETURN
	TLZ A,-1		; FOR SKIIF CALL
	CALL SKIIF		; IS TOP FORK INF TO EXECUTING FORK?
	JRST CNDIRD		; NO, TOP FORK OF GROUP SPEC'D BY USER
				; IS TOP OF EXECUTING FORK'S GROUP
	HRL B,A
	PUSH P,B		; 0(P)=JOB,,SYS INDEX TOP FORK IN GROUP
	MOVE B,FKDIR(B)		; -1(P)=JOB INDEX FORK FROZEN
	UMOVE A,1
	TLZ A,-1
	JRST CNDIR1

CNDIRD:	POP P,A			; A=INDEX OF FROZEN FORK
	PUSH P,D
	CALL RFORK1		; RESUME FROZEN FORKS
	POP P,D
CNDIRF:	TLZ D,(1B2)		; CLEAR B2 FUNCTION
	UMOVE A,1
	TLZ A,-1
	JRST CNDIR0		; RESUME AS ORDINARY CNDIR

; Determine access to a directory and/or file.

; Call:	1/	Flags,,Directory (target)
;		B0: Accept file protection in 2, return file access in 2
;		B1: Accept directory number in 3, do proxy GFACC
;	2/	File protection (numeric) if B0 of AC1 on.
;	3/	Directory number (source) if B1 of AC1 on.
;	GFACC
; Returns
;	+1	Error, error code in 1
;	+2	Success, directory access in 1, file access in 2 if
;		B0 of AC1 on in call

.GFACC::JSYS MENTR
	UMOVE E,1		; Get function bits and target dir
	TLNE E,(1B1)		; Proxy GFACC?
	JRST GFACC1		; Yes
	MOVE A,FORKX		; No, get fork number
	MOVE B,FKGRPS(A)	; Get group word if top of fork group
	SKIPGE A,FKDIR(A)	; Get conn,,login dir if top of fork grp
	JRST .-2		; Not top, FKDIR was fork# of top
	JRST GFACC2

; Doing proxy GFACC -- make sure privileged and find out for whom
GFACC1:	MOVE A,CAPENB		; Wheel or operator enabled?
	TRNN A,WHEEL+OPER
	 ERR(WHELX1)		; No, error
	UMOVE A,3		; User # for whom GFACC is being done
	PUSHJ P,GETDDB		; Get DDB for user
	  ERR(GFACX1)	; Not there
	MOVE B,DDBGRP(A)	; Ok, get groups of this user
	UMOVE A,3		; Get dir # again
	PUSHJ P,USTDIR		; Unlock index

; Here with A/ connected,,login dir #'s of requestor,
;	    B/ user group membership word of requestor
GFACC2:	PUSH P,A		; Save requestor dir #
	PUSH P,B		; Save user group word
	HRRZ A,E		; Get target dir #
	PUSHJ P,HSHLUK		; Lookup in index
	  ERR(GFACX1,<PUSHJ P,USTDIR>)
	UNLOCK DIRLCK		; Unlock index but remain NOINT
	MOVE C,CAPENB
	TRNE C,WHEEL+OPER	; Wheel or operator?
	TLNE E,(1B1)		; And not doing proxy GFACC?
	JRST GFACC3		; No, do normal stuff
	MOVEI A,77		; Yes, return all access for directory
	MOVEI D,-^D18		; Set shift count to return file access
	JRST GFACC4		; Bypass directory lookup

; Here with A/ target directory number
GFACC3:	SETO B,			; Default disk unit arg
	PUSHJ P,MAPDIR		; Map the directory
	POP P,D			; Get back user group word of requestor
	AND D,DIRGRP		; Find common user and directory groups
	SKIPE D			; User belong to directory group?
	MOVEI D,-6		; Set to right-justify group protection
	POP P,A			; Restore requestor dir #(s)
	HLRZ B,A		; Connected dir if any
	HRRZS A
	CAME A,DIRNUM		; Checking access to own directory?
	CAMN B,DIRNUM		; Or to connected directory?
	MOVEI D,-^D12		; Yes, set to right-justify owner prot.
	MOVE A,DIRPRT		; Get directory protection word
	LSH A,(D)		; Right-justify appropriate field
	ANDI A,77

; Here with A/ directory access,
;	    D/ shift count for right-justifying protection field
GFACC4:	JUMPGE E,GFACC5		; Jump if not also checking file access
	UMOVE B,2		; Get protection word from caller
	TLC B,500000		; Only numeric protections allowed
	TLCE B,-1
	ERR(GFACX2)		; Illegal protection
	LSH B,(D)		; Ok, right-justify appropriate field
	ANDI B,77
	TRNE A,40		; Have access to target directory, and
	TRNN A,20		; Access to open files?
	SETZ B,			; No, return no access to file
	UMOVEM B,2		; Return file access bits
GFACC5:	UMOVEM A,1		; Return directory access bits
	JRST SKMRTN

	END
