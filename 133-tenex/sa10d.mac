;<DALE>SA10D.MAC;3  12-AUG-74 11:36:41  EDIT BY DALE
;<DALE>SA10D.MAC;2   9-AUG-74 12:07:40  EDIT BY DALE
;<OP-CHASE>SA10D.MAC;3    21-JUL-74 16:56:40	EDIT BY OP-CHASE
;<OP-CHASE>SA10D.MAC;2    21-JUL-74 16:32:16	EDIT BY OP-CHASE
;<CLEMENTS>SA10D.MAC;12    31-MAY-74 14:36:05    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;11    29-MAY-74 17:35:16    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;10    28-MAY-74 16:50:09    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;9    28-MAY-74 16:46:39    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;7    28-MAY-74 13:33:01    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;6    28-MAY-74 12:51:56    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;5    28-MAY-74 12:31:11    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;4    28-MAY-74 12:12:38    EDIT BY CLEMENTS
;<CLEMENTS>SA10D.MAC;3    28-MAY-74 12:07:20    EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;40    26-APR-74 18:34:37	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;39    26-APR-74 14:43:24	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;38    25-APR-74 13:52:32	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;37    25-APR-74 13:40:57	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;36    24-APR-74 18:20:22	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;35    24-APR-74 13:54:52	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;34    23-APR-74 19:18:37	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;33    23-APR-74 18:48:21	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;32    23-APR-74 14:43:07	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;31    22-APR-74 20:58:21	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;30    22-APR-74 19:26:27	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;29    22-APR-74 17:32:25	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;28    22-APR-74 17:12:44	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;27    22-APR-74 14:22:58	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;26    16-APR-74 18:19:42	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;25    16-APR-74 16:25:11	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;22     7-APR-74 15:38:37	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;21     7-APR-74 15:08:25	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;20     7-APR-74 14:10:02	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;20     7-APR-74 14:06:37	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;19     7-APR-74 14:04:34	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;18     7-APR-74 13:33:18	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;17     5-APR-74 20:58:34	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;16     5-APR-74 18:28:43	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;14     5-APR-74 10:00:21	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;13     4-APR-74 19:15:40	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;12    13-MAR-74 13:53:12	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;11    28-FEB-74 15:14:34	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;10    28-FEB-74 12:57:36	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;9    28-FEB-74 12:39:29	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;7    20-FEB-74 20:42:25	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;6    20-FEB-74 11:22:50	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;5    20-FEB-74 11:16:05	EDIT BY CLEMENTS
;<CLEMENTS>SA10.MAC;2    19-FEB-74 16:40:29	EDIT BY CLEMENTS

TITLE SA10 - DIAGNOSTIC FOR SYSTEMS CONCEPTS SA-10 IBM-TO-DEC SUBSYSTEM ADAPTER

A=1
B=2
C=3
D=4
E=5
F=6
G=7
H=10
I=11
J=12
K=13
L=14
CN=15		;SA-10 subchannel (*10)
BF=16		; BUSY FLAGS, FOR LIGHT WATCHERS. B0-7 MEAN DRIVE
		;  0-7 WAITING FOR DEVICE END. RH IS MOST RECENT INT DV
P=17		; PUSHDOWN POINTER

;;what is this bullshit about B or C???
;;if this is an ISI assembly, you had better let CV=1!!!
IFNDEF CV,<
CV==1>		; 0 FOR B, 1 FOR C (HARDWARE POINTER LAYOUTS)
IFLE CV,<
CNTSFT==2>	;SHIFT IN LH FOR COUNT
IFG CV,<
CNTSFT==6>	; ..
IFNDEF EADR,<
EADR==0>	;22 BIT ADDRESS FEATURE
IFNDEF BASE,<
BASE==160>	;CHNL 0 GO ADR
SA0==274	;DEVICE NUMBER OF SA-10
IDEV==300	;DEVICE TO USE FOR UCODE SIM
;;the following are now memory to allow run-time modification of channel assignments
;;IFNDEF DCHAN,<DCHAN==1>		;DISK SUBCHANNEL
;;IFNDEF TCHAN,<TCHAN==0>		;TAPE SUBCHANNEL
;;IFNDEF PCHAN,<PCHAN==1>		; PRINTER SUBCHANNEL
APRCH==2	;PI CH FOR TIME, PAR ERR, AND NXM
IFNDEF RECL,<
RECL==1000>	;LENGTH OF RECORD ON DISK
NRPT==^D5	;NUMBER OF RECORDS PER TRACK
IFNDEF NPACKS,<
NPACKS==^D3>	;NUMBER OF DISK PACKS TO RUN IN DSKT
IFNDEF NCHN,<
NCHN==2>	;# OF CHANNELS SIMULATED BY THIS
		;  PARTICULAR SA-10 (2 OR 4)
SA0CH==1	;PI CHANNEL IN DISK ROUTINE
NBF==20		; # OF BYTES IN RING BUFFER (FIFO) IN EACH CHANNEL
NRETRY==^D8	; TIMES TO REREAD A CORRECTABLE DATA CHECK
NBADSP==100	; NUMBER OF BADSPOTS TO REMEMBER

;MACROS FOR WORD POINTERS DEPENDING ON WHICH KIND OF SA10 (B OR C)

DEFINE CW (BYTS)	;device command word
	<BYTE (8)BYTS>
DEFINE TIC (LOC)	;transfer in channel
	<1B1+LOC>
IFE CV,<
	DEFINE IOW(CT,ADR)
	<-CT*4,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*4,,ADR>>
IFN CV,<
	DEFINE IOW(CT,ADR)
	<-CT*100,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*100,,ADR>>

;BITS FOR CONO
RSTSA==400000	;RESET WHOLE SCHMEER, START CLOCK
CLMERR==200000	;CLEAR MEMORY ERROR FLAGS
SASTEP==1000	;STOP CLOCK IF RUNNING; STEP IT IF STOPPED
SACGO==1040	;START CLOCK
RSTCH==300	;RESET CHANNEL SPECIFIED BY 10 AND 20 BITS
CLBSY==400	;CLEAR BUSY FLAG OF CHANNEL . . .
STBSY==440	;SET BUSY FLAG OF CHANNEL . . .
CLSRQ==500	;CLEAR STATUS REQUEST FLAG OF CHANNEL . . .
STSRQ==540	;SET STATUS REQUEST FLAG OF CHANNEL . . .
CLSTF==600	;CLEAR STATUS FLAG OF CHANNEL . . .
STSTF==640	;SET STATUS FLAG OF CHANNEL . . .
CLPIE==700	;CLEAR PI ENABLE OF CHANNEL . . .
STPIE==740	;SET PI ENABLE OF CHANNEL . . .

;CERTAIN OF ABOVE BITS ALSO SELECT WHAT DIAGNOSTIC WORD WILL
;BE READ BY THE NEXT DATAI TO BE EXECUTED, AS FOLLOWS:

RDCCI==0	;READ CHANNEL SELECTED (BITS 16, 17); CON-
		;TENTS OF CBUS (BITS 18-25); MICRO-PROGRAM
		;COUNTER (BITS 26-35)
RDMA==10	;READ MEMORY ADDRESS REGISTER (BITS 16-35)
RDMBL==20	;READ CHANNEL REFERENCING MEMORY (BITS 16,
		;17); LEFT HALF OF MEMORY BUFFER (BITS 18-
		;35).  THIS M.B. IS ONLY FOR DATA GOING
		;TOWARDS THE MEMORY.
RDMBR==30	;READ PARITY BIT OF MEMORY BUFFER (BIT 17);
		;RIGHT HALF OF MEMORY BUFFER (BITS 18-35)
RDCONI==40	;READ THE "CLOCK RUNNING" BIT (BIT 16); THE
		;"MEMORY SUBROUTINE BUSY" BIT (BIT 17); AND
		;THE SAME DATA SENSED BY CONI (BITS 18-35)
;CONTINUED ON NEXT PAGE


RDBITS==50	;READ SOME MISCELLANEOUS BITS:
		;BITS 16 AND 17 SPECIFY WHICH CHANNEL IS
		;USING THE MEMORY
	WRRQ==400000	;CURRENT MEM CYCLE IS A WRITE
	MUXACK==200000	;ACKNOWLEDGE FROM MEMORY PORT
	MEMACK==100000	;ACKNOWLEDGE FROM MEMORY
	MBUSDN==40000	;MEMORY BUS FINISHED
	MDNSYN==20000	;MEMORY DONE SYNC
	RDDIAG==10000
	IOFWR==4000
	CHRST==2000
	RESET==1000
	BRANCH==400	;THE MICRO-INSTRUCTION WHICH IS
			;ABOUT TO BE EXECUTED IS GOING TO BRANCH
;LOW 3 BITS ARE PI CHANNEL ASSIGNMENT

;BITS FOR CONI, CONSZ, CONSO
PIRQ==400000	;THIS SA-10 IS REQUESTING AN INTERRUPT
PARERR==200000	;PARITY ERROR IN SOME WORD (COMMAND OR
		;DATA) READ FROM MEMORY
NXM==100000	;SA-10 TRIED TO REFERENCE NON-EX MEMORY
PIE0==40000	;PI ENABLE FLAG FOR CHANNEL 0
PIE1==20000	; . . . CHANNEL 1
PIE2==10000	; . . . CHANNEL 2
PIE3==4000	; . . . CHANNEL 3
BSY0==2000	;BUSY FLAG FOR CHANNEL 0
BSY1==1000	; . . . CHANNEL 1
BSY2==400	; . . . CHANNEL 2
BSY3==200	; . . . CHANNEL 3
STF0==100	;STATUS FLAG FOR CHANNEL 0
STF1==40	; . . . CHANNEL 1
STF2==20	; . . . CHANNEL 2
STF3==10	; . . . CHANNEL 3
;LOW 3 BITS ARE PI CHANNEL ASSIGNMENT

HANGPC==64	;MAGIC PLACE TO STICK MICRO-PROGRAM COUNTER
		; THIS IS A MICRO-CODE PC. NOT A PDP-10 ADDRESS

;DEFS FOR TAPE
TRECL==2000	; RECORD LENGTH ON TAPE
TUNIT==340

GOGO:	JRST DDTE
DDTG:	MOVE A,116
	MOVEM A,36
	MOVE A,117
	MOVEM A,32
	JRST DDT
DDTE:	SKIPN SUPER0
	JRST DDT
	MOVE A,SUPER0
	MOVEM A,36
	MOVE A,SUPER1
	MOVEM A,32
	SETZM SUPER0
	JRST DDT


RSTALL:	;clear out the world...
	CONSZ TTY,20		;let TTY output finish..
	JRST .-1
	CONO 635550		;total reset..
	CONO 020000		; (turn off auto-restart of KI)
	MOVEI 10000
	SOJG .
	POPJ P,

CSET:	;setup for a particular SA-10 subchannel
	MOVEM CN,CHAN
	LSH CN,2
	ADDI CN,BASE
	MOVEM CN,CBASE
	ADDI CN,1
	MOVEM CN,CBASE+1
	ADDI CN,1
	MOVEM CN,CBASE+2
	MOVE CN,CHAN
	DPB CN,[030200,,STBSYC]
	DPB CN,[030200,,CLSTFC]
	DPB CN,[030200,,STPIEC]
	LSH CN,3
	POPJ P,0

DCHAN:	0	;disk subchannel
PCHAN:	1	;printer subchannel
TCHAN:	1	;tape subchannel

CHAN:	0
CBASE:	BLOCK 3
STBSYC:	STBSY+SA0CH
CLSTFC:	CLSTF+SA0CH
STPIEC:	STPIE+SA0CH

BEG:	MOVEI P,PDL-1
	PUSHJ P,RSTALL
	CLEARM PIE	;NO INTERRUPTS ARE EXPECTED
	CONO PI,11577
	MOVE A,[JSR UUOH]
	MOVEM A,41	;INITIALIZE MAGIC MEMORY LOACTIONS
	MOVE A,[JSR INT1]
	MOVEI B,42	;ALL INTERRUPT ROUTINES ARE SAME LENGTH
PISETL:	MOVEM A,(B)
	ADDI A,INT2-INT1
	ADDI B,2
	CAIE B,60
	JRST PISETL
	CONO SA0,RSTSA!CLMERR
;SEE IF CHANNEL COUNTER COUNTS WHEN CLOCK IS STEPPED
	MOVEI B,2*NCHN
BEG1A:	DATAO SA0,[0]
	CONO SA0,SASTEP!RDCCI
	DATAI SA0,A
	LSH A,-22	;FLUSH CBUS AND MICRO-P.C.
	TDNE A,[-1_2]
	JRST ERR1	;DATAI READ IN EXTRANEOUS BITS
	JUMPN A,BEG1	;WAIT UNTIL WE GET TO CHANNEL 0
	MOVSI A,-NCHN	;CLEAR OUT COUNT TABLE
BEG20:	CLEARM CCTBL(A)
	AOBJN A,BEG20
	MOVEI B,100*NCHN
BEG2:	DATAO SA0,[0]	;GET THE THING A NO-OP TO EXECUTE
	CONO SA0,SASTEP!RDCCI
	DATAI SA0,A
	LSH A,-22
	ANDI A,-1_<-44+2>
	AOS CCTBL(A)	;NOTE THAT THIS CHANNEL HAS BEEN COUNTED
	SOJG B,BEG2
	MOVSI A,-NCHN	;MAKE SURE ALL CHANNELS GOT SERVICE
BEG21:	SKIPN CCTBL(A)
	JRST ERR3	;THIS GUY DIDN'T GET COUNTED
	AOBJN A,BEG21	;CHECK THE OTHERS
;FALL THRU

;MAKE SURE ALL BITS OF MICRO-P.C. CAN BE SET
	MOVEI B,1777
	PUSHJ P,STEPC0
IARL:	DATAO SA0,B
	PUSHJ P,STEP0
	ANDI A,1777
	CAME A,B
	JRST ERR4	;MICRO-P.C. NOT BEING SET PROPERLY
	DATAO SA0,[040000]	;CBUS_IARB
	DATAI SA0,A
	LDB A,[121000,,A]
	XOR A,B
	TRNE A,377
	JRST ERR5	;CBUS_IARB LOSING
	SOJGE B,IARL
;SEE IF SOURCE OF ZEROES WORKS
	MOVEI A,176320	;REG. 3_0
	PUSHJ P,C0XCT
	MOVEI A,072260	;START DUMMY WRITE FROM REG. 3
	PUSHJ P,C0XCT
	CONO SA0,RDMBL
	DATAI SA0,A	;SHOULD GIVE US 0 IN THE R.H. OF A
	TRNE A,-1
	JRST ERR40	;FAILS HERE IF NO ROMS INSTALLED YET
	MOVE C,[200000,,TEST]
	PUSHJ P,LC0CW
	MOVE C,[123456,,654321]
	PUSHJ P,LC0R2
	MOVEI A,062260	;START DUMMY WRITE FROM REG. 2
	PUSHJ P,C0XCT
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
	CONO SA0,RDMA
	DATAI SA0,A
	AND A,[3,,-1]
	CAIE A,TEST
	JRST ERR11	;MEM ADDR REG HAS WRONG THING IN IT
	CONO SA0,RDMBL
	DATAI SA0,A
	HRRZ B,A
	CAIE B,123456
	JRST ERR6	;MB LEFT LOSING
	TLNE A,-1
	JRST ERR7	;WRONG CHANNEL HAS MEMORY SUBROUTINE
	CONO SA0,RDMBR
	DATAI SA0,A
	CAIE A,654321
	JRST ERR12	;MB RIGHT LOSING
	MOVE C,[200000,,TEST]
	PUSHJ P,LC0CW
	MOVEI E,146720	;REG. 0_MEM RD BUFFER
MRD1:	MOVEI A,042200	;START READ AT CA
	PUSHJ P,C0XCT
	MOVEI B,3
MRD:	MOVE A,E
	PUSHJ P,C0XCT
	SOJLE B,ERR8	;MEM CYCLE TOOK TOO MANY TICKS
	CONO SA0,RDCONI
	DATAI SA0,A
	TLNE A,1
	JRST MRD
	MOVE A,E
	PUSHJ P,C0XCT
	ADDI E,10000	;FILL NEXT REGISTER
	TRNE E,40000	;ALL FILLED?
	JRST MRD1	;NO
	SETOM TEST1	;CLOBBER PLACE WHERE DATA WILL BE READ BACK
	CLEARM TEST1+1
	MOVE A,TEST+2
	SETCAM A,TEST1+2
	MOVEM A,TEST1+3
	MOVEI E,042240	;START WRITE CYCLE
MWR1:	MOVE A,E
	PUSHJ P,C0XCT
	MOVEI B,3
MWR:	SOJLE B,ERR9	;MEM CYCLE TOOK TOO MANY TICKS
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
	MOVEI A,0
	PUSHJ P,C0XCT
	CONO SA0,RDCONI
	DATAI SA0,A
	TLNE A,1
	JRST MWR
	ADDI E,10000
	TRNE E,40000
	JRST MWR1
	MOVSI A,-4
MCMP:	MOVE B,TEST1(A)
	CAME B,TEST(A)
	JRST ERR10	;DATA GOTTEN BACK WRONG
	AOBJN A,MCMP
	MOVEI G,NCHN-1	;TRY OUT WC, CA, PC PATHS
CWTST:	PUSHJ P,STEPCX	;STEP CLOCK TO APPROPRIATE CHANNEL
	MOVE C,TEST+2	;TAKE SOME RANDOM DATA
	MOVE J,[441100,,CWTD]
	PUSHJ P,LCXCW	;PUT INTO WC, CA REGISTERS
	MOVE C,TEST+3
	PUSHJ P,LCXR2
	MOVEI A,065300	;PC_ADR FILED OF REG. 2
	PUSHJ P,CXXCT
	MOVEI C,040400	;CBUS_BYTE 1 OF WC
	MOVEI F,3	;DO STUFF FOR EACH OF 3 REGISTERS
CWT1:	MOVEI B,3	;DO THIS STUFF FOR EACH OF 3 BYTES
CWT2:	DATAO SA0,C	;GET DATA ONTO CBUS
	CONO SA0,RDCCI
	DATAI SA0,A
	LDB A,[121000,,A]	;GET CONTENTS OF CBUS
	ILDB D,J	;GET EXPECTED ANSWER
	CAIN B,1	;CHECK FOR 3RD BYTE
	ANDI A,360	;IGNORE EXTRANEOUS BITS
	CAME D,A	;ARE THEY THE SAME?
	JRST ERR28	;NOPE
	ADDI C,400	;ADVANCE TO NEXT BYTE OF REGISTER
	SOJG B,CWT2	;THAT'S ALL FOR THAT REGISTER
	ADDI C,400	;ADVANCE TO NEXT REGISTER
	SOJG F,CWT1	;WE'VE TESTED ALL THREE REGISTERS
	SOJGE G,CWTST	;TRY ALL CHANNELS
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
STCL:	MOVEI G,NCHN-1	;HANG ALL CHANNELS
STCLH:	PUSHJ P,STEPCX	;GET TO RIGHT CHANNEL
	MOVEI A,HANGPC	;FEED IT MAGIC PC WHICH WILL HANG IT
	PUSHJ P,CXXCT
	SOJGE G,STCLH	;DO SAME FOR ALL CHANNELS
	CONO SA0,SACGO	;START THE CLOCK SO CONO'S WILL WORK
	MOVEI E,10*<NCHN-1>
	MOVEI D,PIE0_<1-NCHN>
STCL1:	CONO SA0,STPIE(E)
	CONSO SA0,(D)
	JRST ERR13
	CONO SA0,CLPIE(E)
	CONSZ SA0,(D)
	JRST ERR14
	LSH D,-4
	CONO SA0,STBSY(E)
	CONSO SA0,(D)
	JRST ERR15
	CONO SA0,CLBSY(E)
	CONSZ SA0,(D)
	JRST ERR16
	LSH D,-4
	CONO SA0,STSTF(E)
	CONSO SA0,(D)
	JRST ERR17
	CONO SA0,CLSTF(E)
	CONSZ SA0,(D)
	JRST ERR18
	LSH D,10+1
	SUBI E,10
	JUMPGE E,STCL1
	MOVSI B,-3
	CONO SA0,SASTEP
	PUSHJ P,STEPC0
STCLM2:	MOVE A,STCLM(B)
	PUSHJ P,C0XCT
	CONSO SA0,@STCLM1(B)
	JRST ERR19
	MOVE A,STCLM(B)
	SUBI A,4000
	PUSHJ P,C0XCT
	CONSZ SA0,@STCLM1(B)
	JRST ERR20
	AOBJN B,STCLM2
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
QFIFO:	MOVEI G,NCHN-1	;FILL UP THE FIRST-IN, FIRST-OUT
		;BUFFERS OF EACH OF THE CHANNELS
FIFO1:	PUSHJ P,STEPCX	;STEP TO THE APPROPRIATE CHANNEL
	MOVEI A,002000	;CLEAR TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,027000	;SET WRITE BIT IN TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,027400	;SET BUFFER ENABLE BIT IN TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,145000	;TEST BUFFER EMPTY BIT
	PUSHJ P,CXTST
	TRNN A,40_12	;CHECK RESULTS OF TEST
	JRST ERR21	;BUFFER WASN'T EMPTY
	MOVEI C,0
	PUSHJ P,LCXCW	;CAUSE AN APPARENT W.C. OVERFLOW
	MOVEI D,NBF	;SET UP COUNT OF # BYTES TO SEND
FIFO2:	MOVE A,G
	LSH A,5
	ADD A,D		;SYNTHESIZE A UNIQUE BYTE OF DATA
	PUSHJ P,CXXCT	;PUT IT INTO MICRO-P.C.
	MOVEI A,040140	;PUT "FIFO_MICRO-P.C." IN MICROIN-
	PUSHJ P,CXTST	;STRUCTION REGISTER TO SEE IF IT
			;WILL BRANCH
	PUSHJ P,STEPX	;NOW EXECUTE THE MICROINSTRUCTION
	MOVEI A,145000	;TEST BUFFER EMPTY BIT
	PUSHJ P,CXTST
	TRNE A,40_12
	JRST ERR22	;BUFFER WAS EMPTY
	SOJG D,FIFO2	;KEEP DOING IT UNTIL FIFO SHOULD BE FULL
	MOVEI A,040140	;TRY TO PUT ANOTHER WORD INTO FIFO
	PUSHJ P,CXXCT
	TRNN A,1	;OUGHT TO COMPLAIN THIS TIME
	JRST ERR24	;DIDN'T
	SOJGE G,FIFO1	;FILL UP FIFOS OF OTHER CHANNELS
;O.K., FOLKS, NOW WE SEE IF WE CAN GET THE DATA BACK
;FALLS THROUGH TO NEXT PAGE


;FALLEN INTO FROM PREVIOUS PAGE
	MOVEI G,NCHN-1	;START UNLOADING HIGHEST CHANNEL
FIFO3:	PUSHJ P,STEPCX	;STEP COUNTER TO APPROPRIATE CHANNEL
	MOVEI A,023400	;CLEAR BUFFER ENABLE
	PUSHJ P,CXXCT
	MOVEI A,027400	;SET BUFFER ENABLE
	PUSHJ P,CXXCT
	MOVEI A,145000	;TEST BUFFER EMPTY (SHOULD BE)
	PUSHJ P,CXTST
	TRNN A,40_12
	JRST ERR25	;WASN'T
	MOVEI A,023000	;CLEAR WRITE
	PUSHJ P,CXXCT
	MOVEI D,NBF
FIFO4:	MOVEI A,145000	;TEST BUFFER EMPTY
	PUSHJ P,CXTST
	TRNE A,40_12
	JRST ERR26	;OOPS, IT WAS
	MOVEI A,147000	;R0B0_FIFO
	PUSHJ P,CXTST
	PUSHJ P,STEPX
	MOVE H,G
	LSH H,5
	ADD H,D
	MOVEI A,140000	;CBUS_R0B0
	PUSHJ P,CXTST
	LDB A,[121000,,A]
	CAME A,H
	JRST ERR27	;WRONG DATA READ BACK FROM FIFO
	SOJG D,FIFO4	;READ BACK THE REST
	MOVEI A,145000	;BUFFER SHOULD NOW BE EMPTY
	PUSHJ P,CXTST
	TRNN A,40_12
	JRST ERR23	;OOPS, IT ISN'T
	SOJGE G,FIFO3	;READ BACK FIFOS OF OTHER CHANNELS
;FALL THRU

;TRY OUT P.I. REQUEST LOGIC
	CONO SA0,SACGO
	MOVEI G,<NCHN-1>*10
PITST:	CONO SA0,CLSRQ(G)	;CLEAR STATUS REQUEST FLAG
	CONO SA0,CLSTF(G)	;AND STATUS FLAG
	CONO SA0,STPIE(G)	;AND SET P.I. ENABLE FLAG
	SUBI G,10
	JUMPGE G,PITST	;FOR ALL CHANNELS
	CONSZ SA0,PIRQ	;SHOULD NOT BE REQUESTING AN INTERRUPT
	JRST ERR29	;OOPS, WAS
	CLEARM PIE	;NOT EXPECTING ANY INTERRUPTS
	CONO PI,12377	;ENABLE ALL P.I. CHANNELS
	MOVEI B,7
PIT1:	CONO SA0,(B)
	SOJG B,.-1	;SHOULD NEVER INTERRUPT
	MOVEI G,<NCHN-1>*10
PIT2:	MOVEI B,7
PIT3:	MOVEM B,PIE
	ADD B,G
	CONO SA0,STSTF(B)	;SHOULD CAUSE AN INTERRUPT
	ROT 377	;DELAY FOR KI-10
	JFCL
	SKIPE PIE	;DID IT?
	JRST ERR38	;NO, COMPLAIN
	SUB B,G
	SOJG B,PIT3	;TRY ALL P.I. CHANNELS
	SUBI G,10
	JUMPGE G,PIT2	;TRY ALL SA-10 CHANNELS
	JRST BEG	;O.K., IT ALL WORKS.  TRY IT OVER AGAIN
;HERE


BEG1:	SOJG B,BEG1A
	JRST ERR2		;DIDN'T GET TO CHANNEL 0

STEPC0:	MOVEI G,0
STEPCX:	CONO SA0,RDCCI
STPC0A:	DATAI SA0,A
	LDB H,[220200,,A]	;CHANNEL SELECTION.
	CAMN H,G		;DESIRED CHANNEL?
	POPJ P,			;YES.
	DATAO SA0,[HANGPC]	;NO. STICK OTHER CHANNELS AT STICKY PC
STEPX:
STEPX1:	CONO SA0,SASTEP!RDCCI
	JRST STPC0A

LC0CW:	MOVEI G,0
LCXCW:	PUSHJ P,LCXR2
	MOVEI A,060700	;WC_WC FIELD OF REG. 2
	PUSHJ P,CXXCT
	MOVEI A,063300	;CA_CA FIELD OF REG. 2
CXXCT:	DATAO SA0,A
	JRST STEPX

C0XCT:	DATAO SA0,A
STEP0:	MOVEI G,0
	JRST STEPX1

CXTST:	DATAO SA0,A
	CONO SA0,RDCCI
	DATAI SA0,A
	POPJ P,

LC0R2:	MOVEI G,0
LCXR2:	MOVEI D,060000-20	;IARB TO BYTE OF REG. 2
LCXR2A:	ADDI D,20	;ADVANCE TO NEXT BYTE OF REGISTER
	MOVEI B,0
	LSHC B,10
	DATAO SA0,B	;PUT A BYTE OF DATA INTO MICRO-P.C.
	PUSHJ P,STEPX
	DATAO SA0,D	;TRANSFER IT TO BYTE OF REG. 2
	PUSHJ P,STEPX
	TRNN D,100	;WAS THAT THE LAST BYTE?
	JRST LCXR2A	;NO
	POPJ P,	;I CAN'T BELIEVE WE FILLED THE WHOLE WORD


CPROG:	MOVEI P,PDL-1
	MOVEI A,001000	;CLEAR TAG BYTE
	PUSHJ P,CXXCT
	MOVEI A,025400
	PUSHJ P,CXXCT
	MOVEI A,^D25000
	SOJG A,.
	DATAI A	;SELECT A DEVICE ADDRESS
	ANDI A,377
	PUSHJ P,CXXCT	;PUT IT IN IARB
	MOVEI A,040120	;IARB TO BUS OUT
	PUSHJ P,CXXCT
	MOVEI A,024000	;RAISE ADR OUT
	PUSHJ P,CXXCT
	MOVEI A,024400	;RAISE SEL OUT
	PUSHJ P,CXXCT
	MOVEI A,105060	;TEST OPL IN
	PUSHJ P,TWAIT
	MOVEI A,020000	;DROP ADR OUT
	PUSHJ P,CXXCT
	MOVEI A,105000	;TEST ADR IN
	PUSHJ P,TWAIT
	MOVEI A,144000	;BUS IN TO CBUS
	PUSHJ P,CXTST
	LDB J,[121000,,A]	;PICK UP CBUS INTO J
	DATAI A		;GET A COMMAND FROM L.H. KEYS
	LDB A,[221000,,A]
	PUSHJ P,CXXCT	;PUT IT IN IARB
	MOVEI A,040120	;IARB TO BUS OUT
	PUSHJ P,CXXCT
	MOVEI A,026400	;RAISE CMD OUT
	PUSHJ P,CXXCT
	MOVEI A,105001	;TEST ADR IN
	PUSHJ P,TWAIT
	MOVEI A,022400	;DROP CMD OUT
	PUSHJ P,CXXCT
	MOVEI A,105120	;TEST STA IN
	PUSHJ P,TWAIT
	MOVEI A,144000	;BUS IN TO CBUS
	PUSHJ P,CXTST
	LDB K,[121000,,A]
	MOVEI A,020400	;DROP SEL OUT
	PUSHJ P,CXXCT
	MOVEI A,025000	;RAISE SERV OUT
	PUSHJ P,CXXCT
	MOVEI A,105061	;TEST NOT OPL IN
	PUSHJ P,TWAIT
	JRST CPROG	;TRY AGAIN

TWAIT:	MOVE E,A		; USED ONLY IN CPROG, ABOVE
	MOVEI B,^D40		;TIME OUT
TWAIT1:	MOVE A,E
	PUSHJ P,CXXCT
	TRNE A,1
	POPJ P,
	SOJG B,TWAIT1
	JRST ERR42

CMT:	;MEMORY TEST...
	MOVEI P,PDL-1
	PUSHJ P,RSTALL
	MOVEI CN,0
	PUSHJ P,CSET
CMT0:	MOVE E,ADRLO
CMT1:	MOVE A,[MOVE CMTP0]
	PUSHJ P,RND
	MOVEM B,(E)
	HRRM E,CMTP0
	PUSHJ P,CMTG
	CAME B,CMTPT
	JRST DDT
	SETCAM B,CMTPT
	MOVE A,[MOVE CMTP1]
	HRRM E,CMTP1A
	PUSHJ P,CMTG
	EQV B,(E)
	JUMPN B,DDT
	ADDI E,1
	CAMGE E,ADRHI
	JRST CMT1
	JRST CMT0

CMTG:	MOVEM A,@CBASE
	CONO SA0,@STBSYC
	CONSO SA0,600170
	JRST .-1
	CONSZ SA0,600000
	JRST CMTGE
	CONO SA0,@CLSTFC
	POPJ P,
CMTGE:	PUSHJ P,DSPE1
	JRST DDT

CMTP0:	40000,,0	;LAC X (X FILLED IN ABOVE)
	440000,,CMTPT	;DAC CMTPT
	0

CMTP1:	40000,,CMTPT	;LAC CMTPT
CMTP1A:	440000,,0	;DAC XX (XX FILLED IN ABOVE)
	0

CMTPT:	0



;DISK TEST INTERRUPT CODE FOR DSKT BELOW
;JSR HERE ON CH 1 INT, SET UP AT START OF DSKT
DSKI:	0
	MOVEM G,ACS+G
	MOVEI G,ACS
	BLT G,ACS+G-1
	CONI SA0,0
	TRNN 0,PIRQ
	JRST DSKIE
	TRNE 0,PARERR+NXM
	JRST DSPE
	TRNE 0,170
	JRST DSI0
DSKIE:	MOVEI C,[ASCIZ /UNKNOWN INT. CONI=%@
/]				;INT ON CH 1, NOT FROM SA10
	PUSHJ P,STYO
	JRST DSKXX

DSKX1:	CONO SA0,@CLSTFC
DSKEX:	MOVSI G,ACS
	BLT G,G
	JRST 12,@DSKI

DSPE1:	CONO SA0,10
	DATAI SA0,D		;ADDR
	CONO SA0,20
	DATAI SA0,A
	HLRZM A,E		;CH
	CONO SA0,30
	DATAI SA0,F
	HRLM A,F		;WORD
	MOVE G,(D)		;WORD IN MEM
	MOVEI C,[ASCIZ /NON EX MEM ON CH %E
ADDR=%D MEM HAS %G CHNL GOT %F
/]
	CONSZ SA0,PARERR	;SELECT PARITY ERR OR NXM MSG
	MOVEI C,[ASCIZ /MEM PAR ERR ON CH %E
ADDR=%D MEM HAS %G CHNL GOT %F
/]
	JRST STYO

DSPE:	PUSHJ P,DSPE1
	LSH E,3			; CHANNEL NUMBER CAUSING INTERRUPT

	CONO SA0,RSTCH+40(E)
	CONO SA0,CLMERR+SA0CH
	JRST DSKEX

DSKXX:	SKIPE SERR
	JSR GOPR
	JRST DSKT0

;HERE ON SA10 INT FOR DSK CHANNEL

DSI0:	LDB A,[DEVFLD,,@CBASE+1]
	MOVEI G,-IDEV(A)
	CAILE G,NPACKS-1
	JRST DSE1		;BAD DEV #
	MOVE A,TIME		; OK. UPDATE TIME OF RECENT INTERRUPT.
	EXCH A,HUNGT(G)		; FOR THIS DRIVE
	SKIPN OFFLIN(G)		; IF IT HAD BEEN OFF LINE, OR
	AOJN A,DSI0A		; IF IT HAD BEEN HUNG,
	MOVSI B,10		; SET FLAG TO COMMENT ON ITS REVIVAL
	IORM B,CHCW(G)		; AT MAIN PROGRAM LEVEL
	SETZM OFFLIN(G)		; AND CLEAR THE OFF-LINE FLAG.
DSI0A:	MOVE A,@CBASE+1
	TLNE A,163014		;SELECT ERR,BIPERR,CONTROL ERR,PROG INT,
				; ATTN, UNIT CK, UNIT EXCEPTION
	JRST DSE1		;BAD BITS IN STATUS
	TLNE A,100
	JRST DSIBSY		;POSS CU BUSY
	TLNE A,200
	JRST DSKX2		;CU END, RESTART CHAN
	TLNN A,20		;DEV END
	JRST DSI5		; NO.
	TLNE A,4000		; LENGTH ERROR HERE IS BAD
	JRST DSE1		; ..
	MOVSI B,1		; YES. CLEAR BIT IN STATUS WORD FOR DRV
	TDZ BF,BITS(G)		; AND IN LIGHT-WATCHER WORD.
	ANDCAM B,CHCW(G)
DSI5:	MOVE A,CHCW(G)
	TLNE A,7		; MAIN PROG WAIT OR DEV END WAIT?
	JRST DSKX1		; YES, DISMISS
	MOVEI B,IDEV(G)		; NO, PROCESS THIS INT.
	HRR BF,B		; FOR LIGHT WATCHERS
	HRRZM B,DEVN
	JRST (A)		;DISMISS VIA FINITE STATE MACHINE

DSIBSY:	TLNN A,400		; STATUS MODIFIER?
	JRST DSIB1		;NO STATUS MOD, DEVICE BUSY
	MOVE B,CPGP(G)		; CONTROLLER BUSY
	MOVEM B,DEVL(G)		;BACK UP CHNL PC
	JRST DSKX1		;BUT WAIT FOR CU END BEFORE RESTARTING

DSKX2:	CONO SA0,@STBSYC
	JRST DSKX1		;CLEAR STATUS FLAG, RESTORE AC'S, DISMISS INT.

DSIB1:	TLNN A,200		; DEVICE BUSY. CU END?
	JRST DSE1		; NO.
	MOVE B,CPGP(G)		; YES. PREVIOUS CU BUSY IS NOW OVER
	MOVEM B,DEVL(G)
	JRST DSKX2		;TRY CMD AGAIN IF CU END IN INIT STAT

;CALLED AT THESE TAGS FROM INT ROUTINE WITH CHCW(DRIVE) IN A.
; BITS IN LH MEAN:
;B1: RANDOM TRACK AND HEAD
;B2: DO WRITES
;B3: DO READS
;B4: RE-FILL DATA, CHECK DATA
;B5: RANDOM CORE ADDR ON RD AND WRITE
;B6: TEST THIS DRIVE AT ALL.
;B7-8 - COUNT THRU SURFACE VERIFIER PATTERNS: 00=ZEROES, 01=ONES,
;	1X=WORST CASE PATTERN.
;B9 - USE VERIFIER, NOT RANDOM TRK AND DATA
;B17: WAITING FOR DEVICE END
;B16: REQUESTS MAIN PROG TO FILL WITH NEW DATA
;B15: REQUESTS MAIN PROG TO CHECK DATA
;B14: DRIVE CAME BACK UP AFTER HANG.
;B13: RETRYING CORRECTABLE DATA CHECK

DIP0:	TLNN A,(1B9)		; NOT RANDOM IF SURFACE VERIFYING
	TLNN A,200000		; OK, RANDOM IF REQUESTED BY B1
	JRST DIP1
	PUSHJ P,RNDTK
	MOVEM C,TRK(G)
DIP1:	TLNN A,(1B9)		; DON'T RANDOMIZE IN SURFACE VERIFIER
	TLNN A,10000		; RANDOM CORE ADDR REQUESTED? (WRITE)
	JRST DIP1A
	PUSHJ P,RNDAD
	MOVEM C,ADDR(G)
DIP1A:	TLNN A,20000		; RE-FILL DATA AREA?
	JRST DIP1B
	MOVSI B,2
	JSP F,DIMP		; REQUEST MAIN PROG TO FILL DATA
DIP1B:	TLNN A,100000		; WRITE THE DATA?
	JRST DIP2
	MOVEI C,5		; WRITE DATA OPCODE
	PUSHJ P,DIRW		; DISK INT, READ/WRITE RTN
	MOVEI A,NRPT*RECL
	ADDM A,NWRITE(G)	; COUNT WORDS WRITTEN
	JSP F,DIGO
DIP2:	TLNN A,(1B9)		; DON'T RANDOMIZE ADR IN SURF VERIFY
	TLNN A,10000		; RANDOM CORE ADDR? (READ)
	JRST DIP2A
	PUSHJ P,RNDAD
	MOVEM C,ADDR(G)
DIP2A:	TLNN A,40000		; DO READS?
	JRST DIP3
	MOVEI C,6		; READ DATA OPCODE
	PUSHJ P,DIRW
	MOVEI A,NRPT*RECL
	ADDM A,NREAD(G)		; COUNT WORDS READ
	JSP F,DIGO
DIP3:	TLNE A,40000		; READING?
	TLNN A,20000		; YES. WANT DATA CHECKED?
	JRST DIP0		; NO TO ONE OF THOSE. DON'T CHECK
	MOVSI B,4		; REQUEST MAIN PROG TO CHECK DATA
	JSP F,DIMP
	JRST DIP0

DIGO:	HLL F,CHCW(G)
	TLO F,1
	MOVEM F,CHCW(G)
	IOR BF,BITS(G)		; FLAG BUSY FOR LIGHTS WATCHERS
	JRST DSKX2

DIMP:	HRRM F,CHCW(G)
	IORM B,CHCW(G)
	JRST DSKX1

RNDTK:	PUSHJ P,RND
	TLNE B,7
	JRST RNDT1		;MAKE CYL RANDOM ONLY 1/8 OF THE TIME
	IDIVI B,^D411*^D19
	JRST RNDT2		; MAKE SURE NOT A BADSPOT

RNDT1:	IDIVI B,^D19		;RANDOM HEAD ONLY
	MOVE D,TRK(G)
	IDIVI D,^D19		;GET OLD HEAD
	SUB C,E	;NEW-OLD
	ADD C,TRK(G)
RNDT2:	MOVE D,C		; TRACK*19+HEAD
	HRL D,G			; DRIVE
	MOVSI E,-NBADSP		; COUNT THRU BAD SPOTS TABLE
RNDT2L:	SKIPGE SPOTTB(E)	;A SPOT IN TABLE?
	POPJ P,0		;NO, SO SELECTED ONE IS OK
	CAMN D,SPOTTB(E)	;YES. SAME AS SELECTED ONE?
	JRST RNDTK		;YES. DON'T USE IT. PICK ANOTHER
	AOBJN E,RNDT2L		;NO, SEE IF ANY MORE
	POPJ P,

RND:	MOVEI B,105
	FMPB B,RNDM
	POPJ P,
RNDM:	123456,,654321

RNDAD:	MOVE D,ADRHI
	SUB D,ADRLO		;SIZE OF BUFFER AREA
	IDIVI D,NPACKS		; SIZE FOR EACH DEVICE
	MOVEI E,(D)		; SIZE OF ONE DRIVE'S SPACE
	IMULI E,(G)		; BASE OF CURRENT GUY'S SPACE
	ADD E,ADRLO		; PLUS BASE OF ALL DATA AREAS.
	SUBI D,RECL*NRPT	;MAXIMUM POSSIBLE BUFFER ORIGIN OFFSET
	PUSHJ P,RND
	IDIVI B,1(D)		;OFFSET TO C
	ADD C,E			;BUFFER ORIGIN TO C
	POPJ P,

PBITS:	JUMPE E,CPOPJ
	TRNN E,1
	JRST PBIT1
	TLON D,400000
	JRST PBIT2
	MOVEI B,"+"
	PUSHJ P,TYO
PBIT2:	MOVE C,(D)
	PUSHJ P,STYO
PBIT1:	LSH E,-1
	AOJA D,PBITS

SNSMSG:	[ASCIZ /STATISTICS/]
	[ASCIZ /2-2/]
	[ASCIZ /CORRECTABLE/]
	[ASCIZ /2-0/]
	[ASCIZ /INCOMPLETE/]
	[ASCIZ /WRITE INHIBIT/]
	[ASCIZ /FILE PROTECT/]
	[ASCIZ /NO RECORD FOUND/]
	[ASCIZ /1-3/]
	[ASCIZ /CYLINDER END/]
	[ASCIZ /TRACK OVERRUN/]
	[ASCIZ /PERMANENT ERROR/]
	[ASCIZ /0-7/]
	[ASCIZ /0-6/]
	[ASCIZ /OVERRUN/]
	[ASCIZ /DATA CHECK/]
	[ASCIZ /EQUIPMENT CHECK/]
	[ASCIZ /BUS OUT PARITY CHECK/]
	[ASCIZ /INTERVENTION REQUIRED/]
	[ASCIZ /COMMAND REJECT/]
STAMSG:	[ASCIZ /UNIT EXCEPTION/]
	[ASCIZ /UNIT CHECK/]
	[ASCIZ /DEVICE END/]
	[ASCIZ /CHANNEL END/]
	[ASCIZ /BUSY/]
	[ASCIZ /CONTROL UNIT END/]
	[ASCIZ /STATUS MODIFIER/]
	[ASCIZ /ATTENTION/]
	[ASCIZ /PROG INT FLAG/]
	[ASCIZ /LENGTH ERROR/]
	[ASCIZ /BIT 5?/]
	[ASCIZ /SA10 CONTROL SEQ CHECK/]
	[ASCIZ /BUS IN PARITY CHECK/]
	[ASCIZ /SELECT ERROR/]

;DISK INTERRUPT, READ OR WRITE TO BE DONE. OPCODE IN C.

DIRW:	MOVSI A,2000
	MOVE B,CPGP(G)
	MOVEM B,DEVL(G)
	HRLI B,200000		;TCH
	LSH C,^D20		; TO OPCODE FIELD (RD OR WRT)
	MOVE D,DEVN		; DEVICE WHICH CAUSED THIS INTERRUPT
	LSH D,^D12
	TLC D,162034		;SEEK, CHAINED
	MOVE E,TRK(G)
	IDIVI E,^D19
	LSH E,^D20
	LSH F,4
	IOR E,F
	ADDI B,4
	MOVEM D,-4(B)		;STORE SEEK
	MOVSI F,<-6>_CNTSFT
	HRRI F,177(B)
	MOVEM F,-3(B)		;PTR TO SEEK ARG
	SETZM 177(B)		;BB
	TLC D,2220		;MAKE SET SECTOR
	MOVEM D,-2(B)
	MOVE F,[<<-1>_CNTSFT>,,[0]]	; ONE BYTE OF ZERO FOR SECTOR NUMBER
	MOVEM F,-1(B)		;PTR TO SECTOR
	TLC D,110		;MAKE SRCH ID =
DIRW1:	MOVEM D,(B)		;STORE SRCH
	MOVSI F,<<-5>_CNTSFT>
	ADDI F,200(B)
	MOVEM F,1(B)		;STORE DCW FOR SEARCH
	MOVEM B,2(B)		;STORE TCH *-1 WHILE SRCH FAILS
	TLZ D,21774		; THEN DO THE RD OR WRT
	XOR D,C			; PUT RD OR WRT OPCODE INTO CMD
	MOVEM D,3(B)		;STORE CMD
	MOVSI F,<<-RECL>_CNTSFT>		; WORDS IN A RECORD (ONE PAGE)
	ADDI F,(A)
	ADD F,ADDR(G)		; BASE ADDR OF DATA AREA FOR THIS PACK
	MOVEM F,4(B)		;STORE DCW
	TLZ D,21774
	TLC D,20304		; CONVERT BACK TO "SEARCH ID EQUAL"
	MOVEM E,200(B)		;STORE CCHH
	MOVEM A,201(B)		;STORE REC #
	ADDI B,5		; COMMAND WORDS PER RECORD
	ADD A,[2000,,RECL]
	CAMGE A,[<NRPT+1>*2000,,0]	; RECORDS PER TRK. FILLED TRACK?
	JRST DIRW1			; NO. GO DO ANOTHER RECORD
	SETZM (B)		; YES. DONE. STORE HALT
	MOVSI F,40000
	ANDCAM F,-2(B)		;UNCHAIN LAST CMD
	POPJ P,


;HERE IF BUSY, NOT STATUS MOD, NOT CU END.
;HERE IF WRONG DEVICE INTERRUPTS.
;HERE IF "BAD BITS" IN CONI OR STATUS WORD (CHANNEL ERRORS)
DSE1:	SETOM SENSED		; IN CASE NO SENSE DONE
	HRLZ A,CBASE		; COPY THE 4 WORDS FROM LOW CORE
	HRRI A,DSTAT		; FORM BLT POINTER
	BLT A,DSTAT+3		; BEFORE DOING SENSE
	LDB D,[141000,,DSTAT+1]	; DEV CAUSING INT
	MOVE A,DSTAT+1		; SEE IF UNIT CHECK
	TLNE A,10		; ..
	PUSHJ P,DSENSE		; YES. DO A SENSE.
	LDB E,[202400,,SENSED]	; SUPPRESS ERROR TYPEOUT ON SOME OF
	CAIE E,100004		; THE CORRECTABLES, IN REPEATS.
	JRST DSE4		; NOT A CORRECTABLE
	MOVE E,RETRYC(G)	; CORRECTABLE. FIRST OR LAST?
	CAIE E,NRETRY
	CAIN E,0		; ..
	SKIPA			; YES.
	JRST DSKCDC		; NO. DON'T TYPE THE SENSE STUFF
DSE4:	PUSHJ P,PTIME		; TIME-STAMP THE ERROR
	LDB A,[420200,,DSTAT+1] ; GET 0=END,1=INIT,2=ASYNC,3=DUMMY
	MOVE C,STTT(A)		; WHAT KIND OF STATUS STORED
	PUSHJ P,STYO
	LDB D,[141000,,DSTAT+1]	; DEVICE NUMBER
	MOVEI C,[ASCIZ / STATUS, DEVICE %D =
/]
	PUSHJ P,STYO
	LDB E,[241600,,DSTAT+1] ;FOURTEEN STATUS BITS FRM 1ST WD
	MOVEI D,STAMSG
	PUSHJ P,PBITS
	MOVE D,DSTAT+2
	MOVE E,TRK(G)		; WHERE SHOULD IT HAVE BEEN?
	IDIVI E,^D19		; CYL TO E, HD TO F
	MOVEI C,[ASCIZ /
SW2=%D , CYLINDER %E, HEAD %F
/]
	PUSHJ P,STYO
	MOVE A,DSTAT+1
	TLNN A,10		; UNIT CHECK?
	JRST DSKXX		; NO, RESTART
DSE2:	MOVEI C,[ASCIZ /SENSE: /]
	PUSHJ P,STYO
	MOVE E,SENSED
	AOJE E,[HRROI C,[ASCIZ \MISSING
\]
		PUSHJ P,STYO
		JRST DSKXX]
	LDB E,[202400,,SENSED]
	LDB A,[POINT 6,SENSED+1,7]	;BYTE 4 TELLS WHAT DRIVE
	PUSHJ P,DPHADR		; PRINT PHYS ADR LETTER OR "?"
	PUSHJ P,CR
	MOVEI D,SNSMSG
	PUSHJ P,PBITS
	PUSHJ P,PSB
	MOVE E,SENSED		; SEE IF OFF LINE
	TLNE E,(1B1)		; ..
	SETOM OFFLIN(G)		; YES, FLAG NOT TO RUN IT.
	LDB E,[202400,,SENSED]	; FIRST TWENTY BITS OF SENSE DATA
	CAIN E,1		;STATISTICS?
	JRST DSKT0		;YES. NOT A FATAL ERROR, DON'T GET OPR
	CAIN E,100004		;SKIP UNLESS CORRECTABLE DATA CHECK
	JRST DSKCDC		;PRINT WHERE THE ERROR WAS
	AOS A,ERRCT(G)		; COUNT "OTHER" ERRORS
	CAMGE A,MAXBER		; MORE THAN MAX BAD ERRORS?
	JRST DSE5		; NO
	SETOM OFFLIN(G)		; YES. SHUT IT DOWN.
	MOVEI D,(G)		; TELL THE WORLD
	MOVEI C,[ASCIZ /
*** DRIVE %D EXCESSIVE ERRORS. MARKED OFF LINE, /]
	PUSHJ P,STYO
	PUSHJ P,PTIME
DSE5:	JRST DSKXX		; GET OPR OR RESTART.

MAXBER:	EXP ^D50

; CALL WITH DRIVE CODE IN A

DPHADR:	PUSH P,A
	MOVEI C,[ASCIZ /PHYSICAL DRIVE /]
	PUSHJ P,STYO
	MOVSI C,-10
	POP P,A
	CAMN A,PHADRT(C)	; LOOK THRU FUNNY NAMES
	JRST DPHAD2		; FOUND IT
	AOBJN C,.-2
	MOVEI B,"?"		; NOT FOUND
	JRST DPHAD3
DPHAD2:	MOVEI B,"A"(C)
DPHAD3:	PUSHJ P,TYO
	POPJ P,0

DSENSE:	DPB D,[141000,,PSENSE]	; SUBR TO GET SENSE FROM DEV IN D
	MOVEI A,10
	MOVEM A,SENSCT
DSE2A:	MOVE A,[MOVE PSENSE]
	MOVEM A,@CBASE
	SETOM SENSED
	SETZM SENSED+1
	SETZM SENSED+2
	SETZM SENSED+3
	SETZM SENSED+4
	SETZM SENSED+5
	SETZM @CBASE+1
	CONO SA0,@STBSYC
	CONO SA0,@CLSTFC
	MOVEI A,-1
	CONSO SA0,170
	SOJG A,.-1
	JUMPLE A,DSE2B
	MOVE A,@CBASE+1
	TLNN A,(1B11)		; BUSY?
	JRST DSE2B
	SOSLE SENSCT
	JRST DSE2A
DSE2B:	POPJ P,0

DSENS1:	DPB D,[141000,,PNOP]	; SAME SUBR BUT DO NOP FIRST
	MOVE A,[MOVE PNOP]	; BECAUSE SENSE NOT UP TO DATE AT
	MOVEM A,@CBASE		; AT STARTUP WITHOUT IT
	CONO SA0,@STBSYC
	CONO SA0,@CLSTFC
	MOVEI A,-1
	CONSO SA0,170
	SOJG A,.-1
	JRST DSENSE
PNOP:	BYTE (8) 240,3,IDEV,0
	0

STTT:	[ASCIZ /ENDING/]
	[ASCIZ /INITIAL/]
	[ASCIZ /ASYNC/]
	[ASCIZ /DUMMY/]


DSKCDC:	AOS NCORDC(G)		; COUNT CORRECTABLE DATA CHECKS
	MOVSI A,(1B13)		; FLAG CORRECTABLE CHECK
	IORB A,CHCW(G)		; IN DRIVE STATUS WORD
	SOS D,RETRYC(G)		; COUNT DOWN RETRIES
	CAIN D,NRETRY-1		; IF THIS IS FIRST ERROR,
	JRST DSKWHR		; GO REPORT ITS LOCATION
	JUMPGE D,DSKWHX		; IF NOT COUNTED OUT, QUIT HERE.
	MOVEI D,NRETRY		; CALL IT PERMANENT
	MOVEI C,[ASCIZ /*** DATA CHECK AFTER $D RE-READS.
/]
	PUSHJ P,STYO		; COMPLAIN, FALL INTO FULL REPORTER
DSKWHR:	LDB D,[POINT 3,SENSED+1,27]	; SENSE FORMAT DESCRIPTOR
	CAIE D,4		;IF 4 OR 5, GIVES POSITIONS.
	CAIN D,5		; ..
	JRST DSKWH1		; GOOD
	MOVEI C,[ASCIZ /SENSE BYTE FORMAT IS %D, SHOULD BE 4 OR 5.
/]
	PUSHJ P,STYO
	JRST DSKWHX		;GIVE UP
DSKWH1:	LDB D,[POINT 16,SENSED+2,15]	; CYL
	LDB E,[POINT 16,SENSED+2,31]	; HEAD
	MOVEI C,[ASCIZ /ERROR REPORT: DRIVE %G, CYLINDER %D, HEAD %E/]
	PUSHJ P,STYO
	LDB D,[POINT 8,SENSED+3,7]	; RECORD
	LDB E,[POINT 8,SENSED+3,15]	; SECTOR
	LDB F,[POINT 8,SENSED+3,23]	; OFFSET
	MOVEI C,[ASCIZ /
   RECORD %D, SECTOR %E, OFFSET %F
/]
	PUSHJ P,STYO
DSKWHX:	JRST DSKT0

PHADRT:	EXP 70,61,52,43,34,25,16,07	;WIERD NAMES OF DRIVES

; ROUTINE TO PRINT ERROR STUFF FOR TAPE TEST

TSPE1:	SETOM TAPF		; FLAG TAPE, NOT DISK
	LDB A,[420200,,@CBASE+1] ; GET 0=END,1=INIT,2=ASYNC,3=DUMMY
	MOVE C,STTT(A)		; WHAT KIND OF STATUS STORED
	PUSHJ P,STYO
	LDB D,[141000,,@CBASE+1] ; DEVICE ADDR FROM STORED STATUS
	DPB D,[141000,,PSENSE]	; TO DO SENSE ON IT.
	MOVEI C,[ASCIZ / STATUS, DEVICE %D =
/]
	PUSHJ P,STYO
	LDB E,[241600,,@CBASE+1] ;FOURTEEN STATUS BITS FRM 1ST WD
	MOVEI D,STAMSG
	PUSHJ P,PBITS
	MOVE D,@CBASE+2
	MOVEI C,[ASCIZ /
SW2=%D
/]
	PUSHJ P,STYO
	MOVE A,@CBASE+1
TSE2:	MOVEI A,10
	MOVEM A,SENSCT
TSE2A:	MOVE A,[MOVE PSENSE]
	MOVEM A,@CBASE
	SETOM SENSED
	SETZM SENSED+1
	MOVE A,[SENSED+1,,SENSED+2]
	BLT A,SENSED+5
	SETZM @CBASE+1
	CONO SA0,@STBSYC
	CONO SA0,@CLSTFC
	MOVEI A,-1		; COUNTER
	CONSO SA0,170
	SOJG A,.-1
	JUMPLE A,TSE2B
	MOVE A,@CBASE+1
	TLNN A,(1B11)		; BUSY?
	JRST TSE2B		; NO.
	SOSLE SENSCT
	JRST TSE2A
TSE2B:	MOVEI C,[ASCIZ /SENSE: /]
	PUSHJ P,STYO
	MOVE E,SENSED
	AOJE E,[HRROI C,[ASCIZ \MISSING
\]
		PUSHJ P,STYO
		JRST QTT0]
	LDB E,[202400,,SENSED]
	MOVEI D,SNSMSG
	LDB E,[242000,,SENSED]	;SIXTEEN BITS OF SENSE DATA
	MOVEI D,TAPSNS
	PUSHJ P,PBITS
	PUSHJ P,PSB
	POPJ P,0

DSKT:	TDZA A,A		;ENTRY FOR RANDOM TRANSFERS
DSKTV:	SETO A,			;ENTRY FOR VERIFYING SURFACES
	MOVEM A,DSVFLG		;DISK SURFACE VERIFY FLAG
	MOVEI P,PDL-1
	PUSHJ P,RSTALL
	MOVE CN,DCHAN
	PUSHJ P,CSET		;SET UP TO USE IT
	SETZM TIME
	SETZM TIMEC		; CLEAR RUNNING TIME COUNTERS.
	CONO 4,10000		; CLEAR PI
	JFCL 17,.+1		; AND APR FLAGS SO CONSZ BELO WORKS
				; ON BOTH KA AND KI10
	MOVSI B,-1000		; SCAN FOR MEMORY SIZE
DSKTS2:	MOVE A,(B)		; SEE IF MEMORY EXISTS
	CONSZ 0,1B23!1B29	; KA OR KI NXM?
	JRST DSKTS1		; YES
	ADDI B,777		; NO. ANOTHER PAGE
	AOBJN B,DSKTS2		; LOOP THRU ALL MEMORY
DSKTS1:	MOVEI B,-1(B)		; LAST EXISTENT LOCATION
	CAMGE B,ADRHI		; ADRHI TOO HIGH?
	MOVEM B,ADRHI		; YES. BACK OFF.
	MOVEI D,(B)
	MOVEI C,[ASCIZ /
LAST WORD OF MEMORY IS %D
/]
	PUSHJ P,STYO
	MOVSI G,-NPACKS
DSKTL1:	SETZM OFFLIN(G)		; ASSUME NOT OFF LINE
	MOVEI D,IDEV(G)		; SEE IF IT IS ON LINE
	PUSHJ P,DSENS1		; DISK SENSE ROUTINE
	MOVE A,SENSED		; GET OFF-LINE BIT
	TLNN A,(1B1)		; INTERVENTION REQUIRED?
	JRST DSKTS3		; NO.
	SETOM OFFLIN(G)		; YES.
	LDB A,[POINT 6,SENSED+1,7] ; MAGIC CODE FOR THIS DRIVE
	PUSHJ P,DPHADR		; TYPE PHYSICAL DRIVE NAME
	MOVEI D,(G)		; AND LOGICAL NAME
	MOVEI C,[ASCIZ /, LOGICAL DRIVE %D OFF LINE.
/]
	PUSHJ P,STYO
DSKTS3:	PUSHJ P,RNDAD		; SET UP ADDRESS TABLE
	MOVEM C,ADDR(G)		; IN CASE NOT RANDOM DURING TEST
	SETZM RETRYC(G)		; CLEAR RETRY COUNTER
	SETZM NREAD(G)		; CLEAR SUMMARY COUNTERS OF READS,
	SETZM NWRITE(G)		; WRITES,
	SETZM NCORDC(G)		; AND CORRECTABLE DATA CHECKS
	SETZM ERRCT(G)		; AND OTHER ERRORS
	SETZM TRK(G)		; START AT TRACK 0 IN CASE VERIFIER
	MOVSI A,(37B17!1B9!3B8)	; CLEAR WAITING STATES, VERIFIER FLAG,
	ANDCAB A,CHCW(G)	; AND VERIFIER STATE FIELD
	MOVSI A,(1B9)		; SET VERIFIER BIT IF
	SKIPE DSVFLG		; STARTED AT DSKVT
	IORM A,CHCW(G)		; ..
	AOBJN G,DSKTL1
;FALL THRU

;FALL THRU, ALSO BACK HERE AFTER ERRORS.
DSKT0:	MOVEI P,PDL-1
	PUSHJ P,RSTALL
	CONO 4,252377
	MOVE A,[JSR DSKI]
	MOVEM A,40+SA0CH+SA0CH
	MOVE A,[JSR APRI]
	MOVEM A,40+APRCH*2
	MOVEI C,[BYTE (7)15,12,0]
	PUSHJ P,STYO
	CONO 2000+APRCH		;ENABLE CLOCK

	MOVEI BF,0		; LIGHT-WATCHER CELL
	MOVSI G,-NPACKS
DSKT1:	MOVSI A,17		; CLEAR WAITING STATES
	ANDCAM A,CHCW(G)	; IN CONTROL WORD
	SETOM DEVL(G)
	SETZM HUNGT(G)		; NEVER STARTED DRIVE YET
DSKT1A:	MOVEI B,DIP0		; INITIAL FSM FOR DRIVE
	MOVE A,CHCW(G)
	TLNN A,(1B13)		; RETRYING?
	JRST DSKT1B		; NO.
	MOVEI B,DIP2A		; YES. START AT THE READ
	SKIPL RETRYC(G)		; UNLESS ALL COUNTED OUT
	JRST DSKT1B		; STILL TRIES LEFT. GO READ.
	MOVSI A,(1B13)		; TOO MANY. CLEAR RETRY FLAG
	ANDCAB A,CHCW(G)	; SET TO RUN CHECKER
	MOVE C,TRK(G)		; PUT IT IN THE BADSPOT TABLE
	HRL C,G			; PUT DRIVE IN LH
	MOVSI B,-NBADSP		; AND PUT RESULT IN TABLE
	SKIPL SPOTTB(B)		; FREE SLOT? (NEGATIVE)
	AOBJN B,.-1		; NO, FIND ONE
	SKIPGE B		; ONE FOUND?
	MOVEM C,SPOTTB(B)	; YES. STORE THE BAD SPOT
	MOVEI B,DIP3		; CHECKER WILL MOVE PAST THE ERROR
DSKT1B:	HRRM B,CHCW(G)
	MOVE B,CPGP(G)
	HRRI B,[0]
	TLNE A,4000
	SKIPE OFFLIN(G)
	SKIPA			; DON'T START DRIVE
	MOVEM B,DEVL(G)		; GIVE IT EMPTY CMD LIST TO GET INT
	AOBJN G,DSKT1

	MOVE A,[600000,,DEVL]
	MOVEM A,@CBASE
	CONO SA0,@STPIEC
	CONO SA0,@STBSYC
DSKT2:	MOVSI G,-NPACKS
DSKT3:	MOVE A,CHCW(G)
	TLNE A,2
	JRST FILLIT
	TLNE A,4
	JRST CHKIT
	SKIPG B,HUNGT(G)	; SEE IF DRIVE IS HUNG
	JRST DSKT4		; NEGATIVE MEANS IDLE
	ADDI B,^D60*^D30	; TIME TILL DRIVE IS HUNG (TICKS)
	CAMG B,TIME		; THAT LONG SINCE INT?
	JRST HUNG		; YUP
DSKT4:	MOVSI B,10		; DRIVE JUST COME ON LINE?
	TDNN B,CHCW(G)		; ..
	JRST DSKT5		; NOPE.
	ANDCAM B,CHCW(G)	; YES. CLEAR THE FLAG AND COMMENT.
	MOVEI D,(G)
	MOVEI C,[ASCIZ /*** DRIVE %D RUNNING, /]
	PUSHJ P,STYO
	PUSHJ P,PTIME
DSKT5:	AOBJN G,DSKT3
	MOVE A,TIMEC
	CAIGE A,^D60*^D60*^D15
	JRST DSKT2
	SETZM TIMEC
	MOVEI C,[ASCIZ /
TIME CHECK:  /]
	PUSHJ P,STYO
	PUSHJ P,PTIME		; REPORT TOTAL TIME
	MOVEI C,[ASCIZ /SUMMARY:

DRIVE, BYTES READ, BYTES WRITTEN, CORR'BLE DATA CKS, OTHER ERRS

/]
	PUSHJ P,STYO
	MOVEI G,0
DSKSML:	MOVE D,NREAD(G)
	ASH D,-1
	IMULI D,11		; CONVERT TO BYTES (8 BITS)
	MOVE E,NWRITE(G)
	ASH E,-1
	IMULI E,11		; CONVERT TO BYTES
	MOVE F,NCORDC(G)
	MOVE H,ERRCT(G)
	MOVEI C,[ASCIZ /  %G,    $D,    $E,    $F,   $H
/]
	PUSHJ P,STYO
	CAIGE G,NPACKS-1
	AOJA G,DSKSML
	PUSHJ P,CR
	JRST DSKT2

FILLIT:	MOVEI A,NRETRY		; SET UP MAX COUNT IN CASE OF ERRORS
	MOVEM A,RETRYC(G)	; ..
	HRRZ A,ADDR(G)
	HRLI A,-RECL*NRPT
	MOVE C,CHCW(G)		; WANT RANDOM, OR SURFACE VERIFIER
	MOVE B,TRK(G)
	TLNE C,(1B9)		; ..
	JRST FILLV		; VERIFIER
FILI1:	MOVEM B,(A)
	SETCAM B,1(A)
	AOBJP A,FILX
	ROT B,1
	AOBJN A,FILI1
FILX:	MOVSI A,6
	ANDCAM A,CHCW(G)
	MOVE A,CPGP(G)
	HRRI A,[0]
	MOVEM A,DEVL(G)
	CONO SA0,@STBSYC
	JRST DSKT4

FILLV:	TLNE C,(2B8)		; WORST CASE?
	JRST FILLVW		; YES
	MOVEI B,0		; NO. ZEROES OR ONES
	TLNE C,(1B8)		; ..
	SETO B,			; ONES.
	MOVEM B,(A)
	AOBJN A,.-1		; FILL WITH THIS WORD
	JRST FILX

FILLVW:	MOVSI C,-NWCPDT		; GENERATE BUFFER FULL OF WORSTCASE PAT
FILVW1:	MOVE B,WCPDAT(C)
	MOVEM B,(A)		; A WORD OF THE PATTERN
	AOBJN C,.+2		; COUNT THE SOURCE
	MOVSI C,-NWCPDT		; WRAPAROUND
	AOBJN A,FILVW1
	JRST FILX

WCPDAT:	; 28-BIT REPEATING PATTERN FROM CALCOMP CONSULTANTS

IFG CV,<	; HERE IT IS EXCEPT FOR SA10 ROTATING/SPLITTING A BYTE
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 6,0,17,13,6,15,13,6,0
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 6,0,17,13,6,15,13,6,0
>
IFLE CV,<	;AND THIS IS SAME WITH ODD WORDS SHUFFLED AS NEEDED
	BYTE (4) 17,13,6,15,13,6,0,17,13
	BYTE (4) 15,13,6,0,17,13,6,15,6
	BYTE (4) 13,6,0,17,13,6,15,13,6
	BYTE (4) 17,13,6,15,13,6,0,17,0
	BYTE (4) 13,6,15,13,6,0,17,13,6
	BYTE (4) 13,6,0,17,13,6,15,13,15
	BYTE (4) 6,0,17,13,6,15,13,6,0
	BYTE (4) 13,6,15,13,6,0,17,13,17
	BYTE (4) 6,15,13,6,0,17,13,6,15
	BYTE (4) 6,0,17,13,6,15,13,6,13
	BYTE (4) 0,17,13,6,15,13,6,0,17
	BYTE (4) 6,15,13,6,0,17,13,6,13
	BYTE (4) 15,13,6,0,17,13,6,15,13
	BYTE (4) 0,17,13,6,15,13,6,0,6
>
NWCPDT==.-WCPDAT		;LENGTH OF REPEATED BLOCK

CHKIT:	MOVE C,CHCW(G)		; SEE IF IN RETRY SEQUENCE
	TLNN C,(1B13)		; ..
	JRST CHK0		; NO.
	MOVNI D,NRETRY+1	; YES. BUT READ OK NOW, SAY SO.
	ADD D,RETRYC(G)		; COMPUT READS NEEDED
	MOVMS D			; ..
	MOVEI E,(G)		; RH DRIVE NUMBER
	MOVEI C,[ASCIZ /DRIVE %E READ OK ON PASS $D.

/]
	PUSHJ P,STYO
	MOVSI A,(1B13)		; CLEEAR RETRYING FLAG
	ANDCAM A,CHCW(G)
CHK0:	HRRZ A,ADDR(G)
	HRLI A,-RECL*NRPT
	MOVE C,CHCW(G)		; RANDOM OR FIXED PATTERN?
	TLNE C,(1B9)		; ..
	JRST CHKV		; FIXED. VERIFY SURFACE
	SKIPGE RETRYC(G)	; PERMANENT ERROR?
	JRST CHKX		; YES. DON'T TEST DATA
	MOVE B,TRK(G)
CHK1:	CAME B,(A)
	PUSHJ P,UNDET		; UNDETECTED ERROR!!
	SETCM C,1(A)
	CAME B,C
	JRST [	ADDI A,1	; UNDETECTED ERROR. MAKE AC'S LIKE 
		SETCA B,	; IN OTHER CALLS TO ERR ROUTINE
		PUSHJ P,UNDET
		SETCA B,
		SOJA A,.+1]
	AOBJP A,FILX
	ROT B,1
	AOBJN A,CHK1
CHKX:	SETZM RETRYC(G)		; START FRESH
	JRST FILX

CHKV:	SKIPGE RETRYC(G)	; END OF PERMANENT ERROR?
	JRST CHKVX		; YES.
	TLNE C,(2B8)		; WORST CASE PATTERN?
	JRST CHKVW		; YES
	MOVEI B,0		; NO. ZEROES, OR ONES
	TLNE C,(1B8)		; ..
	SETO B,			; ONES.
	CAME B,(A)		; IS WORD CORRECT?
	PUSHJ P,UNDET		; NO. UNDETECTED ERROR.
	AOBJN A,.-2		; CHECK WHOLE BUFFER
	JRST CHKVX		; DONE

CHKVW:	MOVSI C,-NWCPDT		; COUNT THRU CORRECT DATA
CHKVW1:	MOVE B,WCPDAT(C)	; GET CORRECT DATUM
	CAME B,(A)		; IS THIS WHAT WE READ?
	PUSHJ P,UNDET		; NO. UNDETECTED ERROR
	AOBJN C,.+2		; OK, COUNT THRU GOOD DATA
	MOVSI C,-NWCPDT		; WRAP AROUND
	AOBJN A,CHKVW1
CHKVX:	AOS A,TRK(G)		; ON TO NEXT HEAD
	CAIGE A,^D411*^D19	; ALL DONE?
	JRST CHKVXX		; NO
	SETZM TRK(G)		; YES. ON TO NEXT PATTERN, BACK TO CYL 0
	LDB A,[POINT 2,CHCW(G),8]
	ADDI A,1
	CAIL A,3
	MOVEI A,0		; RECYCLE AFTER ALL DONE
	DPB A,[POINT 2,CHCW(G),8]
	JUMPN A,CHKVXX
	MOVEI D,(G)
	MOVEI C,[ASCIZ /FINISHED VERIFY PASS ON DRIVE %D.
/]
	PUSHJ P,STYO
CHKVXX:	JRST CHKX

PTIME:	MOVE A,TIME		; REPORT TOTAL TIME
	IDIVI A,^D60*^D60*^D60	; HOURS TO A
	MOVE D,A
	IDIVI B,^D60*^D60	;MINUTES TO B
	MOVE E,B
	MOVEI C,[ASCIZ /TIME $D HOURS, $E MINUTES
/]
	PUSHJ P,STYO
	POPJ P,0

HUNG:	SETOM HUNGT(G)		;SO DOESN'T REPEAT
	MOVEI D,(G)
	MOVEI C,[ASCIZ /
***   DRIVE %D HUNG, /]
	PUSHJ P,STYO
	PUSHJ P,PTIME
	JRST DSKT4

APRI:	0
	CONSZ APR,10000
	JSR BAD	;NXM
	CONSZ PI,200000
	JSR BAD	;PAR ERR
	CONSO APR,1000
	JRST 12,@APRI
	AOS TIME
	AOS TIMEC
	CONO 1000+APRCH
	JRST 12,@APRI

UNDET:	PUSH P,C		; HERE ON UNDETECTED READ ERROR
	PUSH P,A		; OR CATASTROPHE CAUSING CHECK ROUTINE
	PUSH P,B		; TO FAIL. SAVE AC'S
	MOVEI D,(G)		; DRIVE NUMBER
	MOVE E,TRK(G)		; CYL AND HEAD
	IDIVI E,^D19		; CYL TO E, HD TO F
	MOVEI C,[ASCIZ /
*** UNDETECTED ERROR, DRIVE %D, CYLINDER %E, HEAD %F
/]
	PUSHJ P,STYO
	MOVE D,0(P)
	MOVE A,-1(P)
	MOVE E,0(A)
	MOVEI C,[ASCIZ /    WORD SHOULD BE %D, BUT WAS %E
/]
	PUSHJ P,STYO
	PUSHJ P,PTIME
	PUSHJ P,CR2
	POP P,B
	POP P,A
	POP P,C
	SKIPE SERR		; STOP ON ERROR?
	JSR GOPR		; YES. RING FOR HUMAN OPERATOR
	POPJ P,0

BAD:	0
	CONO PI,400
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	HRRZ D,BAD
	MOVEI C,[ASCIZ /BAD ERROR FROM %D
/]
	PUSHJ P,STYO
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	SKIPN SERR
	JRST DSKT0
	JSR GOPR

GOPR:	0
	DATAI TTY,B
GOPR1:	MOVEI B,7
	PUSHJ P,TYO
	CONSO TTY,40
	JRST GOPR1
	JRST DDT



CPGP:
IFLE CV,<
	BYTE (8)320,IDEV(20)CPG0
	BYTE (8)320,IDEV+1(20)CPG1
	BYTE (8)320,IDEV+2(20)CPG2
	BYTE (8)320,IDEV+3(20)CPG3
	BYTE (8)320,IDEV+4(20)CPG4
	BYTE (8)320,IDEV+5(20)CPG5
	BYTE (8)320,IDEV+6(20)CPG6
	BYTE (8)320,IDEV+7(20)CPG7
>
IFG CV,<
	BYTE (8)IDEV,320(20)CPG0
	BYTE (8)IDEV+1,320(20)CPG1
	BYTE (8)IDEV+2,320(20)CPG2
	BYTE (8)IDEV+3,320(20)CPG3
	BYTE (8)IDEV+4,320(20)CPG4
	BYTE (8)IDEV+5,320(20)CPG5
	BYTE (8)IDEV+6,320(20)CPG6
	BYTE (8)IDEV+7,320(20)CPG7
>

; CONTROL WORDS FOR DRIVE. DISPATCH IN RH, BITS IN LH.
; SEE COMMENTS ON BIT USAGE AT DIP0
CHCW:	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0
	374000,,0

ADRLO:	33000		;FIRST AREA FREE FOR BUFFERS
			; SPACE TO LOAD PROG AT 1000, DDT, SYMS.
ADRHI:	777000		;FIRST NON-EX ADDR

;;for CPY..
CLSSD==33000	;contents of ADRLO!!

ADDR:	BLOCK 10		; DATA AREAS PER DRIVE
OFFLIN:	BLOCK 10		; NON-ZERO IF DRIVE OFF LINE
NREAD:	BLOCK 10
NWRITE:	BLOCK 10
NCORDC:	BLOCK 10
ERRCT:	BLOCK 10		; NUMBER OF ERRORS OTHER THAN CORR-
				; ECTABLE DATA CHECKS AND STATISTICS
TRK:	BLOCK 10		; CYL*19 + HEAD OF CURRENT TRANSFER
RETRYC:	BLOCK 10		; COUNTER FOR CORRECTABLE DATA CK'S

HUNGT:	BLOCK 10		;VALUE OF TIME WHEN INT OCCURRED.
				; MINUS ONE IF HUNG OR NOT STARTED.

DEVN:	0
ACS:	BLOCK G+1
SERR:	0
DSVFLG:	0			; DSK SURFACE VERIFIER FLAG

SPOTTB:	REPEAT NBADSP,<-1>	; SPACE FOR BAD SPOTS. -1 IS FREE
	-1			; AND ONE FOR END TEST

DEVL:	-1
	0
	0
	0
	0
	0
	0
	0
	0

TIME:	0
TIMEC:	0
SENSCT:	0
DSTAT:	BLOCK 4			; COPY OF 4 WORDS FROM LOW CORE
				; ON CHANNEL COMPLETION

FRY:	CONO SA0,SASTEP	;STOP CLK
	DATAI TTY,A
	MOVEI C,[ASCIZ /
PROM #: /]
	PUSHJ P,NUMGM
	CAIE B,40
	JRST FRY
	CAIL A,20
	HRROI A,-20(A)
	MOVEM A,PNO
FRY0:	MOVEI C,[ASCIZ /
FN: /]
	PUSHJ P,TYIM
	CAIN B,"F"
	JRST FRYP
	CAIN B,"R"
	JRST REFRY
	CAIN B,"V"
	JRST VERIFY
	CAIN B,"T"
	JRST TROM
	JRST FRY

FRYP:	JSP L,FLOOPN
	  JRST FNEWT
REFRY:	JSP L,FLOOPN
	  JRST FRTST
	LDB F,[430100,,PNO]
	JSP L,FLOOP
	  JRST FRYIT
VERIFY:	MOVEI G,10
VER0:	MOVEI F,0
VER1:	JSP L,FLOOP
	  JRST VFTST
	CAIE F,2
	AOJA F,VER1
	SOJG G,VER0
	MOVEI C,[ASCIZ / OK/]
	PUSHJ P,STYO
	JRST FRY

FLOOPN:	MOVEI F,0
FLOOP:	MOVEI A,(F)
	PUSHJ P,FRS
	MOVEI A,^D2000
	SOJG A,.
	MOVEI A,1100	;RUN
	PUSHJ P,FRS
	SKIPE B
	JSR FERR	;RUN ON
	MOVEI A,1240
	PUSHJ P,FRS
	SKIPGE PNO
	TRC B,1
	SKIPN B
	JSR FERR	;NOT RIGHT SIZE
	SETZB H,I
FLUP1:	MOVEI A,400(I)
	PUSHJ P,FRS	;PUT OUT ADDR
	MOVEI A,1000
	MOVEI D,0
FLUP2:	PUSHJ P,FRS	;SET BIT #
	LSH D,1
	IOR D,B
	CAIN A,1007
	JRST FLUP2A
	SKIPL PNO
	CAIE A,1003
	AOJA A,FLUP2
FLUP2A:	MOVE A,PNO
	JUMPL A,FLUP2B
	MOVE B,I
	TRC B,377
	LSH B,1
	TRZE B,400
	ADDI B,1
	LDB C,[020300,,A]
	DPB C,[100300,,B]
	MOVE C,MCBEG0(B)
	TRNE A,2
	LSH C,10
	TRNE A,1
	LSH C,4
	LDB E,[140400,,C]
	JRST (L)

FLUP3E:	PUSHJ P,STYO
	MOVEI H,1
	CONSZ TTY,40
	JRST FRY
FLUP3:	CAIN I,377
	JRST FLUP3A
	SKIPGE PNO
	CAIE I,37
	AOJA I,FLUP1
FLUP3A:	JUMPE H,1(L)
	JRST FRY

FLUP2B:	LSH A,5
	ADD A,I
	MOVE E,SMPT(A)
	JRST (L)

FRS:	DATAO SA0,A
FRST:	CONI SA0,B
	MOVSS B
	ANDI B,1
	POPJ P,

FNEWT:	JUMPE D,FLUP3
	MOVEI C,[ASCIZ ?
%I/  %D?]
	JRST FLUP3E

VFTST:	CAMN D,E
	JRST FLUP3
	MOVEI C,[ASCIZ ?
%I/  %D  %E?]
	JRST FLUP3E
FRTST:	SETCM A,E
	TDNN A,D
	JRST FLUP3
	MOVEI C,[ASCIZ ?
CAN'T FRY %I/  %D TO %E?]
	JRST FLUP3E

FRYIT:	XOR E,D
	TDNE E,D
	JSR FERR
	MOVEI A,1000
FRYIT1:	SKIPGE PNO
	JRST FRIT1A
	TRNN E,10
	JRST FRYIT2
FRIT1B:	PUSHJ P,FRS
	SKIPE B
	JSR FERR	;BIT SHOULD HAVE BEEN 0
	TRO A,100
	PUSHJ P,FRS
	SKIPE B
	JSR FERR	;RUN SHOULD HAVE BEEN OFF
	TRO A,400
	PUSHJ P,FRS	;ZAP!
	SKIPN B
	JSR FERR	;RUN DIDNT SET
	MOVEI C,^D10000
FRYIT3:	PUSHJ P,FRST
	JUMPE B,FRYIT4
	SOJG C,FRYIT3
	JSR FERR	;TIMEOUT
FRYIT4:	TRZ A,500
	PUSHJ P,FRS
	SKIPN B
	JSR FERR	;BIT DIDNT FRY
FRYIT2:	LSH E,1
	CAIN A,1007
	JRST FLUP3
	SKIPL PNO
	CAIE A,1003
	AOJA A,FRYIT1
	JRST FLUP3

FRIT1A:	TRNN E,200
	JRST FRYIT2
	JRST FRIT1B

PNO:	0
FERR:	0
	MOVE H,FERR
	MOVEI A,(F)
	PUSHJ P,FRS
	MOVEI C,[ASCIZ ?
FRY ERR PC=%H, ROM ADDR=%I?]
	PUSHJ P,STYO
	JRST FRY

TYIM:	PUSHJ P,STYO
TYI:	CONSO TTY,40
	JRST .-1
	DATAI TTY,B
	ANDI B,177
	JRST TYO

NUMGM:	PUSHJ P,STYO
NUMG:	MOVEI A,0
NUMG1:	PUSHJ P,TYI
	CAIG B,"9"
	CAIGE B,"0"
	POPJ P,
	LSH A,3
	ADDI A,-"0"(B)
	JRST NUMG1

HTYO:	CAIL B,12
	ADDI B,"A"-"9"-1
	JRST OPT3

TROM:	JSP L,FLOOPN
	  JRST TROM1
	JRST FRY0

TROM1:	TRNE I,7
	JRST TROM2
	PUSHJ P,CR
	MOVE A,I
	PUSHJ P,OPT
	MOVEI B,40
	PUSHJ P,TYO
TROM2:	MOVE B,D
	SKIPL PNO
	JRST TROM3
	PUSH P,B
	MOVEI B,40
	PUSHJ P,TYO
	LDB B,[40400,,(P)]
	PUSHJ P,HTYO
	POP P,B
	ANDI B,17
TROM3:	PUSHJ P,HTYO
	JRST FLUP3

SMPT:	EXP 007,007,007,007,007,007,007,007
	EXP 007,007,007,007,007,007,007,007
	EXP 207,107,047,027,017,003,005,005
	EXP 007,007,007,007,006,377,017,007
SMPT1:	EXP 000,000,000,000,364,364,364,364
	EXP 364,363,070,010,364,310,070,010
	EXP 000,000,000,000,000,000,000,000
	EXP 000,000,000,000,000,000,000,000
SMPT2:	EXP 020,010,004,002,001,000,000,000
	EXP 001,020,010,004,002,000,000,000
	EXP 000,000,000,000,000,037,010,000
	EXP 000,000,000,000,000,000,000,000

RCROM1:
	EXP 000,105,012,101,240,123,111,125
	EXP 015,104,122,112,116,106,103,113
	EXP 124,132,114,127,110,131,120,121
	EXP 117,102,107,200,115,130,126,377

RCROM2:
	EXP 000,063,012,055,240,007,070,067
	EXP 015,044,064,047,054,041,072,050
	EXP 065,042,051,062,043,066,060,061
	EXP 071,077,045,200,056,057,073,377

RCROM3:
	EXP 000,140,210,250,220,100,050,320
	EXP 010,040,170,260,110,340,240,360
	EXP 150,330,120,020,300,060,030,160
	EXP 230,270,310,104,024,124,264,214

RCROM4:
	EXP 200,026,112,000,000,000,130,000
	EXP 266,262,000,000,316,206,126,224
	EXP 374,174,074,034,014,004,204,304
	EXP 344,364,000,252,000,000,000,062

;FORMAT A PACK. ASSUMES REC 0 EXISTS, WRITES 1-5

FMT:	MOVEI P,PDL-1
	PUSHJ P,RSTALL
	MOVE CN,DCHAN
	PUSHJ P,CSET
	MOVEI D,IDEV		; DEVICE TO FORMAT
	MOVEI F,0		; FORMAT PATTERN NUMBER. (JUST 0 NOW)
FMT0:	LSH D,^D12
	MOVE I,FMTM	;0=HA, R0 ARE GOOD; 1=WRT R0; -1=WRT HA AND R0
	;PUT IN DEV FLD
	MOVE J,RECSIZ(F)
	IMULI J,^D9
	ADDI J,1
	ASH J,-1	;J HAS SIZE IN BYTES
	LSH J,4
	MOVEI E,0
FMT1:	TRZ E,7760		; CLEAR HEAD FIELD
	MOVE H,ADRLO	;PLACE TO PUT C C H H # KL DL DL
	MOVSI C,200000	;A TIC CMD
	ADDI C,<NRPT+1>*^D20*2(H)	;LEAVE ROOM FOR DATA
	MOVEM C,FWP0
	JUMPE I,FMT1A	;IF NO SET FM NEEDED
	MOVE G,[BYTE (8)70,37]	;SET FM
	PUSHJ P,FMTS0
	MOVE G,[-1,,[BYTE (8)300]]	;ALLOW ALL
	PUSHJ P,FMTS1
FMT1A:	TRNE E,7760	;ALWAYS SEEK IF HEAD 0
	JUMPGE I,FMT1B	;OR IF WRITING HA'S
	MOVE G,[BYTE (8)70,7]	;SEEK
	PUSHJ P,FMTS0
	MOVE G,[400000-2,,[0]]	;2 BYTES OF BB
	PUSHJ P,FMTS1
	MOVSI G,-4
	PUSHJ P,FMTS1A
FMT1B:	JUMPL I,FMT1C
	JUMPG I,FMT1D
	MOVE G,[BYTE (8)70,61]	;SRCH ID EQ
	TRNE E,7760
	TLO G,1000	;SET M-T IF NOT 1ST REC
	PUSHJ P,FMTS0
	MOVSI G,-5
FMT1BR:	PUSHJ P,FMTS1A
	PUSHJ P,FMTS2
;FALLS THRU
;FALLS IN
FMT1E:	TLZ J,776000	;SET RN TO 0
FMT2:	MOVEM E,(H)
	MOVEM J,1(H)
	MOVEI A,200
	TLNN J,776000
	HRRM A,1(H)	;R0 HAS DL OF 8
	ADDI H,2
	CAML J,NRECS2(F)
	JRST FMT2A	;NO MORE RECS ON TRK
	ADD J,[2000,,0]
	MOVE G,[BYTE (8)72,35]	;SLI, WRT CKD
	PUSHJ P,FMTS0
	MOVSI G,-^D8
	PUSHJ P,FMTS1A
	JRST FMT2
FMT2A:	ADDI E,20
	LDB A,[41000,,E]
	CAMGE A,NHEDS(F)
	JRST FMT1A	;MORE TRKS ON CYL
	MOVE G,[BYTE (8)240,3]	;NOP
	PUSHJ P,FMTS0
	SETZM (C)
	MOVE A,FWP0
	PUSHJ P,SCHN	;FORMATS ONE CYL
	ADD E,[4,,0]		; COUNT A CYLINDER
	LDB A,[242000,,E]	; WHAT CYLINDER ARE WE UP TO?
	CAMGE A,NTRKS(F)
	JRST FMT1		; NOT DONE YET.
	MOVEI C,[ASCIZ /
FORMATTER DONE.
/]
	PUSHJ P,STYO
	JRST DDT

FMT1D:	MOVE G,[BYTE (8)70,71]	;SRCH HA EQ
	TRNE E,7760
	TLO G,1000	;SET M-T IF NOT 1ST TRK
	PUSHJ P,FMTS0
	MOVSI G,-4
	PUSHJ P,FMTS1A
	PUSHJ P,FMTS2
	JRST FMT1CR

FMT1C:	MOVE G,[BYTE (8)70,31]	;WRT HA
	PUSHJ P,FMTS0
	MOVE G,[400000-1,,[0]]
	PUSHJ P,FMTS1	;PUT OUT A ZERO FLAG BYTE
	MOVSI G,-4
	PUSHJ P,FMTS1A
FMT1CR:	MOVE G,[BYTE (8)72,25]	;WRITE R0
	PUSHJ P,FMTS0
	MOVSI G,-^D8
	PUSHJ P,FMTS1A
	JRST FMT1E

FMTS0:	ADD G,D
FMTS3:	MOVEM G,(C)
	ADDI C,1
	POPJ P,

FMTS2:	MOVE G,C
	SUBI G,2
	JRST FMTS3

FMTS1A:	HRR G,H
FMTS1:	HLLZ A,G
		LSH A,CNTSFT
	SKIPL G
	TLZ A,400000
	HLL G,A
	JRST FMTS3

MXRECT=40			; MAX RECORDS PER TRACK
DEVFLD=141000
; FOLLOWING 4 ARE TABLES, OF LENGTH 1 NOW, DEFINING A FORMAT OF
; A PACK. INDEXED BY F IN FMT ABOVE
RECSIZ:	RECL
NRECS2:	NRPT*2000,,0
NHEDS:	^D19
NTRKS:	^D411

FWP0:	0	;PTR TO CHNL PRGM
FMTM:	0	;FORMATTING MODE

;CPY::  this section is for copying entire (formatted) disk packs
;
; To do a copy, you must first set up locations SRCDRV and DESDRV.  They hold
; respectively, the source and destination subchannel & drive numbers.
; There are two different copy processes, determined by ONEPAS.  If
; ONEPAS is zero, SRCDRV will be entirely copied to DESDRV and then
; verified; both actions are done with one track at a time.  If ONEPAS
; is non-zero (normally), each record of SRCDRV is copied to DESDRV
; and immediately verified.  HDCRSH controls whether or not a permanent
; disk error stops the copy, or just records the error code words.  It is
; normally zero; it stops the copy, prints the error, and aborts to EDDT.
; If HDCRSH is non-zero, it automatically continues after disk errors.  If
; it can't read a record from SRCDRV, it will zero the corresponding record
; on DESDRV.  To start, type CPY<altmode>G to EDDT.
;  *** SRCDRV and DESDRV must be reset for each copy process ***
;
; If you just want to verify one pack against another, set JSTVER
; to -1; this is good for one time only!!  You must reset JSTVER if
; you must restart from an error or do it for another set of packs.
; Otherwise (normally) just leave it alone!!
;
; The verify cycle will normally try one correction if it finds a 
; mismatch between corresponding tracks.  That is, it will re-write
; the copy (one time only) and attempt to verify again.  If it
; still fails, it will complain.  This corrective verification
; can be stopped by setting CORVER to 0; then it will immediately
; complain on the first mis-match found.
;
; For you lite watchers::  BF (16)
;  B0 copy cycle,  B1 verify cycle,  B2 verify 1st time failure
;  B7 stat report,  B8 irrecoverable error
;  B9-B11 count of retry on correctable data check
;  B13-B14 SA-10 subchannel
;  B15-B17 drive responsible for error
;  B18-B29 cylinder,  B30-B35 head
;
; Also::  J (12)
;  B0-B17 count of verification 1st time failures
;  B18-B35 disk error sense storage address (steps by 11(8))


OPDEF	PCALL	[PUSHJ	P,]
OPDEF	PRET	[POPJ	P,]
OPDEF	PSAVE	[PUSH	P,]
OPDEF	PREST	[POP	P,]


;pertinent memory::

;  the following two locations should be filled prior to CPY$G
SRCDRV:	-1	;source-  subchannel,,drive
DESDRV:	-1	;destination-  subchannel,,drive

ONEPAS:	-1	;normally one-pass copy process
HDCRSH:	0	;head crashes don't happen very often
CORVER:	-1	;corrective verification flag
JSTVER:	0	;just verify flag


;the following are the main data buffer definitions:

ORGBUF==40000		;always read SRCDRV data into here
CPYBUF==50000		;during verify, read DESDRV data into here
MSKBUF==60000		;stores ORGBUF(i).xor.CPYBUF(i) of verify


;SENSE I/O command list..

SCHS:	CW <050,004,.-.>
	IOW 30,SENSED
	0


;some temporaries..

EREND:	0		;end of disk error sense info (zero if none stored)
TENPCK:	-1		;drive # of TENEX files pack currently being copied

CACS:	BLOCK	20

;TENEX file system copy...
;  *** Assumptions ***
;    1) There are NPACKS drives in the file system
;    2) The file system packs are on SA-10 subchannel 0
;    3) The scratch packs are on SA-10 subchannel 1
;
;  Other flags (ONEPAS, HDCRSH, CORVER, JSTVER) should be set as
;  desired (OR LEFT ALONE) before SYSDMP<altmode>G.

SYSDMP:
	MOVEI	P,PDL-1
	MOVEI	D,NPACKS-1	;go from drive NPACKS-1 to 0
	MOVEM	D,TENPCK
SDMP1:
;;	HRLI	D,0		;set params for CPY..
	MOVEM	D,SRCDRV
	HRLI	D,1
	MOVEM	D,DESDRV
	PCALL	CPY+2
	SOSL	D,TENPCK	;all done when 0 has been copied
	JRST	SDMP1
	JRST	DDT

CPY:
	MOVEI	P,PDL-1		;do some initialization..
	SETOM	TENPCK		;<claim not TENEX copy--will start CPY+2 if so>
	SETZM	CPY$P-1
	PCALL	RSTALL

	SKIPL	SRCDRV		;minor check on drive #'s..
	SKIPGE	DESDRV
	JRST [	MOVEI	C,[ASCIZ " ?? SRCDRV,DESDRV ??
"]
		PCALL	STYO
		JRST	DDT ]

	MOVEI	F,0		;format pattern of disks (see FMT)

	MOVEI	BF,0		;set up lite show..
	MOVEI	J,100000	; store disk error sense info above 100000

	PCALL	DOCPGL

	SKIPE	HDCRSH		;at least for now, "head-crash"
	SETOM	ONEPAS		;  forces "one-pass"!!!

	SKIPE	ONEPAS		;give em what they asked for..
	PCALL	CPY1
	SKIPN	ONEPAS
	PCALL	CPY2

CPYDON:	;all done, reset some of the parameters..
	MOVEI	C,[ASCIZ "COPIED DRIVE %D TO DRIVE %E
"]
	HRRZ	D,SRCDRV
	HRRZ	E,DESDRV
	PCALL	STYO
	SETOM	SRCDRV		;make-em set SRCDRV & DESDRV each time--
	SETOM	DESDRV		;  it may be a pain, but it's safe!!
	CAIN	J,100000
	SETZ	J,
	MOVEM	J,EREND
	SKIPL	TENPCK
	PRET
	JRST	DDT

;  Set up three major SA-10 command lists:
;    CPG0 -- read one track from SRCDRV into ORGBUF
;    CPG1 -- write one track from ORGBUF onto DESDRV
;    CPG2 -- read one track from DESDRV into CPYBUF

DOCPGL:
	HRRZ	D,SRCDRV
	HRRZ	E,DESDRV
	LSHC	D,^D12
	IOR	D,[ CW <070,007,IDEV>,]	  ; SEEK
	IOR	E,[ CW <070,007,IDEV>,]
	MOVEM	D,CPG0+0
	MOVEM	E,CPG1+0
	MOVE	[ IOW 6,CLSSD+0,]	  ;  ptr to 6 byte SEEK argument ( 0 0 C C H H )
	SETZM	CLSSD+0			  ;    cylinder 0,
	SETZM	CLSSD+1			  ;    head 0
	MOVEM	CPG0+1
	MOVEM	CPG1+1
	MOVE	A,[ TIC CPG0+2,]
	MOVE	B,[ TIC CPG1+2,]
	MOVE	C,[ TIC CPG2+2,]
	MOVN	I,RECSIZ(F)
	ASH	I,^D18+CNTSFT
	MOVE	G,[ BYTE (8)1 ]
	MOVE	H,[ IOW 5,CLSSD+2,]
CPGL:
	XOR	D,[ CW <000,066>,]	  ; SEARCH ID EQUAL
	XOR	E,[ CW <000,066>,]
	MOVEM	D,0(A)
	MOVEM	E,0(B)
	MOVEM	E,0(C)
;;	MOVE	H,[ IOW 5,CLSSD+2*rec#,]  ;  ptr to 5 byte SEARCH argument ( C C H H R )
	SETZM	0(H)			  ;    cylinder 0, head 0,
	MOVEM	G,1(H)			  ;    record #
	MOVEM	H,1(A)
	MOVEM	H,1(B)
	MOVEM	H,1(C)
	MOVEM	A,2(A)			  ; TIC's
	MOVEM	B,2(B)
	MOVEM	C,2(C)
	XOR	D,[ CW <010,067>,]	  ; READ DATA
	XOR	E,[ CW <010,064>,]	  ; WRITE DATA
	MOVEM	D,3(A)
	MOVEM	E,3(B)
	XOR	E,[ CW <000,003>,]	  ; READ DATA
	MOVEM	E,3(C)
	MOVE	I			  ;  IOWD ptr for READ(WRITE)
	HRRI	ORGBUF(I)
	MOVEM	4(A)
	MOVEM	4(B)
	HRRI	CPYBUF(I)
	MOVEM	4(C)
	XOR	D,[ CW <010,001>,]	  ;  ready to make SEARCH ID EQUAL
	XOR	E,[ CW <010,001>,]
	ADDI	A,5
	ADDI	B,5
	ADDI	C,5
	ADD	I,RECSIZ(F)
	ADDI	H,2
	ADD	G,[ BYTE (8)1 ]
	CAMG	G,NRECS2(F)
	JRST	CPGL

	MOVE	[ CW <020>,]	;for CPG0, CPG2..
	XORM	-5+3(A)		;  unchain last READ
	SETZM	0(A)		;  end.of.list
	XORM	-5+3(C)
	SETZM	0(C)
	MOVN	I,NRECS2(F)	; then get lh.of.aobjn.ptr for verify loop
	ASH	I,-^D10
	IMUL	I,RECSIZ(F)
	PRET

CPY1:
	MOVE	[ TIC CPG2+2,]	;fix CPG1 properly,
	AOSN	JSTVER		;  if "just verify"
	MOVEM	CPG1+2		;   don't do copy portion of CPG1!
	MOVEM	0(B)		;  if not, transfer to READ after WRITE.
	HRRI	I,(B)
	TLO	BF,(1B0!1B1)
;;	JRST	D1CPY

D1CPY:	;1-pass copy/verify loop...
	HLRZ	CN,SRCDRV
	PCALL	CSET
	MOVEI	K,D1ZT
	MOVEI	A,CPG0		;read original data,
	PCALL	SCHN
	HLRZ	CN,DESDRV
	PCALL	CSET
	MOVEI	K,D1INC
	MOVEI	A,CPG1		; [copy] & read copy,
	PCALL	SCHN
	SKIPN	JSTVER
	JRST	D1VER
	HLRZ	CN,SRCDRV
	PCALL	CSET
	MOVEI	A,CPG0		; and re-read original if not "just verify".
	PCALL	SCHN
D1VER:
	HLLZ	E,I		;do the short fast version of verify..
	MOVE	CPYBUF(E)
	CAMN	ORGBUF(E)
	AOBJN	E,.-2
	JUMPG	E,D1INC

	MOVEI	E,(E)		; <isolate addr>
	SKIPE	CORVER		;corrective verify?
	TLOE	BF,(1B2)	;already had 1st verify failure?
	JRST [	MOVEI	C,[ASCIZ "*** %N  %E
"]
		PCALL	STYO
		SKIPE	HDCRSH
		JRST	D1INC
		PCALL	CPYER
		JRST	D1CPY ]
	MOVEI	C,[ASCIZ " ?? %N  %E
"]
	PCALL	STYO
	JRST	D1CPY

D1ZT:	;possibly zero the current copy track..
	SKIPN	JSTVER		;if "just verify",
	JRST	D1INC		;  ignore this track.
	MOVEI	C,[ASCIZ " ZT "]
	PCALL	STYO
	MOVE	[ CW <020>,]	; fix CPG1 to just WRITE,
	XORM	-5+3(I)
	SETZM	0(I)
	SETZM	ORGBUF+0	; give it zero data,
	MOVE	[ ORGBUF+0,,ORGBUF+1 ]
	BLT	CPYBUF-1
	HLRZ	CN,DESDRV
	PCALL	CSET
	MOVEI	K,D1ZT1
	MOVEI	A,CPG1
	PCALL	SCHN
	PCALL	CR
D1ZT1:
	MOVE	[ CW <020>,]	;then restore CPG1 to normal.
	XORM	-5+3(I)
	MOVE	[ TIC CPG2+2,]
	MOVEM	0(I)
D1INC:
	TLZE	BF,(1B2)	; if any 1st verify failures,
	ADD	J,[ 1,,0 ]	;  count em!
	PCALL	DOINC
	JRST	D1CPY
	TLZ	BF,(1B0!1B1)
	PRET

CPY2:
	MOVE	[ CW <020>,]	;terminate list CPG1 properly..
	XORM	-5+3(B)		;  unchain last WRITE
	SETZM	0(B)		;  end.of.list
	AOSN	JSTVER		;just a verify?
	JRST	V2		; ya, don't do copy!
	TLO	BF,(1B0)
	PCALL	D2CPY

V2:	;this is the verify portion..
	MOVE	[ TIC CPG2+2,]	;modify CPG1 to READ DESDRV into CPYBUF
	MOVEM	CPG1+2		;  simply transfer control to CPG2
	TLO	BF,(1B1)
;;	JRST	D2CPY		;<let D2CPY PRET back>

D2CPY:	;2-pass copy/verify loop...
;  right now, HDCRSH will be zero if you come thru here; but if you take
;  out the check (CPYDON-6), you must add the appropriate "MOVEI K,loc"
;  for each call to SCHN!!!
	HLRZ	CN,SRCDRV
	PCALL	CSET
	MOVEI	A,CPG0		;read the original track,
	PCALL	SCHN
	HLRZ	CN,DESDRV
	PCALL	CSET
	MOVEI	A,CPG1		;  & copy it (read copy).
	PCALL	SCHN

	TLNE	BF,(1B1)	; verify?
	PCALL	D2VER
	TLZE	BF,(1B2)	;  was there a 1st time failure?
	ADD	J,[ 1,,0 ]	;   ya, show in lites even tho it's listed!

	PCALL	DOINC
	JRST	D2CPY
	TLZ	BF,(1B0!1B1)	;out of copy/verify.
	PRET

D2VER:	;verify the track just read in..
	HLLZ	A,I
	SETZ	E,		; E::  accumulative mask of unmatching bits
D2VL:
	MOVE	ORGBUF(A)	;compare original
	XOR	CPYBUF(A)	;  with copy
	MOVEM	MSKBUF(A)	;  and remember result.
	IOR	E,
	AOBJN	A,D2VL
	CAIN	E,0		;any problems?
	PRET

	SKIPE	CORVER		;corrective verify?
	TLOE	BF,(1B2)	;already had 1st time failure?
	JRST [	MOVEI	C,[ASCIZ "*** %N  %E
"]
		PCALL	STYO
		SKIPE	HDCRSH
		PRET
		PCALL	CPYER
		JRST	.+3 ]
	MOVEI	C,[ASCIZ " ?? %N  %E
"]
	PCALL	STYO

	MOVE	CPG2+2		;modify CPG1 to WRITE from ORGBUF
	MOVEM	CPG1+2
	HLRZ	CN,SRCDRV
	PCALL	CSET
	MOVEI	A,CPG0		;  and recopy track;
	PCALL	SCHN
	HLRZ	CN,DESDRV
	PCALL	CSET
	MOVEI	A,CPG1
	PCALL	SCHN
	MOVE	[ TIC CPG2+2,]	; then restore CPG1 to READ into CPYBUF
	MOVEM	CPG1+2
	MOVEI	A,CPG1		;  and reattempt verify.
	PCALL	SCHN
	HLRZ	CN,SRCDRV
	PCALL	CSET
	MOVEI	A,CPG0
	PCALL	SCHN
	JRST	D2VER

DOINC:	;incriment to the next sequencial track..
	MOVE	A,[ BYTE (8)0,1 ]
	ADDB	A,CLSSD+1
	LSH	A,-^D20
	CAMGE	A,NHEDS(F)	; copied cylinder yet?
	AOJA	BF,DIHED-1	;  no, keep going.
	MOVE	A,[ BYTE (8)0,0,0,1 ]
	ADDB	A,CLSSD+0
	LSH	A,-4
	CAMGE	A,NTRKS(F)	; copied entire pack?
	JRST	DICYL		;  no, go update for new cylinder.

;  all done,
	SETZM	CLSSD+0		; reset SEEK argurment:  cylinder 0,
	SETZM	CLSSD+1		;   head 0
	MOVEI	G,CLSSD+2
	SETZM	0(G)		; reset SEARCH "C C H H" argument part,
	ADD	G,[ BYTE (8)1 (28)2 ]
	CAMGE	G,NRECS2(F)
	JRST	.-3
	HRRI	BF,0		; don't forget the lite register!
	AOS	0(P)		; skip return to caller.
	PRET

DICYL:
	SETZM	CLSSD+1		; update conditions for next cylinder..
	MOVN	NHEDS(F)	;  head = 0
	ASH	4
	ADD	[ BYTE (8)0,1,0,1 ]	;  incr C C, zero H H
	TRO	BF,77
	AOJA	BF,DIHED

	MOVE	[ BYTE (8)0,0,0,1 ]	;  incr H H
DIHED:
	MOVEI	G,CLSSD+2	;loop to update SEARCH arguments..
	ADDM	0(G)
	ADD	G,[ BYTE (8)1 (28)2 ]
	CAMGE	G,NRECS2(F)
	JRST	.-3
	PRET

;Some simple error handling stuff for CPY...

CPYER:	;do any updates before EDDT..
	MOVEM	CACS+0
	MOVE	[ 1,,CACS+1 ]
	BLT	CACS+17
CPYER1:
	MOVEM	J,EREND
	SETOM	CPY$P-1
	JRST	DDT

	0
CPY$P:	;to proceed from EDDT
	AOSE	CPY$P-1		;only allow entry if CPYER happened!
	JRST	DDT
	PCALL	RSTALL		; don't leave any funny conditions lying around!
	MOVSI	P,CACS+0
	BLT	P,P
	PRET


ERRPT:	;error (statistics) report for last CPY...
	SKIPN	EREND
	JRST	DDT
	MOVEI	J,100000
ERPL:
	MOVE	BF,0(J)
	MOVSI	3(J)
	HRRI	SENSED+0
	BLT	SENSED+5
	PCALL	CR
	LDB	A,[ 340600,,SENSED+0 ]
	PCALL	DPHADR
	MOVEI	C,[ASCIZ "  %N  \D  %E
"]
	MOVE	D,1(J)
	MOVE	E,2(J)
	PCALL	STYO
	PCALL	PSB
	ADDI	J,11
	CAMGE	J,EREND
	JRST	ERPL
	PCALL	CR
	JRST	DDT

;... SCHN:: start SA-10 subchannel (CN)
;
; Call--
;	<set up CN and K as necessary>
;	MOVEI A,list.loc
;	PCALL SCHN
;
; ACs:	CN -- <subchannel.number>*10
;	K  -- where to go when permanent error & HDCRSH is non-zero
;
; Returns:
;	+1 -- always (unless error exit thru K)

	MOVE	A,-1(P)		;fake original "PCALL SCHN"
	XCT	-2(A)
SCHN:
	HRLI A,200000
	MOVEM A,@CBASE+0
	CONO SA0,@STBSYC
	CONSO SA0,170
	JRST .-1
	CONO SA0,@CLSTFC
	MOVE A,@CBASE+1
	TLNN A,1314		;Status modifier, Channel end, Device end  OK
	PRET

	MOVEM A,STATW1		; otherwise, grounds to complain,
	MOVE @CBASE+2		;  or re-do if statistics..
	MOVEM STATW2
	LDB D,[DEVFLD,,STATW1]
	DPB D,[DEVFLD,,SCHS]
	ANDI	D,7
	TLO	BF,(D)		;show error info in lites..
	TLO	BF,(CN)
	TLNN	BF,3700		; since we had error, go to SCHNFX before
	PSAVE	[ SCHNFX ]	;  returning - but stack it only once!
	MOVE	[ TIC SCHS,]
	MOVEM	@CBASE+0
	SETOM	SENSED+0	;in case we don't do SENSE I/O
	TLNN	A,10		;if Unit check, do SENSE I/O..
	JRST	SCHNX
	CONO SA0,@STBSYC
	CONSO SA0,170
	JRST .-1
	CONO SA0,@CLSTFC
SCHNX:
	MOVEM	BF,0(J)		; store disk error sense info,
	MOVSI	STATW1		;  all 11 octal words of them
	HRRI	1(J)
	BLT	10(J)
	LDB	A,[ 202400,,SENSED+0 ]
	CAIN	A,1		; just a stat report?
	JRST	SCHNX1		;  yes..
	CAIN	A,100004	; a recoverable data check?
	JRST	SCHNX2		;  yes..
	MOVE	A,SENSED+0	; neither (permanent error)-
	TDNN	A,[ BYTE (8)100,002 ]
	SKIPN	HDCRSH		;  if Intervention.req or Read.only OR
	JRST	SCHNX3		;  HDCRSH zero, get very upset and stop.
	MOVEI	E,(J)		; otherwise, just get slightly upset & cont.
	MOVEI	C,[ASCIZ "!!! %N  %E
"]
	PCALL	STYO
	ADDI	J,11
	PCALL	RSTALL		; don't leave any funny states to trip us!
	HRRM	K,-1(P)
	PRET

SCHNX1:	;stat report..
	TLO	BF,2000		;flag stat.rpt in lites,
	MOVEI	E,(J)		; say a few words,
	MOVEI	C,[ASCIZ ";;; %N  %E
"]
	PCALL	STYO		;   like BF and loc0 of info block
	ADDI	J,11		; file the rpt,
	JRST	SCHN-2		; and retry the transfer.

SCHNX2:	;correctable data check..
	ADD	BF,[ 100,,0 ]	;declare which retry this will be
	TLNE	BF,1000		;  and if it's going to be #8
	JRST	SCHNX3		;  get very upset and stop,
	MOVEI	E,(J)		; otherwise, say a few words,
	MOVEI	C,[ASCIZ "!!! %N  %E
"]
	PCALL	STYO		;   like BF and loc0 of info block
	ADDI	J,11		; file error rpt,
	JRST	SCHN-2		; and try again.

SCHNX3:	;permanent (sticky) error
	TLO	BF,1000		;permanent problem,
	MOVEM	CACS+0		; save all the ACs,
	MOVE	[ 1,,CACS+1 ]
	BLT	CACS+17
	MOVEI	C,[ASCIZ "!!! %N
"]
	PCALL	STYO		; say quite a few words,
	LDB	E,[ 241600,,STATW1 ]
	MOVEI	D,STAMSG
	PCALL	PBITS
	MOVE	SENSED+0
	AOJE	.+5
	PCALL	CR
	LDB	E,[ 202400,,SENSED+0 ]
	MOVEI	D,SNSMSG
	PCALL	PBITS
	PCALL	PSB
	PCALL	CPYER1		; and go to papa.
	JRST	SCHN-2		;-- if he agrees, go retry the transfer.

SCHNFX:	;fix all necessary items before returning..
	TLZ	BF,7777
	PRET


PSB:
	PCALL	CR
	MOVE	F,SENSED
	AOJE	F,[HRROI C,[ASCIZ \MISSING
\]
	 	JRST	STYO]
	MOVE F,[440400,,SENSED]
	MOVEI D,6
PS0:	MOVEI E,^D8
PS1:	ILDB B,F
	CAILE B,^D9
	ADDI B,"A"-"0"-^D10
	ADDI B,"0"
	PUSHJ P,TYO
	MOVEI B,40
	TLNE F,40000
	PUSHJ P,TYO
	SOJG E,PS1
	PUSHJ P,TYO
	IBP F
	TRNE D,1
	PUSHJ P,CR
	SOJG D,PS0
	POPJ P,

PS:	PUSHJ P,PSB
	JRST DDT

MM0:	MOVEI A,MCP0
	MOVE B,[-2,,MM0S]
	PUSHJ P,MXCT
MM1:	MOVEI A,MCP1
	MOVE B,[-4,,MM1S]
	PUSHJ P,MXCT
	MOVEI C,[ASCIZ /OK /]
	PUSHJ P,STYO
	JRST DDT

MCP0:	BYTE (8)240,23,IDEV	;RECALIBRATE, DO NOT WAIT FOR DEV END
	BYTE (8)260,23,IDEV+1	;RECALIBRATE, CHAIN TO WAIT FOR DEV END
	BYTE (8)240,3,IDEV+1	;NOP TO BREAK CHAINING
MCP0E:	0

MM0S:	BYTE (8)0,14,IDEV+1	;CHEND, DEVEND
	MCP0E+1		;HALT HAS BEEN EXECUTED
	BYTE (8)200,4,IDEV	;ASYNC DEV END ON IDEV
	0	;NOT SIGNIFICANT ON ASYNC STATUS

MCP1:	BYTE (8)66,2,IDEV	;RD IPL, PCI,IGN LEN ERR
	IOW (RECL-1,0)		;COUNT SHORT, SKIP
MCP1A:	BYTE (8)66,2,IDEV
	IOW (RECL,0)		;COUNT OK, SKIP
MCP1B:	BYTE (8)66,2,IDEV
	IOW (RECL+1,0)		;COUNT LONG
MCP1C:	BYTE (8)60,2,IDEV	;NO PCI, HLT ON LEN ERR
	IOW (RECL+1,0)		;COUNT LONG
MCP1D:	0	;SHOULD NEVER GET HERE

MM1S:	BYTE (8)3,14,IDEV	;PCI, LENERR, CHEND, DEVEND
	MCP1A	;CNT USED UP
	BYTE (8)1,14,IDEV	;NO LENERR
	MCP1B	;CNT USED UP
	BYTE (8)3,14,IDEV	;LENERR
	IOW (1,MCP1C)	;RESIDUAL CNT=1
	BYTE (8)2,14,IDEV	;LENERR, NO PCI
	IOW (1,MCP1D)	;RESIDUAL CNT, NO HALT

MXCT:	HRLI A,200000
	MOVEM A,@CBASE
	CONO SA0,@STBSYC
MXCT0:	MOVSI C,10
MXCT1:	CONSZ SA0,170
	JRST MXCT2
	SOJG C,MXCT1
	JRST ERR41		;STATUS NEVER SHOWED UP
MXCT2:	MOVE A,@CBASE+1
	CAME A,(B)
	JRST ERR44		;STATUS WORD 1 WRONG
	ADDI B,1
	JUMPL A,MXCT3	;STATUS WORD 2 NOT SIG ON ASYNC OR DUMMY
	MOVE A,@CBASE+2
	CAME A,(B)
	JRST ERR43		;STATUS WORD 2 WRONG
MXCT3:	CONO SA0,@CLSTFC
	AOBJN B,MXCT0
	POPJ P,	;ALL STATUS COMPARED

PDEV==16	;PRINTER DEVICE CODE
PBUFLB==^D132	;NUMBER CHARS PER LINE
PBUFL==PBUFLB/4	;WORDS OF PRINT BUFFER
UCBLB==^D240	;NUMBER OF LOGICAL CHARS ON CHAIN
UCBL==UCBLB/4	;WORDS FOR UCB BUFFER

DEFINE UCS2 (A,B,C,D)
<BYTE (8)"A","B","C","D">

DEFINE UCS1 (AA,BB,CC)
<UCS2 1,2,3,4
UCS2 5,6,7,8
UCS2 9,0,X,Y
UCS2 /,S,T,U
BYTE (8)"V","W",AA,BB
BYTE (8)CC,"*",",","="
UCS2 J,K,L,M
UCS2 N,O,P,Q
UCS2 R,-,Z,(
UCS2 A,B,C,D
UCS2 E,F,G,H
UCS2 I,+,.,)
>

	SALL
UCB:	UCS1 137,42,"$"
	UCS1 74,73,"#"
	UCS1 "?",76,40
	UCS1 "]","'","&"
	UCS1 "[",":","%"
UCBE:	UCS1 137,42,"$"


PAT0:	UCS2 A,B,C,D
	UCS2 E,F,G,H
	UCS2 I,J,K,L
	UCS2 M,N,O,P
	UCS2 Q,R,S,T
	UCS2 U,V,W,X
	UCS2 Y,Z,0,1
	UCS2 2,3,4,5
	UCS2 6,7,8,9
	BYTE (8)"/","*",",","="
	BYTE (8)"-","(","+","."
	BYTE (8)")",137,42,"$"
	BYTE (8)74,73,"#","?"
	BYTE (8)76,40,"]","'"
	BYTE (8)"&","[",":","%"

	XALL

PBUF:	BLOCK PBUFL
PBUFE:

RIP0:	AOS C,PPOS
	MOVE B,[441000,,PBUF]
	DATAI 0,A
	ANDI A,177
	CAIL A,3
	JRST RIP2
	SOJG A,RIP3
	MOVEI D,^D45
	SKIPL A
	MOVEI D,^D60
RIP1:	AOS E,C
	IDIV E,D
	ROT F,-2
	MOVE E,PAT0(F)
	LSH F,-^D31
	LSH E,-^D28(F)
	IDPB E,B
	CAME B,[041000,,PBUFE-1]
	JRST RIP1
	POPJ P,

RIP2:	IDPB A,B
	CAME B,[041000,,PBUFE-1]
	JRST RIP2
	POPJ P,

RIP3:	IMULI C,43
RIP3A:	MOVEI G,3
RIP4:	AOS E,C
	IDIVI E,^D288
	ROT F,-2
	MOVE E,UCB(F)
	LSH F,-^D31
	LSH E,-^D28(F)
	IDPB E,B
	SOJG G,RIP4
	CAME B,[041000,,PBUFE-1]
	SOJA C,RIP3A
	POPJ P,

PTST:	MOVEI P,PDL-1
	PUSHJ P,RSTALL
	MOVE CN,PCHAN
	PUSHJ P,CSET
	MOVEI A,PRTI
	PUSHJ P,PTSTG
PTST1:	PUSHJ P,RIP0
	MOVEI A,PRGO
	PUSHJ P,PTSTG
	JRST PTST1

PTSTG:	HRLI A,200000
	MOVEM A,@CBASE
	CONO SA0,@STBSYC
	CONSO SA0,170
	JRST .-1
	MOVE A,@CBASE+1
	TLNE A,163310
	JRST DDT
	CONO SA0,@CLSTFC
	POPJ P,

PRTI:	BYTE (8)260,353,PDEV
	BYTE (8)260,163,PDEV
	BYTE (8)70,373,PDEV
	IOW (360,UCB)
	BYTE (8)240,3,PDEV
PRTIE:	0
PRGO:	BYTE (8)70,11,PDEV
	IOW (PBUFLB,PBUF)
	BYTE (8)240,3,PDEV
PRGOE:	0
PPOS:	0

QTT:	SETOM TAPF		;FOR ERROR ROUTINE
	SETZM RECDNO		;CLEAR COUNTERS
	SETZM REWNO		; OF RECORDS, REWINDS, WRITE ERRS
	SETZM WERRNO		; ..
QTT0:	CONO SA0,RSTSA	;RESET, START CLOCK
	MOVEI P,PDL-1	;STACK
	MOVE CN,TCHAN
	PUSHJ P,CSET
	SETZB I,K	;START AT REC 0
	MOVE A,TDEV	;SET DEVICE NUMBER OF TAPE ON IBM BUS
	DPB A,[DEVFLD,,TREW]
	DPB A,[DEVFLD,,TERG]
	DPB A,[DEVFLD,,TCP0]	;SET CHANNEL PGM FOR PROPER DEV
	DPB A,[DEVFLD,,TCP0W]
	DPB A,[DEVFLD,,TCP1]
	DPB A,[DEVFLD,,TCP2]
	MOVN A,KTRECL		;MINUS LENGTH OF RECORD
	ADDI A,7
	ASH A,CNTSFT
	HRLM A,TCP0B		;SET CHANNEL PROGRAM LENGTHS
	MOVN A,KTRECL
	ADDI A,13
	ASH A,CNTSFT
	HRLM A,TCP2B		; ..
	SETZM F7TK	;ASSUME NINE TRACK DRIVE
	PUSHJ P,TSENSE	;GET THE DRIVE SENSE DATA
	CONO SA0,@CLSTFC	;CLEAR THE INTERRUPT FLAG
	MOVE A,SENSED+0	;7 TRACK BIT
	TLNE A,100	; ..
	SETOM F7TK	;IT IS A 7 TRACK DRIVE
	MOVEI A,303	;MODE SET FOR 1600 PE 9 TK
	SKIPGE F7TK	;UNLESS 7 TRACK,
	MOVEI A,223	;MAKE IT 800 BPI, ODD, NO XLATORS
	DPB A,[241000,,TCP0]
	PUSHJ P,TGB	;FILL FIRST BUFFER (REC 0)
	PUSHJ P,TGO	;START FIRST OPER
QTT1:	MOVEI I,1(K)	;GENERATE DATA FOR REC N+1
	PUSHJ P,TGB
	PUSHJ P,TWT	;WAIT FOR COMPLETION ON REC N
	ADDI K,1	;NOW ON NEXT REC
	PUSHJ P,TGO	;START IT
	MOVEI I,-1(K)	;SET TO CHECK DATA ON N-1
	PUSHJ P,TCB	;CHECK IT
	JRST QTT1	;KEEP GOING

TGB:	TDZA J,J	;J=0 FOR GENERATE
TCB:	MOVEI J,1	;J=1 FOR CHECK
	MOVN G,KTRECL		;LENGTH OF RECORD
	MOVSI G,(G)		;AOBJN COUNTER
	HRR G,ADRLO	;SETUP FOR BUF 0
	TRNN I,1	;SKIP IF ODD REC
	JRST .+3	;EVEN. DON'T OFFSET
	ADD G,KTRECL	;STEP UP TWO BUFFERS
	ADD G,KTRECL	; ..
	MOVE D,I	;USE REC # FOR SEED WORD
	MOVE C,KTRECL	;POINTER TO SECOND BUFFER OF PAIR (READ)
	HRLI C,G	;INDEX BY AOBJN COUNT
	IMUL D,[175*175*175*175]
TGB1:	XCT TGB3(J)	;STORE OR CHECK DATA (MOVEM OR CAMN)
	JRST TGB2	;OK
	MOVE E,@C	;ERROR, GET BAD WORD
	HLRO F,G	;- REMAINING COUNT
	ADD F,KTRECL	;GET INDEX TO READ WORD
	MOVEI C,[ASCIZ /DATA ERR, REC=%I, WD=%F, WROTE=%D, GOT=%E
/]
	PUSHJ P,STYO
	JRST QTT0	;START TEST OVER
;I.E., TOTAL ABORT ON ANY DATA FAILURE

TGB2:	TLNN D,200000
	TLC D,400000	;FEEDBACK SHIFT REGISTER TYPE RANDOMIZER
	ROT D,1
	AOBJN G,TGB1	;LOOP FOR EACH WORD OF REC
	POPJ P,

TGB3:	MOVEM D,(G)		;XCT'ED FOR DATA GENERATE
	CAMN D,@C		;XCT'ED FOR DATA CHECK

TGO:	AOS RECDNO		;STARTING ANOTHER RECORD
	MOVE A,[MOVE TCP0]	;I.E., TCH TCP0. SKIP REWIND
	MOVEM A,@CBASE	;SET UP PTR TO CHAN PGM, BASE FOR THIS CHAN
	LDB A,[200,,K]		;DECIDE PACKING MODE FROM RECD NO.
	MOVE A,TGOT(A)		;TOP BYTE FOR READ COMMAND
	DPB A,[341000,,TCP2]	;PUT IN READ COMMAND
	ADDI A,22		;ADD CHAIN AND SLI BITS
	DPB A,[341000,,TCP0W]	;PUT IN WRITE COMMAND, MATCHING FORMAT.
	MOVE A,ADRLO
	TRNN K,1		;WHICH BUFFER? (ODD/EVEN REC)
	JRST .+3		;EVEN. FIRST PAIR
	ADD A,KTRECL		;ODD. SECOND PAIR. SKIP 2
	ADD A,KTRECL		; ..
	HRRM A,TCP0A	;PUT IN CHAN PGM
	ADDI A,7
	HRRM A,TCP0B	; SECOND OF TWO WRITE  POINTERS
	SUBI A,7
	ADD A,KTRECL		;AND SECOND OF PAIR IS FOR READING
	HRRM A,TCP2A	;SETUP READ ADDR
	ADDI A,13
	HRRM A,TCP2B	; SECOND READ POINTER
	CONO SA0,@STBSYC	; SPIN!
	POPJ P,

TGOT:	EXP 40,140,150,140	;WORD, NAT, TCOMPAT, NAT.

; NON-PI WAIT LOOP

TWT:	CONSZ SA0,PARERR+NXM
	JRST TWME	;MEM ERR, BAD NEWS
	CONSO SA0,170
	JRST TWT	;WAIT FOR SOME ACTION
	LDB A,[DEVFLD,,@CBASE+1]	; GET DEVICE CAUSING INTERRUPT
	CAME A,TDEV		;IS IT THE TAPE?
	JRST TWE	;UNEXPECTED DEVICE CAUSED TROUBLE
	MOVE A,@CBASE+1	;GET STATUS
TWT1:	TLNE A,163010
	JRST TWE	;BAD BITS ON
	TLNE A,4
	JRST TWUX	;UNIT EXCEPTION, PROBABLY EOT
	TLNE A,100
	JRST TWBSY	;CONTROL BUSY OR STATUS PENDING
	TLNE A,200
	JRST TWRST	;CU END, RESTART
	TLNN A,20
	JRST TWE	;NO DEVICE END IN STATUS
	TLNN A,40
	JRST TWRST	;DEVICE END ALONE
	HRRZ A,@CBASE+2	;LOOKS OK. CHECK THAT WHOLE PGM WAS DONE
	CAIE A,TCPE+1
	JRST TWE	;WASN'T
;HERE IF ALL IS WELL
TWTX:	CONO SA0,@CLSTFC	; CLEAR STATUS FLAG
	POPJ P,

TDEV:	TUNIT		;THIS GOES INTO CHAN CMDS BELOW
KTRECL:	TRECL		;LENGTH OF RECORDS IN TAPE TEST
TREW:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, REWIND OR BACKSPACE
TERG:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, NOP OR ERG
TCP0:	BYTE (8)260	;NO MEM XFER, GO, CHAIN, SET MODE
TCP0W:	BYTE (8)162,1	;GO, CHAIN, SLI, WRITE
TCP0A:	IOWC (7,0)	;BFR ADDR PLUGGED IN RH THIS WD
TCP0B:	IOW (TRECL-7,0)
TCP1:	BYTE (8)260,47	;NO MEM XFER, GO, CHAIN, BACKSPACE BLOCK
TCP2:	BYTE (8)140,2	;GO, READ
TCP2A:	IOWC (13,0)
TCP2B:	IOW (TRECL-13,0)
TCPE:	0		;HALT

TWRST:	CONO SA0,@CLSTFC
	CONO SA0,@STBSYC	; TRY OPERATION AGAIN
	JRST TWT	;AND WAIT FOR RESULTS

TWBSY:	TLNE A,260
	JRST TWRST	;JUST PENDING STATUS, TRY AGAIN
	CONO SA0,@CLSTFC
	JRST TWT	;REALLY BUSY, WAIT FOR COMPLETION

TWUX:	HRRZ A,@CBASE+2
	CAIE A,TCP1		; PC POINTING AFTER THE WRITE?
	JRST TWE	;BOMBED IN WRONG PLACE, ERROR
	AOS D,REWNO	;COUNT REWINDS
	MOVE E,RECDNO	;TYPE SUMMARY FOR PASS
	MOVEI C,[ASCIZ /END OF TAPE, PASS $D, $E RECORDS.
/]
	PUSHJ P,STYO
	MOVEI A,7	;REWIND CMD
	MOVEI B,3	;NOP CMD
TWUX1:	DPB A,[241000,,TREW]	;BACK HERE ON WRITE ERR TOO
	DPB B,[241000,,TERG]
	MOVEI A,TREW
	HRRM A,@CBASE	;SET TO REWIND OR ERASE TAPE, IF
			; WRITE ERROR,  AND TRY AGAIN
	JRST TWRST

TWME:	PUSHJ P,TSPE1	;TYPE MESSAGE
	JRST QTT0

TWE:	MOVE A,@CBASE+1
	TLNN A,10
	JRST TWEX	;OTHER THAN UNIT CHECK, GIVE UP
	HRRZ A,@CBASE+2	;WHAT WAS CHANNEL PC AT FAILURE?
	CAIE A,TCP1	;WRITE ERROR?
	JRST TWEX	;FAILURE NOT ON WRITE CMD, GIVE UP
	PUSH P,@CBASE+1	;YES. TRY TO RECOVER
	PUSH P,@CBASE+2
	PUSHJ P,TSENSE	;GET SENSE BYTES FROM TAPE UNIT
	LDB A,[242000,,@CBASE+1]
	CAIE A,14
	JRST TWEX1	;NOT CHEND+DEVEND, GIVE UP
	LDB A,[341000,,SENSED]	;FIRST BYTE OF SENSE DATA
	CAIE A,10
	JRST TWEX1	;NOT JUST A DATA CHK
	POP P,@CBASE+2	;DATA ERROR ON WRITE. TRY TO
			; ERASE GAP, RE-WRITE.
	POP P,@CBASE+1	;MOSTLY JUST TO RESTORE PDL
	MOVE E,RECDNO	;REPORT THE WRITE ERROR.
	AOS D,WERRNO
	MOVEI C,[ASCIZ /WRITE ERROR # $D, RECORD $E.
/]
	PUSHJ P,STYO
	MOVEI A,47	;BACKSPACE
	MOVEI B,27	;ERASE GAP
	JRST TWUX1	;GO TRY TO RECOVER

TSENSE:	MOVEI A,PSENSE	;GET SENSE BITS TO EXAMINE ERROR
			; (NEW CHANNEL PROGRAM)
	HRRM A,@CBASE	;SETUP TO DO SENSE
	MOVE A,TDEV
	DPB A,[DEVFLD,,PSENSE]	;ON RIGHT DEV
	CONO SA0,@STBSYC
	CONO SA0,@CLSTFC	;DO IT
	CONSO SA0,170
	JRST .-1	;WAIT FOR SENSE DATA
	POPJ P,0

TWEX1:	POP P,@CBASE+2	;RESET STATUS FOR MESSAGE
	POP P,@CBASE+1
TWEX:	SETOM TAPF	;TELL ERR ROUTINE ITS TAPE
	PUSHJ P,TSPE1	;TYPE MESSAGE
	JRST QTT0	;RESTART WHOLE TAPE ROUTINE AT RECORD 0

TAPF:	0
TAPSNS:	[ASCIZ /NOT CAP/]
	[ASCIZ /FILE PROT/]
	[ASCIZ /WRT STAT/]
	[ASCIZ /LD POINT/]
	[ASCIZ /7 TRK/]
	[ASCIZ /TU ST B/]
	[ASCIZ /TU ST A/]
	[ASCIZ /NOISE/]
	[ASCIZ /DATA CONV CHK/]
	[ASCIZ /WC ZERO/]
	[ASCIZ /OVERRUN/]
	[ASCIZ /DATA CHK/]
	[ASCIZ /EQUIP CHK/]
	[ASCIZ /BUS OUT CHK/]
	[ASCIZ /INTERVENTION REQ/]
	[ASCIZ /COMMAND REJECT/]

RECDNO:	BLOCK 1
REWNO:	BLOCK 1
WERRNO:	BLOCK 1
F7TK:	BLOCK 1

QQ=PUSHJ P,MCINTR

MCINTR:	MOVEI B,NITX+1
	CONO SA0,RDCONI
	DATAI SA0,A	;IS CLOCK RUNNING
	TLNE A,2
	CONO SA0,SASTEP	;STOP IT IF SO
	MOVEI G,0
	PUSHJ P,STEPCX	;STEP TO APPROPRIATE CHANNEL
	MOVE A,IAR	;SEE WHERE WE WERE
MCIL:	PUSHJ P,CXXCT	;1ST TIME SETUP IAR, OTHER TIMES XCT INST
	ANDI A,1777	;GET THE RESULTING IAR
	CAMN A,BPLOC	;BREAKPOINT HERE
	JRST DDT	;GO TO DDT
	SOJLE B,MCIL1	;GO BACK TO MAIN PROGRAM
	MOVE A,MCBEG0(A)	;GET MICRO INST. TO BE EXECUTED
	JRST MCIL

MCIL1:	MOVEM A,IAR	;REMEMBER WHERE WE WERE
	DATAO SA0,[0]	;IN CASE CLOCK GETS STARTED
	POPJ P,

; NOTE: FOLLOWING ROUTINE ASSUMES DISK IS ON CHAN 0

MPROG:	MOVE A,[MOVE PSEEK]
	MOVEM A,BASE
MP:	CLEARM IAR
	CONO SA0,RSTSA
	MOVEI P,PDL-1
	CONO SA0,SACGO
	CONO SA0,STBSY
MP1:	QQ
	CONSZ SA0,BSY0
	JRST MP1
	CONO SA0,SACGO
	CONO SA0,STBSY
	MOVSI D,-LSTBUF
MP2B:	MOVEI E,NTICKS
MP2:	QQ
	CONSO SA0,STF0
	JRST MP2A
	MOVE A,BASE+1
	MOVEM A,STBUF(D)
	MOVE A,BASE+2
	MOVEM A,STBUF2(D)
	CONO SA0,SACGO
	CONO SA0,CLSTF
	AOBJN D,MP2B
	JRST DDT	;TOO MUCH STATUS!!

MP2A:	SOJLE E,DDT	;IT'S BEEN A WHILE SINCE STATUS REC'D
	JRST MP2	;WAIT A LITTLE LONGER


NITX==1
NTICKS==^D5000
LSTBUF==20
PSEEK:	120034000000+<IDEV_14>	;SEEK, BYTE MODE
	IOW 6,SEEKD
	0
SEEKD:	0
	0
PSENSE:	120020000000+<IDEV_14>	;SENSE
	IOW 30,SENSED		;24 BYTES OF SENSE DATA
	0

;leave STATW1 and STATW2 immediately before SENSED!
STATW1:	0
STATW2:	0
SENSED:	BLOCK 6
STBUF:	BLOCK LSTBUF
STBUF2:	BLOCK LSTBUF
IAR:	0
BPLOC:	-1

	EXTERN .JBREL
IOLIST:	EXP 0,0

SUPER:	OPEN 1,[EXP 17,SIXBIT /SUPER/,0]
	HALT .
	MTAPE 1,1
	MTAPE 1,0
	MOVN A,.JBREL
	MOVSI A,GOGO(A)
	HRRI A,GOGO-1
	MOVEM A,IOLIST
	OUT 1,IOLIST
	SKIPA
	HALT .
	RELEAS 1,
	EXIT
SUPER0:	0
SUPER1:	0


PPP=PUSHJ P,PWORLD

PWORLD:	PUSHJ P,STEPX1
	MOVSI D,-5
PW0:	CONO SA0,@PW0T1(D)
	MOVE C,PW0T2(D)
	PUSHJ P,STYO
	DATAI SA0,A
	TRNN D,-1
	ANDI A,1777
	PUSHJ P,OPT
	AOBJN D,PW0
	CONO SA0,RDCCI
	MOVSI D,-4
PW1:	MOVE C,BTIMT(D)
	PUSHJ P,STYO1
	DATAO SA0,BTIMD(D)
	DATAI SA0,A
	LDB A,[121000,,A]
	PUSHJ P,OPT
	AOBJN D,PW1
	MOVSI D,-4
	MOVEI E,040000
PW2:	MOVE C,PCWT(D)
	PUSHJ P,STYO1
	MOVE C,[301000,,A]
	ADDI E,400
PW2A:	DATAO SA0,E
	DATAI SA0,B
	LSH B,-12
	IDPB B,C
	ADDI E,400
	TRNE E,1400
	JRST PW2A
	LSH A,-4
	PUSHJ P,OPT
	AOBJN D,PW2
	MOVSI D,-4
	MOVEI E,140002
PW3:	MOVE C,REGT(D)
	PUSHJ P,STYO1
	MOVE C,[441000,,A]
PW3A:	DATAO SA0,E
	DATAI SA0,F
	LSH F,-12
	IDPB F,C
	TRNE E,2000
	JRST PW3B
	ADDI E,400
	JRST PW3A

PW3B:	LSH A,-4
	LSHC A,4
	PUSHJ P,OPT
	ADDI E,6000
	AOBJN D,PW3
	MOVEI C,[ASCIZ \
TDS0=\]
	PUSHJ P,STYO
	DATAI SA0,A
	LDB A,[100400,,A]
	PUSHJ P,OPT
CR:	MOVEI C,[ASCIZ \
\]
STYO:	HRLI C,440700
STYO1:	ILDB B,C
	CAIN B,"%"
	JRST STYO2
	CAIN B,"$"
	JRST STYO3		;DECIMAL TYPEOUT
	CAIN B,"\"
	JRST STYO4		;HEX TYPEOUT
	JUMPE B,CPOPJ
	PUSHJ P,TYO
	JRST STYO1

STYO2:	ILDB B,C
	MOVE A,-100(B)
	PUSHJ P,OPT
	JRST STYO1
STYO3:	ILDB B,C
	MOVE A,-100(B)
	PUSHJ P,DPT
	JRST STYO1
STYO4:	ILDB B,C
	MOVE A,-100(B)
	PUSHJ P,HPT
	JRST STYO1

CR4:	PUSHJ P,CR2
CR2:	PUSHJ P,CR
	JRST CR

OPT:	TLNN A,-1
	JRST OPT1
	PUSH P,A
	HLRZS A
	PUSHJ P,OPT2
	POP P,A
	MOVEI B,54
	PUSHJ P,TYO
	PUSHJ P,TYO
OPT1:	HRRZS A
OPT2:	IDIVI A,10
	JUMPE A,OPT3
	HRLM B,(P)
	PUSHJ P,OPT2
	HLRZ B,(P)
OPT3:	ADDI B,60
	CAILE B,"9"
	ADDI B,"A"-"9"-1
TYO:	CONSZ TTY,20
	JRST .-1
	DATAO TTY,B
CPOPJ:	POPJ P,

DPT:	MOVEI B,"-"
	SKIPGE A
	PUSHJ P,TYO
	MOVMS A
DPT1:	IDIVI A,12
	JUMPE A,OPT3
	HRLM B,(P)
	PUSHJ P,DPT1
	HLRZ B,(P)
	JRST OPT3

HPT:	MOVEI B,0
	ROTC A,-4
	ROT B,4
	JUMPE A,OPT3
	HRLM B,(P)
	PUSHJ P,HPT
	HLRZ B,(P)
	JRST OPT3

BTIMT:	440700,,[ASCIZ \
BUS= \]
	440700,,[ASCIZ \
TAG= \]
	440700,,[ASCIZ \
INS= \]
	440700,,[ASCIZ \
MISC=\]

BTIMD:	144000
	145000
	145400
	142400

PCWT:	440700,,[ASCIZ \
WC=  \]
	440700,,[ASCIZ \
CA=  \]
	440700,,[ASCIZ \
PC=  \]
	440700,,[ASCIZ \
A3=  \]

REGT:	440700,,[ASCIZ \
R0=  \]
	440700,,[ASCIZ \
R1=  \]
	440700,,[ASCIZ \
R2=  \]
	440700,,[ASCIZ \
R3=  \]

PW0T1:	RDCCI
	RDMA
	RDMBL
	RDMBR
	RDCONI

PW0T2:	[ASCIZ /
IARB=/]
	[ASCIZ /
MA=  /]
	[ASCIZ /
MBLT=/]
	[ASCIZ /
MBRT=/]
	[ASCIZ /
CONI=/]


INT1:	0
	MOVE I,PIE
	CAIE I,1	;ARE WE EXPECTING AN INTERRUPT ON THIS CHANNEL?
	JRST ERR31	;NO
	CONO SA0,CLSTF(B)	;REMOVE THE CAUSE FOR THIS INTERRUPT
			;(MAIN PROGRAM HAS SET B UP)
	CLEARM PIE	;NOTE THAT NO FURTHER INTERRUPTS ARE EX-
			;PECTED, ALSO TELL MAIN PROGRAM THAT ONE
			;INTERRUPT DID OCCUR
	JRST 12,@INT1

INT2:	0
	MOVE I,PIE
	CAIE I,2
	JRST ERR32
	CONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT2

INT3:	0
	MOVE I,PIE
	CAIE I,3
	JRST ERR33
	CONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT3

INT4:	0
	MOVE I,PIE
	CAIE I,4
	JRST ERR34
	CONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT4

INT5:	0
	MOVE I,PIE
	CAIE I,5
	JRST ERR35
	CONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT5


INT6:	0
	MOVE I,PIE
	CAIE I,6
	JRST ERR36
	CONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT6

INT7:	0
	MOVE I,PIE
	CAIE I,7
	JRST ERR37
	CONO SA0,CLSTF(B)
	CLEARM PIE
	JRST 12,@INT7

PIE:	0	;CHANNEL ON WHICH INTERRUPT IS EXPECTED
UUOH:	JSR RRR
ERR1:	JSR RRR
ERR2:	JSR RRR
ERR3:	JSR RRR
ERR4:	JSR RRR
ERR5:	JSR RRR
ERR6:	JSR RRR
ERR7:	JSR RRR
ERR8:	JSR RRR
ERR9:	JSR RRR
ERR10:	JSR RRR
ERR11:	JSR RRR
ERR12:	JSR RRR
ERR13:	JSR RRR
ERR14:	JSR RRR
ERR15:	JSR RRR
ERR16:	JSR RRR
ERR17:	JSR RRR
ERR18:	JSR RRR
ERR19:	JSR RRR
ERR20:	JSR RRR
ERR21:	JSR RRR
ERR22:	JSR RRR
ERR23:	JSR RRR
ERR24:	JSR RRR
ERR25:	JSR RRR
ERR26:	JSR RRR
ERR27:	JSR RRR
ERR28:	JSR RRR
ERR29:	JSR RRR

ERR30:	JSR RRR
ERR31:	JSR RRR
ERR32:	JSR RRR
ERR33:	JSR RRR
ERR34:	JSR RRR
ERR35:	JSR RRR
ERR36:	JSR RRR
ERR37:	JSR RRR
ERR38:	JSR RRR
ERR39:	JSR RRR
ERR40:	JSR RRR
ERR41:	JSR RRR
ERR42:	JSR RRR
ERR43:	JSR RRR
ERR44:	JSR RRR
ERR45:	JSR RRR
ERR46:	JSR RRR
ERR47:	JSR RRR
ERR48:	JSR RRR
ERR49:	JSR RRR
ERR50:	JSR RRR
ERR51:	JSR RRR
ERR52:	JSR RRR

EXTERN DDT

RRR:	0
	SOS RRR			;SO POINTS AT RIGHT ERROR CALL
	PUSH P,A		;ADD TYPEOUT:
	PUSH P,B
	PUSH P,C
	PUSH P,D
	HRRZ D,RRR
	SUBI D,ERR1-1
	MOVEI C,[ASCIZ /
ERROR NUMBER $D

/]
	PUSHJ P,STYO
	POP P,D
	POP P,C
	POP P,B
	POP P,A
RRRB:	JRST DDT		;BREAKPOINT HERE FOR DEBUG

TEST:	0
	-1
	252525,,252525
	525252,,525252	;PSEUDO-RANDOM TEST DATA
TEST1:	BLOCK 4	;PLACE TO READ STUFF BACK INTO

CWTD:
IFE CV,<325125,,340125>
IFN CV,<325137,,340125>
	125120,,252252
	240000,,

STCLM:	014000	;SET BUSY FLAG
	015000	;SET STATUS FLAG
	015400	;SET P.I. ENABLE FLAG

STCLM1:	BSY0
	STF0
	PIE0

BITS:	REPEAT ^D36,<	EXP 1B<.-BITS>>

CCTBL:	BLOCK NCHN	;LITTLE TABLE USED AT BEGINNING OF PROG.

	BLOCK 10
CPG0:	BLOCK 400
CPG1:	BLOCK 400
CPG2:	BLOCK 400
CPG3:	BLOCK 400
CPG4:	BLOCK 400
CPG5:	BLOCK 400
CPG6:	BLOCK 400
CPG7:	BLOCK 400

PDL:	BLOCK 200	;PUSHDOWN LIST

R0==0
R1==10000
R2==20000
R3==30000
B0==0
B1==1
B2==2
B3==3
B4==4
SW1==5
BUSOUT==5
FOFI==6
FOFIS==7
BUSIN==10
STRD==10
STRDC==11
TAGB==12
STWR==12
INTST==13
STWRD==13
ZERO==14
LOAD==14
MRB==15
WHOLE==15
FIFO==16
B14==16
FIFOS==17

WC==0
CA==2000
PC==4000
A3==6000
IARB==0
INCR==0
WCFLD==1
ADRFLD==2
MAGIC==3
DECR==1
CLRINS==400
CLRTAG==0
STGO==10000
STRQ==10400
STFLG==11000
STPIE==11400
ADROUT==20000
SELOUT==20400
SRVOUT==21000
NOPOUT==21400
SUPOUT==22000
CMDOUT==22400
WRBIT==23000
BUFENB==23400
INS0==30000
INS1==30400
SELERR==31000
CTBYT==31400
CTLERR==32000
SKPFLG==32400
LENERR==33000
PCIFLG==33400
BIT00==0
BIT01==1
BIT10==20
BIT11==21
BIT20==40
BIT21==41
BIT30==60
BIT31==61
BIT40==100
BIT41==101
BIT50==120
BIT51==121
BIT60==140
BIT61==141
BIT70==160
BIT71==161
Z==200
NZ==201
ERR==221
NERR==220
DEVM==240
RBAK==260
NBTM==300
IFN EADR,<SKPC==320>
IFE EADR,<SKPC==Z>
TAGBS==TAGB_10
ADRI0==TAGBS+BIT00
ADRI1==TAGBS+BIT01
SELI0==TAGBS+BIT10
SELI1==TAGBS+BIT11
BFMT0==TAGBS+BIT20
BFMT1==TAGBS+BIT21
OPLI0==TAGBS+BIT30
OPLI1==TAGBS+BIT31
RQI0==TAGBS+BIT40
RQI1==TAGBS+BIT41
STAI0==TAGBS+BIT50
STAI1==TAGBS+BIT51
BCRQ0==TAGBS+BIT60
BCRQ1==TAGBS+BIT61
BFHLT0==TAGBS+BIT71
BFHLT1==TAGBS+BIT70
INSTS==INTST_10
INS00==INSTS+BIT00
INS01==INSTS+BIT01
INS10==INSTS+BIT10
INS11==INSTS+BIT11
PCIF0==INSTS+BIT70
PCIF1==INSTS+BIT71
SW1S==SW1_10
BSY0==SW1S+BIT00
BSY1==SW1S+BIT01
STRQ0==SW1S+BIT10
STRQ1==SW1S+BIT11
STFL0==SW1S+BIT20
STFL1==SW1S+BIT21
WCOK0==SW1S+BIT40
WCOK1==SW1S+BIT41
TIMER0==SW1S+BIT50
TIMER1==SW1S+BIT51

DEFINE MPAGE
<IFN .&17,<.PRINT <BADMPG>>>

DEFINE ADRSET (NAME)
<IFIDN <NAME>,<>,<ADR=.+1>
IFDIF <NAME>,<>,<ADR=NAME>
IF2,<IFN <.&1400>-<ADR&1400>,<.PRINT <BNDER1>>>
ADR=ADR&377
>
DEFINE PULSE (BIT,NAME)
<ADRSET NAME
.,,BIT+2000+ADR
>

DEFINE ON (BIT,NAME)
<ADRSET NAME
.,,BIT+4000+ADR
>
DEFINE OFF (BIT,NAME)
<ADRSET NAME
.,,BIT+ADR
>
DEFINE ADRST1 (NAME)
<IFIDN <NAME>,<>,<ADR=.+1>
IFDIF <NAME>,<>,<ADR=NAME>
IF2,<IFN <.&1760>-<ADR&1760>,<.PRINT <BNDERR>>>
ADR=ADR&17
>
DEFINE XFER (REG,SRC,DEST,NAME)
<ADRST1 NAME
.,,140000+REG+<SRC_10>+<DEST_4>+ADR
>
DEFINE XANC (SRC1,SRC2,REG,DEST,NAME)
<ADRST1 NAME
.,,040000+REG+SRC1+<SRC2_10>+<DEST_4>+ADR
>
DEFINE GOTO (NAME)
<.,,NAME
>
DEFINE TEST (REG,SRC,FN,NAME)
<ADRST1 NAME
.,,100000+REG+<SRC_10>+<<FN!<ADR+1>>-<FN&<ADR+1>>>
>
DEFINE HANG (REG,SRC,FN)
<.,,100000+REG+<SRC_10>+FN+.&17
>
;THIS IS WHERE THE MICROCODE IS LOADED

	SALL
MCBEG0:

PHASE 0

MCBEG:!

	PULSE CLRINS,RST	;SYS
	ON ADROUT,HIO	;HALT I/O
	PULSE CLRINS,RST	;PROG SYS
	ON INS0,RST	;PROG SEL
	REPEAT 4,<ON INS0,RST>	;PANIC
	REPEAT 10,<0>
	MPAGE

RST:!	OFF STGO
	OFF STFLG
	PULSE CLRTAG
	TEST 0,0,INS01,RS1
RS1:!	ON SUPOUT
	ON NOPOUT
	HANG 0,0,TIMER0
	XFER R0,ZERO,WHOLE
	HANG 0,0,TIMER1
	OFF STRQ
	HANG 0,0,TIMER0
	TEST 0,0,INS00,RS2
RS2:!	OFF NOPOUT,IDLE
HIO1:!	XFER R0,ZERO,WHOLE
	HANG 0,0,OPLI1
	OFF NOPOUT,RS3
	MPAGE

HIO:!	OFF SELOUT,HIO1
ASC1:!	TEST R1,B1,BIT10,ASC1A
ASC1A:!	XANC PC,INCR,0,LOAD	;SKIP A CMD IF DEVEND+STAMOD ON DCC
	GOTO ASC1B
IDLE:!	PULSE CLRINS
	XFER R1,ZERO,WHOLE
IDL1:!	TEST 0,0,BSY1,IDL2
	ON SELOUT,ASY1	;DO A POLL CYCLE
IDL2:!	TEST 0,0,STRQ1,IDL3
	OFF STGO,GO0	;START COMMAND
IDL3:!	TEST 0,0,RQI1,IDL1
	GOTO STR	;DUMMY STATUS REQUEST
RS3:!	PULSE CLRTAG
	PULSE CLRINS
	ON CTLERR
	ON INS0,STR	;TERMINATE A SEL RST WITH A CTRL CHECK INT
	MPAGE


ASY1:!	TEST 0,0,OPLI1,ASY2
	OFF SELOUT,ASYU	;GOT SELECT IN ON POLL - REQ IN MUST HAVE DROPPED
ASY2:!	TEST 0,0,SELI1,ASY1
	ON INS1,ASY3	;POLL SUCCESSFUL
ASY3:!	HANG 0,0,ADRI0
	XFER R1,BUSIN,B2,ASY4	;GET ADDR
ASY5:!	HANG 0,0,ADRI1
	OFF CMDOUT
	HANG 0,0,STAI0
	XFER R1,BUSIN,B1	;GET THE STATUS
	OFF SELOUT,AST	;AND GO TEST FOR DCC
ASY4:!	ON CMDOUT,ASY5
ASYU:!	HANG 0,0,SELI1
	GOTO IDLE
ASP1:!	HANG 0,0,OPLI1
	GOTO STR
	MPAGE

AST:!	TEST R1,B1,NERR,AST1
AST3B:!	TEST R2,B0,BIT01,AST4
AST1:!	ON SRVOUT,ASP	;ERR IN STATUS, GIVE TO PROG
	TEST R1,B1,BIT51,AST2
AST2:!	ON SRVOUT,ASP	;NO DEVEND IN STATUS,GIVE TO PROG
	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,STRD
	GOTO AST3
AST3A:!	TEST R2,B1,BIT01,AST4
	TEST R2,B1,BIT30,AST6	;MATCHING DEV CODE FOUND, CHK WAIT
AST4:!	ON SRVOUT,ASP	;SEL MODE OR END OF LIST,GIVE TO PROG
	XANC A3,INCR,0,STRD
	XFER R2,MRB,WHOLE	;DEV TABLE ENTRY TO R2
AST5:!	TEST R1,0,DEVM,AST3A
AST6:!	ON SRVOUT,ASP	;START OR HALTED, GIVE TO PROG
	ON SUPOUT,ASC	;ALL TESTS PASSED, INDICATE CHAINING
	MPAGE

ASC:!	ON SRVOUT,ASC1
ASC3:!	PULSE CLRINS,FET
ASC1B:!	HANG 0,0,STAI1
	OFF SRVOUT,ASC1C
CMD12:!	GOTO XD4
	0
ASC2:!	XANC A3,DECR,0,STWRD
	XANC A3,B1,R0,B2
	XANC A3,B2,R0,B3
	XANC A3,B3,R0,B14
	XANC CA,INCR,0,LOAD
	XANC CA,INCR,0,LOAD	;BASE+3
	XANC CA,INCR,R0,STWR	;STORE PTR TO DEVLST
ASC2A:!	XANC PC,ADRFLD,R2,LOAD,ASC3
ASP:!	HANG 0,0,STAI1
	OFF SRVOUT,ASP1
	MPAGE

FET:!	XANC PC,INCR,0,STRD
FET0:!	ON INS0
	XFER R0,MRB,WHOLE	;GET CMD
	TEST R0,B0,BIT21,FET1
FET1:!	TEST R0,B0,BIT11,FET2	;SP CMD
	XFER R0,B2,BUSOUT	;DEV CMD
	ON ADROUT,INI2
FET4:!	TEST R0,B0,BIT01,FET5
FET2:!	TEST R0,B0,BIT31,FET3
	XANC PC,ADRFLD,R0,LOAD,FET	;TCH
FET3:!	ON INS1,INERR	;HALT
	XANC CA,ADRFLD,R0,LOAD,FET4	;LOAD OR STORE
FET5:!	XANC CA,INCR,0,STRD,FET6	;LOAD
	XANC CA,INCR,R2,STWR,FET	;STORE
FET6:!	XFER R2,MRB,WHOLE,FET
STR1:!	OFF STRQ,STX
MPAGE

INI6:!	HANG 0,0,SELI1
	OFF ADROUT,INI6A
MERR:!	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,STRD
	ON PCIFLG,MERR1
INI5A:!	OFF SELOUT,INI7
INI2:!	ON SELOUT
INI2A:!	XFER R1,MRB,B2,INI5	;SAVE DEVADR IN STAT FOR CU BSY ETC
INI3:!	TEST 0,0,OPLI1,INI4
	OFF SELOUT,INI6	;NOT OPER
INI4:!	TEST 0,0,STAI1,INI5
	OFF ADROUT,CMD	;NORMAL SELECTION
INI5:!	TEST 0,0,SELI1,INI3
	XFER R1,BUSIN,B1,INI5A	;CU BUSY SEQ, GET STATUS
INI7:!	HANG 0,0,STAI1
	OFF ADROUT,INERR
	MPAGE

CMD:!	OFF SUPOUT,CMD1
CMD2:!	TEST R0,B0,NBTM,CMD3
CMD1:!	HANG 0,0,ADRI0
	XFER R1,BUSIN,B2	;GET ECHOED ADDR
	XFER R0,B1,BUSOUT	;PUT OUT CMD BYTE
	ON CMDOUT,CMD2
CMD3:!	ON CTBYT
	XANC PC,B1,R2,B2
	HANG 0,0,ADRI1	;WAIT FOR CMD ACCEPTED
	OFF CMDOUT,CMD4
CMD10:!	HANG 0,0,STAI0
	TEST 0,BUSIN,Z,CMD11
CMD11:!	GOTO ED
	ON SRVOUT	;ACCEPT INITIAL STATUS OF 0 (NMT)
	HANG 0,0,STAI1
	OFF SRVOUT,CMD12
	MPAGE

CMD4:!	TEST R0,B1,NZ,CMD5
CMD8:!	GOTO DAT
CMD5:!	GOTO ESW	;CMD WAS TEST I/O
	XANC PC,B2,R2,B3
	XANC PC,B3,R2,B14
	TEST R0,B0,BIT00,CMD6
CMD6:!	XANC A3,ADRFLD,R2,LOAD,CMD9	;NMT, SETUP FOR RETRY
	XANC PC,INCR,0,STRD	;START FIRST DCW FET
	XANC A3,ADRFLD,R2,LOAD	;SETUP SAVED PC FOR RETRY
	TEST R0,B1,BIT71,CMD7
CMD7:!	OFF WRBIT,CMD8
	ON WRBIT,CMD8
CMD9:!	ON WRBIT
	ON INS1,CMD10	;MAKE BUFFER NO AVAIL TO DEVICE
INI6A:!	ON SELERR,INERR
INERR:!	OFF SUPOUT,MERR
	MPAGE

STR:!	XFER R1,INTST,B0	;STORE STATUS ROUTINE
	XANC WC,B1,R2,B0
	XANC WC,B2,R2,B1
	XANC PC,B1,R2,B2
	XANC PC,B2,R2,B3
	XANC PC,B3,R2,B14
	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,LOAD
	HANG 0,0,STFL1
	XANC CA,INCR,R1,STWR
	XANC CA,INCR,R2,STWR
	XFER R2,MRB,WHOLE	;WAIT FOR LAST STORE DONE
	ON STFLG,STR1
STX2:!	TEST R0,B0,BIT21,STX3
STX3:!	PULSE CLRINS,FET	;NORMAL PCI
	GOTO SIT	;PCI WITH CHNL END AND DCC
	MPAGE

STX8:!	TEST R2,B0,BIT10,STX9
STX:!	TEST 0,0,PCIF1,STX1
STX1:!	TEST 0,0,INS00,STX4
	OFF PCIFLG,STX2
STX4:!	TEST 0,0,INS10,STX5	;ASYNC OR DUMMY
	TEST R0,B0,BIT21,STX6	;INI OR END
STX5:!	XANC CA,MAGIC,0,LOAD,STX7	;DUMMY
	GOTO STX9	;ASYNC
STX6:!	TEST R0,B0,BIT01,STX6A	;HLT
	GOTO STX9	;NO A HLT
STX6A:!	GOTO STX9	;SLOW HALT
	GOTO SIT	;FAST HLT
STX7:!	XANC CA,INCR,0,STRD
	XFER R2,MRB,WHOLE,STX8
STX9:!	HANG 0,0,STFL1
	GOTO IDLE
	MPAGE

MERR1:!	XFER R2,MRB,WHOLE
	TEST R2,B0,BIT01,MERR2
MERR2:!	OFF PCIFLG,STR	;SEL MODE, JUST STORE
MRK:!	XANC CA,INCR,0,LOAD	;BM
	XANC CA,INCR,0,LOAD
	XANC CA,INCR,0,STRD	;GET SAVED PTR TO DEVLST
	XFER R3,MRB,WHOLE
	XANC A3,ADRFLD,R3,LOAD
	XANC A3,INCR,0,STRD	;GET DEVLST ENTRY
	XANC A3,ADRFLD,R3,LOAD	;SET A3 BACK FOR REWRITE
	XFER R2,MRB,WHOLE
	XANC PC,B1,R2,B2
	XANC PC,B2,R2,B3
	XANC CA,WCFLD,0,LOAD
	GOTO MRK1
	0
	MPAGE

MRK1:!	TEST 0,0,PCIF0,MRK2
CMD7A:!	GOTO DAT
MRK2:!	XANC CA,INCR,0,LOAD	;SET CA FOR TERM
	XANC CA,B3,R2,B1,MRK2A
MRK2B:!	XANC A3,INCR,R2,STWR	;STORE UPDATED PTR
	TEST 0,0,PCIF0,MRK3
MRK3:!	OFF PCIFLG,STR	;MARK TERM DONE
	TEST R0,B0,BIT50,MRK4	;MARK HUNG DONE
MRK4:!	ON PCIFLG,STR	;PIC W/DCC CHNL END
SIT:!	TEST R3,B1,BIT01,SIT1	;TEST FOR ASYNC OR GOFLG STRT
SIT1:!	GOTO IDLE	;ASYNC START
	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,LOAD	;SET CA FOR ASC
	GOTO GO2
MRK2A:!	XANC PC,B3,R2,B14,MRK2B
	0
	MPAGE

GO0:!	XANC CA,MAGIC,0,LOAD
	XANC CA,INCR,0,STRD
	XFER R2,MRB,WHOLE
	TEST R2,B0,BIT01,GO1
GO1:!	GOTO ASC2A	;SEL MODE
	XANC A3,ADRFLD,R2,LOAD,GO2	;BM
GO3:!	GOTO IDLE	;END OF LIST
	TEST R2,B1,BIT21,GO4
GO4:!	XFER R0,MRB,WHOLE,GO4A	;START FOUND,MAKE R0 NEG
GO2:!	XANC A3,INCR,0,STRD	;KEEP LOOKING
	XFER R2,MRB,WHOLE
	TEST R2,B1,BIT01,GO3
GO5:!	GOTO ASC2	;CA:!BASE+1, A3:!DEVLSTPT+1, R2:!CMD ADR
GO4A:!	XFER R1,MRB,B0	;PUT DEVADR INTO STATUS WORD
	XFER R1,B0,B2	;GET IT IN THE CORRECT BYTE
	XFER R1,ZERO,B1,GO5	;AND CLEAR BYTE 1
	MPAGE

DUN:!	TEST 0,0,PCIF1,DUN1
DUN3:!	ON PCIFLG,STR	;DO PCI
DUN1:!	TEST R0,B0,BIT51,DUN2	;NOT DCC
	OFF PCIFLG,DUN4	;DCC
DUN2:!	PULSE CLRINS,FET	;NOT PCI
	XFER R0,ZERO,WHOLE,DUN3	;PCI, CAUSE RET TO FETCH
DUN4:!	OFF SUPOUT,MRK	;MARKS HUNG
AST3:!	XFER R2,MRB,WHOLE	;BLK MUX FLAG TO R2
	XANC A3,ADRFLD,R2,LOAD
	GOTO AST3B
	0
	0
ASC1C:!	HANG 0,0,OPLI1
	XFER R0,ZERO,WHOLE
	GOTO GO4A
	0
	MPAGE

ED:!	TEST 0,0,OPLI1,ED1
IMM:!	TEST 0,INTST,BIT31,ES1
ES1:!	TEST 0,INTST,BIT61,ES1A	;NO PARERR
	GOTO ES7	;BUS IN PAR ERR
ES1A:!	GOTO ES2	;NO LEN ERR
	TEST R0,B0,BIT61,ES1B	;TEST SLI
ES1B:!	GOTO ES3B	;HALT ON LEN ERR
	GOTO ES2	;IGNORE LEN ERR
ED1:!	ON CTLERR,ED1A	;END STATUS MISSING
	XFER R1,BUSIN,B1,IMM
ESWI:!	HANG 0,0,STAI1
	OFF SRVOUT
ESW:!	TEST 0,0,OPLI1,ESW1
ES0:!	XFER R1,BUSIN,B1,IMM	;MORE STATUS
ESW1:!	GOTO DUN	;NORMAL DISCONNECT
	TEST 0,0,STAI1,ESW
	MPAGE

ES2:!	TEST 0,BUSIN,ERR,ES3
ES8A:!	XANC PC,ADRFLD,R2,LOAD,ES8B	;CHAIN BACK TO PREV CMD
ES3:!	TEST R0,B0,BIT31,ES4	;NO BAD BITS
ES3B:!	TEST 0,BUSIN,BIT61,ES7	;BAD BITS
ES4:!	OFF SELOUT,ES5	;NO CHAINING
ES4A:!	ON SUPOUT,ES6	;CHAINING
ES7:!	OFF SUPOUT,CMDE	;NO UNIT CHECK
	TEST 0,BUSIN,BIT11,ES8	;UN CHECK
ES8:!	OFF SUPOUT,CMDE	;NO STA MOD
	XANC A3,B1,R2,B2	;RETRY STATUS
	XANC A3,B2,R2,B3
	XANC A3,B3,R2,B14,ES8A
ES8B:!	OFF LENERR
	XANC PC,DECR,0,STWRD,ES4A
CMDE:!	OFF SELOUT
	ON SRVOUT,CMDE1
	MPAGE

ES6:!	TEST 0,BUSIN,BIT51,ES6A
ES9A:!	TEST R2,B0,BIT01,ES5
ES6A:!	XANC CA,MAGIC,0,LOAD,ES9	;NO DEV END
	TEST 0,BUSIN,BIT11,ES6B	;DEV END
ES6B:!	OFF SELOUT,ESF	;DEVEND W/O STAMOD
	TEST 0,BUSIN,BIT61,ES6C	;STA MOD
ES6C:!	XANC PC,INCR,0,LOAD	;DEVEND, STAMOD, NOT UNCHK
	OFF SELOUT,ESF	;UNCHK OVERRIDES SKIP
ES9:!	XANC CA,INCR,0,STRD
	XFER R2,MRB,WHOLE,ES9A
ES5:!	ON SRVOUT,ESWI
	ON PCIFLG,ES4
XD2D:!	HANG 0,0,BFHLT0
	ON LENERR,XD2C
	0
	0
	MPAGE

DSRO:!	TEST R3,B2,SKPC,DSRO1
XD3:!	TEST R0,B1,BIT71,XD3A
DSRO1:!	TEST R0,B1,RBAK,DSRO3	;NOT SKIP
	TEST R3,B3,Z,DSRO2	;POSS SKIP
DSRO2:!	TEST R0,B1,RBAK,DSRO3	;NOT SKIP
	GOTO SK6	;SKIP
DSRO3:!	GOTO RD6	;RD FWD
	TEST R0,B0,BIT41,DSRO4	;RD BAK
DSRO4:!	GOTO RB6	;RD BAK WD
	GOTO RBB	;RD BAK BYTE
XD3A:!	GOTO XD2	;DON'T DO ANYTHING SPECIAL IF READ
	XANC WC,WCFLD,0,LOAD,XD3B	;FORCE WCOK
XD4:!	XFER R3,ZERO,WHOLE,XD3D	;SET TO CLE@R WC
XD3B:!	XFER R3,ZERO,WHOLE,XD3C	;CLEAR TSD0
XD3D:!	XANC WC,ADRFLD,R3,LOAD,XD3A	;FORCE WC ZERO
XD3C:!	XFER R2,B4,FOFI,XD3D	;WRITE LAST BYTE (HALF FULL)
	MPAGE

DAT2:!	HANG 0,0,STAI0
	TEST 0,BUSIN,Z,DAT3	;TEST INITIAL STATUS
DAT3:!	OFF INS1,XD1D	;NOT ZERO, NO XFER
	TEST R0,B1,BIT71,DAT4	;TEST WRITE
DAT4:!	ON SRVOUT,DAT5	;ACCEPT ZERO STATUS ON READ
	XANC CA,INCR,0,STRD	;FETCH FIRST WORD TO WRITE
	TEST R0,B0,BIT11,DAT6	;TEST TAPE COMPAT MODE
	0
DAT6:!	GOTO DSW0	;NOT TAPE COMPAT
	XFER R2,ZERO,WHOLE	;FOR ZERO BITS IN 9 TRACK MODE
	OFF CTBYT	;MAY HAVE BEEN SET IF 9 TRACK
	GOTO DXW
DAT5:!	HANG 0,0,STAI1
	TEST R0,B0,BIT11,DAT5A
DAT5A:!	OFF SRVOUT,DSR
	GOTO DXR	;TAPE COMPAT READ
	MPAGE

DSR:!	TEST R3,B2,SKPC,DSR1
DSR6A:!	GOTO SK6
DSR1:!	TEST R0,B1,RBAK,DSR3	;NOT SKIP
	TEST R3,B3,Z,DSR2	;POSS SKIP
DSR2:!	TEST R0,B1,RBAK,DSR3	;NOT SKIP
	TEST R0,B1,RBAK,DSR4	;SKIP
DSR3:!	GOTO RD0	;RD FWD
	TEST R0,B0,BIT71,DSR5	;RD BAK
DSR4:!	GOTO SK0	;SKP FWD
	TEST R0,B0,BIT71,DSR6	;SKP BAK
DSR5:!	TEST R0,B0,BIT41,DSR7	;RD BAK EVEN
	GOTO RB11	;RD BAK ODD
DSR6:!	GOTO SK0	;SKP BAK EVEN
	XFER R2,FIFO,B4,DSR6A	;SKP BAK ODD
DSR7:!	GOTO RB0	;RD BAK WD
	GOTO RBB	;RD BAK BYTE
	MPAGE

RD1:!	XFER R2,FIFO,B1,RD2
RDX:!	GOTO DEE
RD2:!	XFER R2,FIFO,B2,RD3
RD5:!	XANC CA,INCR,R2,STWR,RD6
	0
RD3:!	XFER R2,FIFO,B3,RD4
RD4:!	XFER R2,FIFO,B4,RD5
RD10:!	XANC CA,INCR,R3,STWR,RD0
RD7:!	XFER R3,FIFO,B1,RD8
RDX2:!	GOTO DEO
RD8:!	XFER R3,FIFO,B2,RD9
RD0:!	XFER R2,FIFO,B0,RD1
	0
	0
RD9:!	XFER R3,FIFO,B3,RD10
RD6:!	XFER R3,FIFO,B0,RD7
	MPAGE

RB1:!	XFER R3,FIFO,B2,RB2
RBX:!	GOTO DEE
RB2:!	XFER R3,FIFO,B1,RB3
RB5:!	XANC CA,DECR,R3,STWR,RB6
	0
RB3:!	XFER R3,FIFO,B0,RB4
RB4:!	XFER R2,FIFO,B4,RB5
RB10:!	XANC CA,DECR,R2,STWR,RB0
RB7:!	XFER R2,FIFO,B2,RB8
RBX2:!	GOTO DEO
RB8:!	XFER R2,FIFO,B1,RB9
RB0:!	XFER R3,FIFO,B3,RB1
ED1A:!	GOTO MERR
RB9:!	XFER R2,FIFO,B0,RB10
RB6:!	XFER R2,FIFO,B3,RB7
RB11:!	XFER R2,FIFO,B4,RB6
MPAGE

SK1:!	XFER R2,FIFO,B1,SK2
SKX:!	GOTO DEE
SK2:!	XFER R2,FIFO,B2,SK3
SK6:!	XFER R3,FIFO,B0,SK7
	0
SK3:!	XFER R2,FIFO,B3,SK4
SK4:!	XFER R2,FIFO,B4,SK6
SK0:!	XFER R2,FIFO,B0,SK1
SK7:!	XFER R3,FIFO,B1,SK8
SKX2:!	GOTO DEO
SK8:!	XFER R3,FIFO,B2,SK9
	0
	0
SK9:!	XFER R3,FIFO,B3,SK0
DSW4:!	HANG 0,0,STAI1
	OFF SRVOUT,WR2
	MPAGE

ESF:!	ON SRVOUT
	TEST R0,B0,BIT51,ESF1
ESF1:!	XANC PC,INCR,0,STRD,ESF2	;NO PCI, START NEXT FETCH
	GOTO ESWI	;PCI, CAN'T BE FAST
ESF2:!	PULSE CLRINS,ESF3
RBB:!	XFER R2,ZERO,WHOLE,RBBA
RBBT:!	TEST R3,B1,BIT71,RBB0	;3 OR 4 BYTES IN 1ST WD
	TEST R3,B1,BIT71,RBB2	;1 OR 2 BYTES IN 1ST WD
RBB1:!	XFER R2,FIFO,B2,RBB2
	GOTO DEE
RBB2:!	XFER R2,FIFO,B1,RBB3	;2 BYTE ENTRY
RBB3:!	XFER R2,FIFO,B0,RBB4	;1 BYTE ENTRY
RBB0:!	XFER R2,FIFO,B3,RBB1	;4 BYTE ENTRY
	XFER R2,FIFO,B2,RBB2	;3 BYTE ENTRY
RBB4:!	XANC CA,DECR,R2,STWR,RBB0
RBBA:!	TEST R3,B1,BIT61,RBBT
	MPAGE

WR1:!	XFER R2,B1,FOFI,WR2
WRX:!	GOTO DEE
WR2:!	XFER R2,B2,FOFI,WR3
WR3A:!	XFER R3,MRB,WHOLE,WR5
WR4:!	XFER R2,B4,FOFI,WR6
WR3:!	XFER R2,B3,FOFI,WR3A
WR6:!	XFER R3,B0,FOFI,WR7
WR10:!	XFER R2,MRB,WHOLE,WR10A
WR7:!	XFER R3,B1,FOFI,WR8
WRX2:!	GOTO DEO
WR8:!	XFER R3,B2,FOFI,WR9
WR0:!	XFER R2,B0,FOFI,WR1
WR10A:!	XANC CA,INCR,0,STRDC,WR0
WR9:!	XFER R3,B3,FOFI,WR10
WR5:!	XANC CA,INCR,0,STRDC,WR4
WRT:!	XANC CA,INCR,0,STRD,WR10
	MPAGE

DSRE:!	TEST R3,B2,SKPC,DSRE1
	0
DSRE1:!	TEST R0,B1,RBAK,DSRE3	;NOT SKIP
	TEST R3,B3,Z,DSRE2	;POSS SKIP
DSRE2:!	TEST R0,B1,RBAK,DSRE3	;NOT SKIP
	GOTO SK0	;SKIP
DSRE3:!	GOTO RD0	;RD FWD
	TEST R0,B0,BIT41,DSRE4	;RD BAK
DSRE4:!	GOTO RB0	;RD BAK WD
	GOTO RBB	;RD BAK BYTE
DSW2:!	ON SRVOUT,DSW3	;ACCEPT INITIAL STATUS FOR NORMAL WRITE
DSW0:!	TEST R0,B0,BIT71,DSW1
DSW1:!	XFER R2,MRB,WHOLE,DSW2	;WAIT FOR FIRST WORD TO BE WRITTEN
	XFER R2,MRB,WHOLE	;SKIP 2 BYTES
	XANC CA,INCR,0,STRD
	ON SRVOUT,DSW4	;ACCEPT INITIAL STATUS - SKIP 2 BYTES MODE
	MPAGE

DEE:!	TEST 0,0,WCOK1,DEE1
DEE2A:!	XANC CA,ADRFLD,R3,LOAD,DEE2B
DEE1:!	TEST 0,0,INS11,DEE2	;WC OVF TEST DC
DEE1A:!	TEST 0,0,INS11,DEE1B	;DEV TRUNC, SEE IF SKIP DCW'S NEEDED
DEE2:!	GOTO XD2	;NO DC (CHNL TRUNC OR OK)
	XANC PC,INCR,0,STRD	;GET NEXT DCW
	XFER R3,MRB,WHOLE,DEE2A	;DONT STEP ON TDS0
DEE2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD	;SET READ-OK
	TEST R3,B0,BIT00,DEE3
DEE3:!	ON INS1	;FLAG NO MORE DCWS
	TEST R0,B1,BIT71,DEE4
DEE4:!	GOTO DSRE
	GOTO WRT
DEE1B:!	ON LENERR,XD2C	;NO SKIPS NEEDED
	ON INS1,XD1E	;FLAG AS ENDING STATUS, DO SKIPS IF REQUIRED
	MPAGE

DEO:!	TEST 0,0,WCOK1,DEO1
DEO2A:!	XANC CA,ADRFLD,R3,LOAD,DEO2B
DEO1:!	TEST 0,0,INS11,DEO2	;WC OVF TEST DC
	GOTO DEE1A	;DEV TRUNC
DEO2:!	GOTO XD3	;NO DC (CHNL TRUNC OR OK)
	XANC PC,INCR,0,STRD	;GET NEXT DCW
	XFER R3,MRB,WHOLE,DEO2A	;DONT STEP ON TDS0
DEO2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD	;SET READ-OK
	TEST R3,B0,BIT00,DEO3
DEO3:!	ON INS1	;FLAG NO MORE DCWS
	TEST R0,B1,BIT71,DEO4
DEO4:!	GOTO DSRO	;READ
	XANC CA,INCR,0,STRD	;WRITE
	GOTO WR3A
	0
	MPAGE

XD2:!	HANG 0,0,BFHLT0
	TEST 0,0,BCRQ1,XD2A
XD2A:!	TEST 0,0,BFMT1,XD2B
	ON CMDOUT	;CHNL TRUNC
	HANG 0,0,BCRQ1
	OFF CMDOUT,XD2D
XD1C:!	XFER R3,MRB,WHOLE
XD1D:!	TEST R3,B0,BIT00,XD1A
XD2B:!	ON LENERR
XD2C:!	OFF BUFENB,ED
DSW3:!	HANG 0,0,STAI1
	OFF SRVOUT,WR10A
XD1A:!	ON LENERR,XD2C	;NO MORE
XD1E:!	TEST R0,B0,BIT61,XD1B	;UNUSED DCW
XD1B:!	ON LENERR,XD2C	;NO SLI OR NO MORE
	XANC PC,INCR,0,STRD,XD1C	;SKIP A DCW
	MPAGE

DAT:!	XFER R3,MRB,WHOLE
	XANC CA,ADRFLD,R3,LOAD
	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD	;SET READ-OK
	TEST R3,B0,BIT00,DAT1
	0
ESF3:!	HANG 0,0,STAI1
	OFF SRVOUT
	HANG 0,0,OPLI1
	GOTO FET0
CMDE1:!	HANG 0,0,STAI1
	OFF SRVOUT
	HANG 0,0,OPLI1
	GOTO MERR
DAT1:!	ON INS1	;FLAG NO MORE DCW'S
	ON BUFENB,DAT2
	MPAGE

W71:!	XFER R3,B1,FOFI,W72
W7X:!	GOTO DXE
W72:!	XFER R3,B2,FOFI,W73
W74:!	XFER R2,MRB,WHOLE,W75
W75:!	XANC CA,INCR,0,STRDC,W76
W73:!	XFER R3,B3,FOFI,W74
W77:!	XFER R2,B1,FOFIS,W78
W76:!	XFER R2,B0,FOFIS,W77
W78:!	XFER R2,B2,FOFIS,W79
W7X1:!	GOTO DXO
W79:!	XFER R2,B3,FOFIS,W7A
W7B:!	XFER R3,MRB,WHOLE,W7C
W70:!	XFER R3,B0,FOFI,W71
W7A:!	XFER R2,B4,FOFIS,W7B
W7C:!	XANC CA,INCR,0,STRDC,W70
W7D:!	XANC CA,INCR,0,STRD,W7B
	MPAGE

R71:!	XFER R3,FIFO,B1,R72
R7X:!	GOTO DXE
R72:!	XFER R3,FIFO,B2,R73
R75:!	XANC CA,INCR,R3,STWR,R76
	0
R73:!	XFER R3,FIFO,B3,R74
R74:!	XFER R2,FIFOS,B0,R75
R76:!	XFER R2,FIFOS,B1,R77
R77:!	XFER R2,FIFOS,B2,R78
R7X1:!	GOTO DXO
R78:!	XFER R2,FIFOS,B3,R79
R7A:!	XANC CA,INCR,R2,STWR,R70
R70:!	XFER R3,FIFO,B0,R71
R79:!	XFER R2,FIFOS,B4,R7A
	0
	0
	MPAGE

B71:!	XFER R2,FIFOS,B3,B72
B7X:!	GOTO DXE
B72:!	XFER R2,FIFOS,B2,B73
B75:!	XANC CA,DECR,R2,STWR,B76
	0
B73:!	XFER R2,FIFOS,B1,B74
B74:!	XFER R2,FIFOS,B0,B75
B7B:!	XFER R2,FIFOS,B0,B76
B77:!	XFER R3,FIFO,B2,B78
B7X1:!	GOTO DXO
B78:!	XFER R3,FIFO,B1,B79
B7A:!	XANC CA,DECR,R3,STWR,B70
	0
B79:!	XFER R3,FIFO,B0,B7A
B76:!	XFER R3,FIFO,B3,B77
B70:!	XFER R2,FIFOS,B4,B71
	MPAGE

S71:!	XFER R3,FIFO,B1,S72
S7X:!	GOTO DXE
S72:!	XFER R3,FIFO,B2,S73
S75:!	XFER R2,FIFOS,B1,S76
S79:!	XFER R2,FIFOS,B0,S7A
S73:!	XFER R3,FIFO,B3,S74
S74:!	XFER R2,FIFOS,B0,S75
	0
S76:!	XFER R2,FIFOS,B2,S77
S7X1:!	GOTO DXO
S77:!	XFER R2,FIFOS,B3,S78
S70:!	XFER R3,FIFO,B0,S71
	0
S78:!	XFER R2,FIFOS,B4,S70
S7A:!	XFER R2,FIFOS,B1,S76
	0
	MPAGE

W91:!	XFER R3,B1,FOFI,W92
W9X:!	GOTO DXE
W92:!	XFER R3,B2,FOFI,W93
W95:!	XFER R3,MRB,WHOLE,W96
W90:!	XFER R3,B0,FOFI,W91
W93:!	XFER R3,B3,FOFI,W94
W94:!	XFER R2,B4,FOFI,W95
W96:!	XANC CA,INCR,0,STRDC,W90
R91:!	XFER R3,FIFO,B1,R92
R9X:!	GOTO DXE
R92:!	XFER R3,FIFO,B2,R93
R95:!	XANC CA,INCR,R3,STWR,R90
W97:!	XANC CA,INCR,0,STRD,W95
R93:!	XFER R3,FIFO,B3,R94
R94:!	XFER R3,FIFO,B4,R95
R90:!	XFER R3,FIFO,B0,R91
	MPAGE

B91:!	XFER R3,FIFO,B3,B92
B9X:!	GOTO DXE
B92:!	XFER R3,FIFO,B2,B93
B95:!	XANC CA,DECR,R3,STWR,B90
B90:!	XFER R3,FIFO,B4,B91
B93:!	XFER R3,FIFO,B1,B94
B94:!	XFER R3,FIFO,B0,B95
	0
S91:!	XFER R3,FIFO,B1,S92
S9X:!	GOTO DXE
S92:!	XFER R3,FIFO,B2,S93
S90:!	XFER R3,FIFO,B0,S91
DXW:!	XFER R3,MRB,WHOLE,DXWA
S93:!	XFER R3,FIFO,B3,S94
S94:!	XFER R3,FIFO,B4,S90
DXWA:!	ON SRVOUT,DXW0
	MPAGE

DXE:!	TEST 0,0,WCOK1,DXE1
DXE2A:!	XANC CA,ADRFLD,R3,LOAD,DXE2B
DXE1:!	TEST 0,0,INS11,DXE2
	GOTO DEE1A	;DEV TRUNC
DXE2:!	GOTO XD2	;NO DC
	XANC PC,INCR,0,STRD
	XFER R3,MRB,WHOLE,DXE2A
DXE2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD
	TEST R3,B0,BIT00,DXE3
DXE3:!	ON INS1
	TEST R0,B1,BIT71,DXE4
DXE4:!	GOTO DXRE
	TEST R0,B0,BIT41,DXE5
DXE5:!	GOTO W7D
	GOTO W97
	MPAGE

DXO:!	TEST 0,0,WCOK1,DXO1
DXO2A:!	XANC CA,ADRFLD,R3,LOAD,DXO2B
DXO1:!	TEST 0,0,INS11,DXO2
	GOTO DEE1A	;DEV TRUNC
DXO2:!	GOTO XD3	;NO DC
	XANC PC,INCR,0,STRD
	XFER R3,MRB,WHOLE,DXO2A
DXO2B:!	XANC WC,WCFLD,R3,LOAD
	XANC WC,INCR,0,LOAD
	TEST R3,B0,BIT00,DXO3
DXO3:!	ON INS1
	TEST R0,B1,BIT71,DXO4
DXO4:!	GOTO DXRO
	XANC CA,INCR,0,STRD
	GOTO W74
	0
	MPAGE

DXRE:!	TEST R3,B2,SKPC,DXRE1
	OFF CTBYT,DXRS
DXRE1:!	TEST R0,B1,RBAK,DXRE3	;NOT SKIP
	TEST R3,B3,Z,DXRE2	;POSS
DXRE2:!	TEST R0,B1,RBAK,DXRE3	;NOT SKIP
	TEST R0,B0,BIT41,DXRE4	;SKIP
DXRE3:!	TEST R0,B0,BIT41,DXRE5	;RD FWD
	TEST R0,B0,BIT41,DXRE6	;RD BAK
DXRE4:!	GOTO S70	;SKIP 7
	OFF CTBYT,S90	;SKIP 9
DXRE5:!	GOTO R70	;RD 7
	OFF CTBYT,R90	;RD 9
DXRE6:!	GOTO B70	;RB 7
	OFF CTBYT,B90	;RB 9
DXR:!	OFF SRVOUT
	TEST R0,B0,BIT71,DXRE
	MPAGE

DXRO:!	TEST R3,B2,SKPC,DXRO1
DXRS:!	TEST R3,B2,SKPC,DXRS1
DXRO1:!	TEST R0,B1,RBAK,DXRO3	;NOT SKIP
	TEST R3,B3,Z,DXRO2	;POSS
DXRO2:!	TEST R0,B1,RBAK,DXRO3	;NOT SKIP
	GOTO S75	;SKIP
DXRO3:!	GOTO R76	;RD FWD
	GOTO B76	;RD BAK
DXRS1:!	GOTO B7B	;NOT SKIP
	TEST R3,B3,Z,DXRS2	;POSS
DXRS2:!	GOTO B7B	;NOT SKIP
	GOTO S79	;SKIP
DXW0:!	HANG 0,0,STAI1
	TEST R0,B0,BIT41,DXW1
DXW1:!	OFF SRVOUT,W7C
	OFF SRVOUT,W96
	MPAGE

	BLOCK 6*20
	XALL
DEPHASE


PATCH:
PAT:!	BLOCK 1000

	END DDTG

