;<133-TENEX>MAGTAP.MAC;2    11-JAN-75 20:37:21    EDIT BY LYNCH
; HAD TO CHANGE THE UNLOC LOGIC TO BE A SETOM BECAUSE THIS USES A SPECIAL TEST.
;<TENEX-MON>MAGTAP.AIC;21     5-AUG-74 12:59:44	EDIT BY KREMERS
;FIX JSYS MANUAL ERROR.  GDSTS REC LENGTH GOES IN LH AC 3
;<TENEX-MON>MAGTAP.AIC;20    10-JUL-74 11:22:36	EDIT BY LYNCH
; INSERT CORRECTIONS PER MMARKED LISTING
;<TENEX-MON>MAGTAP.AIC;19    12-JUN-74 15:44:09	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;18    10-JUN-74 15:17:31	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;17     6-JUN-74 15:15:56	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;16     3-JUN-74 22:32:37	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;15    21-MAY-74 22:25:24	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;14    21-MAY-74 21:55:47	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;12    12-MAY-74 22:14:41	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;11     7-MAY-74 04:57:50	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;10     6-MAY-74 22:52:39	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;9     6-MAY-74 22:33:52	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;8     1-MAY-74 03:30:13	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;7    30-APR-74 16:45:10	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;6    23-APR-74 18:29:29	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;5    23-APR-74 17:54:47	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;4    18-APR-74 00:29:22	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;3    17-APR-74 19:58:13	EDIT BY KREMERS
;<TENEX-MON>MAGTAP.AIC;2    17-APR-74 02:15:34	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;8    15-APR-74 23:10:36	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;7    15-APR-74 22:30:38	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;6    15-APR-74 22:10:31	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;5    15-APR-74 04:05:29	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;4    13-APR-74 03:30:15	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;3    11-JAN-74 14:06:08	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;2    11-JAN-74 03:19:10	EDIT BY KREMERS
;<KREMERS>MAGTAP.AIC;1    11-JAN-74 03:06:36	EDIT BY KREMERS
	SEARCH STENEX,FILEDEF
	TITLE MAGTAP
	SUBTTL J. H. KREMERS

;	SPECIAL VERSION OF MAGTAP MODULE TO COMMUNICATE WITH THE
;MAG TAPE UNITS ON THE PDP-15 WHILE, AS NEARLY AS POSSIBLE, PRESENTING
;A TENEX-LIKE INTERFACE TO THE USER.  HANDLES ALL FUNCTIONS AVAILABLE 
;THRU THE STANDARD TENEX MAG TAPE MODULE.


;	LINKAGE TO TENEX SCHEDULER
	EXTERN CPOPJ,EDISMS,SKPRET,LCKTST,BHC


;	LINKAGE TO FILESYSTEM
	INTERN MTADTB,MTAINI
	EXTERN GTIOWD,RLIOWD,DMPLKP,DMPULP,DMPCKA

;	LINKAGE TO PDP-15 CODE
	EXTERN FIFIO,MFIFOU,OKITST,OKOTST	;I/O, READY TESTS
	EXTERN FOPEN,FCLOSE		;OPEN, CLOSE
	EXTERN MTADVN			;DEVICE NO. FOR MAGTAPES
	INTERN MTACHR			;INITIAL CHARACTERISTICS



;	MISC. EQUIVALENCES...

;	TABLE OF MAG TAPE OPCODES. (SENT TO PDP-15)
MTANOP==0	; NOP, USED FOR SYNCHING
MTARD==1	; READ RECORD FROM TAPE
REWIND==2	; REWIND TAPE
MTAWRT==3	; WRITE RECORD
SPFREC==4	; SPACE FORWARD ONE RECORD
SPFFIL==5	; DITTO 1 FILE
BSPREC==6	; BACKSPACE RECORD
BSPFIL==7	; DITTO FILE
WRTEOF==10	; WRITE EOF
SETSTA==11	; SET STATUS AND CONTROL BITS
WIND==12	; SPACE TO EOT
SNDREC==13	; SEND LAST RECORD READ TO PDP-10
STATRQ==14	; READ STATUS
SKPBLK==15	; SKIP AND BLANK 3" OF TAPE
RUNLD==16	; REWIND UNLOAD

;	MAGTAPE STATUS BITS, (IN MTASTS)

MTAWIP==1B16	;WRITE IN PROGRESS
MTARIP==1B17	;READ IN PROGRESS, OR WAS
MTAIWR==1B18	;ILLEGAL WRITE
MTADER==1B19	;DEVICE ERROR, (OFFLINE OR HUNG)
MTADTR==1B20	;DATA ERROR (I.E. PARITY)
MTANOC==1B21	;SUPRESS AUTO ERROR CORRECTION
MTAEOF==1B22	;ENT OF FILE SEEN
MTAIRL==1B23	;INCORRECT RECORD LENGTH ON READ
MTABOT==1B24	;BEGINNING OF TAPE SEEN
MTAEOT==1B25	;END OF TAPE
MTAPAR==1B26	;PARITY BIT, 1 = EVEN
MTADEN==3B28	;DENSITY BITS, 00=11=800, 01=200, 10=556
MTACHR==7B31	;CHARACTER COUNTER IF B23 ON

MTAERB==MTAIWR!MTADER!MTADTR!MTAIRL	;ERROR BITS

;	CHARACTERISTICS BITS IN LH MTDSTS (PDP-15 DEVICE AND XFER STATUS)

FCHOKO==10	;ALWAYS OK TO OUTPUT IF ON
FCHOKI==4	;DITTO INPUT
FCHLNG==1	;LONG MESSAGES OK FOR THIS DEVICE

;	;FLAG BITS IN LH MTDSTS

FDVACT==400000	;DEVICE ACTIVE IF ON
FDVOPN==200000	;DEVICE OPEN IF ON
FDVOUT==100000	;OUTPUTING TO PDP-15 IF ON
FDVPAK==040000	;TRANSFER IN PACKED MODE IF ON
FDVOKO==10000	;OK TO OUTPUT (SET BY PDP-15)
FDVOKI==4000	;DITTO INPUT
FDVLNG==2000	;CURRENT XFER IS LONG IF ON
FDVDWN==1000	;PDP-15 WENT DOWN WHILE XFER IN PROGRESS
FDVERR==200	;DATA ERROR
FDVDED==100	;DEVICE DEAD

MTACHR==FCHLNG!FCHOKO!FCHOKI	;CHARACTERISTICS BIT FOR MAGTAPES






;		STORAGE

LS MTASTS,MTAN		;DEVICE (SOFTWARE STATUS
LS MTDSTS,MTAN		;PDP-15 DEVICE STATUS
LS MTALCK,MTAN		;DEVICE LOCKS
LS RECLNG,MTAN		;RECORD LENGTH OF RECORD JUST XFERED
LS HEADER,2*MTAN	;HEADER FOR TRANSFERS TO THE PDP-15, NOT PART OF TAPE RECORD
LS MTAJOB,MTAN		;RH = JOBNO OF OPENER, LH = SYS FORK INDEX


	USE RESPC
;		IOWD'S FOR HEADERS

HDIOWD:	XXX==0
	REPEAT MTAN,<	XWD -2,HEADER+2*XXX
			XXX==XXX+1>


;	MAGTAPE INITIALIZATION CODE

MTAINI:	MOVSI 1,-MTAN
	SETOM MTALCK(1)
	SETZM MTASTS(1)
	SETZM RECLNG(1)
	AOBJN 1,MTAINI+1

	POPJ P,

	USE SWAPPC

; 		DISPATCH TABLE

MTADTB:	CPOPJ		; SET DIRECTORY
	CPOPJ		; NAME LOOKUP
	CPOPJ		; EXTENSION LOOKUP
	MTAVER		; VERSION LOOKUP
	CPOPJ		; PROTECTION INSERTION
	CPOPJ		; ACCOUNT INSERTION
	CPOPJ		; STATUS MODIFICATION
	MTAOPN		; OPEN FILE OR DEVICE
	CPOPJ		; SEQUENTIAL INPUT
	CPOPJ		; SEQUENTIAL OUTPUT
	MTACLZ		; CLOSE FILE OR DEVICE
	CPOPJ		; RENAME FILE
	CPOPJ		; DELETE FILE
	XWD 400000,MTADMI
	XWD 400000,MTADMO
	MTAMNT		; MOUNT
	MTADSM		; DIS-MOUNT
	CPOPJ		; INITIALIZE DIRECTORY
	MTAOPR		; MTOPR
	MTAGST		; GET DEVICE STATUS
	MTASST		; SET DEVICE STATUS


;	COMMON REGISTER SETUP CODE

SETREG:	MOVEI UNIT,MTADVN	;DEVICE NO. TO UNIT
	HLRS DEV		;SUB-DEVICE NO. IN BOTH HALFS OF DEV
	MOVEI IOS,MTDSTS(DEV)	;PDP-15 STATUS WORD POINTER IN IOS
	POPJ P,			;RETURN




;	MAGTAPE SERVICE ROUTINES

;	MOUNT MAGTAPE

MTAMNT:

;	DISMOUNT MAGTAPE

MTADSM:	JRST SKPRET		;COMPLECATED WHAT ?

;	VERSION LOOKUP (CURRENTLY CHECKS LOCK AND UNLOCKS IF NECESSARY)

MTAVER:	SETZ 1,
	TEST (NE,UNLKF)		;LOCKED ?
	JRST SKPRET		;NO
	SETOM MTALCK(UNIT)	;YES, UNLOCK IT
	OKINT			;ALLOW INTERRUPTS
	JRST SKPRET		;RETURN

;	GET MAGTAPE DEVICE STATUS

MTAGST:	PUSHJ P,SETREG	;SETUP AC'S

	MOVE 1,MTASTS(DEV)	;GET CURRENT STATUS
	TLNE 1,(MTARIP)		;IS SOMETHAING GOING ON ?
	JRST MTAGS1		;YES, READ IN PROGRESS, GIVE OLD STATUS

	PUSHJ P,TSTOKO		;PREPARE TO READ STATUS
	MOVEI 1,MTADER		;GET ERROR BIT
	PUSHJ P,RDSTAT		;READ STATUS FROM -15
	JRST MTAGS2		;CAN'T, SAY DEVICE ERROR
	MOVE 2,MTDSTS(DEV)	;GET STATUS
	TLNN 2,FDVDWN!FDVDED	;PDP-15 OR DEVICE ERROR ?
	SETZ 1,			;NO, CLEAR ERROR INDICATION
MTAGS2:	IORB 1,MTASTS(DEV)	;SET BIT IF ANY, AND GET MTA STATUS
MTAGS1:	TLZ 1,777777		;CLEAR EXTRAINOUS BITS
	HRLZ 2,RECLNG(DEV)	;GET RECORD LENGTH
	UMOVEM 2,3	;MOVE TO USERS REG
	POPJ P,		;RETURN



;	SET MAGTAPE DEVICE STATUS

MTASST:	PUSHJ P,SETREG	;SETUP AC'S
	LOCK MTALCK(DEV),<PUSHJ P,LCKTST>
	ANDCMI 1,17	;CLEAN AND SAVE ARG
	PUSH P,1

	MOVE 1,MTASTS(DEV)	;GET CURREINT STATUS
	TLNN 1,(MTARIP)		;SOMETHING GOING ON ?
	JRST MTASS1		;NO, GO AEAD

	MOVE 1,MTDSTS(DEV)	;READ IN PROGRESS
	TLNE 1,FDVOKI!FDVDWN	;DONE YET ?
	JRST MTASS1		;YES
	MOVEI 1,OKITST		;NO, MUST WAIT
	HRLI 1,MTDSTS(DEV)
	JSYS EDISMS

MTASS1:	PUSHJ P,TSTOKO		;BE SURE WE'RE READY
	MOVSI 2,MTANOP		;SYNCH UP BEFORE SENDING NEW BITS
	SETZ 3,
	PUSHJ P,MFIFOU		;SEND NOP
	JFCL			;IGNORE ERRORS

	POP P,2			;RETRIEVE USERS BITS
	MOVEI 1,MTANOC!MTAPAR!MTADEN	;ALLOW ONLY THESE TO BE SET
	ANDCAM 1,MTASTS(DEV)	;RESET SETTABLE VALUES
	ANDB 1,2		;KEEP ONLY SETTABLE ONES
	IORM 2,MTASTS(DEV)	;SET IN STORAGE
	HRLI 2,SETSTA		;SEND NEW STATUS TO THE -15
	SETZ 3,
	PUSHJ P,MFIFOU
	JFCL

	SETOM MTALCK(DEV)	;UNLOCK

	POPJ P,		;EXIT


;	OPEN MAGTAPE


MTAOPN:	PUSHJ P,SETREG	;SETUP AC'S
	LOCK MTALCK(DEV),<PUSHJ P,LCKTST>	;ONLY ONE AT A TIME
	HRLI IOS,MTAJOB(DEV)	;SETUP AC'S FOR FOPEN
	HLR 4,IOS

	PUSHJ P,FOPEN	;LET PDP-15 OPEN CODE DO THE WORK
	JRST OPNERR	;ERROR

	MOVSI 1,FDVPAK	;ALL TRANSFERS WILL BE IN PACKED MODE
	IORM 1,0(IOS)	;SO SET THIS IN THE MTDSTS WORD
	SETZM MTASTS(DEV)	;CLEAR SOFTWARE STATUS WORD
	SETOM MTALCK(DEV)	;UNLOCK
	JRST SKPRET	;RETURN

OPNERR:	SETOM MTALCK(DEV)	;ERROR, JUST UNLOCK
	POPJ P,		;AND RETURN


;	CLOSE MAGTAPE

MTACLZ:	PUSHJ P,SETREG	;AN OLD RITUAL
	LOCK MTALCK(DEV),<PUSHJ P,LCKTST>
	HRLI IOS,MTAJOB(DEV)
	HLR 4,IOS

	PUSHJ P,FCLOSE	;OK, LET PDP-15 DO THE WORK
	CAIA		;ERROR
	AOS 0(P)	;OK, GIVE SKIP

	SETOM MTALCK(DEV)
	POPJ P,		;RETURN



;	MTOPER JSYS CODE

MTAOPR:	MOVEI 1,DESX1		;GET POSSIBLE ERROR NO.
	CAILE 2,NMTOPS		;LEGAL OP ?
	POPJ P,			;NO, RETURN

	PUSHJ P,SETREG		;YES, SETUP AC'S

	MOVEI 1,DESX5		;ERROR FOR DEVICE NOT OPEN
	MOVE 3,MTDSTS(DEV)
	TLNN 3,FDVOPN		;OPEN ?
	POPJ P,			;NO, ERROR

	PUSHJ P,TSTOKO		;INSURE READYNESS
	MOVE 3,MTDSTS(DEV)	;GET -15 STATUS
	TLNE 3,FDVDWN!FDVDED	;DEVICE OK ?
	POPJ P,			;NO, EXIT

	LOCK MTALCK(DEV),<PUSHJ P,LCKTST>	;KEEP OTHERS OUT

	MOVE 2,MTOPTB(2)	;GET OPCODE FROM TABLE
	MOVE 1,MTASTS(DEV)	;GET CURRENT STATUS
	TLNE 1,(MTARIP!MTAWIP)	;CLEAR THESE AND TEST
	TRNN 2,777777		;TO SEE IF WE HAVE TO DO ANY BULLSHIT BECAUSE
	CAIA			;OF THEM. NO, JUST DO THE OP
	JRST 0(2)		;YES, GO DO PSECIAL BULL SHIT

MTAOP2:	HLLZS 2			;SOME COME BACK HERE, CLEAN OP
	SETZ 3,			;CLEAR REST OF HEADER
	PUSHJ P,MFIFOU		;SEND IT
	JFCL			;IGNOR ERROR

MTAOP1:	MOVE 1,[MTARIP!MTAWIP!MTAERB!MTAEOF!MTAEOT]		;CLEAR THESE
	ANDCAM 1,MTASTS(DEV)
	SETZM RECLNG(DEV)	;CLEAR THIS TOO
	TEST (Z,ERRF,EOFF)	;RESET ERRORS

	SETOM MTALCK(DEV)	;UN LOCK
	POPJ P,			;RETURN


;	MTOPER OPERATION TABLE
;	LH CONTAINS OP, RH CONTAINS ADDRESS OF SPECIAL BULLSHIT PROCCESSING
;	ROUTINE FOR USE IN CASE READ-AHEAD IS IN PROGRESS

MTOPTB:	NOPOP			; 0,	NOP
	XWD REWIND,0		; 1,	REWIND
	NOPOP			; 2,	NOP
	XWD WRTEOF,EOFOP	; 3,	WRITE EOF
	NOPOP			; 4,	NOP
	NOPOP			; 5,	NOP
	XWD SPFREC,SPFOP1	; 6,	SPACE RECORD
	XWD BSPREC,EOFOP	; 7,	BACKSPACE RECORD
	XWD WIND,EOFOP		; 10, 	SKIP TO EOT
	XWD RUNLD,0		; 11, 	REWIND, UNLOAD
	NOPOP			; 12,	NOP
	XWD SKPBLK,0		; 13,	SKIP-AND-BLANK
	NOPOP			; 14, 	NOP
	NOPOP			; 15, 	NOP
	XWD SPFFIL,SPFOP	; 16,	SPACE FWD ONE FILE
	XWD BSPFIL,BSFOP	; 17,	BACKSPACE FILE
NMTOPS=.-MTOPTB			;NUMBER OF OPS ALLOWED


;	SPECIAL PROCESSORS

;	PROCESS NOP

NOPOP:	MOVSI 1,FDVOKO		;BE SURE THIS IS SET
	IORM 1,MTDSTS(DEV)	;IN DEVICE STATUS
	MOVEI 1,MTAERB!MTAEOF!MTAEOT	;DON'T KILL READ-IN-PROGRESS
	JRST MTAOP1+1

;	PROCESS EOF

EOFOP:	PUSH P,2
	PUSHJ P,BKSPC		;BACKSPACE RECORD
	POP P,2
	JRST MTAOP2		;GO DO THE OPERATION


;	SPACE FORWARD ONE FILE

SPFOP:	PUSH P,2		;SAVE OLD OP
	PUSHJ P,RDSTAT		;GET LATEST STATUS
	JFCL
	PUSHJ P,TSTOKO
	POP P,2
	MOVE 1,MTASTS(DEV)	;GET STATUS
	TRNN 1,MTAEOF		;ALREADY AT EOF ?
	JRST MTAOP2		;NO, GO DO IT
				;ENTER HERE FROM ABOVE TO BE SURE FDVOKO IS SET
SPFOP1:	MOVSI 1,FDVOKO		;YES, BE SURE THI IS SET
	IORM 1,MTDSTS(DEV)	;AND IGNORE
	JRST MTAOP1



;	BACKSPACE FILE

BSFOP:	PUSH P,2		;SAVE OP
	PUSHJ P,RDSTAT		;GET CURRENT STATUS
	JFCL
	PUSHJ P,TSTOKO
	MOVE 1,MTASTS(DEV)
	TRNE 1,MTAEOF		;JUST PAST AN EOF ?
	PUSHJ P,BKSPC		;YES, BACK OVER IT
	POP P,2			;RETRIEVE OP
	JRST MTAOP2		;GO DO IT


;	BACKSPACE RECORD SUBROUTINE

BKSPC:	MOVSI 2,BSPREC
	SETZ 3,
	PUSHJ P,MFIFOU
	JFCL
	PUSHJ P,TSTOKO
	POPJ P,



;	DUMP OUTPUT CODE FOR MAGTAPES

MTADMO:	HRRI 1,1(1)		;ADJUST IOWD TO POINT AT USER DATA
	PUSH P,1		;SAVE USERS IOWD
	PUSHJ P,SETREG		;SETUP AC'S
	LOCK MTALCK(DEV),<PUSHJ P,LCKTST>	;LOCK UP

	MOVSI 1,(MTAWIP)	;SAY WRITE IN PROGRESS
	IORB 1,MTASTS(DEV)	;SET BIT AND GET STATUS WORD
	TLZN 1,(MTARIP)	;READ IN PROGRESS ?
	JRST MTADO1		;NO, GO  DO THE WRITE

	MOVEM 1,MTASTS(DEV)	;RESTORE STATUS WORD
	PUSHJ P,TSTOKO		;BE SURE WE'RE READY
	PUSHJ P,RDSTAT		;GET CURRENT STATUS
	JRST MTDER1		;CAN'T
	PUSHJ P,BKSPC		;ALWAYS NEED AT LEAST ONE BACK SPACE
	MOVE 1,MTASTS		;RETRIEVE STATUS
	TRNN 1,MTAEOF		;WERE WE AT EOF ?
	JRST MTADO1+1		;NO, GO AHEAD
	PUSHJ P,BKSPC		;YES DO ONE MORE BACKSPACE ...
	MOVEI 2,SPFREC		;THEN SKIP ONE RECORD TO GET TO CORRECT 
	SETZ 3,			;POSITION ...
	PUSHJ P,MFIFOU
	JRST MTDER1

MTADO1:	PUSHJ P,TSTOKO
	MOVSI 1,FDVOKO!FDVDED	;BE SORE THESE ARE OFF
	ANDCAB 1,MTDSTS(DEV)	;IN MTDSTS
	TLNE 1,FDVDWN		;IS THE PDP-15 DOWN ?
	JRST DATER1		;YES, ERROR

	MOVE 1,0(P)		;GET USERS IOWD
	MOVSI 2,(1B2)		;GET ACCESS BITS FOR OPERATION
	PUSHJ P,DMPCKA		;CHECK ACCESS ON ALL PAGES
	JRST MTDER1		;ILLEGAL ACCESS

	MOVE 4,DEV		;1 NOW HAS # PAGES INVOLVED,
	ASH 4,1			;2 HAS -10 WORD COUNT, 4 HAS POINTER TO HEADER
	MOVEI 3,2(2)		;3 WILL HAVE PDP-15 WORD COUNT
	ASH 3,1			;NOW IT DOES
	MOVEM 2,RECLNG(DEV)	;SAVE RECORD LENGTH FOR POSTARITY
	HRLI 2,MTAWRT		;GET WRITE OPCODE
	MOVEM 2,HEADER(4)	;PLANT IN HEADER
	SETZM HEADER+1(4)	;CLEAR REST OF HEADER

	PUSHJ P,GTIOWD		;GET IOWD'S FOR OPERATION
	PUSH P,1		;SAVE FOR RELEASING

	MOVSI 7,FDVACT!FDVOUT!FDVPAK	;SETUP BITS FOR FURTHER OPERATIONS
	MOVE 2,-1(P)		;RETRIEVE USERS IOWD
	PUSHJ P,DMPLKP		;LOCK IN PAGES AND SETUP IOWD LIST

	HRROI 2,HDIOWD(DEV)	;SETUP AOBJN POINTER FOR HEADER
	PUSHJ P,FIFIO		;DO THE OPERATION
	TEST (O,ERRF)		;ERROR, SET BIT

	POP P,1			;GET IOWD POINTER
	PUSHJ P,RLIOWD		;RELEASE IOWD'S

	POP P,1			;GET USERS IOWD
	PUSHJ P,DMPULP		;UNLOCK USERS PAGES

	TEST (NE,ERRF)		;WAS THERE AN ERROR ?
	JRST MTADO2		;YES, TAKE ERROR EXIT

	PUSHJ P,TSTOKO		;WAIT
	MOVSI 1,FDVOKO		;RE-INSERT THIS ...
	IORM 1,MTDSTS(DEV)		;SINCE TSTOKO CLEARS IT

MTADO3:	PUSHJ P,RDSTAT		;OPERATION DOEN, READ STATUS
	JFCL			;IGNORE ERROR
	MOVE 1,MTDSTS(DEV)	;GET DEVICE STATUS
	TLNN 1,FDVDWN!FDVDED	;ERROR IF -15 OR TAPES DIE
	JRST MTADO4		;NO, OK
MTADO2:	MOVEI 1,MTADER		;SOME KIND OF ERROR, SAY DEVICE ERROR
	IORM 1,MTASTS(DEV)	;PLANT IN STATUS WORD
	TEST (O,ERRF)		;AND RETURN ERROR

MTADO4:	MOVSI 1,(MTARIP!MTAWIP)	;SAY NOTHING GOING ON
	ANDCAB 1,MTASTS(DEV)	;AND GET STATUS ...
	TRNE 1,MTAEOT!MTAERB	;TEST ERROR CONDITIONS ...
	TEST (O,ERRF)		;INDICATE IF ANY

	SETOM MTALCK(DEV)
	TEST (NE,ERRF)		;IF ERROR ...
	SETOM RECLNG(DEV)	;SET RECORD LENGTH TO -1
	POPJ P,			;EXIT



;	DUMP INPUT FOR MAGTAPES

MTADMI:	HRRI 1,1(1)		;ADJUST IOWD TO POINT AT USER DATA
	PUSH P,1		;SAVE IT
	PUSHJ P,SETREG	;SETUP AC'S
	LOCK MTALCK(DEV),<PUSHJ P,LCKTST>

	MOVEI 1,MTAERB	;CLEAR ERROR INDICATIONS
	ANDCAB 1,MTASTS(DEV)	;AND GET STATUS

	TLNE 1,(MTARIP)		;READ IN PROGRESS ?
	JRST MTADI1		;YES

	PUSHJ P,TSTOKO
	MOVSI 1,FDVOKI!FDVOKO!FDVDED	;YES, CHECK THESE
	ANDCAM 1,MTDSTS(DEV)
	MOVSI 2,MTARD		;GET COMMAND
	SETZ 3,
	PUSHJ P,MFIFOU		;START THE READ
	JRST DATER1		;CAN'T

MTADI1:	MOVE 1,MTDSTS(DEV)	;READ IN PROGRESS, WAIT FOR IT
	TLNE 1,FDVOKI		;BY WAITING FOR THIS TO BE SET
	JRST MTADI2		;OK, DONE
	MOVEI 1,OKITST		;NOT DOEN, MUST WAIT
	HRLI 1,MTDSTS(DEV)
	JSYS EDISMS

MTADI2:	MOVSI 1,(MTARIP)	;BE SURE THIS IS OFF
	ANDCAM 1,MTASTS(DEV)
	MOVE 1,MTDSTS(DEV)	;GET STATUS OF TRANSFER
	TLNE 1,FDVDWN!FDVDED	;IS IT OK ?
	JRST DATER1		;NO

	PUSHJ P,RDSTAT		;OK, NOW GET TAPE STATUS
	JRST DATER1		;CAN'T
	MOVE 1,MTASTS(DEV)	;TEST IT
	TRNE 1,MTAERB		;ANY ERRORS ?
	JRST MTDER1		;YES
	TRNE 1,MTAEOF!MTAEOT	;EOF ORR EOT ?
	JRST MTDEF1		;YES

	MOVE 1,0(P)		;OK, SETUP FOR READ, GET USERS IOWD
	MOVSI 7,FDVACT!FDVPAK	;SET THIS IN STATUS ONLY
	MOVSI 2,(1B3)		;READ ACCESS TO MEMORY NEEDED
	PUSHJ P,DMPCKA		;CHECK AND COUNT USERS PAGES
	JRST MTDER1		;ACCESS ERROR

	MOVEM 2,RECLNG(DEV)	;SAVE RECORD LENGTH, ASSUMING CORRECT
	HRRZ 4,DEV		;MAKE 4 POINTER TO HEADER
	ASH 4,1			;DEV*2 SINCE HEADER IS 2 WORDS
	MOVEI 2,1(2)		;NO. OF WORDS WE WANT FROM PDP-15
	MOVE 3,2
	ASH 3,1			;MAKE PDP-15 WDCNT IN 3
	HRRZM 2,HEADER(4)	;AND PLANT WORD COUNT IN COMMAND

	MOVEI 1,1(1)		;NEED 1+ NO. PAGES IOWD'S
	PUSHJ P,GTIOWD		;GET SOME
	PUSH P,1		;SAVE ORIGINAL AOBJN WORD FOR RESTORING
	MOVE 2,HDIOWD(DEV)	;GET HEADER IOWD
	MOVEM 2,0(1)		;PLANT IN IOWD LIST
	ADD 1,BHC+1		;ADJUST AOBJN POINTER

	MOVE 2,-1(P)		;GET USERS IOWD
	PUSHJ P,DMPLKP		;LOCK IN THE PAGES

	MOVSI 2,SNDREC		;TELL THE -15 TO SEND THE RECORD OVER
	HLLM 2,HEADER(4)	;PLANT COMMAND IN HEADER WITH WDCNT
	SETZM HEADER+1(4)	;CLEAR REST OF HEADER

	HRROI 2,HDIOWD(DEV)	;MAKE AOBJN WORD FOR HEADER IN AC 2
	MOVE 1,0(P)		;GET AOBJN POINTER FOR DATA
	PUSHJ P,FIFIO		;GET THE RECORD
	TEST (O,ERRF)		;SET IG ERROR

	POP P,1			;GET ORIGINAL AOBJN WORD
	PUSHJ P,RLIOWD		;RELEASE THEM

	POP P,1			;GET USERS IOWD
	PUSHJ P,DMPULP		;RELEASE LOCKED PAGES

	HRRE 2,HEADER+1(4)	;GET WORD COUNT OF RECORD JUST XFERED
	MOVEI 1,MTAIRL		;GET ERROR BIT
	CAME 2,RECLNG(DEV)	;DO THE LENGTHS MATCH ?
	IORM 1,MTASTS(DEV)	;NO
	MOVEM 2,RECLNG(DEV)	;SAVE LENGTH WE GOT

	TEST (NE,ERRF)		;ANY ERRORS
	JRST MTADI3		;YES, QUIT
	MOVSI 1,FDVOKI!FDVOKO	;NOW READ NEXT RECORD FROM TAPE
	ANDCAM 1,MTDSTS(DEV)
	MOVSI 2,MTARD
	SETZ 3,
	PUSHJ P,MFIFOU
	JFCL 

	MOVSI 1,(MTARIP)	;SAY READ IN PROGRESS
	IORM 1,MTASTS(DEV)

MTADI3:	SETOM MTALCK(DEV)	;UNLOCK
	TEST (NE,ERRF)		;WAS THERE AN ERROR ?
	SETOM RECLNG(DEV)	;YES, FLAG RECORD LENGTH

	POPJ P,			;EXIT


;	DUMP INPUT ERROR ROUTINES

DATER1:				;DATA ERROR
	MOVEI 1,MTADTR		;MARK IN STATUS
	IORM 1,MTASTS(DEV)	
MTDEF1:				;EOF
MTDER1:	POP P,1			;CLEAR STACK
	MOVSI 1,(MTARIP!MTAWIP)	;RESET THESE
	ANDCAB 1,MTASTS(DEV)
	TRNE 1,MTAEOF		;EOF ?
	TEST (OA,EOFF)		;YES, TELL THE SYSTEM
	TEST (O,ERRF)		;NO, ERROR
	SETZM RECLNG(DEV)	;CLEAR RECORD LENGTH
	JRST MTADI3		;EXIT



;	ROUTINE TO READ STATUS FROM THE PDP-15
;	RETURNS WITH STSTUS OF UNIT IN MTASTS(DEV).  NO SKIP IF UNABLE
;	TO READ.

RDSTAT:	PUSH P,1		;SAVE 1
	PUSH P,7		;SAVE THIS
	MOVSI 7,FDVACT!FDVPAK	;USE THESE

	HRR 4,DEV		;MAKE POINTER TO HEADER
	ASH 4,1
	MOVSI 2,STATRQ		;GET STATUS REQUEST COMMAND
	MOVEM 2,HEADER(4)	;PLANT IN HEADER
	SETZB 1,HEADER+1(4)	;SAY NO DATA, AND CLEAR HEADER
	HRROI 2,HDIOWD(DEV)	;MAKE AOBJN WORD FOR HEADER
	MOVEI 3,4		;SET PDP-15 WORD COUNT
	PUSHJ P,FIFIO		;REQUEST STATUS
	JRST RDST1		;CAN'T GET IT
	AOS -2(P)		;GOT IT, GIVE SKIP RETURN

	MOVS 7,HEADER(4)	;GET STATUS
	HRRM 7,MTASTS(DEV)	;SAVE LOCALLY

RDST1:	POP P,1
	POP P,7			;RESTORE THIS
	POPJ P,		;EXIT




;	ROUTINE TO TEST OK-TO-OUTPUT BIT IN PDP-15 DEVICE STATUS WORD.
;	CLEARS BIT AFTER DETERMINING THAT IT IS SET.

TSTOKO:	PUSH P,1		;SAVE THIS
	MOVE 1,MTDSTS(DEV)	;GET STATUS
	TLNE 1,FDVOKO!FDVDED	;DEVICE OK, OR DEAD ?
	JRST TSTOK1		;YES

	MOVEI 1,OKOTST		;TEST ROUTINE ADDRESS
	HRLI 1,MTDSTS(DEV)	;WORD TO TEST
	JSYS EDISMS		;WAIT

TSTOK1:	MOVSI 1,FDVOKO		;GET BIT
	ANDCAM 1,MTDSTS(DEV)	;TURN IT OFF

	POP P,1			;RESTORE 1
	POPJ P,			;EXIT



	END
