;<133-TENEX>MDSKPA.MAC;17     1-MAY-75 14:22:06    EDIT BY UNTULIS
;DISABLE MNTSWP CODE

;<133-TENEX>MDSKPA.MAC;9    28-APR-75 14:32:08    EDIT BY UNTULIS
;<133-TENEX>MDSKPA.MAC;8    28-APR-75 13:45:02    EDIT BY UNTULIS
;<133-TENEX>MDSKPA.MAC;7    28-APR-75 09:27:18    EDIT BY UNTULIS
;<133-TENEX>MDSKPA.MAC;6    28-APR-75 09:21:05    EDIT BY UNTULIS
;<133-TENEX>MDSKPA.MAC;2     3-APR-75 11:45:30    EDIT BY UNTULIS
;ADD CODE FOR MULTIPLE PACK SWAPPING
;<133-TENEX>DSKPAK.MAC;35    26-MAR-75 15:24:00    EDIT BY UNTULIS
;<133-TENEX>DSKPAK.MAC;33     6-MAR-75 14:49:03    EDIT BY UNTULIS
;<133-TENEX>DSKPAK.MAC;31     6-MAR-75 12:23:07    EDIT BY UNTULIS
;ADD CODE TO PRINT MESSAGE IF PACK GOES READ ONLY
;<133-TENEX>DSKPAK.MAC;29     2-MAR-75 15:18:13    EDIT BY UNTULIS
;CORRECT CRASH AND MNBOOT CODE
;<133-TENEX>DSKPAK.MAC;27    26-FEB-75 09:23:02    EDIT BY UNTULIS
;CORRECT CRASH CODE AND READ ONLY CODE
;<133-TENEX>DSKPAK.MAC;25    24-FEB-75 09:51:09    EDIT BY UNTULIS
;FIX CALL RETURN IN MNBOOT
;<133-TENEX>DSKPAK.MAC;24    24-FEB-75 09:30:30    EDIT BY UNTULIS
;CORRECT IOR IN CRASH PROBLEM
;<133-TENEX>DSKPAK.MAC;20    19-FEB-75 11:36:33    EDIT BY UNTULIS
;SUPPRESS LISTING OF DC10 CODE
	;<133-TENEX>DSKPAK.MAC;15    19-FEB-75 10:25:38    EDIT BY UNTULIS
;CORRECT AND CHANGE CRASH DUMP CODE
;<133-TENEX>DSKPAK.MAC;11    12-FEB-75 10:01:46    EDIT BY UNTULIS
;ADDED CONDITIONAL CODE FOR DIDSC0. DEPENDENT ON ONE PACK SYSTEM.
;<133-TENEX>DSKPAK.MAC;10    26-JAN-75 17:33:38    EDIT BY LYNCH
;<133-TENEX>DSKPAK.MAC;4    22-JAN-75 15:06:04    EDIT BY UNTULIS
;FIX RDONLY CODE
;<132>DSKPAK.MAC;37    31-DEC-74 10:42:49    EDIT BY UNTULIS
;CORRECT DSKC1 CONO'S FOR CLEARING POWER OFF CONDITION
;<132>DSKPAK.MAC;36    30-DEC-74 16:43:21    EDIT BY UNTULIS
;ADDED ONE PACK SYSTEM CONDITIONALS
;<132>DSKPAK.MAC;32    16-DEC-74 17:08:46    EDIT BY LYNCH
; FIXED BUG IN RRLDF10 FOR ACCESSING RANDOM DISK TABLES.
;<132>DSKPA2.MAC;37    12-DEC-74 22:22:41    EDIT BY OP
; CORRECTED RELEASE OF DF10 LOGIC FOR MULTIPLE CONTROLLER WORLD.
;<132>DSKPA2.MAC;11    20-NOV-74 17:47:26    EDIT BY UNTULIS
;SETUP SO THAT DRIVTAB WILL HAVE A POINTER IN GETTAB
;<UNTULIS>DSKPA2.MAC;10     4-NOV-74 13:23:43    EDIT BY UNTULIS
;ADD CODE FOR SWAPPING FROM MIDDLE OF PACKS
;<132>DSKPAK.MAC;23    21-OCT-74 10:54:57    EDIT BY UNTULIS
;INCREASE DSKOP TIMEOUT FROM 5 TO 20 SECS IN CASE OF BAD PICTURE
;<132>DSKPAK.MAC;21    17-OCT-74 14:01:31    EDIT BY UNTULIS
;SUPPRESS LISTING OF SSA10 CODE

;<132>DSKPAK.MAC;20     7-OCT-74 15:11:28    EDIT BY UNTULIS
;FIX OVERFLOW TO DISK PROBLEM AT DSKIS
;<132>DSKPAK.MAC;18    28-SEP-74 23:43:22	EDIT BY LYNCH
;<132>DSKPAK.MAC;10    20-SEP-74 00:29:51	EDIT BY UNTULIS
;<132>DSKPAK.MAC;9    19-SEP-74 17:09:42	EDIT BY UNTULIS
;<132>DSKPAK.MAC;8    18-SEP-74 11:23:05	EDIT BY UNTULIS
;<TENEX-132>DSKPAK.MAC;89    25-JUN-74 13:23:01    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;89    25-JUN-74 13:20:22    EDIT BY CLEMENTS
; FIXED LOOP ON PI5 IF DSK BUSY (3330), ERROR IN DSVCDC.
;<TENEX-132>DSKPAK.MAC;88    24-JUN-74 10:28:08    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;87    24-JUN-74 09:08:40    EDIT BY CLEMENTS
; MOVED DSK ERROR PRINTER (JOB 0) INTO DSKPAK, FOR DEVICE DEPENDENCE
;<TENEX-132>DSKPAK.MAC;86    10-JUN-74 17:00:41    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;85    10-JUN-74 12:33:22    EDIT BY ALLEN
; REDEFINED BIT TABLE STORAGE TO INSURE PAGE ALIGNMENT
;<TENEX-132>DSKPAK.MAC;84     7-JUN-74 17:11:52    EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;83     5-JUN-74 18:49:32    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;82     5-JUN-74 18:41:22    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;81     3-JUN-74 15:28:00    EDIT BY TOMLINSON
; RESET TIMER DURING RECAL AFTER DSK ERROR
;<TENEX-132>DSKPAK.MAC;80    19-MAY-74 17:25:56    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;79    13-MAY-74 12:57:49    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;78     9-MAY-74 13:06:32    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;77     9-MAY-74 11:39:11    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;76     9-MAY-74 10:07:45    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;75     9-MAY-74 09:38:45    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;74     9-MAY-74 09:02:25    EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;73    30-APR-74 23:34:29	EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;72    29-APR-74 16:38:35	EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;71    29-APR-74 15:04:28	EDIT BY CLEMENTS
;<TENEX-132>DSKPAK.MAC;70    29-APR-74 14:30:58	EDIT BY CLEMENTS
; MERGED 3330/SSA VERSION INTO REGULAR VERSION
;<TENEX-132>DSKPAK.MAC;69    18-APR-74 01:17:19	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;68    17-APR-74 23:00:03	EDIT BY TOMLINSON
;<TENEX-132>DSKPAK.MAC;67    17-APR-74 22:46:32	EDIT BY TOMLINSON
; MAKE DSKPAR BE INITIALIZED AT RUN TIME SO HOME BLOCK ADDRESSES CAN
;  BE CONVERTED TO HARDWARE FORMAT FROM LOGICAL HARDWARE FORMAT
;<TENEX-132>DSKPAK.MAC;66    17-APR-74 21:52:58	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;65    17-APR-74 21:11:35	EDIT BY TOMLINSON
;<TENEX-132>DSKSSA.MAC;7    17-APR-74 15:35:56	EDIT BY CLEMENTS
;<TENEX-132>DSKSSA.MAC;6    15-APR-74 18:33:51	EDIT BY CLEMENTS
;<TENEX-132>DSKSSA.MAC;5    15-APR-74 17:54:11	EDIT BY CLEMENTS
;<TENEX-132>DSKSSA.MAC;4    15-APR-74 17:44:39	EDIT BY CLEMENTS
;<TENEX-132>DSKSSA.MAC;2    15-APR-74 16:24:09	EDIT BY CLEMENTS
;<TENEX-132>DSKSSA.MAC;1    15-APR-74 16:11:40	EDIT BY CLEMENTS
; FIRST PASS AT CODE FOR 3330'S
;<TENEX-132>DSKPAK.MAC;64    12-APR-74 15:03:23	EDIT BY CLEMENTS
; PARAMETERS FOR 3330 ON SSA
;<TENEX-132>DSKPAK.MAC;63     6-APR-74 12:20:17	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;62     3-APR-74 21:18:53	EDIT BY TOMLINSON
; MADE HOME PART OF DSKPAR
;<TENEX-132>DSKPAK.MAC;61    27-MAR-74 21:57:25	EDIT BY TOMLINSON
; INTERNED NDSKPR
;<TENEX-132>DSKPAK.MAC;60    25-MAR-74 10:13:45	EDIT BY TOMLINSON
; ADDED DSKPAR GETAB TABLE
;<TENEX-132>DSKPAK.MAC;59    15-MAR-74 13:21:54	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;58     8-MAR-74 01:52:38	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;57     7-MAR-74 21:09:50	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;56     5-MAR-74 11:17:51	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;55     1-MAR-74 22:53:42	EDIT BY ALLEN
;<TENEX-132>DSKPAK.MAC;54     1-MAR-74 16:10:12	EDIT BY ALLEN
;ADD NON-DESTRUCTIVE (HOPEFULLY) CORE DUMP FEATURE
;<TENEX-132>DSKPAK.MAC;49    27-JUN-73 20:12:28	EDIT BY CLEMENTS
;<TENEX-130>DSKPAK.MAC;48    28-DEC-72 19:26:25	EDIT BY CLEMENTS

;<TENEX-MON>DSKPAK.MAC;16     9-JUL-74 03:50:04	EDIT BY KREMERS
;<TENEX-MON>DSKPAK.MAC;15     9-JUL-74 02:20:20	EDIT BY KREMERS
;<TENEX-MON>DSKPAK.MAC;14     8-JUL-74 20:55:37	EDIT BY KREMERS
;<TENEX-MON>DSKPAK.MAC;13     7-JUL-74 22:38:42	EDIT BY KREMERS
;MODIFIED TO ACCOMIDATE NEW TV START STUFF
;<TENEX-MON>DSKPAK.MAC;12    10-JUN-74 19:14:50	EDIT BY KREMERS
;<TENEX-MON>DSKPAK.MAC;10    10-JUN-74 15:30:31	EDIT BY KREMERS
;MRE FIXES FOR TV STUFF
;<TENEX-MON>DSKPAK.MAC;9     6-JUN-74 00:29:28	EDIT BY KREMERS
;MADE GTDF10 RETURN OKSKED
;<TENEX-MON>DSKPAK.MAC;8    28-MAY-74 11:13:53	EDIT BY LYNCH
; TOOK OUT TEMP PATCH FOR CONTOLLER PROBLEM
;<TENEX-MON>DSKPAK.MAC;7    16-MAY-74 09:30:02	EDIT BY LYNCH
;	CHANGED DRIVE TABLE PERMANENTLY FOR DRIVE 6 (INSTEAD OF 5)

;<TENEX-MON>DSKPAK.MAC;6    23-FEB-74 17:24:54	EDIT BY LYNCH
; CHANGED BUGHLT TO BUGCHK FOR DISK OP OVERDUE. NO USE DYING FOR BRUSH CYCLE
;<TENEX-MON>DSKPAK.MAC;5    29-NOV-73 12:19:02	EDIT BY KREMERS
;<TENEX-MON>DSKPAK.MAC;4    29-NOV-73 12:07:45	EDIT BY KREMERS
;<KREMERS>DSKPAK.MAC;3    29-NOV-73 07:31:09	EDIT BY KREMERS
;<KREMERS>DSKPAK.MAC;2    29-NOV-73 06:52:25	EDIT BY KREMERS
;ADDED SWAPPING OVERFLOW STUFF
;<TENEX-MON>DSKPAK.MAC;2     8-NOV-73 16:21:12	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;13    28-AUG-73 05:28:41	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;11    23-AUG-73 15:25:16	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;10    13-AUG-73  4:01:36	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;9     7-AUG-73  2:07:20	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;8     7-AUG-73  2:02:35	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;7    26-JUL-73 15:44:56	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;6    25-JUL-73 23:56:17	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;5    25-JUL-73 17:16:53	EDIT BY KREMERS
;<SRIMON131>DSKPAK.MAC;3	13 JULY 73 15:00:00	EDIT BY KREMERS
;TENEX DRIVER FOR DISK PACKS.  D. MURPHY

;GENERAL CODE FOR DISK PACK DEVICES; DEVICE DEPENDENT CODE FOR
;DEC RP10/RP02 AND TELEFILE DC10 INCLUDED UNDER ASSEMBLY SWITCH

	INTERN RLMX0,DSKRMA
	INTERN	DRIVTB		;***SRI-AIC***
	INTERN NDSKPR
	INTERN DSKIO,DSKCHK,UDSKIO,CVDSK,CDSKVA,DIDSCI
	EXTERN BLOCK1,DSKTIM,DISKP,FPTA,JFNOFN,NXTDMP
	INTERN GTDF10,RLDF10	;***SRI-AIC***
	EXTERN DRMBND,BUGTYO		;***SRI-AIC***
	EXTERN DISL,DISLE,DISG,BUGMSG,DSKRD,DSKWR	;***SRI-AIC***
	EXTERN SETMPG,SETPT,DBUGSW,PSKED,DIDSCA,DEVMPE
	EXTERN DISGET,SCHEDP,EDISMS

;THE FOLLOWING ARE ALL OF THE DEVICE AND INSTALLATION DEPENDENT
;PARAMETERS

IFDEF RP02F,<		;RP02 DEVICE PARAMETERS
DSKCAT==5B20		;CLEAR ATTENTIONS

DSKCAL==7B20		;RECALIBRATE
DSKIRQ==1B32		;PI REQUEST IN CONI WORD
DSKNOP==6B20		;NOP
SEEK==4B20		;POSITION (SEEK)
READ==0B20		;READ PAGE
WRITE==1B20		;WRITE PAGE
DSK1==250		;CONTROLLER 1
DSK2==254		;CONTROLLER 2
DSK=5			;REGISTER WITH POINTER TO CONTROLLER 0 OR 1
DSKCP1==34		;CONTROLLER 0 INITIAL CHANNEL ADDRESS
DSKCP2==34		;CONTROLLER 1 INITIAL CHANNEL ADDRESS

NTKUN=^D203		;NUMBER OF TRACKS PER DRIVE (UNIT)
NCYLBT==8
NSECBT==5

NTRACK=NTKUN*NPACKS ;EACH DRIVE CONSIDERED A GROUP OF TRACKS

NWSEC==200		;RPO2'S HAVE 128 WORDS/SECTOR,
NSECS==^D10		; 10 SECTORS PER ROTATION,
NSURFS==^D20		; AND 20 SURFACES PER UNIT

	HOMCY1==1			; HOME CYLINDERS
	HOMCY2==1
	HOMSF1==5			; SURFACES
	HOMSF2==^D15
	HOMSC1==0			; AND SECTORS
	HOMSC2==0
	NSECPG==1000/NWSEC		;SECTORS PER PAGE
	NSECTK==NSURFS*NSECS		;NUMBER OF SECTORS PER TRACK
	NPGTK==NSECTK*NWSEC/1000	;NUMBER OF PAGES PER TRACK
	NBWTK==<NPGTK+^D35>/^D36	;NUMBER OF WORDS OF BITS PER TRACK
NMINFP==NPGTK/3			;MIN PAGES FOR FREE CHOICE ASSMT
DSKNST==<<<<NDST+NPGTK-1>/NPGTK>+NPACKS-1>/NPACKS>*NPACKS
					;NUMBER OF TRACKS FOR SWAPPING
					;ROUNDED UP TO NEAREST TRACK
					;AND THEN UP TO NEAREST INTEGRAL
					;MULTIPLE OF NPACKS SO THAT WE GET
					;EQUAL NUMBER OF TRACKS PER PACK
					;AND TOTAL WILL HOLD AT LEAST
					;NDST PAGES
IFGE <MAXCOR-^D512>,<
NCRTRK==<MAXCOR+NPGTK-1>/NPGTK		;RESERVE SPACE FOR CORE DUMP
>

IFL <MAXCOR-^D512>,<
NCRTRK==<^D512+NPGTK-1>/NPGTK
>
MONTKS==<PPRMPG+200+NPGTK-1>/NPGTK	;NO. TRACKS FOR MON IMAGES


SWPTK==NTKUN/2-<DSKNST/NPACKS>/2	;FIRST TRACK FOR SWAPPING PER PACK
SWPTKH==SWPTK+<DSKNST/NPACKS>	;LAST TRACK +1 FOR SWAPPING PER PACK

;TABLE OF ADDRESSES OF START OF SWAP AREA ON EACH PACK
SWPADR:

QQ==SWPTK*NSECTK
	REPEAT NPACKS,<
	QQ
QQ==QQ+<NSECTK*NTKUN>
>

SWPSEC==<DSKNST*NSECTK>/NPACKS		;NO. SECTORS PER PACK FOR SWAPPING

;THE FOLLOWING PARAMETERS RESERVE THE VARIOUS AREAS OF THE DISK(S)

HITRK=NTRACK-MONTKS-NCRTRK		;UPPER LIMIT OF FILES AREA
LOTRK==0				;LOWER LIMIT OF FILES AREA

DSKRMA==<NTRACK-MONTKS-NCRTRK>*NSECTK	;RESIDENT MON IMAGE FOR RELOADING
DSKSMA==DSKRMA+PPRMPG*NSECPG		;SWAP MON IMAGE
DSKCMA==<NTRACK-NCRTRK>*NSECTK		;LOC OF CORE DUMP AREA
>			;END OF RP02 PARAMETERS
	XLIST		;SUPPRESS LISTING OF DC10 CODE ***SRI-AIC***
IFDEF DC10F,<		;TELEFILE DC10 PARAMETERS

DSK=700
DSKCP=34		;INITIAL CHANNEL ADDRESS		***SRI-AIC***

IFNDEF CD215F,<
NTKUN==^D203
NWSEC==100
NSECS==^D18
NCYLBT==8
NSECBT==5
>

IFDEF	CD215F,<
NTKUN==^D406
NWSEC==200
NSECS==^D9
NCYLBT==9
NSECBT==4
>

NSURFS==^D20

	HOMCY1==1		; HOME CYLINDERS
	HOMCY2==1
	HOMSF1==5		; AND SURFACES
	HOMSF2==15
	HOMSC1==0		; AND SECTORS
	HOMSC2==0
	ADRPOS==^D14+NSECBT
	NTRACK=NTKUN*NPACKS
	NSECPG==1000/NWSEC		;SECTORS PER PAGE
	NSECTK==NSURFS*NSECS		;NUMBER OF SECTORS PER TRACK
	NPGTK==NSECTK*NWSEC/1000	;NUMBER OF PAGES PER TRACK
	NBWTK==<NPGTK+^D35>/^D36	;NUMBER OF WORDS OF BITS PER TRACK
	NMINFP==NPGTK/3			;MIN PAGES FOR FREE CHOICE ASSMT
	DSKNST==NDST/NPGTK		;NUMBER OF TRACKS FOR SWAPPING

HITRK=NTRACK-5
LOTRK=0

DSKSWA==<NTRACK>*NSECTK		;SWAPPING AREA AFTER 'LAST' PACK
DSKCMA==DSKSWA+<DSKNST*NSECPG>	;LOC OF CORE DUMP AREA

DSKRMA==<HITRK>*NSECTK		;RESIDENT MON IMAGE
DSKSMA==DSKRMA+PPRMPG*NSECPG	;SWAP MON IMAGE
>			;END OF DC10 PARAMETERS

	LIST		;CONTINUE LISTING
	XLIST		;SUPPRESS SSA10 CODE *** SRI-AIC***
IFDEF SSADF,<
;PARAMETERS FOR 3330 STYLE DISKS, ON IBM STYLE CONTROLLER, ON SSA.

;FOLLOWING FOR CD230'S (=3330'S)
NTKUN==^D406		; PLUS A FEW FOR ALTERNATES NOT COUNTED HERE.
NWSEC==1000		; WORDS ON DATA AREA OF A SECTOR
NSECS==5		; SECTORS AROUND THE PACK
NCYLBT==9		; BITS IN CYLINDER FIELD
NSECBT==4		; ONLY 3 NEEDED, BUT KEEP SAME AS CD215'S
NSURFS==^D19		; NUMBER OF HEADS (SURFACES) ON THE PACK

HOMCY1==1		; HOME CYLINDERS SAME AS CD215'S
HOMCY2==1
HOMSF1==5		; ALSO SECTORS AND SURFACES ARE SAME
HOMSF2==^D15
HOMSC1==0
HOMSC2==0

NTRACK==NTKUN*NPACKS	; CYLINDERS ON ALL PACKS
NSECPG==1000/NWSEC	; SECTORS TO MAKE UP A PAGE (ONE ON 3330'S)
NSECTK==NSURFS*NSECS	; SECTORS WITHOUT MOVING HEADS, ON ONE DRIVE.
NPGTK==NSECTK*NWSEC/1000; PAGES WITHOUT MOVING HEADS, ON ONE DRIVE
NBWTK==<NPGTK+^D35>/^D36; WORDS OF BITS TO DESCRIBE A TRACK IN BIT TABLE
NMINFP==NPGTK/3		; MIN FREE PGS FOR FREE CHOICE ASSIGNMENT
DSKNST==NDST/NPGTK	; NUMBER OF TRACKS FOR SWAPPING AREA
NCRTRK==3		; TRACKS NEEDED TO HOLD CORE IMAGE ON CRASH.

HITRK==NTRACK-DSKNST-NCRTRK-6	;UPPER LIMIT OF FILES AREA
LOTRK==0			;LOWER LIMIT OF FILES AREA
DSKSWA==HITRK*NSECTK	; LINEAR ADDRESS OF SWAPPING AREA
DSKRMA==<NTRACK-NCRTRK-6>*NSECTK; LINEAR ADDRESS OF RESIDENT MON IMAGE
DSKSMA==DSKRMA+PPRMPG*NSECPG	; LINEAR ADDRESS OF SWAPPABLE MON IMAGE
DSKCMA==<NTRACK-NCRTRK>*NSECTK	; LINEAR ADDRESS OF CRASHED MON IMAGE

EXTERN SSABAS		; WHERE SSA GETS INITIAL COMMAND POINTER
IFNDEF SSAWCP,<SSAWCP==^D11>
IFNDEF SA10BF,<SA10BF==1>
>; END OF IFDEF SSADF
	LIST 		;CONTINUE LISTING

;COMMON PARAMETERS AND STORAGE

NGSP DSKFCT,<<NTRACK+<NTRACK*NBWTK>+777>/1000>	;PAGE ALIGNED
			;SPACE FOR BIT TABLE. FIRST NTRACK WORDS
			;ARE COUNTS OF NUMBER OF FREE PAGES PER TRACK
DSKBTB=:DSKFCT+NTRACK	;BIT TABLE

LS DSKBLK,1		;BIT TABLE LOCK
LS DBTJFN,1		;JFN OF BIT TABLE FILE

;DISC ADDRESS OF INDEX FILE
DIDSC0==<SWPTK-1>*NSECTK	;PUT NEXT TO SWAP AREA ON FIRST PACK
IF2,<IFL DIDSC0,<
	PRINTX DIDSC0 NEGATIVE, REDUCE SIZE OF PSEUDO-DRUM
>>

DIDSCI:	DIDSC0+DSKABT
GS DIDSCA,1

NDVMAX==20		;MAX NUMBER OF DRIVES

NDSKCM==10		;SIZE OF UDSKIO COMMAND BUFFER
NDSKPD==10		;SIZE OF INTERRUPT PDL
NPD1==20		;SIZE OF LOCAL (MAIN) PDL

;STATUS OF DRIVE IS RECORDED IN DSKSTS
;SIGN BIT IS DWRBIT, ON FOR WRITE, OFF FOR READ.
DSKSIP==(1B1)		;SEEK IN PROGRESS, LH OF DSKSTS
DSKCMR==(1B2)		;COMMAND READY, LH OF DSKSTS
DSKUIO==(1B3)		;UDSKIO TYPE OPERATION, LH OF DSKSTS
DSKRCB==(1B4)		;RECALIBRATE IN PROGRESS
DSKSNB==(1B5)		;ON SSA, SENSE BEING DONE.
DSKBSB==(1B6)		;ON SSA, DEVICE BUSY HAS BEEN REPORTED

; BITS 18 - 23 ARE ERROR COUNTER
; BITS 24 - 32 ARE CYLINDER AT WHICH DRIVE IS POSITIONED OR SEEKING
;LH BITS 13-17 ARE AN INDEX INTO THE UDSKIO COMMAND BUFFER
;DSKUIO BIT ON INDICATES UDSKIO TYPE OPERATION
; DSKRCB BIT ON INDICATES RECALIBRATE OPERATION IN PROGRESS
;STATE OF DRIVE IS INDICATED BY DSKSIP AND DSKCMR BITS IN LH
; 00 - NOTHING HAPPENING
; 10 - DRIVE SEEKING TRACK
; 01 - DRIVE POSITIONED, TRANSFER READY TO BE STARTED
; 11 - TRANSFER IN PROGRESS (ALSO USED WHEN REQUEST BEING UNQUEUED)

;STORAGE

LS DSKFCL,1		;FREE LIST FOR UDSKIO REQUEST PAIRS
LS DSKCCT,1		;COUNT OF UDSKIO REQUESTS
LS DSKCL,2*NDSKCM	;COMMAND BUFFER FOR UDSKIO REQUESTS
LS DSKLUN,2		;LAST UNIT XFERRING, -1 IF NO UNIT XFERRING
LS DF10LK,1		;LOCK ON DF10. (BOTH DSK AND TV USE IT)	***SRI-AIC***
LS DSKCC1,2		;BUFFERS FOR DF10 CHANNEL WORDS
LS DSKCC2,2

LS DSKQ,NDVMAX		;QUEUE FOR ALL SWAP IO REQUESTS

LS DSKUI,NDVMAX		;UTILITY QUEUE IN
LS DSKUO,NDVMAX		;UTILITY QUEUE OUT

LS DSKDAW,NDVMAX	;DISK ADDRESS FOR CURRENT OPERATION
LS DSKCAW,NDVMAX	;CORE ADDRESS AND COUNT FOR CURRENT OPERATION
LS DSKSTS,NDVMAX	;STATUS OF DRIVE,,CURRENT TRACK
			; SEE BIT DEFINITIONS IN LH, ABOVE.
LS DSKLSV,NDVMAX	;TIME WHEN CURRENT OPERATION IS OVERDUE

LS DSKPD1,NPD1+1	;LOCAL MAIN PDL

LS DSKSVR,1		;INTERRUPT SERVICE RETURN
LS DSKACP,1		;SAVED AC-P
LS DSKPDL,NDSKPD	;INTERRUPT PDL

;DO NOT REORDER ERROR WORDS, USED BY GETAB

NDSKEW==^D10		;NUMBER OF ERROR WORDS FOR GETAB

LS DSKRCE,1		;COUNT OF RECOVERABLE ERRORS
LS DSKRER,4		;COMMAND WORDS AND ERROR BITS OF LAST ERROR
LS DSKNRE,1		;COUNT OF NON-RECOVERABLE ERRORS
LS DSKLER,4		;COMMAND WORDS AND ERROR BITS LAST NON-REC ERR
IFDEF SSADF,<
NDSKEW==NDSKEW+5
LS DSKESB,5>		;MORE ERROR WORDS FOR SENSE BYTES
;END OF GETTAB

DSKNTR==^D5		;NUMBER OF TRIES ON RECOVERABLE ERRORS

UCMIPT:	POINT 5,DSKSTS(A),17	; POINTER TO UDSKIO COMMAND INDEX
ERRCPT:	POINT 6,DSKSTS(A),23	;POINTER TO ERROR RETRY COUNT
CTRKPT:	POINT 9,DSKSTS(A),32	; CURRENT TRACK
	XLIST		;SUPPRESS LISTING OF SSA10 CODE  ***SRI-AIC***
IFDEF SSADF,<			; FOLLOWING ONLY FOR DISKS ON SSA
; STORAGE FOR CHANNEL PROGRAMS AND STATUS

DEFINE DSKSTM(N)<
LS DP'N'SEN,6		; SENSE BYTES FROM DRIVE N
LS DP'N'SEK,3		; SEEK ARGUMENT FOR DRIVE N
>
ZZ==0
REPEAT NDVMAX,<
DSKSTM(\ZZ)
ZZ==ZZ+1>		; ALLOCATE SENSE AND SEEK AREAS FOR ALL DRIVES

LS DPDEVL,NDVMAX+1	; BLOCK MULTIPLEXOR DEVICE LIST
LS DPCHS,NDVMAX		; CHANNEL STATUS (161) AT LAST INTERRUPT
LS DPCPC,NDVMAX		; WORD COUNT AND CHANNEL PC AT LAST INTERRUPT
LS DPADR,NDVMAX		; CCW RESTART,,CORE ADDRESS OF PAGE
LS DSKCDC,NDVMAX	; COUNT OF CORRECTABLE DATA CHECKS PER DRIVE

;POINTERS AND CHANNEL PROGRAMS, PRE-COMPILED.

DEFINE PNTM2(SIZ,ADR,POS,N)<
	POINT SIZ,DP'N'ADR,POS>
DEFINE POINTM(SIZ,ADR,POS)<
ZZ==0
REPEAT NDVMAX,<	PNTM2(SIZ,ADR,POS,\ZZ)
ZZ==ZZ+1>
>
DPCYL:	POINTM(16,SEK,31)	; WHERE CYLINDER GOES IN SEEK ARG
DPSRF:	POINTM(16,SEK+1,15)	; WHERE SURFACE GOES IN SEEK ARG
DPREC:	POINTM(8,SEK+1,23)	; WHERE RECORD NUMBER GOES IN SEARCH ARG
DPSEC:	POINTM(8,SEK+2,7)	; WHERE ROT SECTOR GOES IN SET SECTOR
NBYTES==<NWSEC*^D36>/^D8	; BYTES IN A RECORD
DPKSEC:				; TABLE OF ARGS FOR SET SECTOR COMMAND
REPEAT NSECS,<
	EXP <200*<^D237+<NBYTES*<.-DPKSEC>>>/^D13440>
>

;NOW THE CHANNEL PROGRAMS THEMSELVES

DEFINE CHCMAC(N)<
;FIRST THE READ/WRITE COMMAND CHAIN

IFE SA10BF,<WCSZ==^D16
ADSZ==^D20>
IFN SA10BF,<WCSZ==^D12
ADSZ==^D24>
DP'N'RWC:	BYTE(8)70,IC.SEK,I.DDEV+N,0	;SEEK CYLINDER
	BYTE (WCSZ)-6(ADSZ)DP'N'SEK		; ARG TO SEEK
	BYTE (8)70,IC.SSC,I.DDEV+N,0	; SET SECTOR
	BYTE (WCSZ)-1(ADSZ)DP'N'SEK+2	; SECTOR NUMBER
	BYTE (8)71,IC.SIE,I.DDEV+N,0	; SEARCH ID EQUAL
	BYTE (WCSZ)-5(ADSZ)DP'N'SEK		; ARG TO SEARCH RECORD
	TCH+.-2				; KEEP ON SEARCHIN'
DPOOPC==.-DP'N'RWC			; OFFSET TO RD OR WRT COMMAND
	BYTE (8)40,IC.RDD,I.DDEV+N,0	; READ DATA, OR WRITE DATA
					; THIS CELL MODIFIED AT RUNTIME
DPOADR==.-DP'N'RWC			; OFFSET TO DATA ADDRESS
	BYTE (WCSZ)-1000(ADSZ).-.		; ADDRESS WORD MODIFIED
	0				; END OF COMMAND LIST

DPOSNP==.-DP'N'RWC			; OFFSET TO SENSE PROGRAM
DP'N'SNP:	BYTE (8)70,IC.SNS,I.DDEV+N,0	; SENSE COMMAND
	BYTE (WCSZ)-^D24(ADSZ)DP'N'SEN	; WHERE TO STORE SENSE BYTES
	0				; END OF SENSE PROGRAM
>

ZZ==0					; NOW BUILD ALL THOSE
REPEAT NDVMAX,<
	CHCMAC(\ZZ)
ZZ==ZZ+1>

DPBAS:					; POINTER TO THOSE PROGRAMS
DEFINE DPBASM(N)<
	XWD DP'N'SNP,DP'N'RWC>
ZZ==0
REPEAT NDVMAX,<
	DPBASM(\ZZ)
	ZZ==ZZ+1
>

> ;END OF SSADF CONDITIONAL
	LIST		;CONTINUE LISTING ***SRI-AIC***

;THE FOLLOWING IS A PROTOTYPE GETAB TABLE

DSKPRO:	LOTRK
	HITRK
	NSECTK
	NWSEC
	NTKUN
	NPACKS
	SWPTK
	SWPTKH
DSKRML:	DSKRMA
DSKSML:	DSKSMA
DSKCML:	DSKCMA
	NHOME
QQ==0
HOMPRO:	REPEAT NPACKS,<
	<QQ>B17+<HOMCY1>B<^D17+NCYLBT>+<HOMSF1>B<^D17+NCYLBT+5>+HOMSC1
	<QQ>B17+<HOMCY2>B<^D17+NCYLBT>+<HOMSF2>B<^D17+NCYLBT+5>+HOMSC2
QQ==QQ+1
>
NHOME==.-HOMPRO

NDSKPR==.-DSKPRO

; THE FOLLOWING IS A GETAB TABLE COMPILED BY DSKINI AT START-UP

LS(DSKPAR,NDSKPR-NHOME)
LS(HOME,NHOME)	; MUST BE CONTIGUOUS WITH DSKPAR

;DEVICE DEPENDENT CONSTANTS AND ROUTINES
;SOME ARE CALLED WITH PUSHJ, OTHERS ARE SINGLE INSTRUCTIONS EXECUTED
;WITH XCT

IFDEF RP02F,<		;DEC RP02 DRIVES

DSOIRQ:	XCT	DSKS2(DSK)		;CONSO DSK INTERRUPT REQUEST

DSKPWF:	XCT	DSKC1(DSK)	;CONO IN CASE OF POWER FAIL
	JRST DSKSV1

DSZERR:	CONSZ DSK1,177760-2000	;CONSZ ERROR CONDITIONS - CONTROLLER 0
	CONSZ DSK2,177760-2000	;CONTROLLER 1

DCLERR:	XCT	DSKERX(DSK) ;CONO CLEAR ALL ERROR CONDITIONS

DCLDNF:	XCT	DSKC3(DSK)	;CONO CLEAR DONE FLOP

DRATT:	DATAI DSK1,0		;READ ATTENTIONS TO AC0, B28-35 ,CONTROLLER 0
	DATAI DSK2,0		;CONTROLLER 1

DSKPOS:	MOVE B,DSKDAW(A)	;ISSUE POSITION (SEEK) REQUEST
	TLZ	B,(1B2)		;CLEAR CONTROLLER BIT
	TLO B,(4B2)		;UNIT NUMBER IN AC1, DSK ADR IN DSKDAW(A)
	XCT DSKO(DSK)
	RET

DSKRCL:	MOVSI B,DSKCAL		;ISSUE RECALIBRATE (RESTORE) COMMAND
	DPB A,[POINT 3,B,5]
	XCT	DSKO(DSK)
	RET

DCLATT:	CALL DCLAT1		;INST. TO CLEAR ATTENTIONS FOR DRIVE IN A

DCLAT1:	MOVE	B,DSKDAW(A)
	TLZ	B,(1B2)		;CLEAR CONTROLLER BIT
	XCT	IORATN(DSK)		;GET ATTENTION BIT TO CLEAR
	TLO	2,DSKCAT
	XCT	DSKO(DSK)
	RET

DCKSEK:	XCT	DSKI3(DSK)		;CALLED TO CHECK SEEK COMPLETE
	TLNN C,(1B11)		;SKIP IF NO SEEK INCOMPLETE
	AOS 0(P)
	RET

DSZPCI:	TLNE 0,(1B14+1B16)	;SKIP NO PCI (GIVEN CONI BITS IN 0)

DSZSCF:	TRNE 0,1B21		;SKIP NO SEARCH FAILURE

DSZATN:	TDNE 0,BITS+^D27(1)	;SKIP IF ZERO ATTENTION
	TDNE	0,BITS+^D27-10(1)	;OFFSET FOR SECOND CONTROLLER
DUEATT:	RET			;UNEXPECTED ATTENTION (NOP FOR RP02)

;TEST EXISTENCE OF UNIT AND INIT

DIUNIT:	MOVEI B,0(A)		;UNIT NUMBER
	ROT B,-6		;CONSTRUCT NOP COMMAND
	TLO B,(6B2)
	XCT	DSKO(DSK)	;ISSUE IT, SELECT UNIT
	JFCL
	XCT	DSKI3(DSK)		;GET BITS FOR THAT UNIT
	TLNN C,(1B15)		;NO SUCH UNIT? OR
	TLNN C,(1B13)		;NOT ON LINE?
	JRST [	SETOM DSKSTS(A)	;YES, PREVENT USE OF DRIVE
		RET]
	MOVEI B,0(A)
	ROT B,-6		;CONSTRUCT RECALIBRATE COMMAND
	TLO B,(7B2)
	XCT	DSKO(DSK)	;ISSUE SEEK
	CALL	READY		;WAIT FOR RECAL TO FINISH
	RET			;ERROR OR NOT ONLINE
	CALL	DCLAT1		;ISSUE CLEAR ATTENTION
	AOS	0(P)
	RET
READY:	XCT DSKI3(DSK)		;CHECK STATUS OF DRIVE
	TLNN	C,(1B11)	;ERROR?
	TLNN	C,(1B13)	;NOT ONLINE?
	RET			;YES
	TLNN C,(1B12)		;AND 'ON CYLINDER'
	JRST READY		;NO, WAIT
	AOS	0(P)
	RET

DMKHWA:	LSH B,^D12		;CONVERT LOGICAL H'WARE ADR TO ACTUAL

DSKCYL:	POINT 8,DSKDAW(A),13	;POINTER TO CYLINDER ADDRESS

; TABLES FOR CONO'S, CONI'S, DATAO'S AND DATAI'S
DSKO:
	DATAO DSK1,2
	DATAO DSK2,2
DSKCN0:
	CONI	DSK1,0
	CONI	DSK2,0
DSKCNI:
	CONI DSK1,2
	CONI DSK2,2
DSKO0:
	DATAO DSK1,0
	DATAO DSK2,0
DSKI0:
	DATAI DSK1,0
	DATAI DSK2,0
DSKO1:
	DATAO	DSK1,1
	DATAO	DSK2,1
DSKI3:
	DATAI DSK1,3
	DATAI DSK2,3
DSKC1:
	CONO DSK1,175700+1B32
	CONO DSK2,175700+1B32
DSKC2:
	CONSZ DSK1,777760-202000
	CONSZ DSK2,777760-202000
DSKC3:
	CONO DSK1,1B32+DSKCHN
	CONO DSK2,1B32+DSKCHN
DSKC4:
	CONO	DSK1,0
	CONO	DSK2,0
;			CHECK BUSY BIT
DSKS1:
	CONSO	DSK1,1B31
	CONSO	DSK2,1B31
;			CHECK INTERRUPT BIT
DSKS2:
	CONSO	DSK1,1B32
	CONSO	DSK2,1B32
DSKCCM:
	MOVEM 2,DSKCC1
	MOVEM 2,DSKCC2
DSKCP:
	DSKCP1
	DSKCP2
DSKERX:
	CONO DSK1,175700+1B32+DSKCHN
	CONO DSK2,175700+1B32+DSKCHN
IORATN:	IOR	B,BITS+^D27(1)
	IOR	B,BITS+^D27-10(1)
DSKTB1:
	XWD 0,10
	XWD 0,20
DSKTB2:
	XWD 0,0
	XWD 0,10
>	;END OF RP02 SECTION
	XLIST		;SUPPRESS LISTING OF DC10 CODE ***SRI-AIC***
IFDEF DC10F,<			;TELEFILE DC10 CONSTANTS AND ROUTINES

DSOIRQ:	JSP A,.+1		;CONSO DSK REQUESTING
	CONSZ DSK,640777	;ERRORS, DONE, OR ATTENTIONS?
	CONSZ DSK,1B20		;AND NOT BUSY?
	JRST 0(A)		;NO
	JRST 1(A)		;YES

DSKPWF:	CONO DSK,0		;POWER FAIL - CLEAR PI
	JRST DSKSV1

DSZERR:	TDNE 0,[XWD 73700,440000] ;TEST ERRORS, IGNORE EOC

DCLERR:	CALL DCLER1		;DO NOP, CLEARS ALL ERROR FLOPS

DCLER1:	JSP B,DWTCTL		;WAIT FOR CONTROL NOT BUSY
	MOVEI B,1(A)		;DEVICE ADDRESS IS 1+LOGICAL UNIT
	LSH B,^D9		;SHIFT TO POSITION FOR DATAO
;	IORI B,0B22		;NOP COMMAND
	DATAO DSK,B
	RET

DCLDNF:	CALL [	JSP B,DWTCTL	;CLEAR DONE FLAG
		DATAO DSK,ZERO## ;ANY DATAO DOES IT
		RET]

DRATT:	CONI DSK,0		;READ ATTENTIONS INTO 0

DSKPOS:	JSP B,DWTCTL		;WAIT FOR CONTROLLER
	MOVE B,DSKDAW(A)	;DSK AND CYLINDER
	IORI B,3B22		;SEEK COMMAND
	DATAO DSK,B
	RET

DSKRCL:	JSP B,DWTCTL		;WAIT FOR CONTROL
	MOVEI B,1(A)		;DEVICE ADDRESS
	LSH B,^D9		;SHIFT FOR DATAO
	IORI B,2B22		;RECALIBRATE (RESET) COMMAND
	DATAO DSK,B
	RET

DCLATT:	CALL DCLER1		;CLEAR ATTENTIONS AND SELECT DRIVE

DCKSEK:	CONI DSK,0		;GET SELECTED DRIVE STATUS
	TLNN 0,(1B13)		;CHECK SEEK INCOMPLETE
	AOS 0(P)
	RET

DSZPCI:	TLNE 0,(1B0+1B1)	;CHECK PCI

DSZSCF:	TLNE 0,(1B7+1B8+1B9)	;CHECK SEARCH FAILURE

DSZATN:	CALL [	MOVEI B,1	;SKIP IF ZERO ATTENTION
		LSH B,0(A)	;COMPUTE BIT FOR DRIVE
		TDNN 0,B
		AOS 0(P)
		RET]

DUEATT:	RET			;UNEXPECTED ATTN (E.G. POWER ON)

DMKHWA:	MOVEI B,0(B)		;CYL, SURF, AND SEC
	LSH B,^D35-ADRPOS	;SHIFT FOR DATAO
	DPB A,[POINT 4,B,26]	;DRIVE NUMBER
	ADDI B,1B26		;PLUS 1 FOR DRIVE ADDRESS
	RET

;WAIT FOR CONTROL NOT BUSY

DWTCTL:	
	CONSO DSK,1B20		;CTL BUSY
	JRST 0(B)
	AOS NCTBSY		;COUNT CURRANCES
	JRST DWTCTL

LS NCTBSY,1

DSKCYL:	POINT NCYLBT,DSKDAW(A),9	;POINTER TO CYL IN H'WARE ADDRESS

DSKWDA:	6B22+DSKCP		;WRITE DATA COMMAND
DSKRDI==4B22+DSKCP		;READ DATA COMMAND BITS		***SRI-AIC***
DSKRDA:	DSKRDI			;READ DATA COMMAND		***SRI-AIC***

;TEST UNIT FOR READY AND INIT

DIUNIT:	MOVEI C,1(A)		;UNIT ADDRESS
	LSH C,^D9
	CONO DSK,DSKCHN(C)	;SELECT IT
	CONI DSK,C		;GET DEVICE STATUS
	TLNE C,(1B12+1B15)	;OFF LINE OR WRITE INHIBIT?
	JRST [	SETOM DSKSTS(A)	;YES, SET STATE TO OFFLINE
		RET]
	CALL DSKRCL		;ISSUE RECAL
	MOVEI B,1		;COMPUTE BIT FOR DRIVE
	LSH B,0(A)
	CONSO DSK,0(B)		;WAIT FOR ATTN
	JRST .-1
	CONI DSK,C
	TLNE C,(1B13)		;SEEK INCOMPLETE?
	BUG(HLT,<DSKINI - SEEK INCOMPLETE ON RECAL>)
	MOVEI C,1(A)
	LSH C,^D9
	IOR C,DSKRDA		;CONSTRUCT READ
	DATAO DSK,C		;DO 1-WORD READ TO CLEAR ATTN
	CONSZ DSK,1B20		;WAIT FOR DONE
	JRST .-1
	CONSZ DSK,0(B)		;ATTN NOW GONE?
	BUG(HLT,<DSKINI - XFER FAILED TO CLEAR ATTN>)
	SETZM DSKSTS(A)		;SET STATUS TO READY
	RET
>			;END DC10 SECTION
	LIST		;CONTINUE LISTING
	XLIST		;SUPPRESS LISTING OF SSA10 CODE ***SRI-AIC***
IFDEF SSADF,<			; SSA AND 3330 CONSTANTS AND ROUTINES

; MAKE HARDWARE ADDRESS FROM PACKED HARDWARE ADDRESS.
; CALLED WITH 1/ DRIVE NUMBER IN RH, 2/ CYL.SURF.SECT IN RH, PACKED.

DMKHWA:	LDB C,[POINT NCYLBT,B,^D17+NCYLBT]	; GET CYLINDER
	DPB C,DPCYL(A)		; STORE IN SEEK ARGUMENT AREA
	LDB C,[POINT 5,B,^D35-NSECBT]	; HEAD (SURFACE) NUMBER
	DPB C,DPSRF(A)		; TO SEEK AND SEARCH ARG AREA
	LDB C,[POINT NSECBT,B,35]	; RECORD NUMBER
	ADDI C,1		; RECORDS ARE 1,2,3 NOT 0,1,2
	DPB C,DPREC(A)		; TO SEARCH ARGUMENT
	MOVE C,DPKSEC-1(C)	; GET ARG FOR SET SECTOR COMMAND
	DPB C,DPSEC(A)		; STORE.
	RET			; RETURN. 2 STILL AS CALLED, FOR DSKDAW

DSKPWF::CONO SSA,SA.PIE+<SSADC>B32+SSACHN	; NO MORE DISK INT'S
	RET

DSKCYL:	POINT 9,DSKDAW(A),26	; POINTER TO CURRENT CYLINDER

DIUNIT:	RET			; NOT DONE YET

> ; END OF SSA/3330 ROUTINES
	LIST 		;CONTINUE LISTING  ***SRI-AIC***

;DISK I/O DRIVER - CALLED FROM SWAPPER

DSKIO:	SKIPG DISKP
	JRST DRMIO		;NO DISK, USE DRUM
	MOVEM P,DSKPD1		;SETUP LOCAL STACK
	MOVE P,[XWD -NPD1,DSKPD1]
	PUSH P,1
	MOVE D,CST1(A)		;GET DISK ADDRESS
	TLNN D,10		;REGULAR DISK ADDRESS?
	JRST [	PUSH P,1	;NO, MUST BE SWAPPING ADDRESS
		MOVE A,4
		CALL DSKIS	;CONVERT TO REGULAR DISK ADDRESS
		MOVE D,1
		POP P,1
		JRST DSKI7]
DSKI7:	PUSH P,1
	MOVE A,4		;DISK ADDRESS
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	POP P,4
	LDB C,[POINT NCYLBT,A,17+NCYLBT]	;GET TRACK NUMBER
	TLO D,0(C)		;PUT IN LH OF LIST WORD
	HLRZ A,1		;GET DRIVE NUMBER FOR INDEX
	PIOFF			;MUST NOT INTERRUPT QUEUEING
	MOVEI C,CST3(D)		;ADD TO SWAP QUEUE
	EXCH C,DSKQ(A)
	HRRI D,0(C)
	MOVEM D,@DSKQ(A)
	PION
	SETO C,
	CAMN C,DSKSTS(1)	;DRIVE INITIALIZED ?
	BUG(CHK,<DSKIO REQUESTED ON UNAVAILABLE DRIVE>)
	HRRZ	DSK,DRIVTB(A)	;GET DRIVE AND CONTROLLER
	LSH	DSK,-3		;ISOLATE CONTROLLER
IFNDEF SSADF,<			;CONTROLLER MUST BE FREE UNLESS BLOCK
				; MULTIPLEXER CHANNEL IN USE
	SKIPGE	DSKLUN(DSK)>	;TRANSFER NOW IN PROGRESS?
	CALL	DSKRC		;NO, GO START THIS OPERATION
DSKIR:	POP P,1
	MOVE P,DSKPD1		;RESTORE CALLERS STACK
	RET
;IF SWAPPING TO DISK, DISK ADDRESS DISGUISED AS DRUM ADDRESS

DSKIS:	HRRZS B,1		;LINEARIZE 'DRUM' ADDRESS
	ANDI B,77		;SECTOR
	LSH A,-6		; "Band" = surface*NSWPTK+arm-SWPTRK
	IMULI	A,DRMSEC
	ADD	A,2
	IMULI A,SWPSEC/NSECPG		;MAP CONSECUTIVE PAGES TO DIFFERENT PACKS
	IDIVI A,DSKNST*NSECTK/NSECPG
	ADD A,B
	IDIVI A,SWPSEC/NSECPG		;DIVIDE BY SECTORS OF SWAP SPACE PER PACK
				;GIVES AC1=UNIT, AC2=SECTOR NUMBER ON UNIT
	IMULI	B,NSECPG		;CONVERT PAGE ADDRESS TO SECTOR
	ADD B,SWPADR(A)		;GET ABSOLUTE LINEAR ADDRESS
	MOVE A,B

;MAKE SURE THAT COMPUTED SWAP ADDRESS IS NOT WITHIN THE FILES AREA
	IDIVI B,NSECTK		;CONVERT BACKTO LINEAR TRACK
	IDIVI B,NTKUN		;PACK-RELATIVE TRACK TO AC3
	CAIL C,SWPTK
	CAIL C,SWPTKH
	 BUG (HLT,<SWAP ADDRESS IN FILES AREA>)
	RET

;PERIODIC CHECK OF DISK

DSKCHK:	MOVEI A,^D1000		;DO IT ONCE PER SEC.
	MOVEM A,DSKTIM
	MOVSI A,-NDVMAX
DSKCH3:	SKIPE B,DSKLSV(A)	;TIME SETUP ON THIS DRIVE?
	CAMLE B,TODCLK		;AND PAST DUE?
	JRST DSKCH1		;NO
	SETO B,
	CAME B,DSKSTS(A)	;DRIVE UNINITIALIZED?
	JRST DSKCH4		;NO
;	CALL DIUNIT		;YES, TRY TO INIT IT
	MOVE B,TODCLK
	ADDI B,^D10000
	SKIPL DSKSTS(A)		;WAS INIT SUCCESSFUL?
	SETZ B,			;YES, NO FURTHER CHECK
	MOVEM B,DSKLSV(A)	;OTHERWISE CHECK AGAIN IN 10SEC.
	JRST DSKCH1

DSKCH4:	BUG(CHK,<DISK OPERATION OVERDUE>)
	MOVSI B,DSKUIO		;GIVE ERROR COMPLETION FOR REQUEST
	TDNE B,DSKSTS(A)	;IN PROGRESS
	JRST [	LDB C,UCMIPT	; UTILITY OP
		MOVEI B,-1	;RETURN -1 FOR NONSPECIFIC FAILURE
		MOVEM B,DSKCL+1(C)
		JRST DSKCH2]
	CHNOFF DSKCHN
	CALL DSKEP1		;PROCESS 'UNREC' ERROR
	CHNON DSKCHN
DSKCH2:	CALL DIUNIT
DSKCH1:	AOBJN A,DSKCH3
	RET

;UTILITY DISK I/O
; AC1/ HARDWARE DISK ADDRESS
; AC2/ BIT 13 - WRITE HEADER, BIT 14 - WRITE, BIT 15 - COMPARE CLASS
;      BITS 16-24 - CLASS, BITS 25-35 WORD COUNT
; AC3/ REAL CORE ADDRESS
;RETURNS +1 WITH ERROR BITS IN AC1 24-35 (0 IF NO ERRORS)

UDSKIO:
UDSK3:	SOSGE DSKCCT		;COMMAND BUFFER FULL?
	JRST UDSK1		;YES, GO WAIT FOR ROOM
	NOSKED
	MOVE D,@DSKFCL		;GET A COMMAND PAIR
	EXCH D,DSKFCL
	HRLZM A,0(D)		;STORE DISK ADDRESS LH OF FIRST WORD
	HRRZM C,1(D)		;CORE ADDRESS RH OF SECOND WORD
	HRLM B,1(D)		;WORD COUNT IN BITS 7-17
	MOVEI C,0(D)
	SUBI C,DSKCL		;INDEX FOR THIS PAIR
	TLNE B,(1B14)		;READ OR WRITE?
	TROA C,600000B46	;WRITE
	TRO C,400000B46		;READ, B0 ALWAYS SET
	DPB C,[POINT 7,1(D),6]	;TO BITS 0-6
	HLRZ A,1		;DRIVE NUMBER
	MOVE	DSK,1
	LSH	DSK,-3		;ISOLATE CONTROLLER BIT
	ANDI 1,17		;MASK OFF DRIVE AND CONTROLLER		***SRI-AIC***
	SETO C,
	CAMN C,DSKSTS(A)	;UNIT INITIALIZED?
	JRST [	MOVEI A,-1	;NO, RETURN FAILURE
		JRST UDSK4]
	PIOFF
	HRRM D,@DSKUI(A)	;APPEND TO UTILITY QUEUE
	HRRZM D,DSKUI(A)
	PION
	TLNE 2,(1B14)	;READING OR WRITING ?			***SRI-AIC***
	AOSA DSKWR	;WRITING, SAVE COUNT FOR STATISTICS	***SRI-AIC***
	AOS DSKRD	;DITTO READ				***SRI-AIC***
	PUSH P,4
IFNDEF SSADF,<			; WAIT UNLESS ON BLK MPXR CHAN
	SKIPGE DSKLUN(DSK)>		;STARTUP POSSIBLE?
	CALL DSKRC		;YES
	POP P,4
	OKSKED
	MOVEI A,DISGET		;SCHEDULER .GE. TEST
	HRLI A,1(D)		;WILL TEST SECOND WORD OF PAIR
	JSYS SCHEDP
	NOSKED
	MOVE A,1(D)		;ERROR BITS RETURNED HEREIN
UDSK4:	EXCH D,DSKFCL		;RETURN PAIR TO FREE LIST
	MOVEM D,@DSKFCL
	AOS DSKCCT
	OKSKED
	RET

UDSK1:	PUSH P,1
	AOS DSKCCT		;CORRECT COUNT
	MOVEI A,UDSK2
	JSYS EDISMS		;DISMISS TILL ROOM IN COMMAND LIST
	POP P,1
	JRST UDSK3

UDSK2:	SKIPG DSKCCT		;ROOM NOW?
	JRST 0(D)		;KEEP WAITING
	JRST 1(D)		;RUN

;ENTRY TO DSKRCK AT NON-INTERRUPT LEVEL
; CALLED WITH DRIVE NUMBER IN RH OF 1

DSKRC:	MOVSI C,DSKSIP+DSKCMR
	CHNOFF DSKCHN
IFNDEF SSADF,<
	SKIPGE	DSKLUN(DSK)>	;CONTROL BUSY, OR
	TDNE C,DSKSTS(A)	;THIS DRIVE NOW DOING SOMETHING?
	JRST [	CHNON DSKCHN	;YES, LEAVE IT
		RET]
	CALL DSKRCK		;NO, GO GET IT GOING
	CHNON DSKCHN
	RET

; HERE FROM DSKRCK IF UTILITY QUEUE HAS STUFF TO DO

DSKRC3:	HRRZ B,0(B)		;UNQUEUE
	JUMPN B,.+3
	MOVEI C,DSKUO(A)	;FIXUP ON END
	MOVEM C,DSKUI(A)
	EXCH B,DSKUO(A)
	MOVSI C,DWRBIT+DSKUIO
	ANDCAM C,DSKSTS(A)	;CLEAR BITS
	LDB C,[POINT 5,1(B),6]	;DSKCL INDEX
	DPB C,UCMIPT		 ;WHERE INTERRUPT ROUTINE CAN GET
	HLLZ C,1(B)		;WORD COUNT
	TLZ C,774000		;ISOLATE WORD COUNT (BITS 7-17)
	MOVNM C,DSKCAW(A)	;TO LH OF CHANNEL WORD
	MOVE D,1(B)		;CORE ADDRESS AND BITS
	HRRM D,DSKCAW(A)	;STORE CORE ADDRESS
	MOVSI C,DSKUIO		;SET UTILITY BIT IN ANY CASE
	TLNE D,200000		;AND IF WRITE,
	MOVSI C,DSKUIO+DWRBIT	;SET WRITE BIT TOO
	IORM C,DSKSTS(A)	;YES
	HLRZ B,0(B)		;DISK ADDRESS
	HRLI B,0(A)		;INCLUDE UNIT
	JRST DSKRC4

;ROUTINE TO REMOVE REQUESTS FOR READ AND WRITE QUEUES AND
;INITIATE SEEK OPERATIONS
;CALLED AT MAIN AND INTERRUPT LEVEL WITH DRIVE NUMBER IN 1
; ONLY IF CONTROL FREE, EXCEPT ON SSA/3330 WHERE JUST DRIVE MUST BE FREE

DSKRCK:	IORM C,DSKSTS(A)	;SET BITS TO INDICATE UNQUEUEING IN PROG
	SKIPE B,DSKUO(A)	;UTILITY QUEUE WAITING?
	JRST DSKRC3		;YES, IS FIRST PRIORITY
	SKIPN DSKQ(A)		;SWAP REQUESTS WAITING?
	JRST DSKRCC		;NO
;SWAP REQUESTS WAITING. APPLY ONE-WAY ELEVATOR ALGORITHM.
	MOVEI B,DSKQ(A)		;PTR TO QUEUE
	LDB C,CTRKPT		 ;CURRENT TRACK
	CALL TRKSCH		;FIND NEAREST .GE. TRACK
	JRST [	SETZ C,		;NONE .GE., SO RESET TO 0
		MOVEI B,DSKQ(A)	;AND TRY AGAIN
		CALL TRKSCH
		JRST DSKRCC	;NONE, ALL MUST HAVE BEEN FLUSHED
		JRST .+1]
DSKRC2:	SUBI B,CST3		;CONVERT BACK TO CORE PAGE NUMBER
	HLL B,CST3(B)		;GET WRITE AND CLASS INFO
	MOVSI C,DWRBIT+DSKUIO
	ANDCAM C,DSKSTS(A)	;CLEAR BITS
	MOVSI C,DWRBIT
	TLNE B,DWRBIT		;WRITE BIT ON?
	IORM C,DSKSTS(A)	;YES, PUT IT ON IN STATUS WORD
	MOVEI C,0(B)
	LSH C,^D9		;MAKE PAGE NUMBER INTO CORE ADDRESS
	HRLI C,-1000		;WITH ONE PAGE WORD COUNT
	MOVEM C,DSKCAW(A)	;LEAVE IT FOR TRANSFER STARTUP
	PUSH P,A
	MOVE A,CST1(B)		;DISK ADDRESS
	TLNN A,10		;REGULAR?
	CALL DSKIS		;NO, SWAPPING. CONVERT
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	MOVE B,A
	POP P,A
;FALL THRU

;FALLS THRU FROM ABOVE, ALSO FROM DSKRC3 (UDSKIO)

; AT THIS POINT, DRIVE NUMBER IS IN RH OF A, PACKED HARDWARE
;  ADDRESS IS IN RH OF 2.

DSKRC4:	XCT DMKHWA		;MAKE INTO HARDWARE FORMAT
	MOVEM B,DSKDAW(A)	;LEAVE FOR OTHER ROUTINES
	SETZ B,
	DPB B,ERRCPT		;CLEAR ERROR COUNT BEFORE SEEK
	LDB C,DSKCYL		;GET DESIRED CYLINDER
	LDB B,CTRKPT		 ;CYL DISK IS NOW AT
	DPB C,CTRKPT		;SET NEW CURRENT TRACK
IFNDEF SSADF,<			; FOR DRIVES NEEDING SEPARATE SEEK
				;  COMMANDS TO ATTAIN OVERLAPPING...
	CAMN B,3		;NOW AT DESIRED TRACK?
	JRST [	MOVSI 2,DSKSIP	;INDICATE NO SEEK IN PROGRESS    ***SRI-AIC***
		ANDCAM 2,DSKSTS(1)   		;***SRI-AIC***
		CONSO PI,1B<DSKCHN+^D20>	;ON PI LEVEL ?   ***SRI-AIC***
		JRST DFTCK	;NO, GO START TRANSFER   	***SRI-AIC***
		RET]
	MOVSI B,DSKCMR		;CLEAR READY BIT
	ANDCAM B,DSKSTS(A)
	PIOFF			;ELIMINATE RACE CONDITION WITH TV
	CALL	DSKPOS		;ISSUE SEEK			***SRI-AIC***
	MOVE B,TODCLK
	ADDI B,^D20000		;SET OVERDUE TIME FOR SEEK AS 20 SEC (ALLOW ENOUGH
				;TIME FOR POSSIBLY BAD PICTURE) 	***SRI-AIC***

	MOVEM B,DSKLSV(A)	;FROM NOW
	PION
	RET					;***SRI-AIC***
>
IFDEF SSADF,<
	JRST DSKSVX>		; JUST START THE OPERATION IN BLK MPXR.

DSKRCC:	MOVSI C,DSKSIP+DSKCMR
	ANDCAM C,DSKSTS(A)	;SET DRIVE TO IDLE STATE
	RET

;SCAN FOR BEST OP TO DO NEXT
; 2/ QUEUE TO SEARCH
; 3/ CURRENT TRACK
; FIND ANY PAGE ON CURRENT TRACK, OR CLOSEST PAGE .G. CURRENT TRACK

TRKSCH:	PUSH P,1
	PUSH P,[400000]		;USED TO REMEMBER BEST DIFFERENCE FOUND
	PUSH P,[0]		;REMEMBERS PTR TO BEST PAGE FOUND
	PUSH P,3		;CURRENT TRACK
TRKS1:	HRRZ C,0(B)		;2 ALWAYS HAS PTR TO PTR TO ITEM
	JUMPE C,TRKSD		;END OF LIST
	MOVEI A,0(C)
	SUBI A,CST3		;GET PAGE NUMBER
	MOVE D,CST0(A)
	TLNE D,(700B8)		;PAGE NOW IN USE?
	JRST [	HRRZ D,0(C)	;YES, CANCEL IO. UNQUEUE PAGE
		HRRM D,0(B)
		MOVSI D,(CORMB)
		IORM D,CST0(A)	;SET MODIFIED BIT
		PUSH P,2
		JSP D,SWPDON
		POP P,2
		JRST TRKS1]
	HLRZ C,0(C)		;GET TRACK
	ANDI C,7777
	SUB C,0(P)		;DIFFERENCE OF THIS AND CURRENT TRACK
	JUMPE C,TRKSS		;SAME TRACK, CAN'T BE ANY BETTER
	JUMPL C,TRKSN		;LOWER TRACK, NOT INTERESTED
	CAML C,-2(P)		;BEST DIFFERENCE?
	JRST TRKSN		;NO
	MOVEM C,-2(P)		;YES, SAVE DIFFERENCE
	MOVEM B,-1(P)		;SAVE PTR
TRKSN:	HRRZ B,0(B)		;CDR
	JRST TRKS1

TRKSD:	MOVE D,-2(P)
	CAIL D,400000		;FOUND ANY PAGE?
	JRST TRKSX		;NO
	MOVE B,-1(P)		;YES, GET PTR
TRKSS:	HRRZ C,0(B)		;UNQUEUE PAGE
	HRRZ D,0(C)
	HRRM D,0(B)
	MOVEI B,0(C)
	AOS -4(P)		;RETURN SKIP
TRKSX:	SUB P,BHC+3		;FLUSH TEMPS
	POP P,1
	RET

;DISK INTERRUPT SERVICE

IFNDEF SSADF,<
	INTERN DSKSV
DSKSV:	XWD DSKSVR,.+1
	CONSO	DSK1,DSKIRQ	;DISK 0 REQUESTING
	JRST	.+3		;NO, GO CHECK DISK 1
	MOVEI	DSK,0		;SET UP REGISTER
	JRST	DSKSV0		;GO HANDLE REQUEST
	CONSO	DSK2,DSKIRQ		;DISK 1 REQUESTING
	JRST @DSKSVR		;NO
	MOVEI	DSK,1
DSKSV0:
	MOVEM P,DSKACP		;SAVE AC
	MOVE P,[IOWD NDSKPD,DSKPDL] ;SET UP LOCAL STACK POINTER
	XCT DSKCN0(DSK)		;GET CONTROLLER STATUS
	SKIPE PWRDWN		;PWR FAIL?
	JRST DSKPWF		;YES, CLEAR DSK
	SKIPGE 1,DSKLUN(DSK)	;WAS A DRIVE TRANSFERRING?
	JRST DSKSV2		;NO
DSKSV8:	XCT DSZERR(DSK)		;ERROR   (JFCL'D FOR RDONLY SYSTEM?)
DSKSV9:	JRST DSKERR		;YES   (JFCL'D FOR RDONLY SYSTEM)
DSKSV7:	MOVSI B,DSKSIP+DSKCMR	;XFER FINISHED
	ANDCAB B,DSKSTS(A)	;SO CLEAR ALL BITS FOR THAT DRIVE
	SETZM DSKLSV(A)		;RESET OVERDUE ALARM
	XCT	DSKC3(DSK)	;CLEAR DONE FLAG
	TLNE B,DSKUIO		;UTILITY OP?
	JRST DSKSVU		;YES
	HRRZ A,DSKCAW(A)	;GET CORE ADDRESS JUST FINISHED
	LSH A,-^D9		;PAGE NUMBER
	JSP D,SWPDON		;NOTE XFER COMPLETED
DSKSV2:	XCT DRATT(DSK)		;READ ATTENTION BITS INTO AC0, B28-35
	MOVSI A,-<NDVMAX/2>
	SKIPE	DSK		;IF SECOND DISK, START WIT 10
	HRRI	1,10
DSKSV6:	MOVSI C,DSKSIP+DSKCMR
	XCT DSZATN(DSK)		;ATTENTION UP ON THIS DRIVE?
	JRST DSKSV4		;YES
	TDNN C,DSKSTS(A)	;THIS DRIVE FREE?
	CALL DSKRCK		;YES, SEE IF ANY WAITING REQUESTS
				; THIS WILL SET STATE TO "READY", AND
				; WILL START SEEKS, BUT WILL NOT START
				; DATA TRANSFER SINCE CALLED ON PI LEVEL
DSKSV5:	AOBJN A,DSKSV6		;CHECK ALL DRIVES
	CALL DFTGO		;START TRANSFER IF POSSIBLE	***SRI-AIC***
	JRST	DSKSV1
	SETZ 2,   				;***SRI-AIC***
	DPB 2,ERRCPT		;CLEAR ERROR COUNT   	***SRI-AIC***
DSKSV1:	MOVE P,DSKACP		;RESTORE AC-P
	UNBRK DSK		;DEBREAK
>		; END OF NON-SSA INT ROUTINE (FIRST LEVEL)
		;START ***SRI-AIC***

;ROUTINE TO SETUP AND START TRANSFER TO/FROM DISK

DFTGO:	AOS 1,DSKLUN(DSK)	;START WITH NEXT UNIT, OR 0 IF NONE	
	SKIPE	DSK		;CONTROLLER 0?
	SKIPE	DSKLUN(DSK)	;NO, IS UNIT EQUAL ZERO?
	CAIA			;NO, CONTINUE
	ADD	1,DSKTB2(DSK)	;ADD FIRST UNIT OF CONTROLLER OFFSET
	MOVEI	D,^D20		; .GT. MAXIMUM NUMBER OF SECTORS TO WAIT
	HRLI 1,-<NDVMAX/2>	;-MAX NO. UNITS	
DFTGO1:	MOVEI 2,0(1)	;GET DRIVE NO.		
	CAML	2,DSKTB1(DSK)
	HRR	1,DSKTB2(DSK)
	MOVE 3,DSKSTS(1)			
	TLNE 3,DSKCMR	;COMMAND READY AND NO SEEK IN PROGRESS 
	TLNE 3,DSKSIP				
	JRST	DFTGO2		;NO, CHECK NEXT DRIVE
	JRST	DFTGO3		;TEMPORARY BYPASS OF OPTIMIZE CODE *******
	HRLZ	B,A	;GET UNIT
	LSH	B,^D12		;POSITION IN COMMAND
	TLO	B,DSKNOP	;SELECT DRIVE OPERATION
	XCT	DSKO(DSK)	;FUNCTION DRIVE
	XCT	DSKI3(DSK)	;GET SECTOR INFORMATION
	HRRZ	C,C		;ISOLATE SECTOR
	LSH	C,-^D13		;PRESENT SECTOR POSITION
	ADDI	3,2		;SAY DISK IS TWO AHEAD TO ELIMINATE POSSIBLE
				;SECTOR CROSSING AT TIME OF CHECK
	LDB	B,[POINT 5,DSKDAW(1),23]  ;REQUESTED SECTOR
	CAMG	C,B
	ADDI	B,^D10
	SUB	2,3		;SECTOR DISTANCE
	CAIL	2,0		;TOO SMALL
	CAIL	2,0(4)		;IS DISTANCE SMALLER THAN PRESENT MIN
	JRST	DFTGO2		;NO, SEE IF ANY MORE
	MOVE	D,B		;SAVE MINIMUM DISTANCE
	HRL	D,A		;SAVE OPTIMUM UNIT
DFTGO2:	AOBJN	A,DFTGO1
	JFCL	;	CAIE	D,^D20		;ANYTHING TO DO ?
	JFCL	;	JRST	DFTGO3		;YES
	SETOM	DSKLUN(DSK)	;NO, ALL DRIVES CHECKD, NON TRANSFERING
	RET
DFTGO3:	JFCL		;HLRZ A,D     RETREIVE OPTIMUM UNIT
	CALL DFTCK	;START XFR IF DF10 FREE
	AOS 0(P)	;SKIP, INDICATING XFR STARTED
	RET		;RETURN			


;ROUTINE TO CHECK THAT DF10 IS AVAILABEL AND START TRANSFER 
;IF SO.					
DFTCK:	PIOFF		;ELIMINATE RACE CONDITION WITH TV
	SKIPN DF10LK	;DO WE HAVE THE DF10?	
	JRST DSKSVX	;YES, GO START TRANSFER	
	SETOM DSKLUN(DSK)	;NO, CAN'T START NOW, RESET TRANSFER IN PROGRESS FLAG 
	PION
	RET		;AND RETURN, TRANSFER WILL START WHEN WE GET IT BACK 
			;END ***SRI-AIC***
;ROUTINE TO START XFER ON READY DRIVE
;CALLED HERE ON BOTH PROCESS AND INTERRUPT LEVELS

IFNDEF SSADF,<
DSKSVX:	MOVSI C,DSKSIP+DSKCMR
	IORB C,DSKSTS(A)	;SET STATE TO XFER IN PROGRESS
	MOVE B,TODCLK
	ADDI B,^D1000		;SET OVERDUE ALARM FOR 1 SEC.
	MOVEM B,DSKLSV(A)
	MOVE B,DSKCAW(A)	;CORE ADDRESS AND COUNT
	HRRI B,-1(B)		;LIKE IOWD, ADDRESS IN 1 LESS
	XCT	DSKCCM(DSK)
	HRRZ	B,DSKCCM(DSK)	;GET CONTROL WORD POINTER
	MOVEM	B,@DSKCP(DSK)	;SET UP INITIAL CHANNEL ADDRESS WORD
	MOVE B,DSKDAW(A)	;DISK ADDRESS
	TLZ	B,(1B2)		;CLEAR CONTROLLER BIT
	IOR	2,DSKCP(DSK)	;INCLUDE INITIAL COMMAND WORD ADDRESS
	TLNE C,DWRBIT		;READ OR WRITE?
	TLOA B,WRITE		;WRITE, CONSTRUCT COMMAND
	TLO B,READ		;CONSTRUCT READ COMMAND
	XCT	DSKO(DSK)
	HRRZM A,DSKLUN(DSK)		;REMEMBER NUMBER OF DRIVE XFERRING
	PION
	RET
>
	XLIST		;SUPPRESS LISTING OF SSA10 CODE ***SRI-AIC***
IFDEF SSADF,<

; CALLED HERE FROM SSASRV WHEN SSA INTERRUPTS ON SUBCHANNEL SSADC .
; A/ DEVICE NUMBER
; B/ SSADC
; C/ SSABAS+4*SSADC
; D/ CHANNEL STATUS WORD A, FROM 1(C)

DSKSV::	SUBI A,I.DDEV		;CONVERT TO LOCAL INDEX
	CAIL A,0		; SEE IF IN RANGE
	CAILE A,NPACKS		; ..
	JRST DSVXT1		; NO. DISMISS (MIGHT BUGCHK HERE)
	LSH D,-^D20		; OK. GET THE CHANNEL AND DEVICE STATUS
	CAIN D,0B27+ID.CHE+ID.DVE ; CHECK FOR THE NORMAL CASE FIRST
	JRST DSKSV7		; OK. GO DO COMPLETION ACTION
	TRNE D,ID.UCK		; NOT NORMAL. SEE WHAT IT IS. UNIT CHK?
	JRST DSVUCK		; YES. GO DO SENSE OP.
	TRNE D,ID.BSY		; REJECTED DUE TO BUSY?
	JRST DSVBSY		; YES.
	TRNE D,ID.CUE		; CONTROL UNIT END?
	JRST DSVCUE		; YES. CU END, NO BUSY.
	TRNE D,<<SS.SER!SS.BIP!SS.CSE!SS.PIF!SS.LNE>_<-^D20>>!ID.ATN!ID.UEX
	JRST DSVXT2		; NO GOOD. TRY TO RESTART IT.
	TRNE D,ID.DVE		; DEVICE END ALONE?
	JRST DSVDVE		; YES. ASYNCHRONOUS, PROBABLY.
				; CHANNEL END OR NOTHING AT ALL. IGNORE.
DSVXT1:	CONO SSA,SA.STS!<SSADC>B32!SSACHN	; CLEAR INT REQ FLAG
	POPJ P,0		; RETURN TO SSASRV

DSVXT2:	BUG(CHK,<DSK - BAD STATUS BITS>)
DSVXT3:	MOVE B,DSKSTS(A)	; SEE IF IT WAS GOING BEFORE
	TLNE B,DSKSIP!DSKCMR
DSVXT4:	PUSHJ P,DSKSVX		;YES. RESTART IT.
	JRST DSVXT1		; AND GO DISMISS THIS INT.

;HERE ON DEVICE END ALONE

DSVDVE:	MOVE B,DSKSTS(A)	; SEE WHAT THIS DRIVE HAD BEEN UP TO
	CAMN B,MINUS1##
	JRST DSVDV1		; WAS OFF LINE. JUST CAME ON.
	TLNN B,DSKBSB		; WAS IT BUSY BEFORE?
	JRST DSKSV2		; NO. RESTART IF NEEDED, ELSE IGNORE.
	MOVSI B,DSKBSB		; YES. CLEAR BUSY BIT,
	ANDCAM B,DSKSTS(A)	; ..
	JRST DSVXT3		; RESTART IF NEEDED, DISMISS.

DSVDV1:	SETZM DSKSTS(A)		; MARK DRIVE UP AND IDLE
	JRST DSKSV2		; AND DISMISS THIS INTERRUPT

;NORMAL COMPLETION OR SENSE DONE

DSKSV7:	MOVSI B,DSKBSB		; CLEAR "BUSY BEEN SEEN" BIT
	ANDCAB B,DSKSTS(A)	; AND PICK UP STATUS
	TLNE B,DSKSNB		; SENSE COMPLETED AFTER UNIT CHECK?
	JRST DSVSND		; YES. GO LOOK AT SENSE DATA
DSKSV8:				; BACK HERE AFTER CORRECTING DATA CKS
	MOVSI B,DSKSIP!DSKCMR!DSKSNB ; CLEAR BUSY AND SENSE BITS
	ANDCAB B,DSKSTS(A)	; ..
	SETZM DSKLSV(A)		; NO LONGER WAITING FOR COMPLETION
	TLNE B,DSKUIO		; DSKUIO TYPE OP?
	JRST DSKSVU		; YES. GO COMPLETE IT.
	PUSH P,A		; SAVE UNIT NUMBER
	HRRZ A,DSKCAW(A)	; PAGE BEING TRANSFERRED
	LSH A,-11		; JUST PAGE, NOT ADDRESS
	JSP D,SWPDON		; CALL SWAPPER FOR COMPLETION
	POP P,A			; GET BACK DRIVE NUMBER
DSKSV2:	MOVSI C,DSKSIP!DSKCMR	; SEE WHAT ELSE TO DO ON THIS DRIVE
	PUSHJ P,DSKRCK		; ..
	JRST DSVXT1		; AND DISMISS THE INTERRUPT

DSKSVU:	TDZA 0,0		; NO ERRORS
DSKUER:	MOVEI 0,4000		; ERRORS NOT ENCODED YET ON 3330'S
	LDB C,UCMIPT		; FIND PLACE IN DSKUIO COMMAND LIST
	MOVEM 0,DSKCL+1(C)	; STORE FINAL STATUS
	AOS PSKED		; SIGNAL SCHEDULER ON PAGE COMPLETION
	JRST DSKSV2		; NEXT ACTION ON DRIVE, DISMISS INT.

;HERE WHEN SENSE DONE ON A DRIVE

DSVSND:	MOVSI D,(3B1)		; BACK TO BMX MODE
	HRRI D,DPDEVL
	MOVEM D,SSABAS+4*SSADC
	CONO SSA,SA.GOF+SA.SET+<SSADC>B32+SSACHN
	HLRZ D,DPBAS(A)		; SENSE PROGRAM START
	HRRZ B,1(D)		; SENSE DATA STORAGE
	MOVE D,0(B)		; FIRST WORD OF SENSE INFO
	LSH D,-20		; KEEP TOP 2 AND A HALF BYTES
	CAIN D,100004		; CORRECTABLE DATA CHECK?
	JRST DSVCDC		; YES.
	CAIN D,1		; STATISTICS?
	JRST DSVXT4		; YES. IGNORE FOR NOW
	TLNN D,3		; INTERV REQUIRED?
	JRST DSVSD1		; NO
	BUG (CHK,<DISK OFF LINE OR WRITE PROTECTED>)
	JRST DSVXT3		; RESTART IF NEEDED
DSVSD1:
REPEAT 0,<
	TRNE D,4332		; PERM ERR, BAD PACK, ETC.
	JRST DSKERP		; YES. PERMANENT ERROR HANDLER
>
	JRST DSKERR		; RETRY THIS ERROR

DSVUCK:	MOVSI B,DSKSNB		; SENSE REQUEST.
	TDNE B,DSKSTS		; ALREADY ONE?
	BUG (CHK,<UNIT CHECK ON DISK SENSE>)
	IORM B,DSKSTS(A)	; REQUEST SENSE, FLAG IT.
	HLRZ D,DPBAS(A)		; SENSE PROGRAM STARTS HERE
	HRRZ B,1(D)		; CLOBBER OLD SENSE BYTES
	SETOM 0(B)		; ..
	HRLI D,(TCH)		; NON BMX MODE FOR SENSE
	MOVEM D,SSABAS+<4*SSADC>
	CONO SSA,SA.GOF!SA.SET!<SSADC>B32!SSACHN
	JRST DSVXT1		; START SENSE AND DISMISS.

DSVBSY:	TRNE D,ID.CUE!ID.DVE	; BUSY. ANY ENDS COME WITH IT?
	JRST DSVXT4		; YES. RETRY, CLEAR BUSY, DISMISS
	MOVSI B,DSKBSB		; NO. FLAG BUSY SEEN,
	IORM B,DSKSTS(A)	; ..
	JRST DSVXT1		; AND WAIT FOR AN END

DSVCUE:	MOVSI A,-NPACKS		;CONTROL UNIT END. RESTART PACKS WITH
DSVCU1:	MOVSI B,DSKBSB		; BUSY ON IN STATUS WORD.
	TDNN B,DSKSTS(A)	; THIS ONE BEEN STOPPED WITH BUSY?
	JRST DSVCU2		; NO.
	ANDCAM B,DSKSTS(A)	; YES. CLEAR THE BIT,
	PUSHJ P,DSKSVX		; AND RESTART THE TRANSFER
DSVCU2:	AOBJN A,DSVCU1		; LOOP THRU ALL DRIVES.
	JRST DSVXT1		; ALL RESTARTED. SO DISMISS INT.

;ERROR ROUTINES

;DSKERS IS ERROR SUBROUTINE CALLED TO COUNT ERRORS, MOVE ERROR WORDS.
; CALL WITH DRIVE IN A, POINTER TO SENSE DATA IN B

DSKERS:	MOVE C,DSKCAW(A)	; THE CORE ADDRESS
	MOVEM C,DSKRER
	MOVE C,DSKDAW(A)	; PACKED HARDWARE ADDRESS
	MOVEM C,DSKRER+1
	MOVE C,DSKSTS(A)	; STATUS WORD
	MOVEM C,DSKRER+2
	MOVE C,0(B)		; FIRST WORD OF SENSE DATA
	DPB A,[POINT 4,C,35]	; WITH DRIVE NUMBER IN LOW 4 BITS
	MOVEM C,DSKRER+3	; SAVE IT
	AOS DSKRCE		; COUNT RECOVERABLE ERRORS
	POPJ P,0		; RETURN FROM DSKERS

DSKERR:	PUSHJ P,DSKERS		; STORE ERROR WORDS
	DPB C,ERRCPT		; ..
	CAIG C,DSKNTR		; TOO MANY RETRIES?
	JRST DSVXT4		; NO, TRY IT AGAIN, SAM.
DSKERP:	SETZM DSKLSV(A)		; PERMANENT ERROR. CLEAR WAIT TIME.
	PUSHJ P,DSKERS		; COPY ERR WORDS (IN CASE CALLED DSKERP)
	AOS DSKNRE		; COUNT NON-RECOVERABLE ERRORS
	MOVE C,[DSKRER,,DSKLER]
	BLT C,DSKLER+3		; COPY TO PERM ERROR MEMORY AREA
	MOVSI C,1(B)
	HRRI C,DSKESB		; COPY THE REST OF THE SENSE BYTES
	BLT C,DSKESB+4		; ..
	MOVNI C,DSKNTR
	ADDM DSKRCE		; COUNT DOWN RECOV ERRS
	MOVSI C,DSKUIO		; UTILITY OP?
	TDNE C,DSKSTS(A)	; ..
	JRST DSKUER		; YES. DIFFERENT COMPLETION ACTION
	PUSHJ P,DSKEP1		; FILESYSTEM COMPLETION ON ERROR
	JRST DSKSV2		; TRY SOMETHING ELSE.

DSVCDC:	AOS DSKCDC(A)		; COUNT CORRECTABLE DATA CHECKS PER DRV
	LDB C,[POINT 8,3(B),31]	; FIRST MAKE SURE A PAGE WAS READ
	MOVE D,4(B)		; ..
	LSHC C,^D16		; LENGTH IN BYTES OF TRANSFER
	HRRZ D,DSKCAW(A)	; AND MAKE SURE PAGE-ALIGNED
	TRNN D,777		; (MAY FAIL IN RLRMON)
	CAIE C,4400		; ONE PAGE?
	JRST DSKERR		; NOT NORMAL CASE. RETRY.
	PUSHJ P,DSKERS		; COUNT ERROR, MOVE SENSE BYTES
	MOVE D,5(B)		; GET THE ERROR PATTERN
	TRZ D,7777		; THREE BYTES TO XOR IN
	LDB B,[POINT 16,4(B),31] ; POSITION FROM END
	CAIGE B,3		; THE CHECK FOR ERRS IN CORRECTION BYTES
	TDZ D,[377B23]		; WHICH HAVE TO BE MASKED OUT
	CAIGE B,2		; ..
	TLZ D,(377B15)
	CAIGE B,1
	TLZ D,(377B7)		; (ERROR ENTIRLY IN CORRECTION BYTES!)
	MOVNS B			; NOW COUNT FROM START TO ERR
	ADDI B,4400		; ..
	IDIVI B,11		; B GETS WORD PAIRS, C GETS BYTES TO ERR
	IMULI C,-10		; FOR SHIFT TO ERR POSITION
	ADDI B,(B)		; WORDS, NOT WORD PAIRS
	CAMLE C,[-^D36]		; ERROR ALL BEYOND FIRST WD OF PAIR?
	JRST .+3		; NO.
	  ADDI B,1		; YES. COUNT UP A WORD
	  ADDI C,^D36		; AND SHIFT 36 LESS BITS
	PUSH P,5		; MAKE WORD PAIR OF ERROR IN 4 AND 5
	MOVEI 5,0		; ..
	LSHC D,(C)		; MOVE THE ERROR BITS AROUND
	HRRZ C,DSKCAW(A)	; GET CORE ADDRESS OF PAGE
	LSH C,-11		; CORE PAGE NUMBER (REAL CORE)
	TRNE B,1		; ODD NUMBER WORD OF TRANSFER?
	ROT D,4			; YES. BYTE PACKING DIDDLE
	SKIPE D			; DON'T CLEAR AR'S IF NOT NEEDED
	PUSHJ P,XRMRCA##	; XOR IN THE ERROR PATTERN
	ADDI B,1		; NOW THE SECOND WORD OF ERRORS
	MOVE D,5		; SECOND GROUP OF ERROR BITS
	TRNE B,1		; IF ODD WORD,
	ROT D,4			; MOVE AROUND FOR PACKING MODE
	SKIPE D			; IF ANY ERRORS IN THIS WORD,
	PUSHJ P,XRMRCA		; CORRECT THEM
	POP P,5			; RESTORE STACK
DSCDCX:	JRST DSKSV8		; CORRECTED. GO FINISH UP

>	; END OF SSA INTERRUPT LEVEL CODE

;ROUTINE TO START XFER ON READY DRIVE
;CALLED HERE ON BOTH PROCESS AND INTERRUPT LEVELS

IFDEF SSADF,<
DSKSVX:	MOVSI C,DSKSIP!DSKCMR	; SET STATE TO TRANSFER IN PROG
	IORM C,DSKSTS(A)	; AND PICK UP STATE WORD
	MOVSI C,DSKSNB!DSKBSB	; CLEAR THESE
	ANDCAB C,DSKSTS(A)	; AND PICK UP STATUS IN 3
	MOVE B,TODCLK		; SET OVERDUE ALARM TO COVER SEEK AND 
	ADDI B,^D10000		;  DATA TRANSFER TIME
	MOVEM B,DSKLSV(A)	; ..
	MOVSI B,<-1000>_<^D17-SSAWCP> ; A PAGE AT A TIME
	HRR B,DSKCAW(A)		; AND START OF PAGE TO READ INTO
	HRRZ D,DPBAS(A)		; CHANNEL PROGRAM FOR THIS DRIVE
	MOVEM B,DPOADR(D)	; MODIFY THE DATA CHAIN WORD
	MOVEI B,IC.RDD		; READ DISK OPCODE
	TLNE C,DWRBIT		; UNLESS WRITE REQUESTED,
	MOVEI B,IC.WRD		; WRITE DISK OPCODE
	DPB B,[POINT 8,DPOOPC(D),15]	; TO CHANNEL READ/WRITE PROGRAM
	MOVEI B,I.DDEV(A)	; PUT IN DEVICE NUMBER
IFE SA10BF,<
	HRLI D,(<BMX.S>B7)	; MAKE BMX START WORD
	DPB B,[POINT 8,D,15]>	; PUT IN DEVICE NUMBER
IFN SA10BF,<
	HRLI D,(<BMX.S>B15)
	DPB B,[POINT 8,D,7]>	; PUT IN DEVICE NUMBER
	MOVEM D,DPDEVL(A)	; STORE IN DEVICE LIST
	CONO SSA,SA.GOF+SA.SET+<SSADC>B32+SSACHN	; START I/O
	HRRZM A,DSKLUN		; THIS UNIT GOING
	RET
> ; END OF SSA VERSION OF DSKSVX
	LIST		;CONTINUE LISTING 	***SRI-AIC***

IFNDEF SSADF,<
;FOUND ATTN BIT FOR DRIVE

DSKSV4:	XCT DCLATT		;CLEAR ATTENTIONS
	MOVSI C,DSKSIP
	XOR C,DSKSTS(A)
	TLCE C,DSKSIP+DSKCMR	;WAS SEEK IN PROGRESS?
	JRST	DSKSC1		;NO
	TLNE	C,DSKRCB	;WAS IT A RECALIBRATE COMMAND
	JRST	[MOVSI	C,DSKRCB	;YES CLEAR IT
		ANDCAM	C,DSKSTS(A)
		CALL	DSKPOS		;ISSUE SEEK
		JRST	DSKSV5]
	CALL	DCKSEK		;SEEK INCOMPLETE
	JRST	DSKSKE		;YES
DSKSK1:	MOVSI C,DSKSIP+DSKCMR
	XORM C,DSKSTS(A)	;CHANGE STATE TO COMMAND READY
	JRST DSKSV5

DSKSC1:	TLNE	C,DSKSIP+DSKCMR
	CALL	DUEATT		;NO, UNEXPECTED INTERRUPT
	JRST	DSKSV5		;IGNORE IT

DSKSKE:	LDB C,ERRCPT		;GET RETRY COUNT
	ADDI C,1
	CAILE C,DSKNTR		;UNRECOVERABLE?
	JRST DSKSK1		;YES, TRY XFER ANYHOW
	DPB C,ERRCPT
	MOVSI C,DSKRCB		;SEEK INCOMPLETE, TRY RECAL
	IORM C,DSKSTS(A)
	CALL DSKRCL
	JRST DSKSV5

DSKUER:	MOVSI C,DSKSIP+DSKCMR
	ANDCAM C,DSKSTS(A)
	TLZA 0,400000		;RETURN ERROR BITS (B0 SHOULD BE OFF)
DSKSVU:	SETZ 0,			;0 MEANS NO ERRORS
	LDB C,UCMIPT		; GET COMMAND INDEX
	MOVEM 0,DSKCL+1(C)	;WORD GOING POSITIVE INDICATES DONE
	AOS PSKED		;SIG SCHED
	JRST DSKSV2
;STILL IN COND ON NOT SSADF

;STILL ON NON-SSA COND
;DISK ERROR

	INTERN DSKERR

DSKERR:	XCT DCLERR		;CLEAR ALL ERROR CONDITIONS
DSKEC2:	MOVE 2,0	; GET ERROR BITS TO AC2	***SRI-AIC***
	MOVE C,DSKDAW(A)	;SAVE ERROR WORDS
	SKIPE	DSK		;CONTROLLER 0
	TLO	3,100000	;NO
	MOVEM C,DSKRER
	MOVE C,DSKCAW(A)
	MOVEM C,DSKRER+1
	MOVE C,DSKSTS(A)
	MOVEM C,DSKRER+2
	MOVEM 0,DSKRER+3	;AND ERROR BITS
	TRNE	0,1B26		;IS IT A LEGAL WRITE?
	SKIPE	RDONLY		;NO, IS SYSTEM READ ONLY?
	JRST	DSKEC3		;YES, NOT READ ONLY PROBLEM
	PIOFF			;NO, DRIVE WENT READ ONLY
	PUSH	P,7		;SAVE 7 BECAUSE BUGMSG USES IT
	PUSH	P,B		;SAVE ERROR BITS
	PUSH	P,A		;SAVE UNIT
	MOVEI	A,[SIXBIT @$$$DRIVE @]
	JSR	BUGMSG
	MOVE	A,0(P)		;GET UNIT
	JSR	BUGTYO
	MOVEI	A,[SIXBIT @ WENT READ ONLY...$MAKE IT WRITABLE AND SYSTEM WILL CONTINUE$$$@]
	JSR	BUGMSG
	HRLZ	B,0(P)		;GET UNIT
	LSH	B,-^D12		;POSITION IN DISK COMMAND
	TLO	B,(6B2)		;SELECT UNIT COMMAND
	XCT	DSKO(DSK)	;SELECT UNIT
	XCT	DSKI3(DSK)	;GET UNIT STATUS
	TLNE	3,(1B16)	;IS IT STILL READ ONLY
	JRST	.-3		;YES
	POP	P,A		;NO, RESTORE REGISTERS
	POP	P,B
	POP	P,7
	PION			;CONTINUE
DSKEC3:	AOS DSKRCE		;COUNT REC ERRORS
	LDB C,ERRCPT		;RETRY COUNT
	ADDI C,1
	DPB C,ERRCPT
	CAILE C,DSKNTR		;UNRECOVERABLE?
	JRST DSKERP		;YES
DSKER2:	XCT DSZSCF		;SKIP NO SEARCH FAILURE
	JRST DSKER3		;SEARCH FAILED, TRY RECALIBRATE
	CALL DSKSVX		;START XFER OVER AGAIN
	JRST DSKSV1		;DEBREAK

DSKER3:	MOVSI C,DSKCMR+DSKRCB	;SET STATE TO RECAL IN PROGRESS
	XORM C,DSKSTS(A)
	MOVE B,TODCLK
	ADDI B,^D5000
	MOVEM B,DSKLSV(A)	; RESTART TIMER FOR RECAL
	CALL DSKRCL		;INITIATE RECAL
	JRST DSKSV2		;CONTINUE PROCESSING INTERRUPTS
;STILL IN NON-SSA COND

;STILL IN NON-SSA COND
DSKER1:	TRNE 2,2000	;DRIVE OFF LINE OR UNSAFE?
	JRST DSKUSF	;YES					

	TRNE 2,40000
	BUG(HLT,<DSKSV - SEARCH ERROR>)

	TRNN 2,20000
	JRST	.+3
	BUG(CHK,<DSKSV - DATA LATE ON SEEK>)	
	JRST	DSKUSF
	BUG(CHK,<DSKSV - DISK ERROR, AND NO TRANSFER IN PROGRESS>) 
	JRST	DSKUSF



;DISK OFF LINE, SELECT LOCKED OR OTHER SUCH STATE,  HAVE OPERATOR
;FIXIT, THEN CONTINUE.						

DSKUSF:	PIOFF		;SHUT DOWN TENEX			
	PUSH P,7	;SAVE 7 SINCE BUGMSG USES IT		
	PUSH	P,1	;SAVE UNIT
	MOVEI	1,[SIXBIT '$$$DRIVE /']
	JSR	BUGMSG
	MOVE	1,0(P)	;RETREIVE UNIT
	JSR	BUGTYO
	MOVEI 1,[SIXBIT ' UNSAFE OR OFFLINE$POWER IT DOWN AND BACK UP AGAIN AND SYSTEM WILL CONTINUE$$$/']
 	JSR BUGMSG
	POP P,1		;RETREIVE UNIT
UNSAF3:	CALL	DSKPOS
	CALL	READY
	JRST	UNSAF3		;ERROR, UNSAFE OR OFFLINE
	POP P,7		;RESTORE 7				

	PION		;RESTART TENEX				

	SKIPGE 1,DSKLUN(DSK)		;TRANSFER OR SEEK			
	JRST UNSAF2
	SETOM DSKLUN(DSK)	;SAY NO TRANSFER IN PROGRESS		
UNSAF2:	MOVSI 2,DSKSIP+DSKCMR	;WILL RESTART SEEK				
	IORM 2,DSKSTS(1)	;RESTORE STATUS					
	CALL DSKPOS	;GO DO IT
	JRST DSKSV2	;GO					

	REPEAT	0,<
;ROUTINE TO TELL OPERATOR TO MOUNT PACK FOR SWAPPING

MNTSWP:	PIOFF			;SHUT DOWN TENEX
	PUSH P,7
	PUSH P,2
	PUSH P,1
	MOVEI 1,[SIXBIT '$$$DISK SWAPPING REQUESTED WITH NO SWAPPING PACK MOUNTED$MOUNT PACK ON LOGICAL DRIVE /']
	JSR BUGMSG		;PRINT MESSAGE TO OPERATOR			
	MOVE	1,0(P)		;GET UNIT FROM STACK
	TRZ	1,10		;CLEAR CONTROLLER NUMBER
	JSR	BUGTYO
	MOVEI 1,[SIXBIT' CONTROLLER /']
	JSR	BUGMSG
	HRRZ	1,0(P)
	LSH	1,-3		;ISOLATE CONTROLLER
	JSR 	BUGTYO
	MOVEI	1,[SIXBIT ' AND SYSTEM WILL CONTINUE$$$/']
	JSR	BUGMSG
	MOVE	1,0(P)		;GET UNIT FOR DIUNIT
	CALL	DIUNIT		;GO INITIALIZE UNIT
	JFCL			;ERROR
	SKIPE DSKSTS(1)		;UNIT READY
	JRST .-3		;NO, KEEP TRYING
	POP P,1		;OK, START IT UP AGAIN
	POP P,2
	POP P,7
	PION			;GET TENEX GOING AGAIN				
	RET
	>
;UNRECOVERABLE ERROR

DSKERP:	XCT DSZPCI		;SKIP NO PCI ERROR
	JRST [	MOVE C,[SIXBIT /DSKPAK/]
		MOVEM C,DEVMPE	;YES, REQUEST CORE SCAN
		ISB APRCHN
		JRST DSKER2]	;TRY AGAIN
	SETZM DSKLSV(A)		;RESET OVERDUE ALARM
	MOVNI C,DSKNTR
	ADDM C,DSKRCE		;REMOVE FROM RECOVERABLE COUNT
	AOS DSKNRE		;COUNT IRRECOVERABLE
	MOVE C,[XWD DSKRER,DSKLER]
	BLT C,DSKLER+3		;SAVE COMMAND WORDS
	MOVSI C,DSKUIO
	TDNE C,DSKSTS(A)	;UTILITY OP?
	JRST DSKUER		;YES
>
;USE THIS CODE FOR BOTH DF10 AND SSA DISKS

DSKEP1:	HRRZ B,DSKCAW(A)	;'NORMAL' IRREC TYPE ERROR
	LSH B,-^D9		;GET PAGE NUMBER
	MOVSI C,SWPERR
	IORM C,CST3(B)		;NOTIFY SWAPPER OF ERROR
	MOVE C,CST2(B)		;FIND OUT WHAT PAGE IS
	TLNN C,-1		;FROM SPT?
	JRST [	CAIL C,NOFN	;YES, OFN?
		HLRZ C,SPTH(C)	;NO, GET OFN
		JRST DSKXX3]
	HLRZ C,3
DSKXX3:	CAIL C,1		;SENSITIVE FILE? I.E. DI OR DIRECTORY?
	CAILE C,NFDIB+3
	JRST DSKSV7
	BUG(CHK,<DISK ERROR IN SENSITIVE PAGE>)
	JRST	DSKSV7

INTERN CHKD1		;*** SRI-AIC***
INTERN CHKDSK,CHKDE1		; MOVED FROM SWPMON SO THEY CAN BE
				; DEVICE DEPENDENT

	SWAPCD

CHKDSK:	MOVEM 1,CHKDNE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
***NON-REC DISK ERROR: /]
			;BEGIN ***SRI-AIC***
	MOVEI 6,DSKLER+1	;4 WORD BLOCK OF COMMANDS AND ERROR BITS
CHKDE3:	PSOUT		;PRINT MESSAGE
	HRROI 1,[ASCIZ /WRITE /]
	MOVE 2,1(6)		;GET STATUS BITS
	TLNN 2,1B18		;WRITING?
	HRROI 1,[ASCIZ /READ /]	;NO
	PSOUT
	MOVE 3,[1B0+^D8]
	MOVSI 7,-5	;THERE ARE 5 FIELDS OF INFO
CHKDE4:	MOVE 1,DSKERH(7)	;PRINT HEADING FOR THIS LINE
	PSOUT
	MOVEI 1,101
	LDB 2,DSKADP(7)		; GET FIELD TO PRINT
	NOUT
	JFCL
	MOVEI 2," "	;SEPERATE LINES
	BOUT
	AOBJN 7,CHKDE4		;BUMP POINTER
	HRLI 6,-3		; NOW PRINT THE REST
	MOVEI 2,37		;RETURN THE CARRAGE FIRST
	BOUT
	MOVEI 7,DSKSTH		;GET POINTER TO DISK HEADINGS


CHKD1:	MOVE 3,[1B0+1B2+1B3+6B17+^D8]		; SAY OCTAL AND 6 DIGITS ALWAYS
	MOVE 1,0(7)		;GET HEADING POINTER
	PSOUT		;HEADING
	
	MOVEI 1,101
	HLRZ 2,0(6)
	NOUT
	JFCL

	MOVEI 2,","
	BOUT
	BOUT

	HRRZ 2,0(6)
	NOUT
	JFCL

	MOVEI 7,1(7)		;BUMP HEADING POINTER

	MOVEI 2,37	;RETURN WHEN DONE
	BOUT					;END  ***SRI-AIC***
	AOBJN 6,CHKD1
	JRST CHKR1##;*** SRI-AIC***

CHKDE1:	MOVEM 1,CHKDRE		;SAVE NEW COUNT
	HRROI 1,[ASCIZ /
*DISK ERROR: /]
	MOVEI 6,DSKRER+1		;4 WORD BLOCK OF COMMANDS, ETC.***SRI-AIC***
	JRST CHKDE3				;***SRI-AIC***

GS CHKDRE,1			;COUNT OF REC. ERRORS AT LAST REPORT
GS CHKDNE,1			; "" NON-REC. ""

;HEADINGS FOR LOGGING TTY DISK ERROR MESSAGES		***SRI-AIC*** TO END OF PAGE
DSKERH:	XWD -1,[ASCIZ /CNTLR:/]
	XWD -1,[ASCIZ /PACK: /]
	XWD -1,[ASCIZ /CYL: /]
	XWD -1,[ASCIZ /HEAD: /]
	XWD -1,[ASCIZ /SEC: /]
DSKSTH:	XWD -1,[ASCIZ /WRD CNT,,CORE ADR: /]
	XWD -1,[ASCIZ /SOFTWARE BITS    : /]
	XWD -1,[ASCIZ /CONTROLLER BITS  : /]

;POINTER TO BIT FIELDS IN ERROR WORDS
DSKADP:	POINT 1,-1(6),2		;CONTROLLER
	POINT 3,-1(6),5		;DRIVE
	POINT 8,-1(6),13	;CYLINDER
	POINT 5,-1(6),18	;HEAD
	POINT 5,-1(6),23	;RECORD

	RESCD

;DISK DRIVER INITIALIZATION

	INTERN DSKINI,DSKRST

DSKINI:	IFNDEF DRMCHN,<CALL DRMINI> ;INIT SWAP BIT TABLE
DSKRST:	SETOM DSKLUN
	SETOM	DSKLUN+1
	SKIPN DISKP
	RET
	MOVSI	1,670000		;SELECT NON-EXISTANT UNIT
	DATAO	DSK1,1		;CONTROLLER 0
	DATAO	DSK2,1		;CONTROLLER 1
	SETOM DSKBLK
	MOVEI A,DSKCL+2*NDSKCM-2
	SETZM 0(A)		;END OF LIST
	MOVEM A,-2(A)		;INIT UTILITY FREE LIST
	SUBI A,2
	CAILE A,DSKCL
	JRST .-3
	MOVEM A,DSKFCL
	MOVEI A,NDSKCM
	MOVEM A,DSKCCT		;INIT UTILITY COMMAND FREE COUNT
IFNDEF SSADF,<
	MOVEI	1,DSKCC1
	MOVEM	1,DSKCP1
	MOVEI	1,DSKCC2
	MOVEM	1,DSKCP2>
	SKIPN	RDONLY		;READ ONLY SYSTEM ?
	JRST	DSKII0		;NO
	MOVSI A,(JFCL)		; PUT NOP IN REG A
	MOVEM	A,DSKSV8	;CLEAR ERROR CHECKING FOR READ ONLY SYSTEM
	MOVEM	A,DSKSV9
DSKII0:	MOVEI	1,[SIXBIT @$DISK PACK STATUS:/@]
	JSR	BUGMSG
	SETZ	4,		;UNIT NUMBER

	MOVSI A,-NDVMAX		;FOR EACH UNIT, DO:
DSKII3:	CALL DSKII1		;GO INITIATE ONE DRIVE
	ADDI	4,1		;INCREMENT DRIVE NUMBER
	ANDI	4,7		;ONLY 3 BITS
	AOBJN	1,DSKII3
	SETOM	DSKPRT		;ONLY PRINT STATUS ONCE
	MOVSI C,-NDSKPR+NHOME
DSKII4:	MOVE A,DSKPRO(C)	; LOOP THRU PROTOTYPE TABLE
	MOVEM A,DSKPAR(C)	; AND COPY DSK PARAMETERS
	AOBJN C,DSKII4
	MOVSI C,-NHOME		; FOR ALL HOME BLOCK ADDRESSES
DSKII5:	MOVE A,HOMPRO(C)	; GET LOGICAL HARDWARE ADDRESS
	HLRZ B,1		; LOGICAL UNIT
	HRL A,DRIVTB(B)		; CONVERT TO HDWR ADDRESS (NOT PHYSICAL)
	MOVEM A,HOME(C)
	AOBJN C,DSKII5
	IORM A,MONDSC##

	MOVE A,[JRST CRASH1]
	MOVEM A,CRASH+1		;INIT DUMP ROUTINE FOR JSR
IFNDEF SSADF,<
	CONO	DSK1,DSKCHN
	CONO DSK2,DSKCHN>	;GIVE IT ITS PI ASSMT
	RET
	;THIS ROUT.  ACCEPTS IN 1 - CONTROLLER AND UNIT NO.
		; 4 - ONLY UNIT NO.
DSKII1:
	SETZM DSKQ(1)
	HRRZ DSK,1		;GET CONTROLLER NO.
	LSH DSK,-3
	MOVEI 2,DSKUO(1)	;INIT UTILITY QUEUE
	MOVEM 2,DSKUI(1)
	CALL	DIUNIT		;INITIALIZE UNIT
	JRST	DSKII2
	JRST	DSKII2-2	;TEMPORARY PATCH UNTIL HOME BLOCK CODE IS CHECKED OUT *******
	CALL	RDHOM		;READ HOME BLOCK
	JRST 	DSKII2		;DISK ERROR, OFFLINE, OR BAD HOME BLOCK
	CALL	DSKRCL		;RECALIBRATE
	CALL	READY		;WAIT FOR RECALIBRATE TO FINISH
	JRST	DSKII2		;ERROR
	XCT	DCLATT		;CLEAR RECALIBRATE ATTENTION
	SKIPE DSKPRT		;PRINT STATUS FIRST TIME
	JRST DSKII6
DSKII2:	PUSH P,1
	MOVEI 1,[SIXBIT @$  /@]
	JSR	BUGMSG		;TYPE OUT DRIVE NUMBER AND STATUS
	MOVE 1,0(P)		;GET DRIVE NO.
	LSH	1,-3		;1ST DIGIT
	ANDI 1,7
	CAIN  1,0		;NULL?
	JRST [MOVEI	1," "
		JRST .+2]
	TRO	1,60		;MAKE IT A DIGIT
	JSR BUGTYO
	MOVE 1,0(P)		;GET DRIVE NO.
	ANDI 1,7
	TRO	1,60		;MAKE IT A DIGIT
	JSR BUGTYO
	MOVEI 1,"("		;NOW LOGICAL NO.
	JSR BUGTYO
	MOVE 1,0(P)		;GET PHYSICAL
	HLR 1,DRIVTB(1)
	LSH 1,-3		;ISOLATE CONTROLLER
	ANDI 1,7
	TRO 1,60
	JSR BUGTYO
	MOVE 1,0(P)		;GET PHYSICAL
	HLR 1,DRIVTB(1)
	ANDI 1,7		;ISOLATE DRIVE
	TRO 1,60
	JSR BUGTYO
	MOVEI 1,[SIXBIT @) ONLINE/@]
	TLNN 3,(1B13)	;NOT ON LINE?
	MOVEI 1,[SIXBIT @) NOT ONLINE/@]
	JSR	BUGMSG
	TLNE 3,(1B14)	;UNSAFE?
	JRST [MOVEI 1,[SIXBIT @,UNSAFE/@]
		JSR BUGMSG
		JRST .+1]
	TLNE 3,(1B14)	;POSITION FAILURE?
	JRST [MOVEI 1,[SIXBIT @,POS FAIL/@]
		JSR BUGMSG
		JRST .+1]
	TLNE	3,(1B16)	;PACK READ ONLY
	JRST	[MOVEI	1,[SIXBIT @,READ ONLY/@]
		 JSR	BUGMSG
		 JRST 	.+1]
	SKIPN	RDONLY		;READ ONLY SYSTEM
	JRST	[TLNE	3,(1B16)	;NORMAL SYSTEM,IS PACK READ ONLY?
		 JRST	DSKII7		;PACK IS READ ONLY
		 JRST	DSKIID]		;PACK IS WRITEABLE
	TLNE	3,(1B16)		;READ ONLY SYSTEM, IS PACK READ ONLY?
	JRST	DSKIID			;YES
	MOVEI	1,[SIXBIT @READ ONLY SYSTEM/DO YOU WISH TO WRITE ON THIS DRIVE (Y OR N) @]
	JSR	BUGMSG
DSKIIA:	CONSO	TTY,40		;INPUT DONE
	JRST	.-1
	DATAI	TTY,1
	JSR	BUGTYO			;ECHO
	CAIN	1,"Y"
	JRST	DSKIID			;WNATS TO WRITE ON THIS DRIVE
	CAIN	1,"N"
	JRST	[MOVEI	1,[SIXBIT @$MAKE ALL PACKS READ ONLY AND TRY AGAIN/@]
		 JSR	BUGMSG
		 PIOFF
		 JRST	0,4]		;QUIT
	MOVEI	1,[SIXBIT @ ? @]
	JSR	BUGMSG
	JRST	DSKIIA
DSKIID:	POP	P,1		;RESTORE UNIT OF INTEREST
DSKII6:	TLNN 3,(1B11+1B14)	;POSITION FAIL,FILE UNSAFE?
	TLNN 3,(1B13)		;NOT ON LINE?
	JRST	DSKII8
	RET	
DSKII8:	SETOM	DSKSTS(1)	;YES, PREVENT USE OF DRIVE
	RET

DSKII7:	TLNN	C,(1B13)	;ON LINE?
	JRST	DSKIID		;NO, THEN WE DON'T CARE WHAT THE STATUS IS
	MOVEI	1,[SIXBIT @ *** DISK READ ONLY ***/@]
	JSR	BUGMSG
	MOVEI	1,[SIXBIT @$ TO BRING UP SYSTEM READ ONLY, SET RDONLY=1 AND TRY AGAIN/@]
	JSR	BUGMSG
	PIOFF
	JRST	4,0

;		READ HOME BLOCK FROM UNIT AND SET UP DRIVTB ACCORDINGLY
;		1=UNIT
RDHOM:	TLNN	3,(1B13)	;IS PACK ON LINE
	RET			;NO, THEN DON'T CARE IF IT IS READ ONLY
	HRL	2,1
	HRR	2,HOMPRO(1)	;GET HOME BLOCK DISK ADDRESS
	LSH	2,^D12		;SET UP HARDWARE DISK ADDRESS
	MOVEM	2,DSKDAW(1)
	CALL	DSKPOS		;ISSUE SEEK
RDHM1:	CALL	READY		;WAIT FOR POSITION FINISHED
	RET			;ERROR
	XCT	DCLATT		;CLEAR ATTENTION
	MOVEI	B,NHMBLK-1	;FWA-1 OF READ IN AREA
	HRLI	B,-NHMWD	;NUMBER OF WORDS TO TRANSFER
	XCT	DSKCCM(DSK)	;SET UP CONTROL WORD
	HRRM	B,DSKCCM(DSK)	;GET ADDRESS OF CONTROL WORD
	MOVEM	B,@DSKCP(DSK)	;SET UP POINTER TO CONTROL WORD
	MOVE	B,DSKDAW(A)	;GET DISK ADDRESS
	TLZ	B,(1B2)		;CLEAR CONTROLLER BIT
	IOR	B,DSKCP(DSK)	;SET UP CONTROL WORD POINTER IN COMMAND
	XCT	DSKO(DSK)	;ISSUE READ
	XCT	DSKS1(DSK)	;WAIT TILL BUSY OFF AND DONE ON
	XCT	DSKS2(DSK)
	JRST	.-2
	XCT	DCLDNF		;CLEAR DONE
;		NOW SET UP DRIVTB
	MOVE	2,NHMBLK	;GET LOGICAL UNIT FROM HOME BLOCK
	CAIL	2,0		;CHECK FOR HOMEBLOCK IN RANGE
	CAILE	2,NPACKS
	JRST	[PUSH	P,A	;OUT OF RANGE
		 PUSH 	P,B
		 MOVEI	1,[SIXBIT @***DRIVE HAS QUESTIONABLE HOMEBLOCK = @]
		 JSR	BUGMSG
		 MOVE	1,2
		 JSR	BUGTYO
		 MOVEI	1,[SIXBIT @/@]
		 JSR	BUGMSG
		 POP	P,B
		 POP	P,B
		 RET]
	HRLM	2,DRIVTB(1)
	HRRM	1,DRIVTB(2)
	AOS	0(P)		;SUCCESSFUL RETURN
	RET
LS DSKPRT,1
RDONLY:	0		;=1, BRING UP SYSTEM WITH PACKS READ ONLY


;RELOAD RES MON, CALLED FROM SYSGO

RLRMA==3000		;RUN LOCATION OF RELOAD ROUTINE
RLRCA==36		;FIRST CORE LOCATION RESTORED

RLRMON:	MOVE A,[XWD RLMX0,RLRMA]
	BLT A,RLRMA+777		;MOVE RELOAD ROUTINE TO RUN LOCATION
	JRST RLMGO		;IT RELOADS AND STARTS MON

IFDEF RP02F,<		;BOOT ROUTINE FOR RP02

;RELOAD ROUTINE, RUN IN LOWER CORE. CAN BE EXTRACTED FOR PAPER TAPE, ETC.

RLMX0:	PHASE RLRMA

RLMC5:			;TABLE OF DISK ADDRESSES, SETUP AT POSTLD
	XLIST		;REPEAT PPRMPG,<0>
	REPEAT	PPRMPG,<0>
	LIST

MNBOOT:	SETZM 20		;CLEAR CORE NOT CLEARED BY TENDMP
	MOVSI A,20
	HRRI A,21
	BLT A,777
	MOVE	17,STKWD	;SETUP STACK
	JRST	RLMGO-1		;TEMPORARY PATCH **********
	MOVE	10,MNPK		;GET ASSEMBLED PACK FOR MONITOR
	SETZM	MNPK		;CLEAR FOR CHECKING LATER
	MOVE	7,MNHM		;GET HOME BLOCK ADDRESS
	MOVEI	11,4000		;BUFFER ADDRESS
FIND:	HRLI	6,-NDVMAX	;NUMBER OF UNITS AVAILABLE
FNDLOG:	MOVE	DSK,6
	LSH	DSK,-3		;GET CONTROLLER
	MOVE	1,7		;GET ADDRESS
	HRL	1,6		;DEVICE AND CONTROLLER
	CALL	MNBRD		;READ HOME BLOCK
	JRST	HOMERR
	CAMN	10,0(11)	;IS THIS MONITOR PACK
	HRRZM	6,MNPK	;YES, SAVE MONITOR PACK
HOMERR:	AOBJN	6,FNDLOG
	SKIPN	MNPK		;MONITOR PACK FOUND
	JRST	FIND		;TRY AGAIN
	MOVEI 7,100		;SETUP RETURN TO DDT WHEN LOADED
RLMGO:	MOVSI 10,-PPRMPG+1
	MOVEI 11,RLRCA		;FIRST CORE LOC TO LOAD INTO
RLMG2:	CAIGE 11,RLRMA+1000
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		;SKIP OVER THIS CODE WHEN READING
	MOVE A,RLMC5(10)	;DISK ADDRESS
	HRL	A,MNPK		;ACTUAL UNIT, INCLUDING CONTROLLER
	JSP	16,MNBRD		;READ PAGE SUBROUTINE
	JRST	4,RLMGO		;DISK NOT ON LINE OR ERROR, TRY AGAIN
	ANDCMI 11,777		;BUMP TO NEXT PAGE
	ADDI 11,1000
	AOBJN 10,RLMG2
	AOS GETSMF
	JRST 0(7)		;RETURN

;	READ DATA FROM PACK OF INTEREST
MNBRD:	HLRZ	DSK,1
	LSH	DSK,-3		;ISOLATE CONTROLLER BIT
	LSH A,^D12
	TLZ	1,100000	;TURN OFF CONTROLLER BIT
	TLO A,SEEK
	XCT	RLMDO1(DSK)	;POSITION HEADS
	ROTC B,^D72		;DELAY SEEMS NECESSARY HERE
RLMG1:	XCT	RLMDI2(DSK)	;GET STATUS
	TLNN B,(1B11)		;ERROR?
	TLNN B,(1B13)		;OR NOT ON LINE?
	JRST	0(16)		;YES
	TLNN B,(1B12)		;ON CYL?
	JRST RLMG1		;NO, WAIT
	TLZ	A,DSKCAL	;CLEAR FUNCTION CODE
	TLO	A,(5B2)		;AT EASE COMMAND - CLEAR ATTENTION
	IORI	A,776		;ATTENTION BITS FOR ALL UNITS
	XCT	RLMDO1(DSK)	;CLEAR ATTENTION FROM SEEK
	TRZ	A,776		;CLEAR ATTENTION MASK FROM COMMAND
	MOVEI B,-1(11)		;CONSTRUCT CHANNEL COMMAND
	HRLI B,-1000		;TRANSFER ONE PAGE
	MOVEM B,RLMNB
	SETZM RLMNB+1		;ONE WORD CHAN PGM
	MOVEI B,RLMNB
	MOVEM B,@RLMCP(DSK)	;INITIAL CHANNEL LOC
	TLZ A,DSKCAL		;READ COMMAND = 0
	IOR A,RLMCP(DSK)		;CONSTRUCT READ COMMAND
	XCT	RLMDO1(DSK)	;ISSUE READ
	XCT	RLMC2(DSK)	;WAIT TILL BUSY OFF AND DONE ON
	XCT	RLMC3(DSK)

	JRST .-2
	XCT	RLMC1(DSK)	;CLEAR DONE AFTER TRANSFER COMPLETE
	JRST	1(16)		;GOOD RETURN


;TABLES FOR CONO'S, DATAO'S, ETC.

RLMDO1:
	DATAO DSK1,1
	DATAO DSK2,1
RLMDI2:
	DATAI DSK1,2
	DATAI DSK2,2
RLMC1:
	CONO DSK1,1B32
	CONO DSK2,1B32
RLMC2:
	CONSO DSK1,1B31
	CONSO DSK2,1B31
RLMC3:
	CONSO DSK1,1B32
	CONSO DSK2,1B32
RLMCP:
	DSKCP1
	DSKCP2

MNHM:<HOMCY1>B<^D17+NCYLBT>+<HOMSF1>B<^D17+NCYLBT+5>+HOMSC1
STKWD:	XWD	-10,MNBSTK
MNBSTK:	BLOCK	10
MNPK:	<DSKRMA>/<NTKUN*NSECTK>	;MONITOR PACK
UNITPT:	POINT	4,MNPK,5	;CONTROLLER INCLUDED
RLMNB:	REPEAT 2,<0>

	DEPHASE
RLRMX1:
>			;END RP02F

	XLIST		;SUPPRESS LISTING OF DC10 CODE ***SRI-AIC***
IFDEF DC10F,<		;BOOT ROUTINE FOR DC10

;RELOAD ROUTINE, RUN IN LOWER CORE. CAN BE EXTRACTED FOR PAPER TAPE, ETC.

DCBSY==1B20		;DC10 BUSY FLAG

RLMX0:	PHASE RLRMA

RLMC5:	REPEAT PPRMPG,<0>	;TABLE OF DISK ADDRESSES, SETUP AT POSTLD

MNBOOT:	SETZM 20	;CLEAR CORE NOT CLEARED BY TENDMP
	MOVSI A,20
	HRRI A,21
	BLT A,777
	MOVEI 7,100	;SET UP RETURN TO DDT

RLMGO:	MOVSI 10,-PPRMPG+1
	MOVEI 11,RLRCA		;FIRST CORE LOC TO LOAD INTO
RLMG2:	CAIGE 11,RLRMA+1000
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		;SKIP OVER THIS CODE WHEN READING
	MOVE A,RLMC5(10)	;DISK ADDRESS
	HLRZ B,1	;FORM REAL HARWARE DISK ADR
	ADDI B,1	;UNIT IN 2 +1 (CONTROLLER IS 0)
	HRRZS 1
	LSH A,^D35-ADRPOS
	LSH B,^D9
	IORI A,100000+DSKCP	; MAKE READ COMMAND
	IORI A,(B)	;COMPLETE HARDWARE ADR
	JSR RWDSK	;CORE ADR IN 11, DISK DATAO IN 1
	ANDCMI 11,777		;BUMP TO NEXT PAGE
	ADDI 11,1000
	AOBJN 10,RLMG2
	AOS GETSMF
	JRST 0(7)	;RETURN

;STAND ALONE DISK DRIVER FOR RELOADING MONITOR OFF DISK, AND FOR 
;WRITING CRASH COPY OF MONITOR TO CRASH AREA OF DISK.  AC2,3 SCRATCH
;	1=DATAO WORD FOR DISK
;	11=CORE ADDRESS
;	JSR RWDSK

RWDSK:	0
	MOVEI B,0(11)
	ANDI B,777
	SUBI B,1000	;-WDCNT FOR PARTIAL OR COMPLETE PAGE
	HRLI B,-1(11)	;XWD ADR-1, -WDCNT	(BACKWARDS IOWD)
	MOVSM B,RLMNB	;IOWD TO CHANNEL CMD LOCATION
	MOVEI B,RLMNB	;SET UP DF10 CMD POINTER
	MOVEM B,DSKCP
RWDSK3:	MOVEI C,DSKNTR	;NO. OF RETRIES IF ERROR
RWDSK1:	MOVE B,1	;DISK CMD WORD
	ANDI B,17000	;JUST GET UNIT
	CONO DSK,DSKCHN(B)	;SELECT THE UNIT
	CONI DSK,2	;AND READ ITS STATUS
	TLNE B,(1B12+1B14+1B15)	;OFF LINE, UNSAFE, OR WRITE PROTECTED?
	HALT RWDSK1	;YES, HALT. CLEAR HALT TO TRY AGAIN
	DATAO DSK,1	;START XFER
	CONSZ DSK,DCBSY	;WAIT FOR CONTROLLER BUSY STATE TO RESET
	JRST .-1
	CONSO DSK,640000	;ERRORS?
	JRST @RWDSK	;NO, JUST RETURN
	SOJG C,RWDSK1	;YES, TRY AGAIN
	HALT RWDSK3	;HARD ERROR, CLEAR HALT TO RETRY

RLMNB:	REPEAT 2,<0>

	DEPHASE
RLRMX1:
>			;END DC10F

	LIST		;CONTINUE LISTING
	XLIST		;SUPPRESS LISTING OF SSA10 CODE ***SRI-AIC***
IFDEF SSADF,<		;RLRMON FOR 3330'S

RLMX0:	PHASE RLRMA

RLMC5:	REPEAT PPRMPG,<0>	; TABLE OF PACKED HWARE DSK ADDRESSES

MNBOOT:	SETZM 20		; CLEAR LOW CORE
	MOVSI A,20
	HRRI A,21
	BLT A,777		; ..
	MOVEI 7,100		; SET RETURN PC TO DDT
RLMGO:	MOVSI 10,-PPRMPG+1	; LOAD ALL OF RES CORE EXCEPT THIS PAGE
	MOVEI 11,RLRCA		; WHERE TO START LOADING
RLMG2:	CAIGE 11,RLRMA+1000	; SKIP SELF
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		; POINTING AT SELF. SKIP.
	HLRZ A,RLMC5(10)	; DISK DRIVE, THIS PAGE
	ADDI A,I.DDEV		; REAL ADDRESS
	LSH A,^D12		; SHIFT OVER
	HRRM A,RLMNB		; PUT IN CHANNEL COMMAND
	HRRM A,RLMNB+2		; IN THREE COMMANDS. SEEK, SRCH, RD.
	HRRM A,RLMNB+5		; ..
	HRRZ A,RLMC5(10)	; NOW SET THE CYLINDER
	LSH A,-5
	MOVEM A,RLMNB1
	HRRZ A,RLMC5(10)	; THEN THE SURFACE AND RECORD
	ANDI A,777		; JUST THOSE, FLUSH CYLINDER.
	ADDI A,1		; AND ACCT FOR FIRST REC BEING 1 NOT 0.
	ROTC A,-NSECBT
	ROT A,^D8-NSECBT
	ROTC A,NSECBT
	ROT A,^D12		; TO RIGHT POSITION FOR SEARCH SECTOR ID
	MOVEM A,RLMNB1+1
	HRRM 11,RLMNB2		; THE CORE ADDRESS BEING READ INTO
	MOVSI A,(TCH)		; SET LOW CORE TO GO
	HRRI A,RLMNB		; TO THIS CHANNEL PROGRAM
	MOVEM A,SSABAS+<4*SSADC>
	CONO SSA,SA.STS+<SSADC>B32	; CLEAR ANY PREV DONE FLAG
	CONO SSA,SA.GOF+SA.SET+<SSADC>B32	; MAKE IT READ
	CONSZ SSA,SA.MPE!SA.NXM	; DISASTER?
	JRST 4,RLMGO		; YES.
	CONSO SSA,1B<^D29+SSADC>	; DONE?
	JRST .-3		; NOT YET.
	MOVE A,SSABAS+<4*SSADC>+1	; GET COMPLETION STATUS
	TLC A,(<ID.DVE+ID.CHE>B15)	; THESE SHOULD BE ON, REST OFF.
	TLNE A,177774		; ALL CORRECT?
	JRST 4,RLMGO		; NO.
	TRZ 11,777		; GOOD. ON TO NEXT PAGE
	ADDI 11,1000		; ..
	AOBJN 10,RLMG2		; READ ALL PAGES NEEDED
	AOS GETSMF
	JRST 0(7)		; RETURN TO DDT OR CALLER.

RLMNB:	;SIMPLE CHANNEL PROGRAM TO READ ONE PAGE FROM DISK.
	; THIS PROGRAM IS IMPURE -- MODIFIED ABOVE.

	BYTE (8)70,IC.SEK,I.DDEV	; ISSUE SEEK TO CYLINDER
	BYTE (WCSZ)-6(ADSZ)RLMNB1	; SIX BYTES FROM BUFFER 1
	BYTE (8)71,IC.SIE,I.DDEV	; SEARCH FOR RECORD
	BYTE (WCSZ)-5(ADSZ)RLMNB1	; ARG TO SEARCH FOR
	TCH+.-2				; IF SEARCH FAILS, LOOP.
	BYTE (8)60,IC.RDD,I.DDEV	; READ FROM DISK
RLMNB2:	BYTE (WCSZ)-1000(ADSZ).-.	; ONE PAGE, ADDRESS PLUGGED IN.
	0				; END OF CHANNEL PROGRAM

RLMNB1:	0				; 00CC
	0				; HHRX

	DEPHASE
RLRMX1:
> ; END OF RLRMON FOR 3330'S
	LIST		;CONTINUE LISTING

RLRMSZ==400	;MINIMUM SIZE BECAUSE TENDMP CAN'T LOAD 1 BLOCK FILES
	IFG <RLRMX1-RLMX0-RLRMSZ>,<RLRMSZ==RLRMX1-RLMX0>
	IFG <RLRMSZ-1000>,<PRINTX <RELOAD MONITOR ROUTINE EXCEEDS 1 PAGE - CODE WON'T WORK>>

;STAND-ALONE ROUTINE TO DUMP CORE TO DISK NON-DESTRUCTIVELY
;CALLED BY JSR CRASH
;RETURNS +1 IF DISK CONTROLLER NOT AVAILABLE AFTER SOME TIME
;	+2 IF UNRECOVERABLE HARDWARE ERROR IS ENCOUNTERED
;	+3 IF DUMP SUCCESSFULLY WRITTEN

LS CRASH,2
LS CRACS,20			;ACS AT CRASH
LS DF10CW,2			;CONTROL WORDS FOR DF10
LS CRSTK,NCRSTK			;LOCAL PDL
NCRSTK==10
LS CRERR,1			;STATUS BITS IF ERROR DETECTED

DUMP==:JSR+CRASH		;USED TO INVOKE DUMP ROUTINE

CRASH1:	MOVEM 17,CRACS+17	;STASH ACS
	MOVEI 17,CRACS
	BLT 17,CRACS+16

;CONTROLLER AVAILABLE?
	MOVE	A,[DSKCMA]	;ADDRESS FOR DUMMY CALL TO GET CONTROLLER OF INTEREST
	CALL	CVDSK		;GET CONTROLLER AND UNIT
	LSH	A,-^D18		;ISOLATE CONTROLLER AND UNIT
	TRZ	A,10		;TURN OFF CONTROLLER BIT
	MOVSI B,2
	SKIPGE DSKLUN(DSK)
	 JRST .+3		;ITS AVAILABLE, PROCEED.
	SOJG B,.-2		;NOT AVAILABLE, TRY AGAIN.
	 JRST CRRACS		;TRIED HARD ENOUGH, RETURN.

;SAVE CURRENT STATE OF PI AND THEN TURN IT OFF
	CONI PI,16
	PIOFF

	AOS CRASH		;WE WILL AT LEAST RETURN +2

	MOVE 17,[IOWD NCRSTK,CRSTK]	;SET UP LOCAL STACK

	PUSH 17,@DSKCP(DSK)		;SAVE OLD DSK ICWD ADDRESS
	MOVEI 15,DF10CW		;SET UP NEW ONE
	MOVEM 15,@DSKCP(DSK)

	MOVNI 15,1000*NPGTK	;SET UP DF10 IOWD COUNT
	HRLM 15,DF10CW
	MOVSI D,-NCRTRK		;AOBJN POINTER FOR CORE SWEEP
	MOVE C,[DSKCMA]		;ADDRESS OF CRASH AREA (IN SECTORS)
CRLOOP:	PUSH	P,A		;SAVE UNIT FOR TRANSFER
	MOVE A,C
	CALL CVDSK		;GET UNIT,,HARDWARE ADDRESS
	MOVE	B,A		;SET UP DISK ADDRESS FOR WDSK
	POP	P,A		;SET UP UNIT FOR WDSK
	PUSH	P,D
	IMULI	D,^D50		;FORM CYLINDER ADDRESS
	CALL WDSK		;WRITE THE PAGE
	POP	P,D
	ADDI C,NSECTK		;STEP TO NEXT DISK CYLINDER
	AOBJN D,CRLOOP		;AND NEXT GROUP OF CORES PAGE, IF ANY

	AOS CRASH		;INDICATE SUCCESSFUL

CRRPI:
IFNDEF SSADF,<
	POP 17,@DSKCP(DSK)>		;RESTORE DSKCP
	ANDI 16,1B28		;AND RESTORE PI
	CONO PI,0(16)

;RESTORE ACS
CRRACS:	MOVSI 17,CRACS
	BLT 17,16
	MOVE 17,CRACS+17
	JRST @CRASH		;AND RETURN

	XLIST		;SUPPRESS LISTING OF DC10 CODE ***SRI-AIC***

IFDEF DC10F,<
;WDSK ROUTINE FOR DC10
WDSK:	HLRZ 5,1		;GET UNIT
	ADDI 5,1		;+1 (CONTROLLER IS 0)
	HRRZS 1			;CLEAR LEFT HALF

	LSH A,^D35-ADRPOS	;GET DISK ADDRESS INTO CORRECT POSITION
	LSH 5,^D9		;DO SAME TO UNIT
	IOR A,DSKWDA		;WRITE COMMAND
	IORI A,(5)		;STUFF IN UNIT

;SET UP CONTROL WORD FOR DF10
	PUSH P,2
	LSH B,^D9		;TURN PAGE NO. INTO ADDRESS
	SUBI B,1		;LESS 1
	HRRM B,DF10CW		;ADDR-1 TO IOWD
	POP P,2
	SETZM DF10CW+1	;MAKE SURE DF10 STOPS

;SEE IF DESIRED UNIT IS ALIVE AND WELL
	CONO DSK,DSKCHN(5)	;SELECT UNIT
	CONI DSK,15		;READ STATUS
	TLNE 15,(1B12!1B14!1B15)	;OFFLINE,UNSAFE, OR WRITE PROTECTED?
	 JRST WDSKQ		;YES, QUIT

;DEVICE SEEMS OKAY, ATTEMPT DATA TRANSFER
	MOVEI D,DSKNTR		;RETRY COUNT IF ERROR

WDSK2:	DATAO DSK,1		;ISSUE WRITE COMMAND
	CONSZ DSK,DCBSY		;WAIT TIL CONTROLLER NOT BUSY
	 JRST .-1

	CONSO DSK,640000	;ANY ERRORS?
	 RET			;NO, RETURN

;ERROR OCCURRED. SEE IF IT IS A NXM
	CONI DSK,15
	TLNE 15,(1B2)		;NXM?
	 RET			;YES, THAT'S OK, JUST RETURN

	SOJG D,WDSK2		;TRY AGAIN

;UNRECOVERABLE ERROR
WDSKQ:	MOVEM 15,CRERR		;SAVE STATUS BITS
	SUB 17,BHC+1		;BACK UP STACK POINTER
	JRST CRRPI		;AND EXIT

;END OF WDSK FOR DC10
>
	LIST		;CONTINUE LISTING

IFDEF RP02F,<
;WDSK ROUTINE FOR RP02
WDSK:	LSH B,^D12		;GET ADDRESS TO PROPER POSITION
	TLZ	B,100000	;TURN OFF CONTROLLER BIT
	TLO B,SEEK		;POSITION HEADS COMMAND
	XCT	DSKO(DSK)	;ISSUE COMMAND
	ROTC 5,^D72		;DELAY
WDSK2:	XCT	DSKI0(DSK)	;GET STATUS
	TLNN 0,(1B11!1B16)	;POSITION FAILURE OR READONLY?
	TLNN 0,(1B13)		;OR NOT ONLINE?
	 JRST WDSKQ		;QUIT
	TLNN 0,(1B12)		;IN POSITION?
	 JRST WDSK2		;NOT YET, KEEP TRYING
	TLO	B,(5B2)		;TURN SEEK INTO CLEAR ATTENTION
	PUSH	P,B
	XCT	IORATN(DSK)	;SET CLEAR ATTENTION BIT FOR UNIT SPECIFIED IN A
	XCT	DSKO(DSK)	;CLEAR ATTENTION
	POP	P,B
	PUSH P,D		;SET UP IOWD FOR DF10
	LSH D,^D9		;FORM PAGE ADDRESS
	SUBI D,1
	HRRM D,DF10CW		;CORE ADDRESS -1
	SETZM DF10CW+1
	POP P,D			;RESTORE PAGE NUMBER
;ATTEMPT DATA TRANSFER
	TLZ B,(4B2)		;TURN SEEK INTO WRITE
	IOR B,DSKCP(DSK)		;INIT CW ADDRESS
	MOVEI 6,DSKNTR		;RETRY COUNT
WDSK3:	XCT	DSKO(DSK)	;ISSUE COMMAND
	XCT	DSKS1(DSK)	;WAIT TILL BUSY OFF
	XCT	DSKS2(DSK)	;AND DONE ON
	JRST .-2
	XCT	DSKCN0(DSK)	;GET STATUS
	XCT	DSKC4(DSK)	;AND CLEAR FLAGS
	TDNN 0,[17,,147700]	;TEST FOR ERRORS EXCEPT NXM AND DATA LATE
	 RET			;NO ERRORS, RETURN
	SOJG 6,WDSK3		;TRY AGAIN
WDSKQ:	MOVEM 0,CRERR		;SAVE STATUS
	SUB 17,BHC+2		;BUCKUP PAST RETURN ADDRESS AND SAVE OF D
	JRST CRRPI		;EXIT

;END OF WDSK FOR RP02
>
IFDEF SSADF,<			; NOT YET WRITTEN
WDSK:	JRST CRRPI		; SO GIVE FAIL RETURN
>

;CONVERT LINEAR ADDRESS TO HARDWARE DISK ADDRESS
;OUTPUT IN AC 1
;     DDDCCCCCCCCHHHHHSSSSS
;     111112222222222333333
;     567890123456789012345
;		WHERE D=DRIVE,C=CYLINDER OR TRACK
;		      H=HEAD OR SURFACE  , S=SECTOR

CVDSK:	TLZ A,DSKMSK		;FLUSH EXTRA BITS
	IDIVI A,NSECTK		;GET TRACK, SECTORS
	PUSH P,2		; SAVE SECTOR AND SURFACE
	IDIVI A,NTKUN		;GIVES DRIVE NO IN A, TRACK IN 2
	LSH B,^D18-NCYLBT	;TRACK TO BITS 18-XX
	HRL B,DRIVTB(A)		;PHYS. DRIV NO FOR TRK GROUP TO B15-17
	HLRZ	DSK,B		;GET CONTROLLER AND UNIT
	LSH	DSK,-3		;ISOLATE CONTROLLER
	POP P,1			; GET BACK SECTOR AND SURFACE
	PUSH P,2		; SAVE DRIVE,,<CYL_N>
	IDIVI A,NSECS		;GET SURFACE, SECTOR
	LSH A,NSECBT		;SURFACE TO B26-30
	IORI A,0(B)		;WITH SECTOR IN B31-35
	POP P,2			;RECOVER DRIVE AND TRACK
	IOR A,2			;MERGE ALL FIELDS
	RET			; DRIVE,,(9)CYL(5)SURF(4)SEC IF 215, 230

;CONVERT HARDWARE FORMAT TO LINEAR ADDRESS

CDSKVA:	HLRZ B,1		;14-17 IS DRIVE AND CONTROLLER
	ANDI B,17
	HLRZ C,DRIVTB(B)	;GET CORRESPONDING TRACK GROUP NO
	IMULI C,NTKUN		;FIRST OF THIS GROUP OF TRACKS
	LDB B,[POINT NCYLBT,A,17+NCYLBT]	;18-25 IS TRACK ON SPECIFIED DRIVE
	ADDI C,0(B)		;NOW HAVE ACTUAL TRACK NUMBER
	IMULI C,NSECTK		;COMPUTE SECTOR NUMBER
	LDB B,[POINT 5,A,35-NSECBT]	;26-30 IS SURFACE
	IMULI B,NSECS		;FIRST SECTOR THIS SURFACE
	ANDI A,<1_NSECBT>-1	;31-35 IS SECTOR
	ADDI A,0(B)		;TOTAL SECTORS
	ADD A,3
	RET

;TABLE FOR CONVERSION BETWEEN PHYSICAL DRIVE NUMBERS AND INTERNAL
;TRACK GROUPS NUMBERS.  INDEXED BY INTERNAL, RH GIVES PHYSICAL.
;INDEXED BY PHYSICAL, LH GIVES INTERNAL

DRIVTB:	XWD 0,0
	XWD 1,1
	XWD 2,2
	XWD 3,3
	XWD 4,4
	XWD 5,5
	XWD 6,6
	XWD 7,7
	0
	0
	0
	0
	0
	0
	0
	0

;				BEGIN ********SRI-AIC********

;CODE TO LOCK AND RELEASE THE DF10

;LOCK DF10.  NO PARAMETERS NEEDED, NO REGISTERS DISTROYED.
;DON'T CALL UNDER NOSKED, BECAUSE THIS CODE CAN DISMISS YOU.
;RETURNS LEAVING CALLER IN NOSKED.
;NOTE ... THE ABOVE MAY BE CHANGED IF THE CONTROLLER IS MODIFIED SO THAT
;IT GOES AND STAYS BUSY WHILE THE PICTURE IS BEING TAKEN.

GTDF10:	PUSH P,4
	PUSH P,1
GTCHN1:	MOVE 1,JOBNO	;GET LOCKING JOB
	NOSKED
	
	SKIPE DF10LK	;SKIP IF DISK HAS DF10
	CAMN 1,DF10LK	;NO SKIP IF CALLER HAS DF10
	JRST GTCHN2	;DISK HAS IT

	OKSKED		;SOMEONE ELSE HAS IT
	MOVEI 1,DF10LK	;WAIT
	CALL DISLE	;UNITL IT IS RELEASED TO DISK
	JRST GTCHN1

GTCHN2:	JSP 4,GTDFTS	;TEST
	CAIA
	JRST GTCHN4	;NO. GO
	OKSKED		;YES, WAIT
	MOVEI 1,GTDFTS	;TEST ROUTINE ADR
	JSYS EDISMS
	JRST GTCHN1	;TRY AGAIN

GTCHN4:	MOVE 1,JOBNO	;REGAIN JOB NO.
	CHNOFF DSKCHN	;TURN DISK PI OFF
	SKIPG	DSKLUN
	SKIPL DSKLUN+1	;NO SKIP IF XFER IN PROGRESS
	JRST GTCHN3	;MUST WAIT FOR XFER COMPLETE
	MOVEM 1,DF10LK	;OK, SET LOCK
	CHNON DSKCHN
	POP P,1		;RETURN
	POP P,4
	RET

GTCHN3:	CHNON DSKCHN
	OKSKED		;WAIT ON TRANSFER COMPLETE
	MOVEI 1,DSKLUN	;WORD TO BE TESTED
	SKIPG	DSKLUN		;CONTROLLER 0
	MOVEI	1,DSKLUN+1	;NO
	CALL DISL	;WAIT
	JRST GTCHN1	;TRY AGAIN



;	TEST FOR NO SEEK IN PROGRESS

GTDFTS:	MOVSI 1,-NDVMAX	;COUNTER
	SKIPE DSKLSV(1)
	JRST 0(4)	;SOMEONE'S STILL TRYING
	AOBJN 1,.-2	;TRY THE NEXT ONE
	JRST 1(4)	;OK, EXIT


;RELEASE DF10,  MUST BE CALLED JY SAME JOB THAT LOCKED IT
;NO PARAMETERS, NO REGISTERS DISTROYED
;ASSUMED NOSKED ON CALL, RETURNS OKSKED

RLDF10:	PUSH P,1	;SAVE THINGS
	PUSH P,2
	PUSH P,3
	PUSH P,DSK
	MOVE 1,JOBNO	;GET THIS GUY'S NUMBER
	CAME 1,DF10LK	;IS IT THE SAME GUY?
	JRST RLCHN2	;NO, BAD CALL

	CHNOFF DSKCHN	;TURN OFF THE DF10
	SETZM DF10LK	;UNLOCK THE DF10
	SETZ DSK,	;SET CONTROLLER TO ZERO FOR TV CONTROLLER
	CALL DFTGO	;RESTART DISK IF ANYTHING TO DO
	JFCL		;IGNORE SKIPS			
	CHNON DSKCHN	;REENABLE PI'S

RLCHN1:	OKSKED
	POP P,DSK
	POP P,3	;RESTORE THINGS
	POP P,2
	POP P,1
	RET

RLCHN2:	BUG(CHK,<RLDF10: ATTEMPT TO DEASSIGN DF10 WHEN NOT ASSIGNED>)	;****SRI-AIC***
	JRST RLCHN1	;EXIT
;				END  *****SRI-AIC*****
	END
