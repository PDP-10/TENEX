;<133-TENEX>IO.MAC;6    13-MAR-75 08:28:31    EDIT BY UNTULIS
;ADD NAME STRING CHECK TO DMPMEM CODE FOR LP1 DUMPO.
;<133-TENEX>IO.MAC;5     6-MAR-75 09:01:24    EDIT BY UNTULIS
;ELIMINATE MODE CHECK IN DUMPO
;<133-TENEX>IO.MAC;3     3-JAN-75 16:20:09    EDIT BY UNTULIS
;ADD BBN CHANGES TO IO.MAC TO OUR IO.MAC FOR 133
;LCKTST,REDEFINE BYTREM,BYTSIZ, ANDTRMBYT
;ALSO CHANGE MOVN AT SIOR24 TO MOVNS E
;<132>IO.MAC;6     1-NOV-74 10:48:32    EDIT BY UNTULIS
;PUT LIMIT ON DMPNXT LOOP
;<TENEX-132>IO.MAC;81    19-JUN-74 12:55:01    EDIT BY TOMLINSON
; FIXED FAST SIN BUG WITH 0 AC3 (FAILED TO COUNT FINAL BYTE)
; REMOVED NULL SUPPRESSOR FROM BYTIN
;<TENEX-132>IO.MAC;80    14-MAY-74 09:02:02    EDIT BY TOMLINSON
; INTERNED DOINT FOR FILE INTERRUPTS
;<TENEX-132>IO.MAC;79    17-APR-74 21:42:42	EDIT BY TOMLINSON
; MISSING JRST EDESX1 AFTER PUSHJ P,FIXPTR IN PSOUT
;<TENEX-132>IO.MAC;78    16-APR-74 15:52:48	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;77    16-APR-74 14:19:25	EDIT BY TOMLINSON
; INSTALL CHECKS FOR INDIRECTION/INDEXING OF BYTE POINTERS
;<TENEX-132>IO.MAC;76    15-APR-74 13:11:47	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;75     1-APR-74 20:30:01	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;74     1-APR-74 19:53:25	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;73     1-APR-74 19:21:15	EDIT BY TOMLINSON
; CONVERTED CHKJFN TO RETURN DOUBLE SKIP FOR NIL DESIGNATOR
;<TENEX-132>IO.MAC;72     1-APR-74 19:03:08	EDIT BY TOMLINSON
; ALLOW RADIX UP TO 36 FOR NIN
;<TENEX-132>IO.MAC;71    25-NOV-73 23:23:48	EDIT BY CLEMENTS
; YET ANOTHER FIX TO NO FREE 0 ON END OF -N TYPE SIN
;<TENEX-132>IO.MAC;70    10-NOV-73 20:01:14	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;69    10-NOV-73 14:34:14	EDIT BY CLEMENTS
; KI CHANGES, SMALL BUG FIXES
;<TENEX-132>IO.MAC;68    13-JUN-73 21:12:19	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;67     9-APR-73 16:11:23	EDIT BY TOMLINSON
; FIXED NEG WORD COUNT SIN TO NOT APPEND 0 BYTE
;<TENEX-132>IO.MAC;66     3-APR-73 18:04:30	EDIT BY PLUMMER
;<TENEX-132>IO.MAC;65    12-MAR-73 13:16:25	EDIT BY TOMLINSON
; Fix BYTBL1 to leave unused bits 0
;<TENEX-132>IO.MAC;63     6-MAR-73 12:59:49	EDIT BY TOMLINSON
; MISC FIXES TO SIN/SOUT
;<TENEX-132>IO.MAC;62    23-FEB-73 18:03:51	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;61    22-FEB-73 18:45:00	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;60    13-FEB-73 19:58:17	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;57    26-JAN-73 08:45:16	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;56    24-JAN-73 22:42:43	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;55    24-JAN-73 16:07:56	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;54    24-JAN-73 14:40:10	EDIT BY TOMLINSON
;<TENEX-MON>IO.MAC;14     1-AUG-74 17:42:13	EDIT BY KREMERS
;FIXED COPY-ON-WRITE PROBLEM IN DMPCKA
;<TENEX-MON>IO.MAC;13    12-JUN-74 17:21:00	EDIT BY KREMERS
;FIX GLITCH IN RLIOWD WHICH NEGATED IOWCNT
;<TENEX-MON>IO.MAC;12     1-MAY-74 03:33:54	EDIT BY KREMERS
;<TENEX-MON>IO.MAC;11    18-APR-74 00:16:44	EDIT BY KREMERS
;<TENEX-MON>IO.MAC;10    17-APR-74 05:38:46	EDIT BY KREMERS
;<TENEX-MON>IO.MAC;9    17-APR-74 02:25:23	EDIT BY KREMERS
;<TENEX-MON>IO.MAC;8    10-APR-74 17:03:05	EDIT BY KREMERS
;<TENEX-MON>IO.MAC;7     9-APR-74 20:36:34	EDIT BY KREMERS
;<TENEX-MON>IO.MAC;6     9-APR-74 20:28:59	EDIT BY KREMERS
;<TENEX-MON>IO.MAC;5     9-APR-74 17:08:41	EDIT BY KREMERS
;MODIFY SIN/SOUT TO KILL ERRIOUNIOUS 0 APPEND
;<KREMERS>IO.MAC;13     9-APR-74 16:53:12	EDIT BY KREMERS
;<KREMERS>IO.MAC;12     9-APR-74 04:39:32	EDIT BY KREMERS
;<KREMERS>IO.MAC;11     5-APR-74 04:23:08	EDIT BY KREMERS
;<KREMERS>IO.MAC;9    18-JAN-74 16:11:04	EDIT BY KREMERS
;<KREMERS>IO.MAC;8    15-JAN-74 15:34:53	EDIT BY KREMERS
;<KREMERS>IO.MAC;7    15-JAN-74 15:26:14	EDIT BY KREMERS
;<KREMERS>IO.MAC;6    15-JAN-74 05:02:17	EDIT BY KREMERS
;<KREMERS>IO.MAC;5    14-JAN-74 21:53:09	EDIT BY KREMERS
;<KREMERS>IO.MAC;4    14-JAN-74 21:16:47	EDIT BY KREMERS
;<KREMERS>IO.MAC;3    14-JAN-74 20:47:45	EDIT BY KREMERS
;ADDED PAGE LOCKING AND ACCESS CHECKING STUFF FOR DUMPIO
;<TENEX-MON>IO.MAC;2    13-DEC-73 15:40:06	EDIT BY KREMERS
;<TENEX-132>IO.MAC;68    13-JUN-73 21:12:19	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;67     9-APR-73 16:11:23	EDIT BY TOMLINSON
; FIXED NEG WORD COUNT SIN TO NOT APPEND 0 BYTE
;<TENEX-132>IO.MAC;66     3-APR-73 18:04:30	EDIT BY PLUMMER
;<TENEX-132>IO.MAC;65    12-MAR-73 13:16:25	EDIT BY TOMLINSON
; Fix BYTBL1 to leave unused bits 0
;<TENEX-132>IO.MAC;63     6-MAR-73 12:59:49	EDIT BY TOMLINSON
; MISC FIXES TO SIN/SOUT
;<TENEX-132>IO.MAC;62    23-FEB-73 18:03:51	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;61    22-FEB-73 18:45:00	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;60    13-FEB-73 19:58:17	EDIT BY CLEMENTS
;<TENEX-132>IO.MAC;57    26-JAN-73 08:45:16	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;56    24-JAN-73 22:42:43	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;55    24-JAN-73 16:07:56	EDIT BY TOMLINSON
;<TENEX-132>IO.MAC;54    24-JAN-73 14:40:10	EDIT BY TOMLINSON
;<TENEX-131>IO.MAC;53    10-JAN-73 11:00:09	EDIT BY TOMLINSON
;<TENEX-131>IO.MAC;52     9-JAN-73 14:36:18	EDIT BY TOMLINSON
; FIXED DUMPI/O LOCKUP BUG
;<TENEX-130>IO.MAC;51    20-NOV-72 13:14:45	EDIT BY TOMLINSON
; ADDED OPNF CHECK IN RIN
;<FILESYSTEM>IO.MAC;50    25-AUG-72 17:38:36	EDIT BY TOMLINSON
;<FILESYSTEM>IO.MAC;49    25-AUG-72 16:08:17	EDIT BY TOMLINSON
;<FILESYSTEM>IO.MAC;48    25-AUG-72 15:45:03	EDIT BY TOMLINSON
;<FILESYSTEM>IO.MAC;47    29-JUN-72  9:59:08	EDIT BY TOMLINSON

	SEARCH	FILEDEF,STENEX
	TITLE	IO
	SUBTTL	R.S.Tomlinson

EXTERN	CPOPJ,SKPRET,SK2RET,SK3RET
EXTERN	PBYTSZ,PBYTPO
EXTERN	EDISMS,ERRD,FKHPTN,FPTA,MJRSTF,MLKPG,MRPT,MULKPG,SKIIF,BHC
EXTERN MLKMA						
EXTERN	NILDTB,STRDTB,TTYDTB,SFBNR,STRDEV,PBYTSZ

	USE	SWAPPC

DEFINE	FILINT(N,EXTRA)<
PUSHJ P,[EXTRA
	MOVEI A,N
	JRST DOINT]>

DEFINE	FILABT(N,EXTRA)<
JRST [	EXTRA
	MOVEI A,N
	JRST ABTDO]>

DOINT::	MOVEM JFN,ERRSAV
	MOVEM A,LSTERR
	TEST(NE,HLTF)
	JRST ABTDO		; Halt on these conditions
	MOVEI 1,400000
	MOVSI 2,(1B11)
	IIC
	POPJ P,

ABTDO:	MOVEM A,LSTERR
	PUSHJ P,UNLCKF
	JRST ITRAP

; Check tenex source/destination designator
; Call:	JFN		; The designator
;	PUSHJ P,CHKJFN
; Return
;	+1	; Error, as has error #
;	+2	; Tty
;	+3	; Byte pointer, or other special designator type (e.g. NIL:)
;	+4	; File
; In all cases, the following is set up
;	LH(DEV)	; Unit number (tty no dta no etc)
;	RH(DEV)	; Loc of device dispatch table
;	JFN	; True jfn for files, byte pointer for same
;	STS	; File status bits
; The file is locked if it is a file


CHKJFN::SETZB F,F1
	TLNE JFN,777777		; Lh zero?
	JRST CHKJF1		; No, some kind of byte pointer
	CAIN JFN,100		; Primary input designator?
	HLRZ JFN,PRIMRY		; Get primary input jfn from psb
	CAIN JFN,101		; Primary output designator?
	HRRZ JFN,PRIMRY		; Get primary output jfn from psb
	CAMGE JFN,MAXJFN	; Possibly a jfn?
	JRST CHKJF3		; Yes
	CAIN JFN,777777		; Controlling tty
	JRST CHKJF4		; Yes
	CAIN JFN,377777		; Nil designator
	 JRST CHKJFW		; Yes.
	CAIGE JFN,400000+NLINES	; Valid tty designator?
	CAIGE JFN,400000
	JRST CHKJF7		; No, garbage designator
	HLRZ DEV,TTFORK-400000(JFN)	; Get assignment of tty
	CAIE DEV,777777		; Unattached?
	CAMN DEV,JOBNO		; Or assigned to this job?
	JRST CHKJF5		; Yes, ok to use
	MOVE A,CAPENB
	TRNE A,WHEEL!OPR
	JRST CHKJF5
IFN NPTY,< ; PARTIAL CODE FOR PTY'S - NOT YET SUPPORTED
	SUBI JFN,400000+PTYLO	;SEE IF DEV DESIG IS A PTY
	CAIL JFN,0		;RANGE CHECK
	CAIL JFN,NPTY		; ..
	JRST CHKJF0		;NO. GIVE UP
	MOVE DEV,PTYJOB##(JFN)	;YES. SEE IF THIS JOB OWNS IT.
	ADDI JFN,400000+PTYLO	;RESTORE JFN TO TTY DESIGNATOR
	CAMN DEV,JOBNO
	JRST CHKJF5		;JOB MATCHES. ACCEPT THIS DESIGNATOR
>;END COND ON NPTY
CHKJF0:	MOVEI A,DESX2		; Illegal tty designator
	POPJ P,

CHKJF4:	MOVE A,JOBNO
	MOVEI A,JOBPT(A)
	SKIPGE DEV,(A)
	PUSHJ P,DISGE		; Dismiss until it is greater or equal
	SKIPGE DEV,(A)
	JRST CHKJF4
	HLRZS DEV
	MOVEI JFN,400000(DEV)
CHKJF5:	MOVEI DEV,TTYDTB	; Set up dev to be tty
	HRLI DEV,-400000(JFN)	; And the proper unit
	HRLZI STS,READF!WRTF!OPNF
	JRST SKPRET		; Skip return

CHKJFW:	MOVEI DEV,NILDTB
	HRLZI STS,READF!WRTF!OPNF
	JRST SK2RET

CHKJF3:	LSH JFN,SJFN
	MOVEI A,^D60		; Try 60 times to lock file
CHKJF2:	SOJL A,CHKJFB		; Then fail
	NOINT
	AOSE FILLCK(JFN)
	 JRST [	OKINT
		PUSH P,A
		MOVEI A,^D1000
		DISMS
		POP P,A
		JRST CHKJF2]
	MOVE STS,FILSTS(JFN)
	TEST(NN,NAMEF)
	JRST CHKJF8
	TEST(NN,FRKF)		; Test for file restricted to one fork
	JRST CHKJF9
	HLRZ A,FILVER(JFN)
	PUSHJ P,SKIIF
	JRST CHKJF8		; Can't access
CHKJF9:	MOVE DEV,FILDEV(JFN)	; Set up dev
	HRRZ A,DEV
	CAIN A,TTYDTB
	 JRST [	SETOM FILLCK(JFN)
		OKINT
		JRST .+1]
	JRST SK3RET		; Triple skip return

CHKJF8:	UNLOCK FILLCK(JFN)
	OKINT
CHKJFB:	MOVEI A,DESX3
	POPJ P,

CHKJF1:	MOVE A,JFN
	CALL FIXPTR
	 JRST CHKJF7		; BAD DESIGNATOR
	MOVEM A,JFN
	MOVEI DEV,STRDEV	; Set up to dispatch to string routines
	HRLZI STS,READF!WRTF!OPNF
	JRST SK2RET		; Double skip return

CHKJF7:	MOVEI A,DESX1		; Garbage designator
	POPJ P,

; Unlock file
; Call:	JFN	; Job file number
;	STS	; New filsts
;	PUSHJ P,UNLCKF

UNLCKF::TLNE JFN,777777
	UMOVEM JFN,1
	CAIL JFN,0
	CAIL JFN,RJFN
	POPJ P,
	HLLM STS,FILSTS(JFN)
	PUSH P,A
	MOVEI A,(DEV)
	CAIN A,TTYDTB
	 JRST [	POP P,A
		POPJ P,]
	POP P,A
	SETOM FILLCK(JFN)
	OKINT
	POPJ P,

NOTOPN:	FILABT CLSX1

EDESX1:	MOVEI A,DESX1
IOERR::	MOVEM A,LSTERR
	JRST ITRAP

; Bin from primary io file
; Call:	1	; Character
;	PBIN

.PBIN::	JSYS MENTR
	MOVEI JFN,100
	PUSHJ P,BYTIN
	UMOVEM B,1
	JRST MRETN

; Byte input jsys
; Call:	1	; Tenex source designator
;	BIN
; Return
;	+1
;	B	; A byte

PS(BIOAC0)

.BIN::	NOINT
	JUMPL 1,SLBIN
	CAML 1,MAXJFN		; Possible a jfn?
	JRST SLBIN
	LSH 1,SJFN
	AOSE FILLCK(1)
	JRST SLBIN0
	MOVE 2,FILSTS(1)
	TLC 2,OPNF!READF
	TLCN 2,OPNF!READF
	TLNE 2,ERRF!FRKF
	JRST SLBIN1
	SOSGE FILCNT(1)
	JRST SLBIN2
	AOS 2,FILBYN(1)
	CAMLE 2,FILLEN(1)
	JRST SLBIN3
	ILDB 2,FILBYT(1)
	SETOM FILLCK(1)
	LSH 1,-SJFN
	OKINT
	XCT MJRSTF

SLBIN3:	SOS FILBYN(1)
SLBIN2:	AOS FILCNT(1)
SLBIN1:	SETOM FILLCK(1)
SLBIN0:	LSH 1,-SJFN
SLBIN:	OKINT
	JSYS MENTR		; Become slow etc.
	MOVE JFN,1
	PUSHJ P,BYTIN		; Read the byte
	XCTUU [MOVEM B,2]	; Store in user's ac
	JRST MRETN		; Restore user ac's and return

; Random input jsys
; Call:	1	; Tenex source designator
;	3	; Byte number
;	RIN
; Returns
;	+1
;	2	; The byte

.RIN::	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	JRST IOERR
	JFCL
	FILABT DESX4		; Tty and byte designators are illegal
	JUMPGE STS,NOTOPN
	TEST(NN,RNDF)
	FILABT IOX3		; Illegal to change pointer
	TEST(NN,READF)
	FILABT IOX1		; Illegal to read
	UMOVE A,3
	PUSHJ P,SFBNR		; Set up byte pointer
	JRST ABTDO
	PUSHJ P,BYTINA		; Get the byte
	UMOVEM B,2
	JRST MRETN

; String input jsys
; Call:	1	; Tenex source designator
;	2	; Byte pointer (lh = 777777 will be filled in)
;	3	; Byte count or zero
;		; If zero, the a zero byte terminates
;		; If positive then transfer the specified number
;		; Of characters, or terminate on reading a byte
;		; Equal to that given in 4
;		; If negative, then transfer the specified number
;		; Of bytes
;	4	; (optional) if 3 is > 0, 4 has a terminating byte
;	SIN
; Return
;	+1	; Always
;	2	; Updated string pointer
;	3	; Updated count (always counts toward zero)
; The updated string pointer always points to the last byte read
; Unless 3 contained zero, then it points to the last non-zero byte.

.SIN::	JSYS MENTR		; Become slow etc.
SIN0:	UMOVE JFN,1
	CAIN JFN,100
	 JRST SINOOO		; DO IT THIS WAY TO GET ECHOOS DONE
	PUSHJ P,SIOR1		; CHECK JFN ETC
	 JRST SINTTY		; TTY
	 JRST [	CAIE DEV,STRDTB
		 JRST .+1
		JRST SINBYT]	; BYTE POINTER
	TEST(NN,READF)
	 FILABT(IOX1)		; ILLEGAL READ
	SKIPG FILCNT(JFN)	; ANY BYTES IN BUFFER?
	 JRST SINOLD		; NO, DO IT THE SLOW WAY
	MOVE A,FILBYT(JFN)	; SOURCE POINTER
	UMOVE B,2		; TARGET
	MOVE D,[1B3+1]		; FROM FILE, TO USER.
	PUSHJ P,SIOR2		; SET UP REST OF ARGS AND DO BYTBLT
	UMOVEM B,2		; UPDATE POINTERS
	MOVEM A,FILBYT(JFN)
	PUSHJ P,UNLCKF		; UNLOCK FILE TO ALLOW INTS
	JUMPN D,SIN0		; DO MORE IF NOT DONE
	JUMPN E,MRETN		; IF NON-ZERO COUNT SUPPLIED, NO 0.
	JRST SIN2		; PUT THE ZERO ON THE END.

; DO SIN FROM BYTE POINTER

SINBYT:	MOVE A,JFN
	UMOVE B,2
	MOVE D,[1B2+3]		; BYTE POINTER AND USER TO USER
	PUSHJ P,SIOR2
	UMOVEM B,2
	UMOVEM A,1
	JRST SIN3

; DO SLOW SIN FOR ONE BYTE

SINOOO:	UMOVE A,2
	PUSHJ P,FIXPTR		; FIX UP POINTER
	 JRST EDESX1
	UMOVEM A,2
	PUSHJ P,BYTIN
	JRST SINOL1

SINTTY:
SINOLD:	PUSHJ P,BYTINA		; Read a byte from the source
SINOL1:	JUMPE B,[TEST(NN,EOFF)
		XCTUU [SKIPN 3]
		JRST SIN2
		JRST .+1]
IFN KAFLG,<
	XCTUU [IDPB B,2]>	; Deposit the byte
IFN KIFLG,<			; ON KI-10, MUST HANDLE WITH
	XCTUU [MOVE 3,2]	;  THE POINTER IN MONITOR SPACE
	TLNE 3,37		; AND INDIRECTING/INDEXING
	FILABT DESX1		;  DOESN'T WORK
	XCTUU [IDPB B,3]	; OK. STORE THE BYTE
	XCTUU [MOVEM 3,2]	; RETURN UPDATED POINTER
>
	JSP A,SIONXT		; Test for end of string
	JRST SIN0		; Not end, continue

SIN3:	XCTUU [SKIPE 3]		; NON-ZERO COUNT CASE?
	JRST MRETN		;YES. RETURN.
SIN2:	SETZ B,
	UMOVE A,2
	XCTBU [IDPB B,A]
	JRST MRETN

; SUBROUTINE TO FIX AC2 AND CHECK JFN

SIOR1:	UMOVE A,2
	PUSHJ P,FIXPTR
	 JRST EDESX1
	UMOVEM A,2
	UMOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST IOERR		; GARBAGE
	 POPJ P,
	 JRST [	CAIN DEV,STRDTB
		 AOS 0(P)	; SINGLE SKIP FOR STRING POINTERS
		RET]		; NONE FOR OTHER SPECIAL DESIGNATORS
	TEST(NN,OPNF)
	 FILABT(DESX5)
	CAIL JFN,RJFN
	 POPJ P,
	JRST SK2RET

FIXPTR:	TLC A,777777		; IF LH = -1 CONVERT TO 0
	TLCN A,777777		; UNCONVERT WAS IT -1?
	 HRLI A,440700		; YES. SET TO LEFT BYTE 7-BIT
	TLZN A,37		; DOES POINTER HAVE INDIRECTION OR INDEXING?
	 AOS 0(P)		; NO, GIVE SKIP RETURN
	POPJ P,

; SUBROUTINE TO SET UP REST OF SIN/SOUT AND DO BYTBLT

SIOR2:	UMOVE E,3		; GET COUNT
	MOVM C,E		; MAGNITUDE OF COUNT
	SKIPL E			; TERMINATING BYTE?
	 TLO D,(1B0)		; YES, SET FLAG
	SKIPLE E		; SPECIFIC TERMINATOR?
	 JRST [	UMOVE E,4	; YES. GET (NOTE 0 IN E IF COUNT=0)
		TLO D,(1B1)	; FLAG SPECIFIC TERMINATOR
		JRST .+1]
	SKIPN C			; NON-ZERO COUNT
	 HRLOI C,77		; NO, SET MAX COUNT
	TLNE D,(1B2)		; BYTE POINTER IN JFN?
	 JRST SIOR23		; YES, IGNORE FILCNT
	CAML C,FILCNT(JFN)	; KEEP MIN OF THIS
	 MOVE C,FILCNT(JFN)	; AND BYTES IN BUFFER
SIOR23:	PUSH P,C		; SAVE COUNT
	PUSHJ P,BYTBLT		; DO THE TRANSFER
	SUB C,0(P)		; GET NEG OF BYTES TRANSFERRED
	TLNE D,(1B2)		; BYTE POINTER IN JFN?
	 JRST SIOR24
	TLNE D,(1B4)		; WAS AN EXTRA BYTE READ BUT NOT WRITTEN
	TLNN D,(1B3)		; YES. IS THIS A SIN?
	 SKIPA E,C		; NO. USE STRAIGHT COUNT
	  HRREI E,-1(C)		; YES. COMPENSATE FOR THE EXTRA BYTE
	ADDM E,FILCNT(JFN)	; UPDATE FILCNT
	MOVNS	E
	ADDB E,FILBYN(JFN)
	CAML E,FILLEN(JFN)
	 MOVEM E,FILLEN(JFN)
SIOR24:	XCTUU [SKIPGE E,3]	; WHAT KIND OF COUNT
	 MOVNS C		; MAKE SIGN AGREE
	JUMPE E,SIOR21		; DON'T UPDATE COUNT IF 0
	XCTUU [ADDB C,3]	; DO UPDATE
	JUMPE C,SIOR22		; IF COUNT BECOMES 0, THEN DONE
	SKIPL C			; NOT DONE IF NEG COUNT SUPPLIED & STILL
SIOR21:	TLNE D,(1B0)		; ELSE DONE IF TERMINATOR FOUND
	TROA D,-1		; NOT DONE, SET D NON-0
SIOR22:	SETZ D,			; DONE, SET D = 0
	SUB P,BHC+1
	POPJ P,

; Check for end of string io string
; Call:	B	; Character just transfered
; User	3	; Sin/sout argument
; User	4	; Sin/sout argument
;	JSP A,SIONXT
; Return
;	+1	; Continue
;	MRETN	; If no more left to do
; Updates user 3

SIONXT:	TLNE JFN,777777		; If byte pointer,
	UMOVEM JFN,1		; Restore updated jfn
	XCTUU [SKIPN C,3]
	JRST (A)
SIO1:	JUMPG C,SIO2		; Positive
	XCTUU [AOSGE 3]
	JRST (A)
	JRST MRETN

SIO2:	XCTUU [SOSLE 3]
	XCTUU [CAMN B,4]
	JRST MRETN
	JRST (A)
; Define move .xor. umove

MXUM==<<MOVE>&<-1-<UMOVE>>>!<<-1-<MOVE>>&<UMOVE>>
MXUMM==<<MOVEM>&<-1-<UMOVEM>>>!<<-1-<MOVEM>>&<UMOVEM>>
IFN KIFLG,<
PRINTX !THIS SECTION NEEDS RECODING FOR KI-10 - BYTBLT IN IO$:!
>

; Accumulators

; Arguments...returned updated

SRC=1		; Source byte pointer
TGT=2		; Target byte pointer
CNT=3		; Byte count
MOD=4		; Mode

; Temporaries

T1=5
T2=6
T3=7

; Program space starts here

PRG==T3

P=17
FRM=16

; Local variables

DEFINE	BYTREM<4(FRM)>
DEFINE	BYTSIZ<5(FRM)>
DEFINE	TRMBYT<6(FRM)>

NLCLS==3

; Move bytes
; Call:
; 1/	SOURCE POINTER
; 2/	TARGET POINTER
; 3/	BYTE COUNT
; 4/	MODE BITS AS FOLLOWS:
;	B1/	TRANSFER TERMINATOR BYTE
;	B0/	TRANSFER UNTIL TERMINATOR
;	B34/	FROM USER
;	B35/	TO USER
; E/	TERMINATOR IF ANY

BYTBLT::PUSH P,FRM		; Save old frm
	MOVE FRM,P		; Set up frame base
	PUSH P,T1		; Save temps
	PUSH P,T2
	PUSH P,T3
	ADD P,BHC+NLCLS		; Cover space for locals
	JUMPGE P,MSTKOV
	MOVEM E,TRMBYT		; Shuffle args

; Preliminaries out of the way
; Now get to work

BYTB1:	TLNE MOD,(1B0)		; Terminator?
	 JRST CHKTRM		; Yes, look for it
	TLNN TGT,7700		; Zero byte size?
	 JRST BYTLP		; Well...if you insist
	MOVE T1,TGT		; Compare target
	XOR T1,SRC		; To source
	TLNN T1,7700		; And if byte size differs
	CAIG CNT,20		; Or short transfer
	 JRST BYTLP		; Do byte at a time
	LDB T2,[POINT 6,TGT,11]	; Get byte size
	MOVEM T2,BYTSIZ		; Save it
	ROT T2,-6		; Position in p field
LP1:	SOJL CNT,DONE		; Until cnt < 0
	XCT LDBTB(MOD)		; Do transfer bytes
	XCT DPBTB(MOD)
	CAMG T2,TGT		; Until less than 1 byte remains in tgt
	 JUMPGE T2,LP1		; Loop unless bytesize >= 32
				; (once is always enough)
BYTB2:	MOVEI T1,^D36		; Word size
	IDIV T1,BYTSIZ		; Compute bytes/word and remainder
	MOVEM T1+1,BYTREM	; Save remainder
	MOVE T2,CNT
	IDIV T2,T1		; Compute words to transfer
	MOVEM T2+1,CNT		; Remaining bytes
	JUMPE T2,BYTLP		; Zero words...do byte at a time
	HLLO T1,SRC		; Get source...prevent borrows
	SUB T1,TGT		; When getting bit offset
	ROT T1,6
	ANDI T1,77		; Retain just the position difference
	JUMPN T1,BYTBL1		; Move word at a time
	HRLZ T1,SRC		; Make blt pointer
	HRR T1,TGT
	ADD T1,BHC+1		; Adjust 'cause byte pointer behind by 1
	ADDM T2,SRC		; Adjust src by word count
	ADDB T2,TGT		; And adjust tgt
	XCT BLTTB(MOD)		; Blt t1,0(t2)
BYTLP:	JUMPLE CNT,DONE		; Do rest a byte at a time
BYTLP1:	XCT LDBTB(MOD)
	XCT DPBTB(MOD)
	SOJG CNT,BYTLP1
DONE:	SUB P,BHC+NLCLS		; Flush local storage
	POP P,T3		; Restore temps
	POP P,T2
	POP P,T1
	POP P,FRM		; Restore frm
	POPJ P,

; Transfer a word at a time
; T1/	POSITION OFFSET (RIGHT SHIFT AMOUNT)
; T2/	WORD COUNT
; Bytrem/ lsh amount to right justify first word

BYTBL1:	ADD P,BHC+LPRG-1	; Make room to save ac's
	JUMPGE P,MSTKOV
	MOVSI T3,PRG+1
	HRRI T3,2-LPRG(P)
	BLT T3,0(P)		; Save ac's
	MOVE PRG+LPRG-2,[PROTO,,PRG]
	BLT PRG+LPRG-2,PRG+LPRG-2	; Load up proto program except last word
	TRNE MOD,2		; Is from "user"
	 JRST [	TLC PRG+0,(MXUM)
		TLC PRG+1,(MXUM)
		JRST .+1]
	TRNE MOD,1		; Is to "user"?
	 TLC PRG+5,(MXUMM)	; Change movem to umovem
	HRRI PRG+0,0(SRC)	; Address of first move
	HRRI PRG+1,1(SRC)	; Address of second move
	HRR PRG+4,BYTREM	; Fill in shift amount to left justify
	MOVNS BYTREM		; Get right shift amount
	HRR PRG+2,BYTREM	; Fill in LSH
	MOVNS T1		; NEGATE OFFSET
	ADD T1,BYTREM		; Total right shift = offset + remainder
	CAMG T1,[-^D18]		; Less than half a word?
	 TLCA PRG+4,(<Z <<T1&<-1-T2>>!<<-1-T1>&T2>>,0>)
				; My kingdom for an xor operator
				; Change ac of lsh from t1 to t2
	  TLCA PRG+5,(<Z <<T1&<-1-T2>>!<<-1-T1>&T2>>,0>)
				; No, change ac of MOVEM to T1
	ADDI T1,^D36		; Leave movem t1, change shift amount
	HRRI PRG+5,1(TGT)	; Address of movem
	HRRM T1,PRG+3		; Fill in lshc amount
	ADDM T2,TGT		; Update target
	ADDM T2,SRC		; And source
	PUSH P,SRC		; Want to use SRC for AOBJN
	MOVNS T2		; Make aobjn
	HRLZ SRC,T2		; word in SRC
	MOVE PRG+LPRG-1,PROTO+LPRG-1; Last word of program
	JRST PRG		; Do the program, return to done

BYTLPD:	POP P,SRC
	MOVSI T1,2-LPRG(P)	; Cleanup
	HRRI T1,PRG+1
	BLT T1,PRG+LPRG-1
	SUB P,BHC+LPRG-1
	JRST BYTLP		; Finish up any odd bytes

; Transfer til terminator

CHKTRM:	JUMPLE CNT,DONE
CHKTR1:	XCT LDBTB(MOD)
	CAMN T1,TRMBYT
	 JRST [	TLZ MOD,(1B0)	; TERMINATOR HAS BEEN SEEN
		TLNN MOD,(1B1)	; SPECIFIC TERMINATOR (I.E. KEEP IT?)
		 JRST [	TLO MOD,(1B4)
			JRST DONE]
		XCT DPBTB(MOD)
		SOJA CNT,DONE]
	XCT DPBTB(MOD)
	SOJG CNT,CHKTR1
	JRST DONE

; Instruction tables for different mapping modes
; 00 -- monitor to monitor
; 01 -- monitor to user
; 10 -- user to monitor
; 11 -- user to user

LDBTB:	ILDB T1,SRC
	ILDB T1,SRC
	XCTBU LDBTB
	XCTBU LDBTB

DPBTB:	IDPB T1,TGT
	XCTBU DPBTB
	IDPB T1,TGT
	XCTBU DPBTB

BLTTB:	BLT T1,0(T2)
	XCTMU BLTTB
	XCTUM BLTTB
	XCTUU BLTTB

; Prototype byte blt program
; Note that address designated by .-. are filled in at run time
; also, the LSH and MOVEM instructions at PROTO +4 and +5 have their
; ac fields modified depending on where the LSHC is made to shift right
; or left.  Only one of these instructions is modified in either case
; thus the two instruction end up using T1 if shift left and T2 if right
; Furthermore, the MOVE's and MOVEM's may be changed to UMOVE or
; UMOVEM's depending on the address space of SRC and TGT respectively

PROTO:	MOVE T1,.-.(SRC)	; Note most rh's are filled at run time
	MOVE T2,.-.(SRC)	; Pick up next word
	LSH T1,.-.		; Right justify first word
	LSHC T1,.-.		; Shift to target position+unused bits
	LSH T2,.-.		; Shift back to clear unused bits
	MOVEM T1,.-.(SRC)	; Store
	AOBJN SRC,PRG		; Loop
	JRST BYTLPD		; Done
LPRG==.-PROTO


; Byte input subroutine
; Call:	1	; Source designator
;	PUSHJ P,BYTIN
; Return
;	+1	; Ok
;	B	; A byte
; Clobbers most everything

BYTIN::	MOVS B,PRIMRY
	CAIN JFN,100		; If not from primary input
	CAMN B,PRIMRY		; Or if primary input = output
	 JRST BYTINQ		; Not special
	PUSHJ P,BYTINQ		; Otherwise, do byte in
	JUMPE B,CPOPJ		; Cone if null
	EXCH A,B
	PBOUT
	EXCH A,B
	POPJ P,

BYTINQ:	PUSHJ P,CHKJFN		; Check the designator
	JRST IOERR		; Bad designator
	JFCL			; Tty
	JFCL			; Byte pointer, or special designator
BYTINA:	JUMPGE STS,NOTOPN
	TEST(NN,READF)
	FILABT IOX1		; Illegal read
	TEST(NE,ERRF)
	FILINT(IOX5)		; Generate data error interrupt
	TEST(NE,EOFF)
	JRST INEOF
	PUSHJ P,@BIND(DEV)	; Dispatch to device dependent code
	TEST(NE,ERRF)
	FILINT(IOX5)
	TEST(NE,EOFF)
	JRST INEOF
	MOVE B,A
	JRST UNLCKF

INEOF:	MOVEI A,IOX4
	MOVEM A,LSTERR
	MOVEM JFN,ERRSAV
	MOVEI 1,400000
	MOVSI 2,(1B10)
	IIC			; Initiate interrupt on channel 10
	MOVEI B,0
	JRST UNLCKF

; Output to primary output file
; Call:	1	BYTE
;	PBOUT

.PBOUT::JSYS MENTR
	MOVEI JFN,101
	UMOVE B,1
	PUSHJ P,BYTOUT
	JRST MRETN

; Byte output
; Call:	1	; Tenex destination designator
;	2	; A byte
;	BOUT

.BOUT::	NOINT
	JUMPL 1,SLBOU
	CAML 1,MAXJFN		; Possibly a jfn?
	 JRST SLBOU		; Not possible
	LSH 1,SJFN		; Convert number to index
	AOSE FILLCK(1)
	JRST SLBOU0
	MOVEM C,BIOAC0
	MOVE C,FILSTS(1)
	TLC C,OPNF!WRTF
	TLCN C,OPNF!WRTF
	TLNE C,FRKF!ERRF
	JRST SLBOU1
	SOSGE FILCNT(1)
	JRST SLBOU2
	AOS C,FILBYN(1)
	CAMLE C,FILLEN(1)
	MOVEM C,FILLEN(1)
	IDPB 2,FILBYT(1)
	MOVE C,BIOAC0
	SETOM FILLCK(1)
	LSH 1,-SJFN
	OKINT
	XCT MJRSTF

SLBOU2:	AOS FILCNT(1)
SLBOU1:	MOVE C,BIOAC0
	SETOM FILLCK(1)
SLBOU0:	LSH 1,-SJFN
SLBOU:	OKINT
	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,BYTOUT		; Output the byte
	JRST MRETN

; Random output jsys
; Call:	1	; Tenex source designator
;	2	; A byte
;	3	; Byte number
;	ROUT

.ROUT::	JSYS MENTR
	MOVE JFN,1
	PUSHJ P,CHKJFN
	JRST IOERR
	JFCL
	FILABT DESX4		; Tty and byte designators are illegal
	JUMPGE STS,NOTOPN
	TEST(NN,RNDF)
	FILABT IOX3		; Illegal to change pointer
	TEST(NN,WRTF)
	FILABT IOX2		; Illegal write
	UMOVE A,3
	PUSHJ P,SFBNR
	JRST ABTDO
	UMOVE B,2
	PUSHJ P,BYTOUA
	JRST MRETN

; String output to primary io file
; Call:	1	; String pointer, designator, or location of string
;	PSOUT

.PSOUT::JSYS MENTR
PSOUT1:	TLCE A,777777		; IS LH = 0?
	 TLC A,777777		; NO. UNCOMPLEMENT
	PUSHJ P,FIXPTR		; YES. LEAVE IT -1 AND FIX IT UP ANYWAY
	 JRST EDESX1
PSOUT0:	PUSH P,A		; Make a copy of byte pointer
	XCTBU [ILDB B,0(P)]
	JUMPE B,[XCTMU [POP P,1]
		JRST MRETN]
	MOVEI JFN,101
	PUSHJ P,BYTOUT
	POP P,A
	UMOVEM A,1
	JRST PSOUT0

; PRIMARY ERROR STRING OUTPUT

.ESOUT::JSYS MENTR
	MOVEI A,101
	DOBE
	HRROI A,[ASCIZ /
?/]
	PSOUT
	MOVEI A,100
	CFIBF
	UMOVE 1,1
	JRST PSOUT1

; String output
; Call:	1	; Tenex source designator
;	2	; Byte pointer (lh = 777777 will be filled in)
;	3	; Byte count or zero
;		; If zero, the a zero byte terminates
;		; If positive then transfer the specified number
;		; Of characters, or terminate on reading a byte
;		; Equal to that given in 4
;		; If negative, then transfer the specified number
;		; Of bytes
;	4	; (optional) if 3 is > 0, 4 has a terminating byte
;	SOUT
; Return
;	+1	; Always
;	2	; Updated string pointer
;	3	; Updated count (always counts toward zero)
; The updated string pointer always points to the last byte read
; Unless 3 contained zero, then it points to the last non-zero byte.

.SOUT::	JSYS MENTR		; Become slow etc
SOUT0:	PUSHJ P,SIOR1		; FIX UP AC2, CHECK JFN
	 JRST SOUTTY
	 JRST [	CAIE DEV,STRDEV
		 JRST .+1
		JRST SOUBYT]
	TEST(NN,WRTF)
	 FILABT(IOX2)
	SKIPG FILCNT(JFN)
	 JRST SOUTLD		; DO IT THE OLD WAY
	MOVE B,FILBYT(JFN)	; TARGET IS FILE
	UMOVE A,2		; SOURCE IS USER
	MOVEI D,2
	PUSHJ P,SIOR2
	UMOVEM A,2
	MOVEM B,FILBYT(JFN)
	PUSHJ P,UNLCKF
	JUMPN D,SOUT0
	JRST MRETN

; SOUT TO STRING POINTER

SOUBYT:	MOVE B,JFN
	UMOVE A,2
	MOVE D,[1B2+3]
	PUSHJ P,SIOR2
	UMOVEM A,2
	UMOVEM B,1
	MOVEM B,JFN
	PUSHJ P,APPNUL		; APPEND NULL
	JRST MRETN

; OLD STYLE SOUT

SOUTTY:
SOUTLD:	XCTUM [PUSH P,2]
	XCTBU [ILDB B,0(P)]
	XCTUU [SKIPN 3]
	JUMPE B,[XCTMU [POP P,2]
		PUSHJ P,UNLCKF

		JRST MRETN]	; Don't write zero bytes if arg3 = 0
	PUSH P,B
	PUSHJ P,BYTOUA
	POP P,B
	XCTMU [POP P,2]
	PUSHJ P,APPNUL
	JSP A,SIONXT
	JRST SOUT0

; Byte output subroutine
; Call:	1	; Source designator
;	PUSHJ P,BYTOUT
; Return
;	+1	; Ok
; Clobbers most everything

BYTOUT::PUSHJ P,CHKJFN		; Check the designator
	JRST IOERR		; Bad designator
	JFCL			; Tty
	JFCL			; Byte pointer or special designator
BYTOUA::JUMPGE STS,NOTOPN
	TEST(NN,WRTF)
	FILABT IOX2		; Illegal write
	TEST(NE,ENDF)
	FILABT(IOX6)		; Past abs end of file
	TEST(NE,ERRF)
	FILINT(IOX5)		; Error interrupt
	MOVE A,B
	PUSHJ P,@BOUTD(DEV)	; Dispatch to device dependent code
	JRST UNLCKF

; Append null to string output designator

APPNUL::PUSH P,JFN
	PUSH P,C
	MOVEI C,0
	TLZ JFN,7700
	TLO JFN,700
	CAMN JFN,-1(P)
	XCTBU [IDPB C,JFN]
	POP P,C
	POP P,JFN
	POPJ P,

; Dump io
; Parameters and variables

NDUMP==10
LS(DMPASW)		; Dump buffer assignment word
LS(DMPCNT)		; Dump buffer free count
LS(DMPLCK)		; Dump buffer assignment lock
NRP(DMPBUF,NDUMP*1000)	; Dump buffers

LS(IOWLCK)		;IOWD LOCK		
NIOW==1000		;TOTAL NO. OF IOWD AVAILABLE
LS (IOWPAG,NIOW)	;PAGE FOR IOWD'S	
LS (IOWCNT)		;NO OF IOWD'S AVAILABEL	
MAXIOW==^D72		;MAX. NO OF IOWD WHICH MAY BE REQUESTE
IOWSIZ==^D<NIOW/36+1>	;SIZE OF IOWD BIT TABLE	
LS (IOASW,IOWSIZ)	;IOWD ASSIGNMENT BIT TABLE

; Initialize dump io

	USE	RESPC

DMPINI::MOVEI A,NDUMP
	MOVEM A,DMPCNT
	SETOM DMPLCK
	SETCM A,[-1_<^D36-NDUMP>]
	MOVEM A,DMPASW
	SETOM IOWLCK	;INIT IOWD LOCK		
	MOVEI A,NIOW	;AND COUNTER		
	MOVEM A,IOWCNT					
	MOVE A,[-1_<<<NIOW/^D36>*^D36>-NIOW>]			;INIT BIT TABL
	MOVEM A,IOASW+IOWSIZ-1				
	POPJ P,

	USE	SWAPPC

; Dump input
; Call:	1	; Jfn
;	2	; Pointer to first command
;	DUMPI
; Return
;	+1	; Error
;	+2	; Ok

;MAJOR ALTERATIONS TO THE DUMP CODE HAVE BEEN MADE TO ALLO
;DUMP MODE I/O TO TAKE PLACE DIRECTLY FROM/TO USER MEMORY


.DUMPI::JSYS MENTR	;GET INTO SLOW CODE		
	PUSHJ P,DMPMEM	;CHECK JFN, FILE OFN, ACCESS OK, RETURN+
	TEST (NN,READF)	;ARG1, ACCESS TEST		
	IOX1		;ARG2, ERROR CODE IF ACCESS ILLEGAL
	MOVE A,DMPID(DEV)	;RETURN HERE TO GET DISPATCH WOR
	TLNE A,(1B0)	;ON IF DUMP FORM USER MEMORY DIRECTLY
	JRST DUMPI1	;DUMP FROM USER MEMORY				**SRI-AIC***

	PUSHJ P,DUMPC	;DUMP FORM MON BUFFERS, DOES NOT RETUR
	PUSHJ P,@DMPID(DEV)	;ARG1, CALL TO DEVICE DEPENDENT ROUTIN
	XWD 040000,0	;ARG2, REFS TO MEMORY ARE WRITES

DUMPI1:	PUSHJ P,DMPUM	;DUMP FROM USER MEMORY, DOES NOT RETUR
	PUSHJ P,@DMPID(DEV)	;ARG1, CALL TO DEV DEPEND. ROUTIN

; Dump output
; Call:	1	; Jfn
;	2	; Pointer to first command
;	DUMPO
; Return
;	+1	; Error
;	+2	; Ok

.DUMPO::JSYS MENTR
	PUSHJ P,DMPMEM	;SEE DUMPI COMMENTS		
	TEST (NN,WRTF)							;**:SRI-AIC***
	IOX2							
	MOVE A,DMPOD(DEV)						
	TLNE A,(1B0)						
	JRST DUMPO1						

	PUSHJ P,DUMPC						
	PUSHJ P,@DMPOD(DEV)					
	XWD 100000,0						

DUMPO1:	PUSHJ P,DMPUM						
	PUSHJ P,@DMPOD(DEV)					

;ROUTINE FOR CHECKING JFN'S, OFN'S ACCESS PROTECTION ETC FOR
;DUMP MODE I/O.						
DMPMEM:	UMOVE JFN,1	;GET USERS JFN			
	PUSHJ P,CHKJFN	;CHECK IT			
	JRST ERRD	;BAD				
	JFCL						
	JRST [	MOVEI A,DESX4					
		JRST ERRD]					

	TEST (NN,OPNF)	;SEE IF IT'S OPEN		
	JRST [	MOVEI A,DESX4	;NO, IT'S NOT. GET ERROR CODE
		JRST DMPER3]	;PRINT ERROR		

	HLRZ	A,FILDDN(JFN)		;POINTER TO NAME STRING
	MOVE	A,1(A)			;GET FIRST WORD OF NAME STRING
	CAMN	A,[ASCIZ /LP1/]		;IS IT PRINTER
	JRST	DMPME1			;YES, OK TO DO DUMP OUTPUT
	LDB B,[POINT 4,STS,35]	;OPEN, GET IO MODE	
	CAIGE B,16
	JRST [	MOVEI A,DUMPX2	;NO, ERROR		
		JRST DMPER3]					

DMPME1:	MOVE B,0(P)	;ADDRESS OF ARG LIST	
	MOVE A,1(B)	;ERROR CODE IF ACCESS IS ILLEGAL
	XCT 0(B)	;TEST ACCESS			
	JRST DMPER3	;ILLEGAL			

	MOVEI A,2						
	ADDM A,0(P)	;DOUBLE SKIP RETURN		
	POPJ P,							

; Dump common code

DMPSEB:	JUMPE B,[AOS -1(P)
		JRST MRETN]
	UMOVEM B,2
DMPRT1:	PUSHJ P,UNLCKF						
DMPRET:	AOS -1(P)	;SET SKIP RETURN		
	JRST MRETN	;RETURN TO MONITOR		

DUMPC:	PUSHJ P,UNLCKF	;WAS LOCKED BY DMPMEM, WILL RELOCK LATE
DUMPC1:	MOVE C,0(P)	;ADR OF ARG LIST	
	MOVE C,1(C)	;C=ARG2, READ WRITE MEM ACCESS BIT
	PUSHJ P,DMPNXT	;SETUP FOR NEXT IOWD, DBL SKIP WITLH IOW
	JRST ERRD	;ERROR CODE IN A		
	JRST DMPRET	;NO MORE TO DO, RETURN		

	PUSH P,B	;SAVE IOWD			
	MOVEI B,1(B)		; First address
	LSH A,-9		; Last page number
	LSH B,-9		; First page number
	SUBM B,A
	SOS A			; -# pages
	CAMGE A,[-NDUMP]
	JRST [	MOVEI A,DUMPX3
		JRST ERRD]	; Too many pages
	NOINT
	PUSH P,C	;SAVE READ/WRITE BIT		
	LOCK DMPLCK,<PUSHJ P,LCKTST>
DMPSE0:	MOVSI B,400000
	ASH B,1(A)		; Get a one for each page needed
	HRLZ C,A		; Initial aobjn word
	PUSH P,DMPCNT		; SAVE CURRENT LEVEL OF AVAILABILITY
DMPSE1:	TDNN B,DMPASW		; Are these contiguous buffers free
	JRST DMPSE2		; Yes, assign them
	ROT B,-1		; No, try next set
	AOS C			; Modify aobjn word
	JUMPGE B,DMPSE1		; When low bit wraps around
	EXCH A,0(P)		; SAVE A, GET FORMER DMPCNT
	HRLZS A
	HRRI 1,DMPTST
	JSYS EDISMS		; Dismiss until buffers released
	POP P,1
	JRST DMPSE0		; Then try again

DMPSE2:	SUB P,BHC+1		; FLUSH SAVE DMPCNT
	IORM B,DMPASW		; Mark these buffers as taken
	ADDM A,DMPCNT		; Decrement count of free buffers
	UNLOCK DMPLCK
	PUSH P,C		; Save aobjn word
	HRRZ A,-2(P)		; Get user first address-1
	AOS A
	LSH A,-9		; Page number
IFN KAFLG,<
	JSP B,.+1
	TLNN B,2000		; Call from monitor?
>
IFN KIFLG,<
	MOVE B,-4(P)		; CHECK CALLER'S PC WORD
	TLNE B,(1B5)>		; CALL FROM MONITOR?
	HRLI A,400000		; No, insert fork id

DMPSE3:	PUSH P,A		; Save vulnerable ac's
	PUSH P,C
	JUMPGE A,[LSH A,9
		PUSHJ P,FPTA	; Convert monitor address to ptn.pn
		JRST DMPSE5]
	PUSHJ P,FKHPTN		; Convert user address to ptn.pn
DMPSE5:	PUSH P,A		; Save ptn.pn
	PUSHJ P,MRPACS		; Read access of page
	JUMPE A,[MOVE A,-2(P)	; Non-existent page, create it
		LSH A,9
		UMOVE A,(A)	; By referencing it
		POP P,A
		JRST DMPSE5]
	TDNN A,-4(P)		; Test against needed access
	JRST DMPSE4		; Access not permitted
	TLNN A,(1B6)		; Indirect?
	JRST DMPSE7		; No.
	POP P,A			; Yes, track it down
	PUSHJ P,MRPT		; Get id of page pointed to
	JRST DMPSE5		; Not file, continue
	PUSH P,A		; File, repush
	JRST DMPSE6

DMPSE7:	TLNN A,400		; Write copy?
	 JRST DMPSE6		; No.
	MOVE B,-4(P)		; Yes.
	TLNN B,40000		; Write?
	 JRST DMPSE6		; No.
	TLNN A,100000		; Yes, can we read?
	 JRST DMPSE4		; No, must fail
	MOVE B,-2(P)
	LSH B,9
IFN KAFLG,<
	UMOVES (B)		; Write in page to make not write copy
>
IFN KIFLG,<
	XCTUU [MOVES (B)]	; SAME BUT HARDER
>
	POP P,A
	POP P,C
	POP P,A
	JRST DMPSE3		; Recompute

DMPSE6:	HRRZ A,-1(P)		; Get buffer number
	LSH A,9
	ADDI A,DMPBUF		; Convert to address
	MOVE B,A
	EXCH A,(P)		; Save address, get ptn.pn
	HRLI B,140000
	PUSHJ P,SETMPG		; Map the user page into monitor
	POP P,A			; Get back address
	PUSHJ P,FPTA
	PUSHJ P,MLKPG		; Lock the page
	POP P,C			; Restore vulnerable ac's
	POP P,A
	AOS A			; Next page
	AOBJN C,DMPSE3		; Until done
	POP P,C			; Aobjn word
	MOVEM C,(P)		; Back to stack (clobers access bit)
	MOVEI A,DMPBUF		; Do things the hard way cause macro
	ASH A,-9		; Can't divide externals
	ADDI A,(C)
	AOS -1(P)
	DPB A,[POINT 9,-1(P),26]; Modify iowd to address monitor buffer
	SOS -1(P)

; At this point the dump region has been mapped into the monitor
; Buffer region and access checked
; -1(p) has the iowd needed for the data xfer
; 0(p) has the aobjn word needed to restore buffers when finished

	UMOVE JFN,1
	PUSHJ P,CHKJFN
	 JRST DMPER1		; Error, release buffers
	 JFCL
	 JRST [	CAIE DEV,STRDTB
		 JRST .+1
		MOVEI A,DESX4
		JRST DMPER1]
	MOVE B,-2(P)						
	POP P,A							
	EXCH A,0(P)	;GET IOWD, LEAVE AOBJN ON STACK
	XCT 0(B)	;CALL DEVICE DEPENDENT REOTINE
	POP P,A
	PUSHJ P,DMPREL		; Release buffers
	OKINT
	PUSHJ P,UNLCKF
	PUSHJ P,DMPOK	;ANY ERRORS?			
	JRST ERRD	;YES, QUIT			
	JRST DUMPC1	;OK, CONTINUE			

;SETUP TO PROCESS NEXT IOWD.				
;DOUBLE SKIP RETURN WITH IOWD IN B, SINGLE SKIP IF DONE
;NO SKIP IF ERROR WITH ERROR CODE IN A			

DMPNXT:	PUSH	P,D	;SAVE REGISTER D
	MOVEI	D,DMPLIM	;LIMIT TO NUMBER OF COMMANDS
	JRST	DMPNX3		;START PROCESSING WORDS	
DMPNX1:	JUMPE B,DMPNX2						
	UMOVEM B,2						
DMPNX3:	UMOVE A,2	;GET COMMAND POINTER		
	UMOVE B,(A)	;AND COMMAND			
	SOJE	D,DMPNX4	;LIMIT REACHED?	
	JUMPGE B,DMPNX1	;BRANCH OR DISCONNECT	
	HLRE A,B	;-WORD COUNT			
	MOVNS	A	;WORD COUNT		
	ADDI A,(B)	;LAST ADDRESS			
	CAILE A,777777	;MUST NOT CROSS END OF MEMORY	
	JRST [	MOVEI A,DUMPX3	;AND IT DOES		
		POP P,D   ;RETREIVE REGISTER D
		POPJ P,]	;SO THATS AN ERROR			
	AOS -1(P)	;SKIP RETURN (DOUBLE)		
DMPNX2:	AOS -1(P)	;SKIP RETURN (SINGLE)		
DMPNX4:	POP P,D		;RETREIVE REGISTER D
	POPJ P,							
DMPLIM==^D1000	;LIMIT NUMBER OF COMMANDS

DMPER2:	PUSHJ P,UNLCKF
DMPER1:	EXCH A,(P)
	PUSHJ P,DMPREL
	POP P,A					
	JRST ERRD						
DMPER3:	PUSHJ P,UNLCKF						
	JRST ERRD						

DMPSE4:	POP P,A
	POP P,A
	POP P,B
	PUSH P,A
	PUSHJ P,DMPRL1		; Release buffers assigned but unlocked
	POP P,C
	HLRES C
	MOVNS C
	HRLZS C
	POP P,A
	ADD A,C
	SKIPGE A
	PUSHJ P,DMPREL		; Release buffers both lock and assigned
	MOVEI A,DUMPX4
	JRST ERRD		; Access error

;CHECK FOR ERROR FLAGS RETURNED BY DEVICE DEPENDENT DUMP ROUTINE
;NO SKIP WITHE ERROR NO. IN A IF ERR, AND SKIP AFTER BUMPING
;COMMAND POINTER IF OK							**SRI-AIC**

DMPOK:	MOVEI A,IOX4						
	TEST (NE,EOFF)	;STOP ON EOF			
	POPJ P,								
	MOVEI A,IOX5					
	TEST (NE,ERRF)	;STOP IF ERROR				
	POPJ P,							
	XCTUU [AOS 2]	;BUMP IOWD POINTER		
	AOS 0(P)	;SKIP RETURN			
	POPJ P,							

;DUMP I/O FROM USER CORE.  CHECK JFN DONE ALREADY	

DMPUM:	PUSHJ P,DMPNXT	;SET UP FOR NEXT IOWD		
	JRST DMPER3	;ERROR BAD IOWD LIST ENTRY	
	JRST DMPRT1	;ALL DONE, UNLOCK AND RETURN	

	MOVE A,B	;IOWD TO A			
	MOVE B,0(P)	;ADR OF ARG LIST		
	XCT 0(B)	;CALL DEVICE DEPENDENT ROUTINE	
	PUSHJ P,DMPOK	;CHECK FOR ERRORS		
	JRST DMPER3	;ERROR,  ERROR CODE NO. IN A	
	JRST DMPUM	;GO DO NEXT IOWD,  PTR WAS BUMPED

DMPREL:	PUSH P,A
DMPRL0:	PUSH P,A
	LSH A,9
	MOVEI A,DMPBUF(A)
	PUSH P,A
	PUSHJ P,FPTA
	PUSHJ P,MULKPG
	POP P,B
	MOVEI A,0
	PUSHJ P,SETMPG
	POP P,A
	AOBJN A,DMPRL0
	POP P,A
DMPRL1:	HLRE B,A
	MOVSI C,400000
	ASH C,1(B)
	MOVNI A,(A)
	ROT C,(A)
	ANDCAM C,DMPASW
	MOVNS B
	ADDM B,DMPCNT
	POPJ P,

;HERE ON FAILING TO LOCK RESIDENT LOCK. NOTE THAT THE CODE TAKES
;SPECIAL CARE TO PRESERVE THE STATE OF ALL ACS EXCEPT P WHEN IT
;COMPUTES THE LOCK ADDRESS SO THAT TABLES OF LOCKS MAY BE
;ADDRESSED VIA ANY AC (EXCEPT P, OF COURSE).
LCKTST::PUSH P,1
	PUSH P,1		;DO IT AGAIN
	MOVE 1,-2(P)
	MOVE 1,-2(1)		;GET THE FAILING AOSE
	EXCH 1,0(P)		;PUT IT ON THE STACK AND RESTORE AC1
	HRLZI 1,@0(P)		;GET ADDRESS OF LOCK
	HRRI 1,LCKTSS
	JSYS EDISMS
	SUB P,BHC+1		;ADJUST STACK POINTER
	POP P,1
	POPJ P,




;							BEGI
;PAGE ACCESS CHECK FOR USE BY DIRECT USER CORE DUMPIO.

; CALL:	1	;USERS IOWD
;	2	;ACCESS TEST BITS FOR "RPACS"
;	PUSHJ P,DMPCKA
; RETURN
;	+1	;ERROR, DESIRED ACCESS NOT ALLOWED
;	+2	;SUCCESS, # OF PAGES IN 1, TOTAL WORD COUNT IN 2

DMPCKA::PUSH P,4	;SAVE THINGS
	PUSH P,3
	PUSH P,7
	MOVE 7,2	;TRANSFER ARG
	TLNE 7,(1B3)	;WRITE-TO-MEMORY ACCESS SAUGHT ?
	TLO 7,(1B9)	;YES, PERMIT COPY-ON-WRITE TO PASS

	HLRE 4,1	;GET WORD COUNT FROM IOWD
	MOVNS 4		;KEEP MAGNITUDE
	PUSH P,4	;SAVE FOR LATER

	HRRZ 3,1	;ADR. OF FIRST WORD
	ADD 4,3		;+ WORD COUNT
	SUBI 4,1	;-1

			;=ADR OF LAST WORD
	LSH 3,-11	;KEEP ONLY PAGE ADR BITS, FIRST PAGE
	LSH 4,-11	;LAST PAGE

	SUB 4,3		;GET # OF PAGES TO 4
	MOVEI 4,1(4)	;IS DIFFERENCE +1
	PUSH P,4	;SAVE FOR RETURN

	HRLI 3,400000	;SAY THIS FORK
	EXCH 1,3	;1 NOW HAS FIRST PAGE, FORK DESIGNATOR
			;3 HAS ADDRESS

DMPCK1:	RPACS		;GET ACCESS BITS
	TLNE 2,(1B5)	;DOES PAGE EXIST ?
	JRST .+3	;YES

	UMOVES 0(3)	;NO, CREATE IT BY ACCESSING IT
	JRST DMPCK3

	TDNN 2,7	;DOES PAGE HAVE NEEDED ACCESS ?
	JRST DMPCK2	;NO, DIE
	TLNE 7,(1B3)	;WRITE ACCESS REQUESTED ?
	TLNE 2,(1B9)	;YES, SPECIFICALLY ALLOWED ?
	CAIA		;YES, OK
	UMOVES 0(3)	;NO, COPY-ON-WRITE, MAKE PAGE PRIVATE BY DIRTYING

DMPCK3:	MOVEI 3,1000(3)	;BUMP ADDRESS
	HRRI 1,1(1)	;AND PAGE NO.
	SOJG 4,DMPCK1	;COUNT DOWN PAGES

	CAIA		;DONE, TAKE NORMAL RETURN
DMPCK2:	TEST (O,ERRF)	;ERROR, SET FLAG

	POP P,1		;PAGE COUNT TO 1
	POP P,2		;WORD COUNT TO 2

	POP P,7
	POP P,3		;RESTORE THESE
	POP P,4
	TEST (NN,ERRF)	;ERROR ?
	AOS 0(P)	;NO, SKIP RETURN
	POPJ P,		;EXIT



;PAGE LOCKING AND IOWD SETUP FOR DIRECT USER CORE DUMPIO

; CALL:	1	;AOBJN WORD FOR IOWD LIST
;	2	;XWD -WCNT,USER ADDRESS
;	7	;BIT 0 ON IF OUTPUT
;	PUSHJ P,DMPLKP
; RETURN
;	+1	;ALWAYS

DMPLKP::PUSH P,4	;SAVE THINGS
	PUSH P,IOS
	PUSH P,3
	PUSH P,STS
	PUSH P,UNIT
	PUSH P,1
	PUSH P,7	;SAVE THIS

	HLRE 3,2	;GET + WCNT
	MOVNS 3
	PUSH P,3	;SAVE

	MOVE 4,1	;IOWD INDEX TO 4
	
	HRRZS 2		;CLEAN ADDRESS IN 2
	PUSH P,2	;SAVE
	ANDI 2,777	;KEEP ONLY PAGE BITS
	MOVEI 3,1000	;MAX WCNT THIS PAGE
	SUB 3,2		;WDCNT THIS PAGE TO 3

	MOVE 1,0(P)	;NEXT ADR TO 1

DMPLK1:	CAMLE 3,-1(P)	;WDCNT THIS PAGE .GT. THAT REMAINING
	MOVE 3,-1(P)	;YES, USE REMAINDER

	MOVNS 3		;NEGATE WORD COUNT
	ADDM 3,-1(P)	;UPDATE REMAINING WORD COUNT

	HRL 1,3		;FORM XWD -WDCNT,USR ADR
	MOVEM 1,0(4)	;PLACE IN IOWD ENTRY

	HRLI 1,(1B0)	;FORM XWD THIS.FORK,MEM.ADR
	PUSH P,4	;SAVE AC'S FROM MLKPG
	PUSHJ P,MLKMA	;LOCK DOWN THE PAGE
	POP P,4		;RESTORE AC'S

	DPB 1,[POINT 9,0(4),26]	;STORE REAL PAGE BITS OVER VIRT. ONES

	MOVE 1,0(P)	;GET VIRT. ADR
	MOVE 7,-2(P)	;GET BITS
	TLNN 7,(1B2)	;IS THIS A WRITE FROM MEMORY ?
	UMOVES 0(1)	;YES, DIRTY THE PAGE

	HRRI 1,1000(1)	;GET TO NEXT PAGE
	ANDI 1,777000	;SAVE ONLY PAGE BITS
	MOVEM 1,0(P)	;SAVE

	MOVEI 3,1000	;WDCNT THIS PAGE

	AOBJN 4,DMPLK1	;DO NEXT PAGE

	SUB P,BHC+2	;CLEAR STACK
	POP P,7	;RESTORE AC'S
	POP P,1
	POP P,UNIT
	POP P,STS
	POP P,3
	POP P,IOS
	POP P,4

	POPJ P,



;PAGE UNLOCKING FOR DIRECT USER MEMORY DUMPIO

; CALL:	1	;XWD -WCNT,USER ADDRESS
;	PUSHJ P,DMPULP
; RETURN
;	+1	;ALWAYS

DMPULP::PUSH P,2	;SAVE THINGS
	PUSH P,3
	PUSH P,1

	HLRE 2,1	;WCNT TO 2
	SETZ 3,		;PREPARE TO KEEP ONLY - NO OF PAGES
	ASHC 2,-9	;DIVIDE BY 1000
	SKIPN 3		;DO WE NEED ONE MORE ?
	SUBI 2,1	;YES.  NOW HAVE - NO. OF PAGES IN 2

	HRRZ 3,1	;GET USER ADDRESS
	HRLI 3,(1B0)	;THIS FORK

	MOVE 1,3	;ARG. TO 1
	PUSHJ P,FPTA	;GET PTN.PN
	PUSHJ P,MULKPG	;UNLOCK IT

	HRRI 3,1000(3)	;BUMP ADR.
	AOJL 2,.-4	;COUNT DOWN PAGES

	POP P,1
	POP P,3		;RESTORE
	POP P,2

	POPJ P,		;EXIT







;LOGIC FOR ALLOCATING IOWD'S FOR USER CORE DUMPIO

;GET N IOWD'S FROM OWD LIST...
; CALL:	1	;NO. OF IOWD'S NEEDED
;	PUSHJ P,GTIOWD
; RETURN
;	+1	;ALWAYS, ABOJN WORD FOR IOWD LIST IN 1

GTIOWD::PUSH P,2	;SAVE THINGS
	PUSH P,3
	PUSH P,4

	CAILE 1,MAXIOW	;SEE IF HE'S ASKING FOR TOO MANY
	BUG(CHK,<GTIOWD: TPOO MANY IOWD REQUESTED>)

	HRRZS 1		;CLEAN
	MOVNS 1		;NEGATE NO. NEEDED
	PUSH P,1	;SAVE

	SETZB 2,3	;PREPARE TO SETUP MASK TO SCAN BIT TABLE
	MOVSI 2,(1B0)	;SET THE SIGN BIT
	ASHC 2,1(1)	;MAKE THE MASK (COMPLICATED WHAT ?)
	CAMLE 1,[-^D37]	;MAY HAVE TO KILL SIGN BIT IN 3
	TLZ 3,(1B0)	;YUP

	HRLZS 1		;- COUNT TO LH FOR AOBJN WORD
	PUSH P,1	;MAKE SPACE FOR AOBJN WORD ON STACK
GTIOW3:	PUSH P,2	;SAVE THIS STUFF IN CASE WE HAVE TO WAIT
	PUSH P,3

	LOCK IOWLCK,<PUSHJ P,LCKTST>	;ONLY ONE AT A TIME FROM HERE ON

	MOVSI 4,-IOWSIZ	;SIZE OF BIT TABLE
GTIOW1:	MOVEI 1,^D36	;NO OF BITS IN A BIT TABLE WORD
	TDNN 2,IOASW(4)	;TEST THIS SET OF WORDS
	TDNE 3,IOASW+1(4)	;OK, SEE IF THEY ALL MATCH
	CAIA			;NOT FOUND
	JRST GTIOW2		;FOUND SOME
	AOS -2(P)		;NONE FOUND, MODIFY AOBJN WORD
	SOJE 1,.+3		;IS THAT ALL THIS WORD ?
	ROTC 2,-1		;NO, LOOK AT NEXT SET
	JRST GTIOW1+1
	AOBJN 4,GTIOW1		;YES, GET NEXT WORD

	HLLZ 1,-2(P)		;GET - COUNT
	MOVEM 1,-2(P)		;FIX UP AOBJN WORD
	MOVNS 1			;GET + COUNT FOR TESTING
	HRRI 1,IOWTST		;TEST ROUTINE ADR
	UNLOCK IOWLCK		;LET SOMEONE ELSE LOOK
	JSYS EDISMS
	POP P,3			;RESTORE MASKS
	POP P,2
	JRST GTIOW3

GTIOW2:	IORM 2,IOASW(4)		;FOUND SOME, MARK THEM TAKEN
	IORM 3,IOASW+1(4)

	SUB P,BHC+2		;CLEAR STACK
	POP P,1			;PARTIAL AOBJN WORD TO 1
	HRRI 1,IOWPAG(1)	;INSERT REST OF ADDRESS

	POP P,3			;GET NO. USED
	ADDM 3,IOWCNT		;DECREASE NO. AVAILABLE

	UNLOCK IOWLCK		;LET OTHERS IN

	POP P,4
	POP P,3
	POP P,2

	POPJ P,


;RLIOWD:  COMPLEMENTS ABOVE ROUTINE. RELEASES IOWDS OBTAINED BY GTIOWD

; CALL:	1	;AOBJN WORD FRO IOWD FROM GTIOWD
;	PUSHJ P,RLIOWD
; RETURN
;	+1	;ALWAYS

RLIOWD::PUSH P,2
	PUSH P,3	;SAVE THINGS
	PUSH P,4
	PUSH P,5

	HRRZ 4,1	;ADR. TO 4
	HLRES 1		;-COUNT TO 1
	SETZB 2,3	;MAKE MASK, AS ABOVE
	MOVSI 2,(1B0)
	ASHC 2,1(1)
	CAMLE 1,[^D-37]
	TLZ 3,(1B0)

	SUBI 4,IOWPAG	;GET LOCATION IN TABLE
	IDIVI 4,^D36	;QUOTIENT GIVES WORD IN BIT TABLE ...
	MOVNS 5		;REMAINDER IS OFFSET IN WORD
	ROTC 2,0(5)	;SHIFT THAT AMOUNT

	LOCK IOWLCK,<PUSHJ P,LCKTST>	;DON'T SCREW UP GTIOWD
	ANDCAM 2,IOASW(4)	;RELEASE THOSE WORDS
	ANDCAM 3,IOASW+1(4)

	SUBM 1,IOWCNT	;INCREASE NO. AVAILABLE
	MOVMS IOWCNT	;BE SURE THIS STAYS POSITIVE
	UNLOCK IOWLCK	;FREE UP TABLE

	POP P,5
	POP P,4		;CLEAN UP
	POP P,3
	POP P,2

	POPJ P,




;READY TEST CODE, ETC.
	USE	RESPC


;TEST FOR ENOUGH FREE IOWD'S

IOWTST:	CAML 1,IOWCNT	;ENOUGH ?
	JRST 0(4)	;NO
	JRST 1(4)	;YES, RETURN


;	

LCKTSS:	AOSE 0(1)
	JRST 0(4)
	JRST 1(4)

DMPTST:	CAML 1,DMPCNT
	JRST 0(4)
	JRST 1(4)


	USE	SWAPPC

; Fixed point number output
; Call:	1		; Destination designator
;	2		; Number to be output
;	RH(3)		; Radix
;	3(0)		; 1 to treat number as 36 bit magnitude
;	3(1)		; 1 to always print some kind of sign
;	3(2)		; Right justify the number
;	3(3)		; Print leading zeros if any
;	3(4)		; Print something on errors
;	3(5)		; Print * on errors rather than whole number
;	3(11-17)	; Field width, 0 means large enough to hold all
;	NOUT
; Return
;	+1		; Error, bad radix, or number too big for field
;	+2		; Successful

.NOUT::	JSYS MENTR
	PUSHJ P,NOUTX
	JRST [	MOVE A,LSTERR
		UMOVEM A,3
		JRST MRETN]
	AOS (P)
	JRST MRETN

NOUTX::	HRRZ D,C		; Get radix
	CAIL D,2
	CAILE D,^D10+^D26		; Must be 2 - 36
	JRST [	MOVEI A,NOUTX1
		MOVEM A,LSTERR
		POPJ P,]
	HLL D,C			; Save flags in d too
	LDB F,[POINT 8,D,17]	; Extract column width
	MOVEI E,1		; Initilize digit counter
	TLNN D,(1B0)		; Magnitude printout?
	CAIL B,0		; Or positive number?
	TLZA D,(1B6)		; Yes, remember not minus sign
	TLO D,(1B6+1B1)		; No, remember minus sign
	TLNE D,(1B6)		; - sign to be printed?
	MOVMS B			; Yes complement number
	TLNE D,(1B1)		; A sign of some sort to be printed?
NOUT1:	AOS E			; Yes, count as digit
	LSHC B,-^D35		; Make into double
	LSH C,-1		; Length dividend
	DIVI B,(D)		; Produce a digit
	PUSH P,C		; Save on stack
	JUMPN B,NOUT1		; Repeat until all digits generated
	CAIN F,0		; Zero field width specified?
	MOVE F,E		; Yes, make it same as number of digits
	TLNE D,(1B2)		; Right justify number?
NOUT2:	CAML E,F		; And filler needed?
	JRST NOUT3		; No
	TLNE D,(1B3)		; Yes. leading 0's?
	PUSHJ P,SGNOUT		; Yes, output sign now
	MOVEI B," "		; Get a space
	TLNE D,(1B3)		; Unless 0's wanted
	MOVEI B,"0"		; Then get a 0
	PUSHJ P,BOUTN		; Call bout so strings will work
	SOJA F,NOUT2		; Decrease remaining width and loop

NOUT3:	CAML F,E		; Sufficient room?
	JRST NOUT4		; Yes
	MOVEI B,NOUTX2		; Error
	MOVEM B,LSTERR
	TLNN D,(1B4)		; Print something anyway?
	JRST NOUT7		; No, go away
	TLNN D,(1B5)		; Asterisks?
	JRST NOUT4		; No, print the whole number
	MOVEI B,"*"		; Yes,
NOUT6:	SOJL F,NOUT7		; Column filled
	PUSHJ P,BOUTN
	JRST NOUT6

NOUT7:	TLNE D,(1B1)		; If one position reserved for -,
	SOS E			; One less thing on stack
NOUT71:	SOJL E,CPOPJ
	POP P,B
	JRST NOUT71

NOUT4:	PUSHJ P,SGNOUT		; Output sign before number
NOUT5:	SOJL E,NOUT8		; Any digits left?
	POP P,B			; Yes, get one
	ADDI B,"0"
	CAILE B,"9"
	ADDI B,"A"-"9"-1
	PUSHJ P,BOUTN		; Print it
	SOJA F,NOUT5		; Decrease field width

NOUT8:	SKIPL F
	AOS (P)			; Skip if no error
	MOVEI B," "
	JRST NOUT6		; Insert trailing blanks if necessary

SGNOUT:	TLZN D,(1B1)		; Sign still needed?
	POPJ P,			; No, return immediately
	MOVEI B,"-"
	TLNN D,(1B6)
	MOVEI B,"+"
	PUSHJ P,BOUTN
	SOS E			; Decrement digit count
	SOS F			; Decrement remaining field width
	POPJ P,

; Call bout

BOUTN::	PUSH P,A
	UMOVE A,1		; Output designator
	TLNN A,777777		; String pointer?
	JRST BOUTN1		; No
	PUSHJ P,FIXPTR		; FIX BYTE POINTER
	 JFCL			; IGNORE INDEX/INDIRECTION
	XCTBU [IDPB B,A]
	UMOVEM A,1
	PUSH P,B
	SETZ B,
	XCTBU [IDPB B,A]
	POP P,B
	POP P,A
	POPJ P,

BOUTN1:	BOUT			; For ordinary jfn's just do a bout
	POP P,A
	POPJ P,

; Number input
; Call:	1	; Source designator
;	NIN
; Return
;	+1	; Error
;	+2	OK
;	2	NUMBER

.NIN::	JSYS MENTR
	CAILE 3,1
	CAILE 3,^D10+^D26
	JRST [	MOVEI A,IFIXX1	; Illegal radix
		UMOVEM A,3
		JRST MRETN]
	MOVEI 1,400000
	RCM			; Read interrupt enables
	PUSH P,1		; Save to restore when done
	MOVEI 1,400000
	MOVSI 2,(1B6)
	DIC			; Turn off overflow int
	JOV .+1
	MOVEI C,0
	PUSHJ P,BIN1
	CAIN B,40
	JRST .-2		; Skip leading spaces
	CAIN B,"-"
	JRST MININ
	CAIN B,"+"
	PUSHJ P,BIN1
	PUSHJ P,DIGIN1
	JRST [	MOVEI A,IFIXX2
		UMOVEM A,3
		JRST PLINX]
PLIN:	PUSHJ P,NIN9
	UMOVEM C,2
	JOV [	MOVEI A,IFIXX3
		UMOVEM A,3
		JRST PLINX]
	AOS -1(P)
PLINX:	POP P,2			; Get back interrupt enables
	MOVEI 1,400000
	AIC			; Re-enable
	JRST MRETN

MININ:	PUSHJ P,NIN91
	MOVNS C
	JRST PLIN+1

NIN9:	XCTUU [MUL C,3]
	ASH C,^D34		; Shift lost bits off setting ovrflo
	LSH C,1			; Position old b35 at b0
	ADD C+1,C		; Complete the 36-bit mult
	EXCH C,C+1		; 36-bit prod to c, hi part to c+1
	ADD C+1,C+1		; Set overflow if sign is wrong now
	ADD C,B			; Add in digit
NIN91:	PUSHJ P,DIGIN
	POPJ P,
	JRST NIN9

DIGIN:	PUSHJ P,BIN1
DIGIN1:	SUBI 2,60
	JUMPL 2,CPOPJ
	CAILE 2,9

	 JRST [	CAIL 2,"A"-60
		CAILE 2,"Z"-60
		 POPJ P,
		SUBI 2,"A"-"9"-1
		JRST .+1]
	XCTUU [CAMGE 2,3]
	AOS (P)
	POPJ P,

BIN1::	PUSH P,A
	UMOVE A,1
	TLNN A,777777
	JRST BIN1A
	PUSHJ P,FIXPTR		; FIX UP POINTER
	 JFCL			; IGNORE BADNESS
	XCTBU [ILDB B,A]
	UMOVEM A,1
	POP P,A
	POPJ P,

BIN1A:	BIN
	POP P,A
	POPJ P,
	POPJ P,

	END
	