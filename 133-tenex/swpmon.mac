;<133-TENEX>SWPMON.MAC;40     7-MAY-75 13:51:19    EDIT BY UNTULIS
;ADD SETTING OF LOGDES TO SUPRESS LOGOUT MESSAGES AT SYS SHUTDOWN
;<133-TENEX>SWPMON.MAC;39    26-MAR-75 11:17:59    EDIT BY LYNCH
; MADE THE THREE FAST JSYS'S THAT GIVE TIME AND USER INFO  RESIDENT CODE
;<133-TENEX>SWPMON.MAC;38    25-MAR-75 14:41:05    EDIT BY LYNCH
; BYPASSED THE LINE SCANNER GARBAGE COLLECTER CODE.
;<133-TENEX>SWPMON.MAC;37    14-MAR-75 17:38:51    EDIT BY LYNCH
; TOOK OUT LYNCHT TABLES CAUSE NOT USED.
;<133-TENEX>SWPMON.MAC;36    10-MAR-75 14:01:13    EDIT BY LYNCH
; LINE SCANNER GREW AGAIN.
;<133-TENEX>SWPMON.MAC;35     7-FEB-75 19:56:54    EDIT BY LYNCH
; FUMBLE SSTSIZ UP TO FIT ALL THE FLIPPING SYMBOLS IN TO MDDDT AREA
;<133-TENEX>SWPMON.MAC;34     6-FEB-75 09:56:16    EDIT BY UNTULIS
; MADE AUTOJOBS LOGIN FAST BY ELIMINATING LOGGING TTY OUTPUT DURING STARRTUP.
;<133-TENEX>SWPMON.MAC;33    30-JAN-75 19:37:50    EDIT BY LYNCH
; MAKE MODES AN EXTERN FOR ACCOUNTING AT SRI
;<133-TENEX>SWPMON.MAC;32    29-JAN-75 10:54:53    EDIT BY UNTULIS
;CHANGE FORK DATA TABLE STRUCTURE
;<133-TENEX>SWPMON.MAC;31    28-JAN-75 13:52:45    EDIT BY LYNCH
; COMPLETED PATCH  TO ALLOW JOB 0 TO CHANGE ACCOUNTS ALSO.
;<133-TENEX>SWPMON.MAC;30    26-JAN-75 21:14:49    EDIT BY SYSTEM
; FIXED BUG IN AUTOJOB STARTUP FOR ALPHA ACCOUNTS
;<133-TENEX>SWPMON.MAC;29    21-JAN-75 14:15:25    EDIT BY LYNCH
;<133-TENEX>SWPMON.MAC;28    21-JAN-75 10:49:52    EDIT BY LYNCH
; FIX KFACT AND NAPROC INITIALIZATION EDIT ERROR (ME!)
;<133-TENEX>SWPMON.MAC;27    19-JAN-75 19:38:25    EDIT BY LYNCH
; SET DEFAULT KFACTOR TO 0.0 (EVERYONE GETS SOME WINDFALL)
;<133-TENEX>SWPMON.MAC;26    18-JAN-75 19:47:14    EDIT BY LYNCH
; PATCHED FIFLOD RETURN.
;<133-TENEX>SWPMON.MAC;25    18-JAN-75 13:50:10    EDIT BY LYNCH
;<133-TENEX>SWPMON.MAC;24    17-JAN-75 11:14:25    EDIT BY LYNCH
; ADDED OPERFN TO RELOAD PDP-15.
;<133-TENEX>SWPMON.MAC;22    16-JAN-75 11:59:15    EDIT BY UNTULIS
; ADD FORK TABLES FOR FORK STATUS EPHEMERON
;<133-TENEX>SWPMON.MAC;21    12-JAN-75 07:50:42    EDIT BY LYNCH
;<133-TENEX>SWPMON.MAC;20    11-JAN-75 11:28:46    EDIT BY LYNCH
; PUT LINE SCANNER SCRUBBER IN CHKR FOR NOW.
;<133-TENEX>SWPMON.MAC;19    11-JAN-75 11:16:13    EDIT BY LYNCH
;<133-TENEX>SWPMON.MAC;18    11-JAN-75 10:35:12    EDIT BY LYNCH
; PUT **** IN FRONT OF SYSTEM MESSAGES AGAIN.
;<133-TENEX>SWPMON.MAC;17    10-JAN-75 22:10:18    EDIT BY OP
;<133-TENEX>SWPMON.MAC;16    10-JAN-75 21:57:22    EDIT BY OP
;<133-TENEX>SWPMON.MAC;15     5-JAN-75 21:28:42    EDIT BY LYNCH
;<133-TENEX>SWPMON.MAC;13     4-JAN-75 20:07:34    EDIT BY UNTULIS
; ADD .SETNT JSYS
;<133-TENEX>SWPMON.MAC;9     4-JAN-75 00:06:18    EDIT BY UNTULIS
; ADD OUR LOCAL MODS TO BBN 133 SWPMON
;<133-TENEX>SWPMON.MAC;322     2-JAN-75 12:37:10    EDIT BY TOMLINSON
; FIX DDTRCL TO WORK EVEN IF ALREADY RECLAIMED.
;<133-TENEX>SWPMON.MAC;321    31-DEC-74 09:06:29    EDIT BY TOMLINSON
; FIX UP HANDLING OF ACCIFG
;<133-TENEX>SWPMON.MAC;320    30-DEC-74 11:14:54    EDIT BY CALVIN
; Changed way ACTINI is called
;<133-TENEX>SWPMON.MAC;319    19-DEC-74 13:23:49    EDIT BY ALLEN
; TAKE OUT SETOM PIEGRP(A) IN  LOGOUT & FIX LGCJM0 BUG
;<133-TENEX>SWPMON.MAC;318    17-DEC-74 13:11:04    EDIT BY CLEMENTS
; FIXED TYPO IN OPRFN
;<133-TENEX>SWPMON.MAC;317    16-DEC-74 16:32:05    EDIT BY CLEMENTS
; DISABLE CRJOB DUE TO INADEQUATE TIME FOR EXEC CHANGES AND TEST
;<133-TENEX>SWPMON.MAC;316    12-DEC-74 14:55:07    EDIT BY CALVIN
; Added OPRFN for putting out a new UACHK.FILE (ACTINI)
;<133-TENEX>SWPMON.MAC;315    11-DEC-74 21:41:05    EDIT BY CLEMENTS
; FIXES TO PREVIOUS PASS
;<133-TENEX>SWPMON.MAC;314    11-DEC-74 16:33:53    EDIT BY CLEMENTS
; LOGOUT WAITS TILL JOB NOT OWNED, AND LOGS OUT ALL OWNED JOBS
; ADD USRSPC,SYSSPC TO OPRFN. ALLOW OPEN JFN'S AT GET JSYS.
;MAKE CRJOB STARTUP OPEN THE JFN BEFORE GET, PREVENTING ITRAP.
;MAKE EXECI SHORTSTOP CRJOB TRAPS.
;<133-TENEX>SWPMON.MAC;313    10-DEC-74 17:10:50    EDIT BY CALVIN
; Rewrote LGCJM0 routine
;<133-TENEX>SWPMON.MAC;312    10-DEC-74 10:59:25    EDIT BY ALLEN
; RESET PIEGRP ENTRY TO -1 ON LOGOUT
;<133-TENEX>SWPMON.MAC;311     9-DEC-74 16:20:59    EDIT BY CLEMENTS
; FIXES IN CRJOB
;<133-TENEX>SWPMON.MAC;310     8-DEC-74 23:25:10    EDIT BY CLEMENTS
; MORE CRJOB
;<133-TENEX>SWPMON.MAC;309     8-DEC-74 17:53:10    EDIT BY CLEMENTS
;MORE CRJOB
;<133-TENEX>SWPMON.MAC;308     8-DEC-74 16:16:38    EDIT BY CALVIN
; Made .LGCJM be LGCJM0 to keep everyone happy
;<133-TENEX>SWPMON.MAC;307     8-DEC-74 15:40:32    EDIT BY CLEMENTS
; ADD CRJOB JSYS CODE
;<133-TENEX>SWPMON.MAC;305	 6-DEC-74 16:38:52	EDIT BY CALVIN
; Added call to account verifying initer, .LGCJM for CACCT
;<133-TENEX>SWPMON.MAC;305     5-DEC-74 16:59:04    EDIT BY CLEMENTS
; ADD ENTFLG TO OPRFN JSYS
;<133-TENEX>SWPMON.MAC;304     5-DEC-74 12:45:07    EDIT BY CLEMENTS
; AT LOGOUT, CALL FAST OR SLOW HANGUP ROUTINE DEPENDING WHETHER LGD IN
;<133-TENEX>SWPMON.MAC;303     3-DEC-74 12:19:16    EDIT BY CLEMENTS
;<133-TENEX>SWPMON.MAC;302    26-NOV-74 18:13:38    EDIT BY CLEMENTS
; ADD OPRFN JSYS
;<133-TENEX>SWPMON.MAC;301    12-NOV-74 17:00:38    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;300    11-NOV-74 13:38:31    EDIT BY CLEMENTS
; ALLOW EXEC0 TO START WITH -1 FOR CONTROLLING TTY (DETACHED CRJOB)
;<133-TENEX>SWPMON.MAC;299     7-NOV-74 13:59:51    EDIT BY CLEMENTS
; SMALL COSMETIC FIXES
;<133-TENEX>SWPMON.MAC;298     1-NOV-74 14:05:01    EDIT BY CALLEVA
;<133-TENEX>SWPMON.MAC;297    21-OCT-74 16:58:52    EDIT BY ALLEN
; FIX BUG IN NAPROC MAINTENANCE
;<133-TENEX>SWPMON.MAC;296    16-OCT-74 19:52:05    EDIT BY ALLEN
; CORRECT CPUTIME OVERFLOW PROBLEM IN ASGDSH
;<133-TENEX>SWPMON.MAC;295    12-OCT-74 20:20:30    EDIT BY ALLEN
; CHANGE NAME OF CHECKDSK TO CHECKDISK AS A PRECAUTION AGAINST
; AN OLD VERSION BEING USED ON MULTIPACK SWAP SYSTEM
;<133-TENEX>SWPMON.MAC;294    11-OCT-74 16:18:56    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;293    11-OCT-74 15:36:41    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;292    11-OCT-74 15:34:30    EDIT BY ALLEN
; ADD MONDSC GETAB TABLE
;<133-TENEX>SWPMON.MAC;291     7-OCT-74 12:54:59    EDIT BY CLEMENTS
; PREVENT HUNG JOBS DOING GET FROM TTY DESIGNATORS IN GTSVI
;<133-TENEX>SWPMON.MAC;290    26-SEP-74 22:56:25    EDIT BY ALLEN
; GRPLOK NON-RESIDENT AGAIN. FIX BUG IN LOGOFF OF NON-LOGGED IN JOB
;<133-TENEX>SWPMON.MAC;289    25-SEP-74 13:09:13    EDIT BY TOMLINSON
; INITIALIZE FKDIR FOR AUTOJOBS
;<133-TENEX>SWPMON.MAC;288    25-SEP-74 13:03:41    EDIT BY ALLEN
; MAKE GRPLOK RESIDENT AND CALL LCKTST ON FAILURE TO LOCK
;<133-TENEX>SWPMON.MAC;287    20-SEP-74 20:54:00    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;286    15-SEP-74 21:28:00    EDIT BY ALLEN
; CORRECTIONS FOR STARTING PIE-SLICE SYSTEM WITH NEW FILE SYSTEM
;<133-TENEX>SWPMON.MAC;285     5-SEP-74 17:00:54    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;284    23-AUG-74 11:36:49    EDIT BY ALLEN
; ADD FDFMTF GETAB TABLE
;<133-TENEX>SWPMON.MAC;283    31-JUL-74 10:48:23    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;282    23-JUL-74 19:54:23    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;281    23-JUL-74 16:41:41    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;280    22-JUL-74 11:08:53    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;279    19-JUL-74 16:56:39    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;277    18-JUL-74 16:52:42    EDIT BY ALLEN
;<133-TENEX>SWPMON.MAC;276    15-JUL-74 10:24:13    EDIT BY PLUMMER
; ADD HSYST5 TO SYSTAT TABLE
;<133-TENEX>SWPMON.MAC;275    11-JUL-74 17:52:27    EDIT BY CLEMENTS
; CONDITIONAL AROUND CALL TO HSTINI IN EXEC0
;<133-TENEX>SWPMON.MAC;274    10-JUL-74 17:54:31    EDIT BY CLEMENTS

;5 JUL 72, 1326:

	SEARCH PROLOG
	TITLE SWPMON

;SWAPPABLE MONITOR ROUTINES, JSYS'S, ETC. - D. MURPHY

	EXTERN MODES		; FOR ACCOUNTING AT SRI
	EXTERN MENTR,MRETN,SKMRTN,MRETNE,UJSYS
	EXTERN ISKED,PSKED,NSKED,RSKED,BUGHLT,BUGNTE,BUGCHK
	EXTERN FORKX,FKPGS,INSKED,NPMAX,JB0FLG,DDTIME,IOIP
	EXTERN CHNSON,ITRAP,JOBPT,JOBRT,PSIRQB,TODCLK,FKJOB
	EXTERN GETCHA,RSKP,R,JFNOFN,SETMPG,BLOCKW,FRZB1,FRZB2,FRZBB
	EXTERN JBFINI,FILINI,HSTINI,SYSIFG
	EXTERN MMSPTN,CHKTIM,CHKTM1,DDMPFK,DRMIN0
	EXTERN MRPACS,SWAKES,SBLKTM,FKWSP,PSILOB
	EXTERN ASSFK,EDISMS,FKPT,FKSTAT,FREFK,JSKP,JRET,WTLST,HLTJB
	EXTERN ILIST,DDMP,FPTA,SETPT,HALTF1,BLOCK1,HALTT
	EXTERN CLRM0,FKINT,FORCTM,HLTFK1,PSIR4,SUSFKR,SUSWT,WTFPGS
	EXTERN PRIMRY,CAPMSK,CAPENB,MLKPG,MULKPG,TENDMP
	EXTERN NXTDMP,TTPSRQ,ITRAP1,SETOVF,SPTC,SPC1
	EXTERN JOBNAM,NNAMES,SNAMES,STIMES,SPFLTS,CRSTAD,CGFLG
	EXTERN SUPERP,PARALP,INFERP,PSIT1A,PWRDWN,PASSWC,ACCIFG
	EXTERN NTTYIN,NTTYOT,GETDDB,DDBMAX,USTDIR,SYSRST,FKDIR
	EXTERN ACTINI,ACTIN1

; LINKAGE TO SYSTEM VERSION INFO

EXTERN	SVNN,SVN,SVNUM

IFDEF IMPCHN,<

; LINKAGE TO NETWRK

	EXTERN NETKFK,NETON,FIFONL			;*** SRI-AIC ***

; LINKAGE TO IMPDV

EXTERN	IMPBEG,IMPRDY,IMPLBT,IMPHRT,HSTSTS,IMPNLK,IMPLT1,IMPLT2,IMPLT3,IMPLT4
EXTERN	NLHOST,CHKNET>
IFDEF DSPCHN,<
	EXTERN DSPKFK>

; LINKAGE TO DSK

EXTERN	DIDSCA,MAPBTF,CVDSK,UDSKIO,NSECPG,DISKP,WRMON,WRSWM
EXTERN	CHKBT,DSKRBS,DSKRCE,DSKNRE,DSKLER,DSKRER,NDSKEW,DSKRML,DSKSML

; LINKAGE TO DRM

EXTERN	DRMCFE,DRMFRE,NDRMEW
;   LINKAGE TO PDP-15				;*** SRI-AIC ***
EXTERN FIFBEG,FIFERW,BUGFIF,FDBGSW		;*** SRI-AIC ***

; LINKAGE TO TTYSRV

EXTERN	NORMTF,TTICB1,TTICB2,TAB81,TAB82,OTYLIN,TTFORK,TTHNGU
EXTERN	TCITST,PSICHL,PSICHU,PSICHO,PSICH,TTPSI,TTDPSI
EXTERN RSTMSG,SRIFLG				;*** SRI-AIC ***

; LINKAGE TO SCHEDULER

EXTERN	JOBSRT,SCDRQ7,ENTFLG,DBUGSW,DCHKSW

; MISCELLANEOUS OTHER EXTERNS

EXTERN MAKPGA,MAKPGU,DDTPRS,SYMPRS,DDTX,PLCKT
	EXTERN SETLFK,SETLF1,SETJFK,CLRLFK,CLFRET,FKHPTN
	EXTERN	BHC,BITS,DTIALL,RLMX0
EXTERN FACTSW
EXTERN .JBUSY,SWPCOR,MONCOR,JOBRTT,MAPDIR,DIRDSK

WHEEL==:1B18
OPER==:1B19
CONF==:1B20		;CONFIDENTIAL INFO ACCESS
MAINT==:1B21		;MAINTENANCE CAPABILITY
LOG==:1B21		;LEFT HALF


IFN PIESLC,<

;STORAGE FOR PIE-SLICE GROUP DATA FILE
NGSP GRPFIL,NGRPPG			;PLACE TO MAP THE FILE

TOTSHR=:GRPFIL				;TOTAL NUMBER OF SHARES

;EACH PIE-SLICE GROUP ENTRY CONTAINS THE FOLLOWING FIELDS
BEGDAT=:GRPFIL+1			;START DATE OF GROUP
CPUSED=:GRPFIL+2			;CPU TIME USED BY GROUP
SSHARE=:GRPFIL+3			;NUMBER OF SHARES OWNED BY GROUP
GRPNM=:GRPFIL+4				;GROUP NAME (SIXBIT)
;NOTE THAT THERE ARE 3 UNUSED WORDS PER GROUP ENTRY

;OTHER SWAPPABLE STORAGE FOR PIE-SLICE SCHEDULER
NGS NJBGRP,NGRPS		;NUMBER OF JOBS PER GROUP
NGS KFACT,1			;MULTIPLICATIVE FACTOR FOR WINDFALL
NGS PIEFLG,1			;NON-ZERO MEANS PIE SLICE DATA FILE
				;SUCCESSFULLY MAPPED
NGS GRPLOK,1			;PIE-SLICE DATA LOCK

;PIE-SLICE GROUP FILE PARAMETER GETAB TABLE (DO NOT SEPARATE ENTRIES)
	SWAPCD
GRPDES:	NGRPPG
	NWDGRP
	NGRPS
NGRPD=.-GRPDES

	RESCD

;LINKAGE TO RESIDENT PIE-SLICE SCHEDULER VARIABLES
	EXTERN PIEGRP,DSHARE

>;END PIE-SLICE SCHEDULER CONDITIONAL



	INTERN	CHKBG1,CHKH1,WHEELX,CAPX
	INTERN	.SETNT				;*** SRI-AIC ***
	INTERN .DTACH,.ATACH
	INTERN EXEC0,EXECI,.EXEC,EXBUGH,GETMST,WMST
	INTERN WHEEL,OPER,SWCEND
	INTERN JB0TT,OPTT,MDDT
	INTERN GETSWM,DDTFSH,DDTRCL,RCADDT,SAVE36,SAVE32
	INTERN MKPGSA,MKPGSU
	INTERN CHKR,GETPAT,ULKSM1,RUNDD
	INTERN .GJINF,.TIME,.JOBTM,.RUNTM,.GTRPI,.GTDAL,.HSYS,.USRIO
	INTERN .GETAB,.SYSGT,.PEEK
	INTERN .SETNM,.GETNM
	INTERN .SWTCH,.LITES
	INTERN .LGOUT,FLOGO
	INTERN LOGTOT,LOGDES,LOGONM,LOGCJM
	INTERN .GET,.SAVE,.SSAVE
	INTERN CHKR1,.SETNT			;*** SRI-AIC ***
	INTERN LGCJM0

SSTSIZ==36000		;MAX SIZE OF SWP SYM TAB
DDTSYM=MDDT+1		;PTR TO DDT SYMTAB PTR

NGSP BUGTAB,SBUGTF/1000			;BUG TABLE AND STRINGS
NGSP SWPST,SSTSIZ/1000		;SWP SYM TAB

	DEFINE TMSG
<	PUSHJ P,TMSGQ>

; FOLLOWING IS A GETTAB TABLE
LOGDES:	LOGTTY			;DESIGNATOR FOR LOG MSGS - DEF IN PARAMS
JB0TT:	JB0TTY			;DESIG FOR JOB 0 AND ERR MSGS
OPTT:	OPTTY			; DESIGNATOR FOR OPERATOR
NLGDES==.-LOGDES
;END OF GETTAB

;THE FOLLOWING IS THE MONITOR DESCRIPTOR GETAB TABLE ("MONDSC")
;CURRENT ASSIGNMENTS:
;WORD0, B0 = 0 MEANS NO PIE-SLICING
;	  = 1 MEANS PIE-SLICE SYSTEM
;WORD0, B1 = 0 MEANS CONTIGUOUS DISK SWAP AREA
;	  = 1 MEANS MULTI-PACK SWAPPING 

MONDSC:: <PIESLC>B0

NMNDSC==.-MONDSC


; STUFF FOR NON-JOB0 AUTOJOB STARTUP FROM FILE

GS AUTONX,1		; STATE OF NON-JOB0 STARTUP
			; + CHARACTER POINTER TO STARTUP FILE
			; -1 DONE

; ALL JOBS START HERE, INCLUDING THE BEGINNING OF JOB 0 WHICH DOES
;  LOTS OF INITIALIZATION INCLUDING GETTING IN THE SWAPPABLE MONITOR FROM
;  DISK OR DECTAPE. THE MECHANISM FOR GETTING HERE IS AS FOLLOWS:
; EITHER A ^C ON AN IDLE LINE OR THE EXPLICIT CALL AT SYSGO IN PISRV
;  FOR THE FIRST JOB, OR AUTO-JOBS AT SPCSTJ, CALL SCDRQ WITH A REQUEST
;  FOR THE SCHEDULER TO RUN JOBSRT (WITH A TTY LINE NUMBER AS ARGUMENT).
;  JOBSRT GRABS A JOB AND INITIATES A FORK-CREATION PSI ON IT. WHEN
;  THE FORK INITIALIZES ITSELF, IT SEES THAT IT IS THE TOP FORK IN
;  A JOB, AND SETS ITS PI PC TO EXEC0. THEN IT DEBREAKS, AND LO AND
;  BEHOLD IT IS RUNNING HERE AT PROCESS LEVEL.

EXEC0:	MOVSI 1,UMODF		;SIMULATE CALL FROM USER
	MOVEM 1,FPC
	JSYS MENTR
	SKIPN SYSIFG		;NEW SYSTEM?
	CALL GETSWM		;YES, GET SWAPPABLE MONITOR
	MOVEI 1,FKPTRS
	MOVEI 2,NUFKS
	CALL ILIST
	MOVE 1,0(1)		;GRAB FIRST SLOT FOR TOP FORK
	MOVEM 1,FREJFK
	SETZM FKPTRS
	MOVE 1,FORKX
	HRROM 1,SYSFK		;SYSFK=JOB CTTY,,FORK INDEX

IFN PIESLC,<
	MOVSI 2,NOCNT##
	ANDCAM 2,FKFLGS##(1)	;FORK NOW IN SYSFK, OK TO MAINTAIN NAPROC
	MOVE 2,JOBNO
	MOVE 2,PIEGRP(2)
	MOVSI 1,(1.0)
	FADRM 1,NAPROC(2)	;DO THIS NOW BECAUSE IT WASN'T DONE
				;WHEN THIS FORK ENTERED BALSET

> ;END PIE-SLICE SCHEDULER CONDITIONAL

	MOVE 1,[XWD SYSFK+1,SYSFK+2]
	SETOM -1(1)		;INIT REMAINDER OF TABLE
	BLT 1,SYSFK+NUFKS-1
	SETOM TTJTIW
	MOVSI 1,<JFCL>B53
	MOVEM 1,MONINT		;FOR DDT BREAKPOINT
	MOVE 1,[XWD ITFPC,EXECI]
	MOVEM 1,MONBK
	SETZ 1,
	MOVEI 2,3		;ENABLE CHANS 34 AND 35 FOR ^P
	MOVEM 2,MONCHN		;AND GRAB THEM IF THEY HAPPEN
	AIC
	CALL JBFINI		;INIT FILE SYS FOR THIS JOB
	SKIPE SYSIFG		;SYSTEM INITIALIZED?
	JRST SYSINE		;YES
;FOLLOWING CODE ONLY EXECUTED FOR FIRST JOB IN SYSTEM
	SKIPE DIDSCA		; REFRESHING DISK?
	 SETOM ACCIFG		; NO, ASSUME SPECIAL FILES SHOULD EXIST
	CALL FILINI		;INIT FILE SYSTEM
	CALL ACTINI		; CALL ACCOUNT VERIFYING INITER
	 JFCL			; IT'LL DO THE BUGCHK ON FAIL
IFN PIESLC,<SETZB 1,PIEFLG>	; ASSUME NO PIE-SLICE FOR NOW
	SKIPN ACCIFG		; SHOULD SPECIAL FILES EXIST?
	 JRST EXEC1		; NO, SKIP SOME THINGS
IFDEF IMPCHN,<
	CALL HSTINI		; INITIALIZE HOST NAME TABLE
	 BUG(CHK,<FAILURE TRYING TO INIT HOST NAME TABLES>)
>
	CALL MAPBTF		;INIT DSK BIT TABLE

IFN PIESLC,<
	CALL MAPGRP		;MAP PIE-SLICE GROUP DATA FILE
	SKIPN 1,PIEFLG		;MAPPING SUCCESSFUL?
	 JRST EXEC1		;NO

	MOVE 1,[INIGP]		;GET DEFAULT GROUP NAME
	CALL GRPLUK##		;LOOK UP IN FILE
	BUG (HLT,<DEFAULT GROUP NAME NOT IN FILE>)
>
EXEC1:
IFN PIESLC,<
	MOVEM 1,DEFGP##		;RECORD DEFAULT GROUP INDEX FOR STARTING JOBS
	MOVEM 1,PIEGRP		;USE FOR THIS JOB (JOB 0)
	SETZM NAPROC		;CLEAR COUNTER INCREMENTED FOR FIRST FORK
	MOVSI 2,(1.0)		;AND SET THE CORRECT COUNTER
	MOVEM 2,NAPROC(1)

	MOVSI 2,(0.0)		;INITAL VALUE FOR KFACT
	MOVEM 2,KFACT

	SETOM GRPLOK		;INITIALIZE PIE SLICE DATA LOCK
>

	MOVE 1,[XWD SBSNMS,SNAMES]
	BLT 1,SNAMES+NSBSNM-1	;MOVE REGULAR SUBSYSTEM NAMES TO TABLE
	MOVNI 1,NSBSNM		;INIT TABLE POINTER WITH NEG COUNT
	MOVEM 1,SNMPT
	SETOM SNMLCK		;AND INIT LOCK
	SETOM LOGLCK
	MOVE A,[JOBONT,,JOBONT+1] ;CLEAR BACK-POINTERS
	SETOM JOBONT		; TO OWNING JOBS. NOTE JOB 0
	BLT A,JOBONT+NJOBS-1	; IS NOT OWNED BY ANYBODY.

SYSINE:	MOVEI 1,0		;ASSUME WILL BE ABLE TO LOG IN
	MOVE 2,SPTC		;CHECK FOR FULL SYSTEM
	CAIL 2,SSPT-NOFN-100	;ROOM IN SPT?
	MOVEI 1,LGINX3##	;NO. (THESE FAILURES SHOULD BE SEPARATE)
	MOVE 2,DRMFRE		;DRUM SPACE?
	CAMG 2,DRMIN0##
	MOVEI 1,LGINX3
	SKIPE FREJOB##
	SKIPN FREFK		;ANOTHER JOB AND FORK LEFT?
	MOVEI 1,LGINX3		;NO.
	MOVEM 1,LGNPAR		;SAVE ZERO OR FAIL CODE FOR LOGIN JSYS
	MOVE 1,JOBNO
IFN PIESLC,<
	MOVE 2,PIEGRP(1)
	AOS NJBGRP(2)
> ;END PIE-SLICE SCHEDULER CONDITIONAL
	HLRZ 2,JOBPT(1)		;GET TTY NUMBER TO START ON
	CAIE 2,-2		;SPECIAL FLAG THAT THIS IS CRJOB START?
	JRST EX0NCJ		;NOT CREATE-JOB
	SKIPL 2,CRJTTY		;YES. SEE WHAT TTY REALLY IS
	HRLM 1,TTFORK(2)	; ..
	HRLM 2,JOBPT(1)		;REASSIGN THE TTY TO NEW JOB
	MOVEM 2,CTRLTT		; ..
	SKIPE LGNPAR		;WILL IT SUCCEED?
	JRST [	MOVEI 1,CRJBX6##;NO, SAY SYSTEM FULL TO CALLER
		MOVEM 1,CRJANS##
		JRST LOGO]	;AND KILL OFF THE NEW JOB
	SETOM LGNPAR		;FLAG IN LGNPAR THAT THIS IS A CRJOB
EX0NCJ:	NOINT
	HRROI 2,[ASCIZ /<PMFDIR0>JOBPMF/]
	MOVE 1,JOBNO
	CAIGE 1,10
	HRROI 2,[ASCIZ /<SYSTEM>JOBPMF/] ;SYSTEM DIR FOR FIRST JOBS
	MOVSI 1,(1B5+1B8+1B17)	;TEMP FILE,IGN DEL AND SHORT FORM GTJFN
	GTJFN
	JRST PMFBAD
	HRRZM 1,JOBPMF
	MOVEI 2,1B19+1B20+1B21+1B25	;IN, OUT, XCT, THAWED
	OPENF			;OPEN PMF
	JRST PMFBAD
PMFB1:	SKIPGE 1,CTRLTT		;GET CONTROLLING TTY IF ANY
	JRST EXEC0A		;NONE. STARTING DETACHED JOB.
	HRLI 1,600012		;CONSTRUCT DEVICE DESIGNATOR FOR CTRLTTY
	JFCL ;	ASND			;ASSIGN IT
	JFCL
EXEC0A:	TIME
	MOVEM 1,CONSTO		;SET CONSOLE TIME ON
	MOVE 1,JOBNO		;FIRST FEW JOBS ARE SPECIAL,
	CAIGE 1,NSPECJ		;IS THIS ONE OF THEM?
	JRST [	MOVE 2,BHC+1	;YES, FAKE A LOGIN AS SYSTEM
		MOVEM 2,JOBDIR(1)
		MOVSI 3,200000	; GET STRING ACCOUNT PERMISSION BIT
		MOVEM 3,MODES	; PLANTIT IN JSB
		MOVE 3,FORKX
		MOVEM 1,FKDIR(3)
		HRRZ 2,SPECJT(1)
		JRST 0(2)]	;GO DO THE SPECIAL FUNCTION
	SKIPGE CTRLTT		;ATTACHED TO A TERMINAL?
	JRST EXEC0B		;NO -- SKIP TTY INITIALIZATION
	MOVEI 1,100
	MOVEI 2,3B33		;SET TO HDX HERE, SO SETTING TO FDX
	STPAR			;BELOW WILL FORCE OUT TELNET CONTROL
	MOVE 2,NORMTF		;GET TTY TO STANDARD STATE
	SFMOD
	STPAR			;SET DEVICE PARAMETERS TOO
	HRRZ	3,CTRLTT	;GET CONTROLLING TTY	*** SRI-AIC ***
	HRRZ	2,SRIFLG(3)	;GET DEFAULT FOR THIS LINE  *** SRI-AIC ***
	STTYP			;INIT TERM TYPE TO 0
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	MOVE 2,TAB81		;GET STANDARD TAB STOPS
	MOVE 4,2
	MOVE 3,TAB82
	STABS			;SET CONTROLLING TTY
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1		;ALL REMOTE
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL

EXEC0B:	SKIPGE LGNPAR		;CRJOB STARTUP?
	JRST STCRJB		;YES.
	MOVE 1,[CHKDSE]		;CHKDSK ERRORS?
	TDNE 1,FACTSW
	JRST	[HRRZ 3,CTRLTT		;YES, ALLOW CTY & DIALUP TO FIX
		CAME 3,OTYLIN		;DIALUP LINE?
		CAIN 3,CTYLIN		;OR OPERATORS CONSOLE
		JRST STEX		;START THE EXEC
		MOVEI 1,SYSINT		;HAVE AUTOJOBS WAIT FOR DISK OK
		JSYS EDISMS
		JRST .+1]
	SETO 3,
	EXCH 3,AUTONX		; PREVENT FURTHER AUTO START UP
	JUMPGE 3,SPECJB		; IF ANY MORE AUTOSTARTUP, DO IT
	JRST STEX		;GO START EXEC

SYSINT:	MOVE 1,[CHKDSE]	;DISK ERRORS FIXED?
	TDNE 1,FACTSW
	JRST 0(4)		;NO
	JRST 1(4)		;YES

PMFBAD:	BUG(CHK,<PMF FAILURE>)
	MOVE 1,JOBPMF
	RLJFN
	JFCL
	SETOM JOBPMF
	SETZM PSIBW		;FLUSH ANY BREAKS, E.G. DATA ERROR
	OKINT
	JRST PMFB1		;ALLOW JOB WITH NO PMF


;REGULAR SUBSYSTEM NAMES FOR INCLUSION IN SNAMES TABLE AT STARTUP

SBSNMS:	SIXBIT /EXEC/
	SIXBIT /(PRIV)/
NSBSNM==.-SBSNMS

;TABLE DEFINES SPECIAL PURPOSE FOR FIRST FEW JOBS

SPECJT:	XWD 0,RUNDD		;JOB 0 IS ALWAYS DISK CHECKER, ETC.

NSPECJ==.-SPECJT		;NUMBER OF SPECIAL JOBS

;EACH SPECIAL JOB CALLS THIS TO DETACH AND START THE NEXT ONE

DONSJ:	CALL LOGONM		;DO LOGIN STUFF
	MOVE 4,CTRLTT
	DTACH
	MOVE 1,JB0TT
	HRRM 1,PRIMRY		;USE JOB 0 TTY FOR ANY OUTPUT
	MOVE 1,JOBNO
	CAIGE 1,NSPECJ-1		;MORE SPECIAL JOBS TO DO?
	JRST DONS1		;YES
	RET
DONS1:	MOVE 2,4
	CALL SPCSTJ		; START ANOTHER JOB ON THIS TTY
	RET


; ATERNATE STARTUP MECHANISM TO START JOBS FROM FILE "AUTOJOBS"

SPECJB:	PUSH P,3
	MOVE 1,JOBNO
	MOVE 2,BHC+1
	MOVEM 2,JOBDIR(1)	; FAKE LOGIN AS SYSTEM
	PUSH P,LOGDES		; SAVE TRUE LOGDES
	MOVEI 3,377777
	MOVEM 3,LOGDES		; MAKE AUTOJOB LOGINS SILENT AND FAST
	MOVSI 3,200000		; SRI DIDDLE FOR ALPHANUMERIC ACCOUNTS
	MOVEM 3,MODES		; TO ALLOW ACCOUNT CHANGING BY AUTOJOB PROGRAMS.
	MOVE 3,FORKX
	MOVEM 2,FKDIR(3)
	PUSHJ P,LOGONM		; AND PRINT LOGIN MESSAGE
	POP P,LOGDES
	POP P,3
	MOVE 1,DBUGSW
	HRROI 2,[ASCIZ /<SYSTEM>AUTOJOBS.RUN/]
	CAIN 1,2
	HRROI 2,[ASCIZ /<SYSTEM>AUTOJOBS.DEBUG/]
	MOVSI 1,(1B2+1B17)	; OLD FILE & STRING & SHORT FORM
	GTJFN
	 JRST SPECJ5		; FILE NON-EXISTENT
	PUSH P,1		; SAVE IT
	PUSH P,LOGDES
	MOVEI 2,377777
	MOVEM 2,LOGDES
	DTACH			; DETACH THIS JOB
	POP P,LOGDES		; GO BAC TO LOGTTY BEING REAL
	MOVE 2,[7B5+1B19]
	OPENF			; OPEN TO READ
	 JRST [	POP P,1
		RLJFN
		 JFCL
		JRST SPECJ9]	; COULDN'T OPEN
	MOVE 2,3		; START POINT
	SFPTR
	 JRST SPECJ8		; HADN'T OUGHT TO HAPPEN
	HRLZ 2,1		; MAKE IT BE INPUT FOR GTJFN
	HRRI 2,377777		; NO OUTPUT
	MOVSI 1,(1B2+1B16+1B17)	; OLD FILE, FILE INPUT, SHORT FORM
	GTJFN
	 JRST SPECJ6		; FILE APPARENTLY NOT THERE
	EXCH 1,0(P)		; SAVE JFN OF TASK, GET JFN OF AUTOJOBS
	CALL SPECJN		; GET NEXT ONE STARTED
	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>EXEC.SAV/]
	GTJFN
	JRST [	POP P,1		; NO EXEC?  GET RID OF JFN
		RLJFN
		JFCL
		JRST SPECLO]	; AND LOGOUT
	HRLI 1,400000
	GET			;GET CURRENT EXECUTIVE
	XCTMU [POP P,2]		; PUT JFN OF SAVE FILE IN AC2 OF EXEC
	HRRO 1,JB0TT		;GET JOB 0 TTY FOR PRIMARY
	UMOVEM 1,1		;GIVE IT TO EXEC TO USE.
	HRRZ 1,ENTVEC
	ADDI	1,2		;GO TO AUTO JOB ENTRY POINT
	HRRM 1,0(P)
	JRST MRETN

SPECJ6:	POP P,1
	CALL SPECJN		; SKIP TO NEXT TASK
SPECLO:	SETO 1,
	LGOUT			; LOG OURSELVES OUT
	 JFCL
	BUG(HLT,<IMPOSSIBLE FAILURE OF LGOUT(-1)>)

SPECJ8:	POP P,1
	CLOSF
	 JFCL
SPECJ9:	BUG(CHK,<SPECJB:  AUTOJOB FILE SCREWED UP>)
SPECJ5:	HRROI 1,[ASCIZ /NO AUTOJOBS FILE
/]
	PSOUT
	DTACH			; CAUSE SPECJL TO START A NEW EXEC
	CALL SPECJL		; PRETEND THIS WAS LAST TASK
	JRST SPECLO		; GO LOGOUT

SPECJN:	BIN			; SKIP TO NON-SEPARATOR
	JUMPE 2,SPECJ7		; NULL == EOF, FINISH UP
	CAIG 2,40		; SPACE OR LESS IS TO BE SKIPPED
	 JRST SPECJN
	RFPTR			; GET WHERE WE ARE AT
	 JFCL
	SOS 2			; MINUS ONE
	MOVEM 2,AUTONX		; IS NEXT PACE TO START
	CLOSF			; DONE WITH AUTOJOBS FILE
	 JFCL
	MOVEI 2,CTYLIN
	CALL SPCSTJ		; THEN START UP NEXT ON CTYLIN
	RET			; CONTINUE STARTING THIS TASK

SPECJ7:	CLOSF			; CLOSE AUTOJOBS FILE
	 JFCL
SPECJL:	MOVE 3,[CHKDSE]		;CHECK DEBUG AND ERROR CONDITIONS
	MOVE 1,DBUGSW
	TDZN 3,FACTSW		;IF DSK ERRORS, CLEAR 3 AND SKIP
	CAIN 1,2		;IF DEBUGSW AT 2, DONT ALLOW ON.
	JRST	.+4		;ONE OR THE OTHER FAILED *** SRI-AIC ***
	SETO	3,		;PERMIT ENTRIES NOW,	 *** SRI-AIC ***
	SKIPG	ENTFLG		;BUT NOT IF ENTFLG ALREADY SET *** SRI-AIC ***
	SETOM	ENTFLG		;OK			  *** SRI-AIC ***
	HRROI 2,TNAMS2		;NOT AVAIL MSG, DEBUGGING
	CAIE	1,2
	HRROI 2,TIOMSG		;TENEX IN OPERATION MSG
	SKIPN 3			;DISK ERRORS?
	HRROI 2,TNAMS1		;YES. NOT AVAIL MSG DSK ERRORS.
	SKIPL	ENTFLG		;BUT SAY AVAILABLE ONLY IF OPERATOR ALLOWS *** SRI-AIC ***
	HRROI	2,TNAMS2	;NOT AVAILABLE			    *** SRI-AIC ***
	SETO 1,
	TTMSG
	GTAD			;IF WE NEED TIME AND DATE
	JUMPGE 1,R
	MOVEI 2,CTYLIN		; START JOB ON CTY
	CALL SPCSTJ
	RET

SPCSTJ:	NOSKED			;PREVENT RACE ON TTY STARTUP
	SKIPGE 1,TTFORK(2)	;IS THERE A JOB EXTANT
	TLNN 1,1		; OR STARTING ON THIS LINE?
	JRST 	[OKSKED		; YES
		RET]		; NOT ANOTHER.
	MOVSI 1,-2		;NO.. FLAG STARTING ONE.
	HLLM 1,TTFORK(2)	; ..
	MOVEI 1,JOBSRT
	HRL 1,2
	CALL SCDRQ7		;START JOB ON CTY TO GET T&D
	OKSKED
	RET

TNAMS1:	ASCIZ /
**** TENEX NOT AVAILABLE: DISK NEEDS FIXING.
/
TNAMS2:	ASCIZ /
**** TENEX NOT AVAILABLE
/
TIOMSG:	ASCIZ /
**** TENEX IN OPERATION
/

;GET SWAPPABLE MONITOR

	EXTERN BGTEND,LWTEND,GETSMF

GETSWM:	PUSH P,NPMAX		;SAVE CURRENT MAX SIZE
	MOVE 1,TOTRC
	MOVEM 1,NPMAX		;ALLOW ALL OF CORE WHILE GETTING SWM
	MOVEI 7,SWPMP0		;FIRST PAGE OF SWM
	MOVE 10,DSKSML		;SWP MONS DISK ADDRESS
	NOSKED
LOKSM1:	MOVEI 2,0(7)
	LSH 2,^D9
	SKIP 0(2)		;REF THE PAGE THEREBY ASSIGNING IT
	MOVEI 1,0(7)
	HRL 1,MMSPTN
	PUSH P,7
	CALL MLKPG		;LOCK THE PAGE
	POP P,7
	SKIPG GETSMF		;GETTING MONITOR FROM DISK?
	JRST LOKSM2		;NO
	MOVE 1,10		;YES, GET CURRENT ADDRESS
	CALL CVDSK		;CONVERT TO H'WARE FORMAT
	MOVEI 2,1000		;READ 1000 WORDS
	LDB 3,[POINT 11,MMAP(7),35] ;CORE PAGE NUMBER
	LSH 3,^D9		;CORE ADDRESS
	CALL UDSKIO		;OPERATE THE DISK
	ADDI 10,NSECPG		;INCREMENT DISK ADDRESS 4 SECTORS
LOKSM2:	CAMGE 7,SWCEND		;HIGHEST PAGE OF SWM
	AOJA 7,LOKSM1
	SKIPLE GETSMF		;GETTING FROM DISK?
	JRST LOKSM3		;YES, SKIP TENDMP CALL
	MOVSI 1,1
	SOJG 1,.		;WAIT AWHILE FOR DRUM OPS TO COMPLETE
	MOVE 1,[XWD BGTEND,LWTEND] ;COPY IT UP TO RUN ADDR
	BLT 1,377777		;MOVE TENDMP TO HIGH LOCATION
	PIOFF			;TO PREVENT DATA LATE
	MOVEM P,TW1
	JSR TENDMP		;CALL TO INTERPRET PRE-STORED STRING
	MOVE P,TW1
	PION

;GETSWM ...

LOKSM3:	MOVSI 6,WRITEB		;SET TO CLEAR WRITE BIT FROM MMAP
	MOVE 1,DBUGSW
	CAIN 1,2		;BUT IF DBUGSW = 2,
	SETZ 6,			;LEAVE IT WRITABLE
	MOVEI 7,SWPMP0
	MOVE 10,DSKSML		;DISK ADDRESS FOR POSSIBLE WRITING
ULKSM1:	ANDCAM 6,MMAP(7)	;CLEAR ANY UNWANTED ACCESS
	MOVEI 1,0(7)
	HRL 1,MMSPTN
	CALL MULKPG		;UNLOCK THE PAGES
	CAMGE 7,SWCEND
	AOJA 7,ULKSM1
	OKSKED
	POP P,NPMAX		;RESTORE NORMAL MAX SIZE
	SKIPN GETSMF		;IF FRESH START FROM DTA
	SKIPN DISKP		;AND DISK AVAILABLE
	JRST ULKSM2
	PUSH P,CAPENB		;SAVE CURRENT CAPS
	MOVEI 1,WHEEL		;WE NEED WHEEL FOR THE FOLLOWING
	IORM 1,CAPENB
	CALL WRMON		;WRITE RES AND SWP MON ON DISK
	CALL WRSWM
	POP P,CAPENB
	AOS GETSMF		;FLAG MON NOW ON DISK
ULKSM2:
	MOVE 1,DBUGSW		;SHOULD WE FLUSH DDT ?
	IOR 1,DCHKSW
	SKIPN 1
	CALL DDTFSH		;YES
	RET

;SWCEND IS SET BY POSTLD TO CONTAIN THE NUMBER OF THE HIGHEST
;PAGE CONTAINING SWAPPABLE CODE

SWCEND:	0

;FLUSH DDT AND SYMBOL TABLE AND MAKE PAGES AVAILABLE FOR SWAPPING
;RESIDENT DDT AND ITS SYMBOL TABLE CAN BE FLUSHED SEPARATELY
;THE CONTENTS OF CELL SYMDDT CONTROL WHAT GETS FLUSHED AS FOLLOWS
; C(SYMDDT)=0 MEANS FLUSH DDT AND SYMBOL TABLE
; C(SYMDDT)<>0 MEANS FLUSH SYMBOL TABLE ONLY
;THE FOLLOWING TWO CELLS DEFINE THE CURRENT STATUS
;  DDTPRS=0 MEANS DDT IS RESIDENT
;  SYMPRS=0 MEANS THE SYMBOL TABLE IS RESIDENT
;(NOTE THAT THE CODE WILL NOT ALLOW FOR A RESIDENT SYMBOL TABLE AND
;  A NON-RESIDENT DDT)

SYMDDT:	0
	SWAPCD

DDTFSH:	PUSH P,3		;SAVE REGISTERS
	PUSH P,2
	PUSH P,1
	NOINT			; PREVENT CONFUSION
	SETOM SYMPRS		; NO SYMBOLS
	SETZM SWPSTP		; CAUSE ANY MDDT'S TO TO FORGET SYMTAB
	SETZM 32		; NO RESIDENT SYMBOL TABLE
	SETZM 36
	SKIPE SYMDDT		;FLUSH SYMBOLS ONLY ?
	JRST [	HRRZ 1,SAVE36	;COMPUTE STARTING FLUSH ADDRESS
		MOVEI 3,777(1)	; AS FIRST PAGE .GE. SYMTAB BEG
		LSH 3,-^D9	; CONVERT ADDRESS TO PAGE NUMBER
		JRST DDTFS1]
	SETOM DDTPRS		; NO DDT
	MOVE 1,[JRST 4,100]	;CHANGE 100 DISPATCH
	MOVEM 1,100
	HRRZ 3,MONCOR		; START FLUSHING HERE
DDTFS1:	PUSH P,3		; SAVE FIRST PAGE
	MOVSI 2,(01B5)
DDTFSL:	SETZ 1,
	NOSKED			; INSURE CONSISTENT MMAP/CST0
	EXCH 1,MMAP(3)
	SKIPE 1
	MOVEM 2,CST0(3)		; MARK AS UNAVAILABLE
	OKSKED
	AOS 3
	CAMGE 3,RCADDT
	 JRST DDTFSL
	POP P,1			; FIRST PAGE FLUSHED
	MOVE 2,RCADDT
	SOS 2			; LAST PAGE FLUSHED
	CALL MKPGSA		; MAKE THEM ALL AVAILABLE
	OKINT
	POP P,1			;RESTORE REGISTERS
	POP P,2
	POP P,3
	RET			;RETURN

RCADDT:	0		;SAVE ADDRESS OF SWPCOR
SAVE36:	0		;SAVED LOCATION 36 (SYMBOL POINTER)
SAVE32:	0		;SAVED LOCATION 32 (UNDEF SYMBOL POINTER)

;RECLAIM DDT AND/OR SYMBOL TABLE (SEE ABOVE COMMENTS)

DDTRCL:	SKIPN SYMPRS		; HAVE SYMBOLS ALREADY?
	 JRST DDTRC0		; YES
	HRRZ 1,SAVE36
	MOVEI 1,777(1)
	LSH 1,-^D9
	SKIPE DDTPRS		; NEED DDT TOO?
	 MOVE 1,MONCOR		; THEN RESTORE FROM MONCOR
	MOVE 2,RCADDT		; THRU RCADDT
	CAMG	2,SWPCOR	;CORE ALREADY RECLAIMED   *** SRI-AIC ***
	JRST	DDTRC0		;YES, DON'T DO IT AGAIN   *** SRI-AIC ***
	SOS 2			; MINUS 1
	CALL MKPGSU		;GET THE PAGES
DDTRC0:	NOINT
	HRRZ 1,MONCOR		; START WITH MONCOR
	HRLZ 2,MMSPTN		;FIXUP THE MAP AND CST'S
	MOVSI 3,400000
	MOVSI 4,RWXB
DDTRC1:	HRR 4,1
	HRR 2,1
	NOSKED			; INSURE CONSISTENT MMAP/CST
	MOVEM 4,MMAP(1)
	MOVEM 3,CST0(1)		; PREVENT TRAPS
	MOVEM 1,CST1(1)
	MOVEM 2,CST2(1)
	OKSKED
	AOS 1
	CAMGE 1,RCADDT		; ALL DONE?
	 JRST DDTRC1		; NO, DO NEXT
	MOVE 4,MONCOR		;GET DDT AND SYMBOLS BACK FROM DISK
	SUB 4,RCADDT		; NEG NUMBER OF PAGES
	HRLZ 4,4
	HRR 4,MONCOR
DDTRC2:	MOVEI 1,-1(4)		;COMPUTE LINEAR DISK ADDRESS
	IMULI 1,NSECPG
	ADD 1,DSKRML
	CALL CVDSK		;CONVERT TO HARDWARE ADDRESS
	MOVEI 2,1000		;READ 1000 WORDS
	MOVEI 3,0(4)		;GET CORE ADDRESS
	LSH 3,^D9
	DSKOP
	AOBJN 4,DDTRC2		;ALL DONE, NO TO DDTRC2
DDTRC3:	MOVE 1,[JRST DDTX]	;UPDATE 100
	MOVEM 1,100
	MOVE 1,SAVE36		;SETUP SYMBOL TABLE POINTER
	MOVEM 1,36
	MOVE 1,SAVE32
	MOVEM 1,32
	SETZM DDTPRS		;INDICATE DDT PRESENT
	SETZM SYMPRS		;INDICATE SYMBOLS PRESENT
	OKINT
	RET

MKPGSA:	CALL MAKPGA		; CALL ROUTINE IN PAGEM
	RET

MKPGSU:	PUSH P,1		;SAVE ARGS
	PUSH P,2
	CALL MAKPGU		; ROUTINE IN PAGEM
	 JRST MKPSU1
	SUB P,BHC+2		;ADJUST STACK
	RET

MKPSU1:	HRRZ 2,1		;NUMBER OF PAGES LOCKED
	HLRZS 1			;LOCKED PAGE
	PUSH P,1		;STACK THE LOCKED PAGE
	MOVEI 1,101		;TTY OUTPUT
	MOVEI 3,12		;DECIMAL			*** SRI-AIC ***
	NOUT			;NUMBER OF LOCKED PAGES

	  JFCL
	HRROI 1,MKPSU2		;MESSAGE
	PSOUT
	POP P,2			;GET BACK LOCKED PAGE NUMBER
	MOVEI 1,101
	NOUT
	  JFCL
	HRROI 1,[ASCIZ /
/]
	PSOUT
	HRLZ 1,2		;SET UP DISMISS TILL PAGE UNLOCKED
	HRRI 1,PLCKT		; ..
	JSYS EDISMS		;WAIT
	POP P,2			;GET BACK ARGS
	POP P,1			; ..
	JRST MKPGSU		;TRY AGAIN
MKPSU2:	ASCIZ / PAGES LOCKED. WAITING FOR PAGE /

RUNDD:	MOVSI 1,777
	ANDCAM 1,CAPENB		;FLUSH ANY SUPERIOR FORK CAPS
	SKIPN 1,CRSTAD		;DO WE HAVE A SAVED TIME FROM CRASH?
	JRST RUNDD3		;NO
	STAD			;YES, SET IT
	JFCL
RUNDD3:	MOVEI 1,101
	DOBE
	SETO 1,
	HRROI	2,RSTMSG		;SAY WE ARE COMING UP   *** SRI-AIC ***
	TTMSG
	SKIPG DISKP
	JRST RUNDD2		;SKIP DISK STUFF IF NO DISK
	MOVEI 1,RUNDD1		;BREAK TO RUNDD1 IF ANYTHING GOES WRONG
	HRRM 1,MONBK
	CALL CHKBT		;CHECK CONSISTENCY OF DISK BIT TABLE
	MOVE 2,DBUGSW
	CAIN 2,2		;IF REAL DEBUGGING,
	JRST RUNDD2		;SKIP DISK CHECKING
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>CHECKDISK.SAV/]
	GTJFN
	JRST RUNDD1
	PUSH P,1
	MOVSI 1,(1B1)		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR CHECKDSK
	BUG(HLT,<JOB 0 CFORK FAILED>)
	EXCH 1,0(P)
	HRL 1,0(P)
	GET
	MOVE 1,[CHKDSR]		;SAY CHECK DSK RUNNING
	IORM 1,FACTSW
	POP P,1
	SETZ 2,
	SFRKV			;START AT MAIN ENTRY
	WFORK
	KFORK
	MOVE 1,[CHKDSR]		;SAY CHKDSK COMPLETED
	ANDCAM 1,FACTSW
	JRST RUNDD2

RUNDD1:	HRROI 1,[ASCIZ / NO CHECKDSK
/]
	PSOUT

RUNDD2:	MOVEI 1,RUNDD6		;BREAK TO RUNDD6 IF ANY SCREWUP
	HRRM 1,MONBK
	MOVEI 1,101
	DOBE			;WAIT FOR ANY JOB0 OUTPUT
	MOVE 1,[CHKDSE]		;DISK OK?
	TDNE 1,FACTSW
	JRST 	[HRROI 2,TNAMS1
		SETO 1,
		TTMSG
		JRST .+1]
	MOVE 1,JB0TT		;JOB 0 TTY
	CAIE 1,377777		;REAL TTY?
	JRST RUNDD4		;YES
	MOVSI 1,(1B0+1B17)	;NONE, SO OPEN FILE FOR MESSAGES
	HRROI 2,[ASCIZ /<SYSTEM>ERROR.REPORT/]
	GTJFN
	BUG(CHK,<CAN'T GTJFN ERROR REPORT FILE>)
	MOVE 2,[44B5+1B20]
	OPENF
	BUG(CHK,<CAN'T OPENF ERROR REPORT FILE>)
RUNDD4:	HRRM 1,PRIMRY		;USE IT FOR OUTPUT 
	MOVE 1,FORKX
	MOVEM 1,DDMPFK		; RECORD FORKX OF DDMP FORK
	MOVEI 1,[SIXBIT '$RUNNING DDMP$$/']
	TMSG			;ON TTY 0
	MOVSI 1,(740B8)
	MOVEM 1,LOGBUF
	HRROI 1,LOGBUF
	EFACT			;RESTART ENTRY IN FACT FILE
	 JSP 2,XEFACT		;CHECK EFACT FAILURE (ALWAYS SKIPS)
	  SETOM ACCIFG		; IF SUCCESS, ASSUME ACCOUNTING GOOD
	AOS SYSIFG		;MAKE SYSTEM AVAILABLE
	CALL DONSJ		;START NEXT SPECIAL JOB
	MOVSI 1,(1B1)		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR SYSJOB
	BUG(HLT,<JOB 0 CFORK FAILED>)
	PUSH P,1
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>SYSJOB.SAV/]
	GTJFN
	JRST [	POP P,1
		KFORK
		MOVEI 1,[SIXBIT '$NO SYSJOB$/']
		TMSG
		JRST RUNDD5]
	HRL 1,0(P)
	GET
	POP P,1
	SETZ 2,
	SFRKV			;START AT MAIN ENTRY, LET RUN FOREVER

RUNDD5:
RUNDD6:	MOVEI 2,CTYLIN
	CALL SPCSTJ		; START UP FIRST AUTO JOB
	CALL	FIFBEG		;START PDP15-ASYNC FORK   *** SRI-AIC ***
	IFDEF IMPCHN,<CALL IMPBEG> ;START IMP ASYNCH FORK
	MOVEI 1,103
	MOVEM 1,JOBBIT		;SET PRIORITY FOR CHKR
	MOVEI 1,CHKRI
	HRRM 1,MONBK		;SET DISPATCH FOR INTERRUPTS
	MOVE 1,FORKX		;SAVE FORK INDEX FOR DEBUGGING
	MOVEM 1,CHKFRK		; ..
	JRST CHKR		;GO DO BACKGROUND

LS CHKFRK,1			;FORKX OF THE DDMP FORK

;MAP DDT FROM IMAGE FILE

GETDDT:	SKIPE GOTDDT		;GOT DDT NOW?
	RET			;YES
	MOVSI 1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>MDDT2.SAV/]
	GTJFN
	JRST NODDT
	MOVE 2,[44B5+1B19]	;36-BIT READ
	OPENF
	JRST NODDT
	BIN			;FIRST WORD IS XWD -LENGTH,LOC
	HLRE 3,2		;GET LENGTH
	CAMGE 3,[-LMDDT]	;OUR SPACE BIG ENOUGH?
	JRST [	CLOSF		;NO
		JFCL
		MOVEI 1,[SIXBIT '$MDDT TOO BIG$/']
		JRST NODD2]
	HLLZ 7,2		;SETUP OUR AOBJN PTR
	MOVEI 2,0(2)		;SEE IF LOC IS CORRECT
	CAIE 2,MDDT
	JRST [	CLOSF		;WRONG-MUST BE REASSEMBLED
		JFCL
		MOVEI 1,[SIXBIT '$MDDT AT WRONG LOCATION$/']
		JRST NODD2]
	BIN
	MOVEM 2,MDDT(7)		;STORE MDDT CODE IN PRIVATE PAGE, BUT
	AOBJN 7,.-2		;CODE WILL BE USED BY ALL PROCESSES
	CLOSF
	JFCL
	NOINT
	MOVE 1,[XWD -LMDDT,MDDT]
	ASH 1,-^D9
	MOVSI 2,WRITEB
	ANDCAM 2,MMAP(1)	;WRITE-PROTECT ALL MDDT PAGES
	AOBJN 1,.-1
	AOS GOTDDT
	OKINT
	RET

NODDT:	MOVEI 1,[SIXBIT '$NO MDDT FILE$/']
NODD2:	TMSG
	JRST NODD1

LS SWPSTP,1			;POINTER TO SWAPPABLE SYMTAB
LS GOTDDT,1			;REMEMBERS IF WE HAVE MAPPED DDT

;READ IN MONITOR SYMBOL TABLE FROM FILE

GETMST:	MOVE 1,SVNUM		; SYSTEM VERSION NUMBER
	HRLI 1,(1B2+1B17)	; OLD FILE & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \<SYSTEM>MONSYMS.>,<\>)]
	GTJFN
	JRST NOSYMS		;NO FILE
	MOVE 2,[44B5+1B19]	;36 BIT READ
	OPENF
	JRST [	RLJFN
		JFCL
		JRST NOSYMS]
	NOINT
	BIN			;GET XWD -LENGTH,ADDRESS
	HLRE 3,2
	MOVM 3,3		;POSITIVE OF LENGTH
	CAILE 3,SSTSIZ		;TOO BIG?
	HRLI 2,-SSTSIZ		;YES, READ ONLY TO MAX
	HRRI 2,SWPST		;ADDRESS WHERE TABLE TO BE PUT
	MOVEM 2,SWPSTP
	MOVE 7,2
	BIN
	MOVEM 2,0(7)
	AOBJN 7,.-2
	OKINT
	CLOSF
	JFCL
NOSYMS:	RET

EWMST:	MOVEI 1,[SIXBIT 'RITE MON SYM TAB/']
	TMSG
	CALL OKGO
	SKIPE 1,@DDTSYM		;DDT HAS CURRENT POINTER?
	MOVEM 1,SWPSTP		;YES, UPDATE IT
	JSP 4,WMST		;WRITE TABLE ONTO FILE
	JRST EXCRR

;WRITE MONITOR SYMBOL TABLE ONTO FILE
;CALLED WITH JSP 4,WMST

WMST:	HRROI 1,[ASCIZ /
SYMBOL TABLE LARGER THAN SWAPPABLE STORAGE ALLOCATED FOR IT.
/]
	HLRE 2,SWPSTP
	MOVM 2,2
	CAILE 2,SSTSIZ		;TOO LARGE?
	PSOUT			;YES, PRINT MESSAGE
	HRROI 1,[ASCIZ /
SYMBOL TABLE WRITTEN ON FILE /]
	PSOUT
	MOVE 1,SVNUM		; VERSION NUMBER OF THIS SYSTEM
	HRLI 1,(1B0+1B17)	; FOR OUTPUT & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \MONSYMS.>,<\>)]
	GTJFN
	0
	MOVE 2,[44B5+1B20]
	OPENF
	0
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	JFNS			;TYPE THE FILE NAME
	MOVE 1,2
	MOVE 2,SWPSTP
	BOUT			;OUTPUT -LENGTH,,ADR
	HLRE 3,2		;SET UP A SOUT COUNT
	HRLI 2,444400		;AND POINTER
	SOUT
	MOVEI 2,0		;APPEND A ZERO AS ENT VECTOR
	BOUT			;FOR IDDT, EXEC MERGE
	CLOSF
	JFCL
	JRST 0(4)

EXEC2:	SKIPGE LGNPAR		;CRJOB FAILED TO GET GOING?
	JRST CRJMEX		;YES. KEEP IT FROM MINIEXEC!
	MOVEI 1,100		;ESTABLISH CORRECT TTY MODES
	MOVE 2,NORMTF
	SFMOD
	MOVE 2,TTICB1
	MOVE 3,TTICB2
	SFCOC
	CALL DTIALL
	MOVE 1,[XWD 20,^D34]
	ATI			;ASSIGN CONTROL-P FOR INTERRUPTS
	MOVE 2,JOBNO
	HRRZ 1,JOBDIR(2)
	SKIPE ACCIFG		;IF NOT REFRESHING,
	JUMPE 1,[SETZM CAPMSK	;AND NOT LOGGED, FLUSH ALL CAPS
		SETZM CAPENB
		MOVE 3,CTRLTT
		CAIE 3,CTYLIN	;ALLOW MINI-EXEC ONLY ON CTY
		JRST .+1
		HRLOI 3,777000	;GIVE ALL CAPS
		MOVEM 3,CAPMSK
		MOVEM 3,CAPENB
		MOVE 3,BHC+1	;FAKE LOGIN AS SYSTEM
		MOVEM 3,JOBDIR(2)
		JRST .+1]
	MOVE 1,CAPMSK		;LOOK AT CAPS, ALLOW MINI-EXEC
	TRNN 1,WHEEL+OPER	;ONLY IF WHEEL OR OPER
	JRST [	SKIPE FORKN	;OTHERWISE,
		HALTF		;HALTF IF BELOW EXEC
		JRST LOGO]	;LOGOUT IF TOP FORK
	MOVEI 1,"."
	PBOUT
EXECT1:	PBIN			;AWAIT USER INPUT
	CAIL 1,"A"+40
	CAILE A,"Z"+40
	SKIPA
	SUBI A,40
	CAIN 1,"E"
	JRST GEX
	CAIN 1,"B"
	JRST EBLT		;BLT SWP MON TO USER SPACE
	CAIN 1,"M"
	JRST EMNT		;MOUNT DTA-
	CAIN 1,"R"
	JRST EREST		;RESET USER MAP AND FILES
	CAIN 1,"G"		;G - GET FILE
	JRST EGET
	CAIN 1,"S"		;S - START
	JRST EST
	CAIN 1,"D"		;D - DUMP ON FILE
	JRST EDMP
	CAIN 1,"I"
	JRST EINI
	CAIN 1,"H"
	JRST EHLT		;HALT T.S.
	CAIN 1,"W"
	JRST EWMST
	CAIN 1,"^"
	JRST MRETN
	CAIN 1,"/"
	JRST TODDT
	JRST EXERR		;NOTA

CRJMEX:	MOVEI 1,CRJBX2##	;FAILURE CODE
	MOVEM 1,CRJANS##	; ..
	JRST LOGO		;AND KILL NEW JOB

TODDT:	HRROI 1,[ASCIZ /
/]
	PSOUT
	CALL GETDDT		;GET PROTOTYPE DDT
	SKIPN SWPSTP		;NON RES SYMTAB HERE?
	CALL GETMST		;NO, TRY TO GET IT
	SKIPN 1,SWPSTP		;USE NON-RES SYMTAB IF PRESENT
	MOVE 1,36		;MOVE MONITOR SYMBOL POINTER
	SKIPN @DDTSYM		;HAVE SYMTAB PTR ALREADY?
	MOVEM 1,@DDTSYM		;NO, SET ONE UP
	JRST MDDT		;GO TO DDT

;BLT SWAPPABLE CODE TO USER SPACE.  SHOULD DO RESET FIRST,
;THEN DUMP ON DTA--

EBLT:	MOVEI 1,[SIXBIT 'LT SWP MON/']
	TMSG
	CALL OKGO
	SKIPLE DISKP		;IF DISK,
	CALL WRSWM		;WRITE IT ON DISK
	MOVE 2,SWCEND		;LST PAGE
	LSH 2,^D9
	MOVEI 1,SWPMP0		;FIRST PAGE
	LSH 1,^D9
	HRLI 1,0(1)
	XCTMU [BLT 1,777(2)]
	JRST EXCRR

EREST:	MOVEI 1,[SIXBIT 'ESET/']
	TMSG
	CALL OKGO
	MOVEI 1,-4
	KFORK			;KILL ALL FORKS
	MOVSI 7,-1000
	MOVNI 1,1
	MOVSI 2,400000
	SETZ 3,
ERES1:	HRRI 2,0(7)
	SKIPE UPTA(7)		;DON'T WASTE TIME IF ALREADY EMPTY
	PMAP
	AOBJN 7,ERES1
	MOVNI 1,1		;CLOSE ALL FILES
	CLOSF
	JFCL
	JRST EXCRR

OKGO:	PBIN
	CAIN 1,"."
	RET			;PERIOD MEANS GO
NODD1:	POP P,1			;ANYTHING ELSE MEANS ABORT
	JRST EXERR

GEX:	MOVEI 1,[SIXBIT 'XEC$/']
	TMSG
STEX:	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>EXEC.SAV/]
	GTJFN
	JRST [	HRROI 1,[ASCIZ /NO EXEC/]
		PSOUT
		JRST EXCRR]
	HRLI 1,400000
	GET
	JRST GEX1

;HERE AT STARTUP OF JOB BY CRJOB JSYS

STCRJB:	MOVE 7,JOBNO		;CARRY AROUND MY JOB NUMBER
	HRLM 7,CRJONJ		;RETURN THE ANSWER
	MOVE 10,CRJAC1		;GET THE FLAGS IN CREATOR'S AC1
	MOVE A,CRJONJ		;GET CREATOR'S JOB NUMBER
	TLNN 10,(1B6)		;IF NOT DISOWNED,
	MOVEM A,JOBONT(7)	;STORE BACK-LINK TO OWNER
	JUMPL 10,STCJB1		;JUMP IF WANT TO DO LOGIN
	HLLZ A,JOBDIR(A)	;NO LOGIN. CONNECT TO CREATOR'S CONN DIR
	HLLZM A,JOBDIR(7)	;I AM CONNECTED THERE, NOT LOGGED IN.
	MOVE 6,FORKX
	HLLZM A,FKDIR(6)
	SETZM FKGRPS##(6)		;I HAVE NO GROUP CAPABILITIES
	SETZM CAPENB		;MAKE SURE I'M NOT PRIVILEGED
	HLLZS CAPMSK		; ..
	JRST STCJ1A		;DONE WITH LOGIN STUFF

STCJB1:	MOVE A,CRJUSR		;WANT TO LOG IN. SEE IF NAME GIVEN
	TLNN A,-1		;TEXT OR NUMBER?
	JRST STCJ1B		;NUMBER.
	MOVEI A,0		;DO NOT RECOGNIZE
	HRROI B,CRJUSR		;NAME TO LOG IN AS
	STDIR			;GET DIRECTORY NUMBER
	  JFCL
	  JRST SCJXX1		;NO GOOD NAME.
	TLNE 1,(1B0)		;NOT FILES-ONLY, I HOPE
	JRST SCJXX1		;YES. YOU CAN'T DO THAT
	HRRZM 1,CRJUSR		;STORE THE NUMBER
STCJ1B:	HRRZ 1,CRJUSR		;THE DIRECTORY NUMBER
	HRROI 2,CRJPSW		;PASSWORD
	HRROI 3,CRJACT		;STRING ACCOUNT
	SKIPN CRJACT		;OR IS IT NUMERIC?
	MOVE 3,CRJACT+1		;NUMERIC.
IFN PIESLC,<
	MOVE 4,CRJPIE>		;TEMP. PIE GROUP
	LOGIN
	  JRST SCJXXX		;LOGIN FAILED.
STCJ1A:	SETZM LGNPAR		;NOW LOGIN IS DONE IF WANTED.
	TLNE 10,(1B3)		;WANT TO RUN A FILE?
	JRST STCJB2		;YES.
	SETOM CRJANS		;NO. LET'S ASSUME GETTING AN EXEC WINS
	JRST STEX		;SET -1 TO ANSWER AND DO EXEC STARTUP
STCJB2:	TLNE 10,(1B4)		;FILE WANTED. EXEC TOO?
	JRST STCJB3		;YES.
	MOVSI A,(1B2+1B17)	;NO, JUST THE FILE.
	HRROI B,CRJFIL		;THIS FILE NAME
	GTJFN
	  JRST SCJXXX		;CAN'T GET IT.
	HRLI A,400000		;INTO THIS FORK
	GET
	MOVSI A,CRJFAC		;ACS FROM STORAGE TO USER 0
	TLNE 10,(1B5)		;IF WANTED
	XCTMU [BLT A,17]	;STORE THEM
	MOVEI A,400000		;GET THE ENTRY VECTOR
	TLNN B,777000		;DEC STYLE ENTRY?
	JRST STCJ2A		;NO.
	HRRZ C,CRJEVO		;GET ENTRY VECTOR OFFSET
	CAILE C,1		;GOOD FOR DEC STYLE?
	JRST SCJXX3		;NO
	UMOVE B,120		;JOBSA
	TRNE C,-1		;IF ZERO OFFSET
	UMOVE B,124		;ELSE JOBREN
	SKIPA
STCJ2A:	ADD B,CRJEVO		;ADD OFFSET TO VECTOR
	HRRM B,0(P)		;STORE FOR RETURN
	SETOM CRJANS		;SAY CRJOB HAS SUCCEEDED
	JRST MRETN		;AND GO DO IT

STCJB3:	MOVSI A,(1B2+1B17)	;HERE IF WANT FILE AND EXEC BOTH
	HRROI B,CRJFIL		;GET A JFN FOR THE DESIRED FILE
	GTJFN
	  JRST SCJXXX		;RETURN GTJFN ERROR
	PUSH P,A
	DVCHR			;SEE IF IT'S THE DISK
	TLNE B,777		; ..
	JRST STCJ3A		;NO. JUST PASS JFN TO GET JSYS
	MOVE A,0(P)		;RESTORE JFN
	MOVE B,[44B5+5B21+1B25]	;OPEN RD, EX, THAWED, 36BIT
	OPENF			; ..
	  JRST SCJXX2		;OPENF FAILED. RETURN THE ERROR CODE.
STCJ3A:	MOVEI A,0		;SIMPLE INFERIOR FORK
	TLNE 10,(1B5)		;UNLESS LOAD AC'S
	TLO A,(1B3)		;THEN LOAD AC'S
	MOVEI B,CRJFAC		;FROM HERE
	CFORK
	  JRST SCJXX2		;CAN'T GET A FORK
	EXCH A,0(P)
	HRL A,0(P)		;FORK,,FILE
	GET
	POP P,A			;FORK
	HRRZ B,CRJEVO		;ENTRY VECTOR OFFSET
	SFRKV			;START IT UP
	SETOM CRJANS		;ALL HAS GONE WELL, ANSWER GOOD,
	JRST STEX		;AND GO START AN EXEC IN TOP FORK.

SCJXX3:	MOVEI A,SFRVX1##
	JRST SCJXXX
SCJXX2:	POP P,(P)		;CLEAR STACK
	JRST SCJXXX		;AND GIVE CFORK'S ERROR RETURN
SCJXX1:	MOVEI A,CRJBX5##	;BAD DIRECTORY NUMBER, UNKNOWN NAME
SCJXXX:	MOVEM A,CRJANS		;STORE ERROR CODE
	JRST LOGO		;AND KILL OFF THE ATTEMPTED JOB

;INIT DISK BIT TABLE, BAD SPOTS, ETC

EINI:	MOVEI 1,[SIXBIT 'NIT BIT TABLE/']
	TMSG
	CALL OKGO
	CALL DSKRBS		;READ BAD SPOTS
	JRST EXCRR

;HALT TENEX

EHLT:	MOVEI 1,[SIXBIT 'ALT TENEX/']
	TMSG
	MOVSI 4,(1B0)	;HALT SCHED						***SRI-AIC***
	PBIN		;SEE IF HE WANTS TO RELOAD				***SRI-AIC***
	CAIN 1,"."	;. IF NOT						***SRI-AIC***
	JRST EHLT1	;NO							***SRI-AIC***
	CAIE 1,","	;MAYBE						***SRI-AIC***
	JRST EXERR	;NO, SOME KIND OF TYPO				***SRI-AIC***
	MOVEI 1,[SIXBIT ' AND RELOAD/']						;***SRI-AIC***
	TMSG		;TYPE OUT REST OF MESSAGE				***SRI-AIC***
	CALL OKGO
	MOVSI	4,(1B3)		;RELOAD FROM DISK	*** SI-AIC ***
EHLT1:	SETZM NXTDMP		;REQUEST DDMP ACTION	*** SRI-AIC ***
	SETZM DDTIME		;FORCE DDMP RUN
	AOS JB0FLG		;REQUEST JOB 0
	MOVEI 1,^D1000
	DISMS			;WAIT A SECOND
	SKIPN CGFLG		;SWAPPING AND
	SKIPL NXTDMP		;DDMP FINISHED?
	JRST .-4		;NO
;	MOVSI 1,400000
	MOVEM 4,20		;HALT SCHED
	JRST EXCRR

;MOUNT DECTAPE

EMNT:	MOVEI 1,[SIXBIT 'OUNT DTA/']
	TMSG
	PBIN
	CAIL 1,"0"		;USER TYPES DIGIT
	CAILE 1,"7"		;FROM 0 TO 7
	JRST EXERR		;BAD CHAR
	MOVE 10,[ASCIZ /DTA0/]
	DPB 1,[POINT 7,10,27]	;CONSTRUCT STRING WITH UNIT NUMBER
	HRROI 1,10
	STDEV
	JRST EXERR		;NO SUCH DEVICE
	MOVE 1,2
	MOUNT
	JRST EXERR
	JRST EXCRR

EGET:	MOVEI 1,[SIXBIT 'ET FILE /']
	TMSG
	MOVSI 1,(1B2+1B4+1B16+1B17)	;OLD FILE,TERMINATION,IFOF,SHORT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	GET
	JRST EXCRR

EST:	MOVEI 1,[SIXBIT 'TART/']
	TMSG
	CALL OKGO
	HRROI 1,[ASCIZ /
/]
	PSOUT
GEX1:	HRRZ 1,ENTVEC
	JUMPN 1,.+2
	UMOVE 1,120		;USE JOBSA
	HRRM 1,0(P)
	JRST MRETN

EDMP:	MOVEI 1,[SIXBIT 'UMP ON FILE /']
	TMSG
	MOVSI 1,(1B0+1B3+1B4+3B17)	;NEW V,PNT O/N,TERM,IFOF,SHRT
	MOVE 2,[XWD 100,101]
	GTJFN
	JRST EXERR
	HRLI 1,400000		;THIS FORK
	MOVE 2,[XWD 777760,20]	;ALL EXCEPT AC'S
	SAVE
	JRST EXCRR

EXERR:	HRROI A,[ASCIZ //]
	ESOUT
EXCRR:	HRROI 1,[ASCIZ /
/]
	PSOUT
	JRST EXEC2

;PSI TRAPPED TO HERE

EXECI:	XCT MONINT		;FOR DDT BREAKPOINT
	EXCH 1,ITFPC		;SAVE 1, GET TRAP PC
	TLNN 1,UMODF		;USER?
	JRST EXECI1		;NO
	MOVEM 1,FPC		;YES, ENTER MONITOR AT THAT LOC
	MOVE 1,ITFPC		;RESTORE AC1
EXECI2:	JSYS MENTR
	SETOM PRIMRY
	SKIPGE LGNPAR		;FAILURE IN START OF CREATED JOB?
	JRST CRJMEX		;YES. KEEP OUT OF MINIEXEC
	MOVEI 1,-4
	FFORK			;FREEZE FORKS
	MOVEI 1,100
	CFIBF			;CLEAR INPUT BUFFER
	MOVEI 1,400000
	SETO 2,
	DIC
	CALL DTIALL		;IN CASE PROGRAM TURNED ANY ON
	MOVE 2,PSIBW
	CIS
	TRNN 2,2		;CHANNEL 34?
	JRST EXECI3
	MOVEI 1,101
	CFOBF			;CLEAR OUTPUT BUFFER
	MOVEI 1,EM2
	TMSG
	JRST EXEC2

EXECI1:	MOVE P,UPP		;RESTORE TOP OF PDL
	MOVE 1,1(P)		;GET USER PC
	HRLI 1,UMODF
	MOVEM 1,FPC
	HRLZ P,ACBAS1		;RECOVER USER AC'S
	LSH P,4
	BLT P,17
	JRST EXECI2

EXECI3:	MOVEI 1,EM3
	TMSG
	MOVEI 1,101
	HRRZ 2,UPP
	HRRZ 2,1(2)		;GET TOP PC
	MOVEI 3,10		;RADIX
	NOUT			;PRINT ADDRESS
	JFCL
	JRST EXCRR		;TO MINI-EXEC IF WHEEL OR OPERATOR

EM2:	SIXBIT '$ABORT$/'
EM3:	SIXBIT '$INTERRUPT AT /'

;JSYS TO ENTER MINI-EXEC

.EXEC:	JSYS MENTR
	MOVEI 1,WHEEL+OPER
	TDNN 1,CAPENB
	JRST WHEELX		;ITRAP WITH WHEEL ERROR
	JRST EXEC2

EXBUGH:	MOVE 1,UPDL		;RESET STACK, ETC.
	HRLI 1,UMODF
	MOVEM 1,FPC
	JSYS MENTR
	SETOM TRAPC
	SETZM NSKED
	SETZM INTDF
	MOVE 1,FORKX
	CAMN 1,DDMPFK		; DDMP FORK?
	JRST CHKRI		;YES, INTERRUPT
	HRRZ 1,PRIMRY
	HRROI 2,[ASCIZ /
BUGHLT AT /]
	SETZ 3,
	SOUT
	HRRZ 2,BUGHLT
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2,15
	BOUT
	MOVEI 2,12
	BOUT
	JRST ITRAP

;EXEC UTILITY ROUTINES

;MESSAGE TYPER - ADR OF SIXBIT TEXT IN 1

TMSGQ:	HRLI 1,440600		;CONSTRUCT BYTE POINTER
	PUSH P,1
TMSG1:	ILDB 1,0(P)
	ADDI 1,40		;CONVERT TO ASCII
	CAIN 1,"/"		;SLASH IS TERMINATOR
	JRST TMSG2
	CAIN 1,"$"		;DOLLARS MEANS EOL
	JRST [HRROI 1,[ASCIZ /
/]
		PSOUT
		JRST TMSG1]
	PBOUT
	JRST TMSG1

TMSG2:	POP P,1			;FLUSH TEMP
	RET

;HALT SYSTEM - REQUIRES MAINT (OR WHEEL ETC.) CAPABILITY
; ACCEPTS A GTAD-STYLE DATE AND TIME IN 1, AT WHICH TIME TENEX
;WILL BE SHUT DOWN. JOB 0 NOTIFIES USERS AND DOES THE SHUTDOWN.
; AND ACCEPTS A GTAD TIME IN 2 WHEN SYSTEM IS EXPECTED UP AGAIN
; ACCEPTS 4-BIT CODE FOR REASON FOR DOWNAGE IN 3.
; REQUIRES WHEEL, MAINT, OR OPER CAPABILITY.

.HSYS:	JSYS MENTR		;SET UP AC BLOCK
	MOVE 2,CAPENB		;SEE IF USER ALLOWED TO HALT TENEX.
	TRNN 2,WHEEL+OPER+MAINT	; ..
	JRST CAPXR		;NO. RETURN CAPX ERROR
	JUMPG 1,HSYS1		;JUMP UNLESS ABORTING THE SHUTDOWN
	SETZM HSYST1		;ABORTING. KILL FLAGS.
	SETZM HSYST2		; ..
	SETZM HSYST3		; ..
	JRST SKMRTN		;SKIP RETURN TO USER

HSYS1:	PUSH P,1		;HOLD THE DESIRED SHUTDOWN.
	CALL CVTAD		; LINEARIZE
	PUSH P,1
	GTAD			;GET CURRENT TIME AND DATE
	CALL CVTAD		; LINEARIZE
	SUB 1,0(P)		;DIFFERENCE IN TIMES
	SKIPGE 1		; NOW MUST BE BEFORE SHUTDOWN
	SKIPGE 1,[^D<7*24*60*60>]
	RETERR TIMEX1		;YES. GIVE BAD TIME FAILURE
	POP P,HSYST2		; LINEAR TAD OF SHUTDOWN
	POP P,HSYST1		; GTAD OF SHUTDOWN
	UMOVE 1,2		; TIME BACK UP, GTAD FORMAT
	CAMG 1,HSYST1		; LATER THAN SHUTDOWN? (IGNORING SIGN)
	MOVEI 1,0		; NO. ASSUME JUNK - UNKNOWN RETURN
	MOVEM 1,HSYST4		; STORE FOR GETAB, IMPHLT.
	SETZM HSYST3		; NO MSG TYPED YET
	UMOVE 2,3		; GET REASON FOR DOWN TIME
	ANDI 2,17		; RESTRICT TO 4 BITS
	MOVEM 2,HSYST5
	AOS JB0FLG		;WAKE JOB 0 TO SEE THIS
	JRST SKMRTN		;AND GIVE SUCCESS RETURN TO USER.

EXTERN HSYST1,HSYST4		;GTAD FORMAT, IN SYSTAT GETAB TABLE
LS HSYST2,1			; LINEAR TAD OF SHUTDOWN
LS HSYST3,1			; LINEARTAD FOR NEXT MSG TYPEOUT
LS HSYST5,1			; REASON CODE FOR SHUTDOWN (A LA 1822)

;POINTS (IN MINUTES BEFORE SHUTDOWN) AT WHICH TO DO NOTIFICATION

CTIMS:	^D<BYTE (9) 60,30,15,10>
	^D<BYTE (9) 5,1,0>

;FORK STARTED BY CHKR AT ARMAGEDDON TIME.
;COMMENCE SHUTDOWN. PREVENT NEW JOBS, LOGOUT EXISTING JOBS, HALT.

HSYS4:	MOVSI 1,UMODF		;FAKE UP SLOW JSYS ENTRY
	MOVEM 1,FPC		; ..
	JSYS MENTR		; ..
	IFDEF IMPCHN,<
	MOVE 2,HSYST4
	MOVE 1,HSYST5
	CALL IMPHLT##>
	MOVEI 6,377777
	MOVEM 6,LOGDES	;TURN OFF LOGOUT JOB MESSAGES
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	MOVEI 5,^D60000		; INITIAL TIME-OUT INTERVAL
	SKIPGE JOBRT(6)		;LOOK FOR EXISTING JOB
HSYS41:	AOBJN 6,.-1
	JUMPGE 6,HSYS7		;JUMP IF DONE
	HLRZ 1,JOBPT(6)		;WHAT TTY IS THE JOB ON?
	CAME 1,OTYLIN		;ONE OF THE PRIVILEGED ONES?
	CAIN 1,CTYLIN		; ..
	JRST HSYS41		;YES. LET IT STAY ON
	MOVEI 1,(6)		;NO, LOG OUT THIS JOB NUMBER
	LGOUT			; ..
	  JFCL
	ADDI 5,^D10000		; AUGMENT TIME-OUT BY 10 SEC PER JOB
	JRST HSYS41

HSYS7:	ADD 5,TODCLK		; TIME TO STOP WAITING FOR LOGOUTS
HSYS8:	CAMG 5,TODCLK		;WAITED MAX TIME?
	JRST HSYS9		;YES, PROCEED WITH SHUTDOWN
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;SEE IF ANY JOBS STILL EXIST
HSYS81:	AOBJN 6,.-1
	JUMPGE 6,HSYS9		;NONE FOUND, PROCEED
	HLRZ 1,JOBPT(6)		;TTY NUMBER OF THIS JOB
	CAME 1,OTYLIN		;PRIVILEGED?
	CAIN 1,CTYLIN		; ..
	JRST HSYS81		;YES, IGNORE
	MOVEI 1,^D1000		;NO, WAIT 1 SEC., THEN CHECK AGAIN
	DISMS
	JRST HSYS8

HSYS9:	SETZM NXTDMP		;INITIATE DDMP
	SETZM DDTIME
	AOS JB0FLG
	MOVEI 5,^D30		;MAX TIME FOR JOB 0
HSYS91:	MOVEI 1,^D1000		;WAIT 1 SEC
	DISMS
	SKIPN CGFLG		;EVERYTHING FINISHED?
	SKIPL NXTDMP
	SOJG 5,HSYS91		;NO, WAIT MORE
	JUMPLE 5,HSYS9		;IF TIMED OUT, TRY AGAIN
	SKIPE IOIP		;WRITES IN PROGRESS?
	JRST .-1		;YES, WAIT FOR COMPLETION
	MOVEI 1,CTYLIN		;ANNOUNCE SHUTDOWN.
	HRROI 2,[ASCIZ /SHUTDOWN COMPLETE.
/]
	TTMSG
	MOVEI 1,^D15000		;FINALLY FOR TTY OUTPUT TO QUIT,
	DISMS			; WAIT JUST A BIT MORE
	MOVE 1,OTYLIN		;NOW HALT OR HALTF DEPENDING ON
	MOVEI 2,CTYLIN
	SKIPGE TTFORK(1)	;WHETHER A JOB IS STILL ON CTY/OTY
	SKIPL TTFORK(2)		; ..
	HALTF			;SOMEONE STILL ON. KEEP RUNNING.
	JRST [	PIOFF 610000	;CLEAR EVERYTHING
		CONO APR,200000	;IOB RESET
		SETOM ENTFLG	; IN CASE CONTINUED
		JRST 4,SYSRST]

;ROUTINE TOSEND GOING DOWN MESSAGE TO ALL LINES

THSYS:	PUSH P,1		;1 CONTAINS NUMBER OF MINUTES
	SETO 1,
	HRROI 2,[SYSNAM(<ASCIZ /
*** >,< GOING DOWN IN />)]
	TTMSG
	MOVE 2,0(P)		;GET NUMBER OF MINUTES AGAIN
	CAIN 2,1		;THE 'ONE' CASE?
	JRST [	HRROI 2,[ASCIZ /ONE MINUTE!! ***
/]
		JRST HSYS51]	;YES, SPECIAL MESSAGE
	MOVEI 1,1(P)		;USE STACK TO HOLD STRING
	ADD P,BHC+2
	HRLI 1,440700
	PUSH P,1
	MOVEI 3,^D10
	NOUT
	JFCL
	POP P,2			;POINTER TO STRING
	SETO 1,
	TTMSG			;PRINT NUMBER
	SUB P,BHC+2		;FLUSH TEMPS FROM STACK
	HRROI 2,[ASCIZ / MINUTES. ***
/]
HSYS51:	SETO 1,
	TTMSG
	POP P,1			;RETURN NUMBER OF MINUTES
	RET

;PERIODIC (10 SEC) CHECK OF THINGS

CHKR:	SETZM JB0FLG		;CLEAR REQUEST FLAG
	MOVE 1,TODCLK
	ADDI 1,^D120000		; IN 2 MINUTES GET HI-Q
	MOVEM 1,CHKTM1
	ADDI 1,^D120000		; 2 AFTER THAT CALL US HUNG
	MOVEM 1,CHKTIM		;LEAVE FOR SCHED TO CHECK
	SKIPE BUGHLT		;BUGHLTS LATELY?
	CALL CHKHLT		;REPORT
	SKIPE BUGCHK		;BUGCHK?
	CALL CHKBUG		;YES
	SKIPE BUGNTE		;ANY BUGNTES?
	CALL CHKNTE		;YES
	CALL CHKDMS		;CHECK DRUM SPACE
	CALL CHKSPT		;CHECK SPT SPACE
	MOVE 1,DRMCFE		;DRUM ERROR COUNT
	CAME 1,CHKDMC		;DIFFERENT FROM LAST TIME?
	CALL CHKDRM		;YES
	MOVE 1,DSKRCE		;DISK RECOVERABLE ERRORS
	CAME 1,CHKDRE##		;DIFFERENT FROM LAST CHECK?
	CALL CHKDE1##		;YES, GO PRINT INFO
	MOVE 1,DSKNRE		;DISK NON-REC ERRORS
	CAME 1,CHKDNE##		;DIFFERENT?
	CALL CHKDSK##		;PRINT INFO
IFDEF IMPCHN,<
	CALL CHKNET		;YES, LOG IT
>
	CALL TTHCK##		;SEE IF DATASETS NEED TO BE HUNG UP
	CALL DDMP		;DISK BACKUP
	SKIPE HSYST1		;SYSTEM SHUTTING DOWN?
	CALL CHKHSY		;YES. CHECK HSYS TIMERS.
	MOVE 2,TODCLK		;SETUP DISMISS CONDITION FOR
	ANDI 2,377777		;NOW PLUS 30 SEC
	MOVSI 1,^D30000(2)
	HRRI 1,JB0TST		;OR JB0FLG
	JSYS EDISMS
	JRST CHKR		; BYPASS THE FOLLOWING CODE BUT LEAV IT AROUND FOR CONVENIENCE.
	MOVEI B,60		; END OF REAL LINE SCANNER TODAY
	CALL TTCOBI##		; GO FLUSH BUFFERS WAITING ON THIS GUY
	ADDI B,1
	CAIGE B,100		; END OF LINE SCANNER WHEN WE GET DONE
	JRST .-3
	JRST CHKR

	RESCD

JB0TST:	MOVE 3,4		;SAVE RETURN
	JSP 4,BLOCKW		;TEST CLOCK
	SKIPE JB0FLG		;OR FLAG
	JRST 1(3)		;RUN
	JRST 0(3)

	SWAPCD
CHKFIF:	SKIPN FIFERW	;IS THIS A PDP15 BUGHLT ?			***SRI-AIC***
	JRST CHKF1	;NO, GO SEE IF IT'S A BUG IN FIF CODE	***SRI-AIC***
	HRROI 1,[ASCIZ /
*****PDP15 BUGHLT AT /]							;***SRI-AIC***
	PSOUT									;***SRI-AIC***
	MOVE 2,FIFERW	;REPORT LOCATION					***SRI-AIC***
	SETZM FIFERW	;CLEAR ERROR CONDITION					***SRI-AIC***
	CALL CHKH1	;PRINT LOCATION						***SRI-AIC***
								;BEGIN ***SRI-AIC***

CHKF1:	SKIPN 2,BUGFIF	;FIF BUG ?
	RET		;NO

	HRROI 1,[ASCIZ /
**** FIF BUG AT /]
	PSOUT		;PRINT MESSAGE

	HRRZS 2		;CLEAN						***SRI-AIC***
	SOS 2		;ADJUST PC TO POINT AT JSR
	SETZM BUGFIF	;CLEAR FLAG
	JRST CHKBG1	;PRINT REST OF MESSAGE AND STRING
								;END ***SRI-AIC***

CHKH1:	MOVEI 1,101
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
CHKR1::	GTAD			;CURRENT TIME AND DATE
	JUMPL 1,CHKR2		;IF NOT SET
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	ODTIM			;INCLUDE TAD WITH MESSAGE
CHKR2:	HRROI 1,[ASCIZ /
/]
	PSOUT
	RET

CHKHLT:	HRROI 1,[ASCIZ /
*****BUGHLT AT /]
	PSOUT
	HRRZ 2,BUGHLT
	SETZM BUGHLT
	JRST CHKBG1

CHKNTE:	HRROI 1,[ASCIZ /
***** BUGNOTE AT /]
	PSOUT
	HRRZ 2,BUGNTE
	SETZM BUGNTE
	SOJA 2,CHKBG1

CHKBUG:	HRROI 1,[ASCIZ /
*****BUGCHK AT /]
	PSOUT
	HRRZ 2,BUGCHK
	SUBI 2,1		;TO POINT AT JSR
	SETZM BUGCHK
CHKBG1:	PUSH P,2		;SAVE ADDRESS
	CALL CHKH1		;PRINT IT
	SKIPE NBUGTP		;HAVE BUG TABLE NOW?
	JRST BUGLK5		;YES
	MOVE 1,SVNUM		; VERSION NUMBER OF THIS SYSTEM
	HRLI 1,(1B2+1B17)	; OLD FILE & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \<SYSTEM>BUGTABLE.>,<\>)]
	GTJFN
	JRST BUGLK0
	MOVE 2,[44B5+1B19]
	OPENF
	JRST BUGLK0
	BIN			;FIRST WORD IS (NEG) COUNT OF PTRS
	MOVEM 2,NBUGTP
	MOVE 7,[XWD -SBUGTF,BUGTAB]
BUGLK3:	BIN
	JUMPN 2,BUGLK2
	GTSTS
	TLNE 2,(1B8)		;EOF?
	JRST BUGLK4		;YES
	SETZ 2,
BUGLK2:	MOVEM 2,0(7)
	AOBJN 7,BUGLK3
BUGLK4:	CLOSF
	JFCL
BUGLK5:	POP P,1			;BUG ADDRESS
	HRLZ 7,NBUGTP
BUGLK1:	MOVE 6,BUGTAB(7)
	HLRZ 2,6
	CAME 1,2
	AOBJN 7,BUGLK1
	JUMPGE 7,R		;FAILED TO FIND ADDRESS, PRINT NOTHING
	HRROI 1,[ASCIZ / - /]
	PSOUT
	HRROI 1,BUGTAB(6)	;STRING STORAGE RELATIVE TO START OF TABLE
	PSOUT
	JRST CHKR2		;PRINT EOL AND RETURN

BUGLK0:	HRROI 1,[ASCIZ @ - (FAILED TO GTJFN/OPEN BUGTABLE FILE)
@]
	PSOUT
	POP P,1
	RET

LS NBUGTP,1		;NEG COUNT OF PTRS IN BUGTABLE

;CHECK IF SYSTEM SHUTDOWN MESSAGE NEEDS TO BE TYPED.
;CALLED ONLY FROM JOB 0, CHKR ROUTINE.

CHKHSY:	GTAD			; GET NOW
	CALL CVTAD		; LINEARIZE
	SKIPE HSYST3		; ANY MSGS TYPED YET?
	JRST CHKHS2		;YES.
	MOVE 2,HSYST2		; GET SHUTDOWN TIME
	CAIG 2,^D<2*60*60>(1)	; MORE THAN TWO HOURS AWAY?
	 SKIPA 2,1		; NO, USE NOW
	  SUBI 2,^D<60*60>	; YES, USE 1 HOUR BEFORE
	MOVEM 2,HSYST3		; ELSE USE NOW
CHKHS2:	CAML 1,HSYST2		; SHUT DOWN TIME YET?
	 JRST CHKHS4		; YES, GO DO IT
	CAMGE 1,HSYST3		;UP TO NOTIFICATION TIME?
	JRST CHKHS3		;NO. DO NOTHING.
	SUB 1,HSYST2		;YES. COMPUTE TIME TILL SHUTDOWN.
	MOVNS 1
	ADDI 1,^D30		; ROUND TO NEAREST MINUTE
	IDIVI 1,^D60
	CALL THSYS		;NOT TIME YET. SAY HOW LONG TO ALL TTY'S
	MOVE 3,[POINT 9,CTIMS]	;FIND WHEN NEXT NOTIFY SHOULD BE
	ILDB 2,3		;LOOK THRU LIST OF TIMES
	CAMG 1,2		;SHORTER TIME?
	JUMPG 2,.-2		;NO. LOOK ON. (JUMPG IN CASE IMPOS ERR)
	IMULI 2,^D60		;BACK TO SECONDS
	SUB 2,HSYST2		; ..
	MOVNM 2,HSYST3		;STORE FOR NEXT TYPEOUT TEST
CHKHS3:	RET			;DONE FOR THIS TIME.

CHKHS4:	SETZM ENTFLG		;THE TIME HAS COME. START SHUTDOWN.
	SETZM HSYST1		;CLEAR FLAGS IN CASE RESTARTED,
	SETZM HSYST2		; AND TO PREVENT MULTIPLE HSYS4 FORKS
	SETZM HSYST3		; ..
	MOVSI 1,(1B1)		;CREATE A FORK WITH CAPABILITIES
	CFORK			; ..
	  BUG (HLT,<JOB 0 CFORK FAILED - HSYS>)	;OH WELL, TIME TO QUIT..
	MOVEI 2,HSYS4		;WHERE TO START INFERIOR, EXEC MODE.
	MSFRK			;START IT.
	RET			;AND THATS ALL CHKR DOES ABOUT IT.

; CONVERT GTAD FORMAT TO LINEAR TIME AND DATE

CVTAD:	PUSH P,1
	HRRZS 0(P)
	HLRZS 1
	IMULI 1,^D<60*60*24>
	ADD 1,0(P)
	SUB P,BHC+1
	RET

CHKDRM:	MOVEM 1,CHKDMC		;STORE NEW COUNT
	HRROI 1,[ASCIZ /
*****DRUM ERR: /]
	PSOUT
	MOVE 6,[XWD -4,DRMCFE]	;PRINT BAND, ECT.				***SRI-AIC***
	MOVEI 7,DRMSTH		;GET POINTER TO DRUM HEADINGS			***SRI-AIC***
	JRST CHKD1##		;						***SRI-AIC***

CHKDMS:	MOVE 1,DRMFRE
	CAMLE 1,DRMIN0		;DRUM SPACE LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****DRUM SPACE LOW, /]
	PSOUT
	MOVE 2,DRMFRE
	JRST CHKH1		;PRINT FREE COUNT

CHKSPT:	MOVE 1,SPTC
	CAMGE 1,SPC1		;SPT LOW?
	RET			;NO
	HRROI 1,[ASCIZ /
*****SPT SPACE LOW, /]
	PSOUT
	MOVN 2,[NOFN-SSPT]
	SUB 2,SPTC		;SPACE LEFT
	JRST CHKH1

;ANY INTERRUPT WILL EVENTUALLY TRAP TO HERE

CHKRI:	MOVE P,UPP
	ADD P,BHC+2		;RESET STACK
	SETZM SLOWF
	SETOM INTDF
	SETZM PSIBW
	HRROI 1,[ASCIZ /
*****JOB 0 CRASH, CONTINUING
/]
	PSOUT
	JRST CHKR

LS CHKDMC,1
;HEADINGS FOR DRUM ERRORS						***SRI-AIC***
DRMSTH:	XWD -1,[ASCIZ /ERROR COUNTER      : /]
	XWD -1,[ASCIZ /DRUM ADDRESS WORD  : /]
	XWD -1,[ASCIZ /MEMORY ADDRESS WORD: /]
	XWD -1,[ASCIZ /CONTROLLER BITS    : /]

;GET 10/50 COMPATIBILITY FILE ON FIRST USE OF UUO

GETPAT:	JSYS MENTR		;GETS HERE FROM UUO HANDLER
	PUSH P,ENTVEC		;SAVE CURRENT ENTRY VECTOR
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SUBSYS>PA1050.SAV/]
	GTJFN
	ITERR ILINS3		;NO FILE
	HRLI 1,400000		;LOAD IT INTO THIS FORK
	GET
	MOVE 1,ENTVEC		;COMPATIBILITY ENTRY VECTOR
	MOVEM 1,PATADR		;PUT IT IN RESERVED PLACE
	POP P,ENTVEC		;RESTORE REGULAR VECTOR
	UMOVE 2,3(1)		;VIRTUAL 40 FOR PAT
	HRRM 2,PATU40
	UMOVE 2,4(1)		;PC WORD FOR PAT
	HRRM 2,PATUPC
	AOJ 1,			;INITIAL ENTRY IS 1, REGULAR 0
	HRLI 1,UMODF
	EXCH 1,0(P)		;SET NEW PAC, GET OLD ONE
	XCTUU PATUPC
	MOVE 1,40
	XCTUU PATU40
	JRST MRETN		;GO TO COMPATIBILITY

IFN PIESLC,<
;ROUTINE TO MAP PIE-SLICE GROUP DATA FILE

MAPGRP:	MOVSI 1,(1B2+1B17)	;OLD FILE + SHORT FORM
	HRROI 2,GRPFNM
	GTJFN
	 JRST MAPGR2

	PUSH P,1		;SAVE JFN
	MOVEI 2,1B19+1B20+1B25	;READ, WRITE AND THAWED
	OPENF
	 BUG (HLT,<MAPGRP - FAILED TO OPENF PIE-SLICE-GROUP.DATA>)

	MOVSI 4,-NGRPPG
	MOVEI 5,GRPFIL		;ADDRESS TO START MAPPING FILE

MAPGR1:	HRLZ 1,0(P)		;GET JFN
	HRRI 1,0(4)		;FILE PAGE NUMBER
	CALL JFNOFN		;CONVERT JFN,,PN TO OFN,,PN
	 BUG (HLT,<MAPGRP - JFNOFN FAILED ON PIE-SLICE-GROUP.DATA>)

	MOVEI 2,0(5)
	HRLI 2,READB+WRITEB
	CALL SETMPG		;MAP THE PAGE

	ADDI 5,1000
	AOBJN 4,MAPGR1		;GO BACK AND DO NEXT

	SUB P,BHC+1
	AOS PIEFLG		;INDICATE SUCCESSFUL MAPPING
	RET

MAPGR2:	BUG (CHK,<MAPGRP - FAILED TO GTJFN FOR PIE-SLICE-GROUP.DATA>)
	RET

GRPFNM:	ASCIZ /<SYSTEM>PIE-SLICE-GROUP.DATA/


;ROUTINE TO ASSIGN DSHARE VALUES. WINDFALL GOES TO LEAST COST-EFFECTIVE GROUP
ASGDSH:: ADD P,BHC+12		;MAKE ROOM FOR 0-12 ON STACK
	JUMPGE P,MSTKOV##			;ERROR IF NO ROOM
	MOVEM 12,0(P)			;SAVE LAST AC
	HRRZI 12,-11(P)			;MAKE UP POINTER FOR BLT
	BLT 12,-1(P)

	NOINT
	LOCK GRPLOK

	MOVSI 6,(1.0)			;INITIALIZE 6 TO ACCUMULATE WINDFALL
	SETZ 12,			;12 USED TO MAINTAIN ACTUAL INDEX
					;TO PIE-SLICE-GROUP.DATA ENTRIES

	HRRZI 7,^D<24*60*60>		;NUMBER OF SECONDS IN A DAY

	MOVSI 5,-NGRPS			;LOOP OVER ALL GROUPS
	SETZ 10,		;INITIALIZE COST-EFFECTIVENESS

ASGDS1:	SKIPN NJBGRP(5)			;ANYBODY USING THIS GROUP?
	 JRST ASGDS2			;NO, GO ON TO NEXT ONE

	MOVE 2,SSHARE(12)		;YES, GET NUMBER OF SHARES
	FDVR 2,TOTSHR			;COMPUTE FRACTION
	MOVEM 2,DSHARE(5)		;AND STASH IN DSHARE

	FSBR 6,2			;MAINTAIN WINDFALL

	SKIPN 3,CPUSED(12)		;GET CPU TIME FOR THIS GROUP
	 JRST [HRLOI 10,377777		;FAKE SMALL COST EFFECTIVENESS
		JRST ASGDS4]
	ASH 3,-^D8			;MAKE SURE WE DON'T LOSE SIGNIFICANT
					;BITS WHEN WE FSC
	FSC 3,233			;CONVERT TO FLOATING
	GTAD				;GET DATE AND TIME
;	CAMN 1,[-1]			;SHOULD REALLY DO THIS
;	JRST ASGDS3
	JUMPL 1,ASGDS3			;RETURN IF NO DATE
	SUB 1,BEGDAT(12)		;LESS START DATE OF THIS GROUP
	CAIL 7,0(1)			;OVERFLOW IN RH?
	SUB 1,[-1,,^D<24*60*60>]	;YES, ADJUST
	LSH 1,-^D9			;MAKE SURE IT FITS IN 27 BITS
	FSC 1,233			;FLOAT IT
	FMPR 2,1			;COMPUTE 1/COST EFFECTIVENESS
	FDVR 2,3			;WHICH IS =(DSHARE*(NOW-BEGDATE))/CPUSED
	CAML 2,10			;LARGEST YET?
	SKIPA 10,2			;YES, REMEMBER IT
	CAIA
ASGDS4:	MOVEI 11,0(5)			;AND REMEMBER GROUP

ASGDS2:	ADDI 12,NWDGRP			;MAINTAIN ACTUAL INDEX
	AOBJN 5,ASGDS1			;ON TO NEXT GROUP

	FMPR 6,KFACT			;MULTIPLICATIVE FACTOR FOR WINDFALL
	FADRM 6,DSHARE(11)		;GIVE WINDFALL TO NEEDIEST GROUP

ASGDS3:	UNLOCK GRPLOK
	OKINT
	HRLZI 12,-11(P)
	BLT 12,12
	SUB P,BHC+12
	RET


>;END PIE-SLICE SCHEDULER CONDITIONAL

;INFO JSYS'S
	RESCD		; MAKE THESE RESIDENT !!!

.GJINF:	MOVE 3,JOBNO
	HRRZ 1,JOBDIR(3)
	HLRZ 2,JOBDIR(3)
	MOVE 4,CTRLTT
	XCT MJRSTF

.TIME:	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
RTIM:	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	XCT MJRSTF

.JOBTM:
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
	ADD 1,JOBRTT
	XCT MJRSTF
	SWAPCD		; BACK TO SWAPPABLE CODE.


.RUNTM:	JSYS MENTR
	XCTUU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	ADD 1,JOBRTT
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JRST CLFRET

.GTRPI:	JSYS MENTR
	CALL SETLFK
	MOVE 1,UTRPCT
	MOVE 2,USWPCT
	MOVE 3,PTTIM
	JRST RETA3

;GET DIRECTORY ALLOCATION
; TAKES A DIRECTORY NUMBER IN 1. 0 MEANS CURRENT CONNECTED DIR
; RETURNS ALLOCATION IN 1, USED IN 2. IF NO SUCH DIRECTORY,
; RETURNS 0 IN 1 AND 2
;
.GTDAL:	JSYS MENTR
	JUMPLE 1,GTDAL1
	PUSHJ P,HSHLUK##	; DIR SUPPLIED. SEE IF IT EXISTS
	  JRST GTDAL3		; NOPE.
	PUSHJ P,USTDIR##	; YES. UNLOCK IT.
	JRST GTDAL2		; AND USE THAT DIRECTORY NUMBER

GTDAL1:	MOVE 1,FORKX
	SKIPGE 1,FKDIR(1)
	MOVE 1,FKDIR(1)		;1=CONN DIR,,USER DIR
	HLRZS 1
GTDAL2:	SETO 2,
	CALL MAPDIR
	HLRZ 1,DIRDSK		; GET MAXIMUM ALLOCATION
	UMOVEM 1,1
	HRRZ 1,DIRDSK		;CURRENT IN-USE COUNT
				;(DOESN'T INCLUDE PAGES CREATED FOR
				; FILES WHICH ARE STILL OPEN)
	UMOVEM 1,2
	JRST MRETN

GTDAL3:	PUSHJ P,USTDIR##	; UNLOCK DIRECTORY
	MOVEI 1,0		; RETURN 0 AS ANSWER FOR USED AND ALLOC
	UMOVEM 1,2
	UMOVEM 1,1
	JRST MRETN


;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL

.SYSGT:	JSYS MENTR
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTUU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTAB(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ 1,GTTAB(4)		;ADDRESS OF FIRST WORD

;TEMPORARILY PROVIDE AN EXTRA LEVEL OF ADDRESSING FOR SYSSTAT
;TABLE WHICH WILL GO AWAY SOON.
	MOVEI 4,0(4)		;CLEAR LEFT HALF
	CAIN 4,SYSSTN		;IS THIS THE SYSSTAT TABLE?
	MOVE 1,0(1)		;YES

	MOVE 1,0(1)
	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN

.GETAB:	JSYS MENTR
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR GTABX3		;NO  *** CHANGE TO GTABX3 ASAP ***
	HLRE 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR GTABX1		;NO
	HLRZ 1,GTTAB(3)		;GET SIZE OF TABLE
	JUMPL 2,RETN1		;RETURN SIZE IF INDEX <0
	CAIL 2,0(1)		;INDEX WITHIN BOUNDS?
	RETERR GTABX2
	ADD 2,GTTAB(3)		;COMPUTE ADDRESS OF DESIRED WORD

;ADD LEVEL OF ADDRESSING FOR SYSSTAT AS PER COMMENT IN SYSGT
	CAIN 3,SYSSTN		;SYSSTAT?
	MOVE 2,0(2)

	MOVE 1,0(2)		;GET WORD
RET1:	UMOVEM 1,1		;RETURN IT TO USER
URSKP:	AOS 0(P)		;SKIP RETURN
	JRST MRETN

RETN1:	XCTUU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	JRST URSKP		;SKIP RETURN

;TABLE OF TABLES

	EXTERN NDEV,DEVNAM,DEVCHR,DEVUNT,JOBDIR
	EXTERN TOTRC,MAXQ,QSUM,NTASKT,SOLD,NLOADT,RJTSUM,NEVENT,DRMRD

GTTAB:	XWD NJOBS,JOBPT		;CONTROL TTY,,TOP FORK
	XWD NJOBS,JOBRT		;JOB RUN TIME
	XWD 1,[^D1000]		;DIVISOR FOR SECONDS
	XWD NJOBS,JOBDIR	;DIRECTORY BEING USED
	XWD NLINES,TTFORK
	XWD 1,TOTRC
	XWD NDEV,DEVNAM
	XWD NDEV,DEVCHR
	XWD NDEV,DEVUNT
	XWD NDSKEW,DSKRCE
	XWD NDRMEW,DRMCFE
	XWD SVNN,SVN
	XWD 1,SVNUM
	XWD 3,UTRPCT
SYSSTN==.-GTTAB
	XWD NSTAT,SYSST
	XWD MAXQ+1,QSUM
	XWD NJOBS,JOBNAM
	XWD NNAMES,SNAMES
	XWD NNAMES,STIMES
	XWD NNAMES,SPFLTS
	XWD NNAMES,SWAKES
	XWD NNAMES,SBLKTM
	XWD 2,DBUGSW		;DBUGSW AND DCHKSW
	XWD NLGDES,LOGDES
	XWD GTBSIZ,SYMTAB	;THE 6BIT SYMBOLS
	XWD GTBSIZ,GTTAB	;AND THE POINTERS
	XWD 1,ENTFLG		;ENTRY ALLOWED IF NON-ZERO
	XWD 1,DRMFRE		;TEMP TILL MOUNTABLE PACKS/NEW SWAPPER
	XWD NTASKT,SOLD
	XWD NLOADT,RJTSUM
	XWD NEVENT,DRMRD
	XWD 1,LGNPAR##		;LOGIN FAILURE CODE IF SYSTEM FULL
	XWD NDSKPR##,DSKPAR##	; DSK PARAMETERS
	XWD 1,FDFMTF##		; DIRECTORY FORMAT FLAG
	XWD NPACKS,DRIVTB##	;DISK LOGICAL/PHYSICAL DRIVE TABLE
	XWD NJOBS,JOBACT##	;JOB ACTIVITY   ***SRI-AIC***
	XWD	NFKT,FORKT	;FORK TABLES *** SRI-AIC ***
IFDEF IMPCHN,<		;NETWORK RELATED TABLES
	EXTERN NHOSTS,HOSTN,LSKT,FSKT,NETAWD,NETBAL,NETSTS,NETBUF
	EXTERN NHSTN,HSTNAM,NETBTC,IMPGTN
	XWD IMPGTN,IMPRDY
	XWD IMPLBT,IMPHRT
	XWD 200,HSTSTS
GTBNHN::XWD NHSTN,HSTNAM
GTBHST::XWD NHOSTS,HOSTN
	XWD NSKT,LSKT
	XWD NSKT,FSKT
	XWD NSKT,NETAWD
	XWD NSKT,NETBAL
	XWD NSKT,NETSTS
	XWD NSKT,NETBUF
	XWD NSKT,NETBTC
	XWD IMPNLK,IMPLT1
	XWD IMPNLK,IMPLT2
	XWD IMPNLK,IMPLT3
	XWD IMPNLK,IMPLT4
	XWD 2,NLHOST		;HOST NUMBER, NVT COUNTER
>

IFN PIESLC,<
	XWD NGRPS,NAPROC##
	XWD NGRPS,DSHARE##
	XWD NJOBS,PIEGRP##
	XWD NGRPS,NJBGRP
	XWD NGRPD,GRPDES
> ; END PIE-SLICE SCHEDULER CONDITIONAL

	XWD NMNDSC,MONDSC

GTBSIZ==.-GTTAB
	BLOCK 10

;SYMBOL TABLE PARALLEL TO ABOVE

SYMTAB:	SIXBIT /JOBTTY/
	SIXBIT /JOBRT/
	SIXBIT /TICKPS/
	SIXBIT /JOBDIR/
	SIXBIT /TTYJOB/
	SIXBIT /NCPGS/
	SIXBIT /DEVNAM/
	SIXBIT /DEVCHR/
	SIXBIT /DEVUNT/
	SIXBIT /DSKERR/
	SIXBIT /DRMERR/
	SIXBIT /SYSVER/
	SIXBIT /VERNUM/
	SIXBIT /PGSTAT/
	SIXBIT /SYSTAT/
	SIXBIT /QTIMES/
	SIXBIT /JOBNAM/
	SIXBIT /SNAMES/
	SIXBIT /STIMES/
	SIXBIT /SPFLTS/
	SIXBIT /SWAKES/
	SIXBIT /SBLKTM/
	SIXBIT /DBUGSW/
	SIXBIT /LOGDES/
	SIXBIT /SYMTAB/
	SIXBIT /GETTAB/
	SIXBIT /ENTFLG/
	SIXBIT /DRMFRE/
	SIXBIT /TASKTB/
	SIXBIT /LOADTB/
	SIXBIT /EVENTS/
	SIXBIT /LGNPAR/
	SIXBIT /DSKPAR/
	SIXBIT /FDFMTF/
	SIXBIT /DRIVTB/
	SIXBIT /JOBACT/
	SIXBIT /FORKT /
IFDEF IMPCHN,<
	SIXBIT /NETRDY/
	SIXBIT /IMPHRT/
	SIXBIT /HSTSTS/
	SIXBIT /HSTNAM/
	SIXBIT /HOSTN/
	SIXBIT /NETLSK/
	SIXBIT /NETFSK/
	SIXBIT /NETAWD/
	SIXBIT /NETBAL/
	SIXBIT /NETSTS/
	SIXBIT /NETBUF/
	SIXBIT /NETBTC/
	SIXBIT /IMPLT1/
	SIXBIT /IMPLT2/
	SIXBIT /IMPLT3/
	SIXBIT /IMPLT4/
	SIXBIT /LHOSTN/
>

IFN PIESLC,<
	SIXBIT /NAPROC/
	SIXBIT /DSHARE/
	SIXBIT /PIEGRP/
	SIXBIT /NJBGRP/
	SIXBIT /GRPDES/

> ; END PIE-SLICE SCHEDULER CONDITIONAL

	SIXBIT /MONDSC/

IFN GTBSIZ-<.-SYMTAB>,<	PRINTX  GETAB SYMBOL TABLE INCORRECT
>
	BLOCK 10


;TEMPORARY SYSTAT TABLE CONTAINING ADDRESSES OF DATA WHICH
;USED TO BE FOUND IN PREVIOUS SYSTAT TABLE
SYSST:	IDLE##
	SWAPWT##
	GCCR##
	PTRAP##
	DRMRD
	DRMWR##
	DSKRD##
	DSKWR##
	WAKEUP##
	TTINTS##
	BSTSUM##
	RJTSUM##
	RJAV##
	RJAV+1
	RJAV+2
	[0]
	[0]
	NTTYIN##
	NTTYOT##
	GCCR+1
	PPG##
	NREMJ##
	[0]
	HSYST1##
	HSYST4##
	HSYST5##
NSTAT==.-SYSST
FORKT:	XWD	NUFKS,SYSFK	;***SRI-AIC***
	XWD	NUFKS,FKPTRS	;***SRI-AIC***
	XWD	NFKS,FKPGS	;***SRI-AIC***
	XWD	NFKS*^D10,FKSTAT	;***SRI-AIC***
NFKT==.-FORKT			;***SRI-AIC***


;SUBSYSTEM STATISTICS LOGIC

.SETNM:	JSYS MENTR
	NOINT
	AOSE SNMLCK		;LOCK TABLE
	JSYS BLOCK1		;OR WAIT TILL LOCKABLE
	HRLZ 3,SNMPT		;NEG COUNT OF ENTRIES
	CAMN 1,SNAMES(3)	;DESIRED NAME?
	JRST SNM1		;YES
	AOBJN 3,.-2		;NO, LOOKED AT ALL?
	MOVEI 3,0(3)
	CAIL 3,NNAMES-1		;TABLE NOW FULL?
	SKIPA 1,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	SOS SNMPT		;UPDATE POINTER
	MOVEM 1,SNAMES(3)	;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	JRST MRETN

GS SNMPT,1		;NEG COUNT OF ENTRIES IN SNAMES
GS SNMLCK,1		;LOCK FOR SNAMES TABLE

.GETNM:	MOVE 1,JOBNO
	HRRZ 1,JOBNAM(1)
	MOVE 1,SNAMES(1)
	XCT MJRSTF

.SWTCH:
	DATAI APR,1
	XCT MJRSTF

.LITES:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER+MAINT	;REQUIRES STATUS
	JRST WHEELX
	DATAO PI,1		;DISPLAY
	JRST MRETN

.USRIO:	JSYS MENTR
	MOVEI 1,WHEEL+OPER+MAINT
	TDNN 1,CAPENB		;REQUIRES STATUS
CAPXR:	RETERR CAPX1
	MOVSI 1,(1B6)		;USER IO BIT
	IORM 1,0(P)		;PUT IT ON
	JRST SKMRTN

;PEEK - AC1:  N,,MONLOC
;       AC2:     USRLOC

.PEEK:	JSYS MENTR
	MOVEI 3,WHEEL+OPER+MAINT
	TDNN 3,CAPMSK		;HAS NECESSARY CAPS?
CAPX:	ITERR CAPX1		;NO.
	MOVSI 5,0(1)		;SETUP BLT ARGS - FROM
	HRRI 5,0(2)		; .. TO
	MOVEI 6,0(2)
	HLRZ 3,1		;COUNT
	ADDI 6,-1(3)		; .. TO LIMIT
	ADDI 3,-1(1)		;FROM LIMIT
	XORI 3,0(1)		;SEE IF BLOCK CROSSES PAGE BOUNDARY
	TRNE 3,777000
	RETERR PEEKX1		;CAN'T CROSS PAGE BOUNDARY
	MOVEI 1,0(1)
	MRPAC			;GET ACCESS OF PAGE
	TLNN 2,READB		;READ ALLOWED?
	RETERR PEEKX2		;NO
	XCTMU [BLT 5,0(6)]	;TRANSFER WORD(S)
	AOS 0(P)
	JRST MRETN

;ERROR - WHEEL OR OPER REQUIRED BUT NOT ENABLED

WHEELX:	ITERR WHELX1

;LOGOUT

.LGOUT:	JSYS MENTR
	NOINT
	CAME 1,MINUS1##		;SELF?
	JRST ELOGO		;NO
LOGO:	SKIPE FORKN		;TOP FORK?
	JRST [	MOVSI 1,LOG
		TDNN 1,CAPMSK	;LOG PERMITTED?
		JRST LOGOE1	;NO, ERROR RETURN
		CALL SKTGRP	;EXECUTING FORK IN TOP GROUP
		RETERR FRKHX7	;NO, ILLEGAL LGOUT ATTEMPT
		HLRZ 1,FORKN
		HRRZ 2,SYSFK(1)	;2=SYS FK INDEX OF TOP FORK IN JOB
		NOSKED
		MOVSI 1,400000+PSILOB
		IORM 1,FKINT(2)	;REQUEST LOGOUT
		CALL PSIR4
		OKSKED
		RESKD1
		OKINT
		JRST HALTF1]	;HALT THIS ONE
FLOGO1:				;LOGOUT PSI REQUEST ENTERS HERE
IFDEF DSPCHN,<
	SETO 1,
	RELDP
	RELDC>
IFDEF IMPCHN,<
	SETO 1,
	JSYS 753>
	MOVEI 1,-4
	KFORK			;DELETE FORKS
	SETO 1,			;CLEAR USER MAP OF TOP FORK
	MOVSI 2,400000
	PMAP
	ADDI 2,1
	TRNN 2,1000
	JRST .-3
	SKIPL CTRLTT
	RESET			;RESET TTY MODES, ETC.
	MOVE 1,[1B5+400000]	;INSIST + THIS FORK
	CLZFF
	MOVE 1,JOBNO
	HLRZ 1,JOBDIR(1)	;CONNECTED DIRECTORY
	DELDF			;DELETE DELETED FILES
	MOVEI 1,400000
	SETO 2,
	DIC			;DEACTIVATE INTERRUPTS AND KEYS
	CALL DTIALL
	MOVSI 3,-NJOBS		;LOG OUT ANY JOBS WHICH I OWN
SJLGO1:	HRRZ 2,JOBONT(3)	;GET AN OWNER
	CAME 2,JOBNO		;IS IT ME?
	JRST SJLGO2		;NO
	MOVEI 1,(3)		;YES. NOW LOG IT OUT
	LGOUT			; ..
	  JFCL			;COULDN'T?!?
	SETOM JOBONT(3)		;AND MAKE ME NOT OWN IT
SJLGO2:	AOBJN 3,SJLGO1		;CHECK ALL JOBS
SJLGO3:	MOVE 1,JOBNO		;NOW SEE IF I AM OWNED
	MOVE 2,JOBONT(1)	; ..
	CAMN 2,MINUS1		; ..
	JRST SJLGO4		;NO, I CAN LOG OUT OK
;; ADD CODE HERE TO POKE MY OWNER
	MOVEI 1,^D5000		;WAIT FOR OWNER TO FREE ME
	DISMS
	JRST SJLGO3		;SEE IF I CAN GO YET

SJLGO4:	MOVE 1,JOBNO
	HRRZ 1,JOBDIR(1)
	JUMPE 1,LOG1		;IF JOB NOT LOGGED IN
	CALL GTLGTT		; GET THE LOGGING TTY
	CALL LOGTOT		;SUMMARY TO LOG TTY
	CALL RLLGTT		; RELEASE LOG TTY
	CALL LGOFCT		; MAKE LOGOUT FACT FILE ENTRY
LOG1:
IFN PIESLC,<
	MOVE 1,JOBNO
	NOINT
	LOCK GRPLOK
	MOVE 2,PIEGRP(1)
	SOSG NJBGRP(2)
	SETZM DSHARE(2)			;CLEAR IF NO LONGER IN USE
	UNLOCK GRPLOK
	OKINT
	CALL ASGDSH		;RECOMPUTE DSHARE VALUES

>;END PIE-SLICE SCHEDULER CONDITIONAL

	HRRE 1,CTRLTT
	JUMPL 1,LOG2		;CONTROL TTY?
	HRLOI 1,(1B0+1B1+1B4+1B5)	;YES. BREAK LINKS
	MOVEI 2,-1
	TLINK			;BREAK LINKS, SET ACCEPT
	JFCL
	HRRZ 1,CTRLTT
	MOVEI 1,400000(1)	;NOW PRINT LOGOUT MESSAGE
	CALL LOGTOT
	CALL LOGCR
	MOVE 2,CTRLTT
	MOVE 1,JOBNO		;SEE IF LOGGED IN.
	HRRZ 1,JOBDIR(1)	; ..
	JUMPE 1,[CALL TTHNGI##	;IF NOT, HANG UP IMMEDIATELY
		JRST LOG2]	; ..
	CALL TTHNGU		;ELSE SLOW HANGUP IN CASE ANOTHER ^C
LOG2:	JRST HLTJB

ELOGO:	MOVE 2,JOBNO		;GIVEN JOB NUMBER TO LOGOUT
	CAIN 2,0(1)		;SELF?
LOGOE1:	RETERR LOUTX1		;YES, CAN'T SAY IT THAT WAY
	CAIGE 1,NJOBS		;REASONABLE NUMBER?
	CAIGE 1,0
LOGOE2:	RETERR LOUTX2		;NO
	SKIPGE JOBRT(1)		;EXISTS?
	JRST LOGOE2
	HRRZ 3,JOBDIR(1)	;LOGIN DIRECTORY OF OBJECT JOB
	XOR 3,JOBDIR(2)
	TRNN 3,-1		;SAME AS THIS JOB?
	JRST ELOGO1		;YES, THAT'S OK
	HRRZ 3,JOBONT(1)	;OWNER OF OBJECT JOB
	CAMN 2,3		;IS IT ME?
	JRST ELOGO1		;YES. I CAN LOG IT OUT.
	MOVEI 3,WHEEL+OPER+MAINT	;OTHERWISE MUST BE WHEEL
	TDNN 3,CAPENB
	JRST LOGOE1		;ILLEGAL
ELOGO1:	SETOM JOBONT(1)		;MAKE IT UN-OWNED, SO IT CAN GO AWAY
	HRRZ 2,JOBPT(1)		;TOP FORK OF OBJECT JOB
	NOSKED
	MOVSI 1,400000+PSILOB
	IORM 1,FKINT(2)		;REQUEST LOGOUT
	CALL PSIR4
	OKSKED
	RESKD1
	AOS 0(P)		;RETURN GOOD
	JRST MRETN

FLOGO:	SKIPGE SLOWF		;ALREADY IN JSYS?
	JSYS MENTR		;NO, DUMMY UP ENTRY
	NOINT
	MOVE P,UPP		;MAKE SURE WE HAVE EMPTY STACK
	ADD P,BHC+2
	JRST FLOGO1

;LOGGING FUNCTIONS

;TYPE LOGOUT MESSAGE, DESTINATION DESIGNATOR IN 1

LOGTOT:	HRROI 2,[ASCIZ /LOGOUT/]
	CALL LOGMES
	CALL LOGJOB		;PRINTS JOB NO, TTY NO, TIME
	HRROI 2,[ASCIZ /
  USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5		;FOR WHOLE JOB
	RUNTM
	MOVEM 1,3(7)		;RUNTIME FOR EFACT
	MOVEM 3,4(7)		;CONSOLE TIME FOR EFACT
	MOVE 2,1
	POP P,1
	PUSH P,3
	CALL LOGTIM		;PRINT CPU TIME
	HRROI 2,[ASCIZ / IN /]
	CALL LOGMES
	POP P,2
	CALL LOGTIM		;PRINT CONSOLE TIME
	RET

; MAKE LOGOUT FACT ENTRY

LGOFCT:	MOVEI 2,141		;LOGOUT CODE
	DPB 2,[POINT 9,0(7),8]
	MOVSI 1,-5		;SIZE OF LOGOUT BLOCK
	; FALL INTO LOGFCT

; MAKE LOG TYPE FACT FILE ENTRY (LOGOUT, LOGIN, ATACH, DETACH ...)

LOGFCT:	HRRI 1,0(7)		;LOC OF LOGOUT BLOCK
	NOINT
	PUSH P,CAPENB
	MOVEI 2,OPER		;TEMP CHANGED FROM MOVSI 2,LOG
	IORM 2,CAPENB		;BE SURE WE HAVE LOG CAPABILITY
	EFACT
	 JSP 2,XEFACT		;CHECK EFACT FAILURE (ALWAYS SKIPS)
	  SETOM ACCIFG		; IF SUCCESS, ASSUME SUCCESS HENCEFORTH
	POP P,CAPENB		;RESTORE CAPS
	OKINT

IFN PIESLC,<
	MOVE 2,JOBNO
	NOINT
	LOCK GRPLOK
	MOVE 2,PIEGRP(2)	;GET PIE-SLICE GROUP INDEX
	IMULI 2,NWDGRP		;CONVERT TO ACTUAL INDEX
	MOVE 3,3(7)		;GET CPU TIME
	ADDM 3,CPUSED(2)
	UNLOCK GRPLOK
	OKINT
>;END PIE-SLICE SCHEDULER CONDITIONAL

	RET

;CHECK EFACT FAILURE

XEFACT:	SKIPE ACCIFG		;ACCOUNTS SUPPOSEDLY INITIALIZED?
	BUG(CHK,<EFACT FAILURE>)
	JRST 1(2)		;NO, ALLOW EFACT FAILURE

;LOGON MESSAGE, CALLED FROM .LOGIN

LOGONM:	CALL GTLGTT		; GET LOGGING TTY
	HRROI 2,[ASCIZ /LOGIN/]
	CALL LOGMES
	CALL LOGJOB
	CALL RLLGTT		; RELEASE LOGGING TTY
	MOVEI 1,501		;LOGIN CODE
LOGCJ1:	DPB 1,[POINT 9,0(7),8]
	MOVE 1,4(7)		;ACCOUNT WORD
	JUMPL 1,[SUBI 1,4	;STRING ACCOUNT, ROUND CHAR COUNT
		IDIVI 1,5	;COMPUTE WORD COUNT
		MOVSI 1,-5(1)	;ADD WORD COUNTS FOR STRING AND BLOCK
		JRST .+2]
	MOVSI 1,-5		;WORD COUND INCLUDES BLOCK ONLY
	JRST LOGFCT

;CHANGED ACCOUNT NUMBER MESSAGE

LOGCJM:	CALL GTLGTT		; GET LOGGING TTY
	HRROI 2,[ASCIZ /CHANGED/]
	CALL LOGMES
	CALL LOGJOB
	HRROI 2,[ASCIZ /
 USED /]
	CALL LOGMES
	PUSH P,1
	MOVNI 1,5
	RUNTM			;RUNTIME OF JOB
	MOVEM 1,3(7)		;SAVE FOR FACT FILE
	MOVE 2,1
	POP P,1
	CALL LOGTIM		;PRINT ON LOG TTY
	CALL RLLGTT		; RELEASE LOGGING TTY
	MOVEI 1,502
	JRST LOGCJ1

LGCJM0::MOVEI 7,LOGBUF			; PLACE FOR EFACT ENTRY
	MOVEI 2,502			; CHANGE ACCOUNT ENTRY
	DPB 2,[POINT 9,0(7),8]
	MOVE 2,JOBNO
	DPB 2,[POINT 9,0(7),17]
	MOVE 2,CTRLTT			; CONTROLLING TTY
	DPB 2,[POINT 9,0(7),29]
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)		; DIRECTORY #
	HRRM 2,1(7)
	GTAD
	MOVEM 1,2(7)
	MOVNI 1,5
	RUNTM				; GET JOB'S RUNTIM
	MOVEM 1,3(7)
	MOVE 2,ACCTPT			; GET ACCOUNT DESIGNATOR
	LDB 3,[POINT 3,2,2]
	CAIE 3,5			; NUMERIC ACCOUNT?
	 JRST LGCJM1			; NO, A STRNG ONE
	TLZ 2,700000			; YES, KILL BITS 0,1,2
	MOVEM 2,4(7)			; INTO EFACT BLOCK
	MOVSI 1,-5			; SIZE OF THIS ENTRY
	JRST LOGFCT			; LOG IT
LGCJM1:	SETZ 4,				; FOR COUNTING
	ILDB 3,2
	JUMPE 3,.+2			; IF DONE
	SOJA 4,.-2			; IF NOT
	MOVEM 4,4(7)			; - # OF CHARS IN STRING
	SUBI 4,4			; ROUND UP(?) TO NEXT WORD
	IDIVI 4,5			; # OF WORDS
	MOVSI 1,-5(4)			; TOTAL SIZE OF BLOCK
	JRST LOGFCT			; LOG THE ENTRY

;PRINT TIME FROM 2

LOGTIM:	JUMPL 1,R
	IDIVI 2,^D1000		;MS TO SECS
	IDIVI 2,^D60		;PEEL OFF SECONDS
	PUSH P,3
	IDIVI 2,^D60		;PEEL OFF MINUTES
	PUSH P,3
	CALL LOGNUM		;PRINT HOURS
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT MINUTES
	MOVEI 2,":"
	BOUT
	POP P,2
	CALL LOGNUM		;PRINT SECONDS
	RET

;ATACH AND DETACH MESSAGES

DETMSG:	CALL GTLGTT		; GET LOGGING TTY
	HRROI 2,[ASCIZ /DETACHED/] ;WORD FOR LOG TTY
	CALL LOGMES
	CALL LOGJOB
	CALL RLLGTT		; RELEASE LOGGING TTY
	MOVEI 1,143		;DETACH CODE
ATAMS2:	DPB 1,[POINT 9,0(7),8]
	MOVSI 1,-3		;SIZE OF BLOCK
	JRST LOGFCT

ATAMSG:	MOVEI 7,LOGBUF
	CALL GTLGTT		; GET LOGGING TTY
	HRROI 2,[ASCIZ /ATTACHED JOB /]
	CALL LOGMES
	HLRZ 2,0(7)		;GET JOB NUMBER
	CALL LOGNUM		;PRINT IT
	HRROI 2,[ASCIZ / TO TTY /]
	CALL LOGMES
	LDB 2,[POINT 12,0(7),29] ;TTY NUMBER
	MOVEI 3,^D8		;PRINT IN OCTAL
	CALL LGNOUT
	CALL LOGJ2		;PRINT AND STORE TOD
	CALL RLLGTT		; RELEASE LOGGING TTY
	MOVEI 1,142		;ATACH CODE
	JRST ATAMS2

;PRINTS  JOB 1, TTY 40, AT 12:34:56
;  OR    JOB 1, DETACHED, AT 12:34:56

LOGJOB:	MOVEI 7,LOGBUF		;BLOCK FOR EFACT
	HRROI 2,[ASCIZ / JOB /]
	CALL LOGMES
	MOVE 2,JOBNO
	DPB 2,[POINT 9,0(7),17]	;JOB NUMBER FOR EFACT
	CALL LOGNUM
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	JUMPE 2,LOGJ3		;LOGGED IN NOW?
	HRROI 2,[ASCIZ /, USER /]
	CALL LOGMES
	MOVE 2,JOBNO
	HRRZ 2,JOBDIR(2)
	HRRM 2,1(7)		;DIRECT NUMBER FOR EFACT
	CAIL 1,0
	DIRST			;DIRECTORY NAME
	JFCL
	HRROI 2,[ASCIZ /, ACCT /]
	CALL LOGMES
	MOVE 2,ACCTPT
	CALL LOGACC
LOGJ3:	MOVE 2,CTRLTT
	DPB 2,[POINT 12,0(7),29] ;TTY NUMBER FOR EFACT
	JUMPL 2,LOGJ1		;IF NO CTRL TTY (DETACHED JOB)
	HRROI 2,[ASCIZ /, TTY /]
	CALL LOGMES
	MOVE 2,CTRLTT
	MOVEI 3,^D8		;PRINT TTY NUMBER IN OCTAL
	CALL LGNOUT
LOGJ2:	HRROI 2,[ASCIZ /, AT /]
	CALL LOGMES
	PUSH P,1		;SAVE DESIGNATOR
	GTAD
	MOVEM 1,2(7)		;TOD FOR EFACT
	MOVE 2,1
	POP P,1			;RESTORE DESTINATION
	JUMPL 1,R
	MOVSI 3,045240		;MOST ABBREVIATED DATE AND TIME
	CAIL 2,0
	ODTIM
	RET

LOGJ1:	HRROI 2,[ASCIZ /, DETACHED/]
	CALL LOGMES
	JRST LOGJ2

LOGACC:	LDB 3,[POINT 3,2,2]
	CAIE 3,5		;STRING OR NUMBER?
	JRST LOGAC1		;STRING
	TLZ 2,700000
	MOVEM 2,4(7)		;ACCOUNT NUMBER FOR EFACT
	JRST LOGNUM		;PRINT NUMBER

LOGAC1:	SETZ 4,			;TO COUNT CHARS
	MOVE 3,2		;STRING PTR
LOGAC2:	ILDB 2,3		;CHAR OF ACCOUNT STRING
	JUMPE 2,LOGAC3		;NULL IS END OF STRING
	CAIL 1,0
	BOUT			;PRINT IT ON LOG TTY
	AOJA 4,LOGAC2		;COUNT IT

LOGAC3:	MOVNM 4,4(7)		;LEAVE NEG OF WORD COUNT FOR EFACT
	RET

LOGMES:	SETZ 3,
	JUMPL 1,R
	SOUT
	RET

LOGNUM:	MOVEI 3,^D10		;DECIMAL FOR TIMES, ETC.
LGNOUT:	JUMPL 1,R
	NOUT
	BUG(CHK,<LGNOUT - NOUT FAILED>)
	RET

LOGCR:	MOVEI 2,15
	JUMPL 1,R
	BOUT
	MOVEI 2,12
	BOUT
	RET

; LOGGING TTY VAIRIABLES

LS(LOGLCK,1)		; INTERLOCK TO PREVENT INTERMIXING MSGS
LS(LLGLCK,1)		; PC OF LAST LOCKER
LS(FLGLCK,1)		; FORKX OF LAST LOCKER

; LOCK UP LOGGING TTY TO PREVENT INTERMIXED MSGS

GTLGTT:	MOVE 1,LOGDES		; TRY TO SEPARATE TYPEOUT IF JOB0 AND
	CAMN 1,JB0TT		; LOGGING INFO, IF ON SAME TTY
	CAIN 1,377777		; DON'T DOBE ON NIL DEVICE - NOT NEEDED
	SKIPA			; NIL OR NOT SAME
	DOBE			; SAME AND NOT NIL. WAIT.
	NOINT
GTLGT1:	AOSE LOGLCK		; LOCK THE LOCK
	 JRST [	MOVEI 1,LOGLCK
		PUSHJ P,DISL##
		JRST GTLGT1]
	MOVE 1,0(P)
	MOVEM 1,LLGLCK
	MOVE 1,FORKX
	MOVEM 1,FLGLCK
	MOVE 1,LOGDES
	PUSH P,2
	PUSH P,3
	MOVE 2,[BYTE (2)0,0,0,0,0,0,0,1,2,2,2,0,1,2,0,0,0,0]
	MOVE 3,[BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,2]
	SFCOC			; MAKE SURE NOBODY'S BEEN MUCKING WITH
	RFMOD
	TRO 2,100
	SFMOD			; MODE WORDS
	POP P,3
	POP P,2
	RET

; RELEASE LOGGING TTY

RLLGTT:	CALL LOGCR
	SETOM LOGLCK
	OKINT
	RET


;DETACH FROM CONTROLLING TTY

.DTACH:	JSYS MENTR
	NOINT
	SKIPGE CTRLTT		;IS ONE?
	JRST MRETN		;NO, DO NOTHING
	CALL SKTGRP		;EX FORK IN TOP GROUP IN JOB?
	JRST MRETN		;NO, DTACH=NOOP
	HRLOI 1,(1B0+1B1+1B4+1B5)
	MOVEI 2,-1
	TLINK			;BREAK LINKS
	JFCL
	MOVE 4,JOBNO
	HRRE 2,JOBDIR(4)
	CAIE 2,0		;LOGGED IN?
	CALL DETMSG		;YES, DO MESSAGE AND EFACT
	MOVE 2,CTRLTT
	SETOM CTRLTT
	SETOM TTFORK(2)
	SETZM TTPSI(2)
	MOVE 1,JOBNO
	HRROS JOBPT(1)
	JRST MRETN

;ATTACH JOB TO TTY

	EXTERN ATACX4

.ATACH:	JSYS MENTR
	NOINT
	PUSH P,1		;SAVE JOB NO
	CALL SKTGRP		;EXECUTING FORK IN TOP GROUP IN JOB?
	RETERR FRKHX7
	UMOVE 2,2		; GET USER NUMBER
	MOVEI 1,WHEEL+OPER
	TDNE 1,CAPENB		;PRIVILEGED?
	JRST ATACH3		;YES, NO PASSWORD CHECK
	PUSH P,2		; SAVE USER NUMBER
	HRRZ 1,2
	UMOVE 2,3		; GET PASSWORD STRING POINTER
	CALL PASSWC		;CHECK PASSWORD
	 JRST [	MOVEI 1,ATACX4
		JRST MRETNE]
	POP P,2
ATACH3:	HRRZ 1,0(P)
	CAIL 1,0
	CAIL 1,NJOBS		;LEGAL JOB NO?
	RETERR ATACX1		;NO
	HRRZ 3,JOBDIR(1)	;DIRECTORY OF  OTHER JOB
	PUSH P,3		;SAVE FOR FACT FILE
	CAIE 3,0(2)		;SAME AS SPECIFIED?
	RETERR ATACX3		;NO
	SKIPGE CTRLTT		;THIS JOB NOT ATTACHED? OR
	RETERR ATACX2		;YES
	HRRZ 1,JOBPT(1)		;TOP FORK OF OTHER JOB
	HRRZ 1,FKPGS(1)		;GET PSB OF IT
	MOVE 2,[XWD RWX,FPBPGA]
	CALL SETMPG		;MAP IT
	LDB 1,[POINT 13,FPBPGA+JSBPG,26]	;GET JSB NO
	CALL SETMPG
	MOVEI 6,FPBPGA-JSB
	SKIPL 4,CTRLTT(6)	;OTHER JOB NOW UNATACHED?
	JRST [	NOSKED		;NO, MUST DETACH IT FIRST
		MOVE 3,PSICH+3	;CONTROL-C INTERRUPT CODE
		MOVEI 2,0(4)	;LINE NUMBER
		CALL TTPSRQ	;FAKE A CONTROL-C ON OTHER JOB
		SETZM TTPSI(4)	;CLEAR TTY WORDS
		SETOM TTFORK(4)
		SETOM CTRLTT(6)
		MOVE 1,-1(P)	;OTHER JOB NUMBER
		HRROS JOBPT(1)
		OKSKED
		JRST ATACH2]

ATACH2:	PUSH P,CTRLTT
	NOSKED
	SETOM CTRLTT
	MOVE 1,JOBNO
	HRROS JOBPT(1)		;DO THE DETACH PART
	POP P,5			;TTY
	DPB 5,[POINT 12,LOGBUF,29] ;TTY NUMBER FOR EFACT
	POP P,4			;OTHER JOB'S DIRECTORY NUMBER
	HRRM 4,LOGBUF+1		;PUT IN EFACT BLOCK
	POP P,4			;DESTINATION JOB NO
	HRLM 4,LOGBUF		;PUT IN EFACT BLOCK
	MOVEM 5,CTRLTT(6)	;SET CTRLTT IN DEST JOB
	HRLM 5,JOBPT(4)
	HRLM 4,TTFORK(5)
	MOVE 1,TTSPSI(6)
	MOVEM 1,TTPSI(5)
	MOVE 1,TTSDPS(6)	;RESTORE INT CODE WORDS TO TTY LINE
	MOVEM 1,TTDPSI(5)
	CALL CLRLFK
	OKSKED
	CALL ATAMSG		;DO LOGGING STUFF
	MOVE 1,JOBNO
	HRRE 1,JOBDIR(1)
	JUMPE 1,LOGO		;VANISH IF NOT LOGGED IN
	JRST SKMRTN		;RETURN SKIP


;SKIP IF EXECUTING FORK IS IN TOP GROUP IN JOB
;CLOBBERS 1 AND 2

SKTGRP:	MOVE 1,FORKX		;CHECK THAT FORK IN TOP GROUP IN JOB
	SKIPGE FKDIR(1)
	HRRZ 1,FKDIR(1)		;1=SYS INDEX OF TOP FORK IN GROUP
	MOVE 2,JOBNO
	HRRZ 2,JOBPT(2)		;2=SYS INDEX OF TOP FORK IN JOB
	CAIN 1,0(2)		;SAME?
	AOS 0(P)		;YES.
	RET

;GET AND SAVE ROUTINES

;AC USAGE IN GET ROUTINE:
; 4 - PAGE NUMBER IN USER SPACE CURRENTLY MAPPED TO FTPG1
; 5 - POINTER TO ADDRESS IN FTPG1 CORRESPONDING TO AC 6
; 6 - AOBJN (NOT IOWD) POINTER TO USER SPACE WHERE CURRENTLY READING
;14 - SETPT ARGUMENT FOR FTPG1
;15 - FORK HANDLE BEING GET'ED INTO
;16 - JFN BEING READ FROM

.GET:	JSYS MENTR
	CALL GTSVI		;CHECK PARAMETERS, ETC.
	HRRI 2,1B19		;READ BIT
	TLNN 3,777		;DISK?
	HRRI 2,5B21+1B25	;YES, REQUEST RD,XCT ACCESS AND THAWED
	PUSH P,2		;SAVE THE DESIRED OPENING BITS
	GTSTS			;SEE IF THE FILE IS OPEN ALREADY
	TLNN 2,(1B0)		; ..
	JRST GET2A		;NO. GO OPEN IT.
	TLNE 3,777		;IT'S OPEN. IS IT A DISK?
	JRST GET2B		;NO. ASSUME HE OPENED IT RIGHT
	TLC 2,(1B0+1B1+1B3)	;SEE IF RD & XCT BOTH ON
	TLNE 2,(1B0+1B1+1B3)	; ..
	JRST GETE2		;NO.
GET2B:	RFBSZ			;AND CORRECT BYTE SIZE?
	CAIE 2,44		; ..
	JRST GETE2		;NO
	POP P,2			;OK. CLEAR STACK
	JRST GET2C		;AND GO READ THE OPEN FILE.

GET2A:	POP P,2			;RETRIEVE OPENING MODE BITS
	OPENF			;OPEN FILE FOR INPUT
	JRST ITRAP1		;WON'T OPEN
GET2C:	MOVEI 1,FTPG1A
	CALL FPTA		;GET HANDLE OF TEMP PAGE FOR LATER
	MOVE 14,1
GET2:	TSTINT			;INTERRUPT PENDING?
	CALL GETINT		;YES, GO ALLOW IT
	MOVEI 1,0(16)		;JFN
	BIN			;GET IOWD COUNT,ADR
	JUMPE 2,[GTSTS		;ZERO. PROBABLY EOF.
		TLNE 2,(1B8)	;IS IT?
		JRST GETE1	;YES. TRUNCATED FILE.
		MOVEI 2,0	;NO, A ZERO ENTRY VECTOR.
		JRST .+1]	;HANDLE IT
	MOVE 6,2
	HLRZ 2,2
	CAIL 2,1000		;LEFT HALF IMPLYING SSAVE?
	CAIL 2,10000
	JRST .+2		; NO
	JRST SGET		; YES.
	JUMPGE 6,GET1		;POSITIVE MEANS END
	ADDI 6,1		; CHANGE IOWD TO AOBJN POINTER
GET5:	CALL GET3		;SET MAP FOR THIS PAGE, SET AC 5
	MOVEI 2,0(6)		;ADDRESS IN USER SPACE
	ORCMI 2,777		;MINUS NUMBER OF WORDS IN THAT PAGE
	HLRE 3,6		;LENGTH OF THE IOWD
	CAMLE 2,3		;WILL IT FIT IN THE WINDOW PAGE?
	MOVE 3,2		;NO. JUST READ WHAT WILL FIT
	MOVM 2,3		;POSITIVE FOR UPDATING POINTERS
	HRL 2,2			;IN BOTH HALVES. THIS IS +N,,+N
	ADD 6,2			;UPDATE THE AOBJN WORD. MAY OR MAY NOT GO +
	MOVE 2,5		;ADDRESS IN WINDOW PAGE
	HRLI 2,444400		;BYTE POINTER TO IT.
	SUB 5,3			;3 IS ALREADY -N FOR SIN. COUNT WINDOW ADDR.
	SIN			;NOW READ INTO THE WINDOW
	JUMPL 6,GET5		;JUMP IF POINTER CROSSED PAGE BOUNDARY
	JRST GET2		;DONE THIS POINTER. READ NEXT ONE.

GET1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK		;MAP PSB
	MOVEM 6,ENTVEC(1)	;STORE ENTRY VECTOR DATA
	MOVEI 1,0(16)		;JFN
	JRST SAVER

SGET:	CAIE 2,1000		;CORRECT TYPE NUMBER?
	JRST GETE1		;NO, STRANGE FILE
	MOVEI 13,0(6)		;SAVE COUNT
	MOVE 1,16
	DVCHR
	TLNE 2,777		;DISK FILE?
SSAVE1:	ITERR SSAVX1		;NO, CAN'T DO IT
SGET1:	MOVE 1,SPTC		;SPT USE COUNT
	CAML 1,SPC1		;RUNNING LOW?
	ITERR GETX2		;YES, BOMB OUT
	MOVE 1,16
	BIN
	MOVEI 1,0(2)		;FILE PAGE NUMBER
	LDB 3,[POINT 9,2,8]	;ACCESS
	LDB 2,[POINT 9,2,17]	;MEMORY PAGE
	ROT 3,-^D9
	TLZE 3,(1B0)		;WRITE COPY REQUEST?
	TLO 3,COPYB		;YES, SET APPROPRIATE BITS
	HRLI 1,0(16)
	HRLI 2,0(15)
	PMAP			;MAP FILE PAGE INTO FORK
	SOJG 13,SGET1
	JRST GET2

GETINT:	SETZ 1,
	MOVEI 2,FTPG1A		;UNMAP STUFF
	CALL SETMPG
	CALL CLRLFK		;THIS DOES OKINT, INTERRUPT HAPPENS HERE
	MOVEI 1,0(15)
	CALL SETLFK		;REESTABLISH STATE
	SETO 4,
	RET

GTSVI:	MOVEI 16,0(1)		;JFN
	HLRZ 15,1		;FORK HANDLE
	MOVEI 1,0(16)		;JFN
	DVCHR			;GET DEVICE CHARACTERISTICS
				;DO THIS FIRST IN CASE OF ITRAP
	HLRZ 3,2		;SEE WHAT KIND OF DEVICE. PREVENT
	ANDI 3,777		; TTY'S, CAUSE FORK HANDLES ARE OFTEN
	CAIN 3,12		; MISPLACED INTO JFN AND LOOK LIKE TTY.
	ITERR (DESX4)		; THEN JOB HANGS NOINT ON TTY BIN
	PUSH P,2
	MOVEI 1,0(15)
	CALL SETLFK		;MAKE SURE FORK IS LEGAL
	MOVEI 1,0(16)		;JFN
	POP P,3			;DEVICE BITS
	MOVSI 2,^D36B23		;BYTE SIZE FOR BIN/BOUT XFER
	SETO 4,
	RET

;CHECK AND REMAP PAGE - 4/ CURRENT PAGE (-1 FIRST TIME)
; SET FTPG1 TO POINT INDIRECT TO USER PAGE ADDRESSED BY AC6

GET3:	TSTINT
	CALL GETINT
	LDB 2,[POINT 9,6,26]	;PAGE NUMBER NEXT REFERENCE
	CAIN 2,0(4)		;SAME AS CURRENT
	JRST GET3A		;YES
	MOVEI 4,0(2)		;REMEMBER IS CURRENT
	HRLI 2,0(15)		;FORK HANDLE
	MOVE 1,2
	CALL FKHPTN		;CONVERT TO INTERNAL FORM
	MOVE 2,14
	MOVSI 3,RWX
	CALL SETPT		;SETUP INDIRECT POINTER TO PAGE
GET3A:	MOVEI 5,0(6)		;SETUP ADDRESS FOR MON REFERENCES
	ANDI 5,777
	ADDI 5,FTPG1A
	MOVEI 1,0(16)		;RESTORE JFN TO 1
	RET

GETE2:	MOVEI 1,GETX3##		;FILE NOT PROPERLY OPENED
	JRST GETE0		;RETURN THIS ERROR CODE
GETE1:	MOVEI 1,GETX1##		;RETURN ERROR CODE
GETE0:	PUSH P,1		;SAVE THE ERROR CODE
	MOVEI 1,0(16)
	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG
	CALL CLRLFK
	POP P,1
	JRST ITRAP1		;RETURN ERROR CODE WITH ITRAP

;SAVE, GIVEN LIST OF BLOCK DESCRIPTORS OR ONE BLOCK DESCRIPTOR
;
; AC USAGE IN THIS ROUTINE --
; 16/ JFN BEING SAVED ONTO
; 15/ FORK HANDLE BEING SAVED FROM
; 10/ USER'S AC2 -- A SINGLE +N,,ADDR OR A
;     POINTER TO A LIST OF THEM, COUNTED AS THEY ARE PROCESSED.
;  7/ CURRENT +N,,ADDR FROM USER TABLE. MADE -N,,ADDR AT SAVEB
;  6/ -N,,ADDR FOR A GROUP OF NON-ZERO WORDS, OR WORDS UP TO PAGE END
;  5/ POINTER TO WINDOW PAGE (FTPG1), OFFSET VERSION OF RH OF 6

.SAVE:	JSYS MENTR
	MOVE 10,2		;SAVE DESCRIPTOR
	CALL GTSVI
	HRRI 2,1B20		;WRITE FILE
	OPENF
	JRST ITRAP1
	MOVEI 2,31
	MOVEI 3,2
	MTOPR			; SET BLOCK SPACING TO 2 IF DTA
	TLNE 10,-1		;SOMETHING IN LH?
	JRST SAVE3		;YES, IT'S ONE DESCRIPTOR
SAVE2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SAVE1		;CHECK FOR END OF LIST OF DESCRIPTORS
	CALL SAVEB		;WRITE BLOCK
	AOJA 10,SAVE2

SAVE3:	MOVE 7,10
	CALL SAVEB
SAVE1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;GET ENTRY VECTOR POINTER
	MOVEI 1,0(16)		;JFN
	BOUT			;WRITE ENTRY VECTOR POINTER
SAVER:	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A		;CLEAR TEMP MAPPINGS
	CALL SETMPG
	JRST CLFRET

;SAVE, PROCESS ONE BLOCK
; ARGUMENT IS +N,,ADDR IN 7 . SEE AC USAGE COMMENT ABOVE

SAVEB:	HLRZ 6,7		;MAKE LH COUNT NEGATIVE
	TRZE 6,400000		;LARGER THAN 377777?
	PUSH P,[SAVEBL]		;YES, DO IN TWO PARTS
	MOVNI 6,0(6)
	HRLI 7,0(6)
SAVEB1:	TSTINT
	CALL GETINT
	JUMPGE 7,R		;DONE?
	MOVE 6,7		;SETUP TO SCAN FOR NON-0'S
	LDB 1,[POINT 9,6,26]	;GET PAGE NUMBER
	CAIN 1,0(4)		;DIFFERENT FOR CURRENT MAPPING?
	JRST SAVE3A		;NO, SAME
	MOVEI 4,0(1)
	HRLI 1,0(15)		;FORK HANDLE
	CALL FKHPTN
	PUSH P,1
	CALL MRPACS		;SEE IF PAGE EXISTS
	POP P,2
	TLNN 1,READB		;CAN IT BE READ?
	JRST SAVE3B		;NO, FORGET IT
	MOVE 1,2
	MOVE 2,[XWD RWX,FTPG1A]
	CALL SETMPG		;MAP PAGE
SAVE3A:	CALL GET3A		;SETUP REFERENCE ADDRESS
	JRST SAVE8

SAVE3B:	ANDI 6,777000
	ADDI 6,1000		;TO NEXT PAGE
	SUBI 6,0(7)
	HRLI 6,0(6)		;COUNT OF WORDS SKIPPED IN BOTH HALVES
	ADD 7,6			;UPDATE COUNT AND ADDRESS
	JRST SAVEB1

SAVEBL:	HRLI 7,400000		;DID N-400000 BEFORE, DO LAST 400000 NOW
	JRST SAVEB1

SAVE12:	TRNN 6,777		;NEW PAGE?
	JRST SAVE5		;YES
SAVE8:	SKIPN 0(5)		;NON-0 WORD?
	JRST SAVE6		;NO, GO CHECK FOR MORE
SAVE7:	ADDI 5,1
	AOBJN 6,SAVE12
	MOVE 6,7		;END OF BLOCK. 6/ -N,,ADDR

;WRITE ALL OR PART OF ONE PAGE. ARGS ARE -N,,ADDR IN 6 AND
; OFFSET ADDR IN 5. ALSO -N',,ADDR IN 7.
;VALUES ARE UPDATED 5 AND 7


SAVED:	HLRE 2,6		;COUNT OF WORDS JUST SCANNED
	ADD 5,2			;RESET WINDOW POINTER
	MOVEI 1,0(16)		;JFN
	MOVE 2,6
	SUBI 2,1		;OUTPUT IOWD CNT,ADR
	BOUT
	MOVEI 2,(5)		;FORM BYTE POINTER TO WINDOW
	HRLI 2,444400		; FOR 36 BIT SOUT
	HLRO 3,6		;NEGATIVE COUNT
	SOUT			;OUTPUT THIS BLOCK OF DATA
	HLRO 6,6		;NOW UPDATE THE POINTERS. - NUM WDS SENT
	MOVM 6,6		;POSITIVE NUMBER OF WORDS SENT
	ADDI 5,(6)		;UPDATE POINTER TO WINDOW
	HRLI 6,(6)		;PLUS N IN BOTH HALVES
	ADD 7,6			;UPDATE MAJOR AOBJN CTR. MAY BE SOME LEFT
	RET

;SPECIAL PURPOSE JSYS'S INSTALLED BY ***SRI-AIC***		BEGIN ***SRI-AIC*** TO END OF PAGE

;	NETON JSYS,  TRUNS THE NET ON AND OFF ACCORDING TO THE CONTENTS OF
;	AC1.	AC1=0	==> TURN THE NET OFF
;		AC1=-1	==> TURN THE NET ON
.SETNT:	JSYS MENTR	;USE SLOW CODE
	SETZ 0,		;ASSUME HE WANTS IT OFF
	JUMPE 1,.+3	;DOES HE?
	SETO 0,		;NO, SEE IF HE WANTS IT ON
	AOJN 1,MRETN	;MAYBE, BUT HE DIDN'T SAY IT RIGHT
	MOVEM 0,NETON	;OK, SET IT
	JRST MRETN

;FOUND 0 WORD, CHECK FOR MORE

SAVE6:	MOVEI 2,0(6)
	CAIN 2,0(7)		;FIRST WORD OF BLOCK OR PAGE?
	JRST SAVE9		;YES
	HLRZ 2,6
	SETCMI 3,0(6)
	CAIE 2,-1		;END OF BLOCK, OR
	TRNN 3,777		;END OF PAGE?
	JRST SAVE5		;YES, FINISH BLOCK
	SKIPE 1(5)		;SUCCESSIVE 0?
	JRST SAVE7		;NO, CONTINUE SCAN
SAVE5:	MOVNI 6,0(6)		;COMPUTE NUMBER OF WORD TO DUMP
	ADDI 6,0(7)		;(-CURRENT)+OLD = -DIFFERENCE
	MOVSI 6,0(6)
	HRRI 6,0(7)		;FIRST ADDRESS
	CALL SAVED		;WRITE BLOCK
	JRST SAVEB1

;SCAN OVER BLOCK OF 0'S

SAVE10:	TRNE 6,777		;END OF PAGE?
	SKIPE 0(5)		;OR NON-0 WORD?
	JRST SAVE11		;YES
SAVE9:	ADDI 5,1
	AOBJN 6,SAVE10
SAVE11:	MOVE 7,6		;UPDATE POINTER
	JRST SAVEB1		;RECHECK PAGE, ETC.

;SHARED SAVE

.SSAVE:	JSYS MENTR
	MOVE 10,2		;OUTPUT DESCRIPTOR
	CALL GTSVI
	TLNE 3,777		;DISK?
	JRST SSAVE1		;GOTTA BE
	HRRI 2,1B20		;WRITE
	OPENF
	JRST ITRAP1
	MOVSI 13,2		;START MAPPING INTO FILE PAGE 2
	JUMPL 10,SSAV3		;SINGLE DESCRIPTOR
SSAV2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SSAV1		;DONE
	CALL SSAVB		;OUTPUT THE STUFF
	AOJA 10,SSAV2

SSAV3:	MOVE 7,10
	CALL SSAVB
SSAV1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;PUT ENTRY VECTOR IN FILE
	MOVEI 1,0(16)		;JFN
	BOUT
	HLRZ 2,13		;NEXT FREE PAGE IN FILE
	ASH 2,^D9		;FIRST WORD OF THAT PAGE
	SFPTR			;SET EOF AFTER ALL EXISTING PAGES
	BUG(CHK,<SSAVE - UNEXPECTED BAD RETURN FROM SFPTR>)
	JRST SAVER		;REGULAR FINISH UP

;SAVE PAGES ACCORDING TO AC7, XWD -NPAGES,,ACCESS,FIRST PAGE

SSAVB:	PUSH P,10
	TLC 7,777000		;MAKE SURE COUNT .L. 1000 PAGES
	TLCE 7,777000		;I.E. BITS 0-8 SHOULD BE 0
	ITERR SSAVX2		;LOSE
	HLLZ 13,13		;CLEAR COUNT FOR PAGES IN THIS BLOCK
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG		;CLEAR TEMP PAGE
SSAVB2:	MOVSI 1,0(15)
	HRRI 1,0(7)
	ANDCMI 1,777000		;FLUSH ACCESS BITS FROM HERE
	RPACS			;GET STATE OF THIS MEM PAGE
	JUMPE 2,SSAVB1		;DOESN'T EXIST
	TLNN 2,(1B2)		;READABLE?
	JRST SSAVB1		;NO, SKIP IT
	TRNE 7,1B19		;ACCESS FROM SOURCE PAGE REQUESTED?
	JRST [	TSC 7,2		;YES
		TRZ 7,1B18+RWX+TRAPUB ;MOVE THESE BITS INTO ACCESS WD
		TSC 7,2		;FROM RPACS OF SOURCE PAGE
		TLNE 2,WRITEB+COPYB ;SOURCE HAS SOME KIND OF WRITE?
		TRO 7,1B18	;YES, GIVE WRITE-COPY
		JRST .+1]
	CALL FKHPTN
	MOVE 2,[XWD RWX,FPG2A]
	CALL SETMPG		;SETUPT INDIRECT PTR TO USER PAGE
	MOVSI 1,0(16)		;JFN
	HLR 1,13		;FILE PAGE NUMBER
	PUSH P,13
	CALL JFNOFN
	BUG(HLT,<SSAVE - JFNOFN FAILED>)
	POP P,13
	MOVE 2,[XWD RWX,FPG3A]
	CALL SETMPG		;MAP THE FILE PAGE
	HRLI 2,FPG2A
	BLT 2,FPG3A+777		;COPY USER'S PAGE TO FILE
	HLRZ 2,13		;PAGE IN FILE TO USE
	HRLI 2,0(7)		;MEM PAGE IN LH, FILE PAGE IN RH
	TLZ 2,(1B1+7B7)		;FLUSH UNSPECIFIED BITS
	MOVEM 2,FTPG1A(13)	;SAVE FOR LATER OUTPUT
	AOBJP 13,.+1		;INCREMENT FILE PAGE NUMBER AND COUNT
SSAVB1:	AOBJN 7,SSAVB2		;COUNT MEM PAGES
	MOVEI 2,0(13)		;NUMBER OF FILE PAGES DONE
	JUMPE 2,SSAVB3
	HRLI 2,1000		;TYPE NUMBER
	MOVEI 1,0(16)
	BOUT
	MOVNI 7,0(13)		;GET NEG COUNT FOR THIS BLOCK
	MOVSI 7,0(7)		;SETUP AOBJN WORD
	MOVE 2,FTPG1A(7)	;GET WORD FOR ONE PAGE
	BOUT
	AOBJN 7,.-2
SSAVB3:	SETZ 1,			;CLEAR TEMP PAGE
	MOVEI 2,FTPG1A
	CALL SETMPG
	MOVEI 2,FPG2A
	CALL SETMPG
	MOVEI 2,FPG3A
	CALL SETMPG
	POP P,10
	RET

;OPERATOR FUNCTION CALL JSYS "OPRFN". THIS JSYS EXISTS TO BE
;USED BY THE EXEC OR EPHEMERONS TO DO OPERATOR TASKS, SO THE OP
;DOES NOT NEED TO GET INTO MDDT MOST OF THE TIME.
;
;THE FUNCTIONS ARE CALLED BY SIXBIT NAME, WHICH REQUIRES A TABLE
;SEARCH BUT IS OK BECAUSE THESE FUNCTIONS SHOULD ONLY BE CALLED
;ONCE A DAY OR SO. 
;
;FIELD SITES NOTE -- BBN WILL NEVER ADD ANY SIXBIT NAMES STARTING WITH
;THE LETTER "X". FIELD SITES CAN USE THAT CLASS OF NAMES WITHOUT 
;NEEDING TO WORRY ABOUT CONFLICT WITH FUTURE BBN FUNCTIONS.

;CALL - MOVE 1,[SIXBIT .FUNCTION-NAME.]
;	MOVE 2,ARGUMENT DEPENDENT ON FUNCTION. (MORE IN 3 &4...)
;	OPRFN
;	  FAIL RETURN, ERROR CODE IN 1
;	GOOD RETURN

INTERN .OPRFN

.OPRFN:	JSYS MENTR		;ESTABLISH MONITOR CONTEXT
	MOVSI F,-NOPRFS		;COUNT THRU NAME TABLE
	CAMN A,OPRFTB(F)	;SEARCH. THIS ONE?
	JRST OPRFN1		;YES.
	AOBJN F,.-2		;NO, SEARCH ONWARDS.
	MOVEI A,OPRFX1##	;NOT IN TABLE.
	JRST MRETNE##		;FAIL, NONSKIP, CODE TO LSTERR AND 1

OPRFN1:	HLRZ E,OPRFT2(F)	;SEE WHAT CAPABILITIES ARE NEEDED
	TDNN E,CAPENB		;ARE THEY ON IN THIS FORK?
	JRST CAPX		;NO. FAIL.
	HRRZ E,OPRFT2(F)	;YES. GO DO THE FUNCTION
	PUSHJ P,0(E)		; ..
	  JRST MRETNE		;FAILED. ERROR CODE IN 1
	JRST SKMRTN		;SUCCESS RETURN.

;HERE ARE THE FUNCTIONS DEFINED SO FAR. ARGS TO THE "X" MACRO
; ARE SIXBIT NAME, CAPABILITIES NEEDED, TAG TO CALL.

DEFINE OPRFNS <
IFN PIESLC,<
	X(KFACT,WHEEL+OPER,OPRKFC)>
IFDEF IMPCHN,<
	X(NETON,WHEEL+OPER+MAINT,OPRNTN)>
IFN JTRPSW,<
	X(JTRPON,WHEEL+OPER,OPRJTN)>
	X(ENTFLG,WHEEL+OPER+MAINT,OPRENT)
	X(MKPGSA,WHEEL+OPER+MAINT,OPRMPA)
	X(MKPGSU,WHEEL+OPER+MAINT,OPRMPU)
	X(DDTRCL,WHEEL+OPER,OPRRCD)
	X(DDTFSH,WHEEL+OPER,OPRFSD)
	X(DBUGSW,WHEEL+OPER,OPRBSW)
	X(DCHKSW,WHEEL+OPER,OPRCSW)
	X(USRSPC,WHEEL+OPER,OPRUSP)
	X(SYSSPC,WHEEL+OPER,OPRSSP)
	X(ACTINI,WHEEL+OPER,OPRACT)
	X(XFIFLD,WHEEL+OPER+MAINT,OPRFIF)
;ADD MORE HERE
>

DEFINE X(NAME,CAPS,ROUTIN)<	<SIXBIT \NAME\>>
OPRFTB:	OPRFNS
NOPRFS==.-OPRFTB

DEFINE X(NAME,CAPS,ROUTIN)<	XWD CAPS,ROUTIN>
OPRFT2:	OPRFNS

IFN PIESLC,<

OPRKFC:	FMPRI B,(1.0)		;MAKE SURE IT'S A NORMALIZED FP NUMBER
	CAIL B,0		;AND IN RANGE 0 THRU 1
	CAMLE B,[1.0]
	JRST OPRFXX		;NO GOOD.
	MOVEM B,KFACT##		;OK, SET IT.
	JRST RSKP		;GOOD RETURN.
>
IFDEF IMPCHN,<
OPRNTN:	SKIPE C,B		;SET NETON TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM B,NETON##		;OK, SET IT.
	JRST RSKP
>
OPRENT:	SKIPE C,B		;SET ENTFLG TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT 0 OR -1
	MOVEM B,ENTFLG##	;OK, SET IT.
	JRST RSKP
IFN JTRPSW,<
OPRJTN:	SKIPE C,B		;SET JTRPON TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM B,JTRPON##	;OK, SET IT.
	JRST RSKP
>
OPRRCD:	PUSHJ P,DDTRCL		;RECLAIM DDT
	JRST RSKP

OPRFSD:	PUSHJ P,DDTFSH		;FLUSH DDT
	JRST RSKP

OPRBSW:	CAIL B,0		;SET DEBUGSWITCH TO 0 THRU 2
	CAILE B,2		; ..
	JRST OPRFXX		;BAD VALUE
	MOVEM B,DBUGSW		;OK. SET IT
	JRST RSKP

OPRCSW:	CAIE B,0		;0 OR 1 TO DCHKSW
	CAIN B,1
	JRST OPRCS1		;OK
OPRFXX:	MOVEI A,OPRFX2##		;BAD ARG ERROR CODE
	POPJ P,0		;NON-SKIP RETURN
OPRCS1:	MOVEM B,DCHKSW		;STORE GOOD DCHKSW
	JRST RSKP

OPRMPA:	MOVE A,B		;MOVE ARGUMENTS OVER TO 1 AND 2
	MOVE B,C
	CAMLE A,B		;PAGES IN RIGHT ORDER?
	JRST OPRFXX
	CAMLE A,SWPCOR		;AND IN REASONABLE AREA?
	CAIL B,MAXCOR		; ..
	JRST OPRFXX		;NO
	PUSHJ P,MKPGSA		;PUT PAGES ON LINE
	JRST RSKP

OPRMPU:	MOVE A,B		;PUT PAGES ON LINE
	MOVE B,C
	CAMLE A,B
	JRST OPRFXX
	CAML A,SWPCOR
	CAIL B,MAXCOR
	JRST OPRFXX
	PUSHJ P,MKPGSU
	JRST RSKP
OPRUSP:	JUMPL B,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM B,USRSPC##	;SET USER DISK LIMIT
	JRST RSKP

OPRSSP:	JUMPL B,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM B,SYSSPC##	;SET SYSTEM DISK LIMIT
	JRST RSKP

OPRACT:	CALL ACTIN1		; PUT NEW UACHK.FILE OUT
	 RET				; FAILED
	JRST RSKP			; OK
OPRFIF:	SETOM FIFONL		; REQUEST FIFTEEN RELOAD
	JRST RSKP


;CREATE JOB JSYS -- NOTE SPEC DOES NOT AGREE WITH JSYS MANUALS
;BEFORE 1975.
;
;STORAGE FOR CRJOB
;
NGS JOBONT,NJOBS	;JOB NUMBER WHICH OWNS ANOTHER JOB (IE CREATED 
			; IT), OR -1 IF NOT OWNED.
NGS CRJONJ,1		;DURING THE JSYS, JOB NUMBER CREATING NEW JOB
NGS CRJAC1,1		;AC1 FROM CREATOR TO CREATEE FOR EXEC0
NGS CRJOJC,1		;CAPABILITIES WORD OF CREATOR AT TIME OF JSYS
NGS CRJUSR,10		;NAME STRING WHICH NEW JOB WILL BE LOGGED IN AS.
NGS CRJPSW,10		;PASSWORD FOR LOGIN OF NEW JOB
NGS CRJACT,10		;ACCOUNT FOR LOGIN. IF WORD 0 =0, WD 1 IS 5B2+N
NGS CRJFIL,40		;FILE NAME STRING TO RUN IN NEW JOB.
NGS CRJEVO,1		;OFFSET IN ENT VEC FOR FILE TO RUN
NGS CRJFAC,20		;AC'S TO PUT INTO FORK BEING RUN
NGS CRJTTY,1		;TTY NUMBER FOR NEW JOB, OR -1 IF TO BE DETACHED
IFN PIESLC,<
NGS CRJPIE,1>		;PIE GROUP NAME - UNTIL ACCT DOES IT

;CALLING SEQUENCE:
;	MOVE 1,FLAG BITS
;	MOVEI 2,ADDR OF ARGUMENT BLOCK
;	CRJOB
;	  FAIL, ERROR IN AC1
;	SUCCESS
;
;BITS IN AC1:
;B0: ON MEANS LOG THE NEW JOB IN
;B1: ON MEANS USE THE NAME AND PASSWORD IN ARGUMENT BLOCK
;    OFF MEANS LOG IN SAME AS JOB EXECUTING CRJOB
;B2: ON MEANS USE ACCOUNT IN ARGUMENT BLOCK
;    OFF MEANS USE CURRENT ACCT OF JOB EXECUTING CRJOB
;B3: ON MEANS RUN THE FILE WHOSE NAME IS SPECIFIED IN ARG BLOCK
;    ELSE JUST PUT IN AN EXEC
;B4: PUT AN EXEC IN ABOVE THE SPECIFIED FILE 
;B5: IF FILE IS TO BE RUN, SET ITS AC'S AS IN ARG BLK
;B6: DISOWN THE NEW JOB
;
;IN ARG BLOCK:
;WD 0: LH - ADDR OF NAME STRING (ASCIZ)
;      RH - SAME FOR PASSWORD STRING (ASCIZ)
;WD 1: 5B2+N FOR NUMERIC ACCOUNT, ELSE 0,,ADDR OF STRING ACCT
;WD 2: LH OFFSET FOR SFRKV FOR FORK TO RUN
;      RH ADDR OF FILE'S NAME STRING TO BE RUN
;WD 3: TERMINAL DESIGNATOR FOR JOB'S CONTROLLING TTY, OR 377777
;      FOR A DETACHED JOB
;WD 4: CPU LIMIT FOR NEW JOB BEFORE FORCED LOGOUT (NOT YET IMPL)
;WD 5: CONNECT TIME LIMIT FOR NEW JOB BEFORE FORCED LOGOUT (NOT YET IMP)
;WDS 6-25 AC'S TO BE STUFFED INTO FORK BEFORE STARTING IT


INTERN .CRJOB

.CRJOB:	JRST UJSYS##		;THIS CODE IS NOT YET SUPPORTED IN 1.33
	JSYS MENTR		;ENTER NORMAL MONITOR CONTEXT
CRJOB1:	NOINT			;DON'T INTERRUPT OF OF CRJLCK RESOURCE
	LOCK (CRJLCK##,<JRST CRJLKF>)
	SETZM CRJANS##		;CLEAR RESULT WORD
	MOVE A,JOBNO		;STORE MY JOB NUMBER
	MOVEM A,CRJONJ		;IN COMMON STORAGE
	MOVE A,CAPENB		;AND MY CURRENT CAPABILITIES
	MOVEM A,CRJOJC		; ..
	UMOVE 10,1		;JSYS REQUEST BITS
	MOVEM 10,CRJAC1		; ..
	TRNN A,WHEEL+OPER	;IS IT A WHEEL OR OPER?
	TLNE 10,(1B0+1B4)	;NO. MUST HAVE LOGIN OR EXEC BITS ON
	SKIPA			;OK
	JRST CRJILG		;ILLEGAL REQUEST.
	UMOVE 7,2		;POINTER TO PARAMETER BLOCK
	SETOM CRJTTY		;ASSUME DETACHED NEW JOB
	UMOVE A,3(7)		;SEE WHAT TTY HE WANTS THIS ON
	CAIN A,377777		;NIL?
	JRST CRJB1A		;YES. OK.
	CAIL A,400000		;RANGE CHECK
	CAIL A,400000+NLINES	; ..
	JRST CRJTTX		;NOT A GOOD TTY NUMBER
	SUBI A,400000		;OK, SEE IF HE CAN HAVE IT
	NOSKED			;STABLE STATE OF TTFORK
	HLRZ B,TTFORK(A)	;WHO OWNS IT?
	CAMN B,JOBNO		;ME?
	CAMN A,CTRLTT		;OK. MUST ALSO NOT BE MY CTTY ALREADY
CRJOTX:	JRST [OKSKED		;NOT MINE, OR IS CTTY
		JRST CRJTTX]	; ..
	TRO A,400000		;SEE IF IT'S ASSIGNED TO ME
	PUSHJ P,CHKDEV##	; ..
	  JRST CRJOTX		;SHOULDN'T HAVE FAILED HERE...
	TLNN C,(1B6)		;ASSIGNED (TO ME)?
	JRST CRJOTX		;NO.
	UMOVE 10,1		;RESTORE AC'S
	UMOVE 7,2
	UMOVE A,3(7)		;AND THE SPECIFIED TTY NUMBER
	ANDI A,377777
	MOVEM A,CRJTTY		;STORE THE TTY TO START JOB ON
	OKSKED
	TRO A,400000
	RELD			;RELEASE THE TTY
	  JFCL

CRJB1A:	JUMPGE 10,CRJOB4	;IF NOT LOGGING IN, SKIP NAME, PSWD
	TLNN 10,(1B1)		;USE SUPPLIED, OR MINE?
	JRST CRJOB2		;MINE.
	UMOVE B,0(7)		;SUPPLIED. GET NAME STRING
	HLRZ B,B		;FROM USER SPACE
	HRLI B,440700		;AND IS AN ASCIZ STRING
	MOVEI A,CRJUSR-1	;WHERE TO STORE IT
	PUSHJ P,CPYFU1##	;COPY IT.
	  JRST CRJCPX		;COPY FAILED
	UMOVE B,0(7)		;NOW SAME FOR PASSWORD
	HRLI B,440700		; ..
	MOVEI A,CRJPSW		;STORE PASSWORD HERE
	PUSHJ P,CPYFU1
	  JRST CRJCPX		;COPY FAILED
	JRST CRJOB4		;GO GET AN ACCOUNT NUMBER/STRING

;HERE'S THE FAIL PATH ON LOCK MACRO ABOVE...
CRJLKF:	OKINT
	MOVEI 1,CRJLCK
	PUSHJ P,DISL		;WAIT, INTERRUPTABLE, FOR LOCK.
	JRST CRJOB1		;TRY TO GET IT AGAIN.

;HERE TO COPY MY OWN NAME AND PASSWORD FOR NEW JOB
;ACTUALLY, JUST PUT NAME IN, CAUSE LOGIN JSYS TO NOT CHECK PSWD
CRJOB2:	MOVE A,JOBNO
	HRRZ A,JOBDIR(A)	;HERE IS MY IDENTITY
	MOVEM A,CRJUSR		;EXEC0 WILL TAKE IT FROM HERE.

;NOW GET ACCOUNT FOR NEW JOB
CRJOB4:
IFN PIESLC,<;TEMP TIL ACCOUNT DOES PIE GROUP RIGHT
	MOVE A,JOBNO
	MOVE A,PIEGRP##(A)
	IMULI A,NWDGRP
	MOVE A,GRPNM(A)
	MOVEM A,CRJPIE>
	SETZM CRJACT		;IN CASE WANTED 0 FOR NUMERIC FLAG
	TLNE 10,(1B2)		;USE CURRENT ACCOUNT, OR SUPPLIED.
	JRST CRJOB5		;SUPPLIED.
	SKIPL A,ACCTPT		;LOGGED IN NUMERICALLY?
	JRST CRJB4A		;NO. GO GET STRING
	MOVEM A,CRJACT+1	;YES. STORE IT HERE
	JRST CRJB5Z		;DONE ACCOUNT
;GET STRING ACCOUNT FOR CURRENT JOB
CRJB4A:	MOVE A,[XWD ACCTSR,CRJACT]
	BLT A,CRJACT+7		;COPY THE ACCOUNT STRING
	JRST CRJB5Z		;DONE ACCOUNT.
;HERE IF ACCOUNT WAS SUPPLIED BY USER IN ARG BLOCK
CRJOB5:	UMOVE B,1(7)		;GET THE ACCOUNT NUMBER OR POINTER
	MOVE A,B
	TLC A,(5B2)		;SEE IF NUMERIC OR STRING
	TLNE A,(7B2)		; ..
	JRST CRJB5A		;STRING
	MOVEM B,CRJACT+1	;STORE NUMERIC ACCOUNT
	JRST CRJB5Z		;DONE ACCOUNT
CRJB5A:	HRLI B,440700		;STRING POINTER
	MOVEI A,CRJACT-1	;WHERE IT GOES
	PUSHJ P,CPYFU1		;COPY IT.
	  JRST CRJCPX		;COPY FAILED?
CRJB5Z:				;DONE PUTTING ACCOUNT INTO SWAPPABLE STG
	SETZM CRJEVO		;ASSUME NO FILE TO RUN
	TLNN 10,(1B3)		;WANT TO RUN A FILE?
	JRST CRJB5Y		;NO
	MOVEI A,CRJFIL-1	;YES. STORE THE FILE NAME HERE
	UMOVE B,2(7)		;GET THE NAME FROM HERE
	TLZ B,777000		;9 BITS OF ENT VEC OFFSET
	HLRM B,CRJEVO		;TO SHARED STORAGE
	HRLI B,440700		;MAKE A BYTE POINTER TO NAME
	MOVEI C,<5*40>-1	;MAX STRING LENGTH
	PUSHJ P,CPYFU2##	;COPY THE STRING
	  JRST CRJCPX		;COPY FAILED
	TLNN 10,(1B5)		;SET THE AC'S?
	JRST CRJB5C		;NO
	MOVSI B,6(7)		;YES, HERE'S WHERE THEY ARE IN CALLER
	HRRI B,CRJFAC		;AND HERE THE COMMON TEMP AREA FOR THEM
	XCTUM [BLT B,CRJFAC+17]	;COPY THEM, USER TO MONITOR SPACE.
CRJB5C:
CRJB5Y:	;END OF CODE DEALING WITH INFERIOR TO RUN

;HERE TO ACTUALLY PUT IN THE REQUEST FOR SCHEDULER TO START JOB

	MOVSI A,-2		;FLAG OF -2 FOR JOBSRT MEANS CRJOB CALL
	HRRI A,JOBSRT##		;SCHEDULER JOB START ROUTINE
	CALL SCDRQ7##		;CALL IT
	MOVEI A,CRJANS		;AND WAIT FOR ANSWER TO COME BACK
	CALL DISN##		; ..
	MOVE A,CRJANS		;WHEN IT DOES, IT'S A -1 FOR
	JUMPGE A,CRJXXX		;SUCCESS, OR +N FOR AN ERROR CODE.
	HLRZ A,CRJONJ		;NEW JOB NUMBER IS IN LH HERE
	UMOVEM A,1		;RETURN IT TO CALLER
	UNLOCK CRJLCK		;RELEASE THE JSYS LOCK
	JRST SKMRTN		;AND RETURN TO CALLER

CRJCPX:				;COPY OF USER STUFF FAILED.
CRJILG:	MOVEI A,CRJBX1##	;ILLEGAL PARAMETER OR BIT COMBINATION
	JRST CRJXXX
CRJTTX:	MOVEI A,CRJBX4##	;BAD TTY REQUESTED
CRJXXX:	UNLOCK CRJLCK		;FREE THE CREATE-JOB LOCK
	OKINT
	JRST MRETNE		;RETURN ERROR NUMBER IN 1

;END OF SWPMON MODULE

;		LOCK SWPMON PAGE FOR PATCHING

LOCKPG:	ANDI	1,777		;FORCE PAGE TO BE WITHIN LIMITS
	HRLZI	2,40000		;LOCK BIT
	IORM	2,MMAP(1)	;LOCK PAGE
	RET

;		UNLOCK SWPMON PAGE

UNLKPG:	ANDI	1,777		;FORCE PAGE TO BE WITHIN LIMITS
	HRLZI	2,40000		;LOCK BIT
	ANDCAM	2,MMAP(1)	;UNLOCK PAGE
	RET
	END

