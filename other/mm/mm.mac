TITLE MM
SUBTTL Assembly switches

SEARCH MONSYM
IFNDEF .OSFAIL,<SALL>			;Clean MACRO listings

;Version # stuff

VWHO==0
VMIN==6
VMAJ==1
VEDIT==^D247

;;;Assembly flags

;Switches controlling site-dependent stuff

IFNDEF CLSCSW,<CLSCSW==0>		;College of Science, Utah
 IFN CLSCSW,<CLSCSW==1>
IFNDEF COLSW,<COLSW==0>			;COLUMBIA
 IFN COLSW,<COLSW==1>
IFNDEF DREASW,<DREASW==0>		;DREA-20
 IFN DREASW,<DREASW==1>
IFNDEF HPSW,<HPSW==0>			;Hewlett-Packard
 IFN HPSW,<HPSW==1>
IFNDEF ISISW,<ISISW==0>			;USC-ISI
 IFN ISISW,<ISISW==1>
IFNDEF MITSW,<MITSW==0>			;Any MIT site
 IFN MITSW,<MITSW==1>
IFNDEF RUTGSW,<RUTGSW==0>		;RUTGERS-20
 IFN RUTGSW,<RUTGSW==1>
IFNDEF SRISW,<SRISW==0>			;SRI-KL
 IFN SRISW,<SRISW==1>
IFNDEF STANSW,<STANSW==0>		;Any Stanford (see below)
 IFN STANSW,<STANSW==1>
IFNDEF UTAHSW,<UTAHSW==0>               ;UTAH-20
 IFN UTAHSW,<UTAHSW==1>

;Stanford sites

IFNDEF GSBSW,<GSBSW==0>			;Stanford GSB
 IFN GSBSW,<GSBSW==1>
IFDEF LOTSW,<LOTSSW==LOTSW>		;Standard name for LOTS switch
IFNDEF LOTSSW,<LOTSSW==0>		;Stanford LOTS
 IFN LOTSSW,<LOTSSW==1>
IFNDEF SCORSW,<SCORSW==0>		;Stanford SCORE
 IFN SCORSW,<SCORSW==1>
IFNDEF SUMXSW,<SUMXSW==0>		;Stanford SUMEX 2020
 IFN SUMXSW,<SUMXSW==1>
IFN <GSBSW+LOTSSW+SCORSW+SUMXSW>,<STANSW==1>

;MIT sites

IFNDEF XXSW,<XXSW==0>			;MIT-XX
 IFN XXSW,<XXSW==1>
IFNDEF SPCHSW,<SPCHSW==0>		;SPEECH-TWENEX
 IFN SPCHSW,<SPCHSW==1>
IFN <XXSW+SPCHSW>,<MITSW==1>

;All other sites default to "virgin DEC"

IFNDEF DECSW,<DECSW==1-<CLSCSW!COLSW!DREASW!HPSW!ISISW!MITSW!RUTGSW!SRISW!STANSW!UTAHSW>>
IFN DECSW,<DECSW==1>

;MM feature switches

IFNDEF REL4F,<REL4F==CLSCSW!COLSW!DECSW!GSBSW!SCORSW!UTAHSW>
					;Tops-20 Release 4
IFNDEF ARPAF,<ARPAF==<DECSW!ISISW!XXSW!RUTGSW!SRISW!SCORSW!UTAHSW>>
					;Include Arpanet-only code
IFNDEF NEWQF,<NEWQF==MITSW!STANSW>	;New network mailer
IFNDEF HOST2F,<HOST2F==RUTGSW!STANSW!NEWQF>
					;Use HOSTS2.BIN host table
	;Note: if HOST2F is set SYSTEM:HOSTS2.BIN must exist for MM to work
IFNDEF IPCFF,<IPCFF==CLSCSW!COLSW!DECSW!DREASW!RUTGSW!STANSW>
					;Use IPCF MAILER for local mail
IFNDEF SIPCFF,<SIPCFF==CLSCSW!COLSW!DREASW!RUTGSW!STANSW>
					;Special IPCF MAILER interface
	;At Columbia, Rutgers and DREA only a Date and From line
	;are generated by the IPCF MAILER when FL%MM is set.
	;At Stanford FL%MM suppresses all IPCF MAILER-generated headers.
IFNDEF DECNF,<DECNF==DECSW>		;Include DECNET code
	;Note: DECNF is a no-op if this system has an Arpanet.  Also it doesn't
	;work with HOST2F.
IFNDEF NETPRV,<NETPRV==RUTGSW>		;Use of Arpanet is a privilege, must
					; run MAILER enabled
IFNDEF VTPRMT,<VTPRMT==1-<MITSW!SRISW!<STANSW-LOTSSW>>>
					;Verbose prompt for message text
	;Everybody except for MIT, SRI, and Stanford.
IFNDEF NMSGS,<NMSGS==2000>		;Number of messages we can handle
IFNDEF PAGE0,<PAGE0==40>		;First free page

;Check for obvious lossage in switch settings

IFNDEF .OSFAIL,<			;Tell MACRO what .FATAL means
 DEFINE .FATAL(MSG)<
  PASS2
  PRINTX ?MSG
  END
 >;DEFINE .FATAL
>;IFNDEF .OSFAIL

IFN 1-<CLSCSW+COLSW+DECSW+DREASW+HPSW+ISISW+MITSW+RUTGSW+SRISW+STANSW+UTAHSW>,<
	.FATAL Site conflicts>
IFN MITSW-<SPCHSW+XXSW>,<
	.FATAL MIT site conflicts>
IFN STANSW-<GSBSW+LOTSSW+SCORSW+SUMXSW>,<
	.FATAL Stanford site conflicts>
IFN HOST2F,<IFN DECNF,<.FATAL HOST2F and DECNF are mutually incompatable>>
IFN NEWQF,<IFE HOST2F,<.FATAL HOST2F must be set if NEWQF>>

SUBTTL Macros

;;;This should be everything that depends on one dialect or another of
;;;the assembler

;;;Stuff for FAIL

IFDEF .OSFAIL,<

;Define useful conditionals
FOR @' MAC IN (CLSC,COL,DEC,DREA,HP,ISI,MIT,RUTG,SRI,STAN,UTAH,LOTS,GSB,SCOR,SUMX,XX,SPCH)
   <	DEFINE MAC,<IFN MAC'SW>
	DEFINE NO'MAC,<IFE MAC'SW>
   >

DEFINE DEFPAG (ADDR,LENGTH)
   <	ADDR__PAGEN*1000
	IFIDN <LENGTH>,<>,<PAGEN==PAGEN+1>
	IFDIF <LENGTH>,<>,<PAGEN==PAGEN+LENGTH>
   >

DEFINE FLDDB. (TYP,FLGS,DATA,HLPM,DEFM,LST,MSK) <
    ..XX==0
    IFDIF <FLGS>,<>,<..XX==FLGS>
    ..XX==<TYP>*1B8+..XX
    IFDIF <HLPM>,<>,<..XX_CM%HPP!..XX>
    IFDIF <DEFM>,<>,<..XX_CM%DPP!..XX>
  REL4,<
    IFDIF <MSK>,<>,<..XX_CM%BRK!..XX>
       >;REL4
    IFDIF <LST>,<>,<..XX+LST>
    IFIDN <LST>,<>,<..XX>
    IFDIF <DATA>,<>,<DATA>
    IFIDN <DATA>,<>,<0>
    IFDIF <HLPM>,<>,<HLPM>
    IFIDN <HLPM>,<>,<0>
    IFDIF <DEFM>,<>,<DEFM>
    IFIDN <DEFM>,<>,<0>
  REL4,<
    IFDIF <MSK>,<>,<MSK>
       >;REL4
>
>;FAIL

;;;Stuff for MACRO-10

IFNDEF .OSFAIL,<

DEFINE DEFSIT(MAC) <
    IRP MAC,<
	DEFINE MAC,<IFN MAC'SW>
	DEFINE NO'MAC,<IFE MAC'SW>
>>

DEFSIT (<CLSC,COL,DEC,DREA,HP,ISI,MIT,RUTG,SRI,STAN,UTAH,LOTS,GSB,SCOR,SUMX,XX,SPCH>)

DEFINE DEFPAG (ADDR,LENGTH)
   <	ADDR==PAGEN*1000
	IFIDN <LENGTH>,<>,<PAGEN==PAGEN+1>
	IFDIF <LENGTH>,<>,<PAGEN==PAGEN+LENGTH>
   >

DEFINE POS(MASK)<<^L<<MASK>&<-<MASK>>>>>
DEFINE FLD(VAL,MSK)<<VAL>B<POS(MSK)>>
DEFINE FLDDB. (TYP,FLGS,DATA,HLPM,DEFM,LST,MSK) <
	..XX==<FLD(TYP,CM%FNC)>+FLGS+<Z LST>
	IFNB <HLPM>,<..XX==CM%HPP!..XX>
	IFNB <DEFM>,<..XX==CM%DPP!..XX>
REL4,<
	IFNB <MSK>,<..XX==CM%BRK!..XX>
>;REL4
	..XX
	IFNB <DATA>,<DATA>
	IFB <DATA>,<0>
	IFNB <HLPM>,<HLPM>
	IFB <HLPM>,<0>
	IFNB <DEFM>,<DEFM>
	IFB <DEFM>,<0>
REL4,<
	IFNB <MSK>,<MSK>
>;REL4
>
>;MACRO

;;;Assembler independant macros

DEFINE REL4,<IFN REL4F>
DEFINE NOREL4,<IFE REL4F>
DEFINE ARPA,<IFN ARPAF>
DEFINE NOARPA,<IFE ARPAF>
DEFINE IPCF,<IFN IPCFF>
DEFINE NOIPCF,<IFE IPCFF>
DEFINE SIPCF,<IFN SIPCFF>
DEFINE NOSIPCF,<IFE SIPCFF>
DEFINE DECN,<IFN DECNF>
DEFINE NODECN,<IFE DECNF>
DEFINE HOSTS2,<IFN HOST2F>
DEFINE NOHST2,<IFE HOST2F>
DEFINE NEWQ,<IFN NEWQF>
DEFINE NONEWQ,<IFE NEWQF>

DEFINE CTL(CHAR) <"CHAR"-100>		;Useful for defining control characters

DEFINE DEFERR (X,Y)
   <	DEFINE X (Z)
	   <	IFIDN <Z>,<>,<UERR Y,0>
		IFDIF <Z>,<>,<UERR Y,[ASCIZ /Z/]>
	   >
   >

DEFINE	CMD ' (X,Y,Z) <
    IFIDN <Z>,<>,<
	IFIDN <Y>,<>,<[ASCIZ \X\],,.'X>
	IFDIF <Y>,<>,<[ASCIZ \X\],,Y>
    >
    IFDIF <Z>,<>,<
	IFIDN <Y>,<>,<[	Z
			ASCIZ \X\],,.'X>
	IFDIF <Y>,<>,<[	Z
			ASCIZ \X\],,Y>
    >
>

DEFINE	CMD1 (X,Y,Z) <
   IFIDN <Z>,<>,<CMD (X,Y,<CM%FW>)>
   IFDIF <Z>,<>,<CMD (X,Y,<CM%FW!Z>)>
>

DEFINE VAR (X,Y,Z)
   <	[ASCIZ /X/],,[Z,,Y]
   >

DEFINE HDY (X,Y,Z)
   <	RADIX 5+5
	[ASCIZ /X/],,[<Y-1>*512+<Z-1>,,DATHDY]
	RADIX 8
   >

DEFINE TYPE (X)
   <	UTYPE [ASCIZ /X/]
   >
DEFINE CTYPE (X)
   <	UTYPE 10,[ASCIZ /X/]
   >
DEFINE CITYPE (X)
   <	UTYPE 1,[ASCIZ /X/]
   >

DEFINE ETYPE (X)
   <	UETYPE [ASCIZ /X/]
   >
DEFINE CETYPE (X)
   <	UETYPE 10,[ASCIZ /X/]
   >
DEFINE CIETYP (X)
   <	UETYPE 1,[ASCIZ /X/]
   >

DEFINE NOISE (X)
   <	UNOI [ASCIZ /X/]
   >

DEFINE DEFALT (X,Y)
   <	UDEF [ASCIZ /X/]
   >

DEFINE PROMPT (X)
   <	UPRMT [ASCIZ /X/]
   >

DEFINE CONFRM
   <	CALL CONF
   >

DEFERR WARN,3
DEFERR JWARN,7
DEFERR CERR,10
DEFERR JCERR,14
DEFERR ERROR,11
DEFERR JERROR,15
DEFERR FATAL,12
DEFERR JFATAL,16

SUBTTL Definitions

;;;AC's

F=0					;Flags
A=1					;Temp and JSYS
B=2					;Ditto
C=3					;Ditto
D=4					;Ditto
E=5					;Temp & local to routine
T=6					;Ditto
U=7					;Ditto
V=10					;Ditto 
W=11					;Ditto
L=12
M=13					;Current message if any
N=14
O=15
X=16
P=17

;;;Opdef's

OPDEF CALL [PUSHJ P,0]
OPDEF RET [POPJ P,0]
OPDEF PRINT [1B8]
OPDEF UTYPE [2B8]
OPDEF UETYPE [3B8]
OPDEF UERR [4B8]
OPDEF UNOI [5B8]
OPDEF UDEF [6B8]
OPDEF UPRMT [7B8]
OPDEF GTBLT [JSYS 634]

;;;Flags

F%F1==1B0				;Temp
F%F2==1B1
F%F3==1B2
F%F4==1B3
F%F5==1B4
F%AT==1B5				;@ see in address
F%ADR==1B6				;Seen non-blank part of an address
F%QOT==1B7				;Inside a quoted string
F%STAD==1B8				;Inside structured address
F%CC==1B9				;In CC command
F%COMA==1B10				;Type comma except before 1st field
F%TYPS==1B11				;Type out numbers of messages handled
NEWQ,<
F%NEWQ==1B12				;Generate quoted host names
>;NEWQ

F%READ==1B18				;Inside the READ command
F%SEND==1B19				;Inside the SEND commands
F%RSCN==1B20				;Called by command line
F%MOD==1B21				;Reading system mail
F%AMOD==1B22				;Auto MOD handling
F%TECO==1B23				;Using TECO based editor
F%RONL==1B24				;Read only file
F%RPLY==1B25				;Inside a reply to this message
F%ESND==1B26				;Editor said send it off
F%TECP==1B27				;Editor supports hairy TECO interface
F%DIRE==1B28				;In message dired mode
F%HOER==1B29				;Halt on error
F%RPTO==1B30				;Processed a Reply-To
DECN,<
F%DECN==1B35				;Have DECNET
>;DECN

ESC==33					;ESCAPE key
EOL==37					;Newline for PRINT UUO

IPCF,<
NACK1==2				;Total wipeout by MAILER
SIPCF,<
FL%MM==1B0				;Don't generate headers, we will
>;SIPCF
>;IPCF

HOSTS2,<
;The format of the compiled HOSTS2 file is:

HSTSID==0	; wd 0	SIXBIT /HOSTS2/
NAMPTR==10	; wd 10 Address in file of NAME table.
SITPTR==11	; wd 11	Address in file of SITE table.
NETPTR==12	; wd 12 Address in file of NETWORK table.

;NETWORK table
; wd 0	Number of entries in table.
; wd 1	Number of words per entry. (2)
NETNUM==0	; wd 0	network number
NTLNAM==1	; wd 1 LH - address in file of name of network
NTRTAB==1	; wd 1 RH - address in file of network's address table

;ADDRESS table(s)
; wd 0	Number of entries in table.
; wd 1	Number of words per entry. (2)
ADDADR==0	; wd 0	Network address of this entry including network number
ADLSIT==1	; wd 1 LH - address in file of SITE table entry
ADRCDR==1	; wd 1 RH - address in file of next ADDRESS entry for this site
		;	    0 = end of list

;SITE table
; wd 0	Number of entries in table.
; wd 1	Number of words per entry. (3)
STLNAM==0	; wd 0 LH - address in file of official host name
STRADR==0	; wd 0 RH - address in file of first ADDRESS table entry for
		;	    this site.  Successive entries are threaded
		;	    together through ADRCDR.

;NAMES table:
; wd 0	Number of entries
; wd 1	Number of words per entry. (1)
NMLSIT==0	; lh	address in file of SITE table entry for this host.
NMRNAM==0	; rh	address in file of host name

; All names are ASCIZ strings, all letters upper case.
; The strings are stored before, after and between the tables.
; All strings are word-aligned, and fully zero-filled in the last word.

;Network addresses are defined as follows, for purposes of this table:
;    4.9     0
;    4.8-4.1 network number
;    Chaos net (number 7):
;	3.9-2.8	0
;	2.7-1.1 address (2.7-1.9 subnet, 1.8-1.1 host)
;    Arpanet (number 12):	(note, old-format Arpanet addresses
;	3.9-3.8	0	 	never appear in the host table.)
;	3.7-2.1	IMP
;	1.9	0
;	1.8-1.1	Host
;    Dialnet (number 26):
;	3.9-3.1	0
;	2.9-1.1	address in file of ASCIZ string of phone number

NW%CHS==7	;Chaos net
NW%ARP==12	;Arpanet
NW%DLN==26	;Dialnet
>;HOSTS2

LOC 41
	CALL UUOH			;UUO handler
RELOC

SUBTTL Page allocation

PAGEN==PAGE0				;Start allocating there

DEFPAG HDRPAG				;Headers
DEFPAG TXTPAG,100			;Message text page
DEFPAG TOPAG,10				;Storage for TO/CC lists
DEFPAG FWDPAG				;Page for mapping to MAILBOX program
NOHST2,<
DEFPAG HSTNAM,2				;Host names
DEFPAG HOSTN				;Host numbers
DEFPAG HOSTAB				;Pointers to above
>;NOHSTS2
HOSTS2,<
DEFPAG HSTPAG,10			;Place to map HOSTS2.BIN
>;HOSTS2
DEFPAG FLGPAG				;For MAILER.FLAGS
DEFPAG EDBPAG				;Editor buffer block page
DEFPAG EDPAGE,20			;Editor pages for data
DEFPAG WRTPGS,2				;Map file for write to update
DEFPAG KEYPAG				;Page full of keyword names
DEFPAG USRHDR				;Page for user generated headers

MSGLEN==11				;Length of block
DEFPAG MSGPGS,<NMSGS/1000*MSGLEN>	;Storage for message data

MSGALL==MSGPGS+0			;Starting byte of message
MSGSAL==MSGPGS+1			;Size of whole message
MSGBOD==MSGPGS+2			;Size of message body,,starting byte
MSGFRM==MSGPGS+3			;Size of from field,,starting byte
MSGSUB==MSGPGS+4			;Size of subject,,starting byte offset
MSGDAT==MSGPGS+5			;Date of message
MSGFLG==MSGPGS+6
 MSGHLN==MSGFLG				;Length of the message header portions
MSGBTS==MSGPGS+7			;Msg bits
MSGFBS==MSGPGS+10			;Bits in file

M%SEEN==1				;Message has been seen
M%DELE==2				;Message is deleted
M%ATTN==4				;Message wants attention (always-show)
M%RPLY==10				;Message has been replied to

M%RECE==1B0				;Message is recent (sign bit)
M%FRME==1B1				;Message is from me
M%FRNM==1B2				;Messages is from someone else

MSGPAG==PAGEN				;Start of file mapping area

SUBTTL Impure storage

;;;User variables

TOPRMT:	ASCIZ /MM>/
	BLOCK 7
REPRMT:	ASCIZ /R>/
	BLOCK 7
SEPRMT:	ASCIZ /S>/
	BLOCK 7
RINCME:	0				;Include me in any replies by default
RFMDEF:	-1				;Reply<cr> means just from, not all
RCCOTH:	0				;Reply cc's everyone other than from
GTCNDR:	0				;>0 conn dir always, <0 login, 0 ask
BLSCST:	-1				;Blank screen on startup
BLNKER:	0				;-1 if an error occurred so no blank
ESCSND:	DEC,<-1> NODEC,<0>		;Escape sends automatically
REPDIS:	0				;Reply command automatically displays
SNDVBS:	1				;Degree of sending verbosity
HDR733:	-1				;Personal Name <User at SITE> style
ABOFLG:	0				;^N aborts >0 always, 0 ask, <0 never
CMIMWK:	0				;Non-zero means CM%WKF on commands
LSTPAG:	0				;List messages on separate pages
LSTHDR:	-1				;Output a list of headers at the start of the listing
SAVFIL:	BLOCK 10			;SAVED.MESSAGES file to use
EDITOR:					;Editor name
NOCLSC,<ASCII /EMACS/>
CLSC,<	ASCII /SEDIT/>
	BLOCK 7

PERNAM:	BLOCK 10			;Personal name
DEFCCL:	BLOCK 20			;Default cc list
DEFPRO:	BLOCK 1				;Default protection for .TXT files
DEFPST:	BLOCK 2				;String version of above

CMDRET:	JRST CMDRES			;Usual return dispatch for error
ZERMEM==.				;Start clearing here at startup
SNDCAL:	0				;Caller of send subcommands
OKTINT:	0				;Is it ok for timer to interrupt now?
CHKTIM:	0				;Next time to check for new messages
MSGJFN:	0				;JFN for current message file
MSGJF2:	0				;JFN to open for write
OUTJFN:	0				;Output file JFN
TMPJFN:	0				;Init file and stuff like that
TTYPE:	0				;Terminal type
SAVMOD:	BLOCK 5				;Normal tty modes
EDMOD:	BLOCK 5				;Editor modes
LASTM:	0				;Number of messages in current file
FILPGS:	0				;Size of the file in pages
FILSIZ:	0				;Size of the file (bytes)
FILCRV:	0				;Creation date
FILWRT:	0				;Write date
LASTRD:	0				;Last read date of file
NRECNT:	0				;Number of recent messages
NUNSEE:	0				;Number of unseen messages
NDELET:	0				;Number of deleted messages
PRIORM:	0				;Saved current message number
LSTMSG:	0				;Saved last message for typing out seq
DOMSG:	0				;Dispatch to process next message
NXTMSD:	0				;Dispatch to fetch next message
RPVSAV:	0				;Saved state for read mode prev command
LHOSTN:	0				;Local host number, -1 if not Arpanet
HOSTS2,<
LHOSTP:	0				;Local host pointer
>;HOSTS2
PSIPC1:	0				;Saved pc from psi routine
PSIPC2:	0				;Ditto
EXECFK:	0				;Saved fork handle for EXEC
EDFORK:	0				;Editor fork
EFRKPC:	0				;Editor fork's PC
EDPAG0:	0				;First page of editor fork mapped in
TOLIST:	0				;TO list pointers tail,,head
CCLIST:	0				;CC list pointers tail,,head
BCCLST:	0				;BCC list
FREETO:	0				;Pointer to free space for to/cc lists
LCLIST:	0				;List of local recipients
FILIST:	0				;List of file "recipients"
NETLST:	0				;List of network recipients
DSTLST:	0				;List of distribution lists, not really used
MSGSIZ:	0				;Size of last message we sent
MOVDSP:	0				;Dispatch for typing or setting to, etc
REPDAT:	0				;Reply date
SAVU:	0				;Used by address parser
SAVL:	0				;Saved sequence pointer
NXTIME:	0				;Time for before/after/on filters
CLEVEL:	0				;Command/subcommand level
TPADD1:	0				;Top level command dispatch
TPADDR:	0				;Reparse address for COMND reparsing
LSTCHR:	0				;Confirming character
BUFNAM:	BLOCK 2				;Name of the editor buffer
EDINAM:	BLOCK 2				;Type of edit being performed
HSTPTR:	0				;Pointer to host table
PRGNAM:	BLOCK 2				;Save area for subsystem/program names
UNTHDR:	0				;Save of unto header word
KEYPTR:	0				;Pointer to keyword string area
KEYBTS:	0				;Bit masks for keywords
RMLPTR:	0				;String pointer and flag for REMAIL
ZEREND==.-1				;End of where to clear

KEYTBL:	BLOCK 23			;Table of keywords for messages
USRHTB:	BLOCK 23			;Table of user message headers
SPRHDR:	BLOCK 23			;Table of headers to not type out
ONLHDR:	BLOCK 23			;Table of headers to only type out
UUOACS:	BLOCK 20			;AC's during LUUO call
INTACS:	BLOCK 20			;During timer interrupt routines
FRKACS:	BLOCK 20			;Setup for editor fork's ac's

NPDL==177				;Size of PDL
PDL:	BLOCK NPDL			;Pushdown list

CSBFSZ==1000
CSBUF:	BLOCK CSBFSZ			;Command line buffer
PATSTR==CSBUF+CSBFSZ/2			;Also used for from filters
CMDGTB:	BLOCK 17			;GTJFN block
CMDFLB:	BLOCK 4				;Individual field block
STRBSZ==1000
SRCBUF==.
FILNAM==.
STRBUF:	BLOCK STRBSZ			;Temporary string space

MYDIR:	0				;Login directory
MYCDIR:	0				;Connected directory

MYDIRS:	BLOCK 10			;ASCII of login directory
MYHNAM:	ASCII / at /
	BLOCK 17			;Host and personal name

MSGSEQ:	BLOCK NMSGS/3			;Table of numbers of messages
MSGSQZ==.

TTXTIB:	7
	RD%JFN
	.PRIIN,,.PRIOU
TXTPTR:	0				;Put updated pointer here
TXTCNT:	0				;Put count here
	POINT 7,TXTPAG			;Where it starts
	0
	TXTMSK				;Break table for text

FSCPKL:	0				;a LSHC A,<n> for SHIFT-IN goes here
	LSH A,1
	MOVEM A,(C)			;Address of dest stored in RH here
	0				;a LSHC A,<n> for SHIFT-OUT goes here
	MOVE B,(C)			;Address of source stored in RH here
	AOBJN C,FSCPKL
	JRST @FENTRM(D)

CMDBLK:	REPARS				;COMND state table
	.PRIIN,,.PRIOU
	0
	POINT 7,CSBUF
	POINT 7,CSBUF
	CSBFSZ*5
	0
	POINT 7,STRBUF
	STRBSZ*5
	CMDGTB

IPCF,<
PIDGET:	IP%CPD				;Block for finding [SYSTEM]MAILER
	0
	0
	ENDPID-.,,.+1			;Pointer to actual message
	1,,1				;Get PID for name
	0
	ASCIZ /[SYSTEM]MAILER/
ENDPID==.
>;IPCF

REQID=='MM'				;Request ID for our ENQing

ENQBLK:	1,,ENQBLL			;Number of locks, block size
	REQID				;Interrupt channel, request ID
	0				;Flags, level number,,JFN
	-1,,[ASCIZ /Mail expunge interlock/]	;Pointer to name string
	0				; (this name used because MS uses it)
	0
ENQBLL==.-ENQBLK			;Length of ENQ BLOCK

SUBTTL Pure storage

;;;Break mask for slurping up a user name

UNMMSK:	777777777760			; no controls
	767544001760			; %, *, -, .. numerics
	400000000760			; upper case alphabetics
	400000000760			; lower case alphabetics

;;;TEXTI break mask for user input

UTXTMS:	000220000400			;^J, ^M, ESC
	000040001000			;, :
	400000000000			;@
	000000000000

;;;TEXTI break mask for text input

TXTMSK:	110140001400			;^B, ^E, ^K, ^L, ^Z, ESC
	000000000000
	000000000000
	000000000000

;;;List of recipients of bug reports for this version of MM

BUGLST:
ARPA,<
	ASCIZ /MMcM@MIT-XX,Admin.MRC@SU-SCORE/
>;ARPA
NOARPA,<
CLSC,<	ASCIZ /C-Griss/>
COL,<	ASCIZ /OC.MRC/>			;Places not on the Arpanet
DREA,<	ASCIZ /Hemphill/>
HP,<	ASCIZ /Eldredge,MRC/>
GSB,<	ASCIZ /A.MRC/>
LOTS,<	ASCIZ /M.MRC/>
SUMX,<	ASCIZ /Crispin/>
SPCH,<	ASCIZ /MMcM/>
IFE .-BUGLST,<
	ASCIZ /Operator/		;Last resort
>;IFE .-BUGLST
>;NOARPA

;;;Interrupt storage

LEVTAB:	PSIPC1
	PSIPC2
	0
CHNTAB:	BLOCK 4
	1,,ABOINT			;^N on chan 4
	2,,TMRINT			;Timer on chan 5
	BLOCK 36

EV:	JRST GO				;Entry vector
	JRST GOAMOD
VERNUM:	BYTE (3) VWHO (9) VMAJ (6) VMIN (18) VEDIT

SUBTTL Command tables

;;;Top level commands

CMDTAB:	NCMDS,,NCMDS 
	CMD1 (A,ENTANS,CM%ABR!CM%INV)
ENTANS:	CMD ANSWER
	CMD APPEND
	CMD BBOARD,.MSBBD
	CMD BLANK
	CMD BUG
	CMD CHECK
	CMD CONTINUE
	CMD COPY
	CMD CREATE-INIT,.CRINI
	CMD1 (D,ENTDEL,CM%ABR!CM%INV)
	CMD DAYTIME
ENTDEL:	CMD DELETE
	CMD DIRED
	CMD EDIT
	CMD ENABLE
	CMD1 (EX,ENTXIT,CM%ABR!CM%INV)
	CMD EXAMINE
ENTXIT:	CMD EXIT
	CMD EXPUNGE
	CMD FILE-LIST,.FLIST
	CMD FLAG
	CMD FORWARD
	CMD GET
	CMD1 (H,ENTHDR,CM%ABR!CM%INV)
ENTHDR:	CMD HEADERS
	CMD HELP
	CMD JUMP
	CMD KEYWORDS
	CMD LIST
	CMD LITERAL-TYPE,.LTYPE
	CMD LOGOUT
	CMD1 (MAIL,.SEND,CM%INV)
	CMD MARK
	CMD MOVE
	CMD1 (N,ENTNXT,CM%ABR!CM%INV)
ARPA,<
	CMD NET-MAIL,.MAILE
>;ARPA
SPCH,<
	CMD NET-MAIL,.MAILE
>;SPCH
ENTNXT:	CMD NEXT
	CMD PREVIOUS
	CMD PROFILE
	CMD PUSH
	CMD QUIT
	CMD1 (R,ENTRED,CM%ABR!CM%INV)
ENTRED:	CMD READ
	CMD REMAIL
	CMD1 (REPLY,.ANSWE,CM%INV)
	CMD RESTORE-DRAFT,.RESTO
	CMD1 (S,ENTSND,CM%ABR!CM%INV)
ENTSND:	CMD SEND
	CMD SET,.VARIA
	CMD STATUS
	CMD SYSTEM-MSGS,.MSGOD
	CMD TYPE
	CMD UNDELETE
	CMD UNFLAG
	CMD UNKEYWORDS
	CMD UNMARK
	CMD VERSION
NCMDS==.-CMDTAB-1

;;;READ commands

RCMDTB:	NRCMDS,,NRCMDS
	CMD BLANK
	CMD CONTINUE
	CMD COPY
	CMD DELETE,.RDELM
	CMD EDIT,.REDIT
	CMD1 (FILE-LIST,.COPY,CM%INV)
	CMD FLAG,.RFLAG
	CMD FORWARD,.RFORW
	CMD1 (H,ENTRHE,CM%ABR!CM%INV)
ENTRHE:	CMD HEADER,.RHEAD
	CMD HELP
	CMD KEYWORDS,.RKEYW
	CMD1 (L,ENTRLS,CM%ABR!CM%INV)
ENTRLS:	CMD LIST
	CMD LITERAL-TYPE,.LRTYP
	CMD1 (MAIL,.SEND,CM%INV)
	CMD MOVE
	CMD1 (N,ENTRNE,CM%ABR!CM%INV)
ARPA,<
	CMD NET-MAIL,.MAILE
>;ARPA
SPCH,<
	CMD NET-MAIL,.MAILE
>;SPCH
ENTRNE:	CMD NEXT,.RNEXT
	CMD1 (P,ENTRPR,CM%ABR!CM%INV)
ENTRPR:	CMD PREVIOUS,.RPREV
	CMD PUSH
	CMD QUIT,.RQUIT
	CMD1 (R,ENTRRP,CM%ABR!CM%INV)
	CMD REMAIL,.RREMA
ENTRRP:	CMD REPLY
	CMD SEND
	CMD TYPE,.TYPMS
	CMD1 (U,ENTRUN,CM%ABR!CM%INV)
ENTRUN:	CMD UNDELETE,.RUDLM
	CMD UNFLAG,.RUFLG
	CMD UNKEYWORDS,.RUKEY
NRCMDS==.-RCMDTB-1

;;;SEND (and REPLY) commands

SCMDTB:	NSCMDS,,NSCMDS
	CMD BCC
	CMD BLANK
	CMD CC
	CMD DISPLAY
	CMD EDIT,.SEDIT
	CMD ERASE
	CMD HELP
	CMD INSERT,.INSFL
	CMD LITERAL-TYPE,.LRTYP
	CMD1 (MAIL,.SSEND,CM%INV)
	CMD PUSH
	CMD QUIT,.SQUIT
	CMD REMOVE,.UNTO
	CMD RESTORE-DRAFT,.SREST
	CMD SAVE-DRAFT,.SSAVE
	CMD SEND,.SSEND
	CMD SUBJECT
	CMD TEXT
	CMD TO
	CMD TYPE,.TYPMS
	CMD USER-HEADER,.USHDR
NSCMDS==.-SCMDTB-1

;;;ERASE commands

ECMDTB:	NECMDS,,NECMDS
	CMD ALL,.ERSAL
	CMD BCC,.ERSBC
	CMD CC,.ERSCC
	CMD REPLY-DATE,.ERSDT
	CMD SUBJECT,.ERSSB
	CMD TEXT,.ERSTX
	CMD TO,.ERSTO
NECMDS==.-ECMDTB-1

;;;DISPLAY commands

DCMDTB:	NDCMDS,,NDCMDS
	CMD ALL,.DSALL
	CMD BCC,.DSBCC
	CMD CC,.DSCC
	CMD SUBJECT,.DSSUB
	CMD TEXT,.DSTXT
	CMD TO,.DSTO
NDCMDS==.-DCMDTB-1

;;;EDIT commands

EDCMTB:	NEDCMS,,NEDCMS
	CMD HEADERS,.EDHEA
	CMD TEXT,.EDTXT
NEDCMS==.-EDCMTB-1

;;;REPLY commands

RPCMTB:	NRPCMS,,NRPCMS
	CMD ALL,.REPAL
	CMD SENDER,.REPFM
NRPCMS==.-RPCMTB-1

;;;Sequence commands

SQCMTB:	NSQCMS,,NSQCMS
	CMD1 (A,ENTALL,CM%INV!CM%ABR)
	CMD1 (AFTER,STQAFT,CM%INV)
ENTALL:	CMD ALL,STQALL
	CMD ANSWERED,STQANS
	CMD BEFORE,STQBEF
	CMD CURRENT,STQCUR
	CMD DELETED,STQDEL
	CMD1 (F,ENTFRM,CM%INV!CM%ABR)
	CMD FLAGGED,STQFLG
ENTFRM:	CMD FROM,STQFRM
	CMD INVERSE,STQREV
	CMD KEYWORDS,STQKEY
	CMD LAST,STQLST
	CMD NEW,STQNEW
	CMD ON,STQON
	CMD PREVIOUS-SEQUENCE,STQPRV
	CMD RECENT,STQREC
	CMD SEEN,STQSEE
	CMD SINCE,STQAFT
	CMD SUBJECT,STQSBJ
	CMD TEXT,STQTXT
	CMD TO,STQTO
	CMD UNANSWERED,STQUNA
	CMD UNDELETED,STQUND
	CMD UNFLAGGED,STQUNF
	CMD UNKEYWORDS,STQUNK
	CMD UNSEEN,STQUNS
NSQCMS==.-SQCMTB-1

;;;RSCAN commands

RSCMTB:	NRSCMS,,NRSCMS
	CMD BBOARD,.MSBBD
	CMD EXAMINE
	CMD GET
	CMD HEADERS,.RSHEA
	CMD READ,.RSREA
	CMD1 (S,ENTSNR,CM%INV!CM%ABR)
ENTSNR:	CMD SEND
	CMD SYSTEM-MSGS,.MSGOD
NRSCMS==.-RSCMTB-1

;;;Date keywords

DATTAB:	NDATBS,,NDATBS
	VAR FRIDAY,DATDOW,4
	VAR MONDAY,DATDOW,0
	VAR SATURDAY,DATDOW,5
	VAR SUNDAY,DATDOW,6
	VAR THURSDAY,DATDOW,3
	VAR TODAY,DATDAY,0
	VAR TUESDAY,DATDOW,1
	VAR WEDNESDAY,DATDOW,2
	VAR YESTERDAY,DATDAY,1
NDATBS==.-DATTAB-1

;;;Holiday keywords

HOLDAY:	NHLDYS,,NHLDYS
	HDY APRIL-FOOLS,4,1
	HDY BASTILLE-DAY,7,14
	HDY BEETHOVENS-BIRTHDAY,12,16
	HDY BILBOS-BIRTHDAY,9,22
	HDY CHRISTMAS,12,25
	HDY COLUMBUS-DAY,10,12
	HDY FLAG-DAY,6,14
	HDY FRODOS-BIRTHDAY,9,22
	HDY GONDORIAN-NEW-YEAR,3,25
	HDY GROUND-HOGS-DAY,2,2
	HDY GUY-FAWKES-DAY,11,5
	HDY HALLOWEEN,10,31
	HDY INDEPENDENCE-DAY,7,4
	HDY LEAP-DAY,2,29
	HDY LINCOLNS-BIRTHDAY,2,12
	HDY MAY-DAY,5,1
	HDY NEW-YEARS,1,1
	HDY SAINT-PATRICKS-DAY,3,17
	HDY SHERLOCK-HOLMES-BIRTHDAY,1,6
	HDY VALENTINES-DAY,2,14
	HDY WASHINGTONS-BIRTHDAY,2,22
NHLDYS==.-HOLDAY-1

SUBTTL Main program

GO:	TDZA F,F			;Reset flags
GOAMOD:	 MOVEI F,F%AMOD			;Automatic mod handling
	RESET
	MOVE A,[SIXBIT /MM/]
	SETNM
	SETZM ZERMEM
	MOVE A,[ZERMEM,,ZERMEM+1]
	BLT A,ZEREND			;Clear out garbage stuff
	SETO A,				;Get our names
	MOVE B,[-2,,PRGNAM]
	MOVEI C,.JISNM
	GETJI
	 JFATAL
IPCF,<	SETZM PIDGET+1	>		;Forget any garbage PID
	MOVE A,[JRST CMDRES]		;Setup initial return dispatch
	MOVEM A,CMDRET
	MOVE P,[IOWD NPDL,PDL]
	MOVEI A,KEYPAG
	MOVEM A,KEYPTR			;Initialize pointer free space
	SETZM USRHDR			;Reset user headers
	CALL INIT			;Init interrupts and tty modes
	CALL DOINIT			;Parse init file
	TRNE F,F%AMOD			;Auto mod handling?
	 JRST MSGOD0			;Yes, go enter that right now
	CALL DORSCN			;Do rscan hacking
	SKIPE BLSCST			;Clear off the screen, maybe
	 CALL BLANK1
	CALL .VERS1			;Tell version
	CALL GETFIL			;Get and parse file,
	CALL RECENT			;Show data on recent messages
	CALL SUMMRY			;And a summary of the files contents

CMDRES:	MOVE P,[IOWD NPDL,PDL]		;Errors that return to command level come here
CMDLUP:	TRNE F,F%RSCN			;Command line routine terminated?
	 CALL QUIT0			;Yes, go get rid of file and stop
	CALL CHECK			;Check for new messages
	SKIPGE M			;Make sure have a valid message
	 SKIPA M,PRIORM			;Don't, use last one then
	  MOVEM M,PRIORM		;Yes, save in case for next time
	MOVE A,[TOPRMT,,CMDTAB]		;Pointer to current command
	CALL CMDINI			;Init command state, etc.
	SETOM OKTINT			;OK for timer interrupt here
	CALL GETCMD
	CALL (A)
	JRST CMDLUP			;And keep going

SUBTTL Command routines

.HHEAD:	[ASCIZ/
The HEADERS command takes one argument, a message sequence.  It will then
output all the headers of that sequence in order of lowest message number
to highest.
/]

;;;Headers of messages

.RSHEA:	CALL RSCFIL			;RSCAN call, get the file
.HEADE:	CALL DFSQTH			;Get sequence, default to current
	MOVEI A,TYPHDR			;Setup to type out header
	JRST DOMSGS			;And go handle them all

.HSTAT:	[ASCIZ/
The STATUS command tells you relevant information and statistics about
your current message file, i.e. how many messages are deleted, unseen, how
large the file is, etc.
/]

;;;Give status

.STATU:	CONFRM
	SKIPG A,MSGJFN
	 ERROR (No current file)
	TLZ F,(F%F1)			;Don't type headers
	PUSH P,M			;Save where we are
	ETYPE < File: %1J>		;Say what file we are using
	CALL RECEN0
	CALL SUMMRY
.STAT1:	POP P,M
	CIETYP < Currently at msg %M.
>
	RET

.HTYPE:	[ASCIZ/
The TYPE command takes a single argument, a message sequence. It then
types out the bodies of those messages.
/]
.HRTYP:	[ASCIZ/
The TYPE command types out the message again.
/]
.HSTYP:	[ASCIZ/
The TYPE command types out the current message (not the one you are sending!).
/]

.HLTYP:	[ASCIZ/
The LITERAL-TYPE command takes a single argument, a message sequence. It then
types out the bodies of those messages, without regard to ONLY-TYPE-HEADERS
or DONT-TYPE-HEADERS.
/]
.HLRTY:	[ASCIZ/
The LITERAL-TYPE command types out the message again, without suppressing
any headers.
/]
.HLSTY:	[ASCIZ/
The LITERAL-TYPE command types out the current message (not the one you are
sending!), without suppressing any headers.
/]

;;;Type messages

.TYPE:	CALL DFSQTH
	MOVEI A,TYPE1
	JRST DOMSGS
	
TYPE1:	CALL CHKDEL			;Not the deleted ones
	 RET
	JRST TYPMSG

;;; Literal typing (no filters)
.LTYPE:	CALL DFSQTH
	MOVEI A,LTYPE
	JRST DOMSGS

LTYPE:	CALL CHKDEL
	 RET
	JRST TYPMSL

.HMARK:	[ASCIZ/
The MARK command takes one argument, a message sequence.  It will then mark
the messages in that sequence as seen.
/]
.HDELE:	[ASCIZ/
The DELETE command takes one argument, a message sequence and marks it for
deletion.  The messages are not erased until the EXPUNGE command is given.
/]
.HRDEL:	[ASCIZ/
The DELETE command deletes the message currently being read.
/]

;;;Mark messages

.MARK:	SKIPA A,[MRKMSG]

;;;Delete messages

.DELET:	 MOVEI A,DELMSG
DELET0:	MOVEM A,DOMSG			;Set up handler
	CALL DFSQTH			;Get sequence, default to current
DELET1:	TLOA F,(F%TYPS)			;Say to print numbers of things done
DOMSGS:	 MOVEM A,DOMSG			;Enter here with routine to handle them in A
DELET2:	CALL NXTMSG			;Next message spec'd
	 RET
	CALL @DOMSG			;Process the message
	JRST DELET2

;;;Put keywords on messages
.HKEYW:	.+1
	ASCIZ/
The KEYWORDS command takes two arguments, a keywords list and a message
sequence.  It will then mark the messages in that sequence as being
included in the keyword.  To define a keyword, put a line in your MM.INIT
of the form:
	KEYWORDS list-of-keywords
This feature is useful for classifying old messages.
/
.HUNKE:	[ASCIZ/
The UNKEYWORDS command takes two arguments, a keywords list and a message
sequence.  It will then mark the messages in that sequence as not being
included in the keyword.
/]

.UNKEY:	SKIPA A,[UNKMSG]
.KEYWO:	 MOVEI A,KEYMSG
	PUSH P,A
	CALL GETKEY			;Get list of keywords
	HLRM U,KEYBTS			;Save mask bits
	POP P,A
	JRST DELET0			;And go handle sequence

.HNEXT:	[ASCIZ/
The NEXT command goes to the next message in the file (or message sequence
if in READ mode) and types it if undeleted.
/]
.NEXT:	NOISE (MESSAGE)
	CONFRM
	SKIPG MSGJFN
	 ERROR (No current file)
	CAML M,LASTM			;At last message?
	 JRST [	CIETYP < Currently at end, msg %M.
>
		RET]
	ADDI M,MSGLEN			;Nope, increment him
.NEXT1:	CALL CHKDEL			;Deleted?
	 RET
	JRST TYPMSG			;No, type the next one then

.HPREV:	[ASCIZ/
The PREVIOUS command goes to the previous message in the file and types it
if undeleted.
/]
.PREVI:	NOISE (MESSAGE)
	CONFRM
	SKIPG MSGJFN
	 ERROR (No current file)
	JUMPE M,[CIETYP < Currently at beginning, msg %M.
>
		 RET]
	SUBI M,MSGLEN
	JRST .NEXT1

.HJUMP:	[ASCIZ/
The JUMP command allows you to specify a message in the current message
file to jump to.  This means make the new current message will be the
JUMP'ed message.
/]
.JUMP:	SKIPG MSGJFN
	 ERROR (No current file)
	NOISE (TO MSG NUMBER)
	MOVEI B,[FLDDB. .CMNUM,,^D10]	;Read a number
	CALL CMDFLD
	PUSH P,B
	CONFRM
	EXCH M,(P)			;Get back number typed
	SUBI M,1
	IMULI M,MSGLEN			;Convert to msg pointer
	CAMG M,LASTM
	 JUMPGE M,CPOPAJ		;Number ok, just flush saved value
	POP P,M
BADNUM:	ERROR (Number out of range)

.HFLAG:	[ASCIZ/
The FLAG command takes one argument, a message sequence. It marks the
messages in that sequence with the FLAG bit. So with other commands that
take message sequences as arguments, the FLAGGED sequence will access
those messages.
/]
.HUNDE:	[ASCIZ/
The UNDELETE command takes a single argument, a message sequence and then
undeletes all the messages in that sequence.
/]

.HUNMA:	[ASCIZ/
The UNMARK command takes a single argument, a message sequnce and then
unmarks all the messages in that sequence, i.e. makes them appear unseen.
/]
.HUNFL:	[ASCIZ/
The UNFLAG command takes a single argument, a message sequence and unflags
all the messages in that sequence.
/]
.FLAG:	SKIPA A,[FLGMSG]		;Flag messages
.UNFLA:	 MOVEI A,UFLMSG			;Unflag messages
	JRST DELET0

.HRUNF:	[ASCIZ/
The UNFLAG command unflags the message currently being read. Use the FLAG
command to make messages of importance "stand out" in your message file.
You can then access them via the FLAGGED message sequence.
/]
.HRUND:	[ASCIZ/
The UNDELETE command undeletes the message currently being read.
/]
.UNMAR:	SKIPA A,[UMKMSG]
.UNDEL:	MOVEI A,UNDMSG
	JRST DELET0

.HBLAN:	[ASCIZ/
The BLANK command blanks the terminal screen if it is a display.
/]
.BLANK:	CONFRM
BLANK1:	AOSN BLNKER			;Did an error happen?
	 JRST [	PROMPT <Shall I rewrite your MM.INIT file?>
		CALL YESNO		;Yes, offer to fix it
		 RET			;User said no, don't blank screen
		JRST CRINI0]		;Fix it and return
	MOVEI A,.PRIOU			;Enter here for things that blank incidentally
	RFMOD				;Change to
	PUSH P,B
	TRZ B,TT%DAM			;Binary mode
	SFMOD
	MOVE B,TTYPE
	CAIGE B,NCLRSC			;More than the number I support?
	 SKIPN A,CLRSCN(B)		;Get right magic
	  JRST BLANK2			;Hardcopy can't do this
	TLOE A,-1			;More than 5 chars?
	 HRROI A,CLRSCN(B)		;No, use immediate
	PSOUT
	MOVEI A,.PRIOU
	SETZ B,				;Tell monitor we are at top of page
	SFPOS
BLANK2:	MOVEI A,.PRIOU
	POP P,B
	SFMOD
	RET

;;;Display clearing codes

DEFINE ADMHAZEL <BYTE (7) 176,34,CTL(V),CTL(Z),0>;ADM+Hazeltine+Tec
DEFINE CLRASCII <BYTE (7) ESC,"H",ESC,"J",0>;Standard ASCII screen clear
DEFINE FORMFEED <BYTE (7) CTL(L),0>	;Traditional screen clear

CLRSCN:	REPEAT 4,<0>			;0 TTY33, 1 TTY35, 2 TTY37, 3 TI
DEC,<
	REPEAT 4,<0>			;4-7 reserved for customer
>;DEC
CLSC,<
	FORMFEED			;4 Glass
	ADMHAZEL			;5 Televideo
	ADMHAZEL			;6 Hazeltine 1500
	0				;7 Unused
>;CLSC
COL,<
	REPEAT 4,<0>			;4-7 unused
>;COL
DREA,<
	BYTE (7) "Z"-100,0		;4 ADM-3
	BYTE (7) 35,36,0		;5 Datamedia
	[BYTE (7) 33,133,"H",33,133,"J",0]	;6 VT100 in native mode
	BYTE (7) 33,"?",33,03,0		;7 C100 and Concept APL
>;DREA
HP,<
	ADMHAZEL			;4 ADM-3
	BYTE (7) CTL(]),CTL(^),0	;5 Datamedia 2500
	CLRASCII			;6 HP2640
	ADMHAZEL			;7 Hazeltine 1500
>;HP
ISI,<
	BYTE (7) ESC,"(",177,0		;4 LP Datamedia
	BYTE (7) CTL(]),CTL(^),0	;5 Datamedia 2500
	CLRASCII			;6 HP2640
	0				;7 unused
>;ISI
MIT,<
	0				;4 IMLAC
	BYTE (7) CTL(]),CTL(^),0	;5 Datamedia 2500
	CLRASCII			;6 HP2640
	0				;7 Terminet
>;MIT
RUTG,<
	BYTE (7) ESC,"+",CTL(L),CTL(Z),0;4 Video unspecified
	BYTE (7) CTL(]),CTL(^),0	;5 Datamedia 2500
	[BYTE (7) ESC,"6","h",ESC,"2","J",ESC,"0","Q",0];6 I400
	FORMFEED			;7 Datamedia 1520
>;RUTG
SRI,<
	BYTE (7) CTL(Z),0		;4 LSI ADM-3
	BYTE (7) CTL(]),CTL(^),0	;5 Datamedia 2500
	CLRASCII			;6 HP2640
	0				;7 Terminet
>;SRI
STAN,<
	ADMHAZEL			;4 ADM-3
	BYTE (7) CTL(]),CTL(^),0	;5 Datamedia 2500
	CLRASCII			;6 HP2640
	ADMHAZEL			;7 Hazeltine 1500
>;STAN
UTAH,<
	FORMFEED	    		;4 Glass teletype
	CLRASCII			;5 Fox
	BYTE (7) CTL(Z),0		;6 ADM 3A
	CLRASCII			;7 Teleray 1061
>;UTAH
	0				;8 default
	0				;9 PTY, NVT (aka "ideal")
	BYTE (7) CTL(]),CTL(_),CTL(_),CTL(_),0;10 VT05
	CLRASCII			;11 VT50
	0				;12 LA30
SRI,<
	BYTE (7) ESC,"(",177,0		;13 LP Datamedia
>;SRI
NOSRI,<
	BYTE (7) CTL(]),CTL(_)		;13 GT40
>;NOSRI
	0				;14 LA36
	CLRASCII			;15 VT52
HP,<
	0				;16 TTY43
	BYTE (7) CTL(V),0		;17 Tec
	BYTE (7) CTL(Z),0		;18 Stanford "new" Hazeltine
	CLRASCII			;19 Teleray 1061
	0				;20 GDP
	CLRASCII			;21 HP2621
>;HP
MIT,<
	FORMFEED			;16 Glass TTY
	CLRASCII			;17 Fox
	CLRASCII			;18 VT100
	CLRASCII			;19 Teleray 1061
	CLRASCII			;20 Heath 19
>;MIT
RUTG,<
	REPEAT 6,<0>			;16-21 left unused
	[BYTE (7) 176,34,177,177,177,177,0];22 Hazeltine Modular 1
	[BYTE (7) 176,34,177,177,177,177,0];23 Hazeltine 1500
	[BYTE (7) 33,"v",33,"3",33,"j",33,"b",33,"\",33,"l",33,"G",0] ;24 Visual 200
	FORMFEED			;25 NIH 5200
	CLRASCII			;26 Heath 19
	FORMFEED			;27 Concept 100
>;RUTG
REL4,<
	CLRASCII			;16 VT100
	0				;17 LA38
	0				;18 LA120
>;REL4
COL,<
	REPEAT 4,<0>			;19-22 left unused
	FORMFEED			;23 Concept 100
	CLRASCII			;24 Fox
	FORMFEED			;25 Datamedia 1520
	FORMFEED			;26 Glass
	CLRASCII			;27 Datamedia 3000
	CLRASCII			;28 HP 2621
	CLRASCII			;29 I100
	BYTE (7) ESC,"K",0		;30 Bantam
>;COL
STAN,<
	0				;19 TTY43
	BYTE (7) CTL(V),0		;20 Tec
	BYTE (7) CTL(Z),0		;21 Stanford "new" Hazeltine
	CLRASCII			;22 Teleray 1061
	[BYTE (7) 35,"E","R","A",";",0]	;23 Tektronix 4025
	FORMFEED			;24 Ann Arbor
	CLRASCII			;25 Heath 19
>;STAN
NCLRSC==.-CLRSCN			;Maximum # of terminal types

.HEXIT:	[ASCIZ/
The EXIT command is used to erase any deleted messages in the current
message file and end a session with MM.
/]
.EXIT:	NOISE (AND UPDATE MESSAGE FILE)
	CONFRM
	SKIPLE MSGJFN			;If have a file,
	 CALL EXPUNG			;Expunge first
	JRST QUIT0			;And then quit

.HLOGO:	[ASCIZ/
The LOGOUT command will stop MM, expunge your message file, and log you
out from the system.
/]
.LOGOU:	NOISE (AND UPDATE MESSAGE FILE)
	CONFRM
	SKIPLE MSGJFN			;If have a file,
	 CALL EXPUNG			;Expunge first
	SETO A,				;Flush us
	LGOUT				;Do the kill
	 ERROR (Logout failed)		;Woops, bombed?
	JRST .-2

.HEXPU:	[ASCIZ/
The EXPUNGE command is used to erase deleted messages from the current
message file and write out a new copy of the file.
/]
.EXPUN:	NOISE (DELETED MESSAGES)
	CONFRM
	SKIPG MSGJFN
	 ERROR (No current file)

EXPUNG:	TRNN F,F%MOD!F%RONL		;Not on system mail you dont
	 CALL GETJF2			;Get write JFN so no one interferes
	  RET				;Failed, or system mail
	SETZB L,M			;Zero start, offset with first msg
	SETZ X,				;Init count of bytes saved

EXPN00:	MOVEI A,M%DELE			;Deleted bit
	TDNN A,MSGBTS(M)		;Is it deleted?
	 JRST EXPN20			;No, must save it
	JUMPN L,EXPN10			;The first deleted msg we have seen?
	MOVSI A,(EN%BLN)		;Exclusive use, no level numbers
	HRR A,MSGJFN			;File's JFN
	MOVEM A,ENQBLK+.ENQLV
	DMOVE A,[.ENQMA			;Change our lock to be exclusive
		 ENQBLK]
	ENQ
	 ERJMP [WARN (Can't do expunge - another process has the file open)
		JRST CLSJF2]		;Get rid of the JFN we made
	MOVE V,X
	CALL CHR2BP			;Yes, byte pointer to last saved byte
	MOVE O,A			;Init pointer to output area
	MOVEI A,MSGPAG*1000		;And make messages private
	HRRZ B,FILPGS
EXPN01:	MOVES (A)
	SOJLE B,EXPN10
	ADDI A,1000
	JRST EXPN01
EXPN10:	SUB L,MSGSAL(M)			;Increment count of byte offset
	JRST EXPN30			;And go process next msg

EXPN20:	MOVE C,MSGSAL(M)		;Get length of this message
	ADD X,C				;Keep track of total
	JUMPE L,EXPN30			;If no bytes deleted yet, no moving
	MOVE V,MSGALL(M)		;Get starting byte of message
	CALL CHR2BP			;Get byte pointer in a to old msg
	CALL FSCOPY			;Do a fast string copy
	ADDM L,MSGALL(M)		;Update position in file of start

EXPN30:	CAMGE M,LASTM			;At the last msg?
	 JRST [	ADDI M,MSGLEN
		JRST EXPN00]		;No, do next then
	JUMPE L,EXPN33			;No msgs deleted, nothing more to do
	JUMPE X,EXPN34			;No msgs retained, delete the file
	CITYPE ( Expunging deleted messages)
	MOVE B,X			;See how many pages touched
	IDIVI B,5000
	JUMPE C,.+2
	 ADDI B,1
	PUSH P,B			;Save new count for later
	HRRZ C,FILPGS			;Number we had mapped to start
	SUBI C,(B)			;Less number touched
	JUMPE C,EXPN31			;All pages touched
	SETO A,
	ADD B,[.FHSLF,,MSGPAG]
	HRLI C,(PM%CNT)
	PMAP				;Unmap those not touched
	HRLZ B,MSGJF2			;Write msg file jfn
	HRR B,(P)			;Number of pages touched
	PMAP				;Make pages in the file go away
	 ERJMP [JFATAL <Can't unmap file pages, probably another user has file open>]

EXPN31:	HRRZ A,MSGJF2			;Write msg file jfn
	HRROI B,MSGPAG*1000		;Write out new pages
	MOVN C,X
	SOUT
	POP P,C				;Get back count of pages touched
	HRRM C,FILPGS			;Update count of pages really in file
	MOVEM X,FILSIZ
	HRLI A,.FBSIZ
	SETO B,
	MOVE C,X			;Update byte count
	CHFDB
	LDB B,[POINT 6,FILPGS,11]	;Get byte size
	CAIN B,7			;If not 7,
	 JRST EXPN32
	HRLI A,.FBBYV			;Make it be
	MOVSI B,(FB%BSZ)
	MOVSI C,(7B11)
	CHFDB
	ANDCAM B,FILPGS
	IORM C,FILPGS
EXPN32:	CALL CLSJF2			;Get rid of write jfn
	MOVSI A,(EN%BLN!EN%SHR)		;No level number, shared access
	HRR A,MSGJFN
	MOVEM A,ENQBLK+.ENQLV		;Change the access back to shared
	DMOVE A,[.ENQMA
		 ENQBLK]
	ENQ
	 ERJMP .+1			;Don't care
	SETZB X,M			;Update message numbers
	SKIPA B,[M%DELE]
EXPN41:	 ADDI M,MSGLEN
	TDNN B,MSGBTS(M)		;Deleted?
	 JRST EXPN43			;No, save numbers then
EXPN42:	CAMGE M,LASTM			;Done?
	 JRST EXPN41
	SUBI X,MSGLEN
	MOVEM X,LASTM			;Yes, update new count
	MOVEI M,(X)			;And go there
	RET				;And done

EXPN43:	CAIN X,(M)			;Still none deleted?
	 JRST EXPN44
	MOVSI A,MSGALL(M)		;Having to move, update header pointers
	HRRI A,MSGALL(X)
	BLT A,MSGALL+MSGLEN-1(X)
EXPN44:	ADDI X,MSGLEN
	JRST EXPN42

EXPN33:	CITYPE < No messages deleted, so no update needed.
>
	JRST CLSJF2

EXPN34:	CITYPE < All messages deleted, deleting file.
>
	DMOVE A,[.DEQID			;Get rid of any locks we got
		 REQID]
	DEQ
	 ERJMP .+1			;Ignore failure
	SKIPLE A,MSGJFN			;Make damn sure this JFN is out of
	 CLOSF				; the way, so the DELF doesn't get a
	  NOP				; DELFX2 loser
	SETOM MSGJFN
	CALL CLSJF2
	SETZM FILSIZ
	HRRZ A,MSGJF2
	TLO A,(DF%EXP)
	DELF
	 JWARN
	HRRZ A,MSGJF2
	RLJFN
	 NOP
	SETOM MSGJF2
	RET

.HANSW:	.+1				;MACRO chokes on this as a literal
	ASCIZ/
The ANSWER command takes 1 argument, a message sequence you would like to
answer. So, to reply to message 3 you would say >ANSWER 3 where 3 is the
message number. Or you could answer any other message sequence. After
typing >ANSWER 3 and then carriage return it asks you "Reply msg #3 to:"
and awaits one of "ALL" or "SENDER". If you respond with ALL, then your
answer will go to everyone in the header of the message: the person who
sent it to you and everyone else.  If you respond with SENDER, then your
answer will only go to the sender of the message.
/
.ANSWE:	CALL DFSQTH			;Get in sequences, def to current
	MOVEI A,ANSRET			;Return here on error
	HRRM A,CMDRET
ANSWE0:	CALL NXTMSG			;Get next message
	 JRST .AQUIT			;Unless all done
	CALL CHKDEL			;Deleted?
	 JRST ANSWE0			;Yes, forget it
	MOVE A,[POINT 7,STRBUF+40]
	MOVEI B,[ASCIZ / Reply msg # /]
	CALL MOVSTR
	MOVEI B,MSGLEN(M)
	IDIVI B,MSGLEN
	MOVEI C,^D10
	NOUT
	 JCERR
	MOVEI B,[ASCIZ / To: /]
	CALL MOVST0
	UPRMT STRBUF+40			;Prompt for all/sender
	MOVEM L,SAVL
	SETOM CLEVEL			;Dont let ^U go to top level
	MOVEI A,REPLY0			;Set reparse address
	HRRM A,CMDBLK+.CMFLG
	CALL REPLY0			;Reply to it
ANSRET:	MOVE L,SAVL
	JRST ANSWE0			;How about another?

.AQUIT:	MOVEI A,CMDRES			;Reset the error handler
	HRRM A,CMDRET
	JRST CMDRES			;And back to snarf a command

;;;Append messages together

.HAPPE:	[ASCIZ/
The APPEND command takes a message sequence, and appends those messages
together into one message.
/]
.APPEN:	SKIPG MSGJFN			;Must have a file
	 ERROR (No current file)
	CALL GETSEQ			;Get a bunch of messages no default
	TLO F,(F%TYPS)			;Type out numbers of messages
	PUSH P,[POINT 7,TXTPAG]		;Lots of string space
	PUSH P,[0]
APPEN1:	CALL NXTMSG			;Get next message
	 JRST APPEN2			;All done
	CALL DELMSG			;Delete it
	HRRZ V,MSGBOD(M)
	CALL MCH2BP			;Get byte pointer to message
	HLRZ C,MSGBOD(M)		;And length
	ADDM C,(P)			;Update total length
	MOVE O,-1(P)
	CALL FSCOPY			;Copy in the message
	MOVEM O,-1(P)
	JRST APPEN1			;For the whole sequence

APPEN2:	CALL UNDMSG			;Undelete the last one of them
	MOVE A,[POINT 7,TXTPAG]
	POP P,C				;Get total length
	CALL RPLMSG			;Go replace that message
	UETYPE [ASCIZ / => %M/]
	JRST CPOP1J

.HREAD:	[ASCIZ/
The READ command takes one argument, a message sequence and starts reading
the messages in that sequence in special read-mode.
/]
.RSREA:	CALL RSCFIL			;Get file for rscan command handling
.READ:	CALL DFSQNW			;Get sequence, default to unseen
	TRO F,F%READ			;Say in read command
	MOVEI A,REDRET			;Return here
	HRRM A,CMDRET			;On error
READ0:	CALL NXTMSG			;Get next message
	 JRST RQUIT0			;None, all done
READ1:	CALL CHKDEL			;Dont if deleted msg
	 JRST REDRET
	SKIPE BLSCST			;Unless user doesnt want it
	 CALL BLANK1			;Clear the screen perhaps
	CALL TYPMSG			;And type the message out
	SKIPGE RINCME			;Special include me mode?
	 SETZM SAVFIL			;Yes, reset default moved to

REDRET:	MOVE P,[IOWD NPDL,PDL]		;Reset stack
REDCLP:	MOVE A,[REPRMT,,RCMDTB]		;Read command
	CALL CMDINI
	DEFALT (NEXT)			;CR moves on to next message
	CALL GETCMD
	CALL (A)
	JRST REDCLP			;Keep going

.RNEXT:	CONFRM
	CALL UPDBT0			;Update message
 	JRST READ0

.RQUIT:	CONFRM
RQUIT0:	CALL UPDBT0			;Update this message
	TRZ F,F%READ
	SETZM RPVSAV
	MOVEI A,CMDRES
	HRRM A,CMDRET
	JRST CMDRES			;And return to top level

;;; Read mode previous command, note this is clever about saving state so
;;; that backing up in the middle of a read undeleted where you delete some
;;; messages will cycle through the same messages no matter what the path.
.RPREV:	CONFRM
	CAMN L,[POINT 12,MSGSEQ,11]
	 ERROR (Already at start of sequence)
	CALL UPDBT0			;Update file
	MOVE A,NXTMSD			;Get next mesage dispatch
	CAIN A,NXTSEQ			;Numeric sequences are easy
	 JRST RPREV1
	HRLM A,RPVSAV			;Save old one
	HRRM M,RPVSAV
	MOVEI A,NXTSEQ
	MOVEM A,NXTMSD
RPREV1:	IDIVI M,MSGLEN			;For ease of computation
	SETO B,				;Do this also in case not normalized
	ADJBP B,L
	LDB A,L				;Get current entry in list
	LDB C,B				;Get start of range or previous entry
	TRZN A,2000			;Is this a range type?
	 JRST RPREV3			;No, just number, take the previous
	CAIG A,(C)			;Start before end?
	 AOJA M,RPREV2
	CAIL A,(C)
	 SUBI M,1			;Else decrement
RPREV2:	CAIN M,(C)			;This puts us at the start?
RPREV3:	 DMOVE L,B			;Point to this new spot
	TRZ M,2000
	IMULI M,MSGLEN			;Back to right unit
	JRST READ1			;Pretend user got there to other way

.HSSEN:	[ASCIZ/
The SEND command sends the message.  Also, if you simply type carriage
return in send mode, it will attempt to send out the message.
/]
.HSEND:	[ASCIZ/
The SEND command starts sending a message. It prompts for the addresses,
subjects and text of the message.  To send the message, type ^Z after
finishing typing the text in. Then confirm with a carriage return or use
the command in send-mode to modify and edit the message before sending it.
/]
.HCONT:	[ASCIZ/
The CONTINUE command resumes a SEND which was interrupted or QUITed out of.
/]

;;;Sending subcommands

.CONTI:	NOISE (SENDING MESSAGE)
	CONFRM
	SKIPL SNDCAL
	 ERROR (There is no sending to continue)
	SETZM LSTCHR			;Dont accidentally send it off
	JRST SEND0			;Enter send mode

.SEND:	NOISE (MESSAGE TO)
	CALL SNDINI
	CALL GETTO0			;Get to: without prompting
	SKIPE TOLIST
	 JRST [	CALL GETMS1		;Get message without cc or to
		JRST SEND0]		;And fall in to rest
	TRZ F,F%HOER			;User wants hand-holding, no more halt
	CALL SNDINI			;Reset fields
	CALL GETMSG			;Prompt for message
SEND0:	CALL CLRABO			;Dont allow ^N any more
	HRRZ A,CMDRET			;Save where we came from
	HRROM A,SNDCAL
	MOVE A,LSTCHR			;Get last character
	SKIPG ESCSND			;Escape sends automatically?
	 JRST SEND01			;No
	CAIN A,ESC			;Yes, wants that?
	 JRST SSEND1			;Yes, just send if off then
	JRST SEND1			;Else go get some commands

SEND01:	CAIE A,CTL(Z)
	 JRST SEND1
	SKIPL ESCSND			;^Z sends automatically?
	 TRNE F,F%RSCN			;Or called in command line?
	  JRST SSEND1			;Yes, do so
SEND1:	MOVEI A,SNDRET
	HRRM A,CMDRET
	TRO F,F%SEND
SNDRET:	MOVE P,[IOWD NPDL, PDL]		;Reset stack
SNDLUP:	TRZE F,F%ESND			;Editor said to send it?
	 JRST SSEND1			;Yes, do that right away
	MOVE A,[SEPRMT,,SCMDTB]
	CALL CMDINI
	DEFALT (SEND)
	CALL GETCMD
	CALL (A)
	JRST SNDLUP

.SSEND:	CONFRM
SSEND1:	CALL SNDMSG			;Send it off
	HRRZS SNDCAL			;Don't let user continue this one
	MOVEI A,M%RPLY			;Mark replying to this message
	TRZE F,F%RPLY			;Was this a reply we just sent?
	 IORM A,MSGBTS(M)		;Yes, mark message as answered
	JRST SQUI1

.HSQUI:	[ASCIZ/
The QUIT command gets out of this mode and returns back to the top level
prompt.
/]
.SQUIT:	CONFRM
SQUI1:	TRZ F,F%SEND			;Not in send command any more
	HRRZ A,SNDCAL			;Get where we entered from
	HRRM A,CMDRET			;Set up to go back there
	TRNE F,F%DIRE			;From dired mode?
	 JRST DIREDR			;Yes, resume that then
	JRST (A)			;And do

.HREDI:	[ASCIZ/
The EDIT command edits the message currently being read.
/]
.HSEDI:	[ASCIZ/
The EDIT command takes one of the following arguments:

	HEADERS	-- edit the headers of the message
	TEXT	-- edit the text of the message

(If you simply type EDIT followed by a carriage return it defaults to
TEXT.)
/]
.SEDIT:	DEFALT (TEXT)
	MOVEI A,EDCMTB
	JRST .ERAS2			;Get field to edit

.HSERA:	[ASCIZ/
The ERASE command takes one of the following arguments:

	All	   -- erase the entire message
	Bcc	   -- erase the blind carbon-copies address list
	Cc	   -- erase the carbon-copies address list
	Reply-date -- erase the reply date
	Subject	   -- erase the subject
	Text	   -- erase the text
	To	   -- erase the to address list
/]
.ERASE:	NOISE (MESSAGE FIELD)
	DEFALT (TEXT)
	MOVEI A,ECMDTB
.ERAS2:	CALL SUBCMD
	PUSH P,A
	CONFRM
	POP P,A
	CALL (A)
	JRST @CMDRET

.HSDIS:	[ASCIZ/
The DISPLAY command takes one of the following arguments:

	ALL 	-- shows the entire message
	BCC 	-- shows only the blind-carbon copy addresses
	CC  	-- shows only the carbon copy addresses
	SUBJECT -- shows only the subject
	TEXT	-- shows only the text
	TO	-- shows only the to recipients

(If you simply type DISPLAY followed by a carriage return it displays the
entire message.)
/]
.DISPL:	NOISE (MESSAGE FIELD)
	DEFALT (ALL)
	MOVEI A,DCMDTB
	JRST .ERAS2

.HRREP:	[ASCIZ/
The REPLY command replies to the message currently being read.
/]
.REPLY:	NOISE (TO)
REPLY0:	MOVEI A,[ASCIZ /ALL/]
	SKIPE RFMDEF
	 MOVEI A,[ASCIZ /SENDER/]
	UDEF (A)			;Setup right default
	MOVEI A,RPCMTB
	JRST .ERAS2

.REPAL:	TLOA F,(F%F3)			;Say reply to everyone
.REPFM:	 TLZ F,(F%F3)			;Say just reply to sender
.REPL6:	CALL SNDINI			;Erase drafts
	TRO F,F%RPLY			;In reply mode
	CALL FNDSDT			;Find send date
	MOVEM B,REPDAT			;Set up as reply date
	CALL REPSUB			;Construct the subject
	MOVEI T,[ASCIZ /
Reply-To: /]				;Look for overiding header
	CALL FNDHDR
	 JRST .REPL5			;Not found, use from then
	SETZ E,				;No host name defaulting
	TLZ F,(F%CC!F%AT!F%F4)
	CALL PRADDT			;Get the guy and add him in
	TROA F,F%RPTO			;Flag that we processed a Reply-To
.REPL5:	 TRZ F,F%RPTO			;Didn't do a Reply-To
	HRRZ V,MSGFRM(M)		;Handle From so we use its flags
	JUMPE V,.REPL2			;Dont know who it's from
	CALL MCH2BP
	SETZ E,				;No host name defaulting
	TRNE F,F%RPTO			;Doing Reply-To?
	 TLOA F,(F%F4)			;Yes, don't type any error message
	  TLZ F,(F%CC!F%AT!F%F4)	;Otherwise do the normal thing
	CALL PRADDR			;Process the address
	TRZN F,F%RPTO			;Did we see a Reply-To just now?
	 CALL ADDTO			;No, add the address then
.REPL0:	TLZN F,(F%F3)			;Wants reply to all addresses?
	 JRST .REPL1			;No, have enough now
	MOVEI T,[ASCIZ /
To: /]					;Find start of addresses
	CALL FNDHDR
	 JRST .REPL1			;Not there, forget it
	CALL PRTOCC			;Get to and cc lists
	MOVEI U,TOPAG+4			;First recipient's name
	MOVEI N,1			;Allow only one occurance
	CALL DOUNTO
	MOVEI U,MYDIRS			;Remove me from the list
	SETZ N,				;Allow 0 occurances
	CALL DOUNTO
.REPL1:	SKIPN RINCME			;Include me in replies?
	 JRST .REPL3			;No, forget it
	HRROI B,MYDIRS			;Me
	CALL CCSTR			;Add a cc from this string
	SKIPL RINCME			;Want special cc to self?
	 JRST .REPL3
	HLRZ B,CCLIST
	SETOM 2(B)			;Flag special user number for this file
.REPL3:	TRNE F,F%DIRE			;From dired mode?
	 JRST [	CALL EDTXT0		;Yes, go into edit right away
		JRST SEND0]
	SKIPE REPDIS			;Display reply at startup?
.REPL4:	 CALL .DSREP			;Yes, do so
.REPL7:	CALL GETTXT			;Get text of reply
	JRST SEND0			;And go get more or send it off
.REPL2:	CITYPE (Can't tell who message is from)
	CALL GETTO			;Ask him who it's to then...
	JRST .REPL0

;;;Add user headers
.HUSER:	[ASCIZ/
The USER-HEADERS command takes two arguments, a header keyword and a
header text line, and inserts the line with that name in the message
header.
/]

.USHDR:	MOVEI B,[FLDDB. .CMKEY,,USRHTB]
	CALL CMDFLD			;Get a keyword
	HLRZ U,(B)			;Save address of string
	CALL GETLIN
	CALL USHDRL			;New header line
	MOVEI B,(U)			;Address of string
	CALL USHDR1
	MOVEI B,[ASCIZ /: /]
	CALL USHDR1
	MOVEI B,STRBUF			;And finally user's line
	CALL USHDR1
	DMOVEM D,USRHDR+2
	IDPB C,D			;End with a null
	RET

USHDRL:	DMOVE D,USRHDR+2		;Get pointers so far
	JUMPE D,[DMOVE D,[POINT 7,USRHDR+4
			  1-776*5]
		 RET]			;First time out, init pointer
	MOVEI B,CRLF0			;Else put in newline first
USHDR1:	HRLI B,(<POINT 7,0>)		;Copy a string and update count
USHDR2:	ILDB C,B
	JUMPE C,CPOPJ
	IDPB C,D
	AOJL E,USHDR2
USHDRE:	ERROR (String space exhausted)

;;;Save current message draft in a file
.HSAVE:	[ASCIZ/
The SAVE-DRAFT takes one argument, a file name, and saves the message
currently being composed into that file to be retrieved later using the
RESTORE-DRAFT command.
/]

.SSAVE:	NOISE (ON FILE)
	MOVEI B,[FLDDB. .CMOFI]		;Get an output file
	CALL CMDFLD
	MOVEM B,OUTJFN
	CONFRM
	TLZ F,(F%AT)			;Dont put in host names
	CALL SETHD2
	MOVE A,OUTJFN
	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Cannot open file)
	MOVE B,[POINT 7,HDRPAG,13]
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;And put in text
	SOUT
CLOSFR:	CLOSF
	 NOP
	RET

;;;Restore saved message draft
.HREST:	[ASCIZ/
The RESTORE-DRAFT command takes a single argument, a file name created
by the SAVE-DRAFT command, and restores the state of the send from that
draft.
/]

.RESTO:	CALL .SREST			;Load it up
	CALL .DSRST			;Display what we brought back
	SKIPN TXTPAG			;Is there text to the message?
	 JRST .REPL7			;No, prompt for it and so on
	CALL SETABO
	UTYPE [BYTE (7) 15,12,15,12,0]
	CALL .TEXT2			;Typeout and get some more text
	JRST SEND0			;And enter send more

.SREST:	NOISE (FROM FILE)
	CALL GETIFI			;Get an input file
	MOVEM A,TMPJFN
	CONFRM
	MOVE A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JERROR (Cannot open input file)
	CALL SNDINI			;Erase everything so far
	MOVE A,TMPJFN
	MOVEI C,5000
	MOVEI D,12			;Read a line at a time
	MOVE B,[POINT 7,HDRPAG]		;Read the headers in
RESTO1:	MOVE E,B			;Save the start of this line
	SIN
	ILDB T,E			;Get character at start of line
	CAIE T,15			;Blank line?
	 CAIN T,12
	  TDZA T,T
	JUMPN T,RESTO1
	DPB T,E				;Make it end with a null anyway
	SKIPA E,[POINT 7,HDRPAG]
RSTLUP:	 SKIPA E,B
RESTO2:	MOVE B,E			;Get copy of pointer
	MOVE C,[POINT 7,STRBUF]
	SETZM STRBUF
	SETZM STRBUF+1
RESTO3:	ILDB T,B
	JUMPE T,RSTTXT			;Done with headers
	CAIE T,15			;End of line before : is an error
	 CAIN T,12
	 JRST [	MOVEI A,STRBUF
		ERROR (%1S does not look like a header line)]
	CAIL T,"a"
	 CAILE T,"z"
	  CAIA
	   SUBI T,"a"-"A"		;Make uppercase
	IDPB T,C
	CAIE T,":"			;End of the name of it?
	 JRST RESTO3
	DMOVE C,STRBUF
	CAME C,[ASCIZ /TO:/]
	 CAMN C,[ASCIZ /CC:/]
	  JRST RSTTO			;Parse a to or cc list
	CAMN C,[ASCII /SUBJE/]
	 CAME D,[ASCIZ /CT:/]
	  JRST RSTRND			;Random line, insert as user option
RSTSB1:	ILDB T,B			;Flush whitespace
	CAIE T," "
	 CAIN T,11
	  JRST RSTSB1
	SKIPA C,[POINT 7,HDRPAG+700]	;Where the subject goes
RSTSB2:	 ILDB T,B
	CAIE T,15
	 CAIN T,12
	  JRST RSTSB3
	JUMPE T,RSTSB3
	IDPB T,C
	JRST RSTSB2
RSTSB3:	CAIN T,15
	 IBP B				;Move over LF after CR
	MOVEI D,0
	IDPB D,C
	JUMPN T,RSTLUP

RSTTXT:	MOVE A,TMPJFN
RSTTX0:	BIN
	JUMPE B,CLOSFR			;Eof, no text then
	CAIE B,15
	 CAIN B,12
	  JRST RSTTX0			;Flush CRLFs
	BKJFN
	 NOP
	JRST INSFL3			;And now insert the file as text

RSTRND:	PUSH P,E			;Save current line
	CALL USHDRL			;New header line
	POP P,B				;Get line again
RSTRN1:	ILDB T,B
	CAIE T,15
	 CAIN T,12
	  JRST RSTRN2
	JUMPE T,RSTRN2
	AOJGE E,USHDRE
	IDPB T,D
	JRST RSTRN1
RSTRN2:	DMOVEM D,USRHDR+2		;Update pointers
	JRST RSTSB3

RSTTO:	MOVE A,E			;Get start of line again
	PUSH P,RCCOTH			;Don't change type of message
	SETZM RCCOTH
	CALL PRTOCC			;Parse to and cc lines
	POP P,RCCOTH
	MOVE E,A
RSTTO1:	LDB B,E				;Now back up to start of line that didn't match
	CAIE B,15
	 CAIN B,12
	  JRST RESTO2
	JUMPE B,RSTTXT
	ADD E,[7B5]
	SKIPGE E
	 SUB E,[43B5+1]
	JRST RSTTO1

.HRCOP:	[ASCIZ/
The COPY command takes one argument, a filename, and copies the message
currently being read into that file.
/]
.HCOPY:	[ASCIZ/
The COPY command takes two arguments.  The first is a filename and the
second is a message sequence.  It copies the specified message sequence
into the given file leaving it intact in the current file.
/]
.HRMOV:	[ASCIZ/
The MOVE command takes one argument, a filename.  It moves the message
currently being read into that file and deletes the message.
/]
.HMOVE:	[ASCIZ/
The MOVE command takes two arguments.  The first is a filename and the
second is a message sequence.  It moves the specified message sequence into
the given file and deletes the sequence from the current file.
/]

;;;Move messages into files

.COPY:	SKIPA A,[PUTMSG]
.MOVE:	 MOVEI A,MOVMSG
	MOVEM A,DOMSG
	TRNE F,F%READ			;In read command?
	 JRST .RCOP1			;Yes
	CALL GETOUT			;Get output file
	CALL DFSQTH			;Get message sequence
	MOVE A,OUTJFN
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JRST [	MOVE A,OUTJFN
		RLJFN
		 NOP
		SETZM OUTJFN
		UERR 17,		;Give error message
		RET]
.COPY1:	CALL DELET1			;Go handle the sequence
.COPY2:	SKIPL RINCME			;Special include me mode?
	 JRST .COPY3			;No
	HRROI A,SAVFIL			;Yes, update name of last moved file
	MOVE B,OUTJFN
	SETZ C,
	JFNS
.COPY3:	MOVE A,OUTJFN
	CLOSF
	 JERROR (Can't close output file)
	SETOM OUTJFN
	RET

.RCOP1:	CALL GETOUT			;Get output file
	CONFRM
	MOVE A,OUTJFN
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JRST [	MOVE A,OUTJFN
		RLJFN
		 NOP
		SETZM OUTJFN
		UERR 17,		;Give error message
		RET]
.RCOP2:	CALL @DOMSG			;Process it
	JRST .COPY2			;And go close it up

.HRLIS:	[ASCIZ/
The LIST command prints the message currently being read on device LPT:
(usually the lineprinter).
/]
.HLIST:	[ASCIZ/
The LIST command takes one argument, a message sequence. It lists the
sequence on device LPT:, (usually the lineprinter).
/]
.HFILE:	[ASCIZ/
The FILE-LIST command is like LIST, except that it will ask you which file
you would like to LIST to.  After the file argument, it takes a message
sequence.
/]

.FLIST:	NOISE (ON FILE)
	MOVEI B,[FLDDB. .CMOFI]		;Get an output file
	CALL CMDFLD
	MOVEM B,OUTJFN
	CAIA
.LIST:	 SETZM OUTJFN			;Forget any old output file
	MOVEI A,LPTMSG
	MOVEM A,DOMSG
	TRNE F,F%READ
	 JRST .RLIS1
	CALL DFSQTH			;Get sequence
	CALL GETLPT			;Get LPT: file
	SKIPE LSTHDR			;Include headers in the list?
	 CALL .LISHD			;Yes, list them now
	JRST .COPY1

.LISHD:	CALL NXTMSG			;Else cycle through messages once
	 JRST .LIST2
	MOVEI A,M%DELE
	TDNE A,MSGBTS(M)		;Deleted?
	 JRST .LISHD			;Yes, skip it but dont complain this pass
	MOVE O,[POINT 7,WRTPGS]
	CALL TYPHD0
	MOVE A,OUTJFN
	HRROI B,WRTPGS
	SETZ C,
	SOUT
	JRST .LISHD

.LIST2:	MOVE A,OUTJFN			;All done, put this on one page
	HRROI B,[ASCIZ /
/]
	SETZ C,
	SOUT
	MOVEI B,CTL(L)			;Form feed
	BOUT
	HRROI B,[ASCIZ /
/]
	SOUT
	JRST GTSQNS			;And output messages from saved seq

.RLIS1:	NOISE (ON LINE-PRINTER)
	CONFRM
	CALL GETLP0
	JRST .RCOP2

.HRFOR:	[ASCIZ/
The FORWARD command forwards the message currently being read to a list of
addresses.  It will prompt you for the addresses with a To:
/]
.HFORW:	[ASCIZ/
The FORWARD command takes one argument, a message sequence.  It forwards the
messages in the sequence to an address which you specify after typing
carriage return.
/]

.RFORW:	CONFRM
	CAIA
.FORWA:	 CALL DFSQTH			;Get message sequence, default to this
	CALL SNDINI			;Reset message drafts
	CALL GETTO			;Get recipients
	CALL GETTXT			;Get initial comments
	SETZ A,				;Get canonical pointer to text field
	ADJBP A,TXTPTR
	CAMN A,[POINT 7,TXTPAG-1,34]	;Empty?
	 JRST .FORW1			;Yes, no initial dashes then
	LDB C,A				;Get last char
	MOVEI B,CRLF0
	CAIE C,12			;Unless have crlf
	 CALL MOVSTR			;Put one in
	MOVEI B,[ASCIZ /                ---------------
/]
	CALL MOVSTR
	MOVEM A,TXTPTR			;Update pointer
.FORW1:	TRNN F,F%READ			;If not in read
	 JRST .FORW2			;Handle list
	CALL FORMSG			;Forward current message
	JRST .FORW3			;Finish it up and return

.FORW2:	CALL NXTMSG			;Get next guy in list
	 JRST .FORW3
	CALL CHKDEL			;Dont forward deleted msgs
	 JRST .FORW2
	CALL FORMSG			;Forward this one too
	JRST .FORW2

.FORW3:	MOVE A,TXTPTR
	MOVEI B,[ASCIZ /                ---------------
/]
	CALL MOVST0
	ADD A,[7B5]			;Back over the null
	MOVEM A,TXTPTR
	JRST SEND0			;Maybe send it off or get more

;;;Remail a message to someone
.HREMA:	[ASCIZ/
The REMAIL command is similar to FORWARD, except instead of inserting
the message after typein, the message is sent as is with the header
modified to indicate who did the remailing.
/]
.RREMA:	CONFRM
	CAIA
.REMAI:	 CALL DFSQTH			;Get a sequence and default it
	CALL SNDINI			;Erase the message draft
	CALL GETTO			;Get the to: list
	TRNE F,F%READ			;In read mode?
	 JRST RMLMSG			;Yes, process it and return
	MOVEI A,RMLMSG
	JRST DOMSGS			;Handle list of messages

.HSYST:	[ASCIZ/
The SYSTEM-MSGS command will read in the system messages file
SYSTEM:MAIL.TXT.
/]
.MSGOD:	CONFRM
MSGOD1:	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,[ASCIZ /SYSTEM:MAIL.TXT.1/]
	GTJFN
	 ERROR (No system message file)
MSGOD2:	PUSH P,A			;Save jfn
	TRO F,F%MOD!F%RONL		;Flag for doing system mail
	TLZ F,(F%F1)			;Not the examine command
	JRST GETF1

.HBBOA:	[ASCIZ/
The BBOARD command will read in the bulletin board file <BBOARD>MAIL.TXT.
/]
.MSBBD:	CONFRM
MSBBD1:	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,[ASCIZ /PS:<BBOARD>MAIL.TXT.1/]
	GTJFN
	 ERROR (No BBOARD message file)
	JRST MSGOD2

MSGOD0:	CALL MSGOD1			;Setup for system mail
	MOVEI A,NXTNEW			;Setup sequencer
	MOVEM A,NXTMSD
	MOVNI M,MSGLEN
	MOVEI A,TYPE1			;Msg processing routine
	CALL DOMSGS			;Go do messages
	PUSH P,[GO]			;In case of continue
	JRST QUIT0			;And exit

.HWHEN:	[ASCIZ/
This command tells you the current date and time.
/]
.DAYTI:	CONFRM
	MOVEI A,.PRIOU
	SETOB B,C
	ODTIM				;Give us ye old daytime
	RET

.MSGSE:	.+1				;MACRO-10 cannot handle big literals
	ASCIZ\
A message sequence is a series of messages that have some trait in common.
The message sequences available are:

	 AFTER	    -  	 Messages after a given date (entered as
			 DATE/MONTH/YEAR
	 ALL	    -    Every message in your file, whether deleted or not.
	 BEFORE	    -	 Messages before a given date
	 CURRENT    -	 MM keeps a pointer to the current message it is
			 set at.  This sequence (which consists of only 1
			 message obviously) is that message.
	 DELETED    -    Messages you have marked for deletion with the
			 DELETE command or the MOVE command
	 FLAGGED    -    Messages you have marked with the FLAG command
	 FROM	    -	 Follow this with a word or phrase denoting the
			 the senders of the message. e.g. HEADERS FROM SMITH
			 would show all the headers of the messages you've
			 received from SMITH
	 INVERSE    -	 This is the exact opposite of ALL. Instead of
			 of taking the sequence as lowest message number to
			 highest, it takes it from highest to lowest
	 KEYWORDS   -	 Messages included in the specified keyword
	 LAST	    -	 Follow this with a number and this specifies the
			 last n messages in the file
	 NEW	    -	 Messages that are new as of this MM session
	 ON	    -	 Messages on a given date
	 RECENT	    -	 Messages that are recent, i.e. you've received
			 them and have looked at them but haven't started up MM
			 again
	 SEEN	    -	 Messages that you have seen. Normally, all messages
			 except new and recent messages are marked seen
	 SINCE	    -	 Messages since a certain date
	 SUBJECT    -	 Follow this with a word or phrase denoting the
			 subject of the message. e.g. HEADERS SUBJECT MEETING
			 would show you all the headers of the messages about
			 a meeting (assuming they say MEETING in the header)
	 TEXT	    -	 Follow this with a word, phrase or sentence denoting
			 the text of the message. e.g. HEADERS TEXT BIZARRE
			 would show you all the headers of the messages with
			 the word BIZARRE in their text
	 TO	    -	 Follow with the name of a recipient, shows messages
			 whose To or Cc fields contain that recipient.
	 UNANSWERED -	 Messages you have not REPLY'd to or ANSWER'd
	 UNDELETED  -    Messages that haven't been deleted via the DELETE or
			 MOVE commands
	 UNFLAGGED  -	 Messages that haven't been flagged by the FLAG command
	 UNKEYWORDS -	 Messages not included in the specified keyword
	 UNSEEN	    - 	 Messages you haven't seen via the READ or TYPE command

Also, message numbers are allowed to be specified as a sequence, i.e.
	1,2,3,5,8   -	 Messages 1,2,3,5, and 8
	1:3,7:10    -	 Messages 1 through 3 and 5 through 8
	5	    -	 Message number 5
\

.HRGEN:	.+1			;MACRO chokes on this as a literal
	ASCIZ/
You are currently at READ level, invoked by giving the READ command.  READ
allows you to process your new messages (or for that matter old ones) in a
sequential obvious manner. Type a ? for a list of the commands you can use
at this level. They represent a subset of the top level commands, and
unless otherwise specified each command operates only on the message you
are currently reading. For more information type HELP followed by ? for a
list of the things you can get help on here.
/

.HSGEN:	.+1			;MACRO chokes on this as a literal
	ASCIZ/
You are currently at SEND level, invoked by giving the SEND command.  SEND
allows you to compose a message to send to someone and edit the particular
fields of interest (subject, to-list, cc-list, bcc-list, text, etc.). You
may use your editor to edit the text by giving the text command. Note that
while typing text in you may type ^K to have what you have typed thus far
re-displayed, ^E to invoke your editor, and ^B to insert a file. To exit,
use ^Z or <ESC>. For more help, you can type HELP ? to get a list of the
commands help is available for at this level.
/
	
.GENER:	HRROI B,[ASCIZ /HLP:MM.HLP/]	;Note: hrroi = 561
	MOVSI A,(GJ%OLD!GJ%SHT)
	GTJFN
	 JRST NOHELP
	MOVEM A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JRST NOHLP0
HELP1:	MOVE A,TMPJFN
	BIN
	JUMPE B,HELP2
	MOVEI A,.PRIOU
	BOUT
	JRST HELP1

HELP2:	GTSTS
	TLNN B,(GS%EOF)			;Null, did we hit eof?
	 JRST HELP1			;No, spurious
CLSTMP:	SKIPG A,TMPJFN
	 RET
	CLOSF
CLSTM0:	 SKIPA A,TMPJFN
	  JRST CLSTM1
	RLJFN
	 NOP
CLSTM1:	SETOM TMPJFN
	RET

NOHLP0:	CALL CLSTM0
NOHELP:	JWARN (No help available)
	RET

.HELP:	NOISE (ON TOPIC)
	DEFALT (GENERAL)
	MOVEI A,H1CMDT			;Otherwise, help for top-level
	TRNE F,F%READ			;In read command?
	 MOVEI A,H1RCMD
	TRNE F,F%SEND			;In send command?
	 MOVEI A,H1SCMD
	CALL SUBCMD
	PUSH P,A
	CONFRM
	POP P,A
	SKIPG B,(A)			;Routine or fixed string?
	 JRST (A)			;Routine, go do it
	HRROI A,(B)
	PSOUT
	RET

;;Help for send-level

H1SCMD:	N1HSCM,,N1HSCM
	CMD (BCC,.HSBCC)
	CMD (BLANK,.HBLANK)
	CMD (CC,.HSCC)
	CMD (DISPLAY,.HSDISPLY)
	CMD (EDIT,.HSEDIT)
	CMD (ERASE,.HSERASE)
	CMD (GENERAL,.HSGENERAL)
	CMD (INSERT,.HSINSERT)
	CMD (LITERAL-TYPE,.HLSTY)
	CMD (MSG-SEQUENCE,.MSGSE)
	CMD (PUSH,.HPUSH)
	CMD (QUIT,.HSQUIT)
	CMD (REMOVE,.HSUNTO)
	CMD (RESTORE-DRAFT,.HREST)
	CMD (SAVE-DRAFT,.HSAVE)
	CMD (SEND,.HSSEND)
	CMD (SUBJECT,.HSSUBJECT)
	CMD (TEXT,.HSTEXT)
	CMD (TO,.HSTO)
	CMD (TYPE,.HSTYPE)
	CMD (USER-HEADER,.HUSER)
N1HSCM==.-H1SCMD-1

;; Help for read-level

H1RCMD:	N1HRCM,,N1HRCM
	CMD (BLANK,.HBLANK)
	CMD (CONTINUE,.HCONT)
	CMD (COPY,.HRCOPY)
	CMD (DELETE,.HRDELETE)
	CMD (EDIT,.HREDIT)
	CMD (FLAG,.HFLAG)
	CMD (FORWARD,.HRFORWARD)
	CMD (GENERAL,.HRGENERAL)
	CMD (KEYWORDS,.HKEYWORDS)
	CMD (LIST,.HRLIST)
	CMD (LITERAL-TYPE,.HLRTY)
	CMD (MOVE,.HRMOVE)
	CMD (MSG-SEQUENCE,.MSGSE)
ARPA,<
	CMD (NET-MAIL,.HMAILER)
>;ARPA
SPCH,<
	CMD (NET-MAIL,.HMAILER)
>;SPCH
	CMD (NEXT,.HNEXT)
	CMD (PREVIOUS,.HPREVIOUS)
	CMD (PUSH,.HPUSH)
	CMD (QUIT,.HSQUIT)
	CMD (REMAIL,.HREMA)
	CMD (REPLY,.HRREPLY)
	CMD (SEND,.HSEND)
	CMD (TYPE,.HRTYPE)
	CMD (UNDELETE,.HRUNDELETE)
	CMD (UNFLAG,.HRUNFLAG)
	CMD (UNKEYWORDS,.HUNKEYWORDS)
N1HRCM==.-H1RCMD-1

;;Help options for top-level stuff

H1CMDT:	N1HCMD,,N1HCMD
	CMD (ANSWER,.HANSWER)
	CMD (APPEND,.HAPPEND)
	CMD (BBOARD,.HBBOARD)
	CMD (BLANK,.HBLANK)
	CMD (BUG,.HBUG)
	CMD (CHECK,.HCHECK)
	CMD (CONTINUE,.HCONT)
	CMD (COPY,.HCOPY)
	CMD (CREATE-INIT,.HCRINI)
	CMD (DAYTIME,.HWHEN)
	CMD (DELETE,.HDELETE)
	CMD (DIRED,.HDIRED)
	CMD (EDIT,.HEDIT)
	CMD (ENABLE,.HENABLE)
	CMD (EXAMINE,.HEXAMINE)
	CMD (EXIT,.HEXIT)
	CMD (EXPUNGE,.HEXPUNGE)
	CMD (FILE-LIST,.HFILE)
	CMD (FLAG,.HFLAG)
	CMD (FORWARD,.HFORWARD)
	CMD (GENERAL)
	CMD (GET,.HGET)
	CMD (HEADERS,.HHEADERS)
	CMD (JUMP,.HJUMP)
	CMD (KEYWORDS,.HKEYWORDS)
	CMD (LIST,.HLIST)
	CMD (LITERAL-TYPE,.HLTYP)
	CMD (LOGOUT,.HLOGO)
	CMD (MARK,.HMARK)
	CMD (MOVE,.HMOVE)
	CMD (MSG-SEQUENCE,.MSGSE)
ARPA,<
	CMD (NET-MAIL,.HMAILER)
>;ARPA
SPCH,<
	CMD (NET-MAIL,.HMAILER)
>;SPCH
	CMD (NEXT,.HNEXT)
	CMD (PREVIOUS,.HPREVIOUS)
	CMD (PROFILE,.HPROFILE)
	CMD (PUSH,.HPUSH)
	CMD (QUIT,.HQUIT)
	CMD (READ,.HREAD)
	CMD (REMAIL,.HREMA)
	CMD (REPLY,.HANSWER)
	CMD (RESTORE-DRAFT,.HREST)
	CMD (SEND,.HSEND)
	CMD (SET,.HSET)
	CMD (STATUS,.HSTATUS)
	CMD (SYSTEM-MSGS,.HSYSTEM)
	CMD (TYPE,.HTYPE)
	CMD (UNDELETE,.HUNDELETE)
	CMD (UNFLAG,.HUNFLAG)
	CMD (UNKEYWORDS,.HUNKEYWORDS)
	CMD (UNMARK,.HUNMARK)
	CMD (VERSION,.HVERSION)
N1HCMD==.-H1CMDT-1

.HENAB:	[ASCIZ/
The ENABLE command enables your capabilities (if you have any.)
/]
.ENABL:	NOISE (CAPABILITIES)
	CONFRM
	TRZ F,F%RONL			;This may let us munge a file
	MOVEI A,.FHSLF
	SETO C,
	EPCAP
	RET

.HQUIT:	[ASCIZ/
The QUIT command quits out of MM without erasing any deleted messages.
/]
.QUIT:	CONFRM
QUIT0:	CALL UNMAPF			;Unmap old file
	SKIPG MSGJFN			;If we don't have a jfn,
	 JRST QUIT1			;Don't try to close it
	DMOVE A,[.DEQID			;Get rid of any locks we got
		 REQID]
	DEQ
	 ERJMP .+1			;Ignore failure
	MOVE A,MSGJFN
	TLO A,(CO%NRJ)			;Don't release jfn
	CLOSF				;Close file
	 NOP
QUIT1:	CALL CLOSF1
	HALTF				;Quit back to the EXEC
NOREL4,<
;  This test tries to catch the mail file jfn being yanked out from under us.
; Evidentally restricted jfn's aren't implemented in release 3.  Unfortunately,
; this test isn't really paranoid enough, since another jfn could have taken
; its place.  In that case, however, PARSEF would probably barf completely.
	SKIPG B,MSGJFN			;If we have jfn,
	 RET
	MOVEI A,.NULIO			;Make sure jfn still there
	SETZB C,D
	JFNS
	 ERJMP [SETZM MSGJFN		;No jfn there, give up
		JRST GETFIL]
	MOVE A,MSGJFN			;Get jfn in A
>;NOREL4
REL4,<	; This bug is fixed in release 4
	SKIPG A,MSGJFN			;If we have jfn,
	 RET
>;REL4
	PUSH P,M			;Save current message number
	PUSH P,LASTM			;And total number of messages
	TRO F,F%AMOD			;Hack to not print stuff
	CALL GETF3			;Get file back
	TRZ F,F%AMOD			;Undo mischief
	MOVE A,-1(P)			;Range check saved current message
	CAML A,LASTM
	 SETZM -1(P)			;Else go to the beginning i guess
	JRST CHECKN			;Print any new messages

.HBUG:	[ASCIZ/
The BUG command can be used to report problems or suggestions you have for
MM to the maintainers of MM.  Basically, BUG puts you into SEND-MODE with a
predefined list of addresses to send the bug to.  You send it the normal
way you would send a message.  The response may take a short while, e.g.
several days.
/]
.BUG:	CONFRM
	CALL SNDINI			;Setup for sending a message
	MOVE A,[POINT 7,BUGLST]
	SETZ E,
	TLZ F,(F%CC)			;As to recipients
	CALL PRADDT			;Process list of bug report recipients
COL,<
	MOVE A,[POINT 7,[ASCIZ /Remarks/]]
	SETZ E,
	TLO F,(F%CC)			;As cc recipient
	CALL PRADDT			;Put this list in
>;COL
RUTG,<
	MOVE A,[POINT 7,[ASCIZ /Remarks/]]
	SETZ E,
	TLO F,(F%CC)			;As cc recipient
	CALL PRADDT			;Put this list in
>;RUTG
	MOVE A,[POINT 7,HDRPAG+700]
	MOVEI B,[ASCIZ /Bug in/]
	CALL MOVSTR			;Setup default subject for this
	PUSH P,A
	CALL GETVER			;Tell what version is buggy
	POP P,A
	MOVEI B,STRBUF
	CALL MOVST0
	JRST .REPL4			;Display it and get the text of bug

.HVERS:	[ASCIZ/
The VERSION command shows the version number of the current MM, including
its configuration.
/]
.VERSI:	CONFRM
DEC,<	CITYPE (DEC default)>;DEC
CLSC,<	CITYPE (Utah College of Science)>;CLSC
COL,<	CITYPE (Columbia)>;COL
DREA,<	CITYPE (D.R.E.A.)>;DREA
GSB,<	CITYPE (Stanford GSB)>;GSB
HP,<	CITYPE (Hewlett-Packard)>;HP
ISI,<	CITYPE (USC-ISI)>;ISI
LOTS,<	CITYPE (Stanford LOTS)>;LOTS
XX,<	CITYPE (MIT-XX)>;XX
SPCH,<	CITYPE (MIT Speech)>;SPCH
RUTG,<	CITYPE (Rutgers)>;RUTG
SCOR,<	CITYPE (Stanford SCORE)>;SCOR
SRI,<	CITYPE (SRI)>;SRI
SUMX,<	CITYPE (SUMEX)>;SUMX
UTAH,<	CITYPE (UTAH-20)>;UTAH
	CALL .VERS1
REL4,<	CITYPE (TOPS-20 release 4 support)>;REL4
ARPA,<	CITYPE (ARPANET support)>;ARPA
DECN,<	CITYPE (DECnet support)>;DECN
HOSTS2,<CITYPE (HOSTS2 host table support)>;HOSTS2
IPCF,<	CITYPE (IPCF mailer for local mail)>;IPCF
NEWQ,<	CITYPE (XMAILR multi-network mailer)>;NEWQ
	RET

.VERS1:	CALL GETVER
	UTYPE STRBUF
	RET

.HSET:	[ASCIZ/
The SET command allows you to change certain defaults that MM uses in
handling your messages. To see the various possibilities you can do SET ?.
This command can be used in conjunction with the the CREATE-INIT command.
You could first type CREATE-INIT and then edit the resultant MM.INIT in
your directory (see HELP CREATE-INIT for more information) or you can SET
variables and then type CREATE-INIT which will put out those defaults in
MM.INIT.
/]
.VARIA:	NOISE (VARIABLE)
	MOVEI B,[FLDDB. .CMKEY,,INIVTB]
	CALL CMDFLD			;Get the name of the variable
	HRRZ T,(B)
	MOVE T,(T)			;Get pointer to variable
	NOISE (TO)
	HLRE N,T			;Get length of string
	JUMPE N,.VRNUM			;Not a string, get a number
	CALL GETLIN			;Read a line
	JUMPG N,[MOVEI U,(T)		;Do routine if specified
		 MOVE T,[POINT 7,STRBUF]
		 JRST (N)]
	HRROI A,(T)			;Where it goes
	HRROI B,STRBUF
	MOVE C,N
	SOUT				;Move the guy over
	RET

.VRNUM:	MOVEI B,[FLDDB. .CMNUM,,10]
	CALL CMDFLD
	PUSH P,B
	CONFRM
	POP P,(T)
	RET

SUBTTL Command subroutines

;;; Once only type initialization
INIT:	MOVEI A,.CTTRM
	GTTYP
	MOVEM B,TTYPE
	MOVEI D,SAVMOD
	CALL GETTYM			;Get current tty modes
	TRZ C,3B19			;Dont echo esc
	SFCOC
	MOVEM C,2(D)
	MOVEI A,.FHSLF			;Setup interrupt stuff
	RPCAP
	TRZ B,-1			;Only enable lh caps at first
	IOR C,B
	EPCAP
	MOVE B,[LEVTAB,,CHNTAB]
	SIR
	EIR
	MOVSI B,(3B5)			;^N and timer chans
	AIC
	CALL SETTIM			;Set up timer interrupt
	GJINF
	DMOVEM A,MYDIR			;Save directory
	MOVE B,A
	HRROI A,MYDIRS			;Temp name for speed
	DIRST
	 NOP
	RET

.RFLAG:	CONFRM
FLGMSG:	SKIPA A,[M%ATTN]		;Flag message
REPMSG:	 MOVEI A,M%RPLY			;Mark as replied to
	JRST SETBIT

.RDELM:	CONFRM				;Confirm first
DELMSG:	SKIPA A,[M%DELE]		;Mark as deleted
MRKMSG:	 MOVEI A,M%SEEN			;Mark as seen
SETBIT:	IORM A,MSGBTS(M)
	JRST UPDBIT			;Go update the message bits, maybe

.RUFLG:	CONFRM
UFLMSG:	MOVEI A,M%ATTN			;Unflag message
	JRST CLRBIT

.RUDLM:	CONFRM
UNDMSG:	SKIPA A,[M%DELE]		;Mark as undeleted
UMKMSG:	 MOVEI A,M%SEEN			;Mark as unseen
CLRBIT:	ANDCAM A,MSGBTS(M)
	JRST UPDBIT			;Go update the message bits, maybe

.RUKEY:	CALL GETKEY			;Remove keywords
	HLRM U,KEYBTS			;Save mask bits
	CONFRM
UNKMSG:	HRLZ A,KEYBTS
	JRST CLRBIT

.RKEYW:	CALL GETKEY			;Add keywords
	HLRM U,KEYBTS
	CONFRM
KEYMSG:	HRLZ A,KEYBTS
	JRST SETBIT

GETOUT:	NOISE (INTO FILE)		;Get an output file
	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]
	BLT A,CMDGTB+.GJATR		;Default to saved msgs file if any
NOREL4,<
	SKIPN SAVFIL
	 SKIPA B,[[FLDDB. .CMFIL,CM%SDH,,<-1,,[ASCIZ/output filespec/]>]]
>;NOREL4
	  MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<-1,,[ASCIZ/output filespec/]>,<-1,,SAVFIL>]
	CALL CMDFLD			;Get the file
	MOVEM B,OUTJFN			;Save it
	RET

GETLPT:	SKIPLE A,OUTJFN
	 JRST GETLP1			;Use specified file
GETLP0:	MOVSI A,(GJ%FOU!GJ%SHT)
	HRROI B,[ASCIZ /LPT:/]
	GTJFN
	 JERROR (Can't get LPT)
GETLP1:	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Can't open LPT)
	MOVEM A,OUTJFN
	RET

MOVMSG:	CALL CHKDEL			;Is it deleted?
	 RET				;Yes, then don't move it
	CALL PUTMS1			;No, go ahead and move it
	CALL DELMSG			;And delete it afterwards
	RET

LPTMSG:	CALL CHKDEL
	 RET
	CALL PUTMS1			;Output the message
	SKIPN LSTPAG			;Separate pages?
	 RET				;No, done
	HRROI B,[ASCIZ /
/]
	SETZ C,
	SOUT				;Yes, output formfeed after each one
	MOVEI B,CTL(L)
	BOUT
	HRROI B,[ASCIZ /
/]
	SOUT
	RET

PUTMSG:	CALL CHKDEL			;Not deleted msgs
	 RET
PUTMS1:	MOVE V,MSGALL(M)		;Get start of the message
	CALL CHR2BP
	MOVE B,A
	MOVN C,MSGSAL(M)		;Length
	MOVE A,OUTJFN			;Where it goes
	SOUT				;That's it
	RET

;;; Make up the correct subject for a reply to the current message
REPSUB:	SKIPN A,MSGSUB(M)
	 RET				;No subject
	MOVE B,[POINT 7,STRBUF]
	CALL FORMSS			;Move it to temp space
	SETZ D,
	IDPB D,B			;And a null
	MOVE A,STRBUF			;Get start of it
	ANDCM A,[<BYTE (7) 40,40,0,0,177>+1];Uppercase and clear last byte
	CAMN A,[ASCIZ /RE: /]		;Already a response?
	 JRST REPSB1			;Yes, dont propogate Re: 's
	MOVE A,[ASCIZ /Re: /]
	MOVEM A,HDRPAG+700		;Start subject off right
	SKIPA A,[POINT 7,HDRPAG+700,27]	;Start going into last byte
REPSB1:	 MOVE A,[POINT 7,HDRPAG+700]	;Start at start of subject
	MOVEI B,STRBUF			;From here
	JRST MOVST0			;Move it and the null

;;; Forward the current message
FORMSG:	SKIPN A,MSGFRM(M)		;Has an author?
	 JRST FORMS2			;No
	MOVE B,[POINT 7,HDRPAG+700]
	MOVEI C,"["
	IDPB C,B
	CALL FORMSS
	MOVEI C,":"
	IDPB C,B
	SKIPN A,MSGSUB(M)
	 JRST FORMS1
	MOVEI C," "
	IDPB C,B
	CALL FORMSS
FORMS1:	MOVEI C,"]"
	IDPB C,B
	SETZ C,
	IDPB C,B
FORMS2:	MOVE A,MSGBOD(M)		;Body of the message
	MOVE B,TXTPTR
	CALL FORMSS
	MOVEM B,TXTPTR
	RET

;;;Output the portion of the message pointed to by A into byte pointer in B
FORMSS:	HLRZ C,A
	JUMPE C,CPOPJ			;None to do
	MOVEI V,(A)			;Get byte offset of field
	CALL MCH2BP			;Get byte pointer to it
FRMSS1:	ILDB D,A			;Get char
	SKIPE D				;Never put in a null
	 IDPB D,B
	SOJG C,FRMSS1
	RET

;;;Remail a single message
RMLMSG:	CALL .ERSTX			;Erase vestiges of previous REMAIL
	HRRZ V,MSGBOD(M)		;Get pointer to message body
	CALL MCH2BP
	HLRZ C,MSGBOD(M)		;Length of it
	MOVE B,[POINT 7,HDRPAG]		;Start of some headers
	MOVEI E,12			;Start at new line
RMLMS1:	SOJL C,[ERROR (Badly formatted message)]
	ILDB D,A			;Get character
	IDPB D,B			;Stick it in
	EXCH D,E
	CAIN E,15			;This char a CR?
	 CAIE D,12			;And previous LF
	  JRST RMLMS1			;No, continue
	ADD B,[7B5]
	MOVEM B,RMLPTR			;This is the pointer to end of headers
	SOJL C,RMLMS2			;If there is more text
	IBP A				;Move over the LF
	MOVE B,TXTPTR			;Move the rest of it into text
	CALL FRMSS1
	MOVEM B,TXTPTR			;Update text pointer
	IDPB C,B			;Make sure it ends with a null
RMLMS2:	JRST SNDMSG			;Go send the message off

;;;Replace current message

RPLMSG:	PUSH P,A			;Save byte pointer
	PUSH P,C			;And byte count
	CALL GETJF2			;Get a write jfn
	 JRST POPCA			;Failed
	MOVEM A,OUTJFN			;Save it here as well
	MOVE B,MSGALL(M)		;Get start of whole message
	IDIVI B,5000			;Round down to start of page
	PUSH P,C			;Save remainder
	IMULI B,5000			;Set to start of page
	SFPTR
	 JERROR
	MOVE V,MSGALL(M)
	CALL CHR2BP			;Get byte pointer to message
	MOVE E,A			;Save it
	ANDI A,777000			;Get page number of start
	PUSH P,A			;Save start of core page
	MOVEI B,-MSGPAG*1000(A)		;Get page offset
	LSH B,-9
	PUSH P,B			;Save starting disk page
	HRRZ C,FILPGS			;Get number of pages in the file
	SUBI C,(B)			;Less where we started
	PUSH P,C			;Save count
RPLMS0:	MOVES (A)			;Make all pages after that private
	ADDI A,1000
	SOJG C,RPLMS0
;;;Remove the old pages from the file
	SETO A,				;Remove these pages from file
	POP P,C				;Count
	TLO C,(PM%CNT)
	POP P,B				;Starting page
	HRL B,MSGJF2			;JFN
	PMAP				;Kill the old copies from file
;;;Copy from start of first page up to message we are concerned with
	HRRZ A,MSGJF2			;Get write jfn again
	POP P,B				;Start of first page
	TLO B,-1			;Make byte pointer
	POP P,C				;Count
	MOVN C,C			;Negate: use exact count
	SKIPE C				;Forget if count=0
	 SOUT				;Copy to file
;;;Now put out revised message
RPLMS1:	ILDB B,E			;Get character
	BOUT
	CAIE B,","			;Until start of byte count
	 JRST RPLMS1
	MOVE B,(P)			;New byte count
	MOVEI C,^D10
	NOUT
	 JERROR
RPLMS2:	ILDB B,E
	CAIE B,";"			;Now look for start of message bits
	 JRST RPLMS2
RPLMS3:	BOUT
	ILDB B,E
	CAIE B,12			;Until end of line
	 JRST RPLMS3
	BOUT				;And that as well
	MOVE B,-1(P)			;Get byte pointer
	MOVN C,(P)			;And byte count
	SOUT				;Put that in now
	PUSH P,M			;Save current message
	ADDI M,MSGLEN
RPLMS4:	CAMLE M,LASTM			;Reached end of file?
	 JRST RPLMS5			;Yes
	CALL PUTMS1			;Move this into file
	ADDI M,MSGLEN
	JRST RPLMS4			;For all messages

RPLMS5:	MOVE A,OUTJFN
	RFPTR
	 JFATAL
	HRLI A,.FBSIZ
	MOVE C,B			;Current position
	SETO B,
	CHFDB				;Make this the new end of the file
	CALL CLSJF2			;Close off file
	CALL SIZFIL			;Get its new size info
	MOVE M,(P)			;Get back current message
	CALL PARSEF			;Reparse the file
	JRST POPMCA			;Restore current message and return

;;;Get TTY modes

GETTYM:	MOVEI A,.FHJOB			;Get job's interrupt word
	RTIW
	DMOVEM B,3(D)
	MOVEI A,.PRIOU
	RFMOD
	MOVEM B,0(D)
	RFCOC
	DMOVEM B,1(D)
	RET

;;;Set TTY modes

SETTYM:	MOVEI A,.FHJOB
	DMOVE B,3(D)
	STIW
	 ERJMP .+1
	MOVEI A,.PRIOU
	MOVE B,0(D)
	SFMOD
	DMOVE B,1(D)
	SFCOC
	RET

.HCHEC:	[ASCIZ/
The CHECK command is used to check for new messages that may have arrived
while you are using MM.
/]
.CHECK:	NOISE (FOR NEW MESSAGES)
	CONFRM
CHECKT:	SETZM CHKTIM			;Force check now.

;;;Check for new messages periodically

CHECK:	CALL CHECK0			;Check for new messages
	 RET				;None

;;;Print message when there are new guys

CHECKS:	MOVE A,MSGJFN
	CALL SETREF			;Set read date
	PUSH P,M			;Save current message
	MOVE M,LASTM			;Start at the end
	PUSH P,M			;Save number of messages
	ADDI M,MSGLEN			;From that one on,
	CALL PARSEF			;Parse these new ones
CHECKN:	POP P,A				;Get old number
	SUB A,LASTM			;Get number of new guys
	JUMPE A,POPMJ			;None - someone's mucking with the file
	IDIVI A,MSGLEN
	MOVM A,A
	MOVEI B,[ASCIZ /are/]
	CAIN A,1
	 MOVEI B,[ASCIZ /is/]
	CIETYP < There %2S %1D additional message%1P
>
	CALL RECENT			;Give the headers of the recent ones
	JRST .STAT1			;Restore current message and tell user

POPMJ:	POP P,M				;Restore current message
	RET

CHECK0:	GTAD
	CAMGE A,CHKTIM			;Time we had a look?
	 RET				;Nope, back to work then
	ADDI A,<5B17/^D<24*60>>		;Five minutes from now
	MOVEM A,CHKTIM			;Is next time to look
	SKIPG MSGJFN			;Have a file?
	 JRST CHKNEW
	PUSH P,FILSIZ			;Save current size
	CALL SIZFIL			;Get the current poop on it
	POP P,T				;Get back old size
	MOVE A,FILWRT
HP,<
	CAML A,LASTRD			;Both dates updated on HP andMIT
>;HP
MIT,<
	CAML A,LASTRD
>;MIT
NOMIT,<
NOHP,<
	CAMLE A,LASTRD			;Written since last read?
>;NOHP
>;NOMIT
	 CAMN T,FILSIZ			;And size changed?
	  RET				;No, nothing changed
	JRST CPOPJ1			;Yes, skip return

;;;Check if MAIL.TXT has been undeleted

CHKNEW:	TLO F,(F%F1)
	CALL FNDFL0			;Has it?
	 RET				;Nope, return
	SKIPN FILSIZ			;If file is empty, ignore it
	 JRST [	RLJFN			;Get rid of the file
		 NOP			;Ignore failure
		RET]
	TRNE F,F%RONL			;Read-only file?
	 JRST CHKNW3			;Yes, don't lock
	MOVSI A,(EN%SHR!EN%BLN)		;Shared access, no level #'s
	HRR A,MSGJFN			;This file
	MOVEM A,ENQBLK+.ENQLV
CHKNW2:	DMOVE A,[.ENQAA			;Try and get lock, but don't wait
		 ENQBLK]
	ENQ
	 ERJMP [WARN (File is locked, waiting...)
		MOVEI A,^D5000		;Wait a bit
		DISMS
		JRST CHKNW2]		;Now try again
CHKNW3:	MOVNI A,MSGLEN			;Flag for full parse
	MOVEM A,LASTM
	SETZ M,
	JRST CPOPJ1

;;;Build string of version number in strbuf

GETVER:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ / MM Version /]
	CALL MOVSTR
	LDB B,[POINT 9,VERNUM,11]
	JUMPE B,GTVER1
	MOVEI C,10
	NOUT
	 NOP
GTVER1:	LDB B,[POINT 6,VERNUM,17]
	JUMPE B,GTVER3
	SUBI B,1
	IDIVI B,^D26
	JUMPE B,GTVER2
	ADDI B,"A"-1
	IDPB B,A
GTVER2:	ADDI C,"A"
	IDPB C,A
GTVER3:	HRRZ B,VERNUM
	JUMPE B,GTVER4
	MOVEI C,"("
	IDPB C,A
	MOVEI C,10
	NOUT
	 NOP
	MOVEI C,")"
	IDPB C,A
GTVER4:	LDB B,[POINT 3,VERNUM,2]
	JUMPE B,GTVER5
	MOVEI C,"-"
	IDPB C,A
	MOVEI C,10
	NOUT
	 NOP
GTVER5:	MOVEI C,0			;Put null in at end
	IDPB C,A
	RET

SUBTTL Lower level subroutines

;;;Move a string from B to A

MOVSTR:	HRLI B,(<POINT 7,0>)
MOVST1:	ILDB C,B
	JUMPE C,MOVST3
	IDPB C,A
	JRST MOVST1

;;;Move string and terminating null

MOVST0:	HRLI B,(<POINT 7,0>)
MOVST2:	ILDB C,B
	IDPB C,A
	JUMPN C,MOVST2
MOVST3:	RET

;;;Unmap pages from file

UNMAPF:	SETO A,
	MOVE B,[.FHSLF,,MSGPAG]
	HRRZ C,FILPGS			;Number of pages
	HRLI C,(PM%CNT)
	PMAP
	RET

;;;Close the file

CLOSEF:	SKIPG MSGJFN
	 JRST CLOSF1
	DMOVE A,[.DEQID			;Get rid of any locks we got
		 REQID]
	DEQ
	 ERJMP .+1			;Ignore failure
	MOVE A,MSGJFN
	CLOSF
	 NOP
	SETOM MSGJFN
CLOSF1:	SKIPLE A,MSGJF2
	 RLJFN
	  NOP
	SETOM MSGJF2
	RET

SUBTTL Interrupt routines

;;;Timer interrupt

TMRINT:	MOVEM 16,INTACS+16
	MOVEI 16,INTACS
	BLT 16,INTACS+15
	CALL SETTIM			;Set next timer up
	SKIPE OKTINT			;OK for timer at this time?
	 JRST TMRIN1			;Yes, check for new messages
TMRIN2:	MOVSI 16,INTACS
	BLT 16,16
	DEBRK				;No, return

SETTIM:	MOVE A,[.FHSLF,,.TIMEL]		;Elapsed time
	MOVEI B,^D<1*60*1000>		;1 min
	MOVEI C,5			;Chan 5
	TIMER
	 NOP
	RET

TMRIN1:	SETZM CHKTIM			;Force ...
	CALL CHECK0			;Check for new guys
	 JRST TMRIN2			;None, return for commands
	CIS				;Clear out interrupt
	MOVEI D,SAVMOD
	CALL SETTYM			;Restore tty modes
	CALL CHECKS			;Print message on new guys
	JRST @CMDRET			;And return to command

;;;^N interrupt routines

SETABO:	MOVE A,[.TICCN,,4]		;Assign ^N on chan 4
	ATI
	RET

CLRABO:	MOVEI A,.TICCN			;Deassign abort interrupt
	DTI
	RET

ABOINT:	PUSH P,A			;Here on actual interrupt
	SKIPGE A,ABOFLG			;Never abort?
	 JRST ABOIN1			;Yes, just return
	JUMPG A,ABOIN2			;Always abort
	CALL CRIF
	HRROI A,[ASCIZ /Abort? /]
	PSOUT
	MOVEI A,.PRIIN
	CFIBF
	PUSH P,B
	RFMOD
	PUSH P,B
	TRO B,TT%WAK			;Wakeup on everything
	SFMOD
	BIN
	EXCH B,(P)
	SFMOD
	POP P,A
	POP P,B
	CAIE A,"Y"
	 CAIN A,"y"
	  JRST ABOIN2			;Ok to abort
	CALL CRIF
ABOIN1:	POP P,A				;Don't abort
	DEBRK

ABOIN2:	MOVEI A,.TICCN			;Dont allow any more
	DTI
	CIS				;Abort back to command level
	MOVEI A,.PRIIN			;Make sure TTY input buffer empty
	CFIBF
	 ERJMP .+1
	MOVEI A,CMDRES			;Restore return address
	TRNE F,F%READ
	 MOVEI A,REDRET
	HRRM A,CMDRET
	SETZM CMDFLB+.CMDEF		;Clear any default setup during this
	JRST (A)

SUBTTL File parsing subroutines

GETFIL:	CALL FNDFIL			;Try to find it first
	 RET				;Not there, forget it
GETFL1:	SKIPN FILSIZ			;Is the file empty?
	 JRST [	MOVE A,MSGJFN		;Yes, get JFN for error message
		CIETYP (There are no messages in %1J.)
		RLJFN			;Get rid of the jfn
		 NOP
		SETOM MSGJFN		;Save we haven't seen it
		JRST CMDRES]
	TRNE F,F%RONL			;Read-only file?
	 JRST GETFL3			;Yes, don't lock
	MOVSI A,(EN%SHR!EN%BLN)		;Shared access, no level #'s
	HRR A,MSGJFN			;This file
	MOVEM A,ENQBLK+.ENQLV
GETFL2:	DMOVE A,[.ENQAA			;Try and get lock, but don't wait
		 ENQBLK]
	ENQ
	 ERJMP [WARN (File is locked, waiting...)
		MOVEI A,^D5000		;Wait a bit
		DISMS
		JRST GETFL2]		;Now try again
GETFL3:	SETZ M,				;Parse all messages
	JRST PARSEF			;Now return

;;;Try to find a MAIL.TXT

FNDFIL:	TLZ F,(F%F1)			;Ok to type messages if none there
FNDFL0:	CALL CLOSEF			;Get rid of old file perhaps
	SKIPGE GTCNDR			;Always get login directory?
	 JRST FNDFL7			;Yes, force that then
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,[ASCIZ /MAIL.TXT.1/]
	GTJFN
	 JRST FNDFL2			;Not there, try login directory
	MOVEM A,MSGJFN			;Save the jfn away
	MOVE C,MYDIR
	TLO C,040000			;Make login user look like directory
	MOVE B,MYCDIR			;Ready to compare logged vs conncted
	SKIPG GTCNDR			;Always get connected directory?
	 CAMN C,B			;Are they the same?
	  JRST FNDFL1			;Yes, then go ahead and read it
	TLNE F,(F%F1)
	 JRST FNDFL1
	CIETYP <You are connected to directory %2U.>
	PROMPT <Read MAIL.TXT here?>	;Get extra confirmation
	CALL YESNO
	 JRST [	MOVE A,MSGJFN		;Answer was no.  Do login directory
		RLJFN
		 NOP
		SETZM MSGJFN
		SETOM GTCNDR		;Make sure get from login at check time
		MOVE C,MYDIR
		TLO C,040000		;Make login user look like directory
		CIETYP <Trying %3U...>
		JRST FNDFL7]
FNDFL1:	CALL SIZFIL			;Get the size of the file, etc.
	MOVEI B,OF%RD			;Try to open it
	OPENF
	 JRST FNDFL5
CPOPJ1:	AOS (P)				;Skip return
	RET

;;; Here to get a YES or NO reply
YESNO1:	MOVEI B,[FLDDB. .CMKEY,CM%SDH,<[2,,2
		 [ASCIZ /NO/],,0
		 [ASCIZ /YES/],,-1]>,<
		 POINT 7,[ASCIZ/YES or NO/]>]
	SKIPA A,[YESNO1]
YESNO:	 DMOVE A,[YESNO			;Set reparse address back to here
		  [FLDDB. .CMKEY,CM%SDH,<[2,,2
		   [ASCIZ /NO/],,0
		   [ASCIZ /YES/],,-1]>,<
		   POINT 7,[ASCIZ/YES or NO/]>,<POINT 7,[ASCIZ/YES/]>]]
	HRRM A,CMDBLK+.CMFLG
	MOVEI A,CMDBLK
	COMND
	TLNE A,(CM%NOP)			;Make sure valid answer
	 JRST YESNOE
	HRRE D,(B)			;Get answer
	MOVEI B,[FLDDB. .CMCFM]		;Make sure confirmed
	COMND
	TLNE A,(CM%NOP)
	 JRST YESNOE
	JUMPN D,CPOPJ1
	RET

YESNOE:	CITYPE <?Please answer YES or NO>
	SOS (P)
	SOS (P)
	RET

;;;Get another message file

.HGET:	[ASCIZ/
The GET command takes one argument, a filename.  It will read in that
message file, parse the messages and act as if that were the default
message file.  All commands now apply to that file.
/]
.HEXAM:	[ASCIZ/
The EXAMINE command takes one argument, a filename.  It is like the
GET command, except that the file is read-only, and the file reference
date is not updated.  Any command which alters the file is a no-op.
/]

.EXAMI:	TLOA F,(F%F1)			;Examine command
.GET:	 TLZ F,(F%F1)			;Get command
	NOISE (MSGS FROM FILE)
	CALL GETJFN
	PUSH P,A			;Save jfn
	CONFRM
	TRZ F,F%AMOD!F%MOD!F%RONL	;Not hacking system mail any more
	TLNE F,(F%F1)
	 TRO F,F%RONL			;Read only for examine command
GETF1:	SKIPG MSGJFN			;Any current file?
	 JRST GETF2			;No, dont need to unmap then
	CALL UNMAPF			;Unmap old file
	CALL CLOSEF			;Release old cruft
GETF2:	POP P,MSGJFN			;Restore new msgjfn
GETF3:	CALL SIZFIL			;And the size
	MOVEI B,OF%RD			;Read access
	TLNE F,(F%F1)			;Examine command?
	 TRO B,OF%PDT			;Yes, dont update anything
	OPENF
	 JRST [	UERR 17,[ASCIZ /Can't open file/]
		JRST FNDFL4]
	CALL GETFL1			;Get file and parse it, barf if empty
	TRNN F,F%AMOD			;Unless auto mod
	 TRNN F,F%MOD			;Mod prints headers
	  TRNE F,F%RSCN			;Allow return to top-level
	   TLOA F,(F%F1)		;Type headers if from command line
	    TLZ F,(F%F1)
	CALL RECEN0
	TRNN F,F%AMOD			;No summary if auto mod
	 CALL SUMMRY
	TRZ F,F%RSCN
	RET

FNDFL2:	GJINF				;See if there is one elsewhere
	MOVEM B,MYCDIR			;Keep this updated
	TLO A,040000			;Make look like directory
	CAMN A,B			;Different?
	 JRST FNDFL3			;No, no MAIL.TXT then
	TLNN F,(F%F1)			;Supress messages?
	 CIETYP < No MAIL.TXT in %2U, trying %1U...>
FNDFL7:	MOVE A,[POINT 7,FILNAM]		;Get string pointer
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Login directory string
	CALL MOVSTR
	MOVEI B,[ASCIZ />MAIL.TXT.1/]
	CALL MOVST0
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,FILNAM
	GTJFN
	 JRST FNDFL3
	MOVEM A,MSGJFN
	JRST FNDFL1

FNDFL3:	TLNN F,(F%F1)			;Suppress messages here?
	 CITYPE ( You have no MAIL.TXT.)
FNDFL4:	SETOB A,MSGJFN			;Get rid of stray jfns
	RLJFN
	 NOP
	JRST CMDRES

FNDFL5:	TLNN F,(F%F1)
	 CITYPE ( Can't open MAIL.TXT)
	JRST FNDFL4

;;;Get size of current file

SIZFIL:	MOVE A,MSGJFN
	MOVE B,[5,,.FBBYV]
	MOVEI C,FILPGS
	GTFDB				;Get the size stuff
	 ERJMP [UERR 17,
		RET]
	TRNN F,F%MOD			;Getting system mail?
	 JRST SIZFL1			;No
	SETO A,				;This job
	HRROI B,LASTRD			;Where to stick info
	MOVEI C,.JILLN			;Get time of last login
	GETJI
	 SETZM LASTRD
	MOVE A,MSGJFN			;Get back jfn
SIZFL1:	LDB U,[POINT 6,FILPGS,11]	;Get byte size
	MOVE V,FILSIZ			;Else get the size now
	CAIN U,7			;If 7 bit,
	 JRST SIZFL3			;Are almost done
	CAIN U,^D36			;36 bit is easier
	 JRST SIZFL2
	MOVEI T,^D36
	IDIVI T,(U)			;Get number of bytes in a word
	IDIVI V,(T)			;Get number of words
SIZFL2:	IMULI V,5			;Into bytes
	MOVEM V,FILSIZ			;Save the size
SIZFL3:	IDIVI V,5000			;Since we have the file open, the
	JUMPE V+1,.+2			;Page count may be too little
	 ADDI V,1			;So, we must check against the
	HRRZ T,FILPGS			;Size according to the byte count
	CAIN V,(T)			;If GTFDB equals computed,
	 RET				;Then done
	MOVE A,MSGJFN			;Find first free page,
	GTSTS				;If file is open
	TLNN B,(GS%OPN)			;Is it open?
	 JRST [	HRRM V,FILPGS		;No, use what we have
		RET]
	FFFFP				;Get first free page
	HRRM A,FILPGS			;And use it
	RET

;;;Parse the file from message (M) on

PARSEF:	HRRZ C,FILPGS
	CAILE C,777-MSGPAG		;Enough room?
	 JRST [	CALL CLOSEF		;Get rid of jfn, etc
		ERROR (File is too large)]
	JUMPE M,[SETZ A,		;First message, start at first page
		JRST PARSF2]		;And go map it all in
	MOVE A,MSGALL-MSGLEN(M)		;Get start of message
	ADD A,MSGSAL-MSGLEN(M)
	ADDI A,1			;Get size in bytes plus one
	IDIVI A,5000			;Get first page we will need
	SUBI C,(A)			;Get real page count
PARSF2:	MOVEI B,MSGPAG(A)		;First page here to map into
	HRL A,MSGJFN			;File they come from
	HRLI B,.FHSLF
	HRLI C,(PM%CNT!PM%RD!PM%CPY)
	PMAP				;Map them in

	SETZ V,				;Assume
	JUMPE M,PARS10			;Start at start
	MOVE V,MSGALL-MSGLEN(M)		;Or at end of last message
	ADD V,MSGSAL-MSGLEN(M)

PARS10:	CALL CHR2BP			;Get byte pointer to this
	MOVEM V,MSGALL(M)		;Start of whole message
PARS11:	ILDB T,A			;Get character
	CAIE T,","
	 JRST PARS11
	MOVEI C,^D10			;Decimal
	CALL $NIN
	HRLM B,MSGBOD(M)		;Save length of real message
	MOVEI C,10			;Octal
	CALL $NIN
	MOVEM B,MSGBTS(M)		;Save message bits
	MOVEM B,MSGFBS(M)
	SETZM MSGFLG(M)
PARS12:	ILDB T,A
	CAIE T,12			;Until end of line
	 JRST [	WARN (File has bad format: garbage at the start of message %M)
		JRST PARS12]
	CALL BP2MCH			;Get character position
	HRRM V,MSGBOD(M)		;Save start of real message
	HLRZ B,MSGBOD(M)		;Get size again
	ADDI B,(V)			;Get end of whole thing
	MOVEM B,MSGSAL(M)		;Save size of whole message
	ADD B,MSGALL(M)			;Compute absolute byte of end of message
	PUSH P,B			;Save it for later

	CALL FNDSUB			;Find the subject
	HRRZM V,MSGSUB(M)
	HRLM W,MSGSUB(M)		;Save position and size

	CALL FNDFRM			;Find the from/sender
	HRRZM V,MSGFRM(M)
	HRLM W,MSGFRM(M)

	CALL FNDDAT			;Find the date
	MOVEM B,MSGDAT(M)		;Receive date

	POP P,V				;Recover ending address
	CAML V,FILSIZ			;Is this the last one
	 JRST PARS13			;Yes, all done then
	CAIE M,MSGLEN*<NMSGS-1>		;Got all we can handle?
	 JRST [	ADDI M,MSGLEN
		JRST PARS10]		;No, keep going
	WARN (File has too many messages)
PARS13:	MOVEM M,LASTM			;Save total number of messages
	RET

;;; Our own version of NIN, does not hack negative or anything like that
$NIN:	SETZ B,
$NIN1:	ILDB D,A
	CAIL D,"0"
	 CAILE D,"0"-1(C)
	  RET				;Done
	CAIN C,10			;This makes overflow not happen
	 LSH B,3
	CAIE C,10
	 IMULI B,(C)
	ADDI B,-"0"(D)
	JRST $NIN1

;;;Find the subject of the message

FNDSUB:	MOVEI T,[ASCIZ /
Subject: /]
	CALL FNDHDR			;Try to find this header
	 JRST FNDSB3			;Not there
FNDSB1:	SETZ W,				;Count size of field in w
FNDSB2:	ILDB T,A			;Get char
	CAIE T,15			;Until the CR
	 AOJA W,FNDSB2
	RET
FNDSB3:	MOVEI T,[ASCIZ /
Re: /]					;Try this then
FNDSB4:	CALL FNDHDR
	 JRST FNDSB5			;Not there either
	JRST FNDSB1			;Found it then
FNDSB5:	SETZB V,W			;Say we didnt find it anywhere
	RET

;;;Find the author of a message

FNDFRM:	MOVEI T,[ASCIZ /
From: /]
	CALL FNDHDR
	 CAIA
	  JRST FNDSB1
	MOVEI T,[ASCIZ /
Sender: /]
	JRST FNDSB4

;;;Find the date field

FNDDAT:	MOVE V,MSGALL(M)		;First thing in header is recv date
	CALL CHR2BP
	SETZB B,C
	IDTIM
	 JRST [	WARN (File has bad format: message %M has no receive date)
	 	SETO B,
		RET]
	RET

FNDSDT:	MOVEI T,[ASCIZ /
Date: /]
	CALL FNDHDR
	 JRST FNDDT1			;Not there
	SETZB B,C
	IDTIM				;Try to parse it
FNDDT1:	 MOVE B,MSGDAT(M)		;Bad format, use recv date
	RET

;;;Try to find a header in the message body

FNDHDR:	HRRZ W,MSGHLN(M)		;Length of header
	JUMPN W,FNDHD1
	HLRZ W,MSGBOD(M)		;Number of bytes in whole
	PUSH P,T
	MOVEI T,[BYTE (7) 15,12,15,12]
	CALL FNDHD1			;Find blank line indicating end
	 SETZ V,
	POP P,T
	HRRM V,MSGHLN(M)		;Save length of header
	SKIPN W,V
	 HLRZ W,MSGBOD(M)
FNDHD1:	HRRZ V,MSGBOD(M)		;Starting byte
	CALL SEARCH			;Try to find it
	 RET				;No good
	AOS (P)
	JRST BP2MCH			;And get char pointer

SEARCH:	HRLI T,(<POINT 7,0>)
SEARC0:	SETZ A,
SEARC1:	ILDB B,T			;Get a character
	MOVEM B,SRCBUF(A)		;Compile search table
	JUMPE B,SEARC2
	AOJA A,SEARC1

SEARC2:	CAIGE W,(A)			;Pattern too long for whole thing?
	 RET				;Yes, dont bother then
	CALL MCH2BP			;Get byte pointer
	JUMPL A,SEARC4			;Aligned to word boundary already
	MOVEI U,1			;Have to do at least one comparison
	SKIPA E,A
SEARC3:	 MOVE A,E
	CALL EQSTR			;See if the strings match
	 CAIA				;No
	  JRST CPOPJ1			;Yes, skip return
	IBP E				;Try next combination
	TLNE E,760000
	 AOJA U,SEARC3

SEAR3A:	MOVEI A,1(E)			;Start with the next word
	SUBI W,(U)			;Discount comparisons done manually
	JUMPL W,CPOPJ			;Did more than we wanted to
SEARC4:	MOVEI B,(W)			;Number of bytes to do
	IDIVI B,5			;Get number of words
	SKIPE C
	 ADDI B,1
	MOVEI W,(B)			;That is number of words to try to do
	MOVE N,SRCBUF			;First character
	IMUL N,[<BYTE (7) 1,1,1,1,1>/2]
	LSH N,1
	MOVE O,N
	XOR O,[BYTE (7) 40,40,40,40,40]
	MOVE X,[BYTE (7) 1,1,1,1,1]

SEARC5:	MOVE B,N			;Pattern to match
	MOVE C,O			;Case indept one
	MOVE D,(A)			;Word to try
	MOVE E,(A)
	JCRY0 .+1			;Clear carry flags
	EQVB D,B
	EQVB E,C
	ADD D,X
	ADD E,X
	EQV D,B
	EQV E,C
	JCRY0 SEARC6			;Found a match
	TDNN D,X
	 TDNE E,X
	  JRST SEARC6
SEAR5B:	SOJLE W,CPOPJ			;Not found
	AOJA A,SEARC5			;Try some more

SEARC6:	MOVSI U,-5			;Try matching withing this word
	SKIPA E,A
SEARC7:	 MOVEI A,(E)			;Get back start of right word
	HRL A,BPS(U)
	CALL EQSTR			;Try to match string
	 AOBJN U,SEARC7			;No match, keep trying
	JUMPL U,CPOPJ1			;Found it, skip return
	MOVEI A,(E)			;Point to start of word again
	JRST SEAR5B			;Not found this word, try some more

;;;Try to match pattern against one in SRCBUF

EQSTR:	SETZ B,
EQSTR1:	SKIPN C,SRCBUF(B)		;Get next char
	 JRST CPOPJ1			;Null, we found a match
	ILDB D,A			;Get next char
	CAIN D,(C)			;Matches?
	 AOJA B,EQSTR1			;Yes, keep trying
	TRC D,(C)			;Try case indept
	CAIE D,40
	 RET				;No good, fails
	AOJA B,EQSTR1			;Yes, keep trying

;;;Convert byte count in V to byte pointer in A

MCH2BP:	ADD V,MSGALL(M)			;Enter here with relative byte count
CHR2BP:	PUSH P,B
	MOVE A,V
	IDIVI A,5
	ADDI A,MSGPAG*1000		;Offset it right
	HRL A,BPS(B)
CPOPBJ:	POP P,B
	RET

;;;Vice versa

BP2MCH:	CALL BP2CHR
	SUB V,MSGALL(M)			;Return relative byte count
	RET

BP2CHR:	LDB C,[POINT 6,A,5]		;Get position field
	MOVEI V,1-MSGPAG*1000(A)	;Clear out bp field
	IMULI V,5
	IDIVI C,7
	SUBI V,(C)
	RET

BPS:	440700
	350700
	260700
	170700
	100700

;;;Parse the rest of this line as addresses from byte pointer in A,
;;;Inserting default host name pointed to by E,
;;;Using free space from FREETO

PRADDR:	MOVE W,FREETO			;Start pointer out right
PRADD0:	SETZ C,				;Not looking for anything
	MOVE V,[-10,,STRBUF+67]		;Get some room for pdl
	MOVEI U,STRBUF			;Get some random string space
PRAD00:	MOVEI T,(U)			;Save start of address
	HRLI U,(<POINT 7,0>)		;Make byte pointer for storing name
NEWQ,<
	TLZ F,(F%F5!F%AT!F%NEWQ!F%ADR!F%QOT!F%STAD)	;Clear state flags
>;NEWQ
NONEWQ,<
	TLZ F,(F%F5!F%AT!F%ADR!F%QOT!F%STAD)
>;NONEWQ
PRAD01:	ILDB B,A			;Get char
	CAIN B,","
	 JRST PRADD0			;Null address, forget it
	CAIE B,15
	 CAIN B,0
	  JRST ADDTO			;End of this address prematurely, fix things up
	CAIE B,11
	 CAIN B," "
	  JRST PRAD01			;Flush leading white space
	CAIA				;Start with this character

;;;Here is the main parsing loop

PRADD1:	 ILDB B,A			;Get next character
PRAD10:	CAIN B,42			;Start or end of quoted string?
	 JRST PRAD21			;Yes, get rest of it
	TLNE F,(F%QOT)			;Quoted string?
	 JRST PRAD13			;Just insert all other characters
	TLNE F,(F%STAD)			;In middle of one?
	 JRST PRAD26			;Yes, go check char for balancing
	CAIN B,"{"			;Start of structured address? }
 	 JRST PRAD25			;Yes
	JUMPE C,PRAD11			;Looking for a special character?
	CAIN B,(C)			;Yes, found it?
	 JRST PRAD14			;Yes
	JUMPL C,PRAD11			;Allowed addresses inside?
	TLNE F,(F%F5)			;Ignoring characters?
	 JRST PRADD1			;Yes, dont do anything with this one
	JRST PRAD12

PRAD11:	CAIE B,","			;End of address?
	 CAIN B,15
	  JRST PRADD5			;Yes, finish up
	JUMPE B,PRADD5
	TLNE F,(F%F5)			;Ignoring characters?
	 JRST PRADD1			;Yes, dont do anything with this one
	CAIN B,"<"			;Start of address after junk?
	 JRST PRAD22			;Yes, set to look for matching >
	CAIN B,":"			;Or filename: junk;?
	 JRST PRAD23			;Yes, look for ;
	CAIN B,"("			;Start of comment?
	 JRST PRAD24			;Yes, look for )
PRAD12:	CAIN B," "			;End of a token?
	 JRST PRADD3			;Yes, check for things like "at"
	CAIN B,"@"			;Start of some hostname?
	 JRST PRADD4			;>
	CAIE B,"<"			;Dont let these filter in
	 CAIN B,";"
	  JRST PRADD1
PRAD13:	IDPB B,U			;Ordinary character, just stick it in
	TLO F,(F%ADR)			;This address is non-null
	JRST PRADD1			;And on for more

PRAD14:	MOVE D,C			;Found matching frob
	POP V,C
	TLZ F,(F%F5)			;Dont ignore any more chars
	TLNE D,200000			;Dont insert char?
	 JRST PRADD1
	JRST PRAD13			;Yes, do so

PRAD21:	TLC F,(F%QOT)			;Complement " state
	TLNN F,(F%F5)			;Ignoring characters?
	 IDPB B,U			;No, stick it in
	JRST PRADD1			;And go get some more
					;< watch these comments just in case
PRAD22:	SKIPA B,[">"]
PRAD23:	 MOVEI B,";"
	PUSH V,C			;Save previous state
	HRROI C,(B)			;Allow nesting with these
	MOVEI U,(T)			;Flush whatever there was before
	JRST PRAD00			;And go re-init all fields

PRAD24:	PUSH V,C
	MOVEI C,")"			;Will look for matching close
	TLOE F,(F%ADR)			;Had anything before?
	 TLOA F,(F%F5)			;Yes, this is a comment, ignore it
	  CAIA				;No, make this address and self-insert
	   TLOA C,200000		;Comments dont insert when done though
	    IDPB B,U			;Address does
	JRST PRADD1

PRAD25:	TLO F,(F%STAD)			;Starting structured address
	MOVEI D,1			;No, init count
	JRST PRAD13			;Go insert it too

PRAD26:	CAIN B,"{"			;Going deeper?
	 AOJA D,PRAD13			;Yes, count one more and insert
	CAIN B,"}"			;Closing a level?
	 SOSLE D			;This the end?
	  JRST PRAD13			;No or no, just insert character
	TLZ F,(F%STAD)			;No longer within one
	JRST PRAD13

;;;End of a token, check for " at " or @

PRADD3:	PUSH P,A			;Save where we are now
	PUSH P,B			;And the current character
PRAD30:	ILDB B,A			;Get next one
	CAIE B,11
	 CAIN B," "
	  JRST PRAD30			;Flush whitespace
	CAIN B,"("
	 JRST PRAD32
	CAIN B,"@"
	 JRST PRAD34
	CAIE B,"A"
	 CAIN B,"a"
	  CAIA
	   JRST PRAD31
	ILDB B,A
	CAIE B,"T"
	 CAIN B,"t"
	  CAIA
	   JRST PRAD31
PRAD34:	ILDB B,A
	CAIE B,11
	 CAIN B," "
	  JRST PRAD33			;Matched, go treat like "@"
PRAD31:	POP P,B				;Get back character that fooled us
	POP P,A				;And byte pointer after it
	JRST PRAD13			;And go treat like normal one
PRAD32:	ADJSP P,-2
	JRST PRAD10
PRAD33:	ADJSP P,-2			;Flush what we saved and enter @ code

;;;Hairy multiple @ parser

PRADD4:	TLON F,(F%AT)			;An @, have we seen more than one?
	 JRST PRAD43			;No, this is the first
NEWQ,<
	TLO F,(F%NEWQ)			;Remember that this is a hard case
>;NEWQ
	HLRZ D,T			;Get what we thought was the hostname
	HRLI D,(<POINT 7,0>)		;Make byte pointer
	SKIPA B,["@"]			;Join the two with an @
PRAD41:	 ILDB B,D			;Get next char from old hostname
	CAMN D,U			;Got to end (where we are now before)
	 JRST PRAD42			;Yes, have appended them
	IDPB B,SAVU
	JRST PRAD41

PRAD42:	IDPB B,SAVU
	SKIPA U,SAVU
PRAD43:	 MOVEM U,SAVU
	MOVEI B,0
	IDPB B,U			;Stick a null onto end of address
	MOVEI U,1(U)			;Point to next word
	HRLI T,(U)			;This will be the start of the hostname
	HRLI U,(<POINT 7,0>)
	JRST PRAD01

;;;Here when we have finished parsing the address, stick in any host default
;;;and build up the final block

PRADD5:	PUSH P,A			;Save byte pointer
	CAIE B,","
	 TLZA F,(F%COMA)
	  TLO F,(F%COMA)
PRAD50:	LDB B,U				;Flush trailing whitespace
	CAIE B," "
	 CAIN B,11
	  JRST [ADD U,[7B5]
		SKIPGE U
		 SUB U,[43B5+1]
		JRST PRAD50]
	SETZ C,
	IDPB C,U			;End with null
	MOVEI U,(W)
	MOVEM U,SAVU			;In case of final parse error
	MOVEI A,4(W)
	HRLI A,(<POINT 7,0>)
	MOVEI B,(T)
	CALL MOVST0			;Move in user name
	MOVEI A,1(A)			;Point to next free word
	SUBM A,W			;Get length
	EXCH A,W
	HRLZM A,(U)
	SETZM 1(U)
	SETZM 3(U)
	TLNE F,(F%AT)			;Host name seen?
	 JRST PRAD54			;Yes, handle network recipient
	SKIPE C,E			;Was there a default host?
	 JRST PRAD52			;Yes, use it then
PRAD51:	TLZ F,(F%AT)			;Pretend no @ was there, for PRTOCC
	MOVSI A,(RC%EMO)
	HRROI B,(T)			;User name
	RCUSR
	 ERJMP [MOVEI B,[ASCIZ /address/]
		MOVEI C,(T)
		JRST PRAD56]
	TLNE A,(RC%NOM!RC%AMB)		;Bad local user?
	 JRST PRAD55			;Yes, complain and flush it
	TDZA A,A			;Local recipient
PRAD52:	 MOVEI A,2			;Network recipient
	DPB A,[POINT 9,(U),8]		;Store type field
	MOVEM C,2(U)			;And host/user number
PRAD53:	POP P,A				;Get back byte pointer
	TLNE F,(F%COMA)			;Unless end of line
	 JRST PRADD0			;Get next one as well
	RET				;All done, return

PRAD54:	SKIPN A,HSTPTR
	 CALL HSTINI
	HLRO B,T			;Host name
	TBLUK
	TLNE B,(TL%NOM!TL%AMB)		;Bad host name?
	 JRST PRAD57
	HRRZ C,(A)
NOHST2,<
	MOVE C,(C)			;Get host number
	CAMN C,LHOSTN			;Really local?
>;NOHST2
HOSTS2,<
	HLRZ C,(C)			;Get pointer to official host name
	CAMN C,LHOSTP			;Really local?
>;HOSTS2
	 JRST PRAD51
NEWQ,<
	TLZN F,(F%NEWQ)			;More than one host?
>;NEWQ
	 JRST PRAD52

NEWQ,<
;; If there was more than one host, maybe we can flush the route given
	MOVEI V,4(U)			;Point to start of user
	HRLI V,(<POINT 7,0>)
	MOVEI T,-1(W)
	HRLI T,(<POINT 7,0,34>)		;Point to end of hosts
PRAD58:	ADD T,[7B5]
	CAMN T,V			;Reached end?
	 JRST PRAD52			;Yes, done then
	JUMPGE T,.+2
	 SUB T,[43B5+1]
	LDB D,T				;Get character
	CAIE D,"@"
	 JRST PRAD58
	MOVE A,HSTPTR
	MOVE B,T			;See if we know this host
	PUSH P,C
	TBLUK
	POP P,C
	TLNE B,(TL%NOM!TL%AMB)		;Matched ok?
	 JRST [	DPB D,T			;Put back in @
		JRST PRAD52]		;And forget it
	SETZ D,				;Truncate user name
	DPB D,T
	HRRZ C,(A)			;A winner, save new host
	HLRZ C,(C)			;Get pointer to official host name
	CAMN C,LHOSTP			;Really local?
	 JRST PRAD51
	JRST PRAD58
>;NEWQ

PRAD55:	MOVEI B,[ASCIZ /local user/]
	MOVEI C,(T)
PRAD56:	TLNN F,(F%F4)			;Unless silence requested
	 CIETYP < No such %2S as "%3S", address flushed>
	MOVE W,SAVU
	JRST PRAD53

PRAD57:	MOVEI B,[ASCIZ /host/]
	HLRZ C,T
	JRST PRAD56

;;;Get To and cc lists from message

PRTOCC:	SETZ E,				;Assume default
	TLNN F,(F%AT)			;Was there an @ in the main name?
	 JRST PRTO10
	MOVE E,TOLIST
	MOVE E,2(E)			;Yes, get default host number then
PRTO10:	SKIPE RCCOTH			;Make everybody cc?
	 TLOA F,(F%CC)			;Yes, do this from the start
	  TLZ F,(F%CC)			;Not in CC yet
PRTO11:	CALL PRADDT			;Parse this line
	LDB B,A				;Get terminating character
	JUMPE B,CPOPJ			;Null means all done now
	IBP A				;Move over the LF too
PRTO12:	ILDB B,A			;Get next char
	CAIE B,11			;Whitespace indicates continuation
	 CAIN B," "
	  JRST PRTO11
	CAIE B,"T"			;More to maybe
	 CAIN B,"t"
	  JRST PRTO20
	CAIE B,"C"			;Or maybe start of cc
	 CAIN B,"c"
	  JRST PRTO30
	RET				;And done

PRTO20:	ILDB B,A
	CAIE B,"O"
	 CAIN B,"o"
	  CAIA
	   RET
	ILDB B,A
	CAIE B,":"
	 RET				;No good I guess
	JRST PRTO11			;Get rest of this line then

PRTO30:	ILDB B,A
	CAIE B,"C"
	 CAIN B,"c"
	  CAIA
	   RET
	ILDB B,A
	CAIE B,":"
	 RET
	TLO F,(F%CC)			;Now doing cc
	JRST PRTO11			;And now go get more

;;;Send to a string of a local user in B

CCSTR:	MOVE U,FREETO			;Get some free space
	PUSH P,B
	MOVEI A,4(U)
	HRLI A,(<POINT 7,0>)
	CALL MOVST0
	MOVEI A,1(A)			;Point to next free word
	MOVEI W,(A)			;Get new end of area
	SUBI A,(U)			;Get length
	HRLZM A,(U)			;Store size field
	SETZM 1(U)
	POP P,B
	MOVSI A,(RC%EMO)		;Require an exact match
	RCUSR
	MOVEM C,2(U)
	SETZM 3(U)
	CAIA				;And add to the cc list

;;;Add new recipients to the appropriate lists

ADDTO:	 TLNE F,(F%CC)
	  SKIPA T,[CCLIST]
	   MOVEI T,TOLIST
ADDTO0:	HRRZ U,FREETO
	HRRZM W,FREETO			;Update free pointer now
ADDTO1:	CAIN U,(W)			;Got to where we left off?
	 RET				;Yes, done
	LDB B,[POINT 4,(U),8]		;Get type field
	MOVEI B,LCLIST(B)
	CALL ADDLST			;Add into transmission medium list
	 JRST ADDTO2			;Duplicate entry
	SKIPN (T)			;This the first entry?
	 HRRM U,(T)			;Yes, store it as head then
	HLRZ B,(T)			;Get old tail
	SKIPE B
	 HRRM U,(B)			;Link to old tail
	HRLM U,(T)			;This is new tail
ADDTO2:	LDB B,[POINT 9,(U),17]		;Get size
	ADDI U,(B)
	JRST ADDTO1

;;;Thread block in U into list in B

ADDLST:	MOVE C,2(U)
	SKIPN V,(B)
	 JRST ADDLS5			;Empty list, this is where it goes
ADDLS1:	CAMG C,2(V)
	 JRST ADDLS4
	HRRZ D,1(V)			;Get next element of list
	JUMPE D,ADDLS2			;None there, put on end of list
	MOVEI V,(D)
	JRST ADDLS1

ADDLS2:	HRRM U,1(V)			;Add this to end of list
ADDLS3:	HRLM V,1(U)			;Link to previous
	JRST CPOPJ1

ADDLS4:	CAIN B,LCLIST
	 CAME C,2(V)			;Local user matches exactly?
	  SKIPA D,V
	   RET				;Yes, flush it
	HRRM V,1(U)			;Link to next
	HLRZ V,1(V)			;Get previous
	HRLM U,1(D)			;Link to previous
	JUMPN V,ADDLS2
ADDLS5:	HRRM U,(B)			;No previous, store this at the end
	JRST CPOPJ1

;;;Remove element in W from transmission medium list

REMLST:	HLRZ A,1(W)			;Link to previous this medium
	HRRZ B,1(W)			;Link to next this transmission medium
	SKIPE B				;Unless tail of list...
	 HRLM A,1(B)			;New link to previous for next element
	SKIPE A				;Unless head of list...
	 HLRM B,1(A)			;New link to next for previous element
	JUMPN A,REMLS1			;If this was the head of the list
	LDB A,[POINT 4,(W),8]		;Get transmission medium type
	HRRM B,LCLIST(A)		;Set as starting pointer
	RET

REMLS1:	HRRM B,1(A)			;Link as next
	RET

SUBTTL Message handling subroutines

;;;Type out header of a message

.RHEAD:	CONFRM				;Type header of current message
TYPHDR:	CALL CRIF			;Get a fresh line
	MOVE O,[POINT 7,WRTPGS]		;Place to put the string
	CALL TYPHD0
	HRROI A,WRTPGS			;Now type it out
	PSOUT
	RET

;;;Stick the header for a message into the string in O

TYPHD0:	MOVE T,MSGBTS(M)		;Get messages bits
	SKIPL MSGFLG(M)
	 JRST TYPH0A
	MOVEI A,"R"			;Recent
	TRON T,M%SEEN			;Unseen as well (o so no U later)
	 TRCA A,<"N"!"R">-<"N"&"R">	;Yes, is new then
TYPH0A:	  MOVEI A," "
	IDPB A,O
	TRNE T,M%SEEN
	 SKIPA A,[" "]
	  MOVEI A,"U"			;Unseen
	IDPB A,O
	TRNN T,M%ATTN			;Flagged
	 SKIPA A,[" "]
	  MOVEI A,"F"
	IDPB A,O
	TRNN T,M%RPLY			;Answered
	 SKIPA A,[" "]
	  MOVEI A,"A"
	IDPB A,O
	TRNN T,M%DELE
	 SKIPA A,[" "]
	  MOVEI A,"D"			;Deleted
	IDPB A,O
	MOVE A,O
	MOVEI B,MSGLEN(M)		; Message number
	IDIVI B,MSGLEN
	MOVE C,[NO%LFL+3B17+^D10]
	NOUT
	 NOP
	MOVEI B," "
	IDPB B,A
	PUSH P,A
	SKIPG B,MSGDAT(M)		;Date
	 JRST [	DMOVE T,[ASCIZ /      /]	;Fill with spaces if not there
		JRST TYPHD2]
	HRROI A,T			;Where to stick string
	MOVSI C,(OT%NTM)
	ODTIM
	TLZ U,(<BYTE (7) 0,177>)	;Clear out year and anything else
TYPHD2:	MOVE A,(P)
	MOVEI B,T
	CALL MOVSTR
	MOVEM A,(P)
	CALL FRMMEP			;Check if message is from me or not
	 MOVE A,MSGFRM(M)		;Isnt, show from field
	MOVEI B,^D20			;Limited to 20 chars
	SKIPE KEYTBL			;If have keywords, make a little shorter
	 MOVEI B,^D15
	POP P,O				;Get back string pointer
	CALL TYPHDS
	JUMPE B,TYPHD3			;None more needed
	MOVEI A," "
	IDPB A,O
	SOJG B,.-1			;Fill with spaces
TYPHD3:	HLLZ A,MSGBTS(M)		;Relevant keyword flags
	CALL KEYSTR			;Insert string for that
	MOVE A,MSGSUB(M)		;Subject field
	MOVEI B,^D30			;Limited to 30 chars
	SUBI B,(T)			;Less what we used for keywords
	CALL TYPHDS
	MOVE A,O
	MOVEI B,[ASCIZ / (/]
	CALL MOVSTR
	HLRZ B,MSGBOD(M)		;Length of message
	MOVEI C,^D10
	NOUT
	 NOP
	MOVEI B,[ASCIZ / chars)
/]
	CALL MOVST0
	ADD A,[7B5]			;Return pointer before null
	SKIPG O,A
	 SUB A,[43B5+1]
	RET

TYPHDS:	MOVEI D," "
	IDPB D,O
	JUMPE A,CPOPJ			;Nothing there to type
	HRRZ V,A			;Start of field
	HLRZ C,A			;Length
	JUMPE C,CPOPJ
	CAILE C,(B)			;Or truncate
	 MOVEI C,(B)
	SUBI B,(C)			;Get number of chars needed to fill
	CALL MCH2BP			;Get byte pointer
TYPHS1:	ILDB D,A
	IDPB D,O
	SOJG C,TYPHS1	
	RET

;;;Check if message is from me, and setup to type out To: field if so

FRMMEP:	MOVE A,MSGFLG(M)
	TLNE A,(M%FRME!M%FRNM)		;See if we have done this before
	 JRST FRMME2			;Yes, we have, dont need to check
	HRRZ V,MSGFRM(M)
	JUMPE V,FRMME1			;Dont know who it's from
	CALL MCH2BP
	SETZ E,				;No host name defaulting
	PUSH P,F			;Save all flags
	MOVEI W,TOPAG
	SKIPN FREETO			;Make sure have some free space to
	 MOVEM W,FREETO			; work with
	TLO F,(F%F4)			;Dont type error messages
	CALL PRADDR			;Get the guy, but dont add to anything
	POP P,F
	MOVE W,FREETO			;Get the address just added
	HRROI A,MYDIRS
	HRROI B,4(W)
	STCMP
	JUMPN A,FRMME1			;Not from me
	SKIPA A,[M%FRME]		;Yes, from me
FRMME1:	 MOVSI A,(M%FRNM)		;Not from me
	IORB A,MSGFLG(M)
FRMME2:	TLNN A,(M%FRME)			;From me?
	 RET				;No, single return to use from field
	MOVEI T,[ASCIZ /
To: /]
	CALL FNDSB4
	HRREI A,-4(V)			;Include length of "To: "
	JUMPL A,CPOPJ			;Didnt find to, still need from
	HRLI A,4(W)
	JRST CPOPJ1

;;; Translate bits into string, byte pointer in O, bits in A, returns bytes output in T
KEYSTR:	TLZ F,(F%COMA)
	SETZ T,				;Init count
KEYST1:	JFFO A,KEYST2			;{
	MOVEI C,"}"
	TLZE F,(F%COMA)			;Anything output?
	 IDPB C,O			;Yes, finish it up
	RET
KEYST2:	MOVSI C,400000
	MOVN D,B
	LSH C,(D)
	XOR A,C				;Clear out the bit in question
	HLRZ C,KEYTBL			;Number of entries in table
	MOVEI D,KEYTBL+1		;Start of table
KEYST3:	SOJL C,KEYST1			;Failed to find anything, forget it
	HRRZ E,(D)			;Get number for this frob
	CAIE E,(B)			;Matches?
	 AOJA D,KEYST3			;Keep looking
	TLON F,(F%COMA)
	 JRST [	MOVEI C," "
		IDPB C,O
		MOVEI C,"{"		;}
		AOJA T,KEYST4]
	MOVEI C,","
	IDPB C,O			;Start list or insert comma
	MOVEI C," "
KEYST4:	IDPB C,O
	ADDI T,2			;", " or "{}"
	HLRZ D,(D)
	HRLI D,(<POINT 7,0>)
KEYST5:	ILDB C,D
	JUMPE C,KEYST1
	IDPB C,O
	AOJA T,KEYST5

;;;Type out a message

.LRTYP:	SKIPG MSGJFN
	 ERROR (No current file)
	CONFRM				;Confirm first
	JRST TYPMSL

.TYPMS:	SKIPG MSGJFN
	 ERROR (No current file)
	CONFRM				;Confirm first
TYPMSG:	TLZA F,(F%F5)			;Normal filtering
TYPMSL:	 TLO F,(F%F5)			;Literally from message
	HLRZ C,MSGBOD(M)		;Length of message
	CIETYP < Msg %M (%3D chars) -- >
	MOVN C,C
	HRRZ V,MSGBOD(M)
	CALL MCH2BP
	MOVE B,A
	TLNE F,(F%F5)			;Unless literal headers requested
	 JRST TYPMSS
	SKIPN SPRHDR			;Any suppressed headers?
	 SKIPE ONLHDR			;Or only certain ones?
	 JRST TYPSHD			;Yes, process the slow way then
TYPMSS:	MOVEI A,.PRIOU
	SOUT				;Print the message out
TYPMSM:	MOVEI A,M%SEEN			;Mark message as seen
	IORM A,MSGBTS(M)
	JRST UPDBIT			;And maybe update

;;;Type out the headers not in the suppressed list only, count in C, bp in B
TYPSHD:	TLZ F,(F%F5)			;Clear state flag
TYPSH0:	ILDB D,B			;Get first character of line
	CAIN D,15			;Start of blank line?
	 JRST [	ADD B,[7B5]		;Yes, back over it
		JRST TYPMSS]		;And type rest of message
	SETZ E,				;Reset pointer to :
	CAIE D,40			;Space
	 CAIN D,11			;Or tab is continuation line
	  ADDI E,1			;Remember this specially
	SKIPA A,[POINT 7,STRBUF]	;Save header here
TYPSH1:	 ILDB D,B			;Get next character
	AOJGE C,TYPMSM			;Nothing but headers
	IDPB D,A			;Stick it in
	JUMPN E,TYPSH2			;Unless already saw a :
	CAIN D,":"			;If this is one
	 SKIPA E,A			;Remember it's position
TYPSH2:	CAIE D,12			;End of a line?
	 JRST TYPSH1			;No, continue accumulating
	SETZ D,				;See if this is a losing header
	IDPB D,A			;Make line end with null
	JUMPE E,TYPSH3			;Didnt see a :, type the line out
	CAIN E,1			;Continuation line?
	 JRST TYPSH4			;Yes, check against last case
	DPB D,E
	PUSH P,B			;Save current pointer
	HRROI B,STRBUF
	PUSH P,C
	SKIPE ONLHDR			;Have headers to type out explicitly?
	 JRST [	MOVEI A,ONLHDR
		TBLUK
		TLNE B,(TL%NOM!TL%AMB!TL%ABR)	;Complement the flags,
		 TDZA A,A		;if no match, say it matched
		  MOVSI A,(TL%NOM)
		JRST TYPSH5]
	MOVEI A,SPRHDR
	TBLUK				;Look for it
	HLLZ A,B			;Get result flags
TYPSH5:	POP P,C
	POP P,B
	TLNN A,(TL%NOM!TL%AMB!TL%ABR)	;One we know to flush?
	 TLOA F,(F%F5)			;Yes, remember we flushed it
	  TLZA F,(F%F5)			;No, will print it
	   JRST TYPSH0			;Handle next line
	MOVEI D,":"			;Put back in the :
	DPB D,E
TYPSH3:	HRROI A,STRBUF
	PSOUT				;Type out a winning line
	JRST TYPSH0			;And continue to next one
TYPSH4:	TLNE F,(F%F5)			;Continuation line, last one flushed?
	 JRST TYPSH0			;Yes, flush this too
	JRST TYPSH3			;No, type this part too

CHKDEL:	MOVEI A,M%DELE
	TDNN A,MSGBTS(M)		;Deleted?
	 JRST CPOPJ1			;No, skip return
	CIETYP < Msg %M deleted.
>
	RET				;Single return

;;;Type out headers of recent messages

RECENT:	TLO F,(F%F1)			;Say type headers
RECEN0:	SETZB M,NRECNT
	SETZM NUNSEE
	SETZM NDELET
RECEN1:	SKIPLE B,MSGDAT(M)		;Get recv date of message
	 CAMG B,LASTRD			;Check against last read date
	  JRST RECEN4
	MOVSI A,(M%RECE)		;Bit to set if recent
	IORM A,MSGFLG(M)		;Say it's recent
	AOS NRECNT			;Count one more
	TRNN F,F%MOD			;If system mail
	 JRST RECEN2
	MOVEI A,M%SEEN
	ANDCAM A,MSGBTS(M)		;Make all recent unseen
RECEN2:	TLNE F,(F%F1)			;Want headers
	 CALL TYPHDR			;Yes, tell him what it's about
RECEN3:	MOVE A,MSGBTS(M)
	TRNN A,M%SEEN			;Count unseen and deleted messages
	 AOS NUNSEE
	TRNE A,M%DELE
	 AOS NDELET
	CAMGE M,LASTM			;Thru with all msgs?
	 JRST [	ADDI M,MSGLEN
		JRST RECEN1]		;No
	MOVE A,NRECNT
	IMULI A,MSGLEN
	SKIPE M				;Unless all messages are new,
	 SUBI M,(A)			;Set current msg to last non-recent
	MOVNI A,MSGLEN
	MOVEM A,PRIORM			;And allow -1 for it in case all new
	RET

RECEN4:	TRNE F,F%MOD			;If doing system mail
	 JRST RECEN5			;Make sure not seen by us either
	MOVEI A,M%ATTN			;Flagged (always-show)?
	TDNN A,MSGBTS(M)
	 JRST RECEN3			;No, dont do it then
	JRST RECEN2			;Yes, type it anyway

RECEN5:	MOVEI A,M%SEEN
	IORM A,MSGBTS(M)		;Make all old messages seen
	JRST RECEN3

;;;Type out summary of the current file

SUMMRY:	MOVE A,LASTM			;Get number of messages
	IDIVI A,MSGLEN
	AOS D,A
	MOVEI B,[ASCIZ /Last read: %3T/]
	TRNE F,F%MOD			;Special message for system mail
	 MOVEI B,[ASCIZ /Last login: %3T/]
	SKIPG C,LASTRD			;Last read date
	 MOVEI B,[ASCIZ /Never read/]
	SUB D,NRECNT			;Number of old messages
	SKIPN NRECNT
	 TDZA E,E
	  MOVEI E,[ASCIZ / (%4D old)/]
	HRRZ T,FILPGS			;Number of pages
	CETYPE < %2S, %1D msg%1P%5S, %6D page%6P>
	MOVE T,NUNSEE
	SUB T,NRECNT
	SKIPG T
	 TDZA E,E
	  MOVEI E,[ASCIZ / %6D message%6P unseen/]
	SKIPG D,NDELET
	 TDZA C,C
	  JRST [MOVEI C,[ASCIZ /; %4D deleted/]
		SKIPG T
		 MOVEI C,[ASCIZ / %4D message%4P deleted/]
		JRST .+1]
	CETYPE (%5S%3S)
	RET

;;;Update the file copy of the message bits, unless in read command

UPDBIT:	TRNE F,F%RONL
	 RET				;In which case noop

;;;Insist on update, even in read mode

UPDBT0:	MOVE B,MSGBTS(M)		;Get new copy of bits
	TRNN F,F%MOD!F%RONL		;Dont try to munge system mail
	 CAMN B,MSGFBS(M)		;Old matches new?
	  RET				;Yes, no need to do any more
	CALL GETJF2			;Get a second jfn if dont already
	 RET				;Failed
	MOVE V,MSGALL(M)		;Start of the message header
	CALL CHR2BP			;Get byte pointer
UPDBT1:	ILDB B,A			;Get char
	CAIN B,15			;At end of line??
	 ERROR (File has bad format: unable to find message flag field)
	CAIE B,";"			;At start of bits?
	 JRST UPDBT1
	SUBI A,MSGPAG*1000		;Get absolute pointer
	TLNN A,760000			;Make sure point to correct first word
	 ADD A,[43B5+1]
	PUSH P,A			;Save that pointer
	ANDI A,-1
	IDIVI A,1000			;Get page number we need
	HRL A,MSGJF2
	CAIL B,775			;If near end of page
	 SKIPA C,[PM%CNT+PM%WR+PM%RD+2]	;Map two pages
	  MOVSI C,(PM%WR!PM%RD)
	MOVE B,[.FHSLF,,WRTPGS/1000]
	PMAP

	POP P,A				;Get back byte pointer
	TRZ A,777000			;Just relative to page
	ADDI A,WRTPGS			;Offset right
	MOVE B,MSGBTS(M)		;Bits to set out
	MOVE C,[NO%MAG+NO%LFL+NO%ZRO+14B17+10]
	NOUT				;Write them out
	 NOP
	MOVEI C,15			;Kill the null
	IDPB C,A			;With a CR
	MOVEM B,MSGFBS(M)		;This is now the file version
	SETO A,
	MOVE B,[.FHSLF,,WRTPGS/1000]
	MOVE C,[PM%CNT+2]
	PMAP				;Unmap the pages
CLSJF2:	HRRZ A,MSGJF2
	TLO A,(CO%NRJ)			;Keep this JFN around
	CLOSF
	 NOP
	HRRZ A,MSGJF2
;	JRST SETREF			;Set read date to now
SETREF:	TRNE F,F%RONL			;Never set reference date if read-only
	 RET
	MOVE C,A			;Save JFN
	GTAD				;Set read date to now 
	EXCH C,A			;Get back JFN
	HRLI A,.FBREF
	SETO B,				;Cause we are going to reparse
	CHFDB
	 ERJMP .+1			;Maybe no access, dont worry
	RET				;Done

GETJF2:	SKIPLE A,MSGJF2			;Have one already?
	 JRST GETJ2A			;Yes, use it
	HRROI A,FILNAM
	MOVE B,MSGJFN			;One we do have
	SETZ C,
	JFNS
	MOVSI A,(GJ%OLD!GJ%SHT!GJ%ACC)
	HRROI B,FILNAM
	GTJFN
	 JERROR (Can't get second handle on file)
	MOVEM A,MSGJF2			;Save JFN
GETJ2A:	MOVE B,[7B5+OF%RD!OF%WR]	;Open file for write as well (it is
	OPENF				;now write-locked against new msgs).
	 JRST [	TRON F,F%RONL		;Can't open for write, now read only?
		 JWARN (Can't open for write)
		RET]
	CALL CHECKT			;Get size and new msgs, now
					;That file is locked
	HRRZ A,MSGJF2			;Return value
	JRST CPOPJ1

SUBTTL Message sequence subroutines

;;;Get sequence, default to current message

DFSQTH:	SKIPA A,[[ASCIZ /CURRENT/]]	;Setup default number to this message
DFSQNW:	 MOVEI A,[ASCIZ /UNSEEN/]	;Default to unseen
	JRST DFSQA1

DFSQRC:	SKIPA A,[[ASCIZ /RECENT/]]	;Default to recent
DFSQAL:	 MOVEI A,[ASCIZ /ALL/]		;Default to all messages
DFSQA1:	SKIPG MSGJFN			;Must have a file
	 ERROR (No current file)
	UDEF (A)			;This is the default
	JRST GETSEQ

STQALL:	CONFRM				;All messages = 1:n
	MOVE A,LASTM
	IDIVI A,MSGLEN
	LSH A,^D12
	IOR A,[BYTE (12) 0,2000,3777]
	MOVEM A,MSGSEQ
	JRST GTSQNS

STQPRV:	CONFRM				;Previous-sequence
	SKIPN NXTMSD			;Was there a previous sequence?
	 ERROR (No previous sequence)
	SKIPG NXTMSD			;Still valid?
	 ERROR (Previous sequence clobbered)
	JRST GTSQNS			;Handle like numeric sequence

STQREV:	SKIPA A,[NXTREV]		;Reverse order
STQDEL:	 MOVEI A,NXTDEL			;Deleted
STQDL0:	MOVEM A,NXTMSD
	CONFRM
STQDL1:	MOVNI M,MSGLEN			;Init search before start of messages
	RET

STQREC:	SKIPA A,[NXTREC]		;Recent
STQUND:	 MOVEI A,NXTUND			;Undeleted
	JRST STQDL0

STQNEW:	SKIPA A,[NXTNEW]		;New
STQSEE:	 MOVEI A,NXTSEE			;Seen
	JRST STQDL0

STQFLG:	SKIPA A,[NXTFLG]		;Flagged
STQUNF:	 MOVEI A,NXTUNF			;Unflagged
	JRST STQDL0

STQANS:	SKIPA A,[NXTANS]		;Answered
STQUNA:	 MOVEI A,NXTUNA			;Unanswered
	JRST STQDL0

STQTHS:	HRROM M,LSTMSG			;This message, save current number
	SKIPA A,[NXTTHS]
STQUNS:	 MOVEI A,NXTUNS			;Unseen
	JRST STQDL0

STQLST:	NOISE (NUMBER OF MESSAGES)
	MOVEI B,[FLDDB. .CMNUM,,^D10,,<POINT 7,[ASCIZ/1/]>]
	CALL CMDFLD			;Get a number
	CAIN B,1			;Just one?
	 JRST STQLS1			;Last one message
	MOVE C,LASTM
	IDIVI C,MSGLEN
	SUBM C,B			;Starting message of sequence
	AOJL B,BADNUM			;Number out of range
	CALL GTSQLC			;Put that in as the start
	MOVEI B,2000(C)			;Last message as end of sequence
	JRST STQLS2			;And go handle that sequence

STQLS1:	SKIPA B,LASTM			;Just last message
STQCUR:	MOVEI B,(M)			;Current message
	IDIVI B,MSGLEN
STQLS2:	CALL GTSQLC			;Save on list
	CONFRM				;Guarantee EOL
	JRST GTSQNR			;Done with list

STQTO:	SKIPA X,[NXTTO]			;Match to string
STQFRM:	 MOVEI X,NXTFRM			;Match from string
	JRST STQSB0			;Common routine to get pattern

STQTXT:	SKIPA X,[NXTTXT]		;Match text substring
STQSBJ:	 MOVEI X,NXTSBJ			;Match subject string
STQSB0:	NOISE (STRING)
	CALL GETLIN			;Read a line from the user
	HRROI B,STRBUF			;Copy string to pattern buffer
	HRROI A,PATSTR
	SETZ C,
	SOUT
STQSB1:	MOVEI A,(X)			;Routine addrs
	JRST STQDL0

STQBEF:	SKIPA X,[NXTBEF]		;Before date
STQAFT:	 MOVEI X,NXTAFT			;After date
	JRST STQON1

STQON:	MOVEI X,NXTON			;On date
STQON1:	NOISE (DATE)
	CALL GETDAT
	MOVEM B,NXTIME
	JRST STQSB1

STQKEY:	SKIPA X,[NXTKEY]		;Keyword
STQUNK:	 MOVEI X,NXTUNK			;Unkeyword
	CALL GETKEY
	HLLM U,KEYBTS			;Save bits
	JRST STQSB1

;;;Get the next message in this sequence and maybe type out its number

NXTMSG:	CALL @NXTMSD			;Get next
	 JRST NXTMS6			;All done, finish up
	AOS (P)				;Skip return when done
	MOVEI A,NXTSEQ			;Already a numeric sequence?
	CAMN A,NXTMSD
	 JRST NXTMS2			;No, return with message
	MOVEI A,(M)			;Copy of new current message
	IDIVI A,MSGLEN
	JUMPL L,NXTMS1			;Always start new when beginning
	LDB B,L				;Get last one out
	TRZN B,2000			;Already a range?
	 HRROS B			;No, must use next slot
	CAIN A,1(B)			;Next in numeric order?
	 TROA A,2000			;Yes, construct a range
	  CAIA
	   JUMPGE B,[DPB A,L		;Put it in place
		     JRST NXTMS2]
NXTMS1:	IDPB A,L			;Use next slot
NXTMS2:	TLNN F,(F%TYPS)			;Want to type out numbers?
	 RET				;No, all done
	SKIPGE A,LSTMSG			;Any last message?
	 JRST NXTMS5			;No, install this one then
	CAIN M,MSGLEN(A)		;Yes, is this one the next one?
	 JRST NXTMS4			;Yes, keep accumulating
	CALL PRTSEQ			;Print what is there now otherwise
NXTMS3:	HRLM M,LSTMSG			;And set ourselves up as start
NXTMS4:	HRRM M,LSTMSG			;Set ourselves up as next link in chain
	RET

NXTMS5:	TLZ F,(F%COMA)			;Reset comma flag
	JRST NXTMS3

NXTMS6:	MOVEI A,NXTSEQ
	MOVEI B,3777
	CAME A,NXTMSD
	 IDPB B,L			;Mark end of sequence if we generated one
	TLNN F,(F%TYPS)			;Finishing up, type last number?
	 RET				;No, done
PRTSEQ:	TLOE F,(F%COMA)			;Maybe a comma first
	 PRINT ","
	PRINT " "
	MOVEI A,.PRIOU
	HLRZ T,LSTMSG			;Get start of sequence
	MOVEI B,MSGLEN(T)
	IDIVI B,MSGLEN
	MOVEI C,^D10
	NOUT
	 NOP
	HRRZ B,LSTMSG			;Get end
	CAIN B,(T)			;Same?
	 RET				;Yes, that's it
	PRINT ":"
	ADDI B,MSGLEN
	IDIVI B,MSGLEN
	MOVEI C,^D10
	NOUT
	 NOP
	RET

;;;Get next message selecting routines

NXTTHS:	JUMPGE M,CPOPJ			;Already did it, done now
	HRRZ M,LSTMSG			;Else get it
	JRST CPOPJ1			;And skip return

NXTSEQ:	SKIPE A,RPVSAV			;Have a recorded backtrack?
	 CAIE M,(A)
	 CAIA
	 JRST [	SETZM RPVSAV
		HLRZM A,NXTMSD		;Yes, unwound back to where we were
		JRST @NXTMSD]		;Reenter old mode
	JUMPL L,NXTSQ1			;Always get it at start
	LDB A,L				;Get last one
	TRZN A,2000			;Part of range?
	 JRST NXTSQ1			;No, get next byte then
NXTSQ0:	IMULI A,MSGLEN
	CAIGE M,(A)			;Before end of range?
	 JRST [	ADDI M,MSGLEN
		JRST CPOPJ1]		;Yes, increment toward it
	CAIE M,(A)			;At end of range?
	 JRST [	SUBI M,MSGLEN
		JRST CPOPJ1]		;No, decrement toward it
NXTSQ1:	ILDB A,L			;Get next byte
	CAIN A,3777			;End?
	 RET				;Yes, single return
	TRZE A,2000
	 JRST NXTSQ0
	IMULI A,MSGLEN
NXTSQ2:	MOVEI M,(A)			;No, this is next message
	JRST CPOPJ1			;Skip return

NXTANS:	SKIPA B,[M%RPLY]		;Answered
NXTSEE:	 MOVEI B,M%SEEN			;Seen => seen bit set
	JRST NXTDL0

NXTFLG:	SKIPA B,[M%ATTN]		;Flagged
NXTDEL:	 MOVEI B,M%DELE			;Deleted
NXTDL0:	SKIPA C,[TDNE B,MSGBTS(A)]	;Bit must be set
NXTREC:	 MOVE C,[SKIPGE MSGFLG(A)]	;Recent
	JRST NXTAL0

NXTUNA:	SKIPA B,[M%RPLY]		;Unanswered
NXTUNF:	 MOVEI B,M%ATTN			;Unflagged
	JRST NXTUD0

NXTUNS:	SKIPA B,[M%SEEN]		;Unseen => seen bit clear
NXTUND:	 MOVEI B,M%DELE			;Undeleted
NXTUD0:	SKIPA C,[TDNN B,MSGBTS(A)]	;Bit must be clear
NXTALL:	MOVSI C,(<NOP>)			;All => pass all thru
NXTAL0:	MOVEI A,MSGLEN(M)		;Start here
NXTAL1:	CAMLE A,LASTM			;Done?
	 RET				;Yes, return
	XCT C				;Test it out
	 JRST NXTSQ2			;Matches
	ADDI A,MSGLEN
	JRST NXTAL1			;No good, try next one

NXTREV:	JUMPGE M,NXTRV1			;First time here?
	HRRZ A,LASTM			;Yes - start at end
	JRST NXTSQ2

NXTRV1:	HRREI A,-MSGLEN(M)		;Try next
	JUMPGE A,NXTSQ2			;Keep going till all done
	RET

NXTNEW:	MOVEI A,MSGLEN(M)		;New
NXTNW1:	CAMLE A,LASTM
	 RET
	MOVEI B,M%SEEN
	SKIPGE MSGFLG(A)		;New => recent
	 TDNE B,MSGBTS(A)		;& unseen
	  CAIA
	   JRST NXTSQ2
	ADDI A,MSGLEN
	JRST NXTNW1			;No, keep looking

NXTKEY:	HLLZ B,KEYBTS			;Get the bits to mask against
	JRST NXTDL0			;Print those with bits set
NXTUNK:	HLLZ B,KEYBTS
	JRST NXTUD0

;;;Find substring in From field

NXTSBJ:	SKIPA C,[CALL SBJSTR]		;Routine to match Subject string
NXTFRM:	MOVE C,[CALL FRMSTR]		;Routine to match From string
	JRST NXTAL0			;Use common loop

NXTTO:	SKIPA C,[CALL TOSTR]		;Routine to match To string
NXTTXT:	 MOVE C,[CALL TXTSTR]		;Routine to match text substring
	JRST NXTAL0

FRMSTR:	PUSH P,A
	PUSH P,C
	MOVEI T,PATSTR			;String to match
	HRRZ V,MSGFRM(A)		;From field for this message
	HLRZ W,MSGFRM(A)
FRMST2:	PUSH P,M
	HRRZM A,M			;Setup this temporarily so search works
	CALL SEARCH			;Look for string
FRMST3:	 AOS -3(P)			;Didnt find it, skip return
POPMCA:	POP P,M
POPCA:	POP P,C
	POP P,A
	RET				;Found - use this

SBJSTR:	PUSH P,A			;Messages with string in subject
	PUSH P,C
	MOVEI T,PATSTR			;String to match
	HRRZ V,MSGSUB(A)		;Subject field for this message
	HLRZ W,MSGSUB(A)
	JRST FRMST2

TXTSTR:	PUSH P,A			;Messages with string in their body
	PUSH P,C
	MOVEI T,PATSTR
	HRRZ V,MSGBOD(A)
	HLRZ W,MSGBOD(A)
	JRST FRMST2

TOSTR:	PUSH P,A			;Messages with string in to or cc field
	PUSH P,C
	PUSH P,M
	MOVEI M,(A)			;Temporarily point to right message
	MOVEI T,[ASCIZ /
To: /]
	CALL FNDHDR
	 JRST FRMST3			;Didn't find it, skip return
	POP P,M
	TDZA W,W
TOSTR1:	 ADDI W,2			;Count the crlf too
	CALL FNDSB2			;Count characters in this line
	IBP A				;Skip LF too
	ILDB T,A
	CAIE T,11
	 CAIN T," "			;Continuation line?
	  JRST TOSTR1			;Yes, get some more
	CAIE T,"T"
	 CAIN T,"t"
	  JRST TOSTR2
	CAIE T,"C"
	 CAIN T,"c"
	  JRST TOSTR4
	MOVE A,-1(P)
	MOVEI T,PATSTR
	JRST FRMST2			;End of recipients, go do the search

TOSTR2:	ILDB T,A			;Looking for TO:
	CAIE T,"O"
	 CAIN T,"o"
	  JRST TOSTR3
	JRST FRMST2

TOSTR3:	ILDB T,A
	CAIE T,":"
	 JRST FRMST2
	ADDI W,3			;Count TO: itself
	JRST TOSTR1

TOSTR4:	ILDB T,A			;Looking for CC:
	CAIE T,"C"
	 CAIN T,"c"
	  JRST TOSTR3
	JRST FRMST2

NXTBEF:	SKIPA C,[CAMLE B,MSGDAT(A)]	;Before date
NXTAFT:	 MOVE C,[CAMG B,MSGDAT(A)]	;After date
	MOVE B,NXTIME
	JRST NXTAL0

NXTON:	MOVE C,[CALL NXTON1]		;On date
	JRST NXTAL0

NXTON1:	MOVE B,MSGDAT(A)
	SUB B,NXTIME
	TLNE B,-1			;More than a day's difference?
	 AOS (P)			;Yes, fail
	RET

SUBTTL Sending subroutines

SNDINI:	TRZ F,F%RPLY			;Assume not a reply to anyone
	SKIPN LHOSTN			;Have name info yet?
	 CALL NAMINI			;No
	CALL .ERSAL			;Go erase everything
	SETZM RMLPTR			;Not remail yet
	SKIPN DEFCCL			;Any default cc list?
	 RET				;No
	MOVE A,[POINT 7,DEFCCL]
	SETZ E,
	TLO F,(F%CC)			;As cc recipients
	TLZ F,(F%F4)
	CALL PRADDR			;Process list of bug report recipients
	MOVEI T,BCCLST			;Set up BCC list
	JRST ADDTO0			;Go add whole bunch to list then

PRADDT:	TLZ F,(F%F4)
	CALL PRADDR			;Process list of bug report recipients
	JRST ADDTO			;Go add whole bunch to list then

NAMINI:
ARPA,<
NOREL4,<
	MOVE A,[SIXBIT /LHOSTN/]
	SYSGT
	MOVEM A,LHOSTN
	JUMPL A,NAMIND			;Don't have Arpanet at all, try DECNET
	MOVEI B,(A)
	MOVE A,[POINT 7,MYHNAM,27]
	CVHST
	 JFATAL (CVHST failed on local host)
>;NOREL4
REL4,<
	MOVEI A,.GTHNS			;Get host number and name
	MOVE B,[POINT 7,MYHNAM,27]
	SETO C,				;My host number/name
	GTHST%
	 ERJMP NAMIND			;Not on Arpanet, try DECNET
	MOVEM C,LHOSTN			;Set LHOSTN
>;REL4
	RET				;Don't bother with DECNET if an Arpanet
>;ARPA
NOARPA,<
NOSPCH,<
	SETOM LHOSTN			;Currently only SPEECH has a net up
>;NPSPCH
NAMINS:
COL,<	MOVEI B,[ASCIZ /COLUMBIA/]>;COL
GSB,<	MOVEI B,[ASCIZ /SU-GSB/]>;GSB
LOTS,<	MOVEI B,[ASCIZ /SU-LOTS/]>;LOTS
SUMX,<	MOVEI B,[ASCIZ /SUMEX-20/]>;SUMX
SPCH,<	MOVEI B,[ASCIZ /MIT-SPEECH/]>;SPCH
IFN .-NAMINS,<
	MOVE A,[POINT 7,MYHNAM,27]
	JRST MOVST0
>;IFN .-NAMINS
>;NOARPA

NAMIND:
DECN,<
REL4,<
	SETOM LHOSTN			;Note we don't have Arpanet
>;REL4
	MOVEI A,.NDGLN			;Get DECNET local hostname
	PUSH P,[POINT 7,MYHNAM,27]
	MOVEI B,(P)
	NODE
	 ERJMP .+2
	TRO F,F%DECN			;Have DECNET if success
	ADJSP P,-1
>;DECN
	RET

NOHST2,<
HSTINI:	MOVEI A,HOSTAB			;Return pointer to host table
	MOVEM A,HSTPTR
	PUSH P,E
	PUSH P,T
	MOVEI A,777			;Length of table (max)
	MOVEM A,HOSTAB
	MOVEI E,HOSTN			;Init free pointers for host numbers
	MOVEI T,HSTNAM			;And names
	SKIPN LHOSTN			;Have name info yet?
	 CALL NAMINI			;No
	SKIPG LHOSTN
	 JRST HSTIND			;Try to get DECNET hosts
	MOVE A,[SIXBIT /HSTNAM/]
	SYSGT
	HLRE A,B			;Get length
	SUB T,A				;Increment free pointer
	HRRO A,B
	MOVEI B,HSTNAM			;Get table of host names
	GTBLT
	 ERCAL $GTBLT
	MOVE A,[SIXBIT /HOSTN/]
	SYSGT
	HLRE A,B
	SUB E,A				;Increment free pointer
	HLLZ C,B			;Save AOBJN pointer
	HRRO A,B
	MOVEI B,HOSTN			;Where to put host numbers
	GTBLT
	 ERCAL $GTBLT
HSTIN1:	MOVSS B,HOSTN(C)		;Get entry
	MOVEI A,377
	ANDM A,HOSTN(C)			;Clear all but host number
	HRRI B,HOSTN(C)
	ADD B,[HSTNAM,,0]		;Make relative pointer
	MOVEI A,HOSTAB			;Host name table
	TBADD
	AOBJN C,HSTIN1

;;;Init DECNET hosttable

HSTIND:
DECN,<
	TRNN F,F%DECN			;Is there one?
	 JRST HSTINE			;No, done
	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,[ASCIZ /SYSTEM:DECNET-HOSTS.TXT/]
	GTJFN
	 JFATAL (Can't find DECNET host table)
	MOVE B,[7B5+OF%RD]
	OPENF
	 JFATAL (Can't open DECNET host table)
	MOVEM A,TMPJFN			;Save it away
HSTID1:	MOVE A,TMPJFN
	HRROI B,(T)			;Where to start string
	MOVEI C,HSTNAM+1777
	SUBI C,(T)
	IMULI C,5			;Amount of room left
	MOVEI D,12			;Until end of line
	SIN
	 ERJMP HSTID2			;Must be eof
	JUMPE C,[FATAL (Host table buffer exhausted)]
	ADD B,[7B5]
	SKIPGE B
	 SUB B,[43B5+1]			;Back up byte pointer
	MOVEI D,0
	DPB D,B				;Replace CR with null
	HRROI B,1(B)
	EXCH B,T			;Update free pointer
	HRLI B,1			;Mark DECNET host
	MOVEM B,(E)			;Save number
	MOVE A,HSTPTR
	MOVSI B,(B)
	HRRI B,(E)
	TBADD
	CAIL E,HOSTN+777
	 FATAL (Host number buffer exhausted)
	AOJA E,HSTID1

HSTID2:	CALL CLSTMP
>;DECN
HSTINE:	POP P,T
	POP P,E
	MOVE A,HSTPTR			;Return pointer to things
	RET				;Done

;;;GTBLT simulator

$GTBLT:	PUSH P,C
	PUSH P,D
	MOVEI C,(A)			;Save table number
	GETAB				;Get number of entries
	 JFATAL (GETAB failed for GTBLT)
	HRLZ D,A			;Form AOBJN pointer
	HRLI B,D
GTBLT1:	MOVEI A,(C)			;Table number
	HRLI A,(D)			;Index
	GETAB
	 JFATAL (GETAB failed for GTBLT)
	MOVEM A,@B
	AOBJN D,GTBLT1
	POP P,D
	POP P,C
	RET
>;NOHST2

HOSTS2,<
;;;Read in the HOSTS2 table

HSTINI:	SKIPN LHOSTN			;Have name info yet?
	 CALL NAMINI			;No
	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,[ASCIZ /SYSTEM:HOSTS2.BIN/]
	GTJFN
	 JFATAL <Cannot find host table>
	MOVEI B,OF%RD
	OPENF
	 JFATAL <Cannot open host table>
	SIZEF
	 JFATAL <Cannot get host table size>
	MOVSI A,(A)			;Start with page 0
	MOVE B,[.FHSLF,,HSTPAG/1000]
	HRLI C,(PM%CNT!PM%RD!PM%CPY)
	PMAP
	MOVE A,HSTPAG+HSTSID
	CAME A,[SIXBIT /HOSTS2/]
	 FATAL <Host table has bad format>
	MOVE A,HSTPAG+NAMPTR		;pointer to name table
	ADDI A,HSTPAG+1
	MOVEM A,HSTPTR			;setup pointer to tbluk table
	HRL A,-1(A)			;number of entries
	HLRM A,(A)
	HLLM A,(A)
	ADD A,[-1,,1]			;Form AOBJN pointer
	TLC A,-1
	MOVE B,[HSTPAG,,HSTPAG]
HSTIN1:	ADDM B,(A)
	MOVSS C,(A)
	MOVE D,(C)			;May be pointed to more than once, so
	TRNN D,700000			;if right half address unnormalized,
	 ADDI D,HSTPAG			;do it now
	TLNN D,700000			;Same for left half
	 ADD D,[HSTPAG,,]
	MOVEM D,(C)
	AOBJN A,HSTIN1
	MOVE A,HSTPTR
	MOVE B,[POINT 7,MYHNAM,27]
	TBLUK
	HRRZ C,(A)
	HLRZ C,(C)			;Get pointer to official name
	MOVEM C,LHOSTP			;Also save the pointer
	MOVE A,HSTPTR
	RET
>;HOSTS2

;;;Host name converter
;;;a/ destination string pointer
;;;b/ zero for local host, host address if not HOSTS2, pointer to address entry
;;;	if HOSTS2

$CVHST:
HOSTS2,<
	JUMPN B,CVHDCN			;If non-zero, must be a pointer
>;HOSTS2
NOHST2,<
	JUMPE B,CVHST2
DECN,<
	HLRZ C,B			;Get network type
	JUMPN C,CVHDCN			;Non-zero DECNET for now
>;DECN
	MOVEI C,10			;Just in case
	CVHST
	 NOUT
	  NOP
	RET
>;NOHST2

CVHST2:	SKIPA B,[POINT 7,MYHNAM,27]	;Use local host-name if none there now
CVHDCN:	 HRLI B,(<POINT 7,0>)
NEWQ,<
	TLNE F,(F%NEWQ)
	 JRST [	PUSH P,B
		MOVEI B,177
		BOUT
		POP P,B
		CALL .+1
		HRROI B,[BYTE (7) 177,0]
		SOUT
		RET]
>;NEWQ
	SETZ C,
	SOUT
	RET

;;;Send the current message off

SNDMS0:	CALL GETTO			;Insist upon having a to-list
SNDMSG:	SKIPN TOLIST			;Must have some addresses?
	 JRST SNDMS0			;Get
	TLZ F,(F%F5)			;Haven't got funny SAVFIL yet
	MOVE A,TXTPTR			;Get end of message
	MOVEI B,[ASCIZ /
/]
	LDB C,A
	CAIN C,12			;Unless ended with CRLF
	 JRST .+3
	CALL MOVST0			;Put one in now
	ADD A,[7B5]			;And back over the null
	MOVEM A,TXTPTR
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Get my logged directory name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ />MAIL.CPY.-1;P770000;T/]
	CALL MOVST0			;And the null
	MOVSI A,(GJ%FOU!GJ%NEW!GJ%SHT)
	HRROI B,STRBUF			;Get it back
	GTJFN
	 JERROR (Can't get MAIL.CPY)
	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Can't open MAIL.CPY)
	HRROI B,TXTPAG
	SETZ C,
	SOUT
	RFPTR
	 JERROR
	SKIPN RMLPTR			;Unless remail
	 ADDI B,9			;Count for dashes later
	MOVEM B,MSGSIZ			;Save size of text portion of message
STAN,<
	DELF				;Make file deleted
	 JERROR
>;STAN
	CLOSF
	 NOP
	SKIPN LCLIST			;Any local recipients?
	 SKIPE FILIST			;Or file recipients?
	  JRST SNDMS1
	SKIPN SAVFIL			;Or uses SAVED.MESSAGES feature
	 JRST SNDMS2			;No, just go send network out then
SNDMS1:	TLZ F,(F%AT)			;Setup headers for local recipients
	PUSH P,MSGSIZ
	CALL SETHDR
	CALL SNDLCL			;Try to send local messages
IPCF,<
	MOVE A,0(P)			;Get back original msg size, since
	MOVEM A,MSGSIZ			;We are starting over with the header
	SKIPN FILIST			;Any file recipients?
	 SKIPE SAVFIL
	  CALL SETHDF			;Yes, local headers and from: field
>;IPCF
	CALL SNDFIL			;Try to send file messages
	SKIPL RINCME			;Special include me mode?
	 JRST SNDMS3			;No
	TLZN F,(F%F5)			;Yes, did we see that address?
	 SETZM SAVFIL			;No, dont send any file guy then
SNDMS3:	CALL FILMSG			;Store SAVED.MESSAGES
	POP P,MSGSIZ
SNDMS2:	SKIPN NETLST			;Any network recipients?
	 RET
NEWQ,<
	TLO F,(F%AT!F%NEWQ)		;Set headers for network recipients
>;NEWQ
NONEWQ,<
	TLO F,(F%AT)
>;NONEWQ
	CALL SETHDR
	CALL SNDNET
	JRST MAIFLG			;Set MAILER.FLAGS for our queued mail

;;;Setup header of message for this kind of recipient

SETHDR:	SKIPE A,RMLPTR			;Doing remail command?
	 JRST SRMLH1			;Yes
IPCF,<
SIPCF,<
NOSTAN,<	;Only Columbia, Rutgers and DREA need this
	TLNN F,(F%AT)			;ARPA address?
	 JRST SETHD2			;No, make shorter header
>;NOSTAN
>;SIPCF
NOSIPCF,<
	TLNN F,(F%AT)			;ARPA address?
	 JRST [	MOVE O,[POINT 7,HDRPAG]
		CALL MOVSUB		;No, just put in subject
		JRST SRMLH3]		;Rejoin common code
>;NOSIPCF
SETHDF:
>;IPCF
	MOVE A,TXTPTR
	MOVEI B,[ASCIZ /-------
/]
	CALL MOVST0			;Put in dashes at end
	SKIPA A,[POINT 7,HDRPAG]	;Start of where to assemble msg headers
SRMLH1:	 SKIPA B,[[ASCIZ /Remailed-date: /]]
	  MOVEI B,[ASCIZ /Date: /]
	CALL MOVSTR
	SETO B,				;Now
	MOVSI C,(OT%4YR!OT%SPA!OT%NSC!OT%NCO!OT%TMZ)	;"12 Dec 1977 1906-PST"
	ODTIM
	SKIPE RMLPTR
	 JRST [	MOVEI B,[ASCIZ /
Remailed-from: /]
		JRST SRMLH2]
	CALL CHKUSR			;Check the user name variable
	 JRST SETHD5
	MOVEI B,[ASCIZ /
Sender: /]
	CALL MOVSTR
	MOVE B,MYDIR			;Login directory
	DIRST
	 JFATAL
	TLNN F,(F%AT)
	 JRST SETHD5
NONEWQ,<
	MOVEI B,MYHNAM
	CALL MOVSTR
>;NONEWQ
NEWQ,<
	CALL MOVMHN			;Output local host
>;NEWQ
SETHD5:	MOVEI B,[ASCIZ /
From: /]
SRMLH2:	CALL MOVSTR
	TLNN F,(F%AT)
	 JRST SETHD3
	SKIPE HDR733			;Wants Person <NAME at SITE>?
	 SKIPN PERNAM			;And has a personal name?
	  JRST SETHD3			;No or no
	MOVEI B,PERNAM
	CALL MOVSTR
	MOVEI B,[ASCIZ / </]		;>
	CALL MOVSTR
SETHD3:	MOVEI B,MYDIRS			;My name
	CALL MOVSTR			;Put it in
	TLNN F,(F%AT)			;Going to network?
	 JRST SETHD1			;No
NONEWQ,<
	MOVEI B,MYHNAM
	CALL MOVSTR			;Yes, put in at SITE (Mumble)
>;NONEWQ
NEWQ,<
	CALL MOVMHN
>;NEWQ
	SKIPN PERNAM			;Has a personal name?
	 JRST SETHD1
	SKIPE HDR733			;Generate brocket style from?
	 JRST SETHD4			;Yes
	MOVEI B,[ASCIZ / (/]
	CALL MOVSTR
	MOVEI B,PERNAM
	CALL MOVSTR
	SKIPA B,[")"]
SETHD4:	 MOVEI B,">"
	IDPB B,A
SETHD1:	SKIPA O,A			;Get pointer set up right
SETHD2:	 MOVE O,[POINT 7,HDRPAG]
	SKIPE RMLPTR			;Remail command?
	 JRST [	MOVEI T,[ASCIZ /
Remailed-to: /]
		MOVE A,[IDPB A,O]	;Output to string
		MOVEM A,MOVDSP
		CALL MOVTRM
		JRST SRMLH3]
	CALL MOVUSH			;Insert user-generated headers
	CALL MOVSUB			;Insert subject
	CALL MOVTO			;And to
	CALL MOVCC			;And CC
	SKIPLE REPDAT			;Has a reply date?
	 CALL MOVRDT			;Yes, insert it too
SRMLH3:	MOVEI B,[ASCIZ /

/]
	CALL MOVSB2			;And a couple blank lines
	SETZ A,
	IDPB A,O			;Mark end of this with a null too
	LDB B,[POINT 6,O,5]
	IDIVI B,7
	MOVEI A,1-HDRPAG(O)
	IMULI A,5			;Compute number of characters used in headers
	SUBI A,1(B)
	ADDM A,MSGSIZ			;Update size of whole thing
	RET

;;;Check that the user name variable is ok

CHKUSR:	PUSH P,A
	MOVSI A,(RC%EMO)
	HRROI B,MYDIRS
	RCUSR
	 ERJMP CHKUS2
	TLNE A,(RC%NOM!RC%AMB)		;No good?
	 JRST CHKUS2			;Yes, fix it up then
	CAME C,MYDIR			;Same as login directory?
	 AOS -1(P)			;No, need to put in sender field then
	JRST CPOPAJ
	
CHKUS2:	HRROI A,MYDIRS
	MOVE B,MYDIR
	DIRST
	 NOP
	JRST CPOPAJ

;;;File away the message in SAVED.MESSAGES if in logged directory

FILMSG:	SKIPN SAVFIL			;Wants one at all?
	 RET				;No
	MOVEI T,M%SEEN			;Mark message as seen
	HRROI B,SAVFIL
	MOVSI A,(GJ%OLD!GJ%SHT)		;Enter here to send to a file
FILMS1:	GTJFN				;Try to get guy's SAVED.MESSAGES
	 RET				;Not there, don't worry about it
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JERROR (Couldn't open file recipient)
	SKIPLE SNDVBS			;Verbose sending mode?
	 TLOA F,(F%F1)			;Yes, type out filename
FILMS2:	  TLZ F,(F%F1)			;Dont type out filename
	SETO B,				;Now
	MOVSI C,(OT%TMZ)		;Timezone as well
	ODTIM
	MOVEI B,","
	BOUT
	MOVE B,MSGSIZ			;Get back size
	MOVEI C,^D10			;Decimal
	NOUT
	 JERROR
	MOVEI B,";"
	BOUT
	MOVE B,T			;Bits to put in
	MOVE C,[NO%LFL!NO%ZRO!NO%MAG!14B17!10] ;"000000000000"
	NOUT
	 JERROR
	HRROI B,CRLF0
	SETZ C,
	SOUT				;Write header bits and crlf
	HRROI B,HDRPAG
	SOUT				;Copy the headers
	HRROI B,TXTPAG
	SOUT				;And the text
	TLZE F,(F%F1)			;Want filename?
	 CIETYP < *%1J -- ok>
	CLOSF
	 JWARN (Couldn't close message file)
	RET

;;;Send other disk file recipients

SNDFIL:	HRRZ W,FILIST
SNDFL1:	JUMPE W,CPOPJ			;Done with file recipients
	MOVEI T,0			;Mark as unseen
	MOVSI A,(GJ%SHT)
	HRROI B,4(W)			;Get name of file
	CALL FILMS1			;Send it off
	HRRZ W,1(W)			;Get next one
	JRST SNDFL1

NOIPCF,<				;If doing local appending
;;;Try to send local mail, queue what we can't handle now

SNDLCL:	HRRZ W,LCLIST			;Get start of local recipients
SNDLC1:	JUMPE W,CPOPJ			;Done with list
	MOVE A,2(W)			;Is this special local recipient?
	AOJE A,[TLON F,(F%F5)		;Yes, setup as saved.messages file
		 SKIPE SAVFIL		;Unless have one from moving
		  JRST SNDLC2
		HRROI A,SAVFIL
		MOVE B,MSGJFN
		SETZ C,
		JFNS
		JRST SNDLC2]
	CALL SNDMSL			;Try to send locally
	 JRST SNDLC3
SNDLC2:	HRRZ W,1(W)			;Get next in list
	JRST SNDLC1

SNDLC3:	SETZM 2(W)			;Clear host/user number for this guy
	MOVEI B,NETLST			;Thread entry into network recipients
	MOVEI U,(W)
	HRRZ W,1(W)			;Get next link for next time
	SETZM 1(U)			;Clear any previous links
	CALL ADDLST			;Add onto this list
	 NOP				;Dont worry about duplicate
	JRST SNDLC1			;And try some more

;;;Attempt to deliver local mail right away for this user

SNDMSL:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,4(W)			;Local user name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ />MAIL.TXT.1/]
	CALL MOVST0			;And the null
;  The following code is here due to a moby loss in GTJFN.  If both GJ%FOU
; and GJ%OLD are set, and the destination mail file is deleted, permanent,
; and empty, what happens is that the file is depermanentized, flushed, and
; the GTJFN fails.
;  This bug exists in both release 3 and release 4.
	MOVSI A,(GJ%OLD!GJ%DEL!GJ%SHT)	;Verify there is a mail file there
	HRROI B,STRBUF
	GTJFN
	 RET				;Not there, single return
	RLJFN				;Now get rid of this JFN
	 NOP
	MOVSI A,(GJ%FOU!GJ%DEL!GJ%SHT)	;Get the JFN we really want
	HRROI B,STRBUF
	GTJFN				;Try to get guys mail file
	 RET				;This shouldn't have happened, oh well
	MOVEM A,OUTJFN			;Save it
	MOVE B,[7B5+OF%APP]		;Open for append
	OPENF
	 JRST [	MOVE A,OUTJFN
		RLJFN
		 NOP
		RET]
	MOVEI T,0			;Mark as unseen
	CALL FILMS2			;Go actually append it
	MOVEI A,4(W)			;Get the guy's name again
	SKIPL SNDVBS			;Super-terse sending?
	 CIETYP < %1S -- ok>		;No, tell of local sending
	JRST CPOPJ1			;Skip return for success
>;NOIPCF

IPCF,<
;;;Send local mail via IPCF mailer

SNDLCL:	SKIPN W,LCLIST			;Any local mail to do?
	 RET				;No, forget it then
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Get my logged directory name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ />MSG.TMP.-1;P770000;T/]
	CALL MOVST0			;And the null
	MOVSI A,(GJ%FOU!GJ%NEW!GJ%SHT)
	HRROI B,STRBUF			;Get it back
	GTJFN
	 JERROR (Can't get temp file)
	MOVE B,[44B5+OF%WR]		;Open initially in 36-bit mode
	OPENF
	 JERROR (Can't open temp file)
	MOVEM A,TMPJFN
SIPCF,<
	MOVSI B,(FL%MM)			;Flag for our own headers
>;SIPCF
NOSIPCF,<
	SETZ B,				;DEC doesn't have this feature
>;NOSIPCF
	BOUT
SNDLC1:	MOVE B,2(W)			;Get directory number
	CAME B,[-1]			;Special local one?
	 JRST SNDL1A
	TLON F,(F%F5)			;Yes, use saved.messages file
	 SKIPE SAVFIL			;If have it from move command
	  JRST SNDLC2
	MOVE B,MYDIR			;Otherwise just reply to me
SNDL1A:	BOUT
SNDLC2:	HRRZ W,1(W)			;Get next in list
	JUMPN W,SNDLC1			;For all
	SETZ B,				;Mark end of list
	BOUT
	BOUT
	MOVEI B,7			;Now get ready to output text
	SFBSZ
	 JERROR
	HRROI B,HDRPAG			;Output our headers
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;And text of message
	SETZ C,
	SOUT
	HRLI A,(CO%NRJ)			;Close but keep the jfn for later
	CLOSF
	 JWARN (Couldn't close temp file)

;;;Now try to find IPCF mailer

IPCFI:	TLZ F,(F%F1)			;Flag for warning message
	SKIPE PIDGET+1			;Have a PID already?
	 TDZA A,A			;Yes, use it
IPCFI1:	  MOVSI A,(IP%CPD)		;No, make one with first message
	MOVEM A,PIDGET
IPCFI2:	MOVEI B,PIDGET			;Get [SYSTEM]MAILER's PID
	SETZM PIDGET+2			;Send to info
	MOVEI A,4			;Length of block
	MSEND
	 JRST [	TLON F,(F%F1)		;Already gave warning?
		 JWARN <Waiting...>
		SETZM PIDGET+1		;Maybe our pid was invalid
		MOVEI A,^D500		;Wait 1/2 sec
		DISMS
		JRST IPCFI1]
	MOVSI A,(IP%CPD)		;Dont need to make a pid any more
	ANDCAM A,PIDGET
IPCFI3:	SETZB T,U			;No flags, any sender
	MOVE V,PIDGET+1			;The pid i got last time
	MOVE W,[10,,WRTPGS]		;Some place for messages
	MOVEI A,4			;Size of block
	MOVEI B,T			;Pointer to block
	MRECV				;Get message from info
	 NOP
	LDB U,[POINT 3,T,32]		;See who sent message
	CAIE U,1			;From monitor
	 CAIN U,2			;Or info
	  CAIA				;Yes, good
	   JRST IPCFI3			;No, get another message
	TRNE T,7			;Was it undeliverable?
	 JRST IPCFI2			;Yes, try sending it again
	LDB U,[POINT 6,T,29]		;Get error field
	JUMPE U,IPCFM			;None
	CAIN U,.IPCSN			;INFO crash?
	 JRST IPCFI3			;Yes, go get more messages
	MOVEI A,[ASCIZ /MAILER not running/]
	JRST SNLQAL			;Go queue all messages

;;;Now send to MAILER file to process

IPCFM:	MOVE V,WRTPGS+1			;Get MAILER's PID
	MOVEM V,PIDGET+2		;Save for later too
	SETZB D,WRTPGS
	HRROI A,WRTPGS+1
	MOVE B,TMPJFN			;Temp file
NOCOL,<
	MOVE C,[001110,,1]		;Don't print structure or directory
>;NOCOL
NOCOL,<
	MOVE C,[111110,,1]		;Print all fields
>;NOCOL
	JFNS
	IDPB D,A			;Move over null
	MOVSI W,-WRTPGS(A)		;Get length of string
	MOVEI A,(B)			;Now can get rid of jfn
	RLJFN
	 NOP
	SETOM TMPJFN
	HRRI W,WRTPGS+1			;Where message is
	SETZ T,				;No flags
	MOVE U,PIDGET+1			;Sent by me
IPCFM1:	MOVEI A,4			;Length
	MOVEI B,T			;Address
	MSEND
	 JRST [	MOVEI A,^D500		;Failed, wait a bit
		DISMS
		JRST IPCFM1]
	CITYPE <Processing local mail...>
IPCFM2:	MOVEI A,4
	MOVEI B,T
	SETZB T,U
	MOVE V,PIDGET+1
	MOVE W,[1000,,WRTPGS+1000]
	MRECV				;Get message from MAILER
	 NOP
	LDB B,[POINT 3,T,32]		;Get sender type
	JUMPE B,IPCFO			;Not special, must be mailer
	CAIE B,2			;From info
	 CAIN B,3			;Or private info
	  JRST IPCFM2			;Yes, get some more
	MOVEI A,[ASCIZ /Could not send to MAILER/]
	JRST SNLQAL			;Queue them all if network

;;;Now see how things got sent

IPCFO:	CAME U,PIDGET+2
	 JRST IPCFM2			;Not from mailer, get some more
	LDB T,[POINT 6,T,29]		;Get error code
	JUMPE T,IPCFN			;No errors
	CAIE T,NACK1			;Total wipeout?
	 JRST IPCFE			;No, tell what happened
	MOVEI A,[ASCIZ /Processing errors occurred/]
	JRST SNLQAL

;;;Report errors or queue failures

IPCFE:	SUB W,[1,,0]
	TLC W,-1			;Form aobjn pointer
	HRRI W,WRTPGS+1000		;Point to list of failed things
IPCFE1:	MOVE T,1(W)			;Get bad guy
	MOVE U,LCLIST			;Get list of local recipients
IPCFE2:	CAMN T,2(U)			;This the guy?
	 JRST IPCFE3			;Yes
	HRRZ U,1(U)			;Get next in list
	JUMPN U,IPCFE2
	WARN < Error reported for %6U, but mail not sent>
	JRST IPCFE5			;Forget about it

IPCFE3:	EXCH U,W
	CALL REMLST			;Remove from present list
	EXCH U,W
	SKIPL LHOSTN			;Are we going to be able to queue this?
	 JRST IPCEF8			;Yes, go do so
	HLRZ B,(W)			;Get error type from mailer
	JUMPE B,IPCFE7			;JSYS type error?
	CAIN B,1			;Message within range of known?
IPCFE4:	 TDZA A,A			;No, dont have anything
	  MOVEI A,[ASCIZ / because of quota exceeded/]
IPCFE5:	MOVEI C,4(U)
	CIETYP < %3S not sent%1S>
IPCFE6:	AOBJN W,.+1
	AOBJN W,IPCFE1			;Go handle next baddie
	JRST IPCFN

IPCFE7:	HRRZ B,(W)			;Get error code
	JUMPE B,IPCFE4
	MOVEI A,[ASCIZ / because of %2E/]
	JRST IPCFE5

IPCEF8:	SETZM 1(U)			;Queue for mailing through network
	SETZM 2(U)
	MOVEI B,NETLST
	CALL ADDLST
	 NOP
	JRST IPCFE6

;;;Print out successes now too

IPCFN:	SKIPL SNDVBS			;Doesnt want to here about this
	 SKIPN U,LCLIST
	  RET
IPCFN1:	MOVEI A,4(U)			;Get user name string
	CIETYP < %1S -- ok>		;Tell about it
	HRRZ U,1(U)
	JUMPN U,IPCFN1
	RET				;All done

;;;Gross failure, queue all messages if there is a network, else bomb

SNLQAL:	SKIPG LHOSTN			;Is there a network
	 ERROR <%1S, no messages sent>
	CIETYP <%1S, all messages will be queued>
	MOVE W,LCLIST
SNLQA1:	JUMPE W,CPOPJ
	MOVEI U,(W)
	SETZM 2(U)			;Clear host number
	HRRZ W,1(U)			;Get next link
	SETZM 1(U)			;Clear links
	MOVEI B,NETLST
	CALL ADDLST			;Link to net list now
	 NOP
	JRST SNLQA1
>;IPCF

;;;Queue network mail

SNDNET:	
NEWQ,<
	TLZ F,(F%NEWQ)
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Get my logged directory name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ />[--NETWORK-MAIL--]..-1;P770000/]
	CALL MOVST0			;put in start of filename
	MOVSI A,(GJ%NEW!GJ%FOU!GJ%SHT)
	HRROI B,STRBUF	
	GTJFN
	 JERROR (Can't get queue file)
	MOVEM A,OUTJFN
	HRLI A,.FBBYV
	MOVSI B,(FB%RET)
	SETZ C,
	CHFDB				;Make keep all versions
	 ERJMP .+1
SNDNTO:	MOVE A,OUTJFN
	MOVE B,[7B5+OF%WR]
	OPENF
	 JRST [	UERR 17,[ASCIZ /Can't open queue file/]
		HALTF			;Give the user a chance to expunge,
		JRST SNDNTO]		;and try again
>;NEWQ
	SETO E,				;Clear last host sent
	HRRZ W,NETLST			;Get start of network list
SNDNT1:
NONEWQ,<
	JUMPE W,CPOPJ			;End of list
	MOVE A,[POINT 7,STRBUF]
DECN,<
	HLRZ B,2(W)			;Get network number
	JUMPN B,SNDNTD			;Send DECNET
>;DECN
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS			;Get my logged directory name
	CALL MOVSTR			;Stick it in too
	MOVEI B,[ASCIZ />[--UNSENT-MAIL--]./]
	CALL MOVSTR			;put in start of filename
	MOVEI B,4(W)			;Get this address
	HRLI B,(<POINT 7,0>)
	MOVEI D,CTL(V)
SNDNT2:	ILDB C,B			;Get char of name
	JUMPE C,SNDNT3			;End
	IDPB D,A			;Quote it
	IDPB C,A
	JRST SNDNT2			;No

SNDNT3:	IDPB D,A			;^V
	MOVEI C,"@"			;Put in @ for good measure
	IDPB C,A
	SKIPE B,2(W)			;Get host address
SNDNT4:	 CALL $CVHST			;Put in name
	MOVEI B,[ASCIZ/.-1;P770000/]	;Set protection to 770000
	CALL MOVST0
	MOVSI A,(GJ%NEW!GJ%FOU!GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 JERROR (Can't get queue file)
	PUSH P,A
	HRLI A,.FBBYV
	MOVSI B,(FB%RET)
	SETZ C,
	CHFDB				;Make keep all versions
	 ERJMP .+1
	POP P,A
	MOVE B,[7B5+OF%WR]
	OPENF
	 JERROR (Can't open queue file)
	HRROI B,HDRPAG			;Start of headers
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;Start of text
	SOUT
	CLOSF				;All there is to it
	 JERROR (Can't close message file)
>;NONEWQ
NEWQ,<
	MOVE A,OUTJFN			;Get back jfn for output
	JUMPE W,SNDNT7			;End of list, finish up
	MOVE B,2(W)			;Get host number
	CAMN B,E			;Same as last time?
	 JRST SNDNT2
	MOVE E,B
	MOVEI B,CTL(L)			;Formfeed separates hosts
	BOUT
	MOVE B,E
	CALL $CVHST
	HRROI B,CRLF0
	SOUT
SNDNT2:	HRROI B,4(W)			;Name of recipient
	SETZ C,
	SOUT
	HRROI B,CRLF0
	SOUT
>
SNDNT5:	SKIPG SNDVBS			;Super-verbose sending?
	 JRST SNDNT6			;No, dont tell of queuing
	MOVEI A,4(W)			;Guy's name
	SKIPG C,2(W)			;Get host number
	 TDZA B,B
	  MOVEI B,[ASCIZ / at %3N/]
	CIETYP < %1S%2S -- queued
>
SNDNT6:	HRRZ W,1(W)			;Get next one to do
	JRST SNDNT1

DECN,<
SNDNTD:	MOVE B,2(W)			;Get DECNET host number
	CAMN B,E			;Same as last time?
	 JRST SNDNT5			;Yes, only one file per host needed
	MOVE E,B
	MOVEI B,[ASCIZ /[--DECNET-MAIL--]./]
	CALL MOVSTR
	MOVE B,E
	JRST SNDNT4
>;DECN

NEWQ,<
SNDNT7:	HRROI B,[BYTE (7) CTL(L),15,12,0]	;Finish up hosts with <form><crlf>
	SETZ C,
	SOUT
	HRROI B,HDRPAG			;Start of headers
	SETZ C,
	SOUT
	HRROI B,TXTPAG			;Start of text
	SOUT
	CLOSF				;All there is to it
	 JERROR (Can't close message file)
	RET
>;NEWQ

;;;Set the MAILER flags

MAIFLG:	MOVSI A,(GJ%OLD!GJ%SHT)
NONEWQ,<
	HRROI B,[ASCIZ /SYSTEM:MAILER.FLAGS.1/]
>;NONEWQ
NEWQ,<
	HRROI B,[ASCIZ /SYSTEM:XMAILR.FLAGS.1/]
>;NEWQ
	GTJFN
	 RET
	PUSH P,A
	MOVEI B,OF%THW!OF%WR!OF%RD
	OPENF
	 JRST [	POP P,A
		RLJFN
		 NOP
		RET]
	HRLZ A,(P)			;Page 0
	MOVE B,[.FHSLF,,FLGPAG/1000]
	MOVSI C,(PM%RD!PM%WR)
	PMAP
	HRRZ C,MYCDIR			;Connected directory
	IDIVI C,^D36
	MOVSI A,(1B0)
	MOVN D,D
	ROT A,(D)
	IORM A,FLGPAG(C)		;Set my bit
	SETO A,
	SETZ C,
	PMAP
	POP P,A
	CLOSF
	 NOP
	RET

.HMAIL:	[ASCIZ/
The NET-MAIL command will attempt to send any messages that may be queued
in your directory.
/]

;;;Run MAILER to send off what we queued

.MAILE:	NOISE (QUEUED MESSAGES)
	CONFRM
NEWQ,<	HRROI B,[ASCIZ /SYS:XMAILR.EXE/]>;NEWQ
NONEWQ,<
DEC,<	HRROI B,[ASCIZ /SYS:NMAILR.EXE/]>;DEC
COL,<	HRROI B,[ASCIZ /SYS:NMAILR.EXE/]>;COL
DREA,<	HRROI B,[ASCIZ /SYS:MAILER.EXE/]>;DREA
HP,<	HRROI B,[ASCIZ /SYS:MAILER.EXE/]>;HP
ISI,<	HRROI B,[ASCIZ /SYS:MAILER.EXE/]>;ISI
MIT,<	HRROI B,[ASCIZ /SYS:MAILER.EXE/]>;MIT
RUTG,<	HRROI B,[ASCIZ /SYS:NMAILR.EXE/]>;RUTG
SRI,<	HRROI B,[ASCIZ /SYS:MAILER.EXE/]>;SRI
STAN,<	HRROI B,[ASCIZ /SYSTEM:NMAILR.EXE/]>;STAN
UTAH,<	HRROI B,[ASCIZ /SYSTEM:NMAILR.EXE/]>;UTAH
DECN,<
	TRNE F,F%DECN
	 HRROI B,[ASCIZ /SYS:DMAILR.EXE/]	;Decnet mailer
>;DECN
>;NONEWQ
	TLO F,(F%F3)			;Make sure it doesnt run enabled
	CALL RUNFL0
	KFORK				;Dont need it any more
	JRST .PUSH1			;Do an automatic CHECK

RUNFIL:	TLZ F,(F%F3)			;Default run enabled
RUNFL0:	MOVSI A,(GJ%OLD!GJ%SHT)
RUNFL1:	GTJFN
	 JERROR (Couldn't find file to run)
	PUSH P,A			;Save the JFN
IFN NETPRV!NEWQF,<
	TLNE F,(F%F3)			;Wants to run enabled?
>;IFN NETPRV!NEWQ
IFE NETPRV!NEWQF,<
	TLZE F,(F%F3)
>;IFE NETPRV!NEWQF
	 TDZA A,A			;No
	  MOVSI A,(CR%CAP)		;Yes, give it our caps
	CFORK
	 JERROR (Couldn't create fork)
IFN NETPRV!NEWQF,<
	PUSH P,C			;Make sure arpanet users can use NMAILR
	SETO B,				;All priv's possible
	SETZ C,				;But none enabled
	TLZE F,(F%F3)			;If not to be enabled
	 EPCAP				;At least give him possibles
	POP P,C
>;IFN NETPRV!NEWQF
	EXCH A,(P)			;Get back jfn
	HRL A,(P)
	GET
	POP P,A				;Get back fork handle
RUNFL2:	SETZ B,
	SFRKV				;At regular startup point
	WFORK
	PUSH P,A
	DMOVE A,PRGNAM			;Restore names
	SETSN
	 JFATAL
	POP P,A
	RET

.HPUSH:	[ASCIZ/
The PUSH command will give you a new EXEC. This means that you'll get a
fresh copy of the TOPS-20 command interpreter which prompts you with @. At
this point you can then do anything, and you may get back to MM by typing
POP.
/]
.PUSH:	CONFRM
	SKIPLE A,EXECFK
	 JRST [	CALL RUNFL2		;Already have one, just run it
		JRST .PUSH1]
	HRROI B,[ASCIZ /SYSTEM:EXEC.EXE/]
	CALL RUNFIL			;Else make a fork and run it
	MOVEM A,EXECFK			;And keep the fork handle
.PUSH1:	SKIPN MSGJFN			;Do we have a mail file?
	 RET				;No, don't do any check then
	SETZM CHKTIM			;Always check
	PUSH P,M			;Remember msg sequence
	SETZ M,				;Reparse entire file
	CALL CHECK0			;Did file change?
	 JRST [	CALL PARSEF		;Reparse anyway in case bits changed
		POP P,M
		RET]
	PUSH P,LASTM			;Save current last message for CHECKN
	CALL PARSEF			;Reparse the whole file
	JRST CHECKN			;Print new messages, restore M, return

;;;Erase fields

.ERSAL:	SETZM HDRPAG+700		;Reset subject
	SETZM TOLIST			;Reset to and cc pointers
	SETZM CCLIST
	SETZM BCCLST
	SETZM LCLIST
	SETZM FILIST
	SETZM NETLST
	SETZM REPDAT			;No reply date
	MOVEI A,TOPAG
	MOVEM A,FREETO			;Reset free space pointer
.ERSTX:	MOVE A,[POINT 7,TXTPAG]
	MOVEM A,TXTPTR			;Reset pointer to text space
	SETZM TXTPAG			;And make sure it starts with null
	MOVEI A,477777			;100 pages less null
	MOVEM A,TXTCNT
	DMOVE A,USRHDR			;User's headers from init file
	DMOVEM A,USRHDR+2		;Set up as current user headers
	MOVEI B,0
	IDPB B,A			;Make sure they end with a null
	RET

.ERSDT:	SETZM REPDAT			;No reply date
	RET

.ERSSB:	SETZM HDRPAG+700
	RET

.ERSBC:	MOVEI T,BCCLST			;Erase bcc list
	JRST ERSTO0

.ERSCC:	SKIPA T,[CCLIST]		;Erase cc list
.ERSTO:	 MOVEI T,TOLIST			;Erase to list
ERSTO0:	HRRZ W,(T)
	JUMPE W,ERSTO2
ERSTO1:	CALL REMLST			;Remove from transmission medium list
	HRRZ W,(W)			;Get next in list
	JUMPN W,ERSTO1
ERSTO2:	SETZM (T)
	SKIPN CCLIST			;All list empty now?
	 SKIPE TOLIST
	  RET
	SKIPE BCCLST
	 RET
	MOVEI A,TOPAG			;Yes, reset free pointer
	MOVEM A,FREETO
	RET

;;;Display fields

.DSREP:	MOVE A,[PBOUT]			;Display reply text
	TLZ F,(F%AT)			;Dont show network headers
	CALL MOVTO0
	CALL MOVCC1
	CALL MOVUS1
	CALL MOVSB1
	SKIPG REPDAT
	 RET				;No reply date
	MOVEI O,.PRIOU
	JRST MOVRDT

.DSALL:	MOVE A,[PBOUT]			;Set up to type it out to tty
	CALL MOVUS0
	CALL MOVSB1
	TLZ F,(F%AT)			;Dont show network headers
	CALL MOVTO1
	CALL MOVCC1
	CALL MOVBC1
	JRST MOVTX1

.DSRST:	MOVE A,[PBOUT]			;Set up to type it out to tty
	CALL MOVUS0
	CALL MOVSB1
	TLZ F,(F%AT)			;Dont show network headers
	CALL MOVTO1
	JRST MOVCC1

.DSSUB:	SKIPA B,[MOVSB0]
.DSTXT:	 MOVEI B,MOVTX0
	JRST .DSCC1

.DSTO:	SKIPA B,[MOVTO0]
.DSCC:	 MOVEI B,MOVCC0
.DSCC1:	MOVE A,[PBOUT]
	TLZ F,(F%AT)			;Dont ever type network type for local
	JRST (B)

.DSBCC:	MOVEI B,MOVBC0
	JRST .DSCC1

MOVUSH:	MOVE A,[IDPB A,O]
MOVUS0:	MOVEM A,MOVDSP			;Set up to move into memory
MOVUS1:	SKIPN USRHDR+2			;Has any user headers?
	 RET				;No, none
	MOVEI B,CRLF0			;Put in crlf first
	CALL MOVSB2
	MOVEI B,USRHDR+4
	JRST MOVSB2			;Go add that in

MOVSUB:	MOVE A,[IDPB A,O]		;Output subject
MOVSB0:	MOVEM A,MOVDSP			;Set up to move into memory
MOVSB1:	LDB A,[POINT 7,HDRPAG+700,6]
	JUMPE A,CPOPJ			;No subject
	MOVEI B,[ASCIZ /
Subject: /]
	CALL MOVSB2			;Print header part
	MOVEI B,HDRPAG+700		;Start of actual string
MOVSB2:	HRLI B,(<POINT 7,0>)
MOVSB3:	ILDB A,B			;Get char
	JUMPE A,CPOPJ			;Done
	XCT MOVDSP			;Handle it
	JRST MOVSB3

MOVTXT:	MOVE A,[IDPB A,O]		;Output text
MOVTX0:	MOVEM A,MOVDSP			;Set up to move into memory
MOVTX1:	MOVEI B,[ASCIZ /

/]
	CALL MOVSB2
	MOVEI B,TXTPAG
	CALL MOVSB2
	LDB A,TXTPTR
	MOVEI B,CRLF0
	CAIE A,12			;Unless ended with CRLF
	 CALL MOVSB2			;Put one in
	MOVEI B,[ASCIZ /-------
/]
	JRST MOVSB2			;And end it up

MOVBC0:	MOVEM A,MOVDSP			;Output BCC
MOVBC1:	MOVEI T,[ASCIZ /
Bcc: /]
	HRRZ W,BCCLST
	JRST MOVTO2

MOVCC:	MOVE A,[IDPB A,O]		;Output CC
MOVCC0:	MOVEM A,MOVDSP
MOVCC1:	MOVEI T,[ASCIZ /
cc: /]
	HRRZ W,CCLIST
	JRST MOVTO2

MOVTO:	MOVE A,[IDPB A,O]		;Output to
MOVTO0:	MOVEM A,MOVDSP
MOVTO1:	MOVEI T,[ASCIZ /
To: /]
MOVTRM:	HRRZ W,TOLIST
MOVTO2:	JUMPE W,CPOPJ			;None here, forget it
	SKIPL (W)			;Show this one in headers, etc?
	 JRST MOVT31			;Yes, ok
	HRRZ W,(W)			;No, get next one
	JRST MOVTO2

MOVTO3:	SKIPN HDR733			;RFC733 continuation lines?
MOVT31:	 SKIPA B,T			;No, use keyword then
MOVT32:	  MOVEI B,[ASCIZ /
    /]					;Yes, just indent
	CALL MOVSB2			;Print header
	MOVEI X,3			;Init horizontal position
MOVTO4:	MOVEI B,4(W)			;Get name
	TLZ F,(F%F1)			;First time through
MOVTO5:	HRLI B,(<POINT 7,0>)
MOVTO6:	ILDB A,B
	JUMPE A,MOVTO7
	XCT MOVDSP
	AOJA X,MOVTO6

MOVTO7:	TLOE F,(F%F1)			;This the first time through?
	 JRST MOVTO9			;No, done with this address
	LDB A,[POINT 4,(W),8]		;Get type field
	CAIN A,3			;Distribution list?
	 JRST MOVT10			;Yes, handle that
	JUMPN A,MOVTO8			;Non-local recipient
	TLNN F,(F%AT)			;This going out over network?
	 JRST MOVTO9			;No, that is enough for local then
	TDZA B,B			;Yes, use local host then
MOVTO8:	 MOVE B,2(W)			;Get host number
	HRROI A,STRBUF
	CALL $CVHST			;Put in name
	MOVEI B,[ASCIZ / at /]
	CALL MOVSB2
	ADDI X,4			;Count 4 chars for this
	MOVEI B,STRBUF
	JRST MOVTO5

MOVT10:	MOVEI B,[ASCIZ /:/]
	SKIPE HDR733			;RFC733 style?
	 MOVEI B,[ASCIZ /: ;/]		;Yes, empty list then
	JRST MOVTO5

MOVTO9:	HRRZ W,(W)			;Get next in list
	JUMPE W,CPOPJ
	SKIPGE (W)			;Print it?
	 JRST MOVTO9			;No, try next then
	MOVEI A,","
	XCT MOVDSP
NEWQ,<
	TLNE F,(F%NEWQ)			;Always generate continuation line
	 AOJA E,MOVT32
>;NEWQ
	CAIL X,^D65			;Near end?
	 AOJA E,MOVTO3			;Yes, get new line for more then
	MOVEI A," "
	XCT MOVDSP
	ADDI X,2
	JRST MOVTO4

MOVRDT:	MOVEI B,[ASCIZ /
In-Reply-To: Your message of /]
	CALL MOVSB2
	MOVE A,O
	MOVE B,REPDAT
	MOVSI C,(OT%NSC!OT%NCO!OT%TMZ!OT%SCL)
	ODTIM
	MOVE O,A
	RET

NEWQ,<
MOVMHN:	TLNN F,(F%NEWQ)
	 JRST [	MOVEI B,MYHNAM
		JRST MOVSTR]
	MOVEI B,[BYTE (7) " ","a","t"," ",177,0]
	CALL MOVSTR
	MOVE B,[POINT 7,MYHNAM,27]
	CALL MOVST1
	MOVEI B,177
	IDPB B,A
	RET
>;NEWQ

;;;Get some more text

GETTXT:
IFN VTPRMT,<
	MOVEI A,[ASCIZ /end with ESCAPE or ^Z/]
	TRNN F,F%RSCN
	 SKIPGE ESCSND
	  MOVEI A,[ASCIZ /ESCAPE to MM command level, ^Z to send/]
	SKIPLE ESCSND
	 MOVEI A,[ASCIZ /^Z to MM command level, ESCAPE to send/]
	CIETYP < Message (%1S):
>
>;IFN VTPRMT
IFE VTPRMT,<
	CITYPE < Msg:
>
>;IFE VTPRMT
	JRST .TEXT0

.HSTEX:	[ASCIZ/
The TEXT command allows you to continue typing the text of the message.
/]
.TEXT:	CONFRM
.TEXT0:	CALL SETABO			;Allow ^N
.TEXT1:	MOVEI A,TTXTIB
	TEXTI
	 JERROR
	LDB B,TXTPTR
	MOVEM B,LSTCHR			;Save terminator
	SETZ A,
	DPB A,TXTPTR			;Replace terminator with null
	SETO A,
	ADJBP A,TXTPTR
	MOVEM A,TXTPTR
	AOS TXTCNT
	CAIN B,CTL(B)			;^B inserts file
	 JRST TXTFIL
SRI,<	CAIN B,CTL(K)>			;^K - enter editor on text
NOSRI,<	CAIN B,CTL(E)>			;^E - enter editor on text
	 JRST TXTED
SRI,<	CAIN B,CTL(E)>			;Wants retype of whole thing?
NOSRI,<	CAIN B,CTL(K)>			;Wants retype of whole thing?
	 JRST .TEXT2
	CAIE B,CTL(L)			;Clear and retype?
	 RET				;No, must have terminated right
	CALL BLANK1			;Yes
	CITYPE < Msg:>
.TEXT2:	CALL CRIF
	HRROI A,TXTPAG			;Start of stuff
	PSOUT
	JRST .TEXT1			;And go get some more

TXTFIL:	PROMPT <(Insert file: >
	MOVEI B,TXTFL1
	HRRM B,CMDBLK+.CMFLG
	MOVEI A,CMDBLK
TXTFL1:	MOVEI B,[FLDDB. .CMIFI]
	COMND
	TLNE A,(CM%NOP)
	 JRST TXTFLE
	MOVEM B,TMPJFN
	MOVEI B,[FLDDB. .CMCFM]
	COMND				;Confirm
	TLNE A,(CM%NOP)
	 JRST TXTFLE
	MOVE A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JRST TXTFLE
	CALL INSFL3
	TYPE <...EOF)
>
	JRST .TEXT1

TXTFLE:	JWARN				;Error getting file, return for text
	CALL CRLF
	JRST .TEXT1

TXTED:	CALL CRIF			;Edit text, get fresh line
	JRST EDTXT0			;And go start doing it

.HSINS:	[ASCIZ/
The INSERT command takes one argument, a filename. It inserts that file
after the current text of the message.
/]
.INSFL:	CALL GETIFI
	MOVEM A,TMPJFN
	CONFRM
	MOVE A,TMPJFN
	MOVE B,[7B5+OF%RD]
	OPENF
	 JRST [	JWARN (Can't open input file)
		JRST CRLF]
INSFL3:	MOVE B,TXTPTR
	MOVN C,TXTCNT
	SIN
	CLOSF
	 NOP
	SETOM TMPJFN
	SKIPL C
	 ERROR (Buffer overflow - file too large)
	EXCH B,TXTPTR		;B - source of copy to remove nulls
	MOVE A,B		;A - dest of copy
	MOVNM C,TXTCNT		;C - current character
INSFL1:	CAMN B,TXTPTR		;TXTPTR - end of source text
	 JRST INSFL2
	ILDB C,B		;copy 
	SKIPE C			;removing nulls
	 IDPB C,A
	SKIPN C			;each one skipped increases free space
	 AOS TXTCNT
	JRST INSFL1
INSFL2:	MOVEM A,TXTPTR		;updated end of text
	RET

.HSSUB:	[ASCIZ/
The SUBJECT command takes a line of text as an argument to make the
subject of the message you are sending.
/]
;;;Get a new subject

GETSUB:	TRZ F,F%HOER			;No more error halting
	PROMPT < Subject: >
	CALL SETABO			;Allowed to ^N out of here
.SUBJE:	CALL GETLIN
	JUMPE B,.ERSSB			;None given, erase the subject then
	MOVE A,[STRBUF,,HDRPAG+700]
	BLT A,HDRPAG+777		;Move over the subject
	RET

.HSBCC:	[ASCIZ/
The BCC command takes an argument consisting of addresses separated by
commas. These addresses will receive blind carbon copies of your outgoing
message which means that those recipients who are addressed in the normal
manner, i.e. TO: and CC: will not see that the BCC: addresses have
received the message as well.
/]

.BCC:	PUSH P,[BCCLST]			;Add someone to bcc list
	JRST CC1

.HSCC:	[ASCIZ/
The CC command takes an arugment consisting of addresses separated by
commas. These addresses will receive carbon copies of your outgoing
message.
/]
GETCC:	PROMPT < cc: >
	CALL SETABO
.CC:	PUSH P,[CCLIST]
CC1:	TLO F,(F%CC)			;Say in cc command
	JRST .TO2			;And enter TO command

.HSTO:	[ASCIZ/
The TO command takes a list of addresses separated by commas as an
argument.  It adds these address as to recipients for the message.
/]
GETTO:	PROMPT < To: >
GETTO0:	CALL SETABO
.TO:	PUSH P,[TOLIST]			;What list to add to
	TLZ F,(F%CC)
.TO2:	TLZ F,(F%F3!F%COMA!F%F4)	;Dont allow funny local names
	MOVE W,FREETO			;Start with some free space
	PUSH P,CMDRET			;Save error dispatch
.TO3:	CALL GETUSR			;Get the user name
	 JRST .TO4			;Null field, return
	TLNE F,(F%COMA)			;Comma seen?
	 JRST .TO3			;Yes, get another then
.TO4:	POP P,CMDRET
	POP P,T				;Get list to add to
	JRST ADDTO0			;Now add the whole line in and return

;;;Get prompted message

GETMSG:	CALL GETTO
	CALL GETCC
GETMS1:	CALL GETSUB
	JRST GETTXT

.HSUNT:	[ASCIZ/
The REMOVE command takes a list of addresses separated by commas as an
argument. It removes those from the recipient lists of the message.
/]

;;;Remove user

.UNTO:	TLZ F,(F%COMA!F%F4)		;No comma seen yet
	TLO F,(F%F3)			;Allow funny addresses
	MOVE W,FREETO			;Some random space to use
.UNTO1:	CALL GETUSR			;Get a user name
	 ERROR (Null address illegal)
	TLNE F,(F%COMA)			;Wants more?
	 JRST .UNTO1			;Yes, get them
	HRRZS W				;Just in case
	PUSH P,W			;Save tail of list
	HRRZ U,FREETO			;Get head of list
.UNTO2:	PUSH P,U			;Save current pointer
	MOVEI U,4(U)			;Point to text of name
	SETZ N,				;Allow 0 occurances of that name
	CALL DOUNTO			;Remove the name
	JUMPE N,[ERROR (Address "%7S" not found)]
	POP P,U
	LDB B,[POINT 9,(U),17]		;Get size
	ADDI U,(B)
	CAME U,(P)			;End of list yet?
	 JRST .UNTO2
	ADJSP P,-1			;No more, fix up stack and return
	RET

;;;Remove name from string in U, allowing only (n) occurances

DOUNTO:	MOVEI V,TOLIST			;Get to pointers
	CALL DOUNTL
	MOVEI V,CCLIST
	CALL DOUNTL
	MOVEI V,BCCLST
DOUNTL:	MOVEM V,UNTHDR			;Save header address for fixing last
DOUNT0:	HRRZ W,(V)
	JUMPE W,CPOPJ			;None of this class
	MOVEI B,(U)			;Target string
	HRLI B,(<POINT 7,0>)
	MOVEI A,4(W)			;This particular one
	HRLI A,(<POINT 7,0>)

DOUNT1:	ILDB C,B			;Get char from target
	ILDB D,A
	JUMPE C,DOUNT3			;Null means it matches
	CAIN D,(C)
	 JRST DOUNT1			;Chars match?
	TRC D,(C)
	CAIN D,40			;Case only?
	 JRST DOUNT1			;Yes, keep looking
DOUNT2:	MOVEI V,(W)			;Setup to get next in list
	JRST DOUNT0

DOUNT3:	JUMPN D,DOUNT2
	SOJGE N,DOUNT2			;Count one more occurance
	LDB A,[POINT 9,(W),17]		;Get length of this block
	ADDI A,(W)			;Point to start of next block
	CAMN A,FREETO			;Was this the last entry?
	 MOVEM W,FREETO			;Yes, just update end pointer
	CALL REMLST			;Remove from transmission medium list
	HRRZ W,(W)			;Get next link in to/cc list
	HRRM W,(V)			;Relink previous
	JUMPN W,DOUNT0			;If this is the end of the list now
	HRLM V,@UNTHDR			;Update last (this fixes a bug)
	CAIE V,TOLIST			;Was this the head of the list?
	 CAIN V,CCLIST
	  SETZM (V)			;Yes, clear whole thing
	CAIN V,BCCLST
	 SETZM (V)
	JRST DOUNT0

SUBTTL Editor interfacing subroutines

.HEDIT:	[ASCIZ/
The EDIT command takes one argument, a message sequence.  It proceeds to
edit each message in that message sequence using the editor specified in
your MM.INIT file.
/]

;;;Edit commands

.EDIT:	CALL DFSQTH			;Edit specifies messages
	MOVEI A,.REDI1
	JRST DOMSGS

.REDIT:	CONFRM				;Edit this message
.REDI1:	CALL CHKDEL
	 RET
	CALL SEDMSG			;Set for editor to munge current message
	DMOVE A,[ASCIZ /Message/]
	DMOVEM A,EDINAM
	DMOVEM A,BUFNAM
	CALL RESTED			;Now edit it
	CALL GEDBUF			;Get the editted text
	 CAIA				;If changed,
	  CALL RPLMSG			;Replace current message with that
	JRST .EDFIN			;Go restore tty modes
	
;;;Prepare for editting the current message

SEDMSG:	DMOVE A,[ASCIZ /Message/]
	DMOVEM A,BUFNAM
	HRRZ V,MSGBOD(M)
	CALL MCH2BP			;Get byte pointer to message
	HLRZ B,MSGBOD(M)		;And length
	JRST EDREPL			;Load message into the editor

;;;Edit message text

.EDTXT:					;Used to be a CONFRM here
EDTXT0:	CALL CLRABO			;Dont ^N out of editor
	DMOVE A,[ASCIZ /Reply/]
	TRNN F,F%RPLY
	 DMOVE A,[ASCIZ /Send/]
	DMOVEM A,EDINAM			;Name of edit type
	CALL SEDTXT
	TRNN F,F%TECP			;Hairy interface?
	 JRST EDTXT1			;No, just edit this field
	CALL SEDMSG			;Put message in the message buffer
	CALL SEDHDR			;And headers in the headers buffer
EDTXT1:	DMOVE A,[ASCIZ /Reply/]
	DMOVEM A,BUFNAM
	CALL RESTED			;Run the editor
	CALL GEDTXT			;Get the new text
	TRNN F,F%TECP
	 JRST .EDFIN
	CALL GEDHDR			;Get updated headers if need be
	JRST .EDFIN

;;;Point editor at message text

SEDTXT:	DMOVE A,[ASCIZ /Reply/]		;Name of the buffer
	DMOVEM A,BUFNAM
	MOVE A,[POINT 7,TXTPAG]		;Starting byte pointer
	MOVE B,TXTPTR			;Ending one
	JRST SEDBUF			;Setup editor text

;;;Get it back and update if necessary

GEDTXT:	DMOVE A,[ASCIZ /Reply/]
	DMOVEM A,BUFNAM
	CALL GEDBUF			;Get the editted text
	 RET				;Isnt changed
	MOVE B,[POINT 7,TXTPAG]		;Replace it here
	CALL FRMSS1			;Move string
	MOVEM B,TXTPTR			;Update pointer
	SETZ D,
	IDPB D,B			;And end with a null too
	RET

;;;All done, restore TTY modes for program

.EDFIN:	MOVEI D,EDMOD			;Save editor modes
	CALL GETTYM
	MOVEI D,SAVMOD			;And restore ours
	JRST SETTYM

;;;Edit headers

.EDHEA:	DMOVE A,[ASCIZ /Default/]
	DMOVEM A,EDINAM
	CALL SEDHDR			;Put in headers
	CALL RESTED			;Edit them
	CALL GEDHDR			;Get new ones
	JRST .EDFIN			;And all done

;;;Put in headers

SEDHDR:	MOVE O,[POINT 7,WRTPGS]		;Some temp space
	CALL MOVTO
	CALL MOVCC1
	CALL MOVUSH
	CALL MOVSUB
	DMOVE A,[ASCIZ /Headers/]
	DMOVEM A,BUFNAM
	MOVE A,[POINT 7,WRTPGS]		;Starting pointer
SEDHD1:	ILDB B,A
	CAIE B,15			;Move over blank lines
	 CAIN B,12
	  JRST SEDHD1
	ADD A,[7B5]
	MOVE B,O			;Ending one
	JRST SEDBUF			;Setup editor for that

;;;Get the new headers

GEDHDR:	DMOVE A,[ASCIZ /Headers/]
	DMOVEM A,BUFNAM
	CALL GEDBUF			;Get what it gave back
	 RET				;Didnt change
	PUSH P,A			;Save pointers to editor text
	PUSH P,C
	CALL .ERSTO			;Erase to field
	CALL .ERSCC			;And cc field
	CALL .ERSSB			;And subject field
	POP P,C				;Get back pointers
	POP P,A
	JUMPLE C,CPOPJ			;No text there
	ADJBP C,A			;Get ending byte pointer
	SETZ D,
	IDPB D,C			;Put a null at the end
	TLZ F,(F%CC!F%AT)		;Start with to field
	SETZ E,				;No default host name
	CALL PRTO12			;Parse these new addresses
	CAIE B,"s"
	 CAIN B,"S"
	  CALL EDSUBJ			;Get the subject now too
	RET

EDSUBJ:	ILDB B,A
	CAIE B,0
	 CAIN B,15
	  RET
	CAIE B,":"
	 JRST EDSUBJ
EDSUB1:	ILDB B,A
	CAIE B,0
	 CAIN B,15
	  RET
	CAIE B,40
	 CAIN B,11
	  JRST EDSUB1
	MOVE C,[POINT 7,HDRPAG+700]
EDSUB2:	IDPB B,C
	ILDB B,A
	CAIE B,0
	 CAIN B,15
	  CAIA
	   JRST EDSUB2
	MOVEI B,0
	IDPB B,C
	RET

;;;Setup the editor's text

SEDBUF:	LDB C,[POINT 6,B,5]
	IDIVI C,7			;Get chars within word
	SUBI B,(A)
	HRREI B,(B)			;Get number of words
	IMULI B,5			;Into chars
	SUBI B,(C)			;Get total number of chars
	LDB C,[POINT 6,A,5]
	IDIVI C,7
	ADDI B,(C)
;	JRST EDREPL			;Run editor over this field

;;;Replace the editor's buffer with a given string, pointer in A, byte count in B

EDREPL:	PUSH P,A			;Save pointer
	PUSH P,B			;Save char count
	SKIPLE EDFORK			;If dont have a fork yet,
	 JRST EDREP1
	CALL GETED			;Get one now
	TRNN F,F%TECO			;If it isnt teco based,
	 JRST EDREP2			;Do it thru a temp file
	MOVEI B,[ASCIZ /0fsexit/]	;Telling it to return right away,
	CALL MOVST0
	CALL RUNED			;Start up the editor
	SKIPN FRKACS+3			;Exitted other than with 0?
	 JRST EDREP1
	TRO F,F%TECP			;Say have hairy editor interface
	CALL RESTE0			;And continue it
EDREP1:	MOVEI D,EDMOD			;Restore editor tty modes
	CALL SETTYM
	LDB T,[POINT 9,FRKACS+2,35]	;Get position in page
	TRNE F,F%TECP			;Fancy interface, fssuperior will
	 JRST EDREP3			;Do it all, and in the right buffer
	MOVE B,EDBPAG+5(T)		;Save addr of end of buffer
	MOVSI A,EDBPAG+0(T)		;Start with beginning addr
	HRRI A,EDBPAG+1(T)		;Into virtual beg
	BLT A,EDBPAG+5(T)		;Up to end pointer
	SUB B,EDBPAG+5(T)		;See how many chars we "deleted"
	ADDM B,EDBPAG+6(T)		;Increase the gap that many
	SETZM EDBPAG+9(T)		;Not modified yet
EDREP3:	MOVE B,(P)			;Get char count
	JRST EDINS2			;And go insert the new string

;;;Do it thru a temp file for non-teco editors

EDREP2:	PUSH P,A			;Save start of jcl
	MOVSI A,(GJ%SHT!GJ%FOU)		;Note: can't use GJ%TMP because
	MOVE B,[7B5+OF%WR]		; of cretinous release 4 EDIT
	CALL GEDTMP
	EXCH A,(P)			;Get back pointer for jcl
	MOVE B,(P)
	MOVE C,[001110,,JS%PAF]
	JFNS
	MOVEI B,[ASCIZ /
/]					;Finish up command line
	CALL MOVST0
	POP P,A				;Recover jfn
	POP P,C				;Recover byte point
	MOVN C,C
	POP P,B				;Recover string
	SOUT				;Write it out
	CLOSF
	 NOP
	JRST RUNED			;And go start it

;;; Generate a temp file unique to this job

GEDTMP:	PUSH P,B			;Save openf args
	PUSH P,A			;Save gtjfn args
	GJINF
	HRROI A,STRBUF+20		;Some string space
	MOVEI B,(C)			;Job number
	MOVE C,[NO%LFL!NO%ZRO+3B17+^D10]
	NOUT
	 MOVE A,[POINT 7,STRBUF+20]
	MOVEI B,[ASCIZ /MM.TMP.0/]
	CALL MOVST0
	POP P,A
	HRROI B,STRBUF+20
	GTJFN
	 JERROR (Can't get TMP file)
	POP P,B
	OPENF
	 JERROR (Can't open TMP file)
	RET

;;;Here to make a new editor, returns with start of jcl in A and F%TECO
;;;setup correctly

GETED:	MOVSI A,(CR%CAP!CR%ACS)
	MOVEI B,FRKACS			;Set these initial ac's
	CFORK
	 JERROR (Can't create editor fork)
	MOVEM A,EDFORK			;Save it
	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]	;Allows:
	BLT A,CMDGTB+.GJATR		; DEFINE EDITOR:SYS:EMACS
	MOVSI A,(GJ%OLD)		;to work instead of only:
	MOVEM A,CMDGTB+.GJGEN		; DEFINE EDITOR:SYS:EMACS.EXE
	MOVE A,[.NULIO,,.NULIO]		;--subtle, but consistent with
	MOVEM A,CMDGTB+.GJSRC		;  how EXEC handles same...
	HRROI A,[ASCIZ /EXE/]
	MOVEM A,CMDGTB+.GJEXT
	MOVEI A,CMDGTB
RUTG,<
	HRROI B,[ASCIZ /EDIT:/]
>;RUTG
NORUTG,<
	HRROI B,[ASCIZ /EDITOR:/]
>;NORUTG
	GTJFN
	 CAIA
	  JRST GETED0
	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]
	BLT A,CMDGTB+.GJATR
	MOVSI A,(GJ%OLD)
	MOVEM A,CMDGTB+.GJGEN
	MOVE A,[.NULIO,,.NULIO]
	MOVEM A,CMDGTB+.GJSRC
	HRROI A,[ASCIZ /SYS/]
	MOVEM A,CMDGTB+.GJDEV
	HRROI A,[ASCIZ /EXE/]
	MOVEM A,CMDGTB+.GJEXT
	MOVEI A,CMDGTB
	HRROI B,EDITOR			;Name of user's editor
	GTJFN
	 JERROR (Can't get editor)
GETED0:	MOVE B,[1,,.FBUSW]
	MOVEI C,C
	GTFDB				;Get user word
	TRZ F,F%TECO!F%TECP		;Assume not TECO based
	HLRZ C,C
	CAIN C,(<SIXBIT /TEC/>)		;Check for teco based
CLSC,<
	 TRO F,F%TECO			;Dont need msg since gen of .0 solves
>;CLSC
NOCLSC,<
	 TROA F,F%TECO			;It is, remember that
	  CIETYP <[%1J is not TECO based, you must write out file when done]
>
>;NOCLSC				;Make sure guy doesnt lose big
	MOVEI B,(A)			;Get file again
	HRROI A,STRBUF
	MOVSI C,001000			;Just name
	JFNS
	MOVEI C," "
	IDPB C,A
	PUSH P,A
	MOVEI A,(B)
	HRL A,EDFORK
	GET				;Get in the editor
	JRST CPOPAJ			;Restore string pointer and return

;;;Here to run the editor

RUNED:	HRROI A,STRBUF			;Set that up for user
	RSCAN
	 NOP
	MOVE A,EDFORK
	SETZ B,				;Start at normal entry
	SFRKV
	JRST WAITED

;;;Here to restart fork to edit something

RESTED:	TRNN F,F%TECO			;Already all done if not teco based
	 RET
	TRNN F,F%TECP			;Hairy interface?
	 JRST RESTE0			;Just resume editor
	MOVE A,[POINT 7,STRBUF]		;Else setup to tell all that's going on
	MOVEI B,[ASCIZ /FOO /]
	CALL MOVSTR
	MOVEI B,BUFNAM
	CALL MOVSTR
	MOVEI B,ESC
	IDPB B,A
	MOVEI B,EDINAM
	CALL MOVSTR
	MOVEI B,[ASCIZ /
/]
	CALL MOVST0
	JRST RUNED			;Start over so ..L run again
RESTE0:	MOVE A,EDFORK
	MOVE B,EFRKPC			;Forks old PC
	SFORK

;;;Here to wait for the editor fork

WAITED:	MOVE A,EDFORK
	RFORK				;Thaw it
	WFORK				;And wait for it to terminate
	DMOVE A,PRGNAM			;Restore our name
	SETSN
	 JFATAL
	MOVE A,EDFORK
	TRNE F,F%TECO			;TECO based?
	 JRST EDFTRM			;Yes, check on it's status
	KFORK				;No, can't reuse it
	SETOM EDFORK			;Forget we had it at all
	RET

;;;Here when fork terminates

EDFTRM:	FFORK				;Freeze it
	RFSTS				;Get its status
	TLZ A,(RF%FRZ)			;We know it's frozen already
	HLRZ A,A
	CAIE A,.RFHLT			;Voluntary termination?
	 JRST KILLED			;No, kill it off, it's bombed
	MOVEM B,EFRKPC			;Save the PC for restarting it
	MOVE A,EDFORK			;Need fork again
	RWM				;See why it stopped
	TLNE B,(1B1)			;Level 1 in progress?
	 JRST CTLCED			;Yes, means the guy ^C'd out
	MOVE A,EDFORK
	MOVEI B,FRKACS			;Get its AC's
	RFACS
	MOVE A,FRKACS+2			;Pointer to buffer block
	IDIVI A,1000			;Get page number of block
	MOVEI T,(B)			;Save position in page
	HRL A,EDFORK
	MOVE B,[.FHSLF,,EDBPAG/1000]	;Into our area
	MOVSI C,(PM%RD!PM%WR)		;Read write
	PMAP
	MOVE A,EDBPAG(T)		;Char address of beginning of buffer
	IDIVI A,5000			;Get page number
	HRL A,EDFORK
	MOVE B,[.FHSLF,,EDPAGE/1000]
	MOVE C,[PM%CNT+PM%RD+PM%WR+10]
	PMAP				;Map those pages too, read/write
	LSH A,9				;Get word address
	HRREI A,-EDPAGE(A)
	MOVEM A,EDPAG0			;Save address of first page mapped
	HLRE A,FRKACS+3			;Negative argument to fs exit?
	JUMPGE A,CPOPJ			;No, done
	HRRE B,FRKACS+3			;Select a different message?
	JUMPL B,EDFTR2			;No
	IMULI B,MSGLEN
	CAMG B,LASTM			;And in range
	 MOVE M,B			;Select it
EDFTR2:	AOJE A,[TRO F,F%ESND		;-1fs exit to send the message off
		RET]
	AOJE A,[ADJSP P,-1		;-2fs exit says dont update fields
		JRST .EDFIN]
	AOJE A,[CALL SEDMSG		;-3fs exit says update current message
		JRST RESTE0]
	AOJE A,.REPL6			;-4fs exit says reply to this message
	RET

;;;Editor terminated badly

KILLED:	MOVE A,EDFORK
	KFORK				;Kill it off
	SETOM EDFORK			;And forget about it
	MOVEI D,SAVMOD			;Restore program's modes
	CALL SETTYM
	ERROR ( Editor fork terminated involuntarily)

;;;^C typed from editor, make it percolate up

CTLCED:	HALTF
	JRST RESTE0			;And resume it afterwards

;;;Get the editted field

GEDBUF:	TRNN F,F%TECO			;Was this teco based editor
	 JRST GEDBF2			;No, get updated version of file
	SKIPE EDBPAG+11(T)		;Was buffer modified
	 AOS (P)			;Yes, skip return when done
	PUSH P,EDBPAG+4(T)
	POP P,EDBPAG+2(T)		;ZJ
	TRNN F,F%TECP			;Ordinary teco,
	 TDZA B,B			;Insert 0 chars
	  SETO B,			;Else negative so dont kill
	CALL EDINSC			;Move gap to end
	MOVE C,EDBPAG+4(T)
	SUB C,EDBPAG+1(T)		;Number of chars in it
	MOVE A,EDBPAG+1(T)		;Start of virtual buffer
	JRST EDCHRP			;Get byte pointer and return

GEDBF2:	MOVSI A,(GJ%OLD!GJ%SHT)
	MOVE B,[7B5+OF%RD]
	CALL GEDTMP			;Find the temp file again
	HRROI B,EDPAGE			;Where to put it
	MOVNI C,20000*5
	SIN
	MOVEI B,0			;Editor may have made new non-temp vers
	DELNF
	 NOP
	CLOSF
	 NOP
	ADDI C,20000*5			;Compute byte count
	MOVE A,[POINT 7,EDPAGE]
	JRST CPOPJ1

;;;Convert char address to byte pointer, taking gap into account

EDCHRP:	CAML A,EDBPAG+3(T)
	 ADD A,EDBPAG+6(T)
EDCHR1:	IDIVI A,5
	SUB A,EDPAG0			;Make absolute
	HRL A,BPS(B)
	RET

;;;Insert a string into the editor buffer, string in a, count in b

EDINS:	PUSH P,A			;Save string pointer
	PUSH P,B			;Save char count
EDINS2:	CALL EDINSC			;Request it to insert
	MOVE A,EDBPAG+2(T)		;Address of current position
	SUB A,(P)			;Back over the chars to be inserted
	CALL EDCHR1			;Get byte pointer
	POP P,C				;Get back char count
	POP P,B				;Get back byte pointer
	ILDB D,B
	IDPB D,A
	SOJG C,.-2			;For all requested
	RET

;;;Request editor to insert (b) chars at PT

EDINSC:	MOVEM B,EDBPAG+8(T)		;Set up as SUPARG
	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /FOO /]		;Be stupid or teco will outsmart itself
	CALL MOVSTR
	MOVEI B,BUFNAM
	CALL MOVSTR
	MOVEI B,[ASCIZ /
/]
	CALL MOVST0
	HRROI A,STRBUF			;Tell it which buffer to use
	RSCAN
	 NOP
	MOVE A,EDFORK
	HRRZ B,EDBPAG+7(T)		;Where to start it
	SFORK				;Start it
	RFORK				;Thaw it
	WFORK				;Wait for it
	DMOVE A,PRGNAM			;Restore our name
	SETSN
	 JFATAL
	MOVE A,EDFORK
	JRST EDFTRM			;Remap the right page, etc

;;;Message dired mode

.HDIRE:	.+1
	ASCIZ/
The DIRED command takes a list of message sequences, and starts the
DIRED subsystem of the MMAIL package to maintain your message file
ala disk DIRED (the message headers are your mail file's "directory").

To use DIRED, your editor must be EMACS and you must load the MMAIL
library.  If the system EMACS.INIT does not already do this, you can
do so by adding the following line to your EMACS.INIT:
	FS XJNAME$ [J F~JMM$"E M(M.M Load Library$)MMAIL$'
(note that $ = escape).
/

.DIRED:	CALL DFSQAL			;Get sequence, default to all messages
	TRO F,F%DIRE			;Entering dired mode
	PUSH P,[POINT 7,WRTPGS]		;Get some string space
DIRED1:	CALL NXTMSG
	 JRST DIRED2
	MOVE O,(P)
	CALL TYPHD0			;Insert the headers
	MOVEM O,(P)
	JRST DIRED1
DIRED2:	DMOVE A,[ASCIZ /Dired/]
	DMOVEM A,BUFNAM
	DMOVEM A,EDINAM
	MOVE A,[POINT 7,WRTPGS]		;Starting pointer
	POP P,B				;Ending
	CALL SEDBUF			;Stick it in the editor
	TRNE F,F%TECP
	 JRST DIRED5
	WARN <You do not have the hairy MMAIL interface loaded>
	CETYPE <Type "HELP DIRED" at MM top-level for more information>
	MOVEI A,^D5000			;Make sure message stays around a bit
	DISMS
DIRED5:	CALL RESTED			;Run the editor over it
	TRZ F,F%DIRE			;Done with dired mode
	DMOVE A,[ASCIZ /Dired/]
	DMOVEM A,BUFNAM
	CALL GEDBUF			;Get what it gave back
	 RET				;Didnt change
	JUMPLE C,CPOPJ			;No text there
	ADJBP C,A			;Get ending byte pointer
	SETZ D,
	IDPB D,C			;Put a null at the end
DIRED3:	ILDB B,A			;Get start of line
	JUMPE B,.EDFIN			;All done
	SETZ E,				;Accumulate bits here
	ILDB B,A			;Seen
	CAIN B," "
	 TRO E,M%SEEN
	ILDB B,A			;Flagged
	CAIE B," "
	 TRO E,M%ATTN
	ILDB B,A
;	CAIE B," "
;	 TRO E,M%RPLY
	ILDB B,A
	CAIE B," "
	 TRO E,M%DELE
	MOVEI C,^D10
	NIN
	 JRST DIRED4			;Skip it
	IMULI B,MSGLEN
	MOVEI M,-MSGLEN(B)
	MOVEI B,M%SEEN!M%ATTN!M%DELE	;Change these bits
	ANDCAM B,MSGBTS(M)
	IORM E,MSGBTS(M)
	PUSH P,A
	CALL UPDBIT
	POP P,A
DIRED4:	ILDB B,A			;Flush the rest of the line
	JUMPE B,.EDFIN
	CAIN B,12
	 JRST DIRED3
	JRST DIRED4

;;;Continue dired

DIREDR:	MOVE P,[IOWD NPDL,PDL]
	PUSH P,A			;Setup return address
	DMOVE A,[ASCIZ /Dired/]
	DMOVEM A,BUFNAM
	DMOVEM A,EDINAM
	JRST DIRED5

SUBTTL Init file handler

;;;For the time being the syntax is just
;;;<variable> <val><crlf>, where val is just an octal number or string

DOINIT:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS
	CALL MOVSTR
	MOVEI B,[ASCIZ />MM.INIT/]
	CALL MOVST0
	MOVSI A,(GJ%OLD!GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 RET				;None there, forget it, use defaults
	MOVE B,[7B5+OF%RD]
	OPENF
	 JWARN (Can't open init file)
	MOVEM A,TMPJFN			;Save this for later

INILUP:	MOVE A,TMPJFN
	HRROI B,STRBUF
	MOVEI C,STRBSZ*5
	MOVEI D,12			;Read a line
	SIN
	 ERJMP CLSTMP			;All done with it
	MOVE T,[POINT 7,STRBUF]		;Handle this line
INILP1:	ILDB C,T
	CAIE C,15			;Reached end of line
	 CAIN C,12
	  JRST INILPX			;Can't understand it then
	CAIE C,11			;Tab or space ok
	 CAIN C,40
	  JRST INILP2
	JRST INILP1

INILP2:	SETZ C,
	DPB C,T				;Stick in a null
	MOVEI A,INIVTB			;Init file variables
	HRROI B,STRBUF
	TBLUK
	TLNE B,(TL%NOM!TL%AMB)		;No good?
	 JRST INILPX			;Yes, complain
	HRRZ A,(A)
	HRRZ U,(A)			;Get address of corresponding variable
	HLRE E,(A)			;Get string length allowed
	JUMPE E,INININ			;Zero means variable is fixnum
	JUMPG E,[CALL (E)		;Call routine if there is one
		 JRST INILUP]
	HRLI U,(<POINT 7,0>)		;Make byte pointer to it
INISTR:	AOJGE E,INILPX			;Ran out of room in variable
	ILDB C,T
	JUMPE C,INIST3
	CAIE C,15
	 CAIN C,12
	  JRST INIST3
INIST2:	IDPB C,U
	JRST INISTR

INIST3:	MOVEI C,0
	IDPB C,U
	JRST INILUP

INININ:	SETZB A,B			;Here to input a fixnum variable
ININI1:	ILDB C,T			;Get next char
	JUMPE C,ININI2
	CAIE C,11
	 CAIN C,40
	  JRST ININI1			;Ignore blanks
	CAIE C,15
	 CAIN C,12			;End of line?
	  JRST ININI2
	CAIN C,"-"
	 AOJA A,ININI1			;Negativize
	CAIL C,"0"
	 CAILE C,"7"
	  JRST INILPX			;Not an octal digit, barf
	LSH B,C
	ADDI B,-"0"(C)
	JRST ININI1

ININI2:	TRNE A,1			;Did it get negative?
	 MOVN B,B			;Yes
	MOVEM B,(U)			;Save variable value
	JRST INILUP

;;; Initialize a table of keywords from a comma separated list
INIKEY:	MOVEI A,^D18			;Initialize header of table
	MOVEM A,(U)
	HRLZ B,KEYPTR			;Addr,,index
INIKY1:	HLR D,B
	HRLI D,(<POINT 7,0>)
INIKY2:	ILDB C,T			;Get next character
	CAIE C,11
	 CAIN C," "
	  JRST INIKY2
	CAIN C,","			;End of keyword?
	 JRST INIKY3
	CAIE C,15
	 CAIN C,12
	  JRST INIKY3
	JUMPE C,INIKY3			;This will happen from SET command
	IDPB C,D
	JRST INIKY2
INIKY3:	MOVEI A,0
	IDPB A,D
	MOVEI A,(U)			;Table pointer
	TBADD
	 ERJMP [CITYPE <?Too many keywords in command
>
		JRST INILPX]
	HRLI B,1(D)			;Save updated pointer
	CAIN C,","			;More to come?
	 AOJA B,INIKY1
	HLRM B,KEYPTR			;Updated string pointer
	RET

;;; Init a string that gets extended by lines
INILNS:	ILDB C,T
	CAIE C,11
	 CAIN C," "
	  JRST INILNS			;Flush whitespace
	ADD T,[7B5]			;Back over first character
	SKIPN D,(U)			;Is there something already?
	 JRST [	MOVNI E,776*5-1
		MOVEI D,4(U)
		HRLI D,(<POINT 7,0>)
		JRST INILN1]		;No, init to start at after 4 words
	AOS E,1(U)			;Extend it with a crlf
	AOJGE E,INILPX
	MOVEI C,15
	IDPB C,D
	MOVEI C,12
INILN2:	IDPB C,D
INILN1:	AOJGE E,INILPX			;Ran out of room in variable
	ILDB C,T
	JUMPE C,INILN3
	CAIE C,15
	 CAIN C,12
	  JRST INILN3
	JUMPE C,INILN3			;This will happen with SET command
	JRST INILN2

INILN3:	DMOVEM D,(U)			;Store ending pointer and count
	MOVEI C,0			;And end string with null
	IDPB C,D
	RET

INILPX:	MOVEI A,STRBUF			;Tell user the losing line
	CIETYP <
There is a problem with your user profile file MM.INIT, occurring
around keyword "%1S".
Your profile file was probably created by an obsolete version of MM,
and rewriting it will fix it.
>
	SETOM BLNKER
	JRST INILUP

INIVTB:	NINVRS,,NINVRS			;User variables
	VAR BLANK-SCREEN-STARTUP,BLSCST
	VAR COMMAND-IMMEDIATE-WAKEUP,CMIMWK
	VAR CONTROL-N-ABORT,ABOFLG
	VAR DEFAULT-CC-LIST,DEFCCL,-117
	VAR DONT-TYPE-HEADERS,SPRHDR,INIKEY
	VAR EDITOR,EDITOR,-47
	VAR ESCAPE-AUTOMATIC-SEND,ESCSND
	VAR GET-CONNECTED-DIRECTORY,GTCNDR
	VAR HEADER-OPTIONS,USRHDR,INILNS
	VAR KEYWORDS,KEYTBL,INIKEY
	VAR LIST-INCLUDE-HEADERS,LSTHDR
	VAR LIST-ON-SEPARATE-PAGES,LSTPAG
	VAR NEW-FILE-PROTECTION,DEFPRO
	VAR ONLY-TYPE-HEADERS,ONLHDR,INIKEY
	VAR PERSONAL-NAME,PERNAM,-47
	VAR READ-PROMPT,REPRMT,-47
	VAR REPLY-CC-OTHERS,RCCOTH
	VAR REPLY-INCLUDE-ME,RINCME
	VAR REPLY-INITIAL-DISPLAY,REPDIS
	VAR REPLY-SENDER-ONLY-DEFAULT,RFMDEF
	VAR RFC733-STYLE-HEADERS,HDR733
	VAR SAVED-MESSAGES-FILE,SAVFIL,-47
	VAR SEND-PROMPT,SEPRMT,-47
	VAR SEND-VERBOSE-FLAG,SNDVBS
	VAR TOP-LEVEL-PROMPT,TOPRMT,-47
	VAR USER-HEADERS,USRHTB,INIKEY
	VAR USER-NAME,MYDIRS,-47
NINVRS==.-INIVTB-1

.HCRIN:	.+1
	ASCIZ/
The CREATE-INIT command will make a file, MM.INIT in your directory which
MM subsequently reads when you start up a new MM. In it, you can set
various switches to make your MM environment more comfortable and easy to
use for your own personal tastes. The following are the settings possible:

  BLANK-SCREEN-STARTUP ..number..
	(If non-zero, the default, then clear the screen at startup
	 and before each message typed out when in READ mode.)
  COMMAND-IMMEDIATE-WAKEUP ..number..
	(If non-zero, the command parser wakes up on every field
	 instead of waiting for a break character.  Some people prefer
	 this.  The default is zero.)
  CONTROL-N-ABORT ..number..
	(If negative, never abort on ^N; if zero, the default, ask
	 if should abort; if positive, always abort.)
  DEFAULT-CC-LIST ...names here...
	(A list of addresses to always bcc your outgoing messages to.)
  DONT-TYPE-HEADERS ..keyword-list..
	(A list of header keywords which should be suppressed in the
	 TYPE and related commands.)
  EDITOR ...editor name here...
	(The editor you want to use if logical name EDITOR: is not
	 defined, otherwise a no-op.  EDITOR: is defined on all release
	 4 systems, and some release 3 systems as well.  The default is
	 EMACS.)
  ESCAPE-AUTOMATIC-SEND ..number..
	(If zero, the default, then both escape and ^Z in message text
	 input mode will return to send level unless MM was invoked
	 from the EXEC, in which case escape enters send level and ^Z
	 sends the message.  If positive, then escape sends the message
	 and ^Z returns to send level.  If negative, then ^Z sends the
	 message and escape returns to send level.)
  GET-CONNECTED-DIRECTORY ..number..
	(If zero, the default, ask where to read in the mail file from
	 if connected to another directory.  If positive then read from
	 the connected directory always; if negative, then read from the
	 login directory always.)
  HEADER-OPTIONS ..text line..
	(Specifies a header to be inserted by default in a message.)
  KEYWORDS ..keyword-list..
	(A list of keywords by which you wish to tag your messages using
	 the KEYWORD command.)
  LIST-INCLUDE-HEADERS ..number..
	(If non-zero, the default, output a list of headers at the
	 beginning of a listing made by the LIST command.)
  LIST-ON-SEPARATE-PAGES ..number..
	(If non-zero, each message is listed on a separate page.  The
	 default is zero.)
  NEW-FILE-PROTECTION ..protection..
	(The default protection to be given to text files created by
	 MOVE, COPY, etc.  The default is the system default protection.)
  ONLY-TYPE-HEADERS ..keyword-list..
	(A list of header that are the only ones typed out by TYPE and
	 related commands.)
  PERSONAL-NAME ..your name here..
	(A personal name to be included in the From: item in outgoing
	 network mail messages.)
  READ-PROMPT ...the prompt meaning you're in read mode...
	(The default is R>.)
  REPLY-CC-OTHERS ..number..
	(If non-zero, reply to all cc's everyone other than from.  If
	 zero, the default, then people in the to-list are to'd, not cc'd.)
  REPLY-INCLUDE-ME ..number..
	(If positive, then include yourself in replies, if negative then
	 if message was moved or copied to a file then the reply will go
	 to that file as well.  If zero, the default, you aren't included
	 in replies.)
  REPLY-INITIAL-DISPLAY ..number..
	(If non-zero then display text of reply initially.  The default
	 is zero.)
  REPLY-SENDER-ONLY-DEFAULT ..number..
	(If non-zero, the default, then default to replying only to
	 the sender of the message.)
  RFC733-STYLE-HEADERS ..number..
	(If non-zero, the default, then write out RFC733 style
	 'John Doe <Doe at Site>' headers.)
  SAVED-MESSAGES-FILE ..filename..
	(Initial file to receive copies of your outgoing messages.)
  SEND-PROMPT ...the prompt meaning you're in send mode..
	(The default is S>.)
  SEND-VERBOSE-FLAG ..number..
	(If negative, then superterse, i.e. say nothing about sending mail.
	 If 0 then tell of local delivery; if positive, the default, then
	 superverbose, i.e. tell of the disposition of all messages.)
  TOP-LEVEL-PROMPT ..the prompt meaning you're at top level..
	(The default is MM>.)
  USER-HEADERS ..keyword-list..
	(Specifies a list of special headers you may want to generate.
	 The send-mode USER-HEADER command will add it to the current
	 message.)
  USER-NAME ..your user name..
	(Defaults to your logged in user name.  This is what MM uses
	 as your "login directory".)
/

.HPROF:	.+1
	ASCIZ /
The PROFILE command will help you setup an environment for using MM
corresponding to your desires in message handling. It asks you a series of
questions and then makes MM remember them (via the MM.INIT file).

It does not go through all of the MM.INIT options possible.  To set the
fancier options, you can use the SET command along with CREATE-INIT, or
use an editor on the MM.INIT file.  HELP CREATE-INIT will list all the
available MM.INIT options.
/
;;; Create a new MM.INIT prompting in ENGLISH!

.PROFI:	CONFRM
	SETZM RINCME			;Default is no
	PROMPT <Do you want to receive copies of your replies to messages?>
	CALL YESNO1
	 JRST PROFI1			;Go for next query
	MOVEI A,1
	MOVEM A,RINCME
PROFI1:	MOVEI A,1			;Default is super-verbose
	MOVEM A,SNDVBS
	CITYPE <Normally, when you send a message you are told this disposition of
each address; whether it was delivered or queued for later delivery.
>
	PROMPT <Do you want to suppress this typeout?>
	CALL YESNO1
	 JRST PROFI2			;No, then terse
	SETOM SNDVBS			;Yes
PROFI2:	SETZM RFMDEF			;Default to No
	CITYPE <Normally, when you REPLY to or ANSWER a message, the reply will
default to only sending to the person you got the message from.
You can have MM default instead to replying to everybody listed in
the message header.>
	PROMPT <Do you want REPLY to default to everybody?>
	CALL YESNO1
	 JRST PROFI3
	SETOM RFMDEF
PROFI3:	SETZM BLSCST
	PROMPT <Do you want to erase the screen at startup and between messages?>
	CALL YESNO1
	 JRST PROFI4
	SETOM BLSCST
PROFI4:	MOVEI A,1
	MOVEM A,ABOFLG
	CITYPE <Normally the abort command control-N asks for confirmation before
aborting.>
	PROMPT <Do you want control-N to abort without asking?>
	CALL YESNO1
	 JRST PROFI5
	SETZM ABOFLG
PROFI5:	CITYPE <Other (fancier) profile options may be set by using the SET command
to set the option, and CREATE-INIT to update your MM.INIT profile file.
You may also edit MM.INIT with an editor.  Type HELP CREATE-INIT for a
complete listing of the MM.INIT options.>
	JRST CRINI0

;;;Create the guy an init file

.CRINI:	CONFRM
CRINI0:	MOVE A,[POINT 7,STRBUF]
	MOVEI B,[ASCIZ /PS:</]
	CALL MOVSTR
	MOVEI B,MYDIRS
	CALL MOVSTR
	MOVEI B,[ASCIZ />MM.INIT/]
	CALL MOVST0
	MOVSI A,(GJ%NEW!GJ%FOU!GJ%SHT)
	HRROI B,STRBUF
	GTJFN
	 JERROR (Can't get init file)
	MOVE B,[7B5+OF%WR]
	OPENF
	 JWARN (Can't open init file)
	MOVEM A,TMPJFN			;Save this for later
	MOVE U,[-NINVRS,,INIVTB+1]

CRILUP:	HRRZ T,(U)
	MOVE T,(T)			;Get info
	MOVE A,TMPJFN
	HLRO B,(U)			;Get name of variable
	SETZ C,
	TLNE T,-1			;Check for routine type entry
	 JUMPG T,CRILP4
	SOUT
	MOVEI B," "
	BOUT
	TLNE T,-1			;A string
	 JRST CRILP3			;Yes
	MOVE B,(T)
	MOVEI C,10
	NOUT
	 JWARN
CRILP1:	HRROI B,CRLF0
	SETZ C,
	SOUT
CRILP2:	AOBJN U,CRILUP
	CLOSF
	 JWARN (Couldn't close init file)
	SETOM TMPJFN
	RET

; String-type entry

CRILP3:	HRROI B,(T)			;Type out string
	SOUT
	JRST CRILP1

; Routine-type entry.  We must handle each of these as a special case

CRILP4:	CAMN T,[INILNS,,USRHDR]		;HEADER-OPTIONS?
	 JRST CRIL41
	HLRZ D,T			;Get dispatch item
	CAIN D,INIKEY			;Keyword table?
	 JRST CRIL45
CRILUZ:	HLRZ B,(U)			;Something new; get the losing string
	WARN (Unprocessable SET option "%2S")
	JRST CRILP2			;Try next item

CRIL41:	SKIPN USRHDR			;Are there any header options?
	 JRST CRILP2			;No, don't output this entry
	SOUT				;Yes, write out option name
	MOVEI B," "
	BOUT
	MOVE T,[POINT 7,USRHDR+4]	;Get pointer to string
CRIL42:	ILDB B,T			;Get byte from string
	JUMPE B,CRILP1			;Null means all done
	BOUT				;Write byte in file
	CAIE B,12			;Line feed?
	 JRST CRIL42
	HRROI B,[ASCIZ/HEADER-OPTIONS /];Yes, write new header and continue
	SOUT
	JRST CRIL42

CRIL45:	HLRZ D,(T)			;Is there anything in this table?
	JUMPE D,CRILP2			;No, don't try to hack it then
	SOUT				;Yes, write out option name
	MOVEI B," "
	BOUT
	HLLO D,(T)			;Get size of table
	EQVI D,(T)			;Form AOBJN pointer to table
	ADJSP D,1			;Skip past header word
	CAMN T,[INIKEY,,KEYTBL]		;Message keyword table?
	 JRST CRIL50			;Ugh.  Must do even more kludgery
CRIL46:	HLRO B,(D)			;Get a keyword string entry
	SOUT
	AOBJN D,[MOVEI B,","		;Insert comma delimiter
		 BOUT
		 JRST CRIL46]
	JRST CRILP1

; This routine is pretty cretinous, but it works and the table isn't that big

CRIL50:	PUSH P,D			;Save the table pointer
	HLLZ T,D			;Set up outside loop counter
CRIL51:	HRRZ B,(D)			;Get the keyword index for this entry
	CAIE B,(T)			;Is this the index we want?
	 AOBJN D,CRIL51			;No, try again
	JUMPGE D,[FATAL <Keyword table messed up>];Bug trap
	HLRO B,(D)			;Found the index, now output its string
	SOUT
	AOBJN T,[MOVEI B,","		;Insert comma delimiter if more to come
		 BOUT
		 MOVE D,(P)		;Restore search pointer
		 JRST CRIL51]
	ADJSP P,-1			;Clean up stack
	JRST CRILP1			;Now try next index

SUBTTL UUO handler

UUOH:	MOVEM 16,UUOACS+16		;Save all AC's
	MOVEI 16,UUOACS
	BLT 16,UUOACS+15
	LDB A,[POINT 9,40,8]		;Get opcode field
	CALL @UUOS(A)			;Do the right routine
	MOVSI 16,UUOACS			;Restore ac's
	BLT 16,16
	RET

UUOS:	0
	%PRINT
	%TYPE
	%ETYPE
	%ERROR
	%NOISE
	%DEFAL
	%PRMPT

%PRINT:	HRRZ A,40			;Get byte
	CAIN A,EOL			;Print EOL means do CRLF
	 JRST CRLF
%PRIN0:	PBOUT
	RET

%TYPE:	CALL TYCRIF			;Check if we should do a CRLF
%TYPE0:	HRRO A,40			;Get string
	PSOUT
	RET

%PRMPT:	SETZM CLEVEL
	HRLZ A,40			;Get prompt string
	JRST CMDINI			;Setup that as prompt

TYCRIF:	MOVE A,40			;Get instruction
	TLNE A,(<10,0>)			;Wants cr all the time?
	 JRST CRLF			;Yes
	TLNE A,(<1,0>)			;Wants fresh line?
	 JRST CRIF			;Yes
	RET

CRIF:	PUSH P,A
	PUSH P,B
	MOVEI A,.PRIOU
	RFPOS
	HRROI A,CRLF0
	TRNE B,-1			;If not at start of line,
	 PSOUT				;Type crlf
POP21J:	POP P,B
CPOP1J:	POP P,A
CPOPJ:	RET

CRLF:	PUSH P,A
	HRROI A,CRLF0
	PSOUT
CPOPAJ:	POP P,A
	RET

CRLF0:	BYTE (7) 15,12,0

%ERROR:	CALL CRIF			;Get a fresh line
	MOVE B,40			;Get instruction
	TLNE B,(<10,0>)			;Wants %?
	 SKIPA A,["?"]			;No
	  MOVEI A,"%"
	PBOUT
	TRNN B,-1			;Any message to print?
	 JRST %ERR2			;No
	CALL %ETYE0			;Yes, print it out
	MOVE B,40			;And recover instruction
%ERR2:	TLNN B,(<4, 0>)			;Wants JSYS error message?
	 JRST %ERR3
	HRROI A,[ASCIZ/ - /]
	TRNE B,-1			;If a previous message, type delimiter
	 PSOUT
	MOVEI A,.PRIOU
	HRLOI B,.FHSLF			;This fork
	SETZ C,
	ERSTR
	 NOP
	 NOP
%ERR3:	LDB A,[POINT 2,40,12]		;Get low order bits of ac field
	TRZE F,F%HOER			;Doing MAIL "monitor command"?
	 HALTF				;Yes, return to EXEC, allow continue
	JRST %ERRS(A)

%ERRS:	JRST CMDRES			;0 - return to top level commands
%ERRET:	XCT CMDRET			;1 - user settable return
	JRST %FATAL			;2 - return to exec
	RET				;3 - return to user

%FATAL:	HALTF
	HRROI A,[ASCIZ/?Can't continue
/]
	PSOUT
	JRST %FATAL

%ETYPE:	CALL TYCRIF			;Type a CR maybe
%ETYE0:	HRRZ U,40
%ETYS0:	HRLI U,(<POINT 7,0>)		;Get byte pointer to string
%ETYP1:	ILDB A,U			;Get char
	JUMPE A,CPOPJ			;Done
	CAIE A,"%"			;Escape code?
	 JRST %ETYP0			;No, just print it out
	SETZ V,				;Reset ac
%ETYP2:	ILDB A,U
	CAIL A,"0"			;Is it part of addr spec?
	 CAILE A,"7"
	  JRST %ETYP3			;No
	IMULI V,10			;Yes, increment address
	ADDI V,-"0"(A)
	JRST %ETYP2
%ETYP3:	CAIG A,"Z"
	 CAIGE A,"A"
	  JRST %ETYP0
	CALL @%ETYTB-"A"(A)		;Do dep't thing
	JRST %ETYP1

%ETYP0:	PBOUT
	JRST %ETYP1

%ETYTB:	%ETYPA				;A - Print time
	%ETYPB				;B - Print date
	%ETYP0				;C
	%ETYPD				;D - print decimal
	%ETYER				;E - error code
	%ETYPF				;F - floating
	%ETYP0				;G
	%ETYPH				;H - RH as octal
	%ETYP0				;I
	%ETYPJ				;J - filename
	REPEAT 2,<%ETYP0>		;K, L
	%ETYPM				;M - current msg number
	%ETYPN				;N - host name
	%ETYPO				;O - octal
	%ETYPP				;P - pluralizer
	REPEAT 2,<%ETYP0>		;Q, R
	%ETYPS				;S - string
	%ETYPT				;T - date and time
	%ETYPU				;U - user name
	REPEAT 5,<%ETYP0>		;V, W, X, Y, Z

%ETYPA:	MOVSI C,(OT%NDA)		;No day, just time
	JRST %ETYB0

%ETYPT:	TDZA C,C			;Both date and time
%ETYPB:	 MOVSI C,(OT%NTM)		;No time, just day
%ETYB0:	JUMPE V,.+2			;If ac field spec'd
	 SKIPA B,UUOACS(V)		;Use it
	  SETO B,			;Else use now
	MOVEI A,.PRIOU
	ODTIM
	RET

%ETYPD:	SKIPA C,[^D10]			;Decimal
%ETYPO:	 MOVEI C,10			;Octal
	MOVE B,UUOACS(V)		;Get data
%ETYO0:	MOVEI A,.PRIOU
	NOUT
	 NOP
	RET

%ETYER:	MOVEI A,.PRIOU
	MOVSI B,.FHSLF			;This fork
	HRR B,UUOACS(V)			;Get error code
	ERSTR
	 NOP
	 NOP
	RET

%ETYPM:	HRRZ B,UUOACS+M			;Current message
	IDIVI B,MSGLEN
	MOVEI C,^D10			;Decimal
	AOJA B,%ETYO0			;Zero is msg 1

%ETYPF:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	SETZ C,
	FLOUT
	 NOP
	RET

%ETYPH:	MOVEI C,10
	HRRZ B,UUOACS(V)
	JRST %ETYO0

%ETYPJ:	MOVEI A,.PRIOU
	HRRZ B,UUOACS(V)
	MOVE C,[211110,,1]		;Def dev, frc, dir, name, etc
	JFNS
	RET

%ETYPN:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	JRST $CVHST

%ETYPP:	MOVEI A,"s"
	MOVE B,UUOACS(V)
	CAIE B,1
	 PBOUT				;Make plural unless just one
	RET

%ETYPS:	PUSH P,U
	SKIPE U,UUOACS(V)
	 CALL %ETYS0			;Recursive call
CPOPUJ:	POP P,U
	RET

%ETYPU:	MOVEI A,.PRIOU
	MOVE B,UUOACS(V)
	DIRST
	 NOP
	RET

SUBTTL FSCOPY - Fast String Copy
;	Courtesy of KLH
;	A - Source BP
;	O - Dest BP
;	C - char count
;	Updates destination pointer in O, smashes AC's A-C freely

KLWINC==^D18	;# chars at which hairy word move starts wining over bp loop

$STENT==1	;offset from beg of loop for entry to STORE phase
$GENT==4	;offset from beg of loop for entry to GET phase

FSCOPY:	CAIL C,KLWINC			;Less than break-even point?
	 JRST FSCPY2			;No, use hairy word copy.
	ILDB B,A			;simple byte-by-byte copying.
	IDPB B,O
	SOJG C,.-2
	POPJ P,

;Wheee, using hairy word copying!

FSCPY2:	DMOVEM N,UUOACS+N	;This is a pain, but faster than using PDL,
	MOVE N,[D,,UUOACS+D]	;And we need to do something
	BLT N,UUOACS+N-1	;Since ACs will be massacred.

	LDB E,[360300,,A]	;Get low 3 bits of P field for source
	SKIPGE E,FSCHTB(E)	;Get resulting # chars, skip if addr ok
	 MOVEI A,1(A)		;P= 01, must bump address.
	MOVEI L,1(A)		;Anyway, get addr+1 into 12.
	LDB D,[360300,,O]	;Repeat procedure for dest
	SKIPGE D,FSCHT2(D)	;Using slightly different table
	 AOSA V,O		;And addr goes into 10
	  MOVEI V,(O)		;And isn't normally bumped.
	MOVEI O,(C)		;Update the destination pointer in o
	ADJBP O,UUOACS+O	;From initial value
;Now get index for shift values, and count for words
	SUBI C,(E)		;Get # chars minus those in 1st src wd.
	ADDI E,-6(D)		;Get E index - D*5+S, zero based.
	IDIVI C,5		;Find # words to loop through, rem in d.
	MOVE B,-1(L)		;And get 1st word of source.
	JRST @FPATH(E)		;Must now pick a path...

;Blt possible!  Jump to FSBLT0 if no shifting needed for setup.

FSBLT0:	MOVEM B,(V)		;Store source word directly
	JRST FSBLT4
FSBLT:	LSH B,@SHASL(E)		;Shift source up against left
	MOVE A,(V)		;Get 1st wd of dest.
	LSH A,@SHADR(E)		;Right-adjust it
	LSHC A,@SHFIX(E)	;And get everything into A.
	LSH A,1			;Need one more bit's worth.
	MOVEM A,(V)		;Store 1st wd of dest...

;Now settle down to serious BLT'ing.

FSBLT4:	MOVEI T,(C)		;Transfer word count
	ADDI T,(V)		;Find addr of last dest word
	MOVEI V,1(V)		;Now get 1st dest addr,
	HRLI V,(L)		;And put 1st source addr in LH.
	BLT V,(T)		;Zoom!!
	JUMPE D,FSCPY9		;If no remainder, super win - done!
	ADDI L,(C)		;Hmm, must get last source word.
	MOVE B,(L)		;Like so.
	MOVE A,FBMSK(D)		;And a word mask for chars
	AND B,A			;Clear unused bits from source,
	ANDCAM A,1(T)		;And zap target bits in dest.
	IORM B,1(T)		;And stick last chars in.
	JRST FSCPY9		;Ok, all done...

;Can't do BLT.  Well, get A and B set up for magical shift loop.

SHSKP2:	LSH B,@SHASL(E)		;Here, only need to adjust source,
	JRST SHSKP5		;Since dest will be totally clobbered.
FSSHFT:	LSH B,@SHASL(E)		;Here, both src and dest must be integrated.
SHSKP1:	MOVE A,(V)		;Here, only need adjust dest;src wd is full.
	LSH A,@SHADR(E)
SHSKP5:	LSHC A,@SHFIX(E)	;Stuff as many chars as possible into A.
	CAIE D,0		;If any remainder,
	 MOVEI C,1(C)		;Add 1 more word.
	MOVNI C,(C)		;Make AOBJN pointer.
	MOVSI C,(C)

;Now make another index for termination wrapup purposes.

	ADD D,FFINDX(E)		;Make new index using # chs left in last wd.

;Now set things up for loop, and enter it.

FSCPY3:	HRLI V,(<MOVEM A,(C)>)
	MOVEM V,FSCPKL+2	;Address for MOVEM
	HRRM L,FSCPKL+4		;Address for MOVE
	MOVE L,FSHINT(E)	;Get LSH for shift-in
	MOVEM L,FSCPKL
	MOVE L,FSHOUT(E)	;And shift-out
	MOVEM L,FSCPKL+3
	JUMPGE D,FSCPKL+$STENT	;Depending on flag in D, enter loop at store
	SOS V,FSCPKL+2
	JRST FSCPKL+$GENT	;Or at get.

;---------------------------------------------------------------------------
;Come here when loop finished.  The last word of the source string
;will be in B.  It may have 1 to 5 chars left for moving, but will
;never have 0.

;Long wrapup.

FSCPTL:	LSHC A,@FSCPKL	;Perform a shift-in
	LSH A,1
	MOVEM A,@10	;Store full word.
	MOVEI C,1(C)	;Increment address index
			;And drop through to Medium wrapup.

;Medium wrapup.

FSCPTM:	LSHC A,@FLOUT(D)	;Shift rest of source word into A
	MOVE B,@10		;Get dest word it will be stored into
	LSH B,@FLADJ(D)		;Left-adjust chars to preserve.
				;And drop thru to Short wrapup.

;Short wrapup.

FSCPTS:	LSHC A,@FFLOUT(D)	;Do final, last, shift-out.
	ANDCMI A,1
	MOVEM A,@10		;And store last dest word.

;Done!!  Just restore regs and return.

FSCPY9:	MOVE N,[UUOACS+D,,D]
	BLT N,N
	POPJ P,

;Indexed by low 3 bits of P field, returns # chars
;existing to right of loc BP points to.  Hence value
;ranges from 5 to 1;if P = 01, SETZ indicates that
;bp address needs incrementing.

FSCHTB:	1	;P=10
	SETZ 5	;P=01, increment addr
	0
	0	;Randomness
	5	;P=44, full word
	4	;P=35, 4 chars to go
	3	;P=26
	2	;P=17

;This table is just like FSCHTB except values are pre-multiplied
;by 5 for easy addition into E.

FSCHT2:	1*5	;P=10
	SETZ 5*5 ;P=01, increment addr
	0
	0	;Random
	5*5
	4*5
	3*5
	2*5

;This table is indexed by D when it has # chars remaining from
;dividing # chars (in C) by 5.  Provides mask for these chars.

FBMSK:	0	;Nothing here.
	BYTE (7) 177
	BYTE (7) 177, 177
	BYTE (7) 177, 177, 177
	BYTE (7) 177, 177, 177, 177

;FPATH table vectors off to BLT and other minor stuff as
;soon as all the basic computations are made.
;Indexed by E.

FPATH:	FSBLT
	FSSHFT
	FSSHFT
	FSSHFT
	SHSKP1
	FSSHFT
	FSBLT
	FSSHFT
	FSSHFT
	SHSKP1
	FSSHFT
	FSSHFT
	FSBLT
	FSSHFT
	SHSKP1
	FSSHFT
	FSSHFT
	FSSHFT
	FSBLT
	SHSKP1
	SHSKP2
	SHSKP2
	SHSKP2
	SHSKP2
	FSBLT0

DEFINE ENT (A,B,C,D,E) <
	A*7
	B*7
	C*7
	D*7
	E*7
   >
;SHASL table, contains # bits to shift first source wd left so
;as to left-adjust it in B.  Indexed by E.

SHASL:	ENT 4,3,2,1,0
	ENT 4,3,2,1,0
	ENT 4,3,2,1,0
	ENT 4,3,2,1,0
	ENT 4,3,2,1,0

;SHADR table, contains # bits to shift first dest wd right so
;as to right-adjust it in A.  Indexed by E.

DEFINE ENT1 (A,B,C,D,E) <
	0,,A*7-1
	0,,B*7-1
	0,,C*7-1
	0,,D*7-1
	0,,E*7-1
   >
SHADR:
	ENT1 -1,-1,-1,-1,-1
	ENT1 -2,-2,-2,-2,-2
	ENT1 -3,-3,-3,-3,-3
	ENT1 -4,-4,-4,-4,-4
	ENT1 -5,-5,-5,-5,-5

;SHFIX table, contains # bits to left-shift A and B combined so
;as to move as many characters out of B as possible.  Indexed
;by E.  MIN(d,e) (d and e after fschtb)

SHFIX:	ENT 1,1,1,1,1
	ENT 1,2,2,2,2
	ENT 1,2,3,3,3
	ENT 1,2,3,4,4
	ENT 1,2,3,4,5

;FSHINT table, containing appropriate LSHC instructions for shifting
;in the first chars of a fresh source word.  Indexed by E.

DEFINE ENTL (ARG1,ARG2,ARG3,ARG4,ARG5) <
	LSHC A,ARG1*7
	LSHC A,ARG2*7
	LSHC A,ARG3*7
	LSHC A,ARG4*7
	LSHC A,ARG5*7
   >
FSHINT:	ENTL 5,4,3,2,1
	ENTL 1,5,4,3,2
	ENTL 2,1,5,4,3
	ENTL 3,2,1,5,4
	ENTL 4,3,2,1,5

;FSHOUT table, containing appropriate LSHC instructions for shifting
;out the last chars of an old source word, to make room for a
;new one.  Indexed by E.

FSHOUT:	ENTL 0,1,2,3,4
	ENTL 4,0,1,2,3
	ENTL 3,4,0,1,2
	ENTL 2,3,4,0,1
	ENTL 1,2,3,4,0

;FFINDX table, contains part of D index for fast add-in.
;Indexed by E.  Similar to FSHOUT.  Sign bit also indicates
;whether entry point is $STENT (pos) or $GENT (neg).

DEFINE ENTS (A,B,C,D,E) <
	ENT5 A
	ENT5 B
	ENT5 C
	ENT5 D
	ENT5 E
   >
DEFINE ENT5 (X,Y) <
	X+<Y*5>
>
S==0B0
G==1B0

FFINDX:	ENTS (<S,0>,<S,1>,<S,2>,<S,3>,<S,4>)
	ENTS (<G,4>,<S,0>,<S,1>,<S,2>,<S,3>)
	ENTS (<G,3>,<G,4>,<S,0>,<S,1>,<S,2>)
	ENTS (<G,2>,<G,3>,<G,4>,<S,0>,<S,1>)
	ENTS (<G,1>,<G,2>,<G,3>,<G,4>,<S,0>)

DEFINE ENTX (A,B,C,D,E) <	;Last item (5) is actually first (0)
	7*E
	7*A
	7*B
	7*C
	7*D
   >

;FENTRM table, dispatching to appropriate wrapup routine when fast AC
;loop is finished.  Indexed by D.

FENTRM:
DEFINE ENTXJ ' (A,B,C,D,E) <
	FSCPT'E
	FSCPT'A
	FSCPT'B
	FSCPT'C
	FSCPT'D
>
	ENTXJ M,M,M,M,S
	ENTXJ M,M,M,S,L
	ENTXJ M,M,S,L,L
	ENTXJ M,S,L,L,L
	ENTXJ S,L,L,L,L

;FLOUT table, for use by Medium wrapup routine;pushes out remaining
;source chars in B, making room for incoming dest word.
;Indexed by D.

FLOUT:	ENTX 1,2,3,4,0
	ENTX 1,2,3,0,1
	ENTX 1,2,0,1,2
	ENTX 1,0,1,2,3
	ENTX 0,1,2,3,4

;FLADJ table, also for Medium wrapup routine;adjusts dest word in
;B to left-adjust chars to be preserved.

FLADJ:	ENTX 1,2,3,4,5
	ENTX 2,3,4,5,1
	ENTX 3,4,5,1,2
	ENTX 4,5,1,2,3
	ENTX 5,1,2,3,4

;FFLOUT table, for Short wrapup routine.  Final Last shift-out of
;chars in B, so that the last dest word can be stored from A.
;Indexed by D.  Adds 1 extra bit since MOVEM A, done right after it,
;and nothing to preserve in B.

FFLOUT:
DEFINE ENTX1 (A,B,C,D,E) <
	E*7+1
	A*7+1
	B*7+1
	C*7+1
	D*7+1
   >
	ENTX1 4,3,2,1,5
	ENTX1 3,2,1,4,4
	ENTX1 2,1,3,4,3
	ENTX1 1,2,4,3,2
	ENTX1 1,4,3,2,1


SUBTTL Command parsing routines

CMDINI:	TRZ F,F%HOER			;No more exiting on errors if command
					;level (user typed ESC or something)
	HLROM A,CMDBLK+.CMRTY		;Set up prompt string
	MOVSI B,(CM%XIF)
	ANDCAM B,CMDBLK+.CMFLG
	MOVEM A,TPADD1			;Save command pointers
	MOVEI A,REPARS			;Setup reparse address
	SKIPE CMIMWK
	 TLO A,(CM%WKF)			;In case user wants immediate wakeup
	MOVEM A,CMDBLK+.CMFLG
RUTG,<
	PUSH P,CMDBLK+.CMIOJ		;Save I/O jfns
	MOVE B,[.NULIO,,.NULIO]		;Get null jfns
	MOVEI A,.RSCNT			;Find count of RSCAN characters
	RSCAN
	 ERJMP .+3			;Assume not rescanning
	  SKIPE A			;If we're reading from rescan buffer
	   MOVEM B,CMDBLK+.CMIOJ	;Do I/O to null this time
>;RUTG
	MOVEI A,CMDBLK			;COMND state pointer
	MOVEI B,[FLDDB. .CMINI]		;Init command block
	COMND
RUTG,<
	POP P,CMDBLK+.CMIOJ		;Restore I/O jfns
>;RUTG
	SETZM CMDFLB			;Init command field block
	MOVE A,[CMDFLB,,CMDFLB+1]
	BLT A,CMDFLB+3
	POP P,TPADDR			;Save address of caller
CMDIN2:	MOVE A,TPADD1			;Get back command pointers
	JRST @TPADDR			;And return

REPARS:	SKIPE CLEVEL			;If not at top-level
	 SETZM CMDFLB+.CMDEF		;Reset default
	CALL CLSTMP			;Get rid of stray jfns
	SKIPLE A,OUTJFN
	 CLOSF
	  NOP
	JRST CMDIN2

CONF:	MOVEI B,[FLDDB. .CMCFM]		;Get confirmation
	JRST CMDFLD

SUBCMD:	AOSA CLEVEL			;One level deeper
GETCMD:	 SETZM CLEVEL			;At the top
	HRRZM A,CMDFLB+.CMDAT		;Address of keyword table
	SETZM CMDFLB+.CMFNP		;.CMKEY = 0
	CALL CMDNO2			;Parse the field
	SETZM CMDFLB+.CMHLP		;Reset default and help messages
	SETZM CMDFLB+.CMDEF
	HRRZ A,(B)			;Get address of routine
	SETZM OKTINT			;No more timer ints now
	AOS CLEVEL			;Know that we arent top-level
	RET

%NOISE:	MOVSI A,(<BYTE (9) .CMNOI,0>)
	MOVEM A,CMDFLB+.CMFNP
	HRRO A,40
CMDNO1:	MOVEM A,CMDFLB+.CMDAT
CMDNO2:	MOVSI A,(CM%DPP)
	SKIPE CMDFLB+.CMDEF		;Default provided?
	 IORM A,CMDFLB+.CMFNP		;Yes, say there is one
	MOVEI B,CMDFLB
CMDFLD:	MOVEI A,CMDBLK
	COMND
	TLNE A,(CM%NOP)
	 UERR 15,			;Give jsys error message and return
	RET				;Did ok

%DEFAL:	HRRZ B,40
	HRROM B,CMDFLB+.CMDEF		;Save default string
	RET

GETLIN:	MOVEI B,[FLDDB. .CMCFM,CM%SDH,,,,[FLDDB. .CMTXT]]
	SKIPE CLEVEL
	 JRST [	HRRZ B,(B)		;Not at top level, dont need cfm option
		JRST CMDFLD]
	MOVEI A,GETLIN
	HRRM A,CMDBLK+.CMFLG		;Reparse address is just us if at top
	SETZM STRBUF			;Else make sure atom buffer clear
	JRST CMDFLD			;Just go read a line

GETDAT:	MOVEI B,[FLDDB. .CMTAD,,CM%IDA!CM%ITM,,,<[
		 FLDDB. .CMTAD,,CM%IDA,,,<[
		 FLDDB. .CMTAD,,CM%ITM,,,<[
		 FLDDB. .CMKEY,,DATTAB,,,<[
		 FLDDB. .CMKEY,,HOLDAY]>]>]>]>]
	CALL CMDFLD
	LDB C,[POINT 9,(C),8]		;Get field type parsed
	CAIN C,.CMTAD			;Date and time?
	 RET				;Yes, just return that time
	HRRZ T,(B)			;Else get data for it
	MOVE T,(T)
	JRST (T)			;And call the right routine

DATDOW:	SETO B,
	SETZ D,
	ODCNV
	MOVSI C,8(C)			;Get day of week into lh
	SUBM C,T			;Get difference from desired
DATDAY:	HLLZ B,T			;Get number of days to offset
	CAMLE B,[7,,0]			;If week wrapped around,
	 SUB B,[7,,0]			;Take next one
	GTAD
	SUBM A,B
	SETZ D,
	ODCNV
	SETZ D,				;Midnight of that day
	IDCNV
	 SETO B,
	RET

DATHDY:	GTAD				;Get now for later
	SETO B,
	SETZ D,
	ODCNV
	HLRZ E,B			;Save year
DATHD1:	LDB B,[POINT 9,T,8]		;Get month
	HRLI B,(E)			;Get year
	HLLZ C,T
	TLZ C,777000			;Get day of month
	SETZ D,
	IDCNV
	 SETO B,
	CAML B,A			;Must be before today
	 SOJA E,DATHD1			;Else try last year
	RET

GETJFN:	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]
	BLT A,CMDGTB+.GJATR
	SKIPN B,DEFPRO			;Have default protection?
	 JRST GETJF0			;No - don't set one up
	HRROI A,DEFPST			;Where to put string
	MOVEM A,CMDGTB+.GJPRO		;Set up pointer to default
	MOVE C,[6,,10]			;Columns,,radix
	NOUT
	 JERROR (New file protection error)
GETJF0:	SKIPG B,MSGJFN			;Have a file now?
	 JRST [	HRROI B,[ASCIZ /MAIL/]
		MOVEM B,CMDGTB+.GJNAM
		HRROI B,[ASCIZ /TXT/]
		MOVEM B,CMDGTB+.GJEXT
		JRST GETJF1]		;No, default to mail then
	HRROI A,STRBUF+40
	MOVEM A,CMDGTB+.GJNAM
	MOVSI C,001000
	JFNS
	HRROI A,STRBUF+60
	MOVEM A,CMDGTB+.GJEXT
	MOVSI C,000100
	JFNS
GETJF1:	SKIPA B,[[FLDDB. .CMFIL]]
GETIFI:	 MOVEI B,[FLDDB. .CMIFI]
	CALL CMDFLD			;Get the file
	MOVE A,B			;Return jfn in a
	RET

;;;Message sequence handler

GETSEQ:	NOISE (MSGS)
	TLZ F,(F%TYPS)			;Default dont type numbers of sequence
	SETOB X,LSTMSG
	MOVE L,[POINT 12,MSGSEQ]	;Pointer to where to store messages
	MOVE A,[FLDDB. .CMTOK,CM%HPP!CM%SDH,,,,TKNDOT] ;Build the first pointer
	MOVEM A,CMDFLB+.CMFNP		;With our default string
	HRROI A,[ASCIZ /%/]
	MOVEM A,CMDFLB+.CMDAT
	HRROI A,HLPTXT
	MOVEM A,CMDFLB+.CMHLP
	CALL CMDNO2
	SETZM CMDFLB+.CMHLP		;Reset default and help messages
	SETZM CMDFLB+.CMDEF
	LDB A,[POINT 9,(C),8]		;Get field type
	CAIN A,.CMTOK
	 JRST GETSQT
	CAIN A,.CMNUM			;Number?
	 JRST GETSQN			;Yes - get that
GETSQK:	HRRZ A,(B)			;Must be keyword, get routine addrs
	JRST (A)			;Go there and return

;;;Token - check for % or . and supply number

GETSQT:	LDB A,[POINT 7,STRBUF,6]	;Get token character
	CAIE A,"*"
	 CAIN A,"%"
	  SKIPA B,LASTM			;% = last message number
	   MOVEI B,(M)			;. = current message number
	ADDI B,MSGLEN			;Handle as number now
	IDIVI B,MSGLEN
;	JRST GETSQN

;;;Number parsed - handle n:m n,m or n alone

GETSQN:	JUMPE B,GTSQNE			;Range error
	SOJL B,GTSQNE
	MOVE C,LASTM
	IDIVI C,MSGLEN
	CAILE B,(C)			;His number > last message?
	 MOVEI B,(C)			;Yes, then default to last one
	JUMPGE X,GTSQ2N			;2nd in series n:m
	CALL GTSQLC			;Save number on list
	MOVEI B,GTNBK1			;Now try for <cr> ! , ! :
GTSQNF:	CALL CMDFLD
	LDB A,[POINT 9,(C),8]		;Get fcn parsed
	CAIN A,.CMCFM			;EOL?
	 JRST GTSQNR			;Yes - done
	CAIE A,.CMCMA			;Comma?
	 LDB X,L			;Must be ":" , setup for 2nd arg
	MOVEI B,GTNBK2			;Yes - try for <number> ! . ! %
	CALL CMDFLD
	LDB A,[POINT 9,(C),8]		;Get fcn parsed
	CAIN A,.CMCFM			;EOL?
	 JRST GTSQNR			;Yes - done
	CAIN A,.CMNUM			;Number?
	 JRST GETSQN			;Yes - handle
	JRST GETSQT			;Handle token

GTSQLC:	CAMN L,[141400,,MSGSQZ-1]	;Reached end of list?
	 ERROR (Too many messages in list)
	IDPB B,L			;Save number in list
	SETOM NXTMSD			;Flag that previous sequence has been clobbered
	RET

;;;2nd in range seen - fill list
GTSQ2N:	TRO B,2000			;Mark as end of range
	CALL GTSQLC			;Save in table
;	JRST GTSQNC			;Go try for more

GTSQNC:	SETO X,				;Say looking for 1st number of pair
	MOVEI B,GTNBK3			;Try for <cr> ! ,
	JRST GTSQNF

;;;EOL seen, wrapup numbers

GTSQNR:	MOVEI B,3777			;Mark end of list
	IDPB B,L
GTSQNS:	MOVE L,[POINT 12,MSGSEQ]	;Reset list
	MOVEI A,NXTSEQ			;Nest in the sequence
	MOVEM A,NXTMSD			;Setup as dispatch
	RET				;Return

GTSQNE:	ERROR (Number out of range)

HLPTXT:	ASCIZ /Message sequence in the form:
   n 	- Single message number
   n,m,...,k	- List of message numbers
   n:m		- Range of message numbers
     or any combination of ranges in a list.
   "."	- Current message number
   "%" or "*" - Last message in file
     Terminate list with <CR>/

TKNDOT:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /./]>,,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /*/]>,,,<[
	FLDDB. .CMNUM,CM%SDH,^D10,,,<[
	FLDDB. .CMKEY,,SQCMTB]>]>]>

TKNCLN:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /:/]>

GTNBK1:	FLDDB. .CMCFM,CM%SDH,,<-1,,HLPTXT>,,<[
	FLDDB. .CMCMA,CM%SDH,,,,TKNCLN]>

GTNBK2:	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /%/]>,<-1,,HLPTXT>,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /./]>,,,<[
	FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /*/]>,,,<[
	FLDDB. .CMNUM,CM%SDH,^D10]>]>]>

GTNBK3:	FLDDB. .CMCFM,CM%SDH,,<-1,,HLPTXT>,,<[
	FLDDB. .CMCMA,CM%SDH]>

;;;Get User@site string, w/ addr where to stick block, return in u

CMDUSE:	MOVEI A,CMDBLK			;Here for error
	MOVEI B,[FLDDB. .CMINI]		;Re-init comnd state block
	COMND
CMDUS0:	MOVSI A,(CM%XIF)		;Here for reparse
	ANDCAM A,CMDBLK+.CMFLG
	MOVE P,TPADDR
	MOVE W,TPADD1			;Reset list as of start
	TLZ F,(F%COMA!F%F4)
GETUSR:	MOVEI B,[FLDDB. .CMCFM,,,,,<[
		 FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /*/]>,<-1,,[ASCIZ/"*" to specify a file address/]>,,<[
		 FLDDB. .CMUSR,,,,,<[
		 FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /./]>,<-1,,[ASCIZ/"." to specify yourself/]>,,<[
		 FLDDB. .CMKEY,CM%SDH,<[2,,2
				[CM%FW!CM%INV!CM%NOR
				 ASCIZ /SYSTE/],,0
				[ASCIZ /SYSTEM/],,0]>,<-1,,[ASCIZ/SYSTEM/]>,,<[
		 FLDDB. .CMQST,,,,,<[
		 FLDDB. .CMFLD,,,<-1,,[ASCIZ/Network address/]>,,,UNMMSK
			]>]>]>]>]>]>]
	TLZE F,(F%COMA)			;Is this the first one?
	 JRST CMDUS1			;No
	SKIPE CLEVEL
	 JRST CMDUS2
	MOVEI A,CMDUS0			;Setup reparse address for this routine
	HRRM A,CMDBLK+.CMFLG
	MOVEI A,CMDUSE			;Setup error dispatch
	HRRM A,CMDRET
	MOVEM P,TPADDR
	MOVEM W,TPADD1			;Save list so far
	JRST CMDUS2

CMDUS1:	HRRZ B,(B)			;Dont allow crlf
CMDUS2:	CALL CMDFLD			;Parse a field
	LDB E,[POINT 9,(C),8]
	CAIN E,.CMCFM
	 RET				;Null field, return
	MOVEI U,(W)
	TLNN F,(F%F4)
	 TDZA A,A
	  MOVSI A,400000		;Invisible if requested
 	MOVEM A,(U)			;Setup flags
	CAIN E,.CMKEY			;Keyword must be SYSTEM
	 SKIPA B,[-2]			;Special user number
	  CAIN E,.CMUSR
	   MOVEM B,2(U)
	CAIE E,.CMTOK			;Token?
	 JRST CMDUS3			;No, just a string then
	MOVE A,.CMDAT(C)
	ILDB A,A			;Get first char of token
	CAIN A,"*"			;File type?
	 JRST CMDUFL			;Yes, handle that
	MOVE B,MYDIR
	MOVEM B,2(U)
	SKIPA B,[MYDIRS]		;Use my name string too
CMDUS3:	 MOVEI B,STRBUF
	MOVEI A,4(W)
	HRLI A,(<POINT 7,0>)
	CALL MOVST0			;Move in user name
	MOVEI A,1(A)			;Point to next free word
	SUBM A,W			;Get length
	EXCH A,W
	DPB A,[POINT 9,(U),17]		;Store it away
	SETZM 1(U)
	SETZM 3(U)
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /@/]>,<-1,,CUSHLP>,,<[
		 FLDDB. .CMTOK,CM%SDH,<POINT 7,[ASCIZ /:/]>]>]
	MOVSI D,(CM%XIF)
	IORM D,CMDBLK+.CMFLG
	COMND
	ANDCAM D,CMDBLK+.CMFLG
	TLNN A,(CM%NOP)			;Was it @ or :?
	 JRST CMDUTK			;Yes, get host or do group then
	CAIE E,.CMUSR			;Was it a user before?
	 TLNE F,(F%F3)			;Or funny addresses ok?
	  JRST CMDUS4
	CAIE E,.CMKEY
	 CAIN E,.CMTOK
	  JRST CMDUS4
; Looks like a local address, but not a user.  Try forwarding.
	MOVSI A,(GJ%OLD!GJ%SHT)		;Get JFN of forwarder
	HRROI B,[ASCIZ/SYS:MAILBOX.EXE/]
	GTJFN
	 ERJMP CMDUS5			;Can't
	PUSH P,A			;Save JFN
	MOVSI A,(CR%CAP)		;Create an inferior fork
	CFORK
	 JERROR (Can't create forwarding fork)
	EXCH A,(P)			;Save fork handle, get JFN
	HRL A,(P)			;Get prog into fork
	GET
	HRLZ A,(P)			;Page 0 of inferior
	MOVE B,[.FHSLF,,FWDPAG/1000]	;Mapped to this fork's FWDPAG
	MOVSI C,(PM%RD!PM%WR)		;Read+write access
	PMAP
	MOVE A,[POINT 7,4(U)]		;Copy name
	SKIPA B,[POINT 7,FWDPAG+140]
	 IDPB C,B
	ILDB C,A
	JUMPN C,.-2
	MOVE A,(P)			;Set inferior's AC1 to 1 for local site
	MOVEI B,[1]-1
	SFACS
	MOVEI B,2			;Start up inferior
	SFRKV
	WFORK
	RFSTS				;See if it finished ok
	HLRZ A,A
	CAIE A,.RFHLT			;HALTF?
	 JRST CMDUS6
	MOVE A,(P)			;Now get the answer from its AC1
	MOVEI B,FRKACS
	RFACS
	SKIPG FRKACS+1			;Success answer?
	 JRST CMDUS6			;No, error
	MOVEI A,4(U)			;Source
	DMOVE B,[FWDPAG+140		;Destination user
		 FWDPAG+150]		;Destination host
	POP P,A				;Flush the fork
	KFORK
	PUSH P,D			;In case HSTINI is called
	SKIPN HSTPTR			;Make sure host table present
	 CALL HSTINI
	POP P,D				;Sigh
NOHST2,<
	MOVE A,LHOSTN			;Get host number
>;NOHST2
HOSTS2,<
	MOVE A,LHOSTP			;Get host string pointer
>;HOSTS2
	MOVEM A,2(U)			;Set up host properly
	MOVEI A,2			;Network recipient
	TLNE F,(F%F4)
	 TRO A,400			;Make invisible is requested
	DPB A,[POINT 9,(U),8]		;Store type field and flags
CMDUS4:	MOVEI B,[FLDDB. .CMCFM,,,,,<[FLDDB. .CMCMA]>]
	CALL CMDFLD			;Must be comma or confirm here
	LDB D,[POINT 9,(C),8]		;Get field type
	CAIN D,.CMCMA
	 TLO F,(F%COMA)
	JRST CPOPJ1

CMDUS6:	POP P,A				;Now flush the fork
	KFORK
CMDUS5:	MOVEI A,4(U)			;Else return error
	ERROR (No such local user as "%1S")

CUSHLP:	ASCIZ/confirm with carriage return
 or ","
 or "@"
 or ":"
/

CMDUTK:	MOVE A,.CMDAT(C)
	ILDB A,A
	CAIN A,"@"			;Hostname?
	 JRST CMDUHS			;Yes, get hostname
	TLO F,(F%F4)			;Say we are within a distribution list
	MOVEI A,3			;Distribution list type recipient
	DPB A,[POINT 9,(U),8]
	JRST GETUSR			;And go get some more guys

CMDUHS:	SETZM CMDFLB+.CMFNP
	SKIPN A,HSTPTR
	 CALL HSTINI
	CALL CMDNO1			;Get pointer to name entry in B
	HRRZ A,(B)			;Get pointer to site entry in A
NOHST2,<
	MOVE A,(A)
>;NOHST2
HOSTS2,<
	HLRZ A,(A)			;Get pointer to offical host name
>;HOSTS2
	MOVEM A,2(U)			;Save host number
	MOVEI A,2			;Network recipient
	TLNE F,(F%F4)
	 TRO A,400			;Make invisible is requested
	DPB A,[POINT 9,(U),8]		;Store type field and flags
	MOVEI B,[FLDDB. .CMCFM,,,,,<[
		 FLDDB. .CMCMA]>]
	CALL CMDFLD
	LDB D,[POINT 9,(C),8]
	CAIN D,.CMCMA
	 TLO F,(F%COMA)
	JRST CPOPJ1

CMDUFL:	SETZM CMDGTB			;Get space for GTJFN
	MOVE A,[CMDGTB,,CMDGTB+1]
	BLT A,CMDGTB+.GJATR
	MOVEI B,[FLDDB. .CMFIL,CM%SDH,,<-1,,[ASCIZ/output filespec/]>]
	CALL CMDFLD
	MOVEI A,(B)
	RLJFN				;Dont need it till later
	 NOP
	MOVEI A,401			;File recipient
	DPB A,[POINT 9,(U),8]
	SETZM 2(U)
	JRST CMDUS3			;Go stick in the filename, etc

;;; Parse list of keywords and return mask in u
GETKEY:	SETZ U,				;Init bits
	MOVEI B,[FLDDB. .CMTOK,,<POINT 7,[ASCIZ /*/]>,,,<[
		 FLDDB. .CMKEY,,KEYTBL]>]
	CALL CMDFLD
	LDB D,[POINT 9,(C),8]
	CAIE D,.CMTOK
	 JRST GETKY2
	SETO U,
	RET

GETKY1:	MOVEI B,[FLDDB. .CMKEY,,KEYTBL]
	CALL CMDFLD			;Get a keyword
GETKY2:	HRRZ B,(B)
	MOVNI B,(B)
	MOVSI A,400000
	LSH A,(B)
	IOR U,A				;Set the given bit
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMCMA]
	COMND
	TLNN A,(CM%NOP)
	 JRST GETKY1
	RET				;Not a comma, return

;;;Parse command line

DORSCN:	SETZ A,
	RSCAN
	 SETZ A,
	JUMPE A,CPOPJ			;No command line
RUTG,<
	MOVSI A,[BYTE (7) "M","M",76]	;Prompt which will be dummied
>;RUTG
NORUTG,<
	MOVSI A,[ASCIZ //]		;Dummy prompt
>;NORUTG
	CALL CMDINI			;Init COMND state block
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMKEY,,<[3,,3
				  [ASCIZ /MAIL/],,.SEND
				  [ASCIZ /MM/],,0
				  [ASCIZ /NMM/],,0]>]
	COMND
	TLNE A,(CM%NOP)
	 JRST DORSCE			;Error, flush line
	HRRZ A,(B)
	JUMPN A,[NOISE (TO)		;In case EXEC has (TO) noise word
		 TRO F,F%HOER		;Return to EXEC on any error
		 JRST DORSC1]
	HRROI A,[ASCIZ / To: /]		;In case of error,
	MOVEM A,CMDBLK+.CMRTY		;Set up reasonable prompt string
	MOVEI A,CMDBLK
	MOVEI B,[FLDDB. .CMKEY,,RSCMTB]	;Parse MM SEND
	COMND
	TLNE A,(CM%NOP)
	 JRST DORSCE
	HRRZ A,(B)			;Get dispatch address
DORSC1:	TRO F,F%RSCN			;Say called from command line
	CALL (A)
	JRST CMDRES			;And go to top-level

DORSCE:	MOVEI A,.PRIOU			;Error, flush rest of line
	BKJFN
	 NOP
	PBIN
	CAIE A,12
	 JRST .-2
	DMOVE A,[POINT 7,CSBUF		;Avoid embarassment if user types ^H
		 CSBFSZ*5]		; first thing
	DMOVEM A,CMDBLK+.CMPTR
	RET

;;;Read in file for rscan command handling

RSCFIL:	CALL GETFIL			;For read from command line
	TLZ F,(F%F1)			;Don't type out headers
	JRST RECEN0

;;;Local modes:
;;;Mode: MIDAS
;;;Comment column:40
;;;End:

END <3,,EV>
