this file contains: opar3,pmem,pmem2,pmem3,pmem4,pmem5,win

COMMENT    VALID 00004 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN 
C00012 00003
C00016 00004	
C00029 ENDMK
C;

BEGIN 

%	THIS FILE CONTAINS THE ROUTINES FROM OLD PARRY WHICH DEALT WITH
		FLARE AND DELUSION TOPICS AND SETTING VARIABLES FROM THEM  %


%		#####   PARANOID MODEL   #####		%


NEW     POINTERS, DELFLAG, FLARE, FLARELIST, WDFLAG,
	TOPIC, DELNLIST, DELVLIST, DELALIST, LIVEFLARES, DEADFLARES, DELEND,

	SENSITIVELIST, WEIGHT, WEAK, SUPPRESS, CHOSEN,
	ANGER, FEAR, MISTRUST, HURT, ANGER0, FEAR0, MISTRUST0, HURT0, AJUMP, FJUMP, HJUMP,
	TRACEV, X, EOF, ENDE, SAVEFILE, FILE1, FILE2;

SPECIAL POINTERS, DELFLAG, FLARE, FLARELIST, WDFLAG,
	TOPIC, DELNLIST, DELVLIST, DELALIST, LIVEFLARES, DEADFLARES, DELEND,

	SENSITIVELIST, WEIGHT, WEAK, SUPPRESS, CHOSEN,
	ANGER, FEAR, MISTRUST, HURT, ANGER0, FEAR0, MISTRUST0, HURT0, AJUMP, FJUMP, HJUMP,
	TRACEV, X, EOF, ENDE, SAVEFILE, FILE1, FILE2;

SPECIAL TEN, EIGHT, IBASE, BASE;

DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
	THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX;

EXPR TEN();  BASE_IBASE_TEN;
EXPR EIGHT();  BASE_IBASE_EIGHT;

%THE FOLLOWING FUNCTION IS TO FIX OCTAL-DECIMAL PROBLEM %
FEXPR LAPIN (L);
	BEGIN NEW IBASE;
	IBASE_8;
	RETURN EVAL ('DSKIN CONS L);
	END;

	%
OPARINITIALIZE	READS IN RDATA, SETS ALL VARIABLES IN THIS FILE  
		MUST BE DONE WHEN MAKING A NEW CORE IMAGE OF PARRY  %

EXPR  OPARINITIALIZE ();
	 BEGIN
	  
		EVAL '(INC (INPUT (PAR BLF) RDATA) NIL);
		WHILE NOT ATOM X _ ERRSET(READ(),T) DO EVAL CAR X;
		INC(NIL,T);

	  FLARE_'INIT;				%   FLARE=CURRENT FLARE TOPIC;
							  'INIT = NONE   %
	  LIVEFLARES_GET ('FLARELIST, 'SETS);	 %   FLARES NOT YET DISCUSSED   %
	    DEADFLARES_NIL;
	  SENSITIVELIST_GET ('SENSITIVELIST, 'SETS);  %   SENSITIVE TOPICS   %
	  DELNLIST_GET ('DELWDS, 'NOUNS);	% DELUSION TOPICS   %
	  DELVLIST_GET ('DELWDS, 'VERBS);
	  DELALIST_GET ('DELWDS, 'AMBIG);	% DELUSION TOPICS ABOVE A CERTAIN THRESHOLD OF MISTRUST   %
	  
	ANGER_ANGER0_FEAR_FEAR0_MISTRUST_MISTRUST0_HURT_HURT0_0;
	FJUMP_AJUMP_HJUMP_NIL;

	END;

	%
CHECKFLARE     SCANS THE INPUT SENTENCE FOR THE FLARE WORD WHICH HAS THE
		HIGHEST WEIGHT   %
		% CALLED BY FLAREREF, ASCAN  %

	EXPR  CHECKFLARE (INP, FLARELIST, FLAG);
	 BEGIN
	  NEW NFLARE, WORD, FSET, WT, RESULT, W;

		%   DISTINGUISH FLARES FOUND WITHIN THE STATEMENT (NFLARE)
		 FROM MOST RECENT FLARE (FLARE)   %

	  NFLARE_'INIT;	    %   GET ('INIT, 'WT) = 0   %

		%   SCAN INPUT FOR FLARES AND CHECK WHETHER WEIGHT IS
		    GREATER THAN ANY PRECEDING FLARES IN INPUT   %

	% ***** SOMEDAY, USE DIFFERENT INP AND DIFFERENT "GET(WORD,'SET)" %
	%   FOR EXAMPLE, USE THE PATTERN OR THE WORDS THAT MATCHED THE PATTERN  %

	  FOR WORD IN INP DO
	      IF (FSET_GET (CAR WORD, 'SET)) MEMBER (FLARELIST) 
			AND GET(CDR WORD, 'USED)  THEN
		IF (WT_GET (FSET, 'WT)) GREATERP GET (GET (NFLARE, 'SET), 'WT) THEN
		   PROG2 (NFLARE_CAR WORD, RESULT_T, W_CDR WORD);
	  IF RESULT THEN

		   %   IF FLARE ALREADY BEING DISCUSSED, DISREGARD ANY 
			VERY WEAK NEW FLARE   %

	     IF NOT (FLARE = 'INIT) AND NOT ((WT_GET (GET (NFLARE, 'SET), 'WT)) GREATERP 1) THEN
		RESULT_NIL
	     ELSE
	     BEGIN
		FLARE_NFLARE;
		WEIGHT_WT;	 %   USED IN COMPUTING RISE IN FEAR   %
		  IF W AND FLAG THEN PUTPROP(W, T, 'USED);
	     END;

	  RETURN (RESULT);
	 END;

	%
DELREF      SCANS THE INPUT SENTENCE FOR THE FIRST DIRECT REFERENCE TO 'SELF'S
	  DELUSIONAL COMPLEX AND RETURNS A FEARFUL REACTION.  IF NO SUCH REFERENCE
	  IS FOUND, NIL IS RETURNED.   %
		%  TOP LEVEL  %

	EXPR  DELREF (FOUND);
	 BEGIN
	  NEW RESULT;

	  IF % FOUND AND %   (FOUND = 'MAFIAEND) THEN
	  BEGIN
	     IF DELFLAG THEN 

			 %   IF DELUSIONS ALREADY BEING DISCUSSED, THEN
			  DISTINGUISH BETWEEN "STRONG" AND "AMBIGUOUS" DELUSIONAL TOPICS
			  IN COMPUTING RISE IN FEAR   %

		IF FOUND AND GET (CAR (FOUND), 'STRONG) THEN FJUMP_0.4
		ELSE FJUMP_0.1
	     ELSE
	     BEGIN
		FJUMP_0.5;
 
			 %   'MAFIA' TOPIC NO LONGEV INDUCES FEARFUL REACTION,
			  SINCE DELUSION DISCUSSION HAS ALREADY BEEN EVOKED   %

		PUTPROP('MAFIA, T, 'USED);

			 %   MODIFY FLARE STRUCTURES TO NOTE THAT 'MAFIA' TOPIC
			  HAS ALREADY BEEN BROUGHT UP   %

		FLMOD ('MAFIASET);
	     END;

		   %   SET (OR KEEP) DELFLAG = T UNLESS 'SELF HAS
			  FINISHED DISCUSSION DELUSIONS   %

	     IF NOT DELEND THEN DELFLAG_T;
	     
		%   RESET SO THAT FLARES OF LOWER PRIORITY THAN THOSE WHICH 
		 MAY HAVE BEEN PREVIOUSLY MENTIONED ARE RECOGNIZED   %

	     FLARE_'INIT;

		   %   FORGET ABOUT RECENTLY DISCUSSED SELF-TOPICS   %

		TOPIC_'DELUSIONS;
		RESULT_NIL;
	  END
	  ELSE
	  IF  (FOUND = 'MAFIAEND  % I.E. AS ALREADY USED DEL WD AND IN INPUT  %
	     ) AND DELEND  THEN RESULT _ CHOOSE 'MAFIASET;

	  RETURN RESULT;
	 END;

	%
DELSTMT	CAUSES THE "NEXT" DELUSION TO BE EXPRESSED   %
		% CALLED BY DELREF, MISCQ, MISCS, FLSTMT  %

	EXPR DELSTMT ();
	 BEGIN
	  NEW STMT;   SPECIAL STMT;

		%   IN WEAK VEVSION, TALK ABOUT RACKETS RATHER THAN MAFIA   %

	  IF WEAK THEN RETURN FLSTMT ('RACKETSET);

	  %   IF 'SELF HAS ALREADY EXPRESSED ALL HIS DELUSIONS, HE REFERS TO 
		PREVIOUSLY MENTIONED ONES UP TO 2 TIMES TOTAL   %

	    IF NOT GET('DELNSET, 'STORY) THEN  DELFLAG_NIL ALSO CHOOSE 'MAFIASET;
	  DELFLAG_T;
	  FLARE_'INIT;
	    TOPIC_'DELUSIONS;

		%   SELECT DELUSION   %

	  STMT_CHOOSEDEL (NIL);

	  %   IF STMT CONTAINS DELUSIONAL FLARE, DELETE AS SUCH   %

	% ***** MAKE SURE DELCHECK IS DONE ON THE OUTPUT SENTENCE  %

	  %   REMEMBER THE DELUSIONAL STATEMENT TO WHICH 'OTHER IS ABOUT TO RESPOND   %

	  RETURN (STMT);
	 END;

	%
FLAREREF    HANDLES FLARE REFERENCES   %
		% TOP LEVEL  %

	EXPR FLAREREF (INP);
	 BEGIN
		%   CHECK FOR NEW FLARE AND RECORD AS "OLD"   %

	  IF CHECKFLARE (INP, LIVEFLARES, NIL) THEN FLRECORD (GET (FLARE, 'SET));

		%   CHECK FOR OLD FLARE   %

	  IF CHECKFLARE (INP, DEADFLARES, T) THEN	%   RESPOND TO FLARE   %
		RETURN (GET (FLARE,'SET));
	 END;


	%
ASCAN	  SCANS 'SELF'S ANSWER FOR MENTION OF FLARE OR MAFIA   %
	% CALLED BY PROMPT, ANSWER--NOW DONE BY NEW PARRY AT END OF OUTPUT%

	EXPR ASCAN (ANS, Q);
	BEGIN
	IF CHECKFLARE (ANS, LIVEFLARES, T) THEN PUTPROP( GET(FLARE,'SET),T,'USED);

	IF 'MAFIA MEMBER ANS THEN  DELFLAG_T 
		ALSO FLARE_'INIT ALSO TOPIC_'DELUSIONS;

	IF DELFLAG THEN DELCHECK(ANS);
	END;

	%
CHOOSE	 SELECTS THE NEXT REPLY FROM THE RELEVANT GROUP  
	  INPUT SHOULD BE THE NAME OF A GROUP OF REPLIES
	  OUTPUT WILL BE A LAMBDA NUMBER  %

	EXPR  CHOOSE(REPLIES);
	BEGIN
	NEW  RESPONSE;
	IF REPLIES THEN RETURN NIL;  CHOSEN_REPLIES;
	  IF NULL RESPONSE_GET (REPLIES, 'IND) THEN
	     RETURN
		IF REPLIES EQ 'EXHAUST THEN ENDE_T ALSO CHOOSE 'BYEFEDUP 
			ELSE  CHOOSE 'EXHAUST;
	  RETURN RESPONSE;
	 END;

	%
CHOOSEDEL   CHOOSES A DELUSIONAL RESPONSE ACCORDING TO "TYPE", WHICH INDICATES
	  WHETHER THE NEXT GENERAL DELUSION IS TO BE SELECTED (TYPE=NUMBER)
	  OR A CERTAIN TYPE OF QUESTION IS TO BE ANSWERED   %
		% CALLED BY DELSTMT, SPECQUES  %

	EXPR CHOOSEDEL (TYPE);
	 BEGIN
	  NEW SEMANT;
		IF SEMANT_GET ('DELNSET, 'STORY) THEN RETURN NIL;
		RETURN CAR SEMANT;
	 END;

	%
DELCHECK    RETURNS ANY NEW DELUSION-EXPRESSIONS FOUND IN INPUT AND DELETES AS SUCH   %
		% CALLED BY DELREF, SPECQUES, DELSTMT  %
	% INP IS INPUTQUES   %

	EXPR DELCHECK (INP);
	 BEGIN
	  NEW WORDS;
 
		%   CHECK FOR STRONG DELUSION-NOUNS AND -VERBS
		    (AT PRESENT THE NOUN-VERB DISTINCTION IS NOT UTILIZED   %

	  IF ( WORDS_MEMBER3 (DELNLIST, INP) )  OR
	     ( WORDS_MEMBER3 (DELVLIST, INP) )  THEN NIL ELSE

		%   CHECK FOR AMBIGUOUS DELUSION WORDS AT HIGH MISTRUST LEVEL  %

	   IF MISTRUST GREATERP 10 AND ( WORDS_MEMBER3 (DELALIST, INP) ) THEN
	      NIL ;
	    IF WORDS  CDR WORDS THEN PUTPROP(CDR WORDS, T, 'USED);
	  IF WORDS AND ATOM WORDS THEN WORDS_ WORDS CONS NIL;
	    IF ('MAFIA MEMBER3 INP % AS ALREADY-USED DELN WD% ) AND WORDS
			THEN WORDS_ 'MAFIAEND;
	    RETURN WORDS;
	 END;

	%
DELETE	 DELETES WORD WD FROM LIST L   %

	EXPR DELETE (WD, L);
	 IF NULL L THEN NIL
	 ELSE
	 IF WD EQUAL CAR (L) THEN CDR (L)
	 ELSE CAR (L) CONS DELETE (WD, CDR (L));

	%
DELETEP	    DELETES WD FROM THE PROP PROPERTY LIST OF L	  %

	EXPR DELETEP (L, WD, PROP);
	PUTPROP (L, DELETE (WD, GET (L, PROP)), PROP);



	%
FIXPTRS     TRANSFERS HIERARCHICAL POINTERS TO NEW FLARE
	  TO NEXT HIGHER FLARE IN PATH   %
		% CALLED BY FLMOD  %

	EXPR FIXPTRS (FLSET);
	BEGIN  NEW CONCEPT;
	FOR CONCEPT IN LIVEFLARES @ DEADFLARES DO
		IF GET (CONCEPT, 'NEXT) EQ FLSET THEN
		  PUTPROP (CONCEPT, GET (FLSET, 'NEXT), 'NEXT);
	 END;

	%
FLRECORD    NOTES MENTION OF FLARE AND RAISES FEAR   %
		% CALLED BY FLAREREF  %

	EXPR FLRECORD (FLSET);
	 BEGIN
	  FLMOD (FLSET);
	  FJUMP_WEIGHT/40.0;

		%   REINITIALIZE SELF-TOPIC INDICATORS   %

	    TOPIC_FLSET;
	 END;

	%
FLMOD       MOVES NEW FLARE FROM "LIVELIST" TO "DEADLIST" AND
	  ADJUSTS FLARE POINTER HIERARCHY   %
		% CALLED BY DELREF, FLRECORD, ASCAN, LEADON  %

	EXPR FLMOD (FLSET);
	 BEGIN
	  LIVEFLARES_DELETE (FLSET, LIVEFLARES);
	  DEADFLARES_(FLSET CONS DEADFLARES);
	  FIXPTRS (FLSET);
	 END;

	%
FLARELEAD DECIDES WHAT TYPE OF "SUSPICIOUSNESS" REPLY IS SUITED
	   TO INTRODUCE THE FLARE CONCEPT   %
		% CALLED BY LEADON  %

EXPR  FLARELEAD (FLSET);

	BEGIN	PUTPROP(FLSET,T,'USED);
	IF GET (FLSET, 'TYPE) EQ 'INSTITUTION THEN
	  WDFLAG _ ( '(THE) @  <CAR (GET (FLSET, 'WORDS))>  )
	 ELSE
			 %   DO NOT TREAT SINGULARS AS A GENERIC TOPIC   %

	  WDFLAG _ (IF CAR (LAST (EXPLODE (FLARE))) EQ 'S THEN <FLARE>
			ELSE <CAR (GET (FLSET, 'WORDS))>   ) ;
	ADDANAPH( < 'THEY CONS (IF CDR WDFLAG THEN CADR WDFLAG ELSE CAR WDFLAG) > ) ;
	ADDANAPH( < 'GOON CONS CARN(GET( FLSET, 'STORY)) > );
	RETURN (CHOOSE 'NEXTFL);
	END;

	%
FLSTMT	 PROVIDES NEXT STATEMENT ABOUT FLARE   %
		% CALLED BY MISCQ, MISCS, ANSVAR, DELSTMT  %

	EXPR FLSTMT (FSET);
	    BEGIN  NEW STMT;

		%   IF REACH 'MAFIASET THRU FLARE HIERARCHY, ENTER DELUSIONAL MODE   %

	  IF (FSET EQ 'MAFIASET) AND NOT DELEND THEN
		DELFLAG_T  ALSO RETURN DELSTMT ();

	    IF STMT_ GET ( FSET, 'STORY) THEN  RETURN CAR STMT;

		 %   GO TO NEXT FLARE TOPIC   %
	  RETURN LEADON (FSET);
	 END   ;
	
	%
LEADON	 %
		% CALLED BY FLSTMT  %

	EXPR LEADON (OLDSET);
	BEGIN  NEW NEWSET;  NEWSET _ GET(OLDSET, 'NEXT);
	  IF NEWSET NEQ 'MAFIASET THEN

		%   RECORD NEW FLARE   %

	  BEGIN
		FLMOD (OLDSET);	% MARK OLD ONE AS BEING USED UP %
	     FLARE_CAR (GET (NEWSET, 'WORDS));
	  END
	  ELSE
	  IF DELEND THEN

		   %   ARRIVE AT 'MAFIASET BUT THROUGH WITH DELUSIONS   %

	     RETURN (PROG2 (FLARE_'INIT, CHOOSE 'FEELER))
	  ELSE
	  IF WEAK OR (FEAR GREATERP 17) OR (ANGER GREATERP 17) OR
	     ((FEAR + ANGER + MISTRUST) GREATERP 40) THEN

		   %   ARRIVED AT 'MAFIASET BUT DOES NOT HAVE DELUSIONS ABOUT
			  MAFIA OR IS UNWILLING TO DISCUSS THEM   %

	     RETURN (CHOOSE 'CHANGESUBJ)
	  ELSE
	  BEGIN
	     DELETE ('MAFIA, DELNLIST);
	     DELFLAG_T;
	     FLARE_'INIT;
		TOPIC_'DELUSIONS;
	  END;

		%   RESPOND WITH NEW FLARE, IF USED THEN NO LEADING STMT   %
		 %  MARK AS USED SO WE DON'T DO FLARELEAD TWICE ON IT  %

	IF GET(NEWSET, 'USED) THEN RETURN FLSTMT(NEWSET) 
	   ELSE  RETURN (FLARELEAD (NEWSET)); 
	 END;

	%
MEMBER1	CHECKS WHETHER ATOMS OR GROUPS OF WORDS IN WLIST ARE PRESENT IN INPUT   %
% ******* NOT USED
	EXPR MEMBER1 (WLIST, SPECIAL INP8);
	 BEGIN
	  NEW FOUND, GROUP;
	  FOR GROUP IN WLIST DO
	     FOUND_IF ATOM (GROUP) THEN GROUP MEMBER INP8
		   ELSE
		EVAL ('AND CONS MAPCAR (FUNCTION (LAMBDA (X); X MEMBER INP8), GROUP))
	     UNTIL FOUND;
	  IF FOUND THEN RETURN GROUP;
	 END;

**** %
	%
MEMBER3		CHECKS IF ATOMS ARE IN INPUT -- INPUT IS A LIST OF DOTTED PAIRS  %

EXPR MEMBER3(WLIST, L);
	BEGIN  NEW WORD, PAIR;
	IF ATOM WLIST THEN WLIST _ <WLIST> ;
	FOR WORD IN WLIST DO	BEGIN
		PAIR _ WORD ASSOC L;
		IF PAIR AND GET(CDR PAIR, 'USED) THEN PAIR_NIL;
		END
	  UNTIL PAIR ;
	RETURN PAIR;
	END;

	%
MISCQ       TRIES TO DETECT AND ANSWER CERTAIN RECOGNIZABLE QUESTIONS.
	  IF IT FAILS, IT TRIES TO DISCERN WHETHER THE QUESTION CONTAINS
	  INTERROGATIVE WORDS REQUIRING A SPECIFIC ANSWER, OR WHETHER IT
	  REQUIRES A GENERAL YES- OR NO-TYPE ANSWER, 
	  AND CALLS FOR AN APPROPRIATE REPLY   %
		% CALLED BY ANSWER  %

	EXPR MISCQ (Q);
	 BEGIN
	  NEW QWORD, ANS, CONCEPT;

		%   CHECK FOR QUESTION ABOUT EXTERNAL WORLD   %

	     IF 'HOW MEMBER Q THEN

			 %   UNIDENTIFIABLE "HOW-TYPE" QUESTION   %

		FOR CONCEPT IN '(MANY MUCH LONG OFTEN) DO
		   IF CONCEPT MEMBER Q THEN ANS_CHOOSE CONCEPT
		UNTIL ANS;
	  IF ANS THEN RETURN (ANS)
	  ELSE

		%   IF QUESTION NOT RECOGNIZED, TRY TO ANSWER ACCORDING TO CONTEXT   %

	  IF ANS _ SPECCONCEPT(Q) THEN RETURN (ANS) 
	  ELSE
	IF (FLARE NEQ 'INIT)  LULL()  ANS_FLSTMT (GET (FLARE,'SET)) THEN RETURN(ANS)
	ELSE
	IF DELFLAG  LULL()   ANS_DELSTMT() THEN RETURN(ANS) 
	ELSE

		%   WH- QUESTIONS   %

	  IF 'WHY MEMBER Q THEN ANS_CHOOSE 'WHY
	  ELSE
	  FOR QWORD IN GET ('QLIST, 'IND) DO
	  (ANS_   IF QWORD MEMBER Q THEN CHOOSE 'UNKNOWN)
	     UNTIL ANS;
	  IF ANS THEN RETURN (ANS)
	  ELSE

		%   MISCELLANEOUS "TELL-" QUESTION   %

	  IF ('TELL MEMBER Q)  THEN RETURN CHOOSE 'KNOWNOTHING
	  ELSE

		%   NO CLUES - ANSWER NONCOMMITTALLY   %

	  RETURN (CHOOSE 'QREPLIES);
	 END;

	%
MISCS	TRIES TO DETECT AND ANSWER CERTAIN RECOGNIZABLE STATEMENTS,
	   MAINLY IMPERATIVES AND EXPECTED EXPRESSIONS   %
		% CALLED BY ANSWER  %

	EXPR MISCS (S);
	BEGIN NEW ANS,FOUND;  FOUND_ 
	 IF ('JUMP MEMBER S) THEN PROG2( ENDE_T, CHOOSE 'EXIT )
	 ELSE
	 IF (CAR (S) EQ 'HI) OR (CAR (S) EQ 'HELLO) OR 
	  CADR S MEMBER '(MORNING AFTERNOON EVENING) THEN CHOOSE 'HELLO
	 ELSE
	 IF (('ALREADY MEMBER S) OR ('BEFORE MEMBER S)) AND
	   (('SAID MEMBER S) OR ('MENTIONED MEMBER S)) THEN
		CHOOSE 'ALREADYSAID
	 ELSE

		%   LOOK AT CONTEXT OF CONVERSATION   %

	 IF ANS _ SPECCONCEPT(S) THEN ANS
	 ELSE
	 IF (FLARE NEQ 'INIT)  LULL()   ANS_ FLSTMT (GET (FLARE, 'SET)) THEN  ANS
	 ELSE
	 IF DELFLAG  LULL()  ANS_ DELSTMT () THEN ANS

		%   NONCOMMITTAL REPLY  %

	 ELSE CHOOSE 'SREPLIES;
	RETURN(FOUND);  END;

	%
MODIFVAR    MODIFIES AFFECT VARIABLES AFTER EACH I-O PAIR   %
		%  TOP LEVEL  %

EXPR MODIFVAR ();
	 BEGIN
		%   ACCOUNT FOR NORMAL DROP IN EACH VARIABLE   %

	  ANGER_ MAX(ANGER-1,ANGER0);
	  HURT_ MAX(HURT-0.5, HURT0);
	  IF DELFLAG THEN   FEAR_ MAX(FEAR-0.1, FEAR0+5)
		   %   ADD 5 TO BASE VALUE OF FEAR IF DELUSIONS UNDER DISCUSSION   %
	  ELSE
	  IF FLARE NEQ 'INIT THEN FEAR_ MAX(FEAR-0.2, FEAR0+3)
		   %   ADD 3 TO BASE VALUE OF FEAR IF FLARES UNDER DISCUSSION   %

	  ELSE FEAR_ MAX(FEAR-0.3, FEAR0);
	  MISTRUST_ MAX(MISTRUST-0.05, MISTRUST0);
      IF TRACEV THEN  PRINTVARS();
	FJUMP_NIL; AJUMP_NIL; HJUMP_NIL;
	 END;


	%
RAISE	RAISES LEVEL OF RELEVANT AFFECT VARIABLES;
	   REDUCE JUMP IF IN WEAK VERSION   %
		% CALLED BY MODIFVAR  %


EXPR MAX(L,M);  IF LM THEN L ELSE M;

END. EOF
COMMENT    VALID 00007 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN
C00005 00003	% DISKREAD, CARN, LAMBDANAME, ALPHANAME    %
C00008 00004	%	BEL AND ENG TAKE AN SEXPR FROM THE MEMORY FILE (PDAT) AND LINK
C00011 00005		%-- REPLYR, ANTHEN, EXPRESS, SELSENTENCE, SAY ------%
C00017 00006	% ANAPHORA ROUTINES, ADDANAPH  %
C00023 00007	%  READING INDEXES,   SETUPSTL    %
C00026 ENDMK
C;

BEGIN

% MASTER LIST OF GLOBAL VARIABLES  %

%			*** GLOBAL VARIABLES***

!ANAPHLIST	is the current list of anaphora dotted-pairs.
!ANAPHLISTOLD	is the previous list of anaphora dotted-pairs.
!ANAPHLISTNEW	is the next list of anaphora dotted-pairs to go into anaphlist
!ALLANAPHS	is a list of lists - ((who they he)(he who)(they who)....)
!CLIST		is a pointer to the first element of the conversation list.
!CLAST		is a pointer to the last element of the conversation list.
!LASTANDTHEN	is either IN or OUT as the last ANDTHEN processed
!LASTIN		points to atom under which is stored the last semantic unit
		inputed by the doctor.
!LASTOUT	points to the atom under which is stored the last semantic
		unit outputed by Parry.

!ERROR		contains a list of errors made
!EXHAUST	is true if a set of responses is exhausted and the exhaust responses are to be used
		  it is set by SELECTSENTENCE  and used at the end of REACT2
!OUTPUT		is the output of parry, to be sent whereever
!LASTOUTPUT	is the -name of the last output

INPUTQUES	is a list of dotted pairs from the pattern matcher to the memory
			each pair is (canonical 5-letter atom . input word)

         %


SPECIAL ?!ANAPHLIST,?!ANAPHLISTNEW,?!ANAPHLISTOLD,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LASTANDTHEN,
	?!OUTPUT,?!LASTOUTPUT, ?!EXHAUST, ?!ERROR,

	INPUTQUES,SSENT,DOSPELL,NEXTCHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOCNAMEFLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVEFILE, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
	THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX;


% DISKREAD, CARN, LAMBDANAME, ALPHANAME    %

EXPR LAMBDANAME(L);  EQUAL (CHRVAL (L), 8); % RETURNS T IF THE FIRST CHAR OF L IS  %

EXPR ALPHANAME(L);  EQUAL (CHRVAL (L), 2);  % RETURNS T IF THE FIRST CHAR OF L IS  %

% READLAMBDA ATTEMPTS TO READ IN A SEMANTIC FUNCTION (FRAME) FROM THE MEMORY
	GIVEN A LAMBDA NUMBER AS INPUT %
EXPR READLAMBDA(A);

	BEGIN IF LAMBDANAME(A) THEN RETURN NIL;
	IF DISKREAD(A) THEN RETURN T;
	ERROR("BAD DISKREAD",A);
	END;

%	 DOES DISKREAD2 PROTECTED BY AN ERRSET;
	 ERRORS MAY OCCUR IF THE MEMORY FILE HAS MISMATCHED PARENS  %
EXPR DISKREAD(NAME); 

	BEGIN NEW A;  RETURN
	IF A_ERRSET( DISKREAD2(NAME), NIL) THEN ERROR("ERROR IN DISKREAD", NAME)
	  ALSO NIL ELSE A;
	END;

%	GIVEN A  OR  NUMBER AS INPUT, READS IN ONE DISK SEXPR 
	IF THE SEXPR IS ALREADY IN CORE, IT JUST RETURNS T
	OTHERWISE IT CALLS BEL OR ENG TO PROPERLY LINK ALL THE INFO INTO THE MEMORY %
	
EXPR DISKREAD2(NAME);

	BEGIN NEW A,B,CHARNO;
	IF GET(NAME,'INCORE) THEN RETURN T;
	IF GET('DSKLOC,'SUBR) THEN A_DSKLOC(NAME);  % GET THE CHAR NO OF THE SEXPR %
	IF A THEN RETURN NIL;  % NOT THERE %
	CHARNO_A;
	 % CHARNO IS THE CHARACTER NUMBER IN THE FILE THAT THE SEXPR NAME BEGINS ON %
	 % IF A RECNO IS NEEDED, IT IS CHARNO/OCTAL 1200 + 1 (FIRST RECORD IS REC 1 %

	CHANSAVE_INC(NIL,NIL);
	INIT();		% INITIALIZE THE READ CHANNEL FOR THE MEMORY FILE %
	INC(INCHAN,NIL);
	CHSETI(INCHAN,CHARNO);  % SET THE INPUT POINTER TO THE CORRECT SEXPR %
	B_READ();
	INC(CHANSAVE,NIL);

	IF B THEN PUTPROP(NAME,T,'INCORE);
	IF B='?#B THEN BEL( B) ELSE IF B='?#E THEN ENG( B);  % LINK UP IN MEMORY %
	RETURN B;
	END;

EXPR CARN(L);  IF ATOM L THEN L ELSE L;  % RETURNS CAR OF A LIST %


%	BEL AND ENG TAKE AN SEXPR FROM THE MEMORY FILE (PDAT) AND LINK
	THE INFORMATION IN THE MEMORY IN THE RIGHT WAY %
	% READ IN SEMANTS AND SURFACE AND STORE UNDER LAMBDAS AND ALPHAS %
	% X IS THE LIST WITHOUT THE B OR E %
	%   X LOOKS LIKE:  ( 17 100 (LOC I HOSP) LIT (...)  ) %

EXPR BEL(X);
	BEGIN NEW NAME,TRUTH,UNIT;
	NAME_ CAR X; TRUTH_ CADR X; UNIT_ CADDR X;
	IF NULL X OR NULL X OR NULL X OR NUMBERP(TRUTH)
		THEN ERROR("B BAD INPUT",X) ALSO RETURN NIL;
	IF GET(NAME,'BONDVALUE) THEN ERROR("BAD INPUT-DOUBLE ENTRY", NAME);
	PUTPROP(NAME,UNIT,'BONDVALUE);
	X_ CDR X;
	WHILE X_ CDDR X DO   % PUT THEM ON THE PROPERTY LIST OF THE  NAME %
	  IF ATOM CAR X OR NULL X THEN ERROR("BAD INPUT ", NAME) ALSO RETURN NIL
		ELSE  PUTPROP(NAME,CADR X,CAR X);
	RETURN NAME;
	END;

	%------------------------------------------------------------%
EXPR ENG(X);
	BEGIN NEW UNIT,ERROR; 
	IF NULL X OR NULL X OR NULL X 
		THEN ERROR("E BAD INPUT", X) ALSO RETURN NIL;
	UNIT_ CAR X;
	IF GET(UNIT,'NORMAL) 
 GET(UNIT,'EMBQ) 
		THEN ERROR("BAD INPUT-DOUBLE ENTRY", UNIT);
	X_ CDR X;
	IF CAR X='ANAPH THEN  X_CDR X 	% PUT ANAPH ON PROPERTY LIST %
	   ALSO PUTPROP(UNIT, CAR X, 'ANAPH)	   
	   ALSO X_CDR X;
	IF CAR X='EXH THEN PUTPROP(UNIT, CADR X, CAR X)
		ALSO X_CDDR X;

	DO BEGIN  % PUT SENTENCES ON THE PROPERTY LIST %
	   IF (NULL X) OR (NULL X) OR (ATOM X) OR (ATOM X) 
		THEN ERROR("E BAD INPUT",UNIT) 	ALSO ERROR_T	ALSO RETURN NIL;
	   PUTPROP(UNIT,CADR X,CAR X);
	   END
	UNTIL ERROR OR  X_ CDDR X;
	IF GET(UNIT,'NORMAL) THEN ERROR("NO NORMAL SENTS",UNIT);
	RETURN UNIT;
	END;

	%-- REPLYR, ANTHEN, EXPRESS, SELSENTENCE, SAY ------%

% REPLYR IS THE FUNCTION WHICH SELECTS AND EXPRESSES AN OUTPUT SENTENCE
	AFTER THE PROPER  NUMBER HAS BEEN DETERMINED BY THE MEMORY.
	A SENTENCE GENERATOR WOULD REPLACE THIS FUNCTION %
% REPLYR  ADDS TO CONVERSATION LIST, AND EXPRESSES %
	% SEMANT IS  NAME, TYPE=D OR Q, CLASS IS RESP   INTO EXPRESS %
	% CALLS  ANDTHEN, EXPRESS %

EXPR REPLYR(SEMANT);

	BEGIN   NEW A;
	IF SEMANT THEN ERROR(NIL,"NOSEMANT IN REPLYR")  ALSO RETURN NIL;
	ANDTHEN(<'OUT,SEMANT>);
	A_EXPRESS(SEMANT,'RESP);
	?!OUTPUT _ IF A  WDFLAG THEN (A @ LASTWORD(WDFLAG)) ELSE A;
	WDFLAG_NIL;  RETURN ?!OUTPUT;
	END;

	%-------------------------------------------------------------------%
% ANDTHEN PUTS THING ON THE CONVERSATION LIST %
	% INPUT THING IS A LIST OF INFORMATION ABOUT THE CURRENT SEMANTS %

EXPR ANDTHEN(THING);

	BEGIN NEW A;
	  % IF THE LAST THING ADDED TO THE CONVERSATION LIST, THEN DONT DO THIS ONE %
	IF ?!LASTANDTHEN = THING THEN RETURN NIL; 
	?!CLIST_ THING CONS ?!CLIST;
	IF THING = 'IN THEN ?!LASTIN_A  ELSE  IF THING = 'OUT THEN ?!LASTOUT_A;
	?!LASTANDTHEN_THING;
	RETURN ?!CLIST;
	END;

	%-------------------------------------------------------------------%
	%--EXPRESS -------------%
	% SAYS SEMANT USING CLASS, HAVING THE SUBCL AS THE NECESSARY SLOT, IN MODE %
	%  SEMANT = 17, CLASS = SQR OR LIT, 
	      SUBCL = HOSPITAL OR NIL; APPLIES TO SQR, MODE = NORMAL OR EMBD OR EMBQ %
	%    SUBCL IS THE NAME OF THE SLOT WHICH HAD THE QMARK %

EXPR EXPRESS(SEMANT,CLASS);

	BEGIN NEW A,BOND,C,K;
	DISKREAD(SEMANT);
	A_ GET(SEMANT,CLASS);
	BOND_ GET(SEMANT,'BONDVALUE);

	  % USE PREDICATE FOR FINDING CLASS %
	IF (NULL A)  BOND   (C_GET(BOND,'UNIT))    DISKREAD(C)
	   THEN  A_ GET(C,CLASS) ;

	  %  ONLY QUIT IF THERE IS NO RESP   %
	IF NULL A  NULL ( A_GET(SEMANT,'RESP) )
	   THEN ERROR("NO CLASS " CAT CLASS, SEMANT)
	   ALSO RETURN NIL;

	  %SET UP ANAPHS FOR NEXT INPUT  %
	IF K_GET(SEMANT,'ANAPH) THEN  ADDANAPH(K);

	A_ SELSENTENCE(A);
	RETURN  IF A THEN  SAY(A,CDR BOND);
	END;

	%-------------------------------------------------------------------%
	%-  SELSENTENCE  ---------------%
	% SELECTS AND RETURNS A  SENTENCE (AN ), ADDING TO THE ANAPHORA LIST%
	% INPUT UNIT IS AN  NUMBER -- LIKE 17, CLASS IS LIKE NORMAL %
	% DELETES THE SENTENCE FROM MEMORY  %

	% CALLS ADDANAPH %

EXPR SELSENTENCE(UNIT);

	BEGIN NEW SENTS,S,A,ANAPH,CLASS;	CLASS_'NORMAL;
	IF DISKREAD(UNIT) THEN RETURN NIL;	% READ FROM DISK INTO MEMORY %

	A_GET(UNIT,CLASS);  % USE NORMAL REPONSES AS DEFAULT %
	ANAPH_GET(UNIT,'ANAPH);
	SENTS_ A;
	IF NULL SENTS THEN ?!EXHAUST_T ALSO RETURN NIL;  % IF NO SENTS THEN SET THE EXHAUST FLAG %

	%  IF EXH IS T, THEN TAKE THE SENTENCES IN ORDER, OTHERWISE CHOOSE RANDOMLY %
	IF GET(UNIT,'EXH) THEN A_1 ELSE A_RANDOM(LENGTH SENTS);
	S_SENTS[A];
	PUTPROP(UNIT, DELETEN(SENTS,A), CLASS);		% DELETE THE SENTENCE FROM MEMORY %

	IF ATOM ANAPH  ANAPH THEN ANAPH_ EVAL(ANAPH);
	ADDANAPH(ANAPH);	% ADD ANAPH FOR THIS SENTENCE %
	RETURN S;
	END;

%	RETURNS THE LIST L MINUS THE NTH ELEMENT %

EXPR DELETEN(L,N);  IF N=1 THEN L ELSE L CONS DELETEN(L, N-1);

% SAY  TAKES A LIST OF ENGLISH OR ARGUMENTS TO BE FILLED AND PRODUCES AN ENGLISH SENTENCE %

	% L MAY BE A LIST OF ENGLISH WORDS REPRESENTING THE OUTPUT SENTENCE %
	% L MAY ALSO BE A LIST OF ONE ELEMENT, WHICH IS A LIST OF ARGUMENTS TO EXPRESS %
	% THE FIRST ARG SELECTS FROM ARGS WHICH  NUMBER TO TAKE %
	% CALLS EXPRESS  %

EXPR SAY(L,ARGS);
	IF ATOM L  NUMBERP CAAR L THEN EXPRESS( ARGS[CAAR L], CADAR L) ELSE L;

% ANAPHORA ROUTINES, ADDANAPH  %

% ADDANAPH ADDS STUFF FROM ANAPHS FROM  ON TO GLOBAL ANAPHORA LIST %

EXPR ADDANAPH(L);

	BEGIN NEW A;
	FOR NEW I IN L DO
	   IF A_ ASSOC(CAR I,?!ANAPHLISTNEW)
		% IF ALREADY ON ANAPH LIST THEN REPLACE %
	   THEN RPLACD(A,CDR I)
	   ELSE ?!ANAPHLISTNEW _ I CONS ?!ANAPHLISTNEW ;
	RETURN ?!ANAPHLISTNEW;
	END;

EXPR RANDOM(N);  1;  % GETS REPLACE BY RANDOM.LAP, LOADED IN AFTER THIS FUNCTION %

% SPECFN CALLS THE SPECIAL FN IF THERE IS ONE %

EXPR SPECFN(STRUC);
	BEGIN NEW A, NAME;
	NAME_ GET( STRUC, 'UNIT);	IF NAME THEN RETURN NIL;  % IE, NOT AN ANAPH %
	IF MEMBER ( NAME, '(GOON ELAB WHO WHAT)) THEN   % CALL THE SPEC FN PROTECTED BY ERRSET %
	  ( IF ATOM A_ERRSET( EVAL< NAME, NIL,T >, NIL) THEN ERROR("SPECFN",NAME)
		ALSO A_NIL  ELSE A_A )
	  ALSO RETURN(IF A THEN A ELSE 'QUIT);
	% QUIT MEANS THERE WAS AN ANAPHORA, BUT WE DIDNT HAVE THE POINTER FOR IT IN MEMORY %
	IF ASSOC(NAME, ?!ALLANAPHS ) 
		THEN A_ GENL( STRUC, T, NAME ) 
		ALSO RETURN (IF A THEN A ELSE 'QUIT );
	END;

% GOON, ELAB, WHO, WHAT
	TRY TO GET THE ANAPHORA, ELSE USE A STORY %

EXPR GOON(L,F);

	BEGIN NEW A;
	IF A THEN A_GETANAPH('GOON);
	IF A THEN A_GETSTORY();
	IF A AND F THEN ANDTHEN(<'IN,GET('GOON,'UNIT)>);
	RETURN A;
	END;

EXPR ELAB(L,F);

	BEGIN NEW A; 
	IF A THEN A_GETANAPH('ELAB);
	IF A THEN A_GETSTORY();
	IF A AND F THEN A_GOON(L,NIL);
	IF A AND F THEN ANDTHEN(<'IN,GET('ELAB,'UNIT)>);
	RETURN A;
	END;

EXPR GENL(L,F,ANAPH);		% TRY THE ANAPH, ELSE TRY GOON  %

	BEGIN NEW A; A_NIL;
	IF A THEN A_GETANAPH(ANAPH);
	IF A THEN A_GOON(L,NIL);
	RETURN A;
	END;

% GETSTORY GETS THE NEXT LINE IN WHATEVER STORY IS BEING TALKED ABOUT %
	%  IT GETS THE TOPIC EITHER FROM THE CURRENT INPUT, OR FROM THE PREVIOUS INPUT %
	%  IT THEN LOCATES THE STORY NAME, AND SELECTS THE NEXT ONE WHICH HASNT BEEN USED %

EXPR GETSTORY();

	BEGIN NEW B,C; 	%  TOPIC %
	IF (B_CARN GET(REACTTO, 'TOPIC) )     % TRY CURRENT INPUT TOPIC %
	%	ALREADY A SETNAME		GET CANONICAL WD AND SET  %
	 (IF GET(B,'WORDS) THEN T ELSE (B_CARN SYNNYM(B))  (B_GET(B,'SET)) )
	   THEN C_B;
	IF C  (B_CARN GET(?!LASTOUTPUT, 'TOPIC) ) 	% TRY PREVIOUS INPUT TOPIC %
	%	ALREADY A SETNAME		GET CANONICAL WD AND SET  %
	 (IF GET(B,'WORDS) THEN T ELSE (B_CARN SYNNYM(B))  (B_GET(B,'SET)) )
	   THEN C_B;
	IF C THEN RETURN NIL;	% NO STORY FROM EITHER %
	IF B_GET(C,'STORY) 
	 THEN  DELETEP(C,CARN B, 'STORY)  ALSO RETURN CARN B;
	IF MEMQ(C,GET('FLARELIST,'SETS)) THEN RETURN FLSTMT(C);
	END;

% GETANAPH TAKES AN ANAPH NAME AS INPUT (EG THEY, GOON, WHO) AND LOOKS
	ON THE CURRENT ANAPH LIST IF ITS NOT NULL, ELSE LOOKS ON THE OLD ANAPHLIST.
	IT ALSO USES THE TRANSLATIONS OF ANAPHORA FOUND ON ?!ALLANAPHS %

EXPR GETANAPH(L);

	BEGIN NEW ANA,B,ALIST;
	ALIST_ IF ?!ANAPHLIST THEN ?!ANAPHLIST ELSE ?!ANAPHLISTOLD;
	 % GET ALL ANAPHS WITH APPROX THE SAME MEANING %
	ANA_ASSOC(L,?!ALLANAPHS);
	FOR NEW J IN  ANA DO  B_ASSOC(J,ALIST)
		UNTIL B;
	IF B  CDR B  ATOM CDR B THEN RETURN CDR B;
	IF L='THEY  B_ASSOC(L,?!ANAPHLISTOLD) THEN RETURN CDR B;
	END;

EXPR WHO(L,F);

	BEGIN NEW A;  A_NIL;
	A_GETANAPH('WHO);
	IF LAMBDANAME(A) THEN RETURN A ELSE A_NIL;
	IF A THEN A_GOON(L,NIL);
	RETURN A;
	END;

EXPR WHAT(L,F);

	BEGIN NEW A;
	A_GETANAPH('WHAT);
	IF L AND GET(A,'BONDVALUE)=L THEN T ELSE A_NIL;
	IF A THEN A_GOON(L,T);
	RETURN A;
	END;

% REPETITION RETURNS T IF SEM ( A  NUMBER ) HAS BEEN USED BEFORE AS TYPE (IN OR OUT) %

EXPR REPETITION(SEM,TYPE);

	BEGIN NEW PTR, FOUND;
	PTR _ ?!CLIST;
	WHILE PTR AND FOUND DO
		IF ( PTR = TYPE) AND ( PTR = SEM) AND (PTR  ?!LASTIN) 
		THEN FOUND_T 	ELSE PTR _ CDR PTR;
	RETURN FOUND;
	END;

%  READING INDEXES,   SETUPSTL    %
%   THESE ROUTINES READ IN DATA FILES AND INTERCONNECT THEM %

% SETUPSTL  SETS UP STORY AND STORYLIST POINTERS %

EXPR SETUPSTL();	% MUST BE DONE AFTER INITIALIZE IN OPAR3  %

	BEGIN NEW A,B,C;  C_T;
	A_ FOR NEW I IN GET('SENSITIVELIST,'SETS) COLLECT GET(I,'WORDS);
	PUTPROP('SENSITIVELIST, A, 'WORDS);
	A_ 'DELNSET CONS ( GET('FLARELIST, 'SETS) @ GET('SETLIST, 'SETS) ) ;

	FOR NEW I IN A DO	% I IS THE NAME OF A FLARESET %
	  FOR NEW J IN GET(I, 'STORY)  DO   BEGIN  % J IS A -NAME %
		B_J;
		IF B THEN PUTPROP(B, I, 'STORYNAME) ELSE C_NIL ALSO PRINT(J);
		END;
	RETURN (IF C THEN '(SET UP OK) ELSE '(SET UP BAD) );
	END;

EXPR READBONDS(FILENAME);	% THIS READS IN A FILE(PDATB) CONTAINING USEFUL INFORMATION ABOUT PDAT %

	BEGIN NEW A;
	SELECTINPUT(NIL, FILENAME);
	WHILE ATOM(A_ERRSET(READDATA()) ) AND A_A DO
		EVAL A;
	PRINTSTR( FILENAME CAT " read in.");
	SELECTINPUT(NIL, NIL);
	END;

EXPR CHANGEL(FILENAME);	
	% THIS READS IN A FILE OF TEMPORARY  NUMBER CHANGES TO MAKE THE PATTERN MATCHER
		AND MEMORY COMPATIBLE %
	BEGIN NEW A;
	SELECTINPUT(NIL,FILENAME);
	WHILE ATOM(A_ERRSET(READDATA()) ) AND A_A DO
		PUTPROP(A, A, 'MEQV);
	PRINTSTR( FILENAME CAT " read in.");
	END;

END.  EOF 
COMMENT    VALID 00007 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN
C00005 00003	%  INITF, FLARESENT, DELNSENT  %
C00011 00004	% *** RAISE, PRINTVARS, WPRINTVARS %
C00014 00005	% SKEYWD, KEYWD, SILENCER, EXHAUSTER, SWEARER, ENDROUTINE  %
C00018 00006	% Q, CANONA, MEMFIND, INITPARAMS, STRINGATE, ANALYZE	%
C00025 00007	%	GETDATE, GETTIME, GETDOCNAME	%
C00033 ENDMK
C;

BEGIN

% MASTER LIST OF GLOBAL VARIABLES  %

%			*** GLOBAL VARIABLES***

!ANAPHLIST	is the current list of anaphora dotted-pairs.
!ANAPHLISTOLD	is the previous list of anaphora dotted-pairs.
!ALLANAPHS	is a list of lists - ((who they he)(he who)(they who)....)
!CLIST		is a pointer to the first element of the conversation list.
!CLAST		is a pointer to the last element of the conversation list.
!LASTANDTHEN	is either IN or OUT as the last ANDTHEN processed
!LASTIN		points to atom under which is stored the last semantic unit
		inputed by the doctor.
!LASTOUT	points to the atom under which is stored the last semantic
		unit outputed by Parry.

!ERROR		contains a list of errors made
!EXHAUST	is true if a set of responses is exhausted and the exhaust responses are to be used
		  it is set by SELECTSENTENCE  and used at the end of REACT2
!OUTPUT		is the output of parry, to be sent whereever
!LASTOUTPUT	is the -name of the last output

INPUTQUES	is a list of dotted pairs from the pattern matcher to the memory
			each pair is (canonical 5-letter atom . input word)

         %


SPECIAL ?!ANAPHLIST,?!ANAPHLISTOLD,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LASTANDTHEN,
	?!OUTPUT,?!LASTOUTPUT, ?!EXHAUST, ?!ERROR, WDFLAG, REACTTO, ERRNAME,
	STYPE, STOPIC, TRACEMEM, ENDE,

	INPUTQUES,SSENT,DOSPELL,NEXTCHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOCNAMEFLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVEFILE, SAVEDUMP, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

SPECIAL EXPERIMENT;

%  INITF, FLARESENT, DELNSENT  %

NEW     ?!ANAPHLIST,?!ANAPHLISTOLD,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LASTANDTHEN,
	?!OUTPUT,?!LASTOUTPUT, ?!EXHAUST, ?!ERROR, WDFLAG, REACTTO, ERRNAME,
	STYPE, STOPIC, TRACEMEM, ENDE,

	INPUTQUES,SSENT,DOSPELL,NEXTCHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOCNAMEFLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVEFILE, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

 
DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
 THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX, NUMED PREFIX, CHRVAL PREFIX;


EXPR INITF();	% INITIALIZES GLOBAL VARIABLES %

	BEGIN  EXHAUSTNO_SILENCENO_SWEARNO_0;

	?!ALLANAPHS_ '( (WHO   % THEY HE SHE WE %  )
			(THEY  HE SHE WE)
			(HE )  (SHE )  (WE )
			(THERE WHERE)  (HERE THERE WHERE)  (WHERE)
			(THEN WHEN)  (WHEN HOWLONG)	(HOWLONG)
			(IT) (WHAT) (YOUDO) (THEYDO) (HOWMUCH) (HOWKNOW)
			(GOON) (ELAB) (WHY) (HOW) (YES) (NO)  ) ;
	END;

EXPR FLARESENT();
	% FLARESENT IS A SEMANTIC FUNCTION CALLED BY A FLARE INPUT %
	% IT CALLS THE OLD PARRY ROUTINES FOR FLARE TOPICS %

	BEGIN  	  % DEACTIVATE NEW FLARE WORDS AND COMPUTE FJUMP  %
	FLAREREF(INPUTQUES); 	RETURN NIL;
	END;

EXPR DELNSENT();
	% FLARESENT IS A SEMANTIC FUNCTION CALLED BY A FLARE INPUT %
	% IT CALLS THE OLD PARRY ROUTINES FOR FLARE TOPICS %

	BEGIN NEW A,B;
	A_DELCHECK(INPUTQUES); 	B_DELREF(A);
	RETURN B;
	END;


% *** RAISE, PRINTVARS, WPRINTVARS %
EXPR RAISE ();
	 BEGIN
	  IF HJUMP THEN  BEGIN
		IF WEAK THEN HJUMP_0.5 * HJUMP;
		HURT _ (HURT + HJUMP * (20 - HURT));
		MISTRUST _ (MISTRUST + (0.5 * HJUMP) * (20 - MISTRUST));
		MISTRUST0_MISTRUST0 + 0.1 * HJUMP * (20 - MISTRUST0);
		HURT0_MAX(HURT/2, HURT0);
			 % SET HIGHER FLOOR ON FEAR AND ANGER DUE TO HURT %
		FEAR0_MAX(FEAR0, HURT0/2); FEAR_MAX(FEAR,FEAR0);
		ANGER0_MAX(ANGER0, HURT0/2); ANGER_MAX(ANGER,ANGER0);
	  END;
	  IF FJUMP THEN  BEGIN
		FJUMP_FJUMP + HURT / 50;	% MAKES FEAR VOLATILE ON HIGH HURT %
		IF WEAK THEN FJUMP_0.3 * FJUMP;
		FEAR _ (FEAR + FJUMP * (20 - FEAR));
		MISTRUST _ (MISTRUST + (0.5 * FJUMP) * (20 - MISTRUST));
		MISTRUST0_MISTRUST0 + 0.1 * FJUMP * (20 - MISTRUST0);
	  END;
	  IF AJUMP THEN  BEGIN
		AJUMP_AJUMP + HURT / 50;	% MAKES ANGER VOLATILE ON HIGH HURT %
		IF WEAK THEN AJUMP_0.7 * AJUMP;
		ANGER _ (ANGER + AJUMP * (20 - ANGER));
		MISTRUST _ (MISTRUST + (0.5 * AJUMP) * (20 - MISTRUST));
		MISTRUST0_MISTRUST0 + 0.1 * AJUMP * (20 - MISTRUST0);
	  END;
	 END ;


EXPR NUMED(N);  % 0.00  N  99.99, RETURNS STRING "12.34" %
	NEDIT( FIX( N*100+0.5));

% SKEYWD, KEYWD, SILENCER, EXHAUSTER, SWEARER, ENDROUTINE  %

% SKEYWD CHECKS FOR FLARE AND DELN WORDS USING OLD PARRY ROUTINES %
% SKEYWD AND KEYWD ARE ONLY USED WHEN NOTHING IS RECOGNIZED BY THE PATTERN MATCHER %

EXPR SKEYWD (TYPE, SENT);

	BEGIN  NEW FOUND,R;
	% CHECK FOR DELN OR FLARE WDS IN INPUT %
	IF DELFLAG  R_DELCHECK (SENT) THEN
		IF R_DELREF (R) THEN FOUND_R ELSE FOUND_ DELSTMT ();
	IF FOUND  (FLARE'INIT)  R_ FLAREREF (SENT) THEN FOUND_ FLSTMT (R);
	IF FOUND THEN FOUND_KEYWD(SENT, SETLIST);
	IF FOUND THEN FOUND_SPECCONCEPT(NIL);
	RETURN (FOUND);
	END;

% KEYWD CHECKS FOR KEY WORDS FROM SPECIAL TOPICS %
% KEYWD IS ONLY USED IF THE PATTERN MATCHER FOUND NOTHING, AND THE NEW KEYWORD
	IS ON THE SAME TOPIC AS THE PREVIOUS INPUT %

EXPR KEYWD(INP, SETLIST);

	BEGIN NEW SET, RESULT,A;
	FOR SET IN GET('SETLIST, 'SETS)  DO  BEGIN
		FOR NEW WORD IN GET(SET, 'WORDS) DO 
		   IF ASSOC(WORD, INP)  THEN RESULT_SET
		UNTIL RESULT;
	END  UNTIL RESULT;
	IF RESULT THEN RETURN NIL; SET_RESULT;
	IF RESULT_GET(RESULT, 'STORY) THEN RETURN NIL;
	A_ IF STOPIC='ANAPH THEN OLDTOPIC ELSE STOPIC;
	IF SYNNYM(A)=SYNNYM(SET) THEN RETURN(  RESULT);
	% ONLY RETURN ANSWER IF TOPIC SAME AS PREVIOUS TOPIC %
	END;

EXPR SILENCER();	% SEMANTIC FUNCTION CALLED BY SILENCE INPUT %

	BEGIN  SILENCENO_SILENCENO+1; IF SILENCENO=11 THEN ENDE_T;
	AJUMP_0.1;	RETURN NIL;
	END;

EXPR EXHAUSTER();	% SEMANTIC FUNCTION CALLED BY EXHAUST OUTPUT SELECTION %

	BEGIN  EXHAUSTNO_EXHAUSTNO+1; AJUMP_0.15;
	IF EXHAUSTNO=9 THEN ENDE_T ALSO RETURN CHOOSE 'MADEXIT;
	END;

EXPR SWEARER();		% SEMANTIC FUNCTION CALLED BY SWEAR INPUT %

	BEGIN  SWEARNO_SWEARNO+1;  AJUMP_0.3;
	IF SWEARNO=5  THEN ENDE_T ALSO RETURN CHOOSE 'MADEXIT;
	END;

EXPR ENDROUTINE();	% SEMANTIC FUNCTION CALLED BY EXIT OUTPUT SELECTION %

	BEGIN	ENDE_T;
	IF FEAR18.4  (DELFLAG 
 FLARE'INIT) THEN AJUMP_0.1 
	  ALSO RETURN CHOOSE 'BYEOFF;
	RETURN CHOOSE 'BYE;
	END;

% Q, CANONA, MEMFIND, INITPARAMS, STRINGATE, ANALYZE	%

EXPR Q(L);	% RETURNS T IF THE INPUT L IS A QUESTION %

	IF L THEN 'D ELSE 	IF CAR LAST L = 'QM THEN 'Q ELSE
	IF (CAR L) MEMBER '(IS ARE WAS WERE AM DID DOES DO HAVE HAS HAD
		WHO WHOM WHAT WHEN WHERE HOW WHY CAN COULD WOULD SHOULD WILL MAY )
	THEN 'Q ELSE 'D ;

% CANONIZE CANONIZES L USING THE PATTERN MATCHER %
	% USED FOR RUNNING THE OUTPUT BACK THRU AN INPUT SCAN FOR DELUSIONAL WORDS %
EXPR CANONA(L);
	BEGIN NEW A,B,C;  A_INPUTQUES; C_DOSPELL;  DOSPELL_NIL;
	B_CANONIZE(IF L  ATOM L THEN L ELSE L);  B_INPUTQUES;
	DOSPELL_C; INPUTQUES_A;  RETURN B;
	END;

EXPR MEMFIND(STRUC);	STRUC;

EXPR INITPARAMS();	% INITIALIZED PROGRAM PARAMETERS %

	BEGIN NEW A;  SPECIAL NOTSAVED; EOF_PERCENT;
	TERPRI NIL;
	PRINTSTR ("END INPUT PARAMETERS WITH CARRIAGE RETURN OR ALTMODE");
	TERPRI NIL;
	PRINTSTR ("PRINT NON VERBAL FEATURE? [Y,N]");
	A_READ();
	IF A=NOTSAVED OR A='FILE THEN SUPPRESS_NIL 
	  ALSO ANGER_ANGER0_FEAR_FEAR0_MISTRUST_MISTRUST0_HURT_HURT0_0
	  ALSO TRACEV_T ALSO SAVEFILE_NIL ALSO INITFN NIL 
	  ALSO ( PRINTSTR("WINDOWS? ") ANDDO WINDOWS_(READ()='Y) )
	  ALSO (IF A='FILE THEN PRINTSTR("FILE=") ALSO A_READ() 
		  ALSO INPUTFILE_A ALSO BILLP() )
	  ALSO TERPRI NIL
	  ALSO RETURN NIL;
	EXPERIMENT_A;

	A_CHRVAL A;
	SUPPRESS_  ( (A=CHRVAL 'Y) OR (A=CHRVAL 'y) ) ;
	TERPRI NIL;
	PRINTSTR ("VERSION [WEAK, MILD, STRONG]");
	A_ CHRVAL READ();
	IF (A=CHRVAL 'W) OR (A=CHRVAL 'w)
	   THEN WEAK_T ALSO VERSION_'WEAK
	ELSE  ANGER_ANGER0_FEAR_FEAR0_MISTRUST_MISTRUST0_HURT_HURT0_
	  (IF (A=CHRVAL 'S) OR (A=CHRVAL 's) THEN VERSION_'STRONG ALSO 5
		ELSE VERSION_'MILD ALSO 0);

	IF DDJOB()  SUMEX
	  THEN PRINTSTR TERPRI ("DISPLAY WINDOWS? [Y,N] ") 
	  ALSO A_CHRVAL READ() 
	  ALSO WINDOWS_ ( (A=CHRVAL 'Y) OR (A=CHRVAL 'y) );

	IF TRACEVFLAG  WINDOWS 
	  THEN PRINTSTR TERPRI ("TRACE INTERNAL PROCESSES? [Y,N] ")
	  ALSO A_CHRVAL READ()
	  ALSO (IF (A=CHRVAL 'Y) OR (A=CHRVAL 'y) THEN TRACEV_'ALL)
	  ALSO (IF TRACEV THEN PRINTSTR ("APPROX 15 LINES OF OUTPUT PER I/O PAIR"));

	IF TRACEV  WINDOWS THEN  PRINTSTR TERPRI ("TRACE EMOTION VARIABLES? [Y,N]")
	  ALSO A_CHRVAL READ() 
	  ALSO (IF (A=CHRVAL 'Y) OR (A=CHRVAL 'y) THEN TRACEV_T);
 
	IF SUMEX  PTYJOB THEN BEGIN
	PRINTSTR TERPRI "DO YOU WANT THE CORE DUMPED? [Y,N]";  % FOR SAVING CORE IF SYSTEM CRASHES %
	IF ( READ () EQ 'Y ) THEN BEGIN
	  PRINTSTR TERPRI "NAME FOR THE DUMP FILE?[6 CHARS]";
	  A_READ();  SAVEDUMP_A;  A_EXPLODE(A);
	  IF A='H  A='A  A='R THEN NIL ELSE SAVEDUMP_NIL;
	 END;  END ELSE SAVEDUMP_NIL;
	SAVEFILE_T;
	INITPARAMS2();
	END;

EXPR INITPARAMS2();
	BEGIN
	PRINTSTR " 
END INPUT WITH A PERIOD OR QUESTION MARK, 
   FOLLOWED BY CARRIAGE RETURN. 
TO INDICATE SILENCE, TYPE   . 
   WHEN FINISHED, TYPE   BYE. 
USE PERIODS ONLY AT THE ENDS OF SENTENCES,
   NOT IN ABBREVIATIONS.
";
	IF PTYJOB() THEN PRINTSTR "
IF YOU ARE NOT AT STANFORD, YOUR BACKSPACE OR RUBOUT KEY
   PROBABLY DOESNT WORK CORRECTLY.
";
	END;

EXPR STRINGATE(L);	% RETURNS A STRING WITH THE QUOTE MARKS, FASTER THAN STR %

	BEGIN NEW A,B; A_EXPLODEC(L);
	A_CDR STRINGATE2(A);
	A_'?" CONS A ; 	B_READLIST(A);
	RETURN B;
	END;

EXPR STRINGATE2(A);

	IF NULL A THEN NIL
	ELSE IF NULL CDR A THEN  < '?" >
	ELSE CAR A CONS STRINGATE2(CDR A);

EXPR ANALYZE(FLAG);	% FOR ANALYZING TIME AND GARBAGE COLLECTION %

	BEGIN SPECIAL OLDTIME, OLDSPEAK, ANALFLAG; NEW A,B;
	IF FLAG THEN OLDTIME_TIME()  ALSO OLDSPEAK_SPEAK()  ALSO ANALFLAG_NIL  ALSO RETURN NIL;
	IF ANALFLAG THEN RETURN NIL;
	A_TIME();	B_ CAR DIVIDE( 10 * (A-OLDTIME) , 166 );
	PRINC(B); PRINTSTR( " TICS");  OLDTIME_A;
	A_SPEAK();	B_A-OLDSPEAK;
	PRINC(B); PRINTSTR( " CONSES"); OLDSPEAK_A;
	END; 


%	GETDATE, GETTIME, GETDOCNAME	%

EXPR DATE(N);

	BEGIN NEW A,B,C,YR,MO,DATE,DAY;
	A_DATEUU();
	TEN();	A_A+N;  % -1 IS YESTERDAY, 0 TODAY, +1 TOMORROW %
	B_DIVIDE(A, 31);	DATE_B+1;
	B_DIVIDE(B, 12);	MO_B+1;
	YR_B+1964;

	C_'((31 .JANUARY)(28 .FEBRUARY)(31 .MARCH)(30 .APRIL)(31 .MAY)(30 .JUNE)
	 (31 .JULY)(31 .AUGUST)(30 .SEPTEMBER)(31 .OCTOBER)(30 .NOVEMBER)(31 .DECEMBER));
	A_0;
	FOR NEW I_1 TO MO-1 BY 1 DO A_A+C[I];
	FOR NEW I_1973 TO YR BY 1 DO A_A+365;
	A_A+DATE-1;
	A_DIVIDE(A,7)+1;	% MINUS 2 AND PLUS 1 TO ORIENT FOR 1973 AND BEYOND%
			% PREVIOUS LINE SHOULD BE FIXED ON FEB 29, 1976 %
	B_'(SUNDAY MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY);
	DAY_B[A];
	MO_C[MO];
	RETURN < YR, MO, DATE, DAY > ;
	END;

EXPR GETDOCNAME();

	BEGIN NEW A,B,C,DOC,TEST,NAME;
	A_SSENT;	
	A_DELETE('PD, A); 	A_DELETE('COMMA, A);
	B_A;
	DO  IF B='MY  B='NAME  B='IS THEN C_B  UNTIL C OR B_B;
	B_A;
	IF C THEN
	  DO IF B='I  B='AM  (B='DR 
 B='DOCTOR) THEN C_B
		ALSO DOC_T	UNTIL C OR B_B;
	B_A;
	IF C THEN
	  DO IF (B='I?'M 
 B='IM)  (B='DR 
 B='DOCTOR) THEN C_B
		ALSO DOC_T	UNTIL C OR B_B;
	IF C='DR 
 C='DOCTOR THEN DOC_T ALSO C_C;
	IF C THEN RETURN NIL;
	NAME_ < C > ;
	IF C THEN TEST_C 
		ALSO IF CANONA(<TEST>) THEN NAME_ < C, C > ;
	IF DOC THEN NAME_'DOCTOR CONS NAME;
	RETURN NAME;
	END;

EXPR GETDATE(A,N);	% FORMS THE OUTPUT SENTENCE FOR YR,MONTH,DAY,DATE %

	BEGIN NEW B; B_DATE(N); IF B THEN RETURN '(I DON?'T PLAY GAMES);
	IF A='YEAR OR A='MONTH THEN
	  RETURN ( '(THE YEAR IS) @ <B CAT ";"> @ '(THE MONTH IS) @ <B> ) ;
	IF A='DATE THEN 
		RETURN ('(TODAY IS) @ <B> @ < B CAT ","> @ '(I THINK) ) ;
	IF A='DAY THEN RETURN ( '(IT?'S) @ <B> ) ;
	END;

EXPR GETDATEARB2(N);	% DECIDES WHETHER YEAR,MONTH,DAY,DATE, OR TIME REQUESTED %

	BEGIN NEW A;
	A_ASSOC('DAY, INPUTQUES);
	IF A THEN A_ASSOC('DATE, INPUTQUES);
	IF A  MEMQ(A, '(YEAR MONTH DAY DATE )) THEN RETURN GETDATE(A,N);
	IF A THEN A_ASSOC('WHEN, INPUTQUES);
	IF A  ( (A = 'TIME) OR (A='WHEN) ) THEN RETURN GETTIME();
	END;

EXPR GETDATEARB();  GETDATEARB2(0);		% DATE,TIME FOR TODAY %
EXPR GETDATEYES();  GETDATEARB2(-1);	% DATE,TIME FOR YESTERDAY %
EXPR GETDATETOM();  GETDATEARB2(1);		% DATE,TIME FOR TOMORROW %

EXPR PTYJOB();  GREATERP(  LSH(LSH( TTYUU() ,6) , -35) , 0); % RETURNS T IF A PTYJOB %

EXPR DDJOB();  GREATERP(  LSH(LSH( TTYUU() ,4) , -35) , 0); % RETURNS T IF A DD JOB %

EXPR GETTIME();	% LOOKS UP SYSTEM TIME AND GETS THE APPROX HOUR %

	BEGIN NEW A, HOUR, MIN, AHOUR;
	A_TIMEUUH(); HOUR_A; MIN_A;
	AHOUR_HOUR + DIVIDE(MIN,30);
	IF AHOUR13 THEN AHOUR_AHOUR-12; IF AHOUR=0 THEN AHOUR_12;
	TEN();  RETURN ( '(IT?'S ABOUT) @ <AHOUR CAT " O" > @ '(CLOCK) ) ;
	END;

EXPR TIMEUUH();
	BEGIN NEW A;
	A_DIVIDE(TIMEUU(), 3600); A_DIVIDE(A,60);
	RETURN <A,A>;  % THIS RETURNS (HOUR MINUTE) %
	END;

EXPR SPECCONCEPT(L);
	% USED FOR GENERAL IYOUME INPUT WHICH THE PATTERN MATCHER DIDNT RECOGNIZE %

	BEGIN NEW CON,YOU,NEG,FOUND,ADJ,INP;  INP_INPUTQUES;
	FOR NEW WORD IN INP DO
	  IF GET(WORD,'SET) MEMBER SENSITIVELIST THEN CON_WORD
	UNTIL CON;
	IF CON THEN RETURN NIL;
	IF ASSOC( 'YOU, INP) THEN YOU_T;
	NEG_ NOTFLAG;
	IF ASSOC('GOOD,INP) THEN ADJ_'GOOD ELSE
	  IF ASSOC('BAD,INP) OR ASSOC('ODD,INP) THEN ADJ_'BAD;
	IF YOU AND ADJ THEN
	  FOUND_ IF ((ADJ='GOOD)NEG) OR (NEG(ADJ='BAD)) THEN 
		CHOOSE 'POSADJ ELSE CHOOSE 'NEGADJ
	ELSE
	  IF YOU AND (GET(CON,'SPECIAL) OR ADJ) THEN FOUND_CHOOSE 'SPECCONCEPT
	ELSE  FOUND_CHOOSE 'SENSITIVELIST;
	RETURN FOUND;
	END;

% LASTWORD CHANGES L INTO THE APPROPRIATE ENGLISH WORD TO ADD TO THE END OF THE OUTPUT %

EXPR LASTWORD(L);	

	BEGIN NEW A,W;	W_L;
	IF W='SENSITIVELIST THEN	W_T ALSO
	  FOR NEW I IN GET('SENSITIVELIST, 'WORDS) DO
		IF A_ASSOC(I, INPUTQUES) THEN A_GET(A,'SET  ) UNTIL A;
	IF W='COMPLEMENT THEN	W_T ALSO
		IF A_ASSOC('GOOD, INPUTQUES) THEN A_A;
	IF W='SPECCONCEPT THEN	W_T ALSO	(
	  IF A_ASSOC('LOOKS, INPUTQUES) THEN A_GET(A,'WORDS) 	ELSE A_'LOOKS ) ;

	A_ IF A THEN <A>
		ELSE IF W=T OR W THEN  '(PROBLEMS) 
		ELSE IF ATOM W THEN <W> ELSE W;
	RETURN A;
	END;

END.  EOF 
COMMENT    VALID 00004 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN
C00005 00003	%  SELECTINPUT, READINC, READDATA  %
C00007 00004	% INITFILE, INITTOFILE, TOFILE, ERRORFILE %
C00013 ENDMK
C;

BEGIN

%			*** GLOBAL VARIABLES***

!ANAPHLIST	is the current list of anaphora dotted-pairs.
!ANAPHLISTOLD	is the previous list of anaphora dotted-pairs.
!ALLANAPHS	is a list of lists - ((who they he)(he who)(they who)....)
!CLIST		is a pointer to the first element of the conversation list.
!CLAST		is a pointer to the last element of the conversation list.
!LASTANDTHEN	is either IN or OUT as the last ANDTHEN processed
!LASTIN		points to atom under which is stored the last semantic unit
		inputed by the doctor.
!LASTOUT	points to the atom under which is stored the last semantic
		unit outputed by Parry.

!ERROR		contains a list of errors made
!EXHAUST	is true if a set of responses is exhausted and the exhaust responses are to be used
		  it is set by SELECTSENTENCE  and used at the end of REACT2
!OUTPUT		is the output of parry, to be sent whereever
!LASTOUTPUT	is the -name of the last output

INPUTQUES	is a list of dotted pairs from the pattern matcher to the memory
			each pair is (canonical 5-letter atom . input word)

         %


SPECIAL ?!ANAPHLIST,?!ANAPHLISTOLD,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LASTANDTHEN,
	?!OUTPUT,?!LASTOUTPUT, ?!EXHAUST, ?!ERROR, WDFLAG,

	INPUTQUES,SSENT,DOSPELL,NEXTCHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOCNAMEFLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVEFILE, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

 
DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
	THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX;


%  SELECTINPUT, READINC, READDATA  %
% ************ THESE ARE ALL INPUT-OUTPUT ROUTINES *************%
 
	% takes a file name (or NIL for TTY) and assigns it to the input channel%

EXPR SELECTINPUT(AREA, FILE);

	BEGIN 
	   IF FILE THEN BEGIN 
			IF AREA THEN INCHAN_EVAL(<'INPUT,AREA,FILE>)
				ELSE INCHAN_EVAL(<'INPUT,'DSK:,FILE>)
			END
		   ALSO INC(NIL,NIL)
		   ALSO PRINTSTR(FILE CAT " SELECTED FOR INPUT.")
	   ELSE PRINTSTR("TTY SELECTED FOR INPUT.")
	   ALSO INC(NIL,T);
	END;

EXPR SELECTINPUTN(AREA, FILE);

	   IF FILE THEN  INCHAN_EVAL(<'INPUT,INPUTFILEAREA,FILE>)
		   ALSO INC(NIL,NIL);

EXPR READINC();

	BEGIN NEW I;  INC(INCHAN,NIL); I_READ(); INC(NIL,NIL); RETURN I; 
	END;

%  READS PAST THE DIRECTORY PAGE IN AN INPUT FILE  %

EXPR READDATA();
	BEGIN NEW A;  A_READINC();
	IF A='COMMENT THEN 
		DO A_READINC() UNTIL ( A='C??; 
 A='??; )   
		ALSO A_READINC() ;
	RETURN A;
	END;


% INITFILE, INITTOFILE, TOFILE, ERRORFILE %
% ************* THESE ARE ROUTINES TO SAVE DIALOGS AND ERRORS ************ %

EXPR INITFILE(L);  INITFILE(L);

EXPR INITFILE(L);
	BEGIN  NEW FILCHAN,I;	SPECIAL DIAFILEAREA,ONEDIA,FILE12;
	EOF_PERCENT;	TEN();
	SAVEFILE _ T;
	FILCHAN _ EVAL < 'INPUT, DIAFILEAREA, '(PAR2.FIL) > ; 
	INC(FILCHAN,NIL);
	I_READ();
	FILE1_ AT("P" CAT I ) CONS 'DIA ;
	FILE2_ AT("P" CAT I CAT "A" ) CONS 'DIA ;
	INC(NIL,NIL);
	EVAL < 'OUTPUT, DIAFILEAREA, '(PAR2.FIL) > ; 
	OUTC(T,NIL);
	PRINT(I+1);
	OUTC(NIL,T);
	INITTOFILE(L);
        END;

EXPR INITTOFILE(L);

	BEGIN NEW FILCHAN;
	FILCHAN_ EVAL < 'OUTPUT, DIAFILEAREA, FILE1 > ;
	OUTC(FILCHAN, NIL);
	PRINTSTR(L CAT "        ");  PRINC TERPRI EOF ;
	OUTC(NIL,T);
	 IF SUMEX AND ONEDIA THEN BEGIN
	FILCHAN_ EVAL < 'OUTPUT, DIAFILEAREA, FILE2 > ;
	OUTC(FILCHAN, NIL);
	PRINTSTR( STR(L) CAT "        ");
	OUTC(NIL,T);
	 END;
	DIACHARNO_STRLEN(L) + 4;  FILE12_FILE1;
	TOFILE( LF, LF, LF);
	RETURN DIACHARNO;
	END;

EXPR TOFILE(L,M,N); IF SUMEX THEN TOFILE1(L,M,N) ELSE TOFILE2(L,M,N);

EXPR TOFILE1(L,M,N);

	BEGIN NEW FILCHAN,C,D,FLAG;  FLAG_NIL;
	CHANSAVE_INC(NIL,NIL);
	FILCHAN_EVAL< 'INOUT, DIAFILEAREA, FILE1 > ;
	OUTC(FILCHAN, NIL);
	CHSETO(FILCHAN, DIACHARNO);
	BUFFER(T);PRINTSTR(L);PRINC(M);PRINC(TAB);PRINC(N);PRINTSTR(TIMESTAT());TERPRI NIL;BUFFER(NIL);

	  % THIS IS TO CORRECT A BUG IN CHSETO WHICH SETS IT TO A MINUS NUMBER
		IF IT HITS A RECORD BOUNDARY EXACTLY  %
	C_CHSETO(FILCHAN,NIL);
	IF MINUSP(C) THEN ERROR("TOFILE MINUS",L) ALSO  
	  BEGIN
	OUTC(NIL,T);	% TO NOT GROW CORE LIKE IT WAS BEFORE %
	FILCHAN_EVAL< 'INOUT, DIAFILEAREA, FILE1 > ;
	OUTC(FILCHAN, NIL);
	CHSETO(FILCHAN, DIACHARNO);
	BUFFER(T);PRINTSTR(L);PRINC(M);PRINC(TAB);PRINC(N);PRINTSTR(TIMESTAT());TERPRI NIL;BUFFER(NIL);
	  END   ALSO PRINTSTR("        ")
	  ALSO D_CHSETO(FILCHAN,NIL) ALSO FLAG_T
	  ALSO IF MINUSP(D) THEN ERROR("TOFILE MIN AGAIN",L);

	 IF ONEDIA THEN BEGIN

	OUTC(NIL,T);
	FILCHAN_EVAL< 'INOUT, DIAFILEAREA, FILE2 > ;
	OUTC(FILCHAN, NIL);
	CHSETO(FILCHAN, DIACHARNO);
	BUFFER(T);PRINTSTR(L);PRINC(M);PRINC(TAB);PRINC(N);PRINTSTR(TIMESTAT());TERPRI NIL;BUFFER(NIL);
	IF FLAG THEN PRINTSTR("        ");
	 END;
	DIACHARNO_CHSETO(FILCHAN,NIL);
	OUTC(NIL,T);
	INC(CHANSAVE,NIL);
	RETURN DIACHARNO;
	END;

EXPR TOFILE2(L,M,N);

	BEGIN NEW F,CH;		% FILE12 HAS THE CURRENT GOOD FILE %
	F_FILE12;   FILE12_IF FILE12=FILE1 THEN FILE2 ELSE FILE1; % SWITCH NAMES %
	CHANSAVE_INC(NIL,NIL);
	FILCHAN_EVAL < 'OUTPUT, DIAFILEAREA, FILE12 > ;
	OUTC(FILCHAN,NIL);
	INCHAN_EVAL < 'INPUT, DIAFILEAREA, F > ;
	INC(INCHAN,NIL);
	BUFFER(T);
	PRINC(INPUTNO CAT " "); READ();  % READ THE NUMBER AND THROW IT AWAY %

	DO NIL UNTIL TYO TYI() EQ OCTAL 45  
		(  ATOM(CH_ERRSET(READCH(),NIL)) 
 PRINC CAR CH  NIL ) ;

	BUFFER(T); PRINTSTR(L); PRINC(M); PRINC(TAB); PRINTSTR(N);  TERPRI NIL; BUFFER(NIL);
	PRINC TERPRI EOF ;
	OUTC(NIL,T); INC(NIL,T); INC(CHANSAVE,NIL);
	END;

EXPR ERRORFILE(A);

	BEGIN 	NEW FILCHAN, FILENAME,I;	TEN();
	CHANSAVE_INC(NIL,NIL);
	FILCHAN _ EVAL < 'INPUT, DIAFILEAREA, '(ERR.FIL) > ;
	INC(FILCHAN,NIL);
	FILENAME_AT("P" CAT (I_READ()));
	INC(CHANSAVE,NIL);
	EVAL < 'OUTPUT, DIAFILEAREA, '(ERR.FIL) > ;
	OUTC(T,NIL);
	PRINT(I+1);
	OUTC(NIL,T);

	OUTC( EVAL( <'OUTPUT, DIAFILEAREA, FILENAME CONS 'ERR > ), NIL);
	PRINT(A);
	OUTC(NIL, T);
	RETURN A;
        END;

 END.  EOF
COMMENT    VALID 00007 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN   % THIS IS ALL THE TOP-LEVEL GOODIES PLUS INFERENCE %
C00010 00003	% ANGERFEARMODE  %
C00013 00004	% REACT2  CALLS REPLYR WITH APPROPRIATE ARGUMENTS AND ENTERS THE INPUT ON THE CONVERSATION LIST %
C00016 00005		% ********** REACT ******* TOP LEVEL ROUTINE OF THE MEMORY ************ %
C00023 00006	% BINIT, READBEL, READINF %
C00026 00007	% ASSERT, ASSERT2, ADDTO, PROVE, PROVE2, BL, EVALUATE, STATED, INFERENCE %
C00032 ENDMK
C;

BEGIN   % THIS IS ALL THE TOP-LEVEL GOODIES PLUS INFERENCE %
 
SPECIAL ?!ANAPHLIST,?!ANAPHLISTOLD,?!ANAPHLISTNEW,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LASTANDTHEN,
	?!OUTPUT,?!LASTOUTPUT, ?!EXHAUST, ?!ERROR, WDFLAG, REACTTO, ERRNAME,
	STYPE, STOPIC, TRACEMEM, ENDE,

	INPUTQUES,SSENT,DOSPELL,NEXTCHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOCNAMEFLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVEFILE, SAVEDUMP, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG, REACTINPUT,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

SPECIAL NEWPROVEN, INTENT, OLDINTENT, BADINPUT, DELNO, PREVOUTPUT;
NEW     NEWPROVEN, INTENT, OLDINTENT, BADINPUT, DELNO, PREVOUTPUT;

SPECIAL PROVEL,PROVEN,NEWPROVEN,INTLIST,INTENT,PRINTALL;
SPECIAL OLDGIBB, OLDMISS;
NEW ?!ANAPHLISTNEW;

SPECIAL LAMDA, INPUTFILEAREA;

DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
 THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX, PL PREFIX, BL PREFIX, NUMED PREFIX;

EXPR INIT();	SELECTINPUTN( '(PAR BLF), INPUTFILE);
EXPR INITFB(); BEGIN EVAL '(DSKIN(RANDOM.LAP)); LAMDA_8; INITF(); INITB(); END;
EXPR TESTM();	TESTPATTERN();

EXPR LAMBDANAME(L);  EQUAL( CHRVAL(L), LAMDA);


EXPR PARRY();	% ************ TOP LEVEL ROUTINE *********** %

	BEGIN 
	TERPRI PRINC "READY:" ;
	WHILE T DO
	  IF ERRSET(  PARRY2() , NIL)
	  THEN ERROR(SSENT, "TOP-LEVEL LISP ERROR " CAT TRACEMEM CAT !ANAPHLIST ) 
	  ALSO TERPRI NIL 
	  ALSO TERPRI PRINTSTR("WHAT DO YOU MEAN BY THAT");
	END;

EXPR PARRY2();

		BEGIN	NEW A,B;
		BUG_0;
		IF SAVEDUMP THEN SAVEJOB( SAVEDUMP, 'SAV );
			%  PROGRAM WILL START HERE AGAIN IF SYSTEM CRASHES %

		IF NOTLASTINPUT() THEN TERPRI PRINC "READY:" ;
		BUG_0; EXPERIMENT();
		BUG_1;
		A_ERRSET(TESTM(),NIL);  IF ATOM A THEN 	ERROR(A,
		  "PATTERNMATCH ERROR" CAT STR < NEXTCHAR,SSENT,INPUTQUES > ) 
		 ALSO ERR(NIL);
		BUG_2;
		A_A;	PM2INPUT_PMINPUT;  PMINPUT_A;
		IF LENGTH(SSENT)=1 THEN A_CHOOSE 'SILENCE;
% *** %		ANALYZE(T);
		BUG_3;
		IF LAMBDANAME(A) THEN A_NIL;
		IF A  ATOM A  B_GET(A,'MEQV) THEN A_B;
		REACTINPUT_A;
		WINDOW(9,T,A);
		READLAMBDA(A);  WINDOW(9,NIL,GET(A,'BONDVALUE));
		BUG_4;
		IF ERRSET(REACT ( < A, Q(SSENT), SSENT > ), NIL) THEN
			ERROR(A,"ERROR IN REACT " CAT SSENT)  ALSO ERR(NIL);
		BUG_70;
		IF ENDE THEN TRACEV_TRACEV ALSO MODIFVAR() ALSO WINXIT()
			ALSO SWAPP()  ALSO EXIT();
		BUG_80;
		END;  

EXPR INITB();			% INITIALIZATION FUNCTION %
	BEGIN 	EIGHT();  NOUUO(T);
	OPARINITIALIZE();	% INITIALIZES OPAR3	%
	READBONDS('PDATB);
	SETUPSTL();
	INPUTFILEAREA_'(1 3);  DIAFILEAREA_'(DIA KMC);
	GCGAG(NIL);
	CHANGEL('CHANGE);
	DELNO_BUG_0;	OLDMISS_OLDGIBB_0;
	INPUTNO_REPEATNO_SPECFNNO_MISCNO_NEWTOPICNO_0;
	HLIST_OLDTOPIC_OLDTOPICS_NIL;
	END;

EXPR REACTPRINT(L);	% FORMATS AND PRINTS THE OUTPUT TO TTY AND DIA FILE %
	BEGIN	NEW SENT, ISENT, N;
	SENT _ L;
	%       SUPPRESS NON-VERBALS HERE	%
	BUG_43;
	IF SUPPRESS  SENT  ATOM SENT THEN SENT_SENT;
	SENT _ IF SENT THEN STRINGATE (SENT) ELSE " ";
	TERPRI NIL;
	PRINTSTR  SENT;
	ISENT _ INPUTSSENT;
	BUG_44;
	ISENT_STRINGATE(IF ISENT  ISENT THEN REVERSE(ISENT) ELSE ISENT);
	N_ < PMINPUT, GET(REACTINPUT,'BONDVALUE), TRACEMEM, NEWPROVEN, INTENT>;
	BUG_45;

	IF SAVEFILE THEN  (
	 IF ERRSET( TOFILE(ISENT, SENT, N ) ,NIL) 
	  THEN ERROR(DIACHARNO, "ERROR IN TOFILE" CAT ISENT CAT SENT )   ) ;
	BUG_46;
	INPUTSSENT_NIL;
	END;


EXPR PMIN();  PMINITIALIZE();

EXPR DOSF(L);   % THIS DOES THE SEMANTIC FN (PROTECTED BY ERRSET) AND RETURNS A LAMBDA OUTPUT %

	BEGIN NEW A,B;
	IF ATOM B_ERRSET( IF LAMBDANAME(L)  (A_GET(L,'SF))  A_EVAL(A) THEN A, NIL)  
	THEN ERROR("BAD SF",<L,B>)
	ELSE B_B   ALSO ( IF LAMBDANAME(B) THEN ?!OUTPUT_B ALSO B_NIL )
	ALSO RETURN B;
	END;

EXPR CHOOSELEAD(); '(BOOKIESET GAMBLERSET HORSERACINGSET GANGSTERSET)[ RANDOM(4) ];

	  %   PRINT OUT VALUES OF VARIABLES   %

EXPR PRINTVARS();
      BEGIN
	BUFFER(T);  TERPRI NIL;
	PRINC("      FEAR = ");  PRINTSTR NUMED FEAR;
	PRINC("     ANGER = ");  PRINTSTR NUMED ANGER;
	PRINC("     SHAME = ");  PRINTSTR NUMED HURT;
	BUFFER(NIL);
      END;

EXPR WPRINTVARS();
      BEGIN  NEW A;
	A_WINSUP(T);  % SUPPRESS AND GET OLD SETTING %
	WINDOW(41,T,"      FEAR = " CAT NUMED FEAR);
	WINDOW(41,T,"     ANGER = " CAT NUMED ANGER);
	WINDOW(41,T,"     SHAME = " CAT NUMED HURT);
	WINDOW(41,T,"  " );
	IF A THEN WINDIS();  WINSUP(A); %IF OLD SETTING OFF, THEN DISPLAY AND RESET %
      END;


% ANGERFEARMODE  %

EXPR NOTLASTINPUT();  NOT ( EQ( NEXTCHAR, CR) OR EQ( NEXTCHAR, LF) ) ;

% ANGERFEARMODE RESPONDS TO HIGH ANGER AND FEAR LEVELS IF NO SPECIFIC EMOTIONS ARE AFFECTED %

EXPR ANGERFEARMODE(TOPIC);

	BEGIN
	IF MEMQ(TOPIC, GET('FLARELIST,'SETS)) OR 
		MEMQ(TOPIC, '(MAFIA BYE IYOUME STRONGFEELINGS FEELINGS GAMES))
	  THEN RETURN NIL;
	BUG_14;
	RETURN ( IF FEAR14 THEN FEARMODE() ELSE ANGERMODE() ) ;
	END;

EXPR ANGERMODE ();
	IF ANGER GREATERP 17.5 THEN  CHOOSE 'ANGER ELSE  CHOOSE 'HOSTILEREPLIES ;

EXPR FEARMODE ();
	IF FEAR GREATERP 18.4 THEN  ENDE_T  ALSO  CHOOSE 'EXIT
		%   DISTINGUISH BETWEEN QUESTIONS AND STATEMENTS OF 'OTHER   %
	ELSE IF BL 'DDHARM  BL 'DHELPFUL  BL 'DMAFIA THEN ((FEAR_FEAR-1)  NIL)
	ELSE IF STYPE='Q THEN CHOOSE 'THREATQ ELSE  CHOOSE 'AFRAID;

% TOPICANALYZE  RECORDS THE NUMBER OF OLD TOPICS, CHANGED TOPICS, AND THE PREVIOUS TOPIC %

EXPR TOPICANALYZE();

	BEGIN  IF STOPIC THEN RETURN NIL;
	IF STOPIC MEMQ '(ANAPH FACTS STRONGFEELINGS GREETINGS) THEN RETURN NIL;
	IF STOPIC=OLDTOPIC THEN RETURN NIL;
	NEWTOPICNO_NEWTOPICNO+1;
	OLDTOPICS_CONS(OLDTOPIC,OLDTOPICS);
	OLDTOPIC_STOPIC;
	END;

EXPR PREVTOPIC();	STOPIC MEMQ OLDTOPICS;

% HISTORY  RECORDS THE SPECIFIC EMOTION THAT WAS AFFECTED BY THIS INPUT %

EXPR HISTORY(L);

	BEGIN  IF L THEN RETURN MEMQ(L, HLIST);
	HLIST_NIL;
	IF AJUMP  (AJUMP0.1) THEN ADDH( '(AJUMP MJUMP));
	IF FJUMP  (FJUMP0.1) THEN ADDH( '(FJUMP MJUMP));
	END;

EXPR ADDH(L);   FOR NEW I IN L DO HLIST_CONS(I,HLIST);


% REACT2  CALLS REPLYR WITH APPROPRIATE ARGUMENTS AND ENTERS THE INPUT ON THE CONVERSATION LIST %

EXPR REACT2(B);

	BEGIN NEW A; ?!EXHAUST_NIL;

	IF LAMBDANAME(B) THEN ERROR("NONLAMBDA INTO REACT2",B) ALSO RETURN NIL;

	IF ?!OUTPUT	% ALREADY HAVE SENTENCE IN ?!OUTPUT %
	  THEN ANDTHEN(<'IN,B>)  ALSO ANDTHEN(<'OUT,NIL>)
	  ALSO RETURN T;

	IF DISKREAD(B) THEN  ERROR("REACT2 ERROR BAD DISKREAD", B) ALSO RETURN NIL;

	ANDTHEN(<'IN, B>);
	RETURN REPLYR(B);

	END;

% REACT3  HANDLES CASES WHEN THE OUTPUT RESPONSES HAVE BEEN EXHAUSTED %

EXPR REACT3(P,STRUC,SENT);	% IF NO !OUTPUT FROM REACT2 THEN DO THIS %

	BEGIN NEW A,B;	B_CARN P;

	IF ?!EXHAUST THEN ERROR(<P, STRUC, SENT>,"BAD INPUT IN REACT3");
	%  REPETITIOUS INPUT AND EXHAUSTED REPLIES	%
	IF ( TRACEMEM='OK ) AND (STOPIC='STRONGFEELINGS) AND REPETITION(B,'IN) 
	  THEN REPEATNO_REPEATNO+1 
	  ALSO  ( IF GET(B,'REPEAT) THEN A_GETSTORY() )  %LET ONE REPEAT GO BY %
	  ALSO PUTPROP(B,T,'REPEAT) 
	  ALSO  (IF A THEN A_CHOOSE 'REPEAT) ;
	IF A  REACT2(A) THEN RETURN A;

	A_ GETSTORY();
	IF A   REACT2(A)  THEN RETURN A;
	IF A_EXHAUSTER() THEN A_CHOOSE 'EXHAUST; 
	IF A  REACT2(A) THEN RETURN A;
	END;


	% ********** REACT ******* TOP LEVEL ROUTINE OF THE MEMORY ************ %

EXPR REACT(INPUT);

	BEGIN NEW A,B,SENT,STRUC,FOUND,FOUND2; 	BUG_10;
	STRUC_ CAR INPUT;  STYPE_ CADR INPUT;  SENT_INPUT;

	INPUTSSENT_SSENT CONS INPUTSSENT;	% SET ALL THE VARIABLES %
	TRACEMEM_NIL;	INPUTNO_INPUTNO+1;
	?!ANAPHLISTNEW_?!EXHAUST_NIL; ?!OUTPUT_WDFLAG_NIL; CHOSEN_NIL;
	IF DOCNAMEFLAG THEN DOCNAME_GETDOCNAME();
	BUG_11;

	IF ( INPUTNO=2 ) AND ERRNAME  THEN ERRNAME_T  	% SAVE A POINTER TO THE DIA FILE %
	  ALSO ERROR( (IF PTYJOB() THEN " PTYJOB" ELSE " ")
	   CAT (IF SAVEFILE THEN " NSAVED" ELSE " ") , NIL);
	BUG_12;
	IF STRUC  READLAMBDA(STRUC) THEN REACTTO_STRUC_NIL ALSO TRACEMEM_'NOTINMEMORY;

	WINDOWSET(2);
	WINDOW(51,T,GET(STRUC,'TOPIC));
	IF A _ GET(STRUC,'UNIT) THEN WINDOW(52,T,A);

	WINDOW(31,T,'PREPROCESS);
	REACTTO_CHECKINPUT(STRUC);	% PREPROCESS THE INPUT %
	IF REACTTO  READLAMBDA(REACTTO) THEN REACTTO_STRUC_NIL;
	BUG_14;

	IF REACTTO  STRUC THEN (  
		(IF REACTTO_SPECFN(STRUC) THEN TRACEMEM_'SPECIALANAPH   % LOOK FOR ANAPHORA %
			ALSO SPECFNNO_SPECFNNO+1 )  OR
		(IF REACTTO_MEMFIND(STRUC)THEN TRACEMEM_'OK)  ) ;	% LOOK UP NORMAL INPUT %
	IF REACTTO='QUIT THEN REACTTO_NIL ALSO TRACEMEM_'NOSPECIALANAPH;
	IF READLAMBDA(REACTTO) THEN REACTTO_NIL;
	BUG_15;
	IF REACTTO  DELFLAG  REACTTO_SKEYWD(STYPE,INPUTQUES) 
		THEN TRACEMEM_'KEYWORD;

	IF READLAMBDA(REACTTO) THEN REACTTO_NIL;

	BUG_16;
%***%   ANALYZE(T);

	STOPIC_ CARN GET(STRUC, 'TOPIC);
	TOPICANALYZE();	% ANALYZE THE CURRENT TOPIC %
	WINDOW(31,T,'INFERENCES);
	IF ERRSET( INFERENCE(),NIL) THEN ERROR("INFERENCE ERROR", PROVEL);
	WINDOW(31,T,'AFFECTS);
	IF ERRSET( AFFECT(),NIL) THEN ERROR("AFFECT ERROR", ACTION);
	WINDOW(31,T,'INTENTIONS);
	IF ERRSET( FOUND_DOINTENT(),NIL) THEN ERROR("DOINTENT", INTENT);
	IF FOUND THEN TRACEMEM_'INTENT;
	WINDOW(31,T,'ACTIONS);
	BUG_17;
	IF FOUND  REACTTO THEN FOUND_REACTTO;

	  % IF THERE IS NOTHING IN FOUND, THEN WE HAVE TO PUNT AND TAKE A MISCELLANEOUS RESPONSE %

	IF FOUND THEN BEGIN IF STYPE='Q THEN FOUND_MISCQ(SENT) ELSE FOUND_MISCS(SENT);
		MISCNO_MISCNO+1;
		IF TRACEMEM  FOUND THEN TRACEMEM_'NOPATTERN; END;
	BUG_18;


	IF READLAMBDA(FOUND) THEN  FOUND_NIL;
	BUG_20;

	REACTTO_FOUND;  B_NIL;
	% DO SEMANTIC FUNCTION, RESULT WILL BE EITHER NAME OR ACTUAL SENTENCE %
	FOUND_ IF B_DOSF(FOUND) THEN ( IF A_DOSF(B) THEN A ELSE B ) ELSE FOUND;
	BUG_22;

	IF NOTLASTINPUT() THEN RETURN NIL;
	  % QUIT HERE IF THERE IS ANOTHER INPUT SENTENCE ON THE INPUT LINE %
%***%   ANALYZE(T);

	IF CARN GET(FOUND,'TOPIC)='MAFIA THEN DELNO_DELNO+1; % RECORD NUMBER OF DELUSION STMTS %
	REACT2(FOUND);  % GET THE ENGLISH SENTENCE INTO ?!OUTPUT %
	BUG_30;

	IF ?!OUTPUT THEN FOUND2_REACT3(FOUND,STRUC,SENT); % TRY AGAIN TO GET ENGLISH OUTPUT %

	BUG_35;
	?!ANAPHLISTOLD_?!ANAPHLIST;	?!ANAPHLIST_?!ANAPHLISTNEW;  % UPDATE ANAPHLIST %

	IF ?!OUTPUT  ?!OUTPUT THEN   % RESCAN OUTPUT FOR FLARE AND DELUSIONAL WORDS %
	   IF ATOM ERRSET(  ASCAN( CANONA(?!OUTPUT) ,NIL) ,NIL  ) THEN
		ERROR("ASCAN" CAT ?!OUTPUT, FOUND);
	BUG_40;

	?!LASTOUTPUT_FOUND;
%***%   ANALYZE(T);
	BUG_42;
	WINDOW(31,T,'OUTPUT); PREVOUTPUT_?!OUTPUT;
	WINDOW(49,T,IF ATOM ?!OUTPUT THEN ?!OUTPUT ELSE ?!OUTPUT );
	IF ATOM ERRSET( REACTPRINT(?!OUTPUT), NIL) THEN  % PRINT OUTPUT TO TTY AND DIA FILE %
		ERROR("REACTPRINT" CAT INPUTSSENT CAT ?!OUTPUT, FOUND);
	INPUTSSENT_NIL;
	BUG_48;
	IF ATOM ERRSET( BEGIN
	HISTORY(NIL);	% REMEMBER CURRENT THINGS FOR HISTORY %
	MODIFVAR(); TERPRI NIL;		% UPDATE EMOTION VARIABLES %
	IF WINDOWS THEN WPRINTVARS();

		%  UPDATE STORY LISTS %
	IF LAMBDANAME(?!LASTOUTPUT) AND A_GET(?!LASTOUTPUT,'STORYNAME)
		THEN DELETEP(A, ?!LASTOUTPUT, 'STORY);
	IF LAMBDANAME(FOUND2) AND A_GET(FOUND2,'STORYNAME)
		THEN DELETEP(A, FOUND2, 'STORY);
	END, NIL) THEN ERROR("ERROR FROM BOTTOM OF REACT",FOUND);

%***%   ANALYZE(T);
	BUG_50;
	RETURN FOUND;
	END;


% BINIT, READBEL, READINF %

EXPR BINIT();

	BEGIN
	BAKGAG(T); NOUUO(T); TEN();
	INTLIST_INTENT_PROVEN_PROVEL_NIL;
	PRINTALL_NIL;
	READBEL('BEL);
	READINF('INF);
	END;

% FORMAT OF INPUT: ( <BELNAME> <NUMBER> <CLASS> <OPTIONAL OPPOS NAME> <NUMBER> ) %

EXPR READBEL(FILE);	% READ BELIEFS INTO MEMORY AND LINK THEM %

	BEGIN NEW A,B;
	SELECTINPUT(NIL,FILE);
	WHILE ATOM(A_ERRSET(READDATA()) ) AND A_A DO
	  BEGIN
		PUTPROP(A, A, 'NTRUTH);
%		PUTPROP(A, A, 'CLASS);  %
		IF A='INN THEN INTLIST_A CONS INTLIST
		    ALSO PUTPROP(A, A, 'CLASS);
		IF B_A 
		  THEN PUTPROP(B, B, 'NTRUTH)
%		  ALSO PUTPROP(B, A, 'CLASS)  %
		  ALSO PUTPROP(B, A, 'OPPOS)
		  ALSO PUTPROP(A, B, 'OPPOS);
		B_A;
	  END;
	INTLIST _ REVERSE(INTLIST);
	PRINTSTR("BELIEF FILE READ, LAST BELIEF: " CAT B );
	END;

% FORMAT OF INPUT: ( <INF NAME> <CONSEQ> <LIST OF ANTECEDENTS> ) %

EXPR READINF(FILE);	% READ INFERENCES INTO MEMORY AND LINK THEM %

	BEGIN NEW A,B;
	SELECTINPUT(NIL,FILE);
	WHILE ATOM(A_ERRSET(READDATA()) ) AND A_A DO
	  IF MEMQ(A,'(TH2 EMOTE)) THEN
	   FOR NEW I IN A DO  PUTPROP(I, CONS(A, GET(I,A)), A)
	ELSE
	  BEGIN B_A;
		IF GET(A,'THEOREM) THEN PRINTSTR("DUPLICATE INF: " CAT A);
		PUTPROP(A, A CONS A, 'THEOREM);
		IF GET(CARN A, 'NTRUTH) THEN PRINTSTR("NO BEL: " CAT A);
		% BACKPOINTER FROM ANTECEDENT TO TH NAME %
		FOR NEW I IN A DO 
		  IF ATOM I THEN PUTPROP(I, A CONS GET(I,'TH), 'TH)
		   ALSO IF LAMBDANAME(I)  GET(I,'NTRUTH) THEN PRINTSTR("NO BEL: " CAT I);
	  END;

	PRINTSTR("INF FILE READ, LAST INF: " CAT B );
	END;

% ASSERT, ASSERT2, ADDTO, PROVE, PROVE2, BL, EVALUATE, STATED, INFERENCE %

EXPR POSIT(B);  IF ATOM B THEN ASSERT2(B) ELSE ADDTO(B,B);

% B IS A NAME OF A BELIEF %

EXPR ASSERT(B);		% ASSERT B, AND TRY TO PROVE ANY CONSEQUENCES OF IT %

	T  ASSERT2(B)  PROVE();

EXPR ASSERT2(B);	% ASSERT A NEW BELIEF, AND FIND ALL THEOREMS IN WHICH IT IS THE ANTECEDENT %

	BEGIN NEW A;
	IF A_GET(B,'EMOTE) THEN INFEMOTE(B,A,T);
	A_GET(B,'OPPOS);
	IF GET(B,'TRUTH) THEN RETURN T;
	IF A  GET(A,'TRUTH) THEN 	% OPPOSITE BELIEF ALREADY TRUE %
	   (IF PRINTALL THEN PRINTSTR("CONTRADICTION : TRYING TO ASSERT " CAT B) )
	   ALSO RETURN T;
	WINDOW(37,NIL,B);
	PUTPROP(B,T,'TRUTH);	% ASSERT %
	IF A THEN PUTPROP(A,NIL,'TRUTH);	% UNASSERT THE OPPOSITE BELIEF %
	IF A_GET(B,'TH) THEN PROVEL_PROVEL @ A;	% FIND THEOREMS %
	PROVEN_CONS(B,PROVEN);	% RECORD THIS BELIEF %
	NEWPROVEN_CONS(B,NEWPROVEN);
	END;

EXPR ADDTO(B,N);	% ADDTO A BELIEF, IF THRESHHOLD CROSSED, THEN ASSERT %

	BEGIN NEW A,VAL;
	IF A_GET(B,'EMOTE) THEN INFEMOTE(B,A,N);
	IF A_GET(B,'TH2) THEN 
		FOR NEW I IN A DO ADDTO(IF ATOM I THEN I ELSE I, N/2);
	A_GET(B,'OPPOS);
	IF GET(B,'TRUTH) OR ( A  GET(A,'TRUTH) ) THEN RETURN T;  % QUIT IF TRUE, OR OPPOSITE TRUE %
	WINDOW(37,NIL,<B,N>);
	VAL_N+GET0(B,'NTRUTH);
	IF 'INN=GET(B,'CLASS) THEN (	% UPDATE VALUE %
	  IF VAL10 THEN VAL_9 ELSE IF VAL0 THEN VAL_0 ) ;
	PUTPROP(B, VAL, 'NTRUTH);
	IF VAL  10 THEN ASSERT2(B);	% ASSERT IF THRESHHOLD CROSSED %
	END;

EXPR GET0(I,V);		% RETURNS A NUMBER FOR GET %
	BEGIN NEW A; A_GET(I,V);
	RETURN   IF NUMBERP(A) THEN A ELSE 0;
	END;

EXPR PROVE();	% DO PROVE2 REPEATEDLY ON PROVEL, THE LIST OF THEOREMS TO BE PROVED %

	WHILE PROVEL DO PROVE2(PROVEL)  PROVEL_PROVEL;

% TH IS A THEOREM NAME FROM THE TOP OF PROVEL %

EXPR PROVE2(TH);	% TRY TO PROVE A THEOREM TH %

	BEGIN NEW A,B,C;
	IF PRINTALL = 2 THEN PRINTSTR(PROVEL);
	IF A_GET(TH,'THEOREM) THEN RETURN NIL;
	  % IF BELIEF ALREADY PROVEN THEN DON'T DO IT  %
	B_CARN A; IF BL B THEN RETURN NIL;
	% C IS THE CONSEQUENT, A IS A LIST OF ANTECEDENTS %
	WINDOW(35,T,A);
	C_A; B_T;
	FOR NEW I IN A DO B_B  EVALUATE(I);   % TRY EACH ANTECEDENT AND "AND" THEM TOGETHER %
	IF B THEN  ( IF PRINTALL THEN PRINTSTR(C CAT " PROVEN") ) ALSO  POSIT(C) 
		ALSO WINDOW(36,T,A);
	END;

EXPR EVALUATE(I);	% EVALUATE AN ANTECEDENT "I" %

	IF ATOM I THEN		% EITHER AN INPUT WHICH IS STATED, OR A BELIEF WHICH IS TRUE %
	  ( IF LAMBDANAME(I) THEN STATED(I) ELSE BL I )
	ELSE IF I='NOT THEN NOT BL I
	ELSE EVAL(I);	% ELSE A FUNCTION FOR LISP TO EVALUATE %

EXPR BL(B);	% RETURNS T IF BELIEF B IS TRUE, OR INTENTION B IS OVER ITS THRESHHOLD %
	IF ATOM B THEN ERROR("BL NOT ATOM", B) ALSO NIL
	ELSE  IF GET(B,'CLASS)='INN THEN ( GET(B,'NTRUTH)5 ) ELSE  GET(B,'TRUTH);

EXPR STATED(I);	EQ(REACTTO,I);

% THINK  TAKES ALL THE NEW FACTS FROM THIS INPUT AND PROVES ALL IT CAN ABOUT THE WORLD %

EXPR INFERENCE();

	BEGIN NEW A; SPECIAL PARA, SPECFNRA;
	NEWPROVEN_NIL;
	PARA_GREATERP(MISTRUST,7);	% PARANOID PARAMETER -- MAKES SOME BELIEFS POSSIBLE %
	IF STOPIC='GREETINGS THEN SPECFNNO_SPECFNNO+1;
	SPECFNRA_100*SPECFNNO/INPUTNO;
	PROVEL_'(IF730 IF740 IF750 IF760 IF770 IF350 IF380 IF566 IF884	% TRY THESE EVERY TIME %
		%	IF205 IF210 %     IF225    );
	IF DOCNAMEFLAG THEN PROVEL_ 'IF331 CONS PROVEL;
	IF STOPIC='MAFIA THEN PROVEL_ 'IF888 CONS PROVEL;
	A_GET(REACTTO,'TH);	% THE INPUT MAY HAVE ASSOCIATED INFERENCES %
	IF A THEN PROVEL_PROVEL @ A;
	IF A_GET(REACTTO,'TH2) THEN FOR NEW I IN A DO POSIT(I);
	PROVE();	% PROVE ALL THATS POSSIBLE %
	IF PRINTALL THEN PRINT(PROVEN);
	END;

END.  EOF 
COMMENT    VALID 00004 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN   % THIS FILE HAS INTENT ROUTINES       %
C00012 00003	%  CHECKINPUT  LOOKS THRU INPUT FOR SWEARING, INSULTS, NEGATIVE WORDS %
C00018 00004	% AFFECT, INTENTION, AND INTENTION ROUTINES %
C00028 ENDMK
C;

BEGIN   % THIS FILE HAS INTENT ROUTINES       %

SPECIAL ?!ANAPHLIST,?!ANAPHLISTOLD,?!ANAPHLISTNEW,?!CLIST,?!CLAST,?!ALLANAPHS,
	?!LASTIN,?!LASTOUT,?!LASTANDTHEN,
	?!OUTPUT,?!LASTOUTPUT, ?!EXHAUST, ?!ERROR, WDFLAG, REACTTO, ERRNAME,
	STYPE, STOPIC, TRACEMEM, ENDE,

	INPUTQUES,SSENT,DOSPELL,NEXTCHAR,MISSPELL,
	INPUTSSENT, DOCNAME, DOCNAMEFLAG, EXHAUSTNO, SILENCENO, SWEARNO,

	CHANSAVE, INCHAN, SAVEFILE, EOF, FILE1, FILE2, DIACHARNO,
	INPUTFILE, PMINPUT, PM2INPUT, BUG,

	INPUTNO, REPEATNO, SPECFNNO, MISCNO, NEWTOPICNO,
	OLDTOPIC, OLDTOPICS, HLIST;

SPECIAL NEWPROVEN, INTENT, OLDINTENT, BADINPUT, DELNO, PREVSSENT;
NEW     NEWPROVEN, INTENT, OLDINTENT, BADINPUT, DELNO, PREVSSENT;

SPECIAL OLDGIBB, OLDMISS, LOWMAN, TRACEVFLAG;
NEW ?!ANAPHLISTNEW;
SPECIAL ACTION, ONEDIA, SUMEX; 
NEW	ACTION, ONEDIA, SUMEX;
SPECIAL EXPERIMENT;

DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
	THEN , ELSE \, CARN PREFIX, CHOOSE PREFIX, BL PREFIX, NUMED PREFIX;

EXPR EXPERIMENT();  % EXPERIMENTS OF RAISING AND LOWERING SHAME %
	BEGIN NEW A; IF EXPERIMENT 
 (EXPERIMENT='SEVEN) THEN RETURN NIL;
	IF INPUTNO=7 THEN HURT_HURT+5;
	IF INPUTNO=17 THEN HURT_HURT-5;
	END;

EXPR ERROR(MESS,L);

	?!ERROR_ ERRORFILE( <MESS,L,PM2INPUT,PMINPUT,FILE1,BUG> ) CONS ?!ERROR;

EXPR ALLOWRUN();
	BEGIN NEW A;  A_IF SUMEX THEN SUMEXALLOW() ELSE ALLOW();
	IF A THEN SWAPP(); % NOT FROM SCHEDULER %
	IF SUMEX THEN NAMEP();  % NAME THIS PROGRAM PARRY %
	IF SUMEX AND (A=9) THEN ONEDIA_NIL ELSE ONEDIA_T;
	IF (A2) THEN LOWMAN_T ELSE LOWMAN_NIL;
	IF (A=1) OR (A=3) THEN TRACEVFLAG_NIL ELSE TRACEVFLAG_T;
	END;

EXPR SUMEXALLOW();
	BEGIN NEW FILCHAN,FLAG,STATUS;
	FILCHAN_EVAL<'INPUT,DIAFILEAREA,'QPARRY>;
	INC(FILCHAN,NIL);
	STATUS_READ(); FLAG_READ();
	IF STATUS='OK THEN INC(NIL,T) ALSO RETURN FLAG;
	INC(NIL,NIL);
	EVAL < 'OUTPUT, DIAFILEAREA, 'QPARRY >;
	OUTC(T,NIL); PRINT(0); PRINT FLAG; OUTC(NIL,T);   % RESET FILE%
	IF STATUS=0 THEN SLEEP(10) ALSO EXIT() ALSO CAR NIL;
	RETURN STATUS;
	END;

EXPR MEASURE(L,M);  % USED IN INFERENCES TO MEASURE QUANTITIES %
	IF NUMBERP(L)  NUMBERP(M) THEN GREATERP(L,M)  ELSE EQ(L,M);

EXPR INF(A); 	% INITIALIZATION ROUTINE %
	BEGIN NEW B,VA;  
	ALLOWRUN();
	INPUTFILE_A; LAMDA_8; NOTSAVED_'NDIA;
	INITFN 'EXIT;
	ANALYZE(NIL);
	GCGAG(NIL);
	RUNTIM(NIL);
	VA _ NIL;   % VA IS FOR STARTING A PARRY WITHOUT INITIAL QUESTIONS %
	IF VA THEN INITPARAMS() ALSO INIT();
	IF VA  THEN INITPARAMS1() ALSO  INITPARAMS2() ALSO INIT();
	IF SAVEFILE THEN INITFILE( (IF VA THEN 'VA) CAT
	  ", TRACEV = " CAT TRACEV CAT ", WINDOWS = " CAT WINDOWS CAT ", PARANOIA = "
		CAT (IF WEAK THEN 'WEAK ELSE IF HURT=0 THEN 'MILD ELSE 'STRONG) );
	IF WINDOWS THEN WININIT();
	PARRY();
	END;

EXPR GN(); BEGIN  GCGAG(NIL);	INITFN 'GN2; END;
EXPR GN2();  INF( 'PDATZ );	% THE ROUTINE THAT INITFN STARTS UP %

EXPR INITPARAMS1();	% INITIALIZE PARAMS FOR VA INTERVIEWS %

	BEGIN SUPPRESS_T;  WEAK_NIL;
	ANGER_ANGER0_FEAR_FEAR0_MISTRUST_MISTRUST0_HURT_HURT0_0;
	TRACEV_NIL; SAVEFILE_T;
	END;

EXPR TIMESTAT();  % THIS KEEPS THE TIME FOR NET AND NONNET JOBS %
	< IF LOWMAN THEN 'NET ELSE 'NONNET, RUNTIM(T) > ;

EXPR ANDDO(L,M); L;

EXPR WINDOW(N,F,L); 
	BEGIN IF TRACEV='ALL THEN TWINDOW(N,F,L);  RETURN L; END;
EXPR WINDOWSET(N); N;
EXPR WINDOWPRINT(A,B,C,D); NIL;

EXPR TWINDOW(N,FLAG,L);  % PRINTS OUT WINDOW STUFF FOR A TELETYPE %
	BEGIN NEW A;
	A_ASSOC ( N, '(	( 2 . "Input:	" )
			( 3 . "Respelled:  " )
			( 4 . "Canonical form:  " )
			( 5 . "Segmented:  " )
			( 7 . "Simple patterns:  " )
			( 9 . "Result:  " )
			( 33 . "Preprocess:  " )
			( 36 . "Inferences succeeded:  " )
			( 37 . "New beliefs:  " )
			( 40 . "Emotions:  " )
			( 42 . "Intentions:  " )
			( 44 . "Action:  " )		) );
	IF A  (FLAG 
 (N=9) 
 (N=36) 
 (N=42)) THEN PRINC CDR A  ALSO PRINTSTR L;
	END;

EXPR SUMEX1();
	% THIS ROUTINE SETS UP A WORKING VERSION OF PARRY WHICH WILL ALMOST RUN ON SUMEX %
	BEGIN
	INITFN(NIL);
	SYNNYM('A);	% READS IN SYNNYM.PAR %
	SPAT('(A));	% READS IN SPATS.PAR %
	CPAT('(A));	% READS IN CPATS.PAR %
	DSKLOC('A);	% READS IN PDATX.PAR %
	ONEDIA_T; SUMEX_T; TRACEVFLAG_NIL;
	PUTPROP('SWAPP, '(LAMBDA NIL T), 'EXPR);
	PUTPROP('WINXIT, '(LAMBDA NIL T), 'EXPR);
	PUTPROP('PPNUU, '(LAMBDA NIL 0), 'EXPR);
	PUTPROP('TTYUU, '(LAMBDA NIL 0), 'EXPR);
	INITFN 'GN2;
	END;

EXPR SUMEX2();
	BEGIN 
	DIAFILEAREA_INPUTFILEAREA_ < READLIST '(F A U), READLIST '(G H T) > ;
	END;

%  CHECKINPUT  LOOKS THRU INPUT FOR SWEARING, INSULTS, NEGATIVE WORDS %

EXPR CHECKINPUT(L);	% RETURNS ONLY IMPORTANT CHANGED INPUT %
 
	BEGIN NEW A,B,C,D;  BADINPUT_NIL; 
	IF ( LOWMAN  INPUTNO20  (RUNTIM(T)60000) )
	  OR ( INPUTNO30  MEMSIZEOK()  PROG2(GC(),T)  MEMSIZEOK() )
	  THEN A_CHOOSE 'TIRED ALSO B_'(INTERVIEW HAS BEEN LONG ENOUGH)
	  ALSO ADDTO('PEXIT2,10)  ALSO ENDE_T
	  ALSO ERROR("INPUTNO= " CAT INPUTNO CAT "  SHORT OF SPACE ",
	    LENGTH(NUMVAL 13) CAT " FS, FW "  CAT LENGTH(NUMVAL 14) );
	IF A  (B_GET(L,'FX))  ERRSET((B_EVAL(B)),NIL) THEN A_B;
		% FX HAS A FEW KLUDGES TO NOT ALLOW SOME INPUTS %

	IF L  GET(L, 'UNIT)  A THEN A_'DONE;

	IF A  ASSOC('SHIT, INPUTQUES) THEN A_ CHOOSE 'SWEARING ALSO BADINPUT_T 
		ALSO B_'EXPLETIVES;
	IF A  ASSOC('CRAZY, INPUTQUES) OR ASSOC('BAD, INPUTQUES) OR ASSOC('ODD, INPUTQUES)
		THEN  BADINPUT_T ALSO B_'(BAD ASSOCIATIONS WITH INPUT WORDS);

	C_GIBBERISH-OLDGIBB; D_LENGTH(SSENT);
	IF A AND ( (C5)  (D15) OR (C3)  (D7) OR (C2)  (D3) )
		THEN A_CHOOSE 'GIBBERISH ALSO B_'(TOO MANY UNRECOGNIZED WORDS);
	IF GIBBERISH20 THEN DOSPELL_NIL;
	IF A  (MISSPELLED6)  (MISSPELLED-OLDMISS3) THEN A_CHOOSE 'MISSPELLED
	  ALSO B_'(TOO MANY MISSPELLED WORDS);

	IF EQUAL(SSENT,PREVOUTPUT @ '(PD)) THEN ADDTO('PGAMES,5)
	ELSE IF PREVSSENT  (PREVSSENT='TWICE)  EQUAL(PREVSSENT,SSENT) THEN ADDTO('PGAMES,5)
	ELSE IF EQUAL(PREVSSENT,SSENT) THEN PREVSSENT_<'TWICE,SSENT>
	ELSE PREVSSENT_SSENT;

	OLDGIBB_GIBBERISH;  OLDMISS_MISSPELLED;
	IF B THEN B_'NORMAL;  	WINDOW(33,T,B);
	IF A='DONE THEN A_NIL;  RETURN A;   % WILL RETURN NIL IF ANAPH OR NORMAL %
	END;


% THE FOLLOWING ARE SEMANTIC FUNCTIONS WHICH ARE CALLED FROM THE MEMORY BY
	SPECIFIC INPUT REFERENCES %

EXPR APOLOGY();

	BEGIN
	IF MISTRUST9 THEN AJUMP_0.2 ELSE ANGER_ANGER-1;
	RETURN IF BL 'DHOSTILE  BL 'DDKNOW THEN CHOOSE 'SORRY
	  ELSE CHOOSE 'ACCUSE;
	END;

EXPR HELPER();
	IF BL 'DHOSTILE 
 BL '?*DHELPFUL 
 BL 'DDHARM THEN CHOOSE 'CAUTION;

EXPR KNOWER();

	IF BL 'DDHARM 
 BL 'DHOSTILE 
 BL '?*DDHELP THEN CHOOSE 'HOSTILEREPLIES
	ELSE IF BL '?*DTRUSTWORTHY 
 BL '?*DHONEST THEN CHOOSE '?*DHONEST
	ELSE IF BL 'DDHELP THEN CHOOSE 'DDHELP
	ELSE IF BL 'DEXCITED THEN CHOOSE 'DEXCITED
	ELSE IF BL '?*DINITIATING THEN CHOOSE 'DBAD
	ELSE NIL;

EXPR LEADIN();	
	( ?!ANAPHLIST_?!ANAPHLISTOLD_NIL ) 
	( IF DELFLAG THEN DELSTMT() ELSE 
		IF FLARE'INIT THEN FLSTMT(GET(FLARE,'SET)) 
		ELSE IF INTENT='PINTERACT THEN CHOOSE 'UPSET ) ;

EXPR ALOOF();
	IF BL 'DHOSTILE 
 BL '?*DHELPFUL 
 BL 'DDHARM THEN CHOOSE 'ALOOF;

EXPR ALOOF2();
	IF BL 'DHOSTILE 
 BL '?*DHELPFUL 
 BL 'DDHARM THEN CHOOSE 'ALOOF2;

EXPR NAMECHECK();
	BEGIN NEW A;
	IF (A_ASSOC('NAME, INPUTQUES))  (A_ASSOC('YOU, INPUTQUES))
	   A='YOUR THEN RETURN CHOOSE 'DONTREMEMBER;
	END;

EXPR MEMSIZEOK();

	(LENGTH (NUMVAL 13)  1500)  (LENGTH (NUMVAL 14)  300);

EXPR OPINION();

	BEGIN NEW A;
	IF BL 'DDHARM 
 BL 'DHOSTILE 
 BL '?*DDHELP THEN A_CHOOSE 'HOSTILEREPLIES
	ELSE IF BL '?*DTRUSTWORTHY 
 BL '?*DHONEST THEN A_CHOOSE '?*DHONEST
	ELSE FOR NEW I IN '(DABNORMAL DEXCITED DRATIONAL DHELPFUL DSOCIABLE)
		DO IF BL I THEN A_CHOOSE I   UNTIL A;
	RETURN A;
	END;

EXPR SELFFEELING();

	IF ANGER10 THEN CHOOSE 'ANGRY 
	ELSE IF FEAR10 THEN CHOOSE 'FEARFUL
	ELSE IF BL 'INTHELPFUL THEN CHOOSE 'GOOD;

EXPR INTERVIEW();
	IF BL 'INTBAD THEN CHOOSE 'INTBAD 
	ELSE IF BL 'INTHELPFUL THEN CHOOSE 'PRAISE;


% AFFECT, INTENTION, AND INTENTION ROUTINES %

% AFFECT EXPRESSES EMOTIONS BASED ON THE INPUT RECOMMENDATION, THE CURRENT VALUES,
	  THE TOPIC, AND CURRENT BELIEFS %
EXPR AFFECT();

	BEGIN  NEW A,B;  ACTION_NIL; INTENT_NIL;
%	(ACTION_GET(REACTTO, 'IN))  (ACTION_EVAL(ACTION)) ;  %
	IF GET(STOPIC, 'SET) MEMBER SENSITIVELIST THEN AJUMP_0.2;
	RAISE();
	IF (FEAR18) OR (ANGER18.8) THEN ADDTO('PEXIT2,10);
  % ** THE TEST FOR ACTIVATING THE PARANOID MODE ******* %
	IF (VERSION='STRONG)  ((HURT7)
(HJUMP(HJUMP0.1)) )
	  
 (VERSION='MILD)  (HURT8)
	  THEN ADDTO('PPARANOIA,5) ANDDO PARANOIA() ANDDO (INTENT_'PPARANOIA)
	 ELSE IF (FJUMP  (FJUMP0.01)) 
 (AJUMP  (AJUMP0.01)) 
 (FEAR14) OR (ANGER14) 
		OR STOPIC='STRONGFEELINGS OR ACTION   THEN ADDTO('PSTRONGFEEL,5)
			ANDDO (INTENT_'PSTRONGFEEL);
	FOR NEW I IN '((FJUMP.FEAR)(AJUMP.ANGER)(HJUMP.SHAME)) DO
	 IF EVAL(I) THEN WINDOW(40,T,<I,'RAISED> @
	   (IF A_GET(I,'INF) THEN ( <'FROM,A> ANDDO PUTPROP(I,NIL,'INF)) )    )  ;
	IF FJUMP  AJUMP  HJUMP THEN WINDOW(40,T,'(NO CHANGE));
	IF WINDOWS THEN WPRINTVARS();
	RETURN ACTION;
	END;

EXPR INFEMOTE(BEL,L,VAL);		% L LOOKS LIKE ((HJUMP 0.5) ... )  %
	FOR NEW A IN L DO 
	BEGIN NEW B,C,D;  B_A; C_A;
	IF B='HJUMP THEN PARBEL_ BEL CONS PARBEL;
	IF B='HJUMP AND WEAK THEN C_C/2;	% IF WEAK PARANOIA THEN DONT LET HJUMP BE STRONG %
	IF NUMBERP(VAL) THEN C_C/2;	% THIS CAME FROM ADDTO, NOT ASSERT -- WEAKEN THE EFFECT %
	D_ZERONIL( EVAL(B) );
	IF CD THEN PUTPROP(B,BEL,'INF);
	SET( B, MAX(D,C) );
	END;

EXPR ZERONIL(L);  IF L THEN 0 ELSE L;

EXPR INTENTION();	% CALCULATES THE CURRENT INTENTION %

	BEGIN NEW A;
	FOR NEW I IN INTLIST DO  IF GET0(I,'NTRUTH)5 THEN A_WINDOW(42,NIL,I);
	IF INTENT 
 (A='PEXIT) 
 (A='PEXIT2) THEN INTENT_A;  
	WINDOW(42,NIL, " : " CAT INTENT);
	END;

% DOINTENT  PERFORMS THE CURRENT INTENTION, CALCULATES AN ACTION, AND RETURNS A  %
% 	CHECKS INTENTS, RETURNS NEW VALUE FOR FOUND IN REACT, ELSE NIL %

EXPR DOINTENT();

	BEGIN  NEW I,A; 
	INTENTION();
	IF PRINTALL THEN PRINT(INTENT) ALSO TERPRI NIL;
	I_INTENT;
	A_GET(INTENT,'TH);  PROVEL_PROVEL @ A;  PROVE(); 

	A_ERRSET( IF I THEN EVAL<I>, NIL); 
	IF ATOM A THEN ERROR("IN DOINTENT BAD FN",I)  ALSO A_NIL  ELSE A_A;
	OLDINTENT_INTENT;
	WINDOW(44,T,IF CHOSEN THEN CHOSEN ELSE 'ANSWER); % **** ACTION WINDOW **** %
	RETURN A;
	END;

% THE FOLLOWING ARE INTENTION ROUTINES, ONE PER INTENTION %

EXPR PINTERACT();	IF FLARE'INIT THEN ADDTO('PHELP,5);
EXPR PGAMES();	CHOOSE 'GAMES ANDDO ADDTO('PGAMES,-2);
EXPR PFACTS();	CHOOSE 'MOVEON ANDDO ADDTO('PFACTS,-2);
EXPR PMAFIA();
	(IF FEAR10 THEN CHOOSE 'PANIC ELSE
	 IF BL 'DGAMES THEN NIL ANDDO (ANGER_ANGER-3)
		 ELSE CHOOSE 'PROBE)   ANDDO ADDTO('PMAFIA,-2);

EXPR PHELP();		IF DELFLAG THEN ADDTO('PTELL,5)
	ELSE ( IF FLARE='INIT  
	 ( GET(STRUC,'UNIT) 
 REACTTO 
 ('LEADIN=GET(REACTTO,'CLASS))   )
		THEN ADDTO('PHELP,-5) ALSO FLARELEAD(CHOOSELEAD())   )  ;

EXPR PSTOP(); NIL;
EXPR PTELL(); NIL;
EXPR PSTRONGFEEL();	STRONGFEEL();

EXPR PCONFIRM();	
	IF BL 'NDELUSIONS  BADINPUT THEN (CHOOSE 'PRAISE ANDDO ADDTO('PSTOP,3))
	ELSE	IF BADINPUT  (GET(REACTTO,'UNIT) 
 REACTTO)
   	  THEN CHOOSE 'FEELER ANDDO (ADDTO('PSTOP,2) ANDDO ADDTO('PCONFIRM,-5));

EXPR PSELF();	CHOOSE 'IYOUME ANDDO ADDTO('PSELF,-3);
EXPR PEXIT();	CHOOSE 'OPINION ANDDO ADDTO('PEXIT2, 10);
EXPR PEXIT2();	CHOOSE(IF ANGER9 THEN 'MADEXIT ELSE
		IF FEAR9 THEN 'FEAREXIT ELSE 
		IF MEMSIZEOK() THEN 'TIRED ELSE 'EXIT) ANDDO ENDE_T;


EXPR LULL();  % RETURNS T IF THERE IS A LULL IN THE CONVERSATION %
	% IF MISC IS USED AND LULL(), THEN WILL JUMP BACK TO FLARES OR DELNS %
	IF OLDTOPIC='ANAPH OR OLDTOPIC='IYOUME THEN T
	ELSE IF LENGTH(SSENT)10 THEN NIL
	ELSE EQ(1, RANDOM(2));

EXPR PPARANOIA();

	BEGIN NEW A;
	ADDTO('PPARANOIA,-5);
	IF HURT10 THEN HURT _ 10 + (HURT-10) * 3 / 5;
	A_ASSOC( GET(REACTTO,'CLASS),
	   '((INSULT.PANGER)(CRAZY.AVOIDANCE)(THREAT.PANIC)(ATTACK.LIE)(FEELINGS.LIE)
	  (WEAKINSULT.PPERS)(COMPLEMENT.PDISTANCE)(DISBELIEF.PBELIEVEREPLIES)(APOLOGY.PACCUSE)));
	IF A THEN A_ASSOC( CARN GET(REACTTO,'SF),
		'((HELPER.PCAUTION)(ALOOF.PALOOF)(ALOOF2.OPINION)));
	IF A THEN A_A;

	IF A  (STOPIC='MAFIA) THEN A_(IF DELFLAG THEN 'AVOIDANCE ELSE 'NOMAFIA);
	IF A  (FEAR14) THEN
	  A_(IF TYPE='Q THEN 'PTHREATQ ELSE 'PAFRAID) ALSO ADDTO('PEXIT,1);
	IF A THEN A_(IF HURT10 THEN 'ALIEN ELSE 'PHOSTILEREPLIES) ALSO ADDTO('PEXIT,1);
	RETURN CHOOSE A;
	END;


EXPR STRONGFEEL(); % THIS IS INVOKED ON EITHER FJUMP, AJUMP, OR HIGH EMOTIONS %
	% THIS RETURNS AN ACTION APPROPRIATE TO TAKE CARE OF THE EMOTIONS %

	BEGIN NEW A,B;	ADDTO('PSTRONGFEEL,-5); ADDTO('PMAFIA,-5);
	IF A_GET(REACTTO,'CLASS) THEN NIL
	ELSE IF B_ASSOC(A, '((INSULT.ANGER)(WEAKINSULT.PERS)(COMPLEMENT.DISTANCE)
		(SENSATTITUDE.SENSREPLIES)(CRAZY.HOSTILEREPLIES)(THREAT.PANIC)
		(DISBELIEF.BELIEVEREPLIES)(APOLOGY.ACCUSE)(LYING.BELIEVEREPLIES) ) )
		THEN B_B
	ELSE IF A='DISTRUST THEN B_(IF FEAR+ANGER14 THEN 'TURNOFF ELSE 'ALOOF)
	;
	IF ANGER14  FEAR14 THEN RETURN CHOOSE B;
	IF FJUMP  AJUMP  MEMQ(STOPIC, '(BYE MAFIA GAMES IYOUME FEELINGS STRONGFEELINGS))
	  THEN RETURN( IF FEAR14 THEN FEARMODE() ELSE ANGERMODE() );
	RETURN CHOOSE B;
	END;

EXPR PARANOIA();

	BEGIN NEW A;
	ASSERT('?*DTRUSTWORTHY);
	FOR NEW I IN PARBEL DO  IF MEMQ(I,'(LYING LOSER CRAZY DUMB))
	  THEN ADDTO(I,-1) ALSO A_I;
	IF A THEN A_ASSOC(A,
	 '( (LYING . ?*DHONEST)(LOSER . ?*DSOCIABLE)(CRAZY . DABNORMAL) (DUMB . ?*DCHELP) ))
	  ALSO ASSERT(A);
	PARBEL_NIL;
	END;

END.
COMMENT    VALID 00003 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00002 00002	BEGIN   % THIS FILE HAS FUNCTIONS FOR THE WINDOW FEATURE      %
C00008 00003		% INITIALIZING WINDOWS %
C00012 ENDMK
C;

BEGIN   % THIS FILE HAS FUNCTIONS FOR THE WINDOW FEATURE      %

SPECIAL WINDOWS;
NEW     WINDOWS;

DEFINE CAR PREFIX , CDR PREFIX , PROG2  3 3, SET0   5 5, CONS  86 83,
	THEN , ELSE \, STOREBYTE  5 5, CARN PREFIX, CHOOSE PREFIX, BL PREFIX;

EXPR PMCLR();
	BEGIN WINSUP(T);
	FOR NEW I_1 TO 29 DO IF (I=9) THEN WINREL(I);
	WINDIS(); WINSUP(NIL);
	END;

EXPR MMCLR();
	BEGIN WINSUP(T);
	FOR NEW I_30 TO 64 DO WINREL(I);
	WINDIS(); WINSUP(NIL);
	END;

EXPR WINDOW(N,FLAG,L);

	BEGIN NEW M;  
	IF TRACEV='ALL THEN TWINDOW(N,FLAG,L) ALSO RETURN L;
	IF WINDOWS THEN RETURN L;
	M_IF STRP L THEN L ELSE STR L;
	IF SPECWIN(N) THEN INTEST();
	WINOUT(N,FLAG,M);
	IF (N=9) 
 (N=49) THEN WINSUP(NIL) ALSO WINDIS();
	RETURN L;
	END;

EXPR SPECWIN(N); (N=1) OR (N=31);

EXPR WININIT();
	BEGIN   WINDOWS_T;
	WINHELP(); WINDOW(2,T,NIL);
	WINXIT(); WINSIL(30); WINSIZ(4,2);  WINDIS();
	TRACEV_NIL;
	END;

EXPR WINHELP(); 
 	PRINTSTR(
"NEW EASIER WINDOW COMMANDS:
    ESC I   IS A BINARY SWITCH TO HALT AND CONTINUE PROCESSING 
   YOU ARE NOW HALTED. TYPE  ESC I  TO CONTINUE.  " );

EXPR WINDOWSET(N);

	BEGIN  IF WINDOWS THEN RETURN NIL;
	IF N = 1  THEN MMCLR()
		ALSO PMWIN();
	IF N = 2  THEN SLEEP(1) ALSO PMCLR()
		ALSO MMWIN2()
		ALSO WINDOW(32,T,PMINPUT) ALSO WINDOW(32,NIL,GET(PMINPUT,'BONDVALUE))
		ALSO WINDIS() ALSO WINREL(9) ALSO WINDIS()
		ALSO MMWIN();
	END;

EXPR TWINDOW(N,FLAG,L);  % PRINTS OUT WINDOW STUFF FOR A TELETYPE %
	BEGIN NEW A;
	A_ASSOC ( N, '(	( 2 . "Input:	" )
			( 3 . "Respelled:  " )
			( 4 . "Canonical form:  " )
			( 5 . "Segmented:  " )
			( 7 . "Simple patterns:  " )
			( 9 . "Result:  " )
			( 33 . "Preprocess:  " )
			( 36 . "Inferences succeeded:  " )
			( 37 . "New beliefs:  " )
			( 40 . "Emotions:  " )
			( 42 . "Intentions:  " )
			( 44 . "Action:  " )		) );
	IF A  (FLAG 
 (N=36) 
 (N=42)) THEN PRINC CDR A  ALSO PRINTSTR L;
	END;

	% INITIALIZING WINDOWS %

EXPR PMWIN();
	BEGIN NEW SENTL;
	WINSUP(T);
	SENTL_76; TEN();
	WINSIL(30);
	WINSIZ(4, 2);

	WINOPN(1, 9, 0, 16, 3);
	WINLBL(1, 'PROCESS);
	WINOPN(2, 0, 3, SENTL, 3);
	WINLBL(2, "INPUT SENTENCE");
	WINDIS(T);

	WINOPN(11, 12, 6, 16, 3);
	WINLBL(11, "WORD");
	WINOPN(12, 42, 6, 22, 3);
	WINLBL(12, "RESPELLED");
	WINOPN(3, 0, 9, SENTL, 3);
	WINLBL(3, "RESPELLED INPUT");
	WINOPN(13,  6, 12, 16, 3);
	WINLBL(13, "WORD");
	WINOPN(14, 27, 12, 22, 3);
	WINLBL(14, "IDIOMS FOUND");
	WINOPN(15, 54, 12, 16, 3);
	WINLBL(15, "ANAPHS FOUND");

	WINOPN(4, 0, 15, SENTL, 3);
	WINLBL(4, "CANONIZED INPUT");
	WINOPN(5, 0, 18, SENTL, 3);
	WINLBL(5, "SEGMENTED INPUT");

	WINOPN(16, 5, 21, 33, 3);
	WINLBL(16, "SIMPLE PATTERN");
	WINOPN(17, 42, 21, 33, 3);
	WINLBL(17, "PATTERNS TRIED");
	WINOPN(7, 3, 24, 60, 3);
	WINLBL(7, "MATCHED SIMPLE PATTERNS");
	WINOPN(8, 0, 27, 30, 3);
	WINLBL(8, "COMPOUND PATTERN");
	WINDIS();

	WINOPN(9, 37, 27, 38, 3);
	WINLBL(9, "INPUT RECOGNIZED");
	WINDIS();

	WINSUP(NIL);
	END;

EXPR MMWIN();
	BEGIN NEW SENTL,HSENTL;
	WINSUP(T);
	SENTL_76; HSENTL_36;  TEN();

	WINOPN(51, 41, 3, 19, 3);
	WINLBL(51, "TOPIC");
	WINOPN(52, 62, 3, 14, 3);
	WINLBL(52, "ANAPHORA");

	WINOPN(33, 4, 6, SENTL-8, 3);
	WINLBL(33, "PREPROCESS RESULTS");

	WINOPN(35, 0, 9, HSENTL, 6);
	WINLBL(35, "INFERENCES TRIED");
	WINOPN(36, 38, 9, HSENTL, 6);
	WINLBL(36, "INFERENCES SUCCEEDED");
	WINOPN(37, 0, 15, HSENTL+17, 4);
	WINLBL(37, "NEW BELIEFS");

	WINOPN(40,  5, 19, 43, 5);
	WINLBL(40, "AFFECT CHANGES");
	WINOPN(41, 55, 17, 22, 6);
	WINLBL(41, "CURRENT AFFECTS");
	WINOPN(42, 0, 24, HSENTL+17, 3);
	WINLBL(42, "INTENTIONS");

	WINOPN(44, 58, 24, 16, 3);
	WINLBL(44, "ACTIONS");

	WINDIS();

	WINOPN(49, 0, 27, SENTL, 3);
	WINLBL(49, "OUTPUT SENTENCES");

	WINDIS();
	WINSUP(NIL);
	END;

EXPR MMWIN2();
	BEGIN  WINSUP(T);
	WINOPN(31, 9, 0, 16, 3);
	WINLBL(31, 'PROCESS);
	WINOPN(32, 0, 3, 38, 3);
	WINLBL(32, "INPUT STRUCTURE");
	END;

END.
EOF 
