IFN FTVER,<			;ONLY LIST SAIO IF ASSEMBLING DEFAULT VERSION
	.CREF
	LIST>
SUBTTL	Top level driver and command scanner

BEGBTS:	MOVEI	P,PDLSTK-1(R)	;RE-INIT THE PDL POINTER
	MOVEI	C,[ASCIZ \

*\](R)
	PUSHJ	P,$STRO(R)	;TELL OPERATOR THAT WE`RE READY FOR A COMMAND
	TLZ	BF,-1		;CLEAR THE TEMPORARY FLAGS
	SETZB	CM,A.ZERO(R)	;CLEAR CMD LEVEL AND FIRST WORD OF ZERO AREA
	HRLI	T1,A.ZERO(R)	;ZERO MEMORY FROM HERE
	HRRI	T1,A.ZERO+1(R)
	BLT	T1,Z.ZERO(R)	; TO THERE
IFN <4-FTVER>,<			;IF NOT ASSEMBLING USER LEVEL VERSION
	MOVE	T1,[POINT 7,INPBFR(R),6](R) ;GET BYTE PTR TO TYPE AHEAD BUFFER
	MOVEM	T1,BFRTIP(R)	;SET UP THE INPUT PUTTER
	MOVEM	T1,BFRTIT(R)	; AND THE INPUT TAKER
	MOVE	T1,[JSR	CTYINT(R)](R) ;SET UP INTERRUPT INST TO HANDLE
	MOVEM	T1,40+<CTYPIA_1> ; CTY I/O INTERRUPTS
	CONO	TTY,CTYPIA	;PUT THE CTY ON THE PI SYSTEM
	CONO	PI,1B25!1B28!1B<28+CTYPIA>> ;AND ARM IT FOR INTERRUPTS
	MOVEI	M,CMDBFR(R)	;GET ADDRESS OF WHERE TO STUFF COMMAND
	PUSHJ	P,GETCMD(R)	;PARSE OFF THE OPERATOR`S COMMAND LINE
	  PUSHJ	P,@SWTADR(R)	;GO EXECUTE THIS COMMAND
	JRST	BEGBTS(R)	;AND LOOP BACK FOR NEXT COMMAND

;Routine to parse off a command line

GETCMD:	HRLI	CM,(M)		;SAVE STARTING WORD ADDR OF NEXT CMD ELEMENT
	HRLI	M,(POINT 7)	;CONVERT WORD ADDR INTO A BYTE POINTER
	MOVSI	NC,-CH%FLD	;SET UP MAX CHAR COUNT PER COMMAND FIELD
	TLNE	BF,(FL.RFS)	;ARE WE RECOGNIZING THE ENTIRE FILE SPEC?
	  POPJ	P,		;YES, GO RECOGNIZE NEXT (DEFAULT) COMMAND FIELD
GTCMD1:	PUSHJ	P,GETCHR(R)	;GET A CHAR (FROM MONITOR CMD OR CTY)
	TLZE	BF,(FL.LIT)	;WAS LAST CHARACTER A ^V?
	  JRST	GTCMD2(R)	;YES, THEN TAKE THIS CHAR LITERALLY
	MOVEI	T1,(B)		;GET A COPY OF THE CHARACTER
	ROT	T1,-1		;HALVE CHAR CODE AND SET SIGN BIT IF ODD
	ADDI	T1,CHRTAB(R)	;DOUBLE INDEXING WOULD BE NICE HERE
	TLNN	T1,(1B0)	;IS THIS AN EVEN CHARACTER (I.E. BIT 35 OFF)?
	 SKIPA	T1,(T1)		;YES, FLAGS ARE ALREADY IN LH
	  MOVS	T1,(T1)		;NO, GET FLAGS INTO LH
	TLNE	T1,CH.LCL	;IS THIS A LOWER CASE CHARACTER?
	  TRZ	B," "		;YES, WELL NOW IT AIN`T
	LDB	T2,[POINT 7,T1,17](R) ;GET THE SPECIAL CHAR DISPATCH INDEX
	JUMPE	T2,GTCMD2(R)	;JUMP IF THIS IS NOT A SPECIAL CHARACTER
	ADDI	T2,CHRDSP-1(R)	;GET DISPATCH TABLE INDEX FOR THIS SPECIAL CHAR
	TLNE	T1,CH.TYP	;SHOULD WE TYPE THIS SPECIAL CHARACTER ANYWAY?
GTCMD2:	  PUSHJ	P,TYPCHR(R)	;YES, GO ECHO THIS CHAR (IN ARROW MODE)
	JUMPL	T1,BADCMD(R)	;ISSUE ERROR IF THIS IS AN ILLEGAL CHARACTER
	JUMPE	T2,.+2(R)	;SKIP IF THIS IS NOT A SPECIAL CHARACTER
	 TLNE	T1,CH.DLM	;IF DELIMITER, TREAT THIS CHAR AS PART OF FIELD
	  IDPB	B,M		;STUFF THIS CHAR INTO THE COMMAND BUFFER
	JUMPN	T2,@(T2)	;IF SPECIAL CHAR THEN DISPATCH TO ITS ROUTINE
	AOBJN	NC,GTCMD1(R)	;LOOP BACK FOR NEXT CHAR IF FIELD NOT FILLED
	JRST	BADCMD(R)	;ISSUE ERROR IF TOO MANY CHARS IN THIS FIELD
SUBTTL	Routines to process the special characters

;Routine to process a ^V (take next character literally)

CHRLIT:	TLO	BF,(FL.LIT)	;TELL COMMAND SCANNER TO JUST EAT NEXT CHAR
	SETZB	T1,T2		;NO FLAGS OR DISPATCH INDEX FOR LITERAL CHARS
	JRST	GTCMD1(R)	;GO EAT THE NEXT CHARACTER

;Routine to process a ^R (retype current line)

RETYPE:	PUSHJ	P,TYPCMD(R)	;USE COMMON ROUTINE TO RETYPE THE COMMAND LINE
	JRST	GTCMD1(R)	;GO GET THE NEXT CHARACTER

;Routine to process a ^A or DEL (rubout last character)

RUBOUT:	TRNE	NC,-1		;ANY CHARS IN THIS (INCOMPLETE) FIELD?
	  JRST	RBOUT1(R)	;YES, NO NEED TO PROCESS LAST COMPLETED FIELD
	TRNN	CM,-1		;ARE THERE ANY COMPLETED FIELDS?
	  JRST	RNGBEL(R)	;NO, JUST RING THE BELL IF NOTHING TYPED YET
	PUSHJ	P,BACKUP(R)	;YES, BACK UP INTO THE LAST (COMPLETED) FIELD
RBOUT1:	MOVEI	B,"\"		;TYPE THE RUBOUT INDICATOR
	PUSHJ	P,$TTYO(R)
	LDB	B,M		;GET THE CHARACTER TO BE DELETED
	PUSHJ	P,TYPCHR(R)	;AND TYPE IT (IN ARROW MODE)
	PUSHJ	P,DECPTR(R)	;DECREMENT THE COMMAND BYTE POINTER
	PUSHJ	P,CHKDLM(R)	;GO CHECK FOR THE IMPLICIT DELIMITER
	JRST	GTCMD1(R)	;AND LOOP BACK FOR NEXT CHARACTER

;Routine to process a ^W (delete current field up to last delimiter)

DELFLD:	MOVEI	T1,(CM)		;GET THE COMMAND LEVEL OF LAST COMPLETED FIELD
	TRNN	NC,-1		;ANY CHARS IN CURRENT (INCOMPLETE) FIELD?
	  JUMPE	T1,RNGBEL(R)	;RING THE BELL IF NOTHING TYPED YET
	MOVEI	B,"_"		;TYPE THE DELETE FIELD INDICATOR
	PUSHJ	P,$TTYO(R)
	MOVS	M,CM		;GET CURRENT FIELD`S ADDR INTO RH
	TLZE	BF,(FL.SWT)	;IS THIS COMMAND JUST A SWITCH?
	  TRZ	CM,-1		;YES, THEN THERE ARE NO COMPLETED FIELDS NOW
	TLZN	BF,(FL.DIR)	;ARE WE IN THE MIDDLE OF A DIRECTORY SPEC
	 TRNN	CM,-1		; OR ARE THERE NO COMPLETED FIELDS YET?
	  JRST	GETCMD(R)	;YES, THEN RETURN NOW
	CAIN	T1,CM%VER	;IS LAST COMPLETED FIELD THE VERSION NUMBER?
	 TRNE	NC,-1		;YES, ANY CHARS IN THE SWITCH FIELD?
	  JRST	DLFLD1(R)	;HERE IF NOT VERSION OR NON-NULL SWITCH FIELD
	PUSHJ	P,BACKUP(R)	;OPEN UP THE VERSION FIELD (IT HAS NO DELIMITER)
	MOVEI	T1,(CM)		;AND GET COMMAND LEVEL OF LAST COMPLETED FIELD
DLFLD1:	PUSH	P,T1		;SAVE CMD LEVEL OF FIELD WE`RE BACKING INTO
	PUSHJ	P,BACKUP(R)	;RE-OPEN THE LAST COMPLETED COMMAND FIELD
	POP	P,T1		;GET THE COMMAND LEVEL OF FIELD BACKED INTO
	CAIE	T1,CM%VER	;DID WE JUST BACK UP INTO THE VERSION SPEC?
	  PUSHJ	P,DECPTR(R)	;NO, RUBOUT THE LAST CHAR (I.E. DELIMITER)
	PUSHJ	P,CHKDLM(R)	;GO CHECK FOR THE IMPLICIT DELIMITER
	JRST	GTCMD1(R)	;AND LOOP BACK FOR NEXT CHARACTER
;Routine to back up into previous command field (called via ^A, DEL, and ^W)

BACKUP:	MOVEI	T1,(CM)		;ISOLATE THE CURRENT COMMAND LEVEL
	ADDI	T1,ELMTAB-1(R)	;GET ADDR OF LAST ELEMENT`S LENGTH,,ADDR
	SKIPN	T2,(T1)		;WAS THIS ELEMENT SPECIFIED BY THE OPERATOR?
	  SOJA	T1,.-1(R)	;NO, KEEP LOOKING FOR LAST SPECIFIED ELEMENT
	SETZM	(T1)		;YES, FLAG THAT THIS FIELD IS NOW INCOMPLETE
	MOVSS	T2		;GET ADDR,,LENGTH OF FIELD WE`VE BACKED INTO
	MOVEI	T3,(T1)		;GET THIS ELEMENT`S COMMAND LEVEL
	SUBI	T3,ELMTAB-1(R)
	CAIN	T3,CM%DIR	;DID WE BACK UP INTO THE DIRECTORY SPEC?
	  TLO	BF,(FL.DIR)	;YES, THEN FLAG DIRECTORY AS NOW OPEN
	CAIN	T3,CM%VER	;DID WE BACK UP INTO THE VERSION SPEC?
	  SOJ	T2,		;YES, VERSION HAS NO (EXPLICIT) DELIMITER
	SOJE	T3,BCKUP1(R)	;BACK UP TILL WE FIND LAST SPECIFIED ELEMENT
	SKIPN	-1(T1)		;WAS THIS ELEMENT SPECIFIED BY THE OPERATOR?
	  SOJA	T1,.-2(R)	;NO, KEEP LOOKING
BCKUP1:	HRRI	CM,(T3)		;RESET CMD LEVEL TO LAST SPECIFIED ELEMENT
	CAILE	T3,CM%DIR	;DID WE BACK UP INTO THE DIRECTORY SPEC?
	  MOVEI	T3,CM%DIR	;NO, GET COMMAND LEVEL FOR A DIRECTORY
	MOVEM	T3,RECLVL(R)	;SET LEVEL TO RECOGNIZE DEV, DIR, OR FILE
	MOVS	M,T2		;GET ADDR OF FIRST WORD OF THIS ELEMENT IN RH
	HRLI	M,(POINT 7)	;CONVERT ADDR INTO A BYTE POINTER
	HRLI	CM,(M)		;SAVE ADDR OF FIRST WORD OF ELEMENT
	MOVEI	T1,(T2)		;GET NUMBER OF CHARACTERS IN THIS FIELD
	MOVSI	NC,-CH%FLD(T1)	;SET UP THE CHARACTER COUNT FOR THIS FIELD
	HRRI	NC,(T1)
	IBP	M		;GET BYTE PTR TO LAST CHAR (I.E. DELIMITER)
	SOJG	T1,.-1(R)
	POPJ	P,		;RETURN WITH PREVIOUS FIELD NOW INCOMPLETE
;Routine to decrement the command string byte pointer

DECPTR:	DPB	BF,M		;TERMINATE TRUNCATED FIELD WITH A NULL
	ADD	M,[07B5](R)	;BUMP P FIELD BY BYTE SIZE
	TLNE	M,(1B0)		;DID WE CROSS A WORD BOUNDARY?
	  SUB	M,[43B5!1](R)	;YES, ADJUST THE DECREMENTED BYTE POINTER
	SUB	NC,[1,,1](R)	;DECREMENT THE CHARACTER COUNT
	TRNE	NC,-1		;DID WE JUST DELETE THE LAST CHAR IN A FIELD?
	  POPJ	P,		;NO, RETURN TO CALLER
	MOVSI	NC,-CH%FLD	;YES, RESET FIELD COUNT (IN CASE CMD IS SWITCH)
	HRLI	M,(POINT 7)	;RESET THE CMD STRING BYTE POINTER
	AOJ	M,
	TLZ	BF,(FL.DIR!FL.SWT) ;DIR AND SWITCH BOTH START WITH A DELIMITER
	MOVEI	T1,(CM)		;GET THE CURRENT COMMAND LEVEL
	JUMPE	T1,CPOPJ(R)	;RETURN NOW IF NO COMPLETED FIELDS YET
	MOVEI	T2,ELMTAB(T1)	;GET THE ADDR OF THIS FIELD`S LENGTH,,ADDR
	ADDI	T2,(R)		;MAKE THIS ADDRESS RELOCATABLE
DCPTR1:	SOJ	T2,		;GET ADDRESS OF PREVIOUS FIELD`S LENGTH,,ADDR
	SKIPN	(T2)		;WAS THIS COMMAND ELEMENT EXPLICITLY SPECIFIED?
	  SOJG	T1,DCPTR1(R)	;NO, LOOP BACK TO CHECK PREVIOUS FIELD
	HRRI	CM,(T1)		;RESET COMMAND LEVEL TO LAST COMPLETED FIELD
	CAIE	T1,CM%VER	;IS LAST COMPLETED FIELD THE VERSION NUMBER?
	  POPJ	P,		;NO, THEN JUST RETURN TO CALLER
	PJRST	BACKUP(R)	;YES, VERSION FIELD HAS NO (EXPLICIT) DELIMITER

;Routine to check for and process an implicit delimiter

CHKDLM:	SKIPE	DLMPTR(R)	;DOES COMMAND CONTAIN AN IMPLICIT DELIMITER?
	TRNE	NC,-1		;YES, IS THE CURRENT FIELD NULL?
	  POPJ	P,		;NO TO EITHER, JUST RETURN TO CALLER
	MOVE	T1,DLMLVL(R)	;YES TO BOTH, GET CMD LEVEL FOR THIS DELIMITER
	CAIE	T1,(CM)		;DOES DELIMITER TERMINATE LAST COMPLETED FIELD?
	  POPJ	P,		;NO, THEN JUST RETURN TO CALLER
	SETZM	DLMPTR(R)	;FLAG THAT THERE`S NO IMPLICIT DELIMITER NOW
	PUSHJ	P,BACKUP(R)	;BACK UP INTO THE LAST COMPLETED FIELD
	PJRST	DECPTR(R)	;BACK UP OVER DELIMITER AND RETURN TO CALLER
SUBTTL	Routines to process the command field delimiters

;Routine to process a colon (device delimiter)

ENDDEV:	MOVEI	T1,CM%DEV	;GET THE COMMAND LEVEL FOR A DEVICE SPEC
	PUSHJ	P,ENDFLD(R)	;AND FINISH UP THE DEVICE FIELD
	JRST	GETCMD(R)	;GO PARSE THE NEXT FIELD

;Routine to process an open angle bracket (start of directory specification)

BEGDIR:	TRNN	NC,-1		;ERROR IF ANYTHING PRECEDES THIS DELIMITER
	 TLOE	BF,(FL.DIR)	;FLAG THAT WE`VE JUST SEEN AN OPEN BRACKET
	  JRST	BADCMD(R)	;AND ISSUE AN ERROR IF WE`VE ALREADY SEEN ONE
	MOVEI	T1,(CM)		;GET COMMAND LEVEL OF THE LAST COMPLETED FIELD
	CAIL	T1,CM%DIR	;HAVE WE ALREADY PROCESSED A DIRECTORY SPEC?
	  JRST	BADCMD(R)	;YES, THEN THIS IS AN INVALID COMMAND
	AOJA	NC,GTCMD1(R)	;NO, GO SCAN THE DIRECTORY SPECIFICATION

;Routine to process a closing angle bracket (directory delimiter)

ENDDIR:	TLZE	BF,(FL.DIR)	;WERE WE PARSING THE DIRECTORY SPEC?
	 TRNN	NC,^-1		;YES, IS THIS A NON-NULL DIRECTORY NAME
	  JRST	BADCMD(R)	;NO TO EITHER, ISSUE AN ERROR
	MOVEI	T1,CM%DIR	;GET THE COMMAND LEVEL FOR A DIRECTORY SPEC
	PUSHJ	P,ENDFLD(R)	;AND FINISH UP THE DIRECTORY FIELD
	JRST	GETCMD(R)	;GO PARSE THE NEXT FIELD

;Routine to process a period (file name delimiter)

ENDFIL:	MOVEI	T1,CM%FIL	;GET THE COMMAND LEVEL FOR A FILE NAME SPEC
	PUSHJ	P,ENDFLD(R)	;AND FINISH UP THE FILE NAME FIELD
	JRST	GETCMD(R)	;GO PARSE THE NEXT FIELD

;Routine to process a semicolon (extension delimiter)

ENDEXT:	MOVEI	T1,CM%EXT	;GET THE COMMAND LEVEL FOR AN EXTENSION SPEC
	PUSHJ	P,CHKSPC(R)	;AND FINISH UP THE EXTENSION FIELD
	JRST	GETCMD(R)	;GO PARSE THE NEXT FIELD
;Routine to process the end of the version spec (called via ^F and altmode)

ENDVER:	TRNN	NC,-1		;DID WE JUST RECOGNIZE THE DEFAULT VERSION?
	  PUSHJ	P,TYPVER(R)	;YES, PRETEND THAT OPR TYPED VERSION WE FOUND
	TLZE	BF,(FL.RFS)	;IF PROCESSING AN ALTMODE, REMOVE PTREC1 CALL
	  POP	P,(P)		;(ALTMODE RECOGNITION ONLY APPLIES TO FILE SPEC)
	MOVEI	T1,CM%VER	;GET THE COMMAND LEVEL FOR A VERSION SPEC
	PUSHJ	P,ENDFLD(R)	;AND FINISH UP THE VERSION FIELD
	JRST	GETCMD(R)	;GO PARSE THE NEXT FIELD

;Routine to process a comma (start of switch specification)

BEGSWT:	SKIPN	ELMFIL(R)	;HAVE WE SEEN A FILE NAME SPECIFICATION YET?
	 TRNN	CM,-1		;NO, ARE THERE ANY COMPLETED FIELDS YET?
	  JRST	BGSWT1(R)	;HERE IF FILE SPEC OR NO COMPLETED FIELDS
	TRNN	NC,-1		;ANY CHARS IN (IMPLICIT) FILE NAME FIELD?
	  JRST	BADCMD(R)	;NO, ISSUE AN ERROR IF NO FILE NAME SPEC
BGSWT1:	DPB	BF,M		;REPLACE COMMA WITH AN ASCII NULL
	MOVEI	T1,CM%VER	;GET THE COMMAND LEVEL FOR A VERSION SPEC
	TRNE	NC,-1		;ANY CHARS IN CURRENT (INCOMPLETE) FIELD?
	  PUSHJ	P,CHKSPC(R)	;YES, FINISH UP THIS (POSSIBLY IMPLICIT) FIELD
	HRRI	CM,CM%VER	;DON`T ACCEPT ANYTHING BUT A SWITCH NOW
	SKIPN	ELMFIL(R)	;HAVE WE SEEN A FILE NAME SPECIFICATION?
	  TLO	BF,(FL.SWT)	;NO, THEN THIS COMMAND IS JUST A SWITCH
	TLNE	BF,(FL.SWT)	;IS THIS COMMAND JUST A SWITCH?
	  HRRZM	CM,RECLVL(R)	;YES, SET LEVEL TO RECOGNIZE SWITCH ONLY
	MOVS	M,CM		;GET THE SWITCH FIELD ADDR INTO RH
	HRLI	M,(POINT 7)	;CONVERT ADDRESS INTO A BYTE POINTER
	MOVEI	B,","		;SET UP FIRST CHARACTER OF THE SWITCH FIELD
	IDPB	B,M
	MOVSI	NC,-^D7		;SET MAX NUMBER OF CHARS ALLOWED IN SWITCH SPEC
	AOJA	NC,GTCMD1(R)	;LOOP BACK TO GET THE OPERATOR`S SWITCH
;Routine to process a CR or LF (both indicate the end of the command line)

ENDCMD:	MOVEI	T1,(CM)		;ISOLATE THE CURRENT COMMAND LEVEL
	TRNN	NC,-1		;ANY CHARS IN CURRENT (INCOMPLETE) FIELD?
	  JUMPE	T1,BEGBTS(R)	;NO, RE-PROMPT OPERATOR IF NOTHING TYPED
	IDPB	BF,M		;RELPACE THE CR (OR LF) WITH AN ASCII NULL
	MOVEI	T1,CM%SWT	;GET THE COMMAND LEVEL FOR A SWITCH SPEC
	TLNE	BF,(FL.SWT)	;IS THIS COMMAND JUST A SWITCH?
	  JRST	ENCMD1(R)	;YES, GO PROCESS THE SWITCH SPEC
	SKIPE	ELMFIL(R)	;NO, HAVE WE SEEN A FILE NAME YET?
	 TRNE	NC,-1		;YES, ANY CHARS IN CURRENT (INCOMPLETE) FIELD?
ENCMD1:	  PUSHJ	P,CHKSPC(R)	;FINISH UP THE CURRENT COMMAND FIELD
	HRRI	CM,CM%SWT	;FLAG THAT WE`VE SEEN THE LAST COMMAND FIELD
	PUSHJ	P,RECFLD(R)	;PARSE DEFAULT SWITCH IF LAST FIELD WAS VERSION
	SKIPE	MONCMD(R)	;WERE WE CALLED VIA THE MONITOR?
	  PJRST	TYCRLF(R)	;YES, THEN DON`T ASK FOR CONFIRMATION
	TLNE	BF,(FL.SWT)	;IS THIS CMD JUST A SWITCH?
	  JRST	ENCMD3(R)	;YES, THEN DON`T FILL IN THE DEFAULTS
	SETOM	ELMVER(R)	;HACK TO TYPE VERSION (IF -2 OR 0)
	MOVSI	T1,-CM%SWT	;CREATE AOBJN POINTER TO LOOP THRU ALL FIELDS
	HRRI	T1,(R)
ENCMD2:	MOVE	T2,DFLTAB(T1)	;GET THE DEFAULT LENGTH,,ADDR FOR THIS FIELD
	ADDI	T2,(R)		;MAKE DEFAULT FIELD ADDRESS RELOCATABLE
	SKIPN	ELMTAB(T1)	;WAS THIS COMMAND FIELD EXPLICITLY SPECIFIED?
	  MOVEM	T2,ELMTAB(T1)	;NO, THEN SET IT TO THE DEFAULT
	AOBJN	T1,ENCMD2(R)	;LOOP BACK IF MORE FIELDS TO CHECK
ENCMD3:	MOVEI	C,[ASCIZ \ [Confirm] \](R)
	PUSHJ	P,$STRO(R)	;ASK OPERATOR TO CONFIRM THE COMMAND
	PUSHJ	P,GTCHR1(R)	;GET THE OPERATOR`S ONE CHAR RESPONSE
	CAIE	B,015		;IS THE RESPONSE A CARRIAGE RETURN
	CAIN	B,012		; OR A LINE FEED?
	  PJRST	TYCRLF(R)	;YES, TYPE A CR-LF AND GO EXECUTE THIS COMMAND
	CAIE	B,"R"-100	;DOES OPR WANT TO SEE THE ENTIRE CMD (I.E. ^R)?
	  JRST	[PUSHJ	P,TYPCHR(R)	;NO, TYPE HIS RESPONSE (IN ARROW MODE)
		 JRST	BEGBTS(R)](R)	;AND LOOP BACK FOR ANOTHER COMMAND
	SETZB	NC,DLMPTR(R)	;YES, FORCE PRINTING OF THE IMPLICIT DELIMITER
	PUSHJ	P,TYPCMD(R)	;GO RETYPE THE COMMAND
	JRST	ENCMD3(R)	;AND ASK FOR CONFIRMATION AGAIN
;Routine to check for and process an implicit field specification

CHKSPC:	MOVEI	T2,-1(T1)	;IS THIS AN EXPLICIT FIELD SPECIFICATION?
	CAIN	T2,(CM)
	  PJRST	ENDFLD(R)	;YES, THEN FINISH UP THIS FIELD AND RETURN
	PUSH	P,T1		;SAVE THE NEW COMMAND LEVEL
	MOVSI	T1,-CM%FIL(T1)	;FIND FIRST FREE COMMAND FIELD
	MOVNS	T1
	HRRI	T1,ELMFIL(R)	;STARTING WITH FILE NAME SPECIFICATION
	SKIPE	(T1)		;HAS THIS FIELD BEEN SPECIFIED?
	  AOBJN	T1,.-1(R)	;NO, LOOP BACK AND CHECK NEXT FIELD
	MOVEI	T1,1(T1)	;GET THE (RELOCATABLE) CMD LEVEL FOR THIS FIELD
	SUBI	T1,ELMTAB	;(NOTICE THAT E FIELD ISN`T INDEXED BY R!)
	CAIE	T1,CM%FIL(R)	;ARE WE PROCESSING THE FILE NAME SPECIFICATION?
	 TRNE	NC,-1		;NO, ANY CHARS IN CURRENT INCOMPLETE FIELD?
	  JRST	CKSPC1(R)	;HERE IF NO FILE YET OR NON-NULL CURRENT FIELD
	POP	P,T1		;ALL FIELDS AFTER FILE SPEC MAY BE DEFAULTED
	HRRI	CM,(T1)		;REMEMBER THE NEW COMMAND LEVEL
	PJRST	RECFLD(R)	;RECOGNIZE IMPLICIT DEFAULT FIELDS AND RETURN
CKSPC1:	MOVEI	B,-CM%FIL(T1)
	MOVE	B,[EXP ".",";",0,0](B) ;GET THIS FIELD`S (IMPLICIT) DELIMITER
	DPB	B,M		;AND REPLACE THE CURRENT DELIMITER WITH THIS
	SUBI	T1,(R)		;COMPUTE THIS FIELD`S COMMAND LEVEL
	JUMPE	B,CKSPC2(R)	;JUMP IF THIS IS A NULL IMPLICIT DELIMITER
	MOVEM	M,DLMPTR(R)	;SAVE DELIMITER ADDR (OPR DIDN`T TYPE THIS CHAR)
	MOVEM	T1,DLMLVL(R)	; AND COMMAND LEVEL CONTAINING THIS DELIMITER
CKSPC2:	PUSHJ	P,ENDFLD(R)	;GO FINISH UP THIS FIELD
	POP	P,T1		;RESTORE THE ORIGINAL COMMAND LEVEL
	CAIE	T1,CM%EXT	;DID WE JUST PROCESS AN IMPLICIT FILE SPEC?
	  JRST	[HRRI	CM,(T1)		;NO, SET COMMAND LEVEL TO THIS LEVEL
		 PJRST	RECFLD(R)](R)	;AND GO RECOGNIZE ALL COMPLETED FIELDS
	MOVEI	B,";"		;YES, GET THE DELIMITER FOR THE EXTENSION FIELD
	MOVS	M,CM		;GET THE ADDRESS OF THE CURRENT FIELD
	HRLI	M,(POINT 7)	;CONVERT ADDRESS INTO A BYTE POINTER
	IDPB	B,M		;TERMINATE THE (NULL) EXTENSION FIELD
	SETZ	NC,		;SET CHARACTER COUNT FOR NULL EXTENSION FIELD
;	PJRST	ENDFLD(R)	;FINISH UP THE EXTENSION FIELD AND RETURN
;Routine to finish up a field specification (called with command level in T1)

ENDFLD:	TLNN	BF,(FL.DIR)	;ARE WE IN THE MIDST OF A DIRECTORY SPEC
	 CAIG	T1,(CM)		; OR ARE WE ALREADY AT THIS LEVEL?
	  JRST	BADCMD(R)	;YES TO EITHER, THEN THIS IS A BAD COMMAND
	CAIN	T1,CM%FIL	;ARE WE PROCESSING THE FILE FIELD?
	TRNE	NC,-1		;YES, CHECK FOR A NON-NULL FILE NAME
	JRST	.+2(R)		;HERE IF NOT FILE SPEC OR NON-NULL NAME
	  JRST	BADCMD(R)	;ISSUE ERROR IF NULL FILE NAME
	CAIN	T1,CM%SWT	;ARE WE PROCESSING THE SWITCH FIELD?
	TRNE	NC,^-1		;YES, DID THE OPERATOR SPECIFY A SWITCH?
	JRST	.+2(R)		;HERE IF NOT SWITCH SPEC OR SWITCH SPECIFIED
	  JRST	BADCMD(R)	;ERROR IF AT SWITCH LEVEL BUT NO SWITCH
	CAIE	T1,CM%SWT	;PROCESSING A FILE SPEC ELEMENT (NOT SWITCH)?
	  TRZ	BF,FR.FIC	;YES, IGNORE ANY PREVIOUSLY LOADED FILE
	HRRI	CM,(T1)		;REMEMBER THE NEW COMMAND LEVEL
	ADDI	T1,ELMTAB-1(R)	;GET ADDR OF WHERE TO SAVE FIELD`S LENGTH,,ADDR
	MOVE	T2,CM		;GET ADDR OF FIRST WORD OF THIS FIELD (IN LH)
	HRRI	T2,1(NC)	;NUMBER OF CHARS IN THIS FIELD (PLUS DELIMITER)
	MOVSM	T2,(T1)		;SAVE LENGTH,,ADDR OF THIS COMMAND ELEMENT
	IDPB	BF,M		;INSURE ASCII NULL AT END OF ELEMENT
	MOVEI	M,1(M)		;SET BYTE POINTER ADDR TO NEXT WORD BOUNDARY
	HRLI	CM,(M)		;SAVE STARTING ADDRESS OF NEXT COMMAND ELEMENT
;	PJRST	RECFLD(R)	;GO RECOGNIZE THIS COMMAND FIELD

;Routine to do recognition on a completed command field

RECFLD:	MOVE	T1,RECLVL(R)	;GET THE CMD LEVEL OF THE LAST RECOGNIZED FIELD
	CAIL	T1,(CM)		;HAVE WE RECOGNIZED ALL COMPLETED FIELDS YET?
	  POPJ	P,		;YES, RETURN TO CALLER
	AOS	T2,RECLVL(R)	;NO, GET LEVEL OF THE NEXT FIELD TO RECOGNIZE
	ADDI	T2,(R)		;MAKE THE COMMAND LEVEL RELOCATABLE
	SKIPE	T1,ELMTAB-1(T2)	;WAS THIS COMMAND ELEMENT EXPLICITLY SPECIFIED?
	  JRST	RCFLD1(R)	;YES, GO RECOGNIZE THIS FIELD
	MOVE	T1,DFLTAB-1(T2)	;NO, GET THE LENGTH,,ADDR OF THE DEFAULT FIELD
	ADDI	T1,(R)		;MAKE THE DEFAULT FIELD ADDRESS RELOCATABLE
RCFLD1:	MOVEM	T1,FLDSPC(R)	;SAVE THE LENGTH,,ADDR OF THIS COMMAND FIELD
	PUSHJ	P,@[FNDDEV(R)	;CALL ROUTINE TO RECOGNIZE THIS COMMAND FIELD
		    FNDDIR(R)
		    FNDFIL(R)
		    FNDEXT(R)
		    FNDVER(R)
		    CHKSWT(R)]-CM%DEV(T2)
	  JRST	BADCMD(R)	;ISSUE ERROR IF WE COULDN`T FIND THIS FIELD
	JRST	RECFLD(R)	;LOOP BACK TO CHECK NEXT COMMAND FIELD
SUBTTL	Routines to process special characters that invoke recognition

;Routine to process a ? (type all that matches the current command field)

MCHFLD:	MOVEI	T1,(CM)		;GET THE CURRENT COMMAND LEVEL
	TRNN	NC,-1		;ANY CHARS IN CURRENT (INCOMPLETE) FIELD?
	  JUMPE	T1,TYPHLP(R)	;NO, TYPE HELP MSG IF "?" IS THE VERY FIRST CHAR
	TLO	BF,(FL.MCH)	;FLAG THAT WE`RE LOOKING FOR FIELD MATCHES
	PUSHJ	P,RECDFL(R)	;RECOGNIZE DEFAULT FIELDS UP TO CURRENT LEVEL
	  TLZ	BF,(FL.MCH)	;HERE IF OPERATOR TRIED TO MATCH THE SWITCH
	MOVEI	B,"?"		;NOW SHOW THE OPERATOR WHAT CHAR HE TYPED
	PUSHJ	P,$TTYO(R)
	TLNN	BF,(FL.MCH)	;DID THE OPERATOR TRY TO MATCH THE SWITCH?
	  JRST	RNGBEL(R)	;YES, MATCHING ONLY APPLIES TO THE FILE SPEC
	PUSH	P,FA		;NO, SAVE THE CURRENT FDB ADDRESS
	MOVEI	T1,1(CM)	;GET COMMAND LEVEL OF CURRENT INCOMPLETE FIELD
	ADDI	T1,(R)		;MAKE IT RELOCATABLE
	PUSHJ	P,@[FNDDIR(R)	;CALL ROUTINE TO MATCH THIS COMMAND FIELD
		    FNDFIL(R)
		    FNDEXT(R)
		    FNDVR1(R)]-CM%DIR(T1)
	POP	P,FA		;RESTORE THE CURRENT FDB ADDRESS
	TLZ	BF,(FL.MCH)	;CLEAR THE MATCH FLAG
	JRST	RETYPE(R)	;AND RETYPE THE CURRENT COMMAND LINE

;Routine to type the help message (called if "?" is the first character typed)

TYPHLP:	MOVEI	C,HLPMSG(R)	;TYPE THE HELP MESSAGE
	PUSHJ	P,$STRO(R)
	JRST	GTCMD1(R)	;AND GO GET THE FIRST CHAR OF THE COMMAND

	.DIRECT	FLBLST		;ONLY LIST FIRST LINE OF GENERATED CODE
HLPMSG:	ASCIZ \?
 Awaiting a file specification of the form:

        Device:<Directory>Filename.Extension;Version,Switch

 Switches are:  ,G  To load and start the file (this is the default)
                ,n  To load and start the file at location "n"
                ,L  To just load the file into core without starting it

*\
	.DIRECT	NO FLBLST	;RESUME NORMAL LISTING MODE
;Routine to process a ^F (recognize and fill in the current command field)

PRTREC:	PUSHJ	P,RECDFL(R)	;RECOGNIZE DEFAULT FIELDS UP TO CURRENT LEVEL
	  JRST	RNGBEL(R)	;HERE IF OPERATOR TRIED TO RECOGNIZE THE SWITCH
	PUSHJ	P,CHKFLD(R)	;SEE IF WE SHOULD DEFAULT THIS FIELD
PTREC1:	TLO	BF,(FL.REC)	;FLAG THAT WE`RE RECOGNIZING AN INCOMPLETE FIELD
	PUSH	P,FA		;SAVE FDB ADDR IN CASE FIELD CAN`T BE RECOGNIZED
	MOVEI	T1,1(CM)	;GET COMMAND LEVEL OF CURRENT INCOMPLETE FIELD
	ADDI	T1,(R)		;MAKE IT RELOCATABLE
	PUSHJ	P,@[FNDDIR(R)	;CALL ROUTINE TO RECOGNIZE THIS COMMAND FIELD
		    FNDFIL(R)
		    FNDEXT(R)
		    FNDVR0(R)]-CM%DIR(T1)
	  JRST	[POP	P,FA		;NO MATCH OR AMBIGUOUS, RESTORE FDB ADDR
		 TLZ	BF,(FL.REC!FL.FND) ;CLEAR ^F AND SUPERSET MATCH FLAGS
		 TLZE	BF,(FL.RFS)	;WERE WE PROCESSING AN ALTMODE?
		  POP	P,(P)		;YES, ADJUST STACK FOR PTREC1 CALL
		 JRST	RNGBEL(R)](R)	;RING BELL TO INDICATE NO MATCH FOUND
	POP	P,(P)		;DON`T RESTORE THE PREVIOUS FDB ADDR!
	TLZ	BF,(FL.REC!FL.FND) ;CLEAR THE ^F AND SUPERSET MATCH FLAGS
	MOVEI	T1,1(CM)	;GET THIS FIELD`S COMMAND LEVEL
	MOVEM	T1,RECLVL(R)	;FLAG THAT WE`VE JUST RECOGNIZED THIS FIELD
	ADDI	T1,(R)		;MAKE THE COMMAND LEVEL RELOCATABLE
	JRST	@[ENDDIR(R)	;CALL ROUTINE TO FINISH UP THIS FIELD SPEC
		  ENDFIL(R)
		  ENDEXT(R)
		  ENDVER(R)]-CM%DIR(T1)

;Routine to process an altmode (recognize and fill in the rest of the file spec)

FULREC:	PUSHJ	P,RECDFL(R)	;RECOGNIZE DEFAULT FIELDS UP TO CURRENT LEVEL
	  JRST	RNGBEL(R)	;HERE IF OPERATOR TRIED TO RECOGNIZE THE SWITCH
	PUSHJ	P,CHKFLD(R)	;SEE IF WE SHOULD DEFAULT THIS FIELD
	TLOA	BF,(FL.RFS)	;FLAG THAT WE`RE RECOGNIZING ENTIRE FILE SPEC
FLREC1:	  PUSHJ	P,CKFLD1(R)	;SET UP THE NEXT DEFAULT FIELD
	PUSHJ	P,PTREC1(R)	;CALL ^F ROUTINE TO DO THE RECOGNITION
	JRST	FLREC1(R)	;AND LOOP BACK TO RECOGNIZE NEXT (DEFAULT) FIELD

;Routine to check if current field should be defaulted (called by ^F and $)

CHKFLD:	MOVEI	T1,(NC)		;GET NUMBER OF CHARS IN CURRENT COMMAND FIELD
	TLNE	BF,(FL.DIR)	;ARE WE IN THE MIDST OF THE DIRECTORY SPEC?
	  SOJN	T1,CPOPJ(R)	;YES, RETURN IF NON-NULL DIR SPEC
	JUMPN	T1,CPOPJ(R)	;RETURN IF THIS IS A NON-NULL FIELD
CKFLD1:	MOVEI	T1,1(CM)	;NULL FIELD, GET THIS FIELD`S COMMAND LEVEL
	ADDI	T1,(R)		;MAKE THE COMMAND LEVEL RELOCATABLE
	MOVE	T1,DFLTAB-1(T1)	;GET THE DEFAULT FIELD FOR THIS CMD LEVEL
	ADDI	T1,(R)		;MAKE THE DEFAULT FIELD ADDR RELOCATABLE
	MOVEM	T1,FLDSPC(R)	;SAVE LENGTH,,ADDR OF FIELD TO RECOGNIZE
	POPJ	P,		;RETURN WITH DEFAULT FIELD SET UP
;Routine to do recognition on all implicitly defined default fields

RECDFL:	MOVEI	T1,(CM)		;GET THE COMMAND LEVEL OF LAST COMPLETED FIELD
	CAIN	T1,CM%VER	;IS OPERATOR TRYING TO RECOGNIZE THE SWITCH?
	  POPJ	P,		;YES, THEN NON-SKIP RETURN TO CALLER
	CAIL	T1,CM%DIR	;HAVE WE SEEN THE DIRECTORY SPEC YET?
	  JRST	RCDFL3(R)	;YES, THEN LAST CMD FIELD HAS BEEN RECOGNIZED
	HRRI	CM,CM%DIR	;NO, SET CURRENT COMMAND LEVEL TO DIRECTORY
	TLNE	BF,(FL.DIR)	;ARE WE IN THE MIDST OF THE DIRECTORY SPEC?
	  HRRI	CM,CM%DEV	;YES, SET CURRENT COMMAND LEVEL TO DEVICE
	PUSHJ	P,RECFLD(R)	;RECOGNIZE DEVICE (AND POSSIBLY DIRECTORY)
	TRNE	NC,-1		;ANY CHARS IN CURRENT (INCOMPLETE) CMD FIELD?
	  JRST	RCDFL3(R)	;YES, THEN NO SPECIAL ACTION
	MOVE	T1,DFLDIR(R)	;NO, GET THE LENGTH,,ADDR OF DEFAULT DIR SPEC
	ADDI	T1,(R)		;MAKE THE DIRECTORY FIELD ADDR RELOCATABLE
	MOVEM	T1,ELMDIR(R)	;PRETEND THAT THE USER TYPED THE DEFAULT DIR
	HRRM	M,ELMDIR(R)
	HRLI	T1,(POINT 7)	;CONVERT DEFAULT DIR FIELD ADDR INTO A BYTE PTR
RCDFL1:	ILDB	B,T1		;GET A CHAR FROM THE DEFAULT DIRECTORY FIELD
	IDPB	B,M		;AND STUFF IT INTO THE COMMAND BUFFER
	JUMPE	B,RCDFL2(R)	;QUIT ON AN ASCII NULL
	PUSHJ	P,TYPCHR(R)	;SHOW THIS CHARACTER TO THE OPERATOR
	JRST	RCDFL1(R)	;LOOP BACK FOR NEXT CHARACTER
RCDFL2:	MOVEI	M,1(M)		;GET ADDR OF NEXT WORD BOUNDARY
	HRLI	CM,(M)		;SAVE STARTING ADDR OF NEXT COMMAND FIELD
	HRLI	M,(POINT 7)	;SET UP BYTE POINTER TO NEXT COMMAND FIELD
RCDFL3:	MOVS	T1,CM		;GET STARTING ADDR OF THIS COMMAND FIELD IN RH
	HRLI	T1,1(NC)	;STUFF THE NUMBER OF CHARS IN THIS FIELD IN LH
	MOVEM	T1,FLDSPC(R)	;SAVE THE LENGTH,,ADDR OF THE CURRENT FIELD
	JRST	CPOPJ1(R)	;AND SKIP RETURN TO CALLER
SUBTTL	Routines to recognize the command fields

;Routine to recognize the device field

FNDDEV:	MOVE	T1,FLDSPC(R)	;GET THE LENGTH,,ADDR OF THE DEVICE SPEC
	MOVE	T1,(T1)		;NOW GET THE FIRST WORD OF THE DEVICE SPEC
	CAMN	T1,[ASCIZ \DSK:\](R) ;IS THIS A LEGAL DEVICE SPECIFICATION?
	  AOS	(P)		;YES, BUMP RETURN ADDR FOR SKIP RETURN
	POPJ	P,		;RETURN TO CALLER AND GET NEXT COMMAND FIELD

;Routine to recognize the directory field

FNDDIR:	MOVE	A,[DIDSC0](R)	;GET ADDR OF INDEX BLOCK FOR (SYSTEM)INDEX.;1
	MOVEI	C,PAGE.1(R)	;READ THIS PAGE INTO THIS BLOCK
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET (SYSTEM)INDEX.;1 INDEX BLOCK
	MOVE	A,PAGE.1(R)	;GET ADDR OF FIRST PAGE OF (SYSTEM)INDEX.;1
	MOVEI	C,PAGE.2(R)	;READ THIS PAGE INTO THIS BLOCK
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET FIRST PAGE OF (SYSTEM)INDEX.;1
	MOVE	T1,FLDSPC(R)	;GET THE ADDRESS OF THE DIRECTORY STRING
	HRLI	T1,(POINT 7,,13) ;BYTE POINTER TO GET FIRST CHAR AFTER DELIMITER
	LDB	T1,T1		;GET THE FIRST CHARACTER OF THE DIRECTORY
	JUMPN	T1,FNDDR1(R)	;JUMP IF THIS IS A NON-NULL DIRECTORY
	TLNE	BF,(FL.MCH)	;NULL DIRECTORY, ARE WE PROCESSING A "?"?
	  TLO	BF,(FL.NUL)	;YES, REMEMBER TO SCAN DIRECTORY -2 NEXT
FNDDR1:	IDIVI	T1,5		;PREPARE TO DISPATCH TO PROPER SUBINDEX
	ADDI	T1,(R)		;MAKE BOTH DISPATCH OFFSETS RELOCATABLE
	ADDI	T2,(R)		;(SURE WISH WE HAD DOUBLE INDEXING)
	LDB	T1,[POINT 7,SBIDTB(T1),6
		    POINT 7,SBIDTB(T1),13
		    POINT 7,SBIDTB(T1),20
		    POINT 7,SBIDTB(T1),27
		    POINT 7,SBIDTB(T1),34](T2) ;GET DIR`S SUBINDEX NUMBER
	JUMPE	T1,CPOPJ(R)	;ERROR IF THERE`S NO SUBINDEX FOR THIS CHAR
	LSH	T1,3		;GET ADDR OF WHICH DIRECTORY TO READ (-1 OR -2)
	ADDI	T1,PAGE.1(R)
	MOVEI	C,DIRORG(R)	;READ THE DIRECTORY INTO THIS BUFFER
	PUSHJ	P,GET8PG(R)	;CALL SAIO TO GET THE EIGHT PAGE DIRECTORY
	TLO	BF,(FL.DLM)	;REMEMBER THAT DIRECTORY HAS OPENING DELIMITER
	PUSHJ	P,LOOKUP(R)	;GO FIND THE SPECIFIED DIRECTORY
	  JRST	[TLZN	BF,(FL.NUL)	;WERE WE MATCHING A NULL DIRECTORY?
		  POPJ	P,		;NO, NON-SKIP RETURN IF NO SUCH DIR
		 TLO	BF,(FL.MCH)	;YES, FLAG THAT WE`RE LOOKING FOR MATCH
		 MOVEI	T1,177		;DIRECTORY -2 ENDS WITH THIS CHAR
		 JRST	FNDDR1(R)](R)	;LOOP BACK TO SCAN DIRECTORY -2
	MOVEI	T3,(FA)		;GET A COPY OF THE DIRECTORY NUMBER
	MOVEI	T4,40		;ASSUME NEW DIR FORMAT (32 DIRS PER PAGE)
	SKIPE	FDFMTF(R)	;HOW WAS THIS ASSUMPTION?
	  LSH	T4,1		;WRONG, OLD DIR FORMAT (64 DIRS PER PAGE)
	IDIVI	T3,(T4)		;COMPUTE OFFSET INTO @INDEX BLOCK FOR THIS DIR
	LSH	T4,4		;ASSUME NEW DIR FORMAT (16 PAGES PER DIRECTORY)
	SKIPE	FDFMTF(R)	;HOW WAS THIS ASSUMPTION?
	  LSH	T4,-1		;WRONG, OLD DIR FORMAT (8 PAGES PER DIRECTORY)
	MOVE	A,FDADR(R)	;GET ADDR OF @INDEX BLOCK FOR (SYS)DIRECTORY.;1
	MOVEI	C,PAGE.1(R)	;READ THIS @INDEX BLOCK INTO THIS BUFFER
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET THIS INDIRECT INDEX BLOCK
	MOVEI	C,DIRORG(R)	;ADDR OF WHERE TO READ THIS DIRECTORY
	PUSHJ	P,GETDIR(R)	;GO READ THIS DIRECTORY INTO CORE
	SKIPN	FDFMTF(R)	;DOES THIS SYSTEM HAVE THE NEW DIRECTORY FORMAT?
	  JRST	CPOPJ1(R)	;YES, THEN WE`VE ALREADY READ THE DIRECTORY
	ADDI	T3,10		;NO, GET ADDR OF INDEX BLOCK FOR SECOND HALF
	PUSHJ	P,GETDIR(R)	;AND GO READ THE SECOND HALF OF THE DIRECTORY
	JRST	CPOPJ1(R)	;SKIP RETURN TO USER WITH DIRECTORY IN CORE

;Routine to recognize the file name field

FNDFIL:	PUSHJ	P,LOOKUP(R)	;GO FIND THE SPECIFIED FILE NAME
	  POPJ	P,		;ERROR RETURN IF NO SUCH FILE NAME
	ADDI	FA,(R)		;MAKE THIS FILE`S FDB ADDRESS RELOCATABLE
	JRST	CPOPJ1(R)	;SKIP RETURN TO CALLER (WITH FDB ADDR IN FA)

;Routine to recognize the extension field

FNDEXT:	MOVE	T1,FDBCTL(FA)	;GET THIS FILE`S CONTROL BITS
	TLNE	T1,(FDBNEX)	;DOES THIS FILE HAVE AN EXTENSION YET?
	  JRST	BADCTL(R)	;NO, THEN THIS IS AN UNUSABLE FILE
	PUSHJ	P,SETFLD(R)	;SET UP THE FIELD THAT WE`RE LOOKING FOR NOW
	JRST	.+2(R)		;INITIAL FDB ADDR IS ALREADY RELOCATABLE
FNDEX1:	  ADDI	FA,(R)		;MAKE THIS EXTENSION`S FDB ADDR RELOCATABLE
	HLRZ	T1,FDBEXT(FA)	;GET THIS FILE`S EXTENSION STRING ADDRESS
	PUSHJ	P,NAMCM2(R)	;GO COMPARE THIS EXTENSION TO OURS
	  JRST	FNDEX3(R)	;HERE IF THIS EXTENSION .GT. OURS
	  JRST	FNDEX3(R)	;HERE IF THIS EXTENSION .LT. OURS
FNDEX2:	  JRST	[PUSHJ	P,CHKREC(R)	;SUBSET, DOING INVOKED RECOGNITION?
		  MOVEM	FA,MCHADR(R)	;YES, SAVE THIS EXTENSION`S FDB ADDR
		 JRST	FNDEX3(R)	;AND GO CHECK THE NEXT EXTENSION
		 POPJ	P,](R)		;ISSUE ERROR IF STRING IS AMBIGUOUS
	TLNE	BF,(FL.MCH)	;HERE ON EXACT MATCH, ARE WE PROCESSING A "?"?
	  JRST	@FNDEX2(R)	;YES, THEN TREAT EXACT MATCH AS IF SUBSET MATCH
	JRST	FNDEX4(R)	;NO, THEN WE FOUND THE EXTENSION
FNDEX3:	HRRZ	FA,FDBEXT(FA)	;GET ADDR OF FDB FOR NEXT EXTENSION
	JUMPN	FA,FNDEX1(R)	;JUMP IF THERE`S ANOTHER EXTENSION TO CHECK
	TLNN	BF,(FL.FND)	;NO EXACT MATCH, DID WE FIND A SUBSET MATCH?
	  POPJ	P,		;NO, THEN WE DIDN`T FIND THE EXTENSION
	MOVE	FA,MCHADR(R)	;YES, GET THE FDB ADDRESS FOR THIS EXTENSION
FNDEX4:	MOVE	T1,FDBCTL(FA)	;EXACT MATCH, GET THIS FILE`S CONTROL BITS
	TLNE	T1,(FDBTMP)	;IS THIS A TEMPORARY FILE (VERSION = JOB NBR)?
	  JRST	BADCTL(R)	;YES, THEN THIS IS AN UNUSABLE FILE
	TLNN	BF,(FL.REC)	;WERE WE PROCESSING A ^F OR ALTMODE?
	  JRST	CPOPJ1(R)	;NO, SKIP RETURN TO CALLER (WITH FDB ADDR IN FA)
	MOVS	T4,FDBEXT(FA)	;YES, GET THE EXTENSION BLOCK ADDR IN THE RH
	PJRST	TYPFLD(R)	;FILL OUT REST OF THE EXTENSION AND SKIP RETURN
;Routine to recognize the version number field

FNDVR0:	MOVE	T1,DFLVER(R)	;ENTER HERE IF DOING INVOKED RECOGNITION
	ADDI	T1,(R)		;MAKE THE DEFAULT VERSION FIELD RELOCATABLE
	TRNN	NC,-1		;IS THIS A NULL VERSION FIELD?
	  MOVEM	T1,FLDSPC(R)	;YES, THEN USE THE DEFAULT VERSION SPEC
FNDVER:	MOVE	T4,FLDSPC(R)	;GET THE ADDRESS OF THE VERSION NUMBER SPEC
	HRLI	T4,(POINT 7)	;BYTE PTR TO GET FIRST CHAR IN VERSION FIELD
	HLRZ	T1,FLDSPC(R)	;GET THE NUMBER OF CHARS IN THE VERSION FIELD
	SUBI	T1,1		;DON`T CONSIDER THE TERMINATING NULL
	PUSHJ	P,GETDEC(R)	;GET THE DECIMAL VERSION NUMBER
	CAIG	T2,^D262141	;VERSION NUMBERS CAN`T BE GREATER THAN THIS
	CAMGE	T2,[-2](R)	; OR LESS THAN THIS
	  POPJ	P,		;ERROR RETURN IF INVALID VERSION NUMBER
	CAMN	T2,[-1](R)	;VERSION NUMBER -1 IS ILLEGAL IF READING A FILE
	  POPJ	P,
	MOVEM	T2,VERNUM(R)	;SAVE THE BINARY VERSION NUMBER
	JUMPLE	T2,HILOVR(R)	;JUMP IF LOOKING FOR HIGHEST OR LOWEST VERSION
FNDVR1:	HLRZ	T1,FDBVER(FA)	;GET THIS FILE`S VERSION NUMBER
	TLNN	BF,(FL.MCH)	;ARE WE PROCESSING A "?" (TYPE ALL VERSIONS)?
	  JRST	FNDVR2(R)	;NO, THEN JUST CHECK FOR AN EXACT MATCH
	MOVEI	1,(T1)		;YES, STUFF THE VERSION INTO AN ABSOLUTE AC
	MOVEI	C,[ASCIZ \
  %1D\](R)
	PUSHJ	P,$STRO(R)	;SHOW THIS VERSION NUMBER TO THE OPERATOR
	JRST	FNDVR3(R)	;AND GO GET THE NEXT VERSION NUMBER
FNDVR2:	CAMN	T1,VERNUM(R)	;IS THIS THE VERSION THAT WE`RE LOOKING FOR?
	  JRST	CPOPJ1(R)	;YES, THEN SKIP RETURN TO CALLER
FNDVR3:	HRRZ	FA,FDBVER(FA)	;GET ADDR OF FDB FOR NEXT VERSION
	JUMPE	FA,CPOPJ(R)	;ERROR RETURN IF NO SUCH VERSION NUMBER
	ADDI	FA,(R)		;MAKE FDB ADDRESS RELOCATABLE
	JRST	FNDVR1(R)	;AND LOOP BACK TO CHECK THIS VERSION NUMBER

;Here to find either the highest or lowest version number

HILOVR:	HLRZ	T2,FDBVER(FA)	;ASSUME THIS IS THE HIGHEST OR LOWEST VERSION
	SKIPE	VERNUM(R)	;ARE WE LOOKING FOR THE HIGHEST OR LOWEST?
	SKIPA	T3,[CAIGE T1,(T2)](R) ;SET UP INST TO FIND THE LOWEST VERSION
	  MOVSI	T3,(CAILE T1,(T2)) ;SET UP INST TO FIND THE HIGHEST VERSION
	JRST	HLVER2(R)	;GO GET FDB ADDR FOR NEXT VERSION NUMBER
HLVER1:	HLRZ	T1,FDBVER(FA)	;GET THIS FILE`S VERSION NUMBER
	XCT	T3		;EXECUTE THE APPROPRIATE COMPARISON
HLVER2:	  MOVEI	T4,(FA)		;SAVE FDB ADDR OF NEW HIGHEST OR LOWEST VERSION
	HRRZ	FA,FDBVER(FA)	;GET ADDR OF FDB FOR NEXT VERSION NUMBER
	JUMPE	FA,HLVER3(R)	;JUMP IF THERE ARE NO MORE VERSIONS TO CHECK
	ADDI	FA,(R)		;MAKE FDB ADDRESS RELOCATABLE
	JRST	HLVER1(R)	;AND LOOP BACK TO CHECK THIS VERSION NUMBER
HLVER3:	MOVEI	FA,(T4)		;GET ADDR OF FDB WITH HIGHEST OR LOWEST VERSION
	HLRZ	T1,FDBVER(FA)	;SAVE THE ACTUAL VERSION NUMBER
	MOVEM	T1,VERNUM(R)
	JRST	CPOPJ1(R)	;AND SKIP RETURN TO CALLER
;Routine to process the switch field

CHKSWT:	MOVE	T4,FLDSPC(R)	;GET THE ADDRESS OF THE SWITCH SPECIFICATION
	HRLI	T4,(POINT 7,,6)	;BYTE POINTER TO FIRST CHAR AFTER COMMA
	HLRZ	T1,FLDSPC(R)	;GET THE NUMBER OF CHARS IN THE SWITCH FIELD
	SUBI	T1,2		;DON`T COUNT THE LEADING COMMA OR TRAILING NULL
	MOVE	B,T4		;PRESERVE BYTE PTR FOR POSSIBLE CALL TO GETOCT
	ILDB	B,B		;AND GET THE FIRST CHAR OF THE SWITCH
	CAIN	B,"L"		;LOAD SWITCH?
	  JRST	[MOVEI	T2,GETFIL(R)	;YES, GET ROUTINE ADDR FOR THIS SWITCH
		 JRST	CKSWT2(R)](R)	;AND FINISH UP THE LOAD SWITCH
	CAIN	B,"G"		;GO SWITCH?
	  JRST	CKSWT1(R)	;YES, GO SET UP ITS ROUTINE ADDRESS
	PUSHJ	P,GETOCT(R)	;NO, THEN IT MUST BE THE STARTING ADDRESS
	TLNN	T2,-1		;STARTING ADDR MUST BE IN THE FIRST 256K
	 CAIG	T2,17		; BUT NOT IN THE ACS
	  POPJ	P,		;BAD STARTING ADDR, ISSUE THE ERROR RETURN
	MOVEM	T2,STADDR(R)	;SAVE THIS FILE`S STARTING ADDRESS
CKSWT1:	MOVEI	T2,LOADGO(R)	;ROUTINE ADDR FOR GO AND STARTING ADDR SWITCHES
	TRNN	BF,FR.FIC	;IS THERE ALREADY A FILE IN CORE
CKSWT2:	TLNN	BF,(FL.SWT)	; OR IS THERE A FILE SPEC IN THIS COMMAND?
	SOJLE	T1,.+2(R)	;YES, JUMP IF THIS IS A LEGAL SWITCH
	  POPJ	P,		;ILLEGAL SWITCH, ISSUE THE ERROR RETURN
	MOVEM	T2,SWTADR(R)	;SAVE ADDR OF ROUTINE TO EXECUTE THIS SWITCH
	JRST	CPOPJ1(R)	;AND SKIP RETURN TO CALLER

;Routine to encode a decimal version number or an octal starting address switch

GETDEC:	SKIPA	T3,[^D10](R)	;HERE TO ENCODE A DECIMAL VERSION NUMBER
GETOCT:	  MOVEI	T3,^D8		;HERE TO ENCODE AN OCTAL STARTING ADDR SWITCH
	SETZ	T2,		;INITIALIZE OUR EVENTUAL RESULT
GETNUM:	SOJL	T1,GTNUM2(R)	;JUMP IF NO MORE DIGITS TO ENCODE
	ILDB	B,T4		;GET A CHARACTER FROM THE COMMAND FIELD
	CAIL	B,"0"		;CHECK FOR A LEGAL DIGIT
	CAIL	B,"0"(T3)
	  JRST	GTNUM1(R)	;HERE IF NOT A LEGAL DIGIT
	IMULI	T2,(T3)		;ADJUST OUR PREVIOUS RESULT
	ADDI	T2,-"0"(B)	;AND ADD IN THIS DIGIT
	JRST	GETNUM(R)	;LOOP BACK FOR NEXT DIGIT
GTNUM1:	CAIN	B,"-"		;ONLY OTHER LEGAL CHARACTER IS A MINUS SIGN
	TLOE	BF,(FL.NEG)	;HAVE WE ALREADY SEEN ONE?
	  JRST	BADCMD(R)	;ERROR IF NOT A MINUS SIGN OR ALREADY SEEN ONE
	JUMPN	T2,BADCMD(R)	;MINUS SIGN MUST PRECEDE FIRST NON-ZERO DIGIT
	JUMPE	T1,BADCMD(R)	;ERROR IF NOTHING AFTER THE MINUS SIGN
	JRST	GETNUM(R)	;LOOP BACK FOR NEXT DIGIT
GTNUM2:	TLZE	BF,(FL.NEG)	;WAS THIS A NEGATIVE NUMBER?
	  MOVNS	T2		;YES, THEN NEGATE OUR FINAL RESULT
	POPJ	P,		;AND RETURN TO CALLER
;Routine to find a directory or file name string

LOOKUP:	PUSHJ	P,SETFLD(R)	;SET UP THE FIELD THAT WE`RE LOOKING FOR
	TLZE	BF,(FL.MCH)	;ARE WE PROCESSING A "?"?
	  PJRST	LOKMCH(R)	;YES, THEN DON`T DO A BINARY SEARCH ON SYM TABLE
	MOVE	T1,SYMTOP(R)	;NO, COMPUTE THE LENGTH OF THE SYMBOL TABLE
	SUB	T1,SYMBOT(R)
	JFFO	T1,.+2(R)	;COMPUTE GREATEST POWER OF 2 .LE. LENGTH
	  MOVEI	T2,^D35
	MOVNS	T2		;PREPARE FOR RIGHT SHIFT
	MOVSI	T1,(1B0)
	LSH	T1,(T2)
	MOVE	T2,SYMBOT(R)	;START JUST BELOW THE SYMBOL TABLE
	SOJ	T2,
MOVEUP:	JUMPE	T1,LOKUP1(R)	;JUMP IF WE DIDN`T FIND AN EXACT MATCH
	ADD	T2,T1		;COMPUTE ADDR OF THE NEXT STRING BLOCK
	ASH	T1,-1		;HALVE THE INCREMENT
	CAMGE	T2,SYMTOP(R)	;HAVE WE REACHED THE TOP OF THE SYMBOL TABLE?
	  JRST	SYMCMP(R)	;NO, THEN COMPARE THE TWO STRINGS
MOVEDN:	JUMPE	T1,LOKUP1(R)	;JUMP IF WE DIDN`T FIND AN EXACT MATCH
	SUB	T2,T1		;COMPUTE ADDR OF THE NEXT STRING BLOCK
	ASH	T1,-1		;HALVE THE INCREMENT
	CAML	T2,SYMTOP(R)	;HAVE WE REACHED THE TOP OF THE SYMBOL TABLE?
	  JRST	MOVEDN(R)	;YES, START BACKING UP
	CAMGE	T2,SYMBOT(R)	;DID WE BACK UP OUT OF THE SYMBOL TABLE?
	  POPJ	P,		;YES, THEN WE DIDN`T FIND THE STRING
SYMCMP:	MOVEM	T1,DIRINC(R)	;SAVE THE CURRENT INCREMENT
	MOVEM	T2,DIRLOC(R)	; AND SYMBOL TABLE LOCATION
	PUSHJ	P,NAMCMM(R)	;COMPARE THE TWO STRINGS
	  JRST	[MOVE	T1,DIRINC(R)	;HERE IF THIS STRING .GT. OURS
		 MOVE	T2,DIRLOC(R)	;RESTORE THE INCREMENT AND LOCATION
		 JRST	MOVEDN(R)](R)	;AND MOVE DOWN IN THE SYMBOL TABLE
	  JRST	[MOVE	T1,DIRINC(R)	;HERE IF THIS STRING .LT. OURS
		 MOVE	T2,DIRLOC(R)	;RESTORE THE INCREMENT AND LOCATION
		 JRST	MOVEUP(R)](R)	;AND MOVE UP IN THE SYMBOL TABLE
	  JRST	[MOVE	T1,DIRINC(R)	;HERE IF OUR STRING IS A SUBSET
		 MOVE	T2,DIRLOC(R)	;RESTORE THE INCREMENT AND LOCATION
		 PUSHJ	P,CHKREC(R)	;PROCESSING A ^F OR ALTMODE?
		  MOVEM	T2,MCHADR(R)	;YES, SAVE STRING`S SYMBOL TABLE ADDR
		 JRST	MOVEDN(R)	;AND MOVE DOWN IN THE SYMBOL TABLE
		 POPJ	P,](R)		;ISSUE ERROR IF STRING IS AMBIGUOUS
	JRST	LOKUP3(R)	;HERE IF WE FOUND AN EXACT MATCH
LOKUP1:	TLNN	BF,(FL.FND)	;NO EXACT MATCH, DID WE FIND A SUBSET MATCH?
	  POPJ	P,		;NO, THEN WE DIDN`T FIND THE STRING
	AOS	T2,MCHADR(R)	;POINT TO THE NEXT ENTRY AFTER THE MATCH
	CAMGE	T2,SYMTOP(R)	;IF NOT AT THE END OF THE SYMBOL TABLE
	 PUSHJ	P,NAMCMM(R)	; THEN COMPARE THIS NEW STRING TO OURS
	  JRST	LOKUP2(R)	;IF THIS STRING .GT. OURS, WE FOUND A MATCH
	  JRST	LOKUP2(R)	;IF THIS STRING .LT. OURS, WE FOUND A MATCH
	  POPJ	P,		;IF ANOTHER SUBSET, THEN OUR STRING IS AMBIGUOUS
	HALT	CPOPJ(R)	;IMPOSSIBLE TO FIND AN EXACT MATCH NOW
LOKUP2:	SOSA	FA,MCHADR(R)	;GET SYMBOL TABLE ADDR OF THIS STRING BLOCK
LOKUP3:	 SKIPA	FA,DIRLOC(R)	;HERE IF EXACT MATCH, GET STRING`S SYM TAB ADDR
	  MOVEM	FA,DIRLOC(R)	;IF RECOGNIZING, SAVE THE SYMBOL TABLE ADDR
	ADDI	FA,(R)		;MAKE THE STRING`S SYMBOL TABLE ADDR RELOCATABLE
	HRRZ	FA,DIRORG(FA)	;GET EITHER DIRECTORY NUMBER OR FILE`S FDB ADDR
	TLNN	BF,(FL.REC)	;ARE WE PROCESSING A ^F AR ALTMODE?
	  JRST	CPOPJ1(R)	;NO, SKIP RETURN SINCE WE FOUND THE STRING
	MOVE	T4,DIRLOC(R)	;YES, GET THIS STRING`S SYMBOL TABLE ADDRESS
	ADDI	T4,(R)		;MAKE THIS ADDRESS RELOCATABLE
	MOVS	T4,DIRORG(T4)	;GET THE STRING BLOCK ADDR IN THE RH
	PJRST	TYPFLD(R)	;FILL OUT THE REST OF THIS FIELD AND SKIP RETURN

;Routine to find a matching directory or file name (called via "?")

LOKMCH:	MOVE	T2,SYMBOT(R)	;GET THE STARTING ADDR OF THE SYMBOL TABLE
	SUB	T2,SYMTOP(R)	;COMPUTE THE -NUMBER OF ENTRIES IN THE TABLE
	MOVSS	T2		;WANT -ENTRY COUNT IN THE LH
	HRR	T2,SYMBOT(R)	;GET THE STARTING ADDR OF SYMBOL TABLE IN RH
	ADDI	T2,(R)		;MAKE THE SYMBOL TABLE ADDR RELOCATABLE
LKMCH1:	SKIPN	DIRORG(T2)	;DOES THIS SYMBOL TABLE ENTRY EXIST?
	  JRST	LKMCH3(R)	;NO, CHECK NEXT IF SYMBOL TABLE NOT EXHAUSTED
	MOVEM	T2,DIRLOC(R)	;YES, SAVE THE SYMBOL TABLE ADDRESS
	PUSHJ	P,NAMCM1(R)	;CALL ROUTINE TO COMPARE THE TWO STRINGS
	  JRST	LKMCH2(R)	;HERE IF THIS STRING .GT. OUR STRING
	  JRST	LKMCH2(R)	;HERE IF THIS STRING .LT. OUR STRING
	  JFCL			;HERE IF OUR STRING IS A SUBSET OF THIS STRING
	MOVE	T2,DIRLOC(R)	;HERE IF EXACT MATCH, GET THE SYMBOL TABLE ADDR
	MOVS	T4,DIRORG(T2)	;GET RELATIVE ADDR OF THIS STRING BLOCK
	PUSHJ	P,TYPMCH(R)	;AND SHOW THIS (MATCHING) STRING TO THE OPERATOR
LKMCH2:	  MOVE	T2,DIRLOC(R)	;RESTORE THE SYMBOL TABLE POINTER
LKMCH3:	AOBJN	T2,LKMCH1(R)	;LOOP BACK IF MORE SYMBOL TABLE ENTRIES TO CHECK
	POPJ	P,		;SYMBOL TABLE EXHAUSTED, RETURN TO CALLER
;Routine to set up the field that we`re about to recognize

SETFLD:	SETZM	FLDBLK(R)	;ZERO THE ENTIRE FIELD BLOCK
	HRLI	T2,FLDBLK(R)
	HRRI	T2,FLDBLK+1(R)
	BLT	T2,FLDBLK+<<CH%FLD+4>/5>-1(R)
	HRRZ	T4,FLDSPC(R)	;GET THE STARTING ADDR OF THIS COMMAND FIELD
	HLRZ	T1,FLDSPC(R)	; AND THE NUMBER OF CHARS IN THIS FIELD
	TLZN	BF,(FL.DLM)	;DOES THIS FIELD START WITH A DELIMITER?
	  TLOA	T4,(POINT 7)	;NO, GET BYTE PTR TO FIRST CHARACTER IN FIELD
	TLOA	T4,(POINT 7,,6)	;YES, GET BYTE PTR TO FIRST CHAR AFTER DELIMITER
	  SOJA	T1,.+2(R)	;DON`T COUNT THE CLOSING DELIMITER
	SUBI	T1,2		;DON`T COUNT OPENING AND CLOSING DELIMITERS
	MOVEI	T2,(T1)		;GET A COPY OF THE CHARACTER COUNT
	JUMPE	T1,STFLD2(R)	;JUMP IF THIS IS A NULL FIELD
	MOVE	T3,[POINT 7,FLDBLK(R)](R) ;BYTE PTR TO SET UP FIELD BLOCK
STFLD1:	ILDB	B,T4		;GET A CHARACTER FROM THE ELEMENT
	IDPB	B,T3		;AND STUFF IT INTO THE FIELD BLOCK
	SOJG	T2,STFLD1(R)	;LOOP BACK IF MORE CHARS TO COPY
	MOVNS	T1		;WANT NEGATIVE CHARACTER COUNT
	IDIVI	T1,5		;COMPUTE -INTEGRAL NUMBER OF WORDS IN FIELD
	MOVSS	T1		;STUFF IT IN THE LH
	SKIPE	T3,T2		;WERE THERE ANY REMAINING BYTES?
	  MOVSI	T2,(177B6)	;YES, SET UP MASK FOR FIRST REMAINING BYTE
	IMULI	T3,7		;CONVERT -BYTE COUNT TO -BIT COUNT
	ASH	T2,7(T3)	;SET UP THE MASK FOR THE LAST WORD IN THE FIELD
STFLD2:	HRRI	T1,FLDBLK(R)	;NOW HAVE -WORD COUNT,,ADDR OF FIRST WORD
	MOVEM	T1,DIRINP(R)	;SAVE THE -WORD COUNT,,FIELD ADDRESS
	MOVEM	T2,DIRMSK(R)	; AND THE MASK FOR THE LAST WORD IN THE FIELD
	POPJ	P,		;RETURN TO CALLER

;Routine to prepare a string for STRCMP

NAMCMM:	ADDI	T2,(R)		;MAKE SYMBOL TABLE POINTER RELOCATABLE
NAMCM1:	MOVS	T1,DIRORG(T2)	;GET ENTRY TYPE,,STRING BLOCK ADDRESS
	TLNE	T1,(7B2)	;DOES THIS STRING HAVE A NON-ZERO ENTRY TYPE?
	  POPJ	P,		;YES, THEN MOVE DOWN IN THE SYMBOL TABLE
NAMCM2:	MOVEI	T2,DIRORG(T1)	;GET RELATIVE ADDR OF LENGTH OF THIS STRING
	ADDI	T2,(R)		;MAKE ADDRESS RELOCATABLE
	MOVN	T2,(T2)		;GET -LENGTH OF THIS STRING BLOCK
	MOVSI	T2,2(T2)	;NOW HAVE -LENGTH OF THIS STRING IN LH
	HRRI	T2,DIRORG+1(T1)	;GET RELATIVE ADDRESS OF THIS STRING
	ADDI	T2,(R)		;MAKE ADDRESS RELOCATABLE
	MOVE	T1,DIRINP(R)	;GET -LENGTH,,ADDR OF OUR STRING
	MOVE	T3,DIRMSK(R)	;GET MASK FOR LAST WORD OF OUR STRING
;	PJRST	STRCMP(R)	;CONTINUE WITH THE STRING COMPARE
;Routine to compare two strings

STRCMP:	PUSH	P,T3		;SAVE THE MASK FOR THE LAST WORD OF OUR STRING
STRCM0:	JUMPGE	T1,STRCM1(R)	;JUMP IF DOWN TO LAST WORD OF OUR STRING
	JCRY0	.+1(R)		;INSURE THAT THE CARRY 0 FLAG IS OFF
	MOVE	T4,(T2)		;GET A WORD FROM THE TEST STRING
	TRZ	T4,1B35		;CLEAR THE UNUSED BIT (JUST IN CASE)
	SUB	T4,(T1)		;COMPARE TEST STRING WORD TO WORD IN OUR STRING
	JUMPE	T4,STRCM2(R)	;JUMP IF THESE WORDS ARE EQUAL
	JCRY0	.+2(R)		;SKIP IF OUR STRING .LT. TEST STRING
STRCM3:	AOS	-1(P)		;HERE IF OUR STRING .GT. TEST STRING
	POP	P,T3		;RESTORE THE MASK
	POPJ	P,		;AND RETURN TO CALLER
STRCM2:	JUMPGE	T2,STRCM3(R)	;JUMP IF TEST STRING IS EXHAUSTED
	AOBJN	T1,.+1(R)	;STEP TO NEXT WORD OF EACH STRING
	AOBJN	T2,STRCM0(R)	; AND LOOP BACK TO CHECK THESE WORDS
	JRST	STRCM0(R)	;LOOP BACK IF LAST WORD OF TEST STRING
STRCM1:	POP	P,T3		;RESTORE THE MASK FOR THE LAST WORD
	MOVE	T4,(T1)		;GET THE LAST WORD OF OUR STRING
	AND	T4,T3		;CLEAR OUT ANY REMAINING GARBAGE
	SKIPL	T2		;IF TEST STRING IS ALSO DOWN TO LAST WORD,
	 CAME	T4,(T2)		; THEN CHECK FOR AN EXACT MATCH
	  JRST	STRCM4(R)	;HERE IF NOT AN EXACT MATCH
	MOVEI	T4,3		;HERE IF BOTH STRINGS ARE IDENTICAL
	ADDM	T4,(P)		;BUMP RETURN ADDR FOR TRIPLE SKIP RETURN
	POPJ	P,		;AND RETURN TO CALLER+4
STRCM4:	AND	T3,(T2)		;MAKE TEST STRING THE SAME LENGTH AS OUR STRING
	JCRY0	.+1(R)		;INSURE THAT CARRY 0 FLAG IS OFF
	SUB	T3,T4		;COMPARE OUR STRING TO TRUNCATED TEST STRING
	JUMPE	T3,CPOPJ2(R)	;DOUBLE SKIP RETURN IF OUR STRING IS A SUBSET
	JCRY0	CPOPJ(R)	;NON-SKIP RETURN IF OUR STRING .LT. TEST STRING
	JRST	CPOPJ1(R)	;SKIP RETURN IF OUR STRING .GT. TEST STRING

;Routine to check a subset match (called via ?, ^F, and altmode)

CHKREC:	TLNE	BF,(FL.MCH)	;LOOKING FOR EXTENSIONS THAT MATCH OURS?
	  PJRST	TYMCH0(R)	;YES, TYPE THIS EXTENSION AND RETURN TO CALLER
	TLNN	BF,(FL.REC)	;PROCESSING A ^F OR ALTMODE?
	  JRST	CPOPJ1(R)	;NO, THEN SKIP RETURN BACK TO CALLER
	TLCN	BF,(FL.FND)	;YES, HAVE WE ALREADY FOUND A SUBSET MATCH?
	  POPJ	P,		;NO, RETURN (THIS IS THE FIRST SUBSET MATCH)
	JRST	CPOPJ2(R)	;YES, THEN OUR STRING IS AMBIGUOUS
;Routine to type a string that matches the current command field

TYMCH0:	MOVS	T4,FDBEXT(FA)	;HERE FOR EXTENSION, GET ITS STRING BLOCK ADDR
TYPMCH:	MOVEI	C,[ASCIZ \
  \](R)
	PUSHJ	P,$STRO(R)	;INDENT BEFORE TYPING THE MATCHING STRING
	MOVEI	C,DIRORG+1(T4)	;GET THE RELATIVE ADDR OF THIS STRING
	ADDI	C,(R)		;MAKE THE STRING ADDR RELOCATABLE
	SKIPN	(C)		;IS THIS A NULL STRING?
	  MOVEI	C,[ASCIZ \[Null]\](R) ;YES, THEN TYPE THIS INSTEAD
	AOS	(P)		;BUMP RETURN ADDRESS FOR SKIP RETURN
	PJRST	$STRO(R)	;TYPE THIS STRING AND SKIP RETURN TO CALLER

;Routine to finish up a recognized command field (called with string addr in T4)

TYPFLD:	MOVEI	T4,DIRORG+1(T4)	;GET THE RELATIVE ADDR OF THIS STRING
	ADDI	T4,(R)		;MAKE THE STRING ADDRESS RELOCATABLE
	HRLI	T4,(POINT 7)	;CONVERT STRING ADDR INTO A BYTE POINTER
	MOVEI	T1,(NC)		;GET THE NUMBER OF CHARS IN THIS COMMAND FIELD
	TLNE	BF,(FL.DIR)	;DID WE JUST RECOGNIZE THE DIRECTORY SPEC?
	  SOJ	T1,		;YES, ADJUST COUNT FOR OPENING DELIMITER
TYFLD1:	ILDB	B,T4		;GET THE NEXT CHARACTER IN THIS STRING
	SOJGE	T1,TYFLD1(R)	;SKIP THE NUMBER OF CHARS ALREADY TYPED BY OPR
	JUMPE	B,TYFLD2(R)	;JUMP IF WE`VE HIT THE END OF THE STRING
	IDPB	B,M		;STUFF THIS CHAR INTO THE COMMAND BUFFER
	PUSHJ	P,TYPCHR(R)	;AND SHOW IT TO THE OPERATOR
	AOJA	NC,TYFLD1(R)	;BUMP FIELD COUNT AND LOOP BACK FOR NEXT CHAR
TYFLD2:	MOVEI	T1,1(CM)	;GET THE COMMAND LEVEL FOR THIS FIELD
	ADDI	T1,(R)		;AND MAKE IT RELOCATABLE
	MOVE	B,[EXP 076,".",";"]-CM%DIR(T1) ;GET THIS FIELD`S DELIMITER
	IDPB	B,M		;STUFF THE DELIMITER INTO THE COMMAND BUFFER
	AOS	(P)		;BUMP RETURN ADDRESS FOR SKIP RETURN
	PJRST	TYPCHR(R)	;SHOW THIS DELIMITER TO THE OPR AND SKIP RETURN

;Routine to finish up a recognized (default) version number

TYPVER:	MOVS	M,CM		;GET STARTING ADDR OF THE VERSION FIELD
	HRLI	M,(POINT 7)	;CONVERT ADDR INTO A BYTE POINTER
	HLRZ	T1,FDBVER(FA)	;GET THE VERSION NUMBER FROM THE FDB
TYVER1:	IDIVI	T1,^D10		;STANDARD ROUTINE TO DECODE A NUMBER
	HRLM	T2,(P)		;SAVE THE REMAINDER ON THE STACK
	JUMPE	T1,.+2(R)	;ARE WE FINISHED DECODING YET?
	  PUSHJ	P,TYVER1(R)	;NO, CALL THIS ROUTINE RECURSIVELY
	HLRZ	B,(P)		;GET A BINARY DECIMAL DIGIT FROM THE STACK
	ADDI	B,"0"		;CONVERT IT TO ASCII
	IDPB	B,M		;STUFF THIS DIGIT INTO THE VERSION FIELD
	AOJA	NC,TYPCHR(R)	;BUMP THE VERSION CHAR COUNT AND TYPE THIS DIGIT
SUBTTL	Routines to execute the switches

;Routine to execute the ,G and ,start-addr switches (start the specified file)

LOADGO:	TLNE	BF,(FL.SWT)	;IS THIS CMD JUST A SWITCH?
	  JRST	STPROG(R)	;YES, START THE FILE ALREADY IN CORE
	TLO	BF,(FL.RUN)	;NO, FLAG TO START FILE AFTER LOADING IT

;Routine to execute the ,L switch (load the specified file into core)

GETFIL:	MOVE	T1,FDBCTL(FA)	;GET THIS FILE`S CONTROL BITS
	TLNE	T1,(FDBDEL!FDBNXF!FDBLNG!FDBSHT!FDBENV!FDBSUB!FDBEPH)
	  JRST	BADCTL(R)	;UNUSABLE FILE IF ANY OF THESE BITS ARE SET
	MOVE	A,FDBADR(FA)	;GET THIS FILE`S INDEX BLOCK ADDRESS
	MOVEI	C,PAGE.1(R)	;ADDR OF WHERE TO READ THIS INDEX BLOCK
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET THIS FILE`S INDEX BLOCK
	MOVE	A,PAGE.1(R)	;GET DISK ADDR OF FIRST PAGE OF THIS FILE
	MOVEI	C,PAGE.2(R)	;ADDR OF WHERE TO READ THIS PAGE
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET FIRST PAGE OF THIS FILE
IFE <4-FTVER>,<			;ASSEMBLE FOLLOWING IF USER LEVEL VERSION
	SETO	A,		;PMAP ARGS TO REMOVE SPECIFIED PAGE
	MOVSI	B,(1B0)		; FROM CURRENT FORK
	MOVEI	T1,<PAGE.0_-^D9>-1 ;NUMBER OF PAGES BELOW BOTTOM OF BOOTS
GTFIL1:	HRRI	B,(T1)		;GET A PAGE NUMBER
	PMAP			;AND REMOVE THIS PAGE FROM UPMP
	SOJG	T1,GTFIL1(R)	;UNMAP PAGES 1 TO PAGE.0-1
	SETZM	PAGE.0(R)	;CLEAR PAGE 0 BUFFER
	MOVSI	T1,PAGE.0(R)
	HRRI	T1,PAGE.0+1(R)>
IFN <4-FTVER>,<			;ASSEMBLE FOLLOWING IF NOT USER LEVEL VERSION
	SETZM	1000		;CLEAR CORE FROM PAGE 1 TO BOTTOM OF BOOTS
	MOVE	T1,[1000,,1001](R)>
	BLT	T1,PAGE.1-1(R)	;BEFORE LOADING FILE
	HLRE	T1,PAGE.2(R)	;GET THE FIRST WORD OF THIS FILE
	CAIN	T1,1776		;IS THIS A TOPS-20 TYPE SAVE FILE (I.E. EXE)?
	  JRST	GETEXE(R)	;YES, GO READ THIS EXE FILE INTO CORE
	CAIN	T1,1000		;IS THIS AN SSAVE TYPE FILE?
	  JRST	GETSSA(R)	;YES, GO READ THIS SSAVE FILE INTO CORE
	JUMPGE	T1,NOTSAV(R)	;IF NON-NEGATIVE THEN THIS IS NOT A SAVE FILE
;	JRST	GETSAV(R)	;IF NEGATIVE THEN THIS IS A SAVE TYPE FILE
;Routine to load a SAVE file into core

GETSAV:	SETZ	T2,		;FORCE LOADING OF FIRST IOWD IN FIRST DATA PAGE
	MOVEI	T3,PAGE.1(R)	;GET ADDRESS OF INDEX BLOCKS FOR THIS FILE
	JRST	GTSAV2(R)	;SET UP AOBJN POINTER FOR FIRST DATA PAGE
GTSAV1:	AOBJN	T1,GTSAV3(R)	;JUMP IF AT LEAST ONE MORE WORD IN THIS PAGE
	MOVE	A,(T3)		;PAGE IS EMPTY, GET ADDR OF NEXT DATA PAGE
	MOVEI	C,PAGE.2(R)	;ADDR OF WHERE TO READ THIS PAGE
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET THIS PAGE
GTSAV2:	MOVSI	T1,-1000	;SET UP AOBJN POINTER TO READ THIS PAGE
	HRRI	T1,PAGE.2(R)	;(USE AOBJN POINTER TO SIMULATE PAGE FAULTING)
	AOJ	T3,		;GET ADDRESS OF INDEX BLOCK FOR NEXT PAGE
GTSAV3:	JUMPL	T2,GTSAV4(R)	;JUMP IF IOWD COUNT IS NOT EXHAUSTED
	SKIPGE	T2,(T1)		;IS THERE ANOTHER IOWD FOR THIS FILE?
	  JRST	GTSAV1(R)	;YES, LOOP BACK TO GET NEXT DATA WORD
	JRST	GETVEC(R)	;NO, GO PROCESS THE ENTRY VECTOR
GTSAV4:	PUSH	P,(T1)		;SAVE THE DATA WORD
	MOVEI	T4,1(T2)	;GET CORE ADDRESS FOR THIS DATA WORD
	CAIL	T4,PAGE.0(R)	;WILL THIS DATA WORD OVERLAY BOOTS?
	  JRST	OVRLAY(R)	;YES, TELL OPERATOR ABOUT THIS AND QUIT
	CAIG	T4,777		;DOES THIS DATA WORD GO INTO PAGE 0?
	  ADDI	T4,PAGE.0(R)	;YES, SET UP PAGE 0 BEFORE STARTING PROGRAM
	POP	P,(T4)		;STUFF THIS DATA WORD INTO CORE
	AOBJN	T2,GTSAV1(R)	;LOOP BACK FOR NEXT DATA WORD
	JRST	GTSAV1(R)	;LOOP BACK FOR NEXT IOWD (OR ENTRY VECTOR)

;Routine to load an SSAVE file into core

GETSSA:	MOVN	T1,PAGE.2(R)	;GET THE -NUMBER OF DATA PAGES IN THIS FILE
	MOVSS	T1		;WANT -NUMBER IN LH
	HRRI	T1,PAGE.2+1(R)	;CREATE AOBJN POINTER TO READ ALL PAGES
GTSSA1:	HRRZ	A,(T1)		;GET OFFSET INTO INDEX BLOCK FOR THIS PAGE
	ADDI	A,PAGE.1(R)	;COMPUTE ADDRESS OF THIS PAGE`S DISK ADDR
	MOVE	A,(A)		;GET THIS PAGE`S LINEAR DISK ADDRESS
	HLRZ	C,(T1)		;GET THE CORRESPONDING CORE PAGE
	TRZ	C,777B26	;CLEAR THE ACCESS BITS FOR THIS PAGE
	LSH	C,^D9		;CONVERT CORE PAGE ADDR TO CORE ADDRESS
	CAIL	C,PAGE.0(R)	;WILL THIS PAGE OVERLAY BOOTS?
	  JRST	OVRLAY(R)	;YES, TELL OPERATOR ABOUT THIS AND QUIT
	JUMPN	C,.+2(R)	;JUMP IF NOT LOADING CORE PAGE 0
	  MOVEI	C,PAGE.0(R)	;SET UP PAGE 0 BEFORE STARTING PROGRAM
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET THIS PAGE OF THE FILE
	AOBJN	T1,GTSSA1(R)	;LOOP BACK IF MORE PAGES TO READ
	HLRZ	T2,(T1)		;GET LH OF WORD FOLLOWING LAST DATA PAGE
	CAIE	T2,1000		;ARE THERE MORE DATA PAGES TO LOAD?
	  JRST	GETVEC(R)	;NO, THEN GO PROCESS THE ENTRY VECTOR
	MOVN	T2,(T1)		;YES, GET -NUMBER OF FOLLOWING DATA PAGES
	HRLI	T1,(T2)		;CREATE AOBJN POINTER TO READ THESE PAGES
	AOJA	T1,GTSSA1(R)	;LOOP BACK TO LOAD THE REST OF THIS FILE
;Routine to load an EXE file into core

GETEXE:	HRRZ	T2,PAGE.2(R)	;GET THE NUMBER OF WORDS IN DIRECTORY SECTION
	SOJLE	T2,NOTSAV(R)	;DON`T CONSIDER THE HEADER WORD
	LSH	T2,-1		;THERE ARE TWO WORDS PER PAGE GROUP
	MOVNS	T2		;GET -NUMBER OF GROUPS IN DIRECTORY SECTION
	MOVSS	T2		;WANT -NUMBER OF GROUPS IN LH
	HRRI	T2,PAGE.2+1(R)	;CREATE AOBJN POINTER TO THE PAGE GROUPS
GTEXE1:	HRRZ	T1,(T2)		;GET THE FILE`S PAGE NUMBER FOR THIS GROUP
	JUMPE	T1,GTEXE2(R)	;IGNORE ZERO PAGES (PAGE FAULTING HANDLES THESE)
	LDB	T3,[POINT 9,1(T2),8](R) ;GET THE REPEAT COUNT FOR THIS GROUP
	HRRZ	T4,1(T2)	;GET THE DESTINATION CORE PAGE ADDRESS
	ADDI	T4,(T3)		;COMPUTE HIGHEST PAGE ADDRESS IN THIS GROUP
	LSH	T4,^D9		;CONVERT CORE PAGE ADDRESS TO WORD ADDRESS
	CAIL	T4,PAGE.0(R)	;WILL ANY PAGE IN THIS GROUP OVERLAY BOOTS?
	  JRST	OVRLAY(R)	;YES, TELL OPERATOR ABOUT THIS AND QUIT
	MOVNI	T3,1(T3)	;NO, COMPUTE -NUMBER OF PAGES IN THIS GROUP
	HRLI	T1,(T3)		;CREATE AOBJN POINTER TO READ THESE PAGES
	ADDI	T1,PAGE.1(R)	;GET ADDR OF INDEX BLOCK FOR FIRST PAGE IN GROUP
	HRRZ	C,1(T2)		;GET THE DESTINATION CORE PAGE ADDRESS
	JUMPN	C,.+2(R)	;JUMP IF NOT LOADING PAGE 0
	  JRST	[MOVE	A,(T1)		;GET LINEAR DISK ADDR FOR PAGE 0
		 MOVEI	C,PAGE.0(R)	;SET UP PAGE 0 BEFORE STARTING PROGRAM
		 PUSHJ	P,GETPAG(R)	;CALL SAIO TO LOAD THIS PAGE
		 AOBJP	T1,GTEXE2(R)	;JUMP IF ONLY ONE PAGE IN THIS GROUP
		 AOJA	C,.+1(R)](R)	;GO LOAD THE REST OF THIS GROUP
	LSH	C,^D9		;CONVERT CORE PAGE ADDRESS TO WORD ADDRESS
	PUSHJ	P,GTPAG1(R)	;CALL SAIO TO READ THESE PAGES
GTEXE2:	AOJ	T2,		;GET ADDRESS OF NEXT PAGE GROUP
	AOBJN	T2,GTEXE1(R)	;LOOP BACK IF MORE PAGE GROUPS TO READ
	MOVE	T1,(T2)		;GET THE FIRST WORD OF THE NEXT SECTION
	CAME	T1,[1775,,3](R)	;IS THIS THE ENTRY VECTOR SECTION?
	  JRST	NOTSAV(R)	;NO, THEN THIS IS A BAD EXE FILE
	MOVE	T1,1(T2)	;YES, GET NUMBER OF WORDS IN THE ENTRY VECTOR
	HRLM	T1,2(T2)	;CREATE A ONE WORD ENTRY VECTOR (FOR GETVEC)
	MOVE	T1,3(T2)	;FINALLY, GET THE TERMINATING SECTION WORD
	CAME	T1,[1777,,1](R)	;IS THIS REALLY THE TERMINATING SECTION?
	  JRST	NOTSAV(R)	;NO, THEN THIS IS A BAD EXE FILE
	MOVEI	T1,2(T2)	;YES, GET THE ADDR OF THIS FILE`S ENTRY VECTOR
;	JRST	GETVEC(R)	;AND GO PROCESS THE ENTRY VECTOR
;Routine to process the entry vector (called with entry vector addr in T1)

GETVEC:	HLRZ	T2,(T1)		;GET THE LH OF THE ENTRY VECTOR
	CAIE	T2,(JRST)	;IS THIS A 10/50 FORMAT ENTRY VECTOR?
	TRNN	T2,777B26	; OR A VALID TENEX ENTRY VECTOR?
	SKIPA	T2,(T1)		;YES, USE RH OF ENTRY VECTOR AS STARTING ADDR
	  JRST	NOTSAV(R)	;NO, THEN THIS FILE IS NOT A SAVE FILE
	SKIPN	STADDR(R)	;DID THE OPERATOR SPECIFY A STARTING ADDR?
	  HRRZM	T2,STADDR(R)	;NO, THEN START PGM VIA ENTRY VECTOR ADDR
	TLZE	BF,(FL.RUN)	;SHOULD WE START THIS FILE?
	  JRST	STPROG(R)	;YES
	TRO	BF,FR.FIC	;FLAG THAT THERE`S A USEABLE FILE IN CORE
	MOVEI	1,PAGE.0(R)	;GET ADDR OF FILE`S PAGE 0
	MOVEI	C,[ASCIZ \ Page 0 loaded at %1O
\](R)
	PJRST	$STRO(R)	;TELL USER WHERE PAGE 0 IS AND GET NEXT CMD
STPROG:	MOVSI	T1,PAGE.0+20(R)	;SET UP CORE PAGE 0
	HRRI	T1,20
	BLT	T1,777
IFN <4-FTVER>,<			;ASSEMBLE FOLLOWING IF NOT USER LEVEL VERSION
	CONO	PI,1B23!1B27	;CLEAR AND DEACTIVATE THE PI SYSTEM
	CONO	TTY,0		;REMOVE THE CTY FROM THE PI SYSTEM
	BTSFLG>			;CLEAR ALL I/O DEVICES
	JRST	@STADDR(R)	;NOW START THE PROGRAM 
SUBTTL	Miscellaneous disk I/O routines

;Routine to get an 8 or 16 page directory block into core

GETDIR:	PUSH	P,C		;SAVE THE ADDR OF WHERE TO READ THIS DIRECORY
	MOVEI	A,PAGE.1(T3)	;GET ADDR OF INDEX BLOCK FOR THIS DIRECTORY
	ADDI	A,(R)		;MAKE THE ADDRESS RELOCATABLE
	MOVE	A,(A)		;GET THE LINEAR DISK ADDR OF THIS INDEX BLOCK
	MOVEI	C,PAGE.2(R)	;ADDR OF WHERE TO READ THIS INDEX BLOCK
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO GET THIS INDEX BLOCK
	MOVEI	T1,PAGE.2(T4)	;GET ADDR OF DIRECTORY BLOCK ADDRS FOR THIS DIR
	ADDI	T1,(R)		;MAKE THIS ADDRESS RELOCATABLE
	POP	P,C		;RESTORE ADDR OF WHERE TO READ THIS DIR BLOCK
	SKIPL	FDFMTF(R)	;DOES THIS SYSTEM HAVE NEW DIRECTORY FORMAT?
;	  PJRST	GT16PG(R)	;YES, GET ENTIRE 16 PAGE DIRECTORY
;	PJRST	GET8PG(R)	;NO, GET HALF OF THE 16 DIRECTORY PAGES

;Routine to get a block of pages (called with addr of page addrs in T1)

GT16PG:	TLOA	T1,-^D16	;SET UP AOBJN COUNTER TO READ 16 PAGES
GET8PG:	  TLO	T1,-^D8		;SET UP AOBJN COUNTER TO READ 8 PAGES
GTPAG1:	MOVE	A,(T1)		;GET THE LINEAR DISK ADDR FOR THIS PAGE
	PUSHJ	P,GETPAG(R)	;CALL SAIO TO READ THIS PAGE
	ADDI	C,1000		;GET ADDRESS OF WHERE TO READ NEXT PAGE
	AOBJN	T1,GTPAG1(R)	;LOOP BACK IF MORE PAGES TO READ
	POPJ	P,		;ELSE RETURN TO CALLER

;Routine to get a page (called with disk addr in A and core addr in C)

GETPAG:	TLZ	A,DSKMSK	;ISOLATE THE LINEAR DISK ADDRESS
	PUSH	P,A		;SAVE THE LINEAR DISK ADDRESS
	IDIV	A,CNVTRK(R)	;CONVERT LINEAR DISK ADDRESS TO TRACK NUMBER
	CAML	A,LOTRK(R)	;IS THIS DISK ADDR WITHIN THE FILE SYSTEM AREA?
	CAML	A,HITRK(R)
	  JRST	BADADR(R)	;NO, TELL OPR THAT SOMETHING`S REALLY FOULED UP
	POP	P,A		;YES, RESTORE THE LINEAR DISK ADDRESS
	TLO	A,(LINADR)	;TELL SAIO THAT THIS IS A LINEAR ADDRESS
	MOVEI	B,1000		;ALWAYS READ ONE ENTIRE PAGE AT A TIME
	PUSHJ	P,$DSKOP(R)	;CALL SAIO TO READ THIS PAGE
	JUMPE	A,CPOPJ(R)	;RETURN TO CALLER IF NO ERRORS ENCOUNTERED
	JRST	INPERR(R)	;NOTIFY THE OPERATOR ABOUT THE INPUT ERROR
SUBTTL	Miscellaneous CTY I/O routines

;Routine to get a char from monitor command or CTY (char returned in B)

GETCHR:	SKIPN	MONCMD(R)	;PROCESSING A MONITOR COMMAND?
	  JRST	GTCHR1(R)	;NO, GO CHECK THE TYPE AHEAD BUFFER
	ILDB	B,MONCMD(R)	;YES, GET A CHAR FROM THE COMMAND?
	JUMPN	B,CPOPJ(R)	;RETURN IF NOT AT END OF COMMAND
	SETZM	MONCMD(R)	;END OF MONITOR CMD, GET NEXT CHAR FROM CTY
GTCHR1:
IFN <4-FTVER>,<			;ASSEMBLE FOLLOWING IF NOT USER LEVEL VERSION
	TLNN	BF,(FL.BFR)	;ANY CHARS IN TYPE AHEAD BUFFER?
	  JRST	GTCHR1(R)	;NO, KEEP LOOPING TILL OPR TYPES A CHAR
	PUSH	P,T1		;YES, GET A WORK AC
	MOVE	T1,BFRTIT(R)	;GET THE INPUT TAKER BYTE PTR
	PUSHJ	P,CHKPTR(R)	;INCREMENT BYTE PTR AND CHECK FOR OVERFLOW
	MOVEM	T1,BFRTIT(R)	;SAVE THE NEW TAKER BYTE PTR
	LDB	B,T1		;RETRIEVE A CHAR FROM TYPE AHEAD BUFFER
	CAMN	T1,BFRTIP(R)	;DID WE CATCH UP TO THE PUTTER?
	  TLZ	BF,(FL.BFR)	;YES, FLAG THAT BUFFER IS NOW EMPTY
	POP	P,T1		;RESTORE THE WORK AC
	POPJ	P,>		;AND RETURN
IFE <4-FTVER>,<			;ASSEMBLE FOLLOWING IF USER LEVEL VERSION
	PUSHJ	P,$TTYIW(R)	;WAIT FOR A CHAR FROM THE CTY
	ANDI	B,177		;ISOLATE THE 7-BIT ASCII CHAR
	CAIN	B,"C"-100	;IS THIS A ^C?
	  JRST	[PUSHJ	P,TYPCHR(R)	;YES, ECHO IT (IN ARROW MODE)
		 PUSHJ	P,TYCRLF(R)	;FOLLOWED BY A CR-LF
		 HALTF](R)		;AND QUIT
	JUMPN	B,CPOPJ(R)	;RETURN IF NON-NULL ASCII CHAR
	JRST	GTCHR1(R)>	;IGNORE NULLS
IFN <4-FTVER>,<			;ASSEMBLE FOLLOWING IF NOT USER LEVEL VERSION
;Interrupt level routine to buffer any operator type ahead

CTYINT:	0			;FLAGS,,PC FOR INTERRUPT RETURN STORED HERE
	CONSZ	TTY,1B30	;INPUT DONE?
	  JRST	BFRCHR(R)	;YES, GO GET THIS CHARACTER
	CONSZ	TTY,1B32	;OUTPUT DONE?
	  CONO	TTY,1B28!CTYPIA	;YES, CLEAR THE OUTPUT DONE FLAG
	JEN	@CTYINT(R)	;AND DISMISS THIS INTERRUPT
BFRCHR:	PUSH	P,B		;SAVE AC B
	PUSHJ	P,$TTYIW(R)	;CALL SAIO TO GET THE CHAR JUST TYPED
	JUMPE	B,BFCHR2(R)	;IGNORE ASCII NULLS
	CAIE	B,"C"-100	;DID THE OPERATOR TYPE A ^C
	CAIN	B,"X"-100	; OR A ^X?
	  JRST	[CONO	PI,1B23!1B27	;YES, CLEAR AND DEACTIVATE PI SYSTEM
		 PUSHJ	P,TYPCHR(R)	;ECHO THE ^C OR ^X
		 JRST	BEGBTS(R)](R)	;AND CANCEL THIS COMMAND
	PUSH	P,T1		;GET A WORK AC
	MOVE	T1,BFRTIP(R)	;GET THE INPUT PUTTER BYTE PTR
	TLOE	BF,(FL.BFR)	;IS THIS THE 1ST CHAR IN THE BUFFER?
	CAME	T1,BFRTIT(R)	;NO, HAVE WE CAUGHT UP TO THE TAKER?
	  JRST	BFCHR1(R)	;HERE IF 1ST CHAR OR BUFFER NOT FULL
	POP	P,T1		;TYPE AHEAD BUFFER IS FULL, RESTORE WORK AC
	MOVEI	B,""		;IGNORE THIS CHAR AND RING BELL
	PUSHJ	P,$TTYO(R)	; TO INDICATE THAT BUFFER IS FULL
	JRST	BFCHR2(R)	;FINISHED WITH THIS INTERRUPT
BFCHR1:	PUSHJ	P,CHKPTR(R)	;INCREMENT BYTE PTR AND CHECK FOR OVERFLOW
	MOVEM	T1,BFRTIP(R)	;SAVE THE NEW PUTTER BYTE PTR
	DPB	B,T1		;STUFF THIS CHAR IN THE TYPE AHEAD BUFFER
	POP	P,T1		;RESTORE THE WORK AC
BFCHR2:	POP	P,B		;RESTORE AC B
	JEN	@CTYINT(R)	;AND DISMISS THIS INTERRUPT

;Routine to wrap around the PUTTER/TAKER byte pointers (called with ptr in T1)

CHKPTR:	IBP	T1		;GET BYTE PTR TO NEXT CHARACTER
	PUSH	P,T2		;GET A WORK AC
	MOVEI	T2,(T1)		;GET WORD ADDR OF THIS BYTE PTR
	CAIL	T2,INPBFR+BF%WDS ;HAVE WE REACHED THE END OF THE BUFFER?
	  SUBI	T1,BF%WDS	;YES, THEN POINT TO 1ST BYTE IN BUFFER
	POP	P,T2		;RESTORE THE WORK AC
	POPJ	P,>		;AND RETURN WITH UPDATED BYTE PTR IN T1
;Routine to retype the current command line

TYPCMD:	MOVEI	C,[ASCIZ \
 \](R)
	PUSHJ	P,$STRO(R)	;RETYPE THE COMMAND ON A NEW LINE
	PUSH	P,M		;SAVE THE CURRENT BYTE POINTER
	MOVSI	T1,-CM%SWT	;CREATE AOBJN PTR TO TYPE ALL COMPLETED FIELDS
	HRRI	T1,ELMTAB(R)
TYCMD1:	SKIPGE	(T1)		;HACK FOR EXPLICIT -2 OR 0 VERSION
	  JRST	[MOVE	1,VERNUM(R)	;GET THE ACTUAL VERSION NUMBER
		 MOVEI	C,[ASCIZ \%1D\](R)
		 PUSHJ	P,$STRO(R)	;TYPE IT (INSTEAD OF -2 OR 0)
		 JRST	TYCMD2(R)](R)	;GO CHECK THE SWITCH FIELD
	SKIPE	M,(T1)		;DID THE OPERATOR SPECIFY THIS FIELD?
	  PUSHJ	P,TYPSTR(R)	;YES, THEN TYPE IT OUT
TYCMD2:	AOBJN	T1,TYCMD1(R)	;LOOP BACK IF MORE FIELDS TO CHECK
	MOVS	M,CM		;GET ADDR OF FIRST WORD OF INCOMPLETE FIELD
	TRNE	NC,-1		;ANYTHING IN CURRENT (INCOMPLETE) CMD FIELD?
	  PUSHJ	P,TYPSTR(R)	;YES, THEN TYPE IT OUT
	POP	P,M		;RESTORE THE ORIGINAL BYTE POINTER
	POPJ	P,		;AND RETURN TO CALLER

;Routine to type a string (string addr passed in M)

TYPSTR:	HRLI	M,(POINT 7)	;CONVERT STRING ADDR INTO A BYTE POINTER
TYSTR1:	ILDB	B,M		;GET A CHARACTER FROM THE STRING
	JUMPE	B,CPOPJ(R)	;QUIT ON AN ASCII NULL
	CAME	M,DLMPTR(R)	;IS THIS THE IMPLICIT DELIMITER CHARACTER?
	  PUSHJ	P,TYPCHR(R)	;NO, TYPE THIS CHARACTER
	JRST	TYSTR1(R)	;AND LOOP BACK FOR NEXT CHARACTER
;Routine to type a character in arrow mode (char passed in B)

TYPCHR:	PUSH	P,B		;SAVE THE ORIGINAL CHARACTER
	CAIN	B,033		;IF THIS CHAR IS AN ALTMODE
	  MOVEI	B,"$"		; THEN TYPE IT AS A DOLLAR SIGN
	CAIE	B,175		;CHECK OTHER 2 FLAVORS OF ALTMODE
	CAIN	B,176
	  MOVEI	B,"$"
	CAIN	B,177		;IF THIS CHAR IS A RUBOUT (I.E. DELETE)
	  SETO	B,		; THEN TYPE IT AS "^?" (SNEAKY EH?)
	CAIL	B," "		;IS THIS A PRINTABLE CHARACTER?
	  JRST	TYCHR1(R)	;YES, THEN JUST GO PRINT IT
	MOVEI	B,"^"		;NO, PRINT AN UP-ARROW TO INDICATE CONTROL CHAR
	PUSHJ	P,$TTYO(R)
	MOVE	B,(P)		;GET THE ORIGINAL CHARACTER BACK
	ADDI	B,"A"-1		;CONVERT IT TO CORRESPONDING PRINTABLE CHAR
TYCHR1:	PUSHJ	P,$TTYO(R)	;ECHO THIS CHARACTER
	POP	P,B		;RESTORE THE CHAR THAT WE WERE CALLED WITH
	POPJ	P,		;AND RETURN TO CALLER

;Routine to type a carriage return - line feed

TYCRLF:	MOVEI	C,[ASCIZ \
\](R)
	PJRST	$STRO(R)	;TYPE THE CRLF AND RETURN TO CALLER
SUBTTL	Error messages

BADCMD:	MOVEI	C,[ASCIZ \ ?\](R)
TYPERR:
IFN <4-FTVER>,<			;IF NOT ASSEMBLING USER LEVEL VERSION
	CONO	PI,1B23!1B27>	; CLEAR AND DEACTIVATE THE PI SYSTEM
	PUSHJ	P,$STRO(R)	;ISSUE THE CATCH-ALL ERROR MESSAGE
	JRST	BEGBTS(R)	;AND GO GET ANOTHER COMMAND

NOTSAV:	MOVEI	C,[ASCIZ \
?This file is neither a SAVE, SSAVE nor EXE file
\](R)
	JRST	TYPERR(R)	;TYPE THIS ERROR MESSAGE AND GET ANOTHER CMD

OVRLAY:	MOVEI	1,PAGE.0(R)	;FIRST WORD IN USE BY BOOTS WHEN LOADING A FILE
	MOVEI	C,[ASCIZ \
?This file is too big (it will overlay BOOTS at location %1O)
\](R)
	JRST	TYPERR(R)	;TYPE THIS ERROR MESSAGE AND GET ANOTHER CMD

BADCTL:	MOVE	1,FDBCTL(FA)	;GET THIS FILE`S CONTROL BITS,,NAME BLOCK ADDR
	MOVEI	C,[ASCIZ \
?This is an unusable file (FDBCTL = %1F)
\](R)
	JRST	TYPERR(R)	;TYPE THIS ERROR MESSAGE AND GET ANOTHER CMD

BADADR:	POP	P,1		;RESTORE THE (ILLEGAL) LINEAR DISK ADDRESS
	MOVEI	C,[ASCIZ \
?Invalid linear disk address encountered (addr = %1O)
\](R)
	JRST	TYPERR(R)	;TYPE THIS ERROR MESSAGE AND GET ANOTHER CMD

RNGBEL:	MOVEI	B,""		;RING BELL TO INDICATE THAT SOMETHING`S ASKEW
	PUSHJ	P,$TTYO(R)
	JRST	GTCMD1(R)	;AND RETURN TO COMMAND SCANNER FOR NEXT CHAR
INPERR:
IFN <4-FTVER>,<			;IF NOT ASSEMBLING USER LEVEL VERSION
	CONO	PI,1B23!1B27>	; CLEAR AND DEACTIVATE THE PI SYSTEM
	MOVEI	C,[ASCIZ \
?DSKOP error %1O (\](R)
	PUSHJ	P,$STRO(R)	;TELL OPERATOR THAT WE GOT PROBLEMS
	TRZE	A,4000		;TRANSLATE CODES 60400X TO 60000X+3
	  ADDI	A,3
	TRZ	A,600000	;CLEAR THE ERROR CODE INDICATOR
	ADDI	A,(R)		;MAKE ERROR CODE RELOCATABLE
	MOVEI	C,@[[ASCIZ \word count not 1000\](R)		;DSKX1
		    [ASCIZ \invalid disk address\](R)		;DSKX2
		    [ASCIZ \I/O error\](R)			;DSKX3
		    [ASCIZ \SA-10 error\](R)			;DSKX4
		    [ASCIZ \operation timed out\](R)]-1(A)	;DSKX5
	PUSHJ	P,$STRO(R)	;TYPE OUT THE CAUSE OF THE ERROR
	MOVEI	C,[ASCIZ \)
 Hit the CONTinue key to restart BOOTS
\](R)
	PUSHJ	P,$STRO(R)	;FINISH UP THE ERROR MESSAGE
	HALT	BEGBTS(R)	;CONTINUE WILL RESTART BOOTS
SUBTTL	Character flag and dispatch tables

	SALL			;DON`T LIST THE MACRO EXPANSIONS

DEFINE	CHARS<
X	,			;;^@ - NULLS ARE IGNORED ON INPUT
X	,RUBOUT			;;^A - RUBOUT LAST CHARACTER
X	CH.NFG,			;;^B - ILLEGAL CHARACTER
X	CH.TYP,BEGBTS		;;^C - CANCEL ENTIRE COMMAND LINE
X	CH.NFG,			;;^D - ILLEGAL CHARACTER
X	CH.NFG,			;;^E - ILLEGAL CHARACTER
X	,PRTREC			;;^F - RECOGNIZE THE CURRENT COMMAND FIELD
X	CH.NFG,			;;^G - ILLEGAL CHARACTER
X	CH.NFG,			;;^H - ILLEGAL CHARACTER
X	CH.NFG,			;;^I - ILLEGAL CHARACTER
X	,ENDCMD			;;^J - (LINE FEED) END OF COMMAND LINE
X	CH.NFG,			;;^K - ILLEGAL CHARACTER
X	CH.NFG,			;;^L - (FORM FEED) ILLEGAL CHARACTER
X	,ENDCMD			;;^M - (CARRIAGE RETURN) END OF COMMAND LINE
X	CH.NFG,			;;^N - ILLEGAL CHARACTER
X	CH.NFG,			;;^O - ILLEGAL CHARACTER
X	CH.NFG,			;;^P - ILLEGAL CHARACTER
X	CH.NFG,			;;^Q - ILLEGAL CHARACTER
X	,RETYPE			;;^R - RETYPE CURRENT COMMAND LINE
X	CH.NFG,			;;^S - ILLEGAL CHARACTER
X	CH.NFG,			;;^T - ILLEGAL CHARACTER
X	CH.NFG,			;;^U - ILLEGAL CHARACTER
X	,CHRLIT			;;^V - TAKE NEXT CHARACTER LITERALLY
X	,DELFLD			;;^W - DELETE CURRENT COMMAND FIELD
X	CH.TYP,BEGBTS		;;^X - CANCEL ENTIRE COMMAND LINE
X	CH.NFG,			;;^Y - ILLEGAL CHARACTER
X	CH.NFG,			;;^Z - ILLEGAL CHARACTER
X	,FULREC			;; $ - (ALTMODE) RECOGNIZE ENTIRE FILE SPEC
X	CH.NFG,			;;^\ - ILLEGAL CHARACTER
X	CH.NFG,			;;^] - ILLEGAL CHARACTER
X	CH.NFG,			;;^^ - ILLEGAL CHARACTER
X	CH.NFG,			;;^_ - ILLEGAL CHARACTER
X	CH.NFG,			;;   - (BLANK) ILLEGAL CHARACTER
X	,			;; ! - LEGAL CHARACTER
X	,			;; " - LEGAL CHARACTER
X	,			;; # - LEGAL CHARACTER
X	,			;; $ - LEGAL CHARACTER
X	,			;; % - LEGAL CHARACTER
X	,			;; & - LEGAL CHARACTER
X	,			;; ' - LEGAL CHARACTER
X	,			;; ( - LEGAL CHARACTER
X	,			;; ) - LEGAL CHARACTER
X	CH.NFG,			;; * - ILLEGAL CHARACTER
X	,			;; + - LEGAL CHARACTER
X	CH.TYP!CH.DLM,BEGSWT	;; , - START OF SWITCH SPECIFICATION
X	,			;; - - LEGAL CHARACTER
X	CH.TYP!CH.DLM,ENDFIL	;; . - END OF FILE NAME SPECIFICATION
X	,			;; / - LEGAL CHARACTER
	REPEAT	^D10,<
X	,			;; 0 to 9 - LEGAL CHARACTERS>
X	CH.TYP!CH.DLM,ENDDEV	;; : - END OF DEVICE SPECIFICATION
X	CH.TYP!CH.DLM,ENDEXT	;; ; - END OF EXTENSION SPECIFICATION
X	CH.TYP!CH.DLM,BEGDIR	;; (074) - START OF DIRECTORY SPECIFICATION
X	CH.NFG,			;; = - ILLEGAL CHARACTER
X	CH.TYP!CH.DLM,ENDDIR	;; (076) - END OF DIRECTORY SPECIFICATION
X	,MCHFLD			;; ? - TYPE ALL THAT MATCH CURRENT CMD FIELD
X	CH.NFG,			;; @ - ILLEGAL CHARACTER
	REPEAT	^D26,<
X	,			;; A to Z - LEGAL CHARACTERS>
X	,			;; [ - LEGAL CHARACTER
X	,			;; \ - LEGAL CHARACTER
X	,			;; ] - LEGAL CHARACTER
X	,			;; ^ - LEGAL CHARACTER
X	CH.NFG,			;; _ - ILLEGAL CHARACTER
X	CH.NFG,			;; ` - ILLEGAL CHARACTER
	REPEAT	^D26,<
X	CH.LCL,			;; a to z - LEGAL CHARACTERS>
X	CH.NFG,			;; { - ILLEGAL CHARACTER
X	CH.NFG,			;; | - ILLEGAL CHARACTER
X	,FULREC			;; $ - (ALTMODE) RECOGNIZE ENTIRE FILE SPEC
X	,FULREC			;; $ - (ALTMODE) RECOGNIZE ENTIRE FILE SPEC
X	,RUBOUT			;; (del) - RUBOUT LAST CHARACTER
	>

DEFINE	X(.FLG<0>,.ADR)<
	XLIST
	.XCREF
	.RH==.FLG
	IFNB <.ADR>,<.RH==.RH!<.INDX==.INDX+1>>
	IFE <.HALF&1>,<.LH==.RH>
	IFN <.HALF&1>,<.LH,,.RH>
	.HALF==.HALF+1
	.CREF
	LIST>

.INDX==	0			;INITIAL INDEX INTO SPECIAL CHAR DISPATCH TABLE
.HALF==	0			;FLIP-FLOP USED TO GENERATE HALF WORD STORAGE

CHRTAB:	CHARS			;BUILD THE CHARACTER FLAG TABLE

DEFINE	X(.FLG,.ADR)<
	XLIST
	IFNB <.ADR>,<Z .ADR'(R)>
	LIST>

CHRDSP:	CHARS			;BUILD THE SPECIAL CHARACTER DISPATCH TABLE

	XALL			;RESUME NORMAL LISTING MODE
SUBTTL	Storage

PDLSTK:	BLOCK	PDLSIZ		;THE PDL STACK ITSELF
MONCMD:	BLOCK	1		;ADDR OF MONITOR`S COMMAND IF NON-ZERO
SWTADR:	BLOCK	1		;ADDRESS OF ROUTINE TO EXECUTE THE SWITCH
STADDR:	BLOCK	1		;STARTING ADDR OF FILE (RH OF ENTRY VECTOR)
MCHADR:	BLOCK	1		;STRING BLOCK ADDR OF STRING CONTAINING OURS
FLDSPC:	BLOCK	1		;LENGTH,,ADDR OF THE FIELD TO BE RECOGNIZED
FLDBLK:	BLOCK	<CH%FLD+4>/5	;FIELD THAT WE`RE CURRENTLY RECOGNIZING
IFN <4-FTVER>,<			;ASSEMBLE FOLLOWING IF NOT USER LEVEL VERSION
BFRTIP:	BLOCK	1		;TYPE AHEAD BUFFER INPUT PUTTER
BFRTIT:	BLOCK	1		;TYPE AHEAD BUFFER INPUT TAKER
INPBFR:	BLOCK	BF%WDS>		;THE TYPE AHEAD INPUT BUFFER ITSELF

A.ZERO==.			;FIRST LOCATION TO ZERO ON START-UP
CMDBFR:	BLOCK	CH%WDS		;COMMAND ELEMENTS SPECIFIED BY OPERATOR
ELMTAB==.			;NUMBER OF CHARS,,ADDR OF FIRST WORD OF
ELMDEV:	BLOCK	1		; DEVICE
ELMDIR:	BLOCK	1		; DIRECTORY
ELMFIL:	BLOCK	1		; FILE NAME
ELMEXT:	BLOCK	1		; EXTENSION
ELMVER:	BLOCK	1		; VERSION NUMBER
ELMSWT:	BLOCK	1		; SWITCH
VERNUM:	BLOCK	1		;ENCODED VERSION NUMBER
DLMPTR:	BLOCK	1		;BYTE POINTER TO IMPLICIT DEIMITER (. OR ;)
DLMLVL:	BLOCK	1		;CMD LEVEL OF FIELD TERMINATED BY THIS DELIMITER
RECLVL:	BLOCK	1		;COMMAND LEVEL OF LAST FIELD RECOGNIZED
Z.ZERO==.-1			;LAST LOCATION TO ZERO ON START-UP

;Parameters changed by WRTBTS (if this version is loaded with WRTBTS)

LOTRK::	MINTRK			;LOWEST ALLOWABLE TRACK NUMBER IN FILE SYSTEM
HITRK::	MAXTRK			;FIRST TRACK NUMBER AFTER FILE SYSTEM AREA
CNVTRK::NTRK*NREC		;VALUE TO CONVERT LINEAR DISK ADDR TO TRACK NBR
FDFMTF::DIRFMT			;DIRECTORY FORMAT FLAG (NEW=0 AND OLD=-1)

;Default command element table (this table parallels the ELMTAB table)

DFLTAB==.			;NUMBER OF CHARS,,ADDR OF FIRST WORD OF
DFLDEV:	^D4,,[ASCIZ \DSK:\]	; DEFAULT DEVICE
DFLDIR:	^D5,,[ASCIZ \<MON>\]	; DEFAULT DIRECTORY
DFLFIL:	^D5,,[ASCIZ \AMON.\]	; DEFAULT FILE NAME
DFLEXT:	^D4,,[ASCIZ \SAV;\]	; DEFAULT EXTENSION
DFLVER:	^D2,,[ASCIZ \0\]	; DEFAULT VERSION NUMBER (NULL DELIMITER)
DFLSWT:	^D3,,[ASCIZ \,G\]	; DEFAULT SWITCH (NULL DELIMITER)
SUBTTL	Literals

	LIT
SUBTTL	Allocate the rest of BOOTS

;***** WARNING --- DON`T ADD ANYTHING AFTER THIS LINE *****

XTRWDS==NBTWDS-<.-BOOTS>	 ;NUMBER OF UNUSED WORDS IN BOOTS

IFL XTRWDS,<
	PRINTX	?BOOTS is too big (it will not fit in NBTPGS pages)
	PRINTX	Increase the value of NBTPGS -- compilation aborted
	PASS2
	END>

	BLOCK	XTRWDS		;MAKE BOOTS "NBTWDS" WORDS LONG


IFE <<2-FTVER>*<3-FTVER>>,<	;ASSEMBLE THIS FOR EITHER READIN VERSION
	END	BOOTS>

	END			;ASSEMBLE THIS FOR ALL OTHER VERSIONS
