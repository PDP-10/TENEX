
	TITLE 	SATIMR
	SUBTTL	SA10 - DISK PACK OPN TIMER

;          ****************************************************
;          ****                                            ****
;          ****           SUMEX Computer Project           ****
;          ****     Stanford University Medical Center     ****
;          **** Sponsored by National Institutes of Health ****
;          ****      Biotechnology Resources Program       ****
;          ****           T. Rindfleisch, 10/3/77          ****
;          ****                                            ****
;          ****************************************************



; This program is for timing seek and rotational times for a 3330 disk
; drive attached to an SA10 DEC memory port/IBM channel interface.  It
; times seeks from full pack spans to single cylinder seeks over the
; inner, middle, and outer ranges of the packs.  Rotational times are
; evaluated between successive READ HOME ADDRESS commands.  No pack
; write operations are required.  The times are based on the 60 cycle
; clock - 100 operations are performed to reduce the timing errors to
; below .2 milliseconds.
;
; At start-up, the program asks for the logical drive number to be timed.
	EXTERN	.JBSYM,.JBUSY,DDT

; Assembly for various processor types is controlled by defining one
; and only one of the symbols KA, KI, or KL.  These symbols must not be
; defined for other purposes!  THE KL OPTIONS ARE INCOMPLETELY SET UP
; AT THIS POINT.

KI=1		; Program will run on a KI-10

IFDEF KL,<
		; Additional symbols for KL10 stuff
DTEFLG=444	;DONE FLG
DTEF11=450	;ARG FROM 11
DTECMD=451	;COMMAND LOC
DTEMTD=455	;TYO DONE
DTEMTI=456	;TYI READY
DTE==200	;DEVICE CODE
.DTMTO==10B27	;TYO CMD
.DTMMC==11B27	;MON MODE ON
.DTMNM==12B27	;MON MODE OFF
TO11DB==1B22	;DOORBELL TO 11
CL11PT==1B26	;CLEAR DOORBELL FOR 10
PILDEN==1B31	;ENABLE LOAD PIA
DTE11=142	;INT ADR
DTEEPW=144	;EXAMINE PROT WORD
	>	; End IFDEF KL


; Basic hardware definitions for SA10 stuff

SA0==274	; I/O bus address of SA-10
BASE==160	; Base address for SA-10 channel control blocks
IFNDEF CV,<
CV==1>		; 0 for B, 1 for C (SA10 hardware pointer layouts)
DCHAN==0	; SA10 channel assigned to disk controller
IDEV==300	; Device address of disk controller (C0)
CTYTMO=^D10000	; CTY time out count
CTYFIL=4	; Number of CTY fill characters after LF
; AC definitions

Z=0		; Z-F are general purpose registers
A=1
B=2
C=3
D=4
E=5
F=6
G=7		; G holds the buffer group index
H=10		; H is used as a counter
DD=15		; Used by SA10 indirect I/O bus macros
P=17		; PDL pointer


; Parameters for copy process

PSTART==4000		; Program starting address
APRCH==1		; PI channel for APR clock and errors
SA0CH==2		; PI channel for SA10
SFTCH==SA0CH		; PI channel for software requests
NPACKS==4		; Number of drives on disk controller
NCYL==^D815		; Total number of cylinders per pack
NUCYL==^D808		; Number of cylinders available to users
NSCYL==^D808+1		; Number of system cylinders (808 plus
			; 1 cylinder worth of spare tracks)
NSURF==^D19		; Number of surfaces (tracks/heads) per cylinder
NRPT==^D5		; Number of records (pages) per track
RECL==1000		; Number of data words per record
TRKWDS==NRPT*RECL	; Number of words per track
CYLREC==NSURF*NRPT	; Number of records per cylinder
CYLWDS==NSURF*TRKWDS	; Number of words per cylinder
CHKCYL==NCYL-1		; Cylinder to use to check drive accessibility
NRETRY==^D5		; Number of times to retry errors
MXDIFP==^D5		; Number of compare errors to print
TIMOUT==^D20*^D60	; Delay for disk operation time out (20 sec)
NITER==^D100		; Number of iterations for timing
NROTIT==^D100		; Number of iterations for rotation timing
STCHAR=="S"-100		; Status request character (^S)
RSTCHR=="C"-100		; Restart request character (^C)
DDTCHR=="D"-100		; DDT request character (^D)
QOTCHR=="V"-100		; Output quote character (^V)
LITES=100		; Data for light watchers -
			;    LH = cylinders to go
			;    RH = cylinders done


; Some 3330 commands

OPDEF	TIC [1B1]	; Transfer in Channel

NOOP==3		; No Op
SENSIO==4	; Sense I/O
SEEK==7		; Seek
SEEKHD==33	; Seek Head
SCHIDE==61	; Search ID Equal
RDDATA==6	; Read Data
WRDATA==5	; Write Data
RDHA==32	; Read Home Address
MULTRK==200	; Multi-track option for Search and Read commands

; Some SENSE byte bit definitions

CMDREJ=1B0			; Command reject (sense byte 0)
INTVEN=1B1			; Intervention required (sense byte 0)
DATCHK=1B4			; Data check (sense byte 0)
WPROT=1B14			; Write protection (sense byte 1)
ENVRN= BYTE (8) 0,0,020,0	; Sense bytes 0-3 for environmental data
CRCTBL=BYTE (8) 010,0,100,0	; Sense bytes 0-3 for correctable error
UNCRTL=BYTE (8) 010,0,0,0	; Sense bytes 0-3 for uncorrectable error


; SA10 Device command word bits

NOXFER==400000	; No data transfer
EXECUT==100000	; Execute this command
CHAIN== 040000	; Chain to next command
BYTMOD==020000	; Transfer data in byte mode
INTRPT==010000	; Interrupt after completing this command
IGNLEN==004000	; Ignore incorrect length
BYTOFS==002000	; Skip over the first 2 data bytes

; SA10 Status word 1, byte 0 bits
STTYPE==600000	; Mask for status type field
ASYNST==400000	; Asynchronous status
ENDST== 200000	; Ending status
SELERR==100000	; Select error
BUSPAR==040000	; Bus in parity error
CTLERR==020000	; Control error
LENERR==004000	; Incorrect length error
PGMINT==002000	; Program interrupt flag

; SA10 Status word 1, byte 1 (DEVICE STATUS) bits
ATTN==  001000	; Device attention
STMOD== 000400	; Device status modifier
CUEND== 000200	; Device control unit end
BUSY==  000100	; Device busy
CHEND== 000040	; Device channel end
DEVEND==000020	; Device end
UNTCHK==000010	; Device unit check
UNTEXC==000004	; Device unit exception

SAERR==SELERR!BUSPAR!CTLERR!PGMINT!ATTN!UNTCHK!UNTEXC
BADERR==SELERR!BUSPAR!CTLERR!PGMINT!ATTN!UNTEXC
; Bit definitions for SA10 CONI, CONSZ, CONSO

PIRQ==400000	;THIS SA-10 IS REQUESTING AN INTERRUPT
PARERR==200000	;PARITY ERROR IN SOME WORD (COMMAND OR
		;DATA) READ FROM MEMORY
NXM==100000	;SA-10 TRIED TO REFERENCE NON-EX MEMORY


; Bit definitions for SA10 CONO commands

RSTSA==400000	;RESET WHOLE SCHMEER, START CLOCK
CLMERR==200000	;CLEAR MEMORY ERROR FLAGS
SASTEP==1000	;STOP CLOCK IF RUNNING; STEP IT IF STOPPED
SACGO==1040	;START CLOCK
RSTCH==300	;RESET CHANNEL SPECIFIED BY 10 AND 20 BITS
CLBSY==400	;CLEAR BUSY FLAG OF CHANNEL . . .
STBSY==440	;SET BUSY FLAG OF CHANNEL . . .
CLSRQ==500	;CLEAR STATUS REQUEST FLAG OF CHANNEL . . .
STSRQ==540	;SET STATUS REQUEST FLAG OF CHANNEL . . .
CLSTF==600	;CLEAR STATUS FLAG OF CHANNEL . . .
STSTF==640	;SET STATUS FLAG OF CHANNEL . . .
CLPIE==700	;CLEAR PI ENABLE OF CHANNEL . . .
STPIE==740	;SET PI ENABLE OF CHANNEL . . .


; Bit definitions for I/O buffer status words

IXFER==400000		; Input transfer started
IDONE==200000		; Input transfer complete
OXFER==100000		; Output transfer started
ODONE==040000		; Output transfer complete
VERFY==020000		; Verify results
CDONE==010000		; All cylinders copied for this buffer

ICRCT==000040		; Correctable input error encountered
IUNCR==000020		; Uncorrectable input error encountered
IHARD==000010		; Non-data-check input error encountered
OCRCT==000004		; Correctable output error encountered
OUNCR==000002		; Uncorrectable output error encountered
OHARD==000001		; Non-data-check output error encountered

IERRS==ICRCT!IUNCR!IHARD
OERRS==OCRCT!OUNCR!OHARD
BFERR==IUNCR!IHARD!OUNCR!OHARD
BFREST==IXFER!IDONE!OXFER!ODONE!VERFY!IERRS!OERRS   ; All bits except CDONE
; Following are MACRO definitions for some SA10 control word formats
; and for hardware control.


; MACROS for word pointers depending on which kind of SA10 (B OR C)
IFE CV,<
	DEFINE IOW(CT,ADR)	; Old SA10
	<-CT*4,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*4,,ADR>
	>

IFN CV,<
	DEFINE IOW(CT,ADR)	; New SA10
	<-CT*100,,ADR>
	DEFINE IOWC(CT,ADR)
	<400000-CT*100,,ADR>
	>

DEFINE	CW(BYTS)<
	BYTE (8) BYTS
	>


; Hardware control function MACROS
DEFINE	APRCLR<
   IFDEF KA,<
	CONO APR,675550		; Clear KA CPU
	PUSHJ P,RSTWT		; Wait a while
	>
   IFDEF KI,<
	CONO APR,725300		; Clear KI CPU
	PUSHJ P,RSTWT		; Wait a while
	CONO APR,20000		; Be sure KI Auto Restart is off
	>
   IFDEF KL,<
	CONO APR,267760		; Clear KL CPU
	PUSHJ P,RSTWT		; Wait a while
	>
	>	; End DEFINE

DEFINE	PICLR<
   IFDEF KA,<
	CONO PI,711577		; Clear KA PI's
	>
   IFDEF KI,<
	CONO PI,731577		; Clear KI PI's
	>
   IFDEF KL,<
	CONO PI,031577		; Clear KL PI's
	>
	>	; End DEFINE

; More hardware MACRO definitions

DEFINE	RSTCLK<
   IFDEF KA,<
	CONO APR,1000+APRCH		; Reset KA clock
	>
   IFDEF KI,<
	CONO APR,1000+<APRCH_3>+APRCH	; Reset KI clock
	>
   IFDEF KL,<
	***			; Not set up yet
	>
	>	; End DEFINE

DEFINE	PIRST<
   IFNDEF KL,<
	CONO PI,652400!<1_<7-SA0CH>>!<1_<7-APRCH>>   ; Reset KA/KI PI's
						     ; Leaves them deactivated
	>
   IFDEF KL,<
	CONO PI,012400!<1_<7-SA0CH>>!<1_<7-APRCH>>    ; Reset KL PI's
						     ; Leaves them deactivated
	>
	>	; End DEFINE

DEFINE	CLKENB<
   IFDEF KA,<
	CONO APR,2000+APRCH		; Enable KA clock
	>
   IFDEF KI,<
	CONO APR,2000+<APRCH_3>+APRCH	; Enable KI clock
	>
   IFDEF KL,<
	***			; Not set up yet
	>
	>	; End DEFINE

DEFINE	PION<
	CONO PI,200			; Turn on PI's
	>	; End DEFINE

DEFINE	PIOFF<
	CONO PI,400			; Turn off PI's
	>	; End DEFINE

DEFINE	SFTINT<
	CONO PI,4000+1_<7-SFTCH>	; Initiate sftwre interrupt
	>	; End DEFINE

DEFINE	DRPSFT<
   IFDEF KA,<
	JFCL				; KA doesn't have drop interrupt
	>	; End IFDEF KA
   IFNDEF KA,<
	CONO PI,20000+1_<7-SFTCH>	; Drop sftwre interrupt
	>	; End IFNDEF KA
	>	; End DEFINE
; SA10 control MACROS

DEFINE MCONO(DEV,DAT)<
	MOVEI DD,DAT
	XCT DCONO
>

DEFINE MCONSZ(DEV,DAT)<
	XCT DCONI
	TRNE DD,DAT
>

DEFINE MCONSO(DEV,DAT)<
	XCT DCONI
	TRNN DD,DAT
>

DEFINE MDATAO(DEV,DAT)<
	MOVE DD,DAT
	XCT DDATAO
>

DEFINE MDATAI(DEV,DAT)<
	XCT DDATAI
	MOVEM DD,DAT
>

DEFINE MCONI(DEV,DAT)<
	XCT DCONI
	MOVEM DD,DAT
>


; MACROS for input/output to TTY

DEFINE	CRLF<
	PUSHJ P,CR			; Do TTY carriage return/line feed
	>

DEFINE	TYPE(STR)<
	MOVEI C,[ASCIZ |STR|]		; Output a string to TTY
	PUSHJ P,STYO
	>


; MACRO for handling BUG's

DEFINE	BUG(STR,RETADR<DSKXX>)<
	JSR   [0
	       JSR BUGENT		; Bug handler
	       [ASCIZ |STR|]		; Error string
	       RETADR]			; Return address
	>
; Start of program code.  This is the onetime initialization stuff

RELOC PSTART-140

GOGO:	JRST DDT		; PSTART starts at DDT
DDTG:	JRST @ENTLOC		; Take off from the entry dispatch
DDTE:	MOVE A,.JBSYM		; Get symbol table pointer
	MOVEM A,36		; Save it
	AOBJN A,.		; Compute adr of end of symbols
	HRRZM A,ADRLO		; Save as bottom of free space
	MOVE A,.JBUSY		; Get undefined symbol pointer
	MOVEM A,32		; Save it
	MOVEI A,TMR		; After this start up at TMR
	MOVEM A,ENTLOC
	JRST DDT		; First time, use DDT
; Entry point to start timing process.  Calls the various routines to do
; the actual timing.

TMR:	MOVEI	P,PDL-1		; Set up a stack
	PUSHJ P,INIHDW		; Initialize hardware
	PUSHJ P,INICTL		; Initialize control variables
	SETZM INIFLG		; Clear initialization flag
	SETZM TIMET		; Start timing
	SETZM TIMEC
	PION			; Activate PI's
	TYPE <
SA-10 Disk Drive Timer
>
	PUSHJ P,INITMR		; Fetch mode and src/des drive numbers
	PUSHJ P,ICHPGM		; Set up channel program
	SETZM TIMET		; OK, init done, restart timing
	SETZM TIMEC
	JSR STTMR		; Do timing operation
	PUSHJ P,WRPMSG		; All done, print a wrap up message
	PUSHJ P,ERRSUM		; And an error summary
	JRST @ENTLOC		; Restart the program
; Routine to fetch TMR parameters from the operator and to verify drive
; status for the operation.

INITMR:	SETOM NOPRNT		; For drive checking, suppress error msgs
	MOVEI D,NPACKS-1	; Get source drive number
	MOVEI C,[ASCIZ "Time drive (0-%4D): "]
	PUSHJ P,GTDRV
	 JRST INITMR		; Invalid input, try again
	MOVEM A,SRCDRV		; Save source channel,,drive
INITM0:	PUSHJ P,CHKDRV		; Now see if it is there and in good shape
	 JRST   [HRRZ D,SRCDRV	; +1 - Drive off-line, inform them
		 PUSHJ P,CPOFL
		 JRST INITMR]	; And try for another drive
	 JRST INITM1		; +2 - Source write protected - proceed
	 JRST   [MOVEI C,[ASCIZ "!!! Drive %4D not read only"]  ; +3
		 HRRZ D,SRCDRV
		 PUSHJ P,CPWPT
		 MOVE A,SRCDRV	; In case we want to recheck it
		 JRST INITM0]	; OK, recheck him for safety
INITM1:	SETOM INIFLG		; Initialization done, set the flag
	SETZM NOPRNT		; Allow error printing again
	POPJ P,			; All done

; This is the initial entry point (STTMR) to start a timing process and
; an entry point (RSTTMR) to restart timing after a serious error.
; Tabulation format:
;   Seek Span        Seek times (msec)
;     (cyl)    @Cyl   0   @Cyl 400   @Cyl 800
;      xxx       xx.x       xx.x       xx.x

STTMR:	0			; Main entry point
	SETZM ERRTAB		; Clear drive error summary table
	MOVE A,[ERRTAB,,ERRTAB+1]
	BLT A,ERRTAB+NETYPE-1
	SETOM TIMSEK		; Init the seek timing sequence
	MOVEI A,1		; Compute timing accuracy (1 tick)
	PUSHJ P,TNORM
	TYPE <
Times are accurate to +/- %1D.%2D msec

Seek Span        Seek times (msec)
  (cyl) >
	MOVSI G,-NCCYL		; Print center cylinder locations
STTMR0:	MOVE D,CNTCYL(G)
	TYPE <   @Cyl>
	MOVEI A,4		; Fixed pt
	PUSHJ P,PRFMT
	AOBJN G,STTMR0
	CRLF
	JRST RSTTM0
RSTTMR:	MOVEI P,PDL-1		; Restart entry point
	PUSHJ P,INIPIS		; Reinitialize PI's
	PUSHJ P,DRSTSA		; Reset the SA10 channel
	PUSHJ P,INICTL		; And control variables
	PION			; Activate PI's
RSTTM0:	SETZM BFSTAT		; Reset to restart transfers
	SETZM BFTMO		; And time-out word
	JRST DOTMR		; Now go pick up copy process

; This is the main idle loop for the timing process.  All disk I/O is
; interrupt driven.  This loop waits until a given test is done, prints
; the necessary timing data, increments for the next test, and sets
; things up to start the next I/O on it.

DOTMR:	MOVEI A,SKPGM		; Set up for seek measurements
	MOVEM A,BFPGM
DOTMR0:	PUSHJ P,TTYIC		; Check for ^C or ^D
	 JFCL			; Nothing input
	AOS A,TIMSEK		; Get current seek span index
	CAIL A,NSPANS		; All done?
	 JRST DOTMR1		; Yes
	SETZM CYLTIM		; Clear the measurement table
	MOVE B,[CYLTIM,,CYLTIM+1]
	BLT B,CYLTIM+NCCYL-1
	MOVSI G,-NCCYL		; Measure all center cylinders
	PUSHJ P,MSRCYL
	AOBJN G,.-1		; And do the other centers
	PUSHJ P,PCYLM		; Print the measurements
	JRST DOTMR0		; Go do all the seek spans

DOTMR1:	MOVEI A,RTPGM		; Now do the rotation program
	MOVEM A,BFPGM
	SETZM BFSTAT		; Set up to run it
	SFTINT			; Start it
	MOVSI B,IDONE		; Terminating condition
	TDNN B,BFSTAT		; Done?
	 JRST   [PUSHJ P,TSTMO	; Check for opn overdue
		 JRST .-1]
	MOVE A,TIMEC		; Yes, record the time
	PUSHJ P,TNORM		; Normalize it
	TYPE <
Rotation time = %1D.%2D msec
>
	JRST @STTMR		; All done
	


; Routine to print out a line of SEEK timing data
; Entry:   TIMSEK = current SEEK span index
;	   CYLTIM = timing data

PCYLM:	MOVE D,TIMSEK		; First print the span
	MOVE D,SKSPAN(D)
	MOVEI A,6
	PUSHJ P,PRFMT
	MOVSI G,-NCCYL		; Then all of the data values
PCYLM0:	HLRZ D,CYLTIM(G)	; Get normalized time
	HRRZ E,CYLTIM(G)	; D _ integer, E _ fraction
	HRROI A,^D11		; Including fractional part
	PUSHJ P,PRFMT
	AOBJN G,PCYLM0
	CRLF
	POPJ P,


; Routine to print out a number in fixed or floating point format
; right justified in a given field width.  If the field is not wide
; enough, the extra characters are printed.
; Entry:  A = LH - 0 for fixed point
;		   -1 for floating point (1 fraction digit)
;	      RH - Field width
;	  D = Integer part of the number
;	  E = Fraction part of the number (1/10's place)

PRFMT:	PUSH P,D		; Save the number
	PUSH P,E		; And any fraction
	PUSH P,A		; And field specs
	HRRZS A			; Save only field count
	IDIVI D,^D10		; Count the digits
	SUBI A,1		; And subtract them from the total field
	JUMPG D,.-2
	SKIPG 0(P)		; Want fraction too?
	 SUBI A,2		; Yes, count ".n"
	MOVEI B," "		; Print the blanks
	SOJL A,PRFMT0
	PUSHJ P,TYO
	JRST .-2
PRFMT0:	POP P,A			; Recover format specs
	POP P,E			; Fraction part
	POP P,D			; Integer part
	JUMPL A,[TYPE <%4D.%5D>	; Print floating point value
		 POPJ P,]
	TYPE <%4D>		; Print integer
	POPJ P,


; Routine to measure SEEK timing data.
; Entry:  TIMSEK = index to current SEEK span
;	  G = Index to center cylinder for SEEK span

MSRCYL:	MOVE A,TIMSEK		; Get current seek span index
	MOVE B,CNTCYL(G)	; Get this center cylinder
	MOVE C,SKSPAN(A)	; And the span
	LSH C,-1		; Half the span
	SUBB B,C		; Lower limit
	CAIGE B,0		; In range?
	 SETZB B,C		; No, fix it
	ADD C,SKSPAN(A)		; Now the upper limit
	CAIG C,NCYL-1		; In range?
	 JRST MSRCL0		; Yes
	MOVEI B,NCYL-1		; No, fix it
	MOVEI C,NCYL-1
	SUB B,SKSPAN(A)
	JUMPGE B,MSRCL0		; If lower range screwed now
	 SETZ B,		; fix it to minimum
MSRCL0:	PUSHJ P,SETCYL		; Install them in the channel commands
	SETZM BFSTAT		; Ready to run it
	SFTINT			; Start it
	MOVSI B,IDONE		; Terminating condition
	TDNN B,BFSTAT		; Done?
	 JRST   [PUSHJ P,TSTMO	; Check for opn overdue
		 JRST .-1]
	MOVE A,TIMEC		; Yes, record the time (1/60 sec ticks)
	PUSHJ P,TNORM		; Normalize it
	HRLM A,CYLTIM(G)	; Save the integer part
	HRRM B,CYLTIM(G)	; And the fraction
	POPJ P,			; Return

; Routine to convert time for NITER opns to time/opn.
; Entry:   A = time ticks for NITER opns
; Call:    PUSHJ P,TNORM
; Return:  A = integer part of time
;	   B = fractional part (1/10 msec)

TNORM:	IMULI A,^D1000		; Convert to milliseconds
	ADDI A,^D60/2
	IDIVI A,^D60
	ADDI A,NITER/20		; Round and normalize to per opn
	IDIVI A,NITER
	PUSH P,C		; Save C
	IDIVI B,^D10		; Convert fraction to 1/10's
	POP P,C			; Restore C
	POPJ P,
; Routine to set up SA-10 command lists for timing seeks and rotations.
; The channel programs are defined by macros at assembly time.  This
; routine just installs the right drive numbers.
;
;    SKPGM -- seek between two cylinders
;    RTPGM -- read home address for a given track
;
; Entry:  SRCDRV = Disk channel,,Drive number

ICHPGM:	SETZM BFSTAT		; Initialize buffer status
	SETZM BFTMO		; Initialize buffer I/O time out
	HRRZ E,BFDAT		; Get adr of ptr block
	HRRZ C,SRCDRV		; Install drive number
	DPB C,SSEEK(E)		; In initial SEEK
	DPB C,SRDHA(E)		; And in initial RDHA
	MOVSI A,-NITER+1	; AOBJN ptr for all SEEK iter + NOOP
	DPB C,SEKOPN(E)		; Drive number in SEEK commands
	ADDI A,1		; Increment ch pgm index by 2
	AOBJN A,.-2		; Do all SEEK commands
	SETZM @SKEOL(E)		; And form end of list
	MOVSI A,-NITER+1	; AOBJN ptr for all RDHA iter + NOOP
	DPB C,RDHOPN(E)		; Drive number in RDHA commands
	ADDI A,1		; Increment ch pgm index by 2
	AOBJN A,.-2		; Do all RDHA commands
	SETZM @RTEOL(E)		; And form end of list
	POPJ P,
; Routine to install the cylinder numbers in the seek data table for
; timing SEEK's.
; Entry:  B = lower cylinder boundary
;	  C = upper cylinder boundary
; Call:   PUSHJ P,SETCYL

SETCYL:	HLRZ A,BFDAT		; Get address of SEEK data table
	LSHC B,4		; Position cylinders for 00CC
	MOVEM B,0(A)		; Store them
	MOVEM C,2(A)
	POPJ P,			; OK, return



; Routine to set up a time-out time for a drive operation in BFTMO
; Entry:   Buffer number in G
; Call:	   PUSHJ P,SETMO

SETMO:	PUSH P,A		; Save AC A
	MOVE A,TIMET		; Current time
	ADDI A,TIMOUT		; Plus time-out period
	MOVEM A,BFTMO		; Equals time-out trigger
	POP P,A
	POPJ P,


; Routine to test for a hung drive, i.e., a disk operation hasn't
; completed in the required time.
; Entry:   Buffer number in G
; Call:	   PUSHJ P,TSTMO

TSTMO:	MOVE A,TIMET		; Get time now (in case interrupt hits)
	SKIPE B,BFTMO		; Time-out limit posted?
	CAMG A,B		; and not exhausted?
	 POPJ P,		; OK, keep on going
	BUG <DOTMR: Disk operation overdue>

; Routine to check disk drive status - does a read and write on a
; maintenance cylinder record to test the status.
; A = subchannel,,drive number
; Call:  PUSHJ P,CHKDRV
; Sense data returned in SENSED
; Returns:  +1  - Drive off-line
;	    +2  - Drive write protected
;	    +3  - Drive OK for read and write

CHKDRV:	SETZ C,			; Install drive number in cmd lists
	HRRZM A,ACTDRV		; and save it for later
CHKDR0:	SKIPN B,CKPTR(C)	; Get a command ptr, is it 0?
	 JRST CHKDR1		; Yes, all done
	DPB A,B			; No, deposit the drive number
	AOJA C,CHKDR0		; Do them all

CHKDR1:	MOVE A,[CKPGR,,[CHKDR2,,CHKDR2+1]]  ; Try the read
	JSR CHKEXC		; Go execute the channel program
CHKDR2:	PUSHJ P,CHKDRE		; Error return from read attempt
	 JRST CHKDR1		; +1 - retry opn
	 POPJ P,		; +2 - read failed.  Return +1
         AOS 0(P)               ; +3 - read OK.  At least return +2
CHKDR3:	MOVE A,[CKPGW,,[CHKDR4,,CHKDR4+1]]  ; Try the write now
	JSR CHKEXC		; Go execute the channel program
CHKDR4:	PUSHJ P,CHKDRE		; Error return from write attempt
	 JRST CHKDR3		; +1 - retry opn
	 POPJ P,		; +2 - write failed.  Return +2
	 JRST CPOPJ1		; +3 - write OK.  Return +3


; Routine for error checking on drive access checkout
; Call:    PUSHJ P,CHKDRE
; Return:  +1 - operation retry requested
;	   +2 - operation failed
;	   +3 - operation OK

CHKDRE:	MOVE B,STBUF+1		; Get status information
	TLNE B,BADERR		; Sel err, Bus par, Ctl err, Pgm int, Attn,
				; or Unit exc?
CHKDE0:	 JRST   [PUSHJ P,CPHRD	; Yes, complain
		 BUG (<CHKDRV: Can't test drive access>,TMR)]
	MOVE A,SENSED		; No, look at first 4 sense bytes
	TLNE A,(BYTE(8) 064, 355)  ; Serious drive error?
	 JRST CHKDE0		; Yes, bomb out
	CAMN A,[ENVRN]		; Environmental data?
	 JRST   [LDB A,[POINT 8,SENSED+1,31]  ; Yes, get fmt/msg
		 CAIN A,6_4	; Is it statistics (60 hex)?
		  POPJ P,	; Yes, return +1 (retry)
		 JRST CPOPJ2]	; No, return +3 (ctlr recovered OK)
	TLNE A,(CMDREJ!INTVEN!WPROT)	; Cmd rej, Int req, or Write prot?
	 JRST CPOPJ1		; Yes, return +2 (failure)
	JRST CPOPJ2		; No, return +3 (success)


; Routine to execute a drive check channel program
; Entry:  A = EXCP control word
;		LH = adr of chan pgm
;		RH = adr of dispatch word  (error adr,,success adr)

CHKEXC:	0
	MOVEM A,EXCPGM		; Save the pointer
	SETOM DOEXCP		; Set flag to run the program
	MOVE A,TIMET		; Current time
	ADDI A,TIMOUT		; Plus time-out period = time-out trigger
	SFTINT			; Interrupt to run the pgm
	CAML A,TIMET		; Time-out elapsed?
	 JRST .-1		; No, loop
	BUG <CHKDRV: Time out running channel program>

; Routine to print a wrap up message after timing a drive
; Entry:   Assumes initialization done (SRCDRV)
; Call:    PUSHJ P,WRPMSG

WRPMSG:	PUSHJ P,BELL		; Ring his bell
	HRRZ	D,SRCDRV
	TYPE <
DONE timing drive %4D
	>
	TYPE <Elapsed time >
	PUSHJ P,PTIME
	CRLF			; And a clean line
	PUSHJ P,BELL		; Ring him again
	POPJ P,


; Routine to print out error summary statistics.  Error summary
; accumulated in ERRTAB.
; Entry:   Error data in ERRTAB
; Call:    PUSHJ P,ERRSUM

ERRSUM:	SETZ A,			; Count total errors seen
	MOVSI B,-NETYPE
	ADD A,ERRTAB(B)
	AOBJN B,.-1
	JUMPG A,ERRSM0		; If any found, go tabulate them
	TYPE <
No errors encountered!
>
	JRST ERRSM1		; Go finish the message

ERRSM0:	TYPE <
ERROR SUMMARY:
   Drive    Corctbl  Uncorctbl   Other
>
	HRRZ D,SRCDRV		; Set up for source drive statistics
	SETZ G,			; First part of ERRTAB
	PUSHJ P,ERRPRT		; Print the numbers
ERRSM1:	PUSHJ P,CR2		; Space down
	POPJ P,


; Routine to print a group of error numbers (NETYPE/2 table entries printed)
; Entry:   D = drive number
;	   RH(G) = starting index into ERRTAB for error group
; Call:    PUSHJ P,ERRPRT

ERRPRT:	TYPE <     %4D>		; Print drive number first
	HRLI G,-NETYPE/2	; Number of errors to print
ERRPR0:	MOVE D,ERRTAB(G)	; Get an error count
	TYPE <        >		; Do 8 spaces
	MOVEI B," "
	CAIGE D,^D10		; 1 or more digits?
	 PUSHJ P,TYO		; 1, add another space
	TYPE <%4D>		; Type the count
	AOBJN G,ERRPR0		; Do the rest
	CRLF			; Done with the line
	POPJ P,
; Routine to handle any UUO's that come - there should be none
; executed in normal operation
; Entered by JSR UUOTRP

UUOTRP:	0
	BUG (<UUOTRP: Invalid UUO>,TMR)



; Routine to handle APR interrupts, errors and clock
; Entered by JSR APRI

APRI:	0
	CONSO APR,1000		; CLOCK?
	 JRST APRI0		; No, check further
	AOS TIMET		; Yes, increment times
	AOS TIMEC
	RSTCLK			; Reset the clock
	JEN @APRI

APRI0:
IFDEF KA,<
	CONSO APR,230110	; KA - PDL, MEM PROT, NXM, OVERFLOWS?
	>
IFDEF KI,<
	CONSO APR,220300	; KI - PAR, POW FAIL, IN/OUT, NXM?
	>
IFDEF KL,<
	***			; Not set up yet
	>
	CONSZ PI,600000		; POWER FAIL or PARITY?
	 JRST APRBAD		; Some serious error
	JEN @APRI		; Who knows, just forget it.

APRBAD:	CONI APR,APCONI		; Here for serious APR error, save APR CONI
	CONI PI,PICONI		; And the PI CONI
	BUG (<APRI: Serious hardware error>,TMR)

; Disk Interrupt Handler - Channel SA0CH
; Entered by JSR DSKI

DSKI:	0
	MOVEM P,ACS+P		; Save the AC's
	MOVEI P,ACS
	BLT P,ACS+P-1
	MOVEI P,IPDL-1		; Set up interrupt stack
	MCONI SA0,D		; Get the SA10 CONI data in D (need it later)
	TRNE D,PIRQ
	 JRST DSAI		; Yes, go handle it
IFDEF KL,<
	***			; Not set up yet
	>
IFDEF KI,<
	CONSZ PI,1_<7-SA0CH>	; Not SA10, how about software?
	>	; KA can't check software interrupt source
	 JRST DSFI		; Yes, go scan for work to do
	JRST DSKIE		; No, unknown interrupt

; Following are entry points to exit from the interrupt level.
DSKEX2:	SKIPL G,ACTBFR		; Exit - if active buffer,
	 PUSHJ P,SETMO		; set time out limit
	MCONO SA0,@STBSYC	; Exit - set busy and clear status flag
DSKEX1:	MCONO SA0,@CLSTFC	; Exit - just clear status flag
DSKEX:	MOVSI P,ACS		; Exit - just clear the interrupt
	BLT P,P			; Restore the AC's
	SETZM SFTREQ		; Clear any software request flag
	JEN @DSKI		; Clear interrupt


; Following are routines for weird interrupt situations
DSKIE:	MOVEI C,[ASCIZ /!!! Unknown int. on chan %0O, SA CONI = %4O, PI CONI = %5O
/]
	MCONI SA0,D		; SA-10 CONI in D
	CONI PI,E		; And PI's in E
	JRST DSKER

DSKIE1:	MOVEI C,[ASCIZ /!!! Strange int. on chan %0O, SA stat 1 = %4O, stat 2 = %5O
/]
	MOVE D,@CBASE+1		; Get the status information
	MOVE E,@CBASE+2
	JRST DSKER

DSKER:	MOVEI Z,SA0CH
	PUSHJ P,STYO
DSKXX:	SKIPN INIFLG		; Initialization done?
	 JRST TMR		; No, start all over again
	JRST RSTTMR		; Go continue the copy process from here


; Here on SA10 hardware interrupt for disk channel
; On entry the CONI word is in D

DSAI:	SKIPGE GETSNS		; Were we collecting sense info?
	 JRST DSAI0		; Yes, then don't save the status stuff again
	MOVEM D,SACONI		; Save SA10 CONI data
	HRL A,CBASE		; Save the SA10 status data
	HRRI A,STBUF
	BLT A,STBUF+3
DSAI0:	TRNE D,PARERR+NXM	; Parity error or NXM?
	 JRST   [PUSHJ P,DSPE	; Yes, inform the world
		 BUG (<DSAI0: SA10 PAR/NXM error>)]	; And bomb
	TRNN D,1_<6-DCHAN>	; OK, status int for disk channel?
	 JRST DSKIE		; No, unknown interrupt
	LDB D,[POINT 4,@CBASE+1,23]  ; Set up D as interrupting drive
	CAILE D,NPACKS-1
	 JRST DSKIE1		; Oops, drive number out of range
	MOVE A,@CBASE+1		; Fetch the SA10 status for this opn
	TLC A,ASYNST		; Asynchronous status?
	TLNN A,STTYPE
	 JRST   [CAMN D,ACTDRV	; Yes, on drive with I/O active?
		 SKIPGE ACTBFR
		  JRST DSKEX1	; No, just ignore it
		 JRST .+1]	; Yes, better look at it
	TLNE A,PGMINT		; Programmed interrupt?
	 JRST   [SETZM TIMEC	; Yes, clear local timer
		 JRST DSKEX1]	; And continue
	TLNE A,SAERR		; Sel err, Bus par, Ctl err, Pgm int,
				; Attn, Unit chk, or Unit exc?
	 JRST DSAER		; Yes, bad news
	TLNE A,BUSY		; Device busy?
	 JRST   [TLNE A,STMOD	; Yes, status modifier too?
		  JRST DSKEX1	; Yes, dismiss and wait for CU end
		 TLNN A,CUEND	; No stat mod, do we have CU end?
		  JRST DSAER	; No, bad news
		 JRST DSKEX2]	; Yes, restart the channel
	TLNE A,CUEND		; Control unit end?
	 JRST DSKEX2		; Yes, restart the channel
	TLNN A,DEVEND		; Device end?
	 JRST   [TLNN A,CHEND	; No, better have channel end
		  JRST DSKIE1	; Oops, this is strange
		 JRST DSKEX1]	; OK, wait for dev end
	CAME D,ACTDRV		; Yes, from right drive?
	 JRST DSKIE1		; No, this is a weird one
	TLNE A,LENERR		; Better not have a length error at this point
	 JRST DSAER		; Oops...
	AOSG GETSNS		; Is this sense information?
	 JRST DSASNS		; Yes, go process it
	SETZM GETSNS
	SKIPN DOEXCP		; Are we executing a special chan pgm?
	 JRST DSAI1		; No
	PUSHJ P,EXCPRT		; Yes, set up to return
	HRRZ A,0(A)		; Get success return address
	MOVEM A,DSKI
	JRST DSKEX1		; Go dismiss the interrupt

DSAI1:	MOVE B,BFSTAT		; Get the buffer status
	TLNE B,IXFER		; Was input transfer going?
	 JRST DNXFER		; Yes, now we are done
	BUG <DSAI: Device end but no I/O in progress>
; Enter here is we had a software disk interrupt request.  This occurs
; when:
;     -	Buffers are idle and nothing is going on on the disk.
;     -	Request to run a special channel program

DSFI:	DRPSFT			; Clear the software interrupt request
	SETOM SFTREQ		; Note that this was a software request
	SKIPL ACTBFR		; Is some buffer doing I/O now?
	 JRST DSKEX		; Yes, just exit
	SKIPN DOEXCP		; Run special program?
	 JRST DSCN		; No
	HLRZ A,EXCPGM		; Get adr of chan pgm
	HRLI A,(<TIC 0>)	; Make it a TIC
	MOVEM A,@CBASE
	JRST DSKEX2		; Go run it

DSCN:	SKIPN A,BFSTAT		; This buffer free?
	 JRST STIXFR		; Yes, start the operation
	SKIPE SFTREQ		; No, if software req, bad news
	BUG <DSCN: Invalid software disk PI request>
	JRST DSKEX1		; OK, check after I/O done - dismiss it


; Start input transfer
STIXFR:	SETZM ACTBFR		; Show operation active
	HRRZ Z,SRCDRV		; Record currently active drive
	HRRZ A,BFPGM		; Get starting channel pgm
	MOVE B,[IXFER,,DIERR]	; Strting bfr stat - input xfer ,, error routine
	MOVEM Z,ACTDRV
	HRLI A,(<TIC 0>)	; Form transfer command
	MOVEM A,@CBASE		; Set up SA10
	MOVEM B,BFSTAT		; Save the new status
	JRST DSKEX2		; No go start the channel running


; Finished with the transfer
; Entry:  B = buffer status word (RH = error handler address)
DNXFER:	TLO B,CDONE		; Update bfr status - xfer DONE
	IORM B,BFSTAT
	TLNN B,IDONE		; If input done previously, don't check again
	 JSR 0(B)		; Go clean up any input errors that happened
	HLLZS B			; Clear out right half of status
	MOVEM B,BFSTAT
	SETZM BFTMO		; Clear the time-out trigger
	SETOM ACTBFR		; All over now, set up for next one
	JRST DSKEX1		; Quit
; Here for SA10/disk errors:
;     -	Busy but no Status modifier or CU end
;     -	Invalid device number
;     -	Bad bits in CONI or status word (channel errors)
;	  Sel err, Bus par, Ctl err, Inc len, Pgm int, Attn, Unit chk,
;	  or Unit exception

DSAER:	SKIPGE GETSNS		; Did we have an error collecting sense info?
	 JRST DSASNS		; Oops!
	SETOM SENSED		; No, some other error.  Clear SENSED
	MOVE A,[SENSED,,SENSED+1]
	BLT A,SENSED+5
	MOVE A,STBUF+1		; Get 1st status word
	TLNE A,UNTCHK		; Unit check?
	 JSR DSENSE		; Yes, get drive sense information first
				; (We come back here after the sense interrupt)
DSASNS:	SKIPN DOEXCP		; Were we executing a special one?
	 JRST DSASN0		; No
	SKIPGE GETSNS		; Was this following a SENSE IO error?
	 PUSHJ P,SNSERR		; Yes, inform them
	PUSHJ P,EXCPRT		; If we come back, set up return
	HLRZ A,0(A)		; Pick the error return
	MOVEM A,DSKI
	JRST DSKEX1		; Go dismiss the interrupt

DSASN0:	MOVE B,BFSTAT		; Buffer status
	 JSR 0(B)		; Dispatch to error routine
	SKIPGE GETSNS		; Was this following a SENSE IO error?
	 PUSHJ P,SNSERR		; Yes, inform them
	HRLI A,(<TIC 0>)	; If we come back, run the chan pgm in A
	MOVEM A,@CBASE
	JRST DSKEX2		; Start executing it


; Routine to print information about SA10 NXM or Parity Error

DSPE:	TYPE <
!!! SA-10 ERROR at >
	PUSHJ P,PTIME		; Time stamp it
	MCONI SA0,D		; CONI data into D
	TYPE <     CONI = %4O
>
	CRLF
	MCONO SA0,10		; Fetch memory address
	MDATAI SA0,D
	MCONO SA0,20		; And channel number
	MDATAI SA0,A
	HLRZM A,E
	MCONO SA0,30		; Word contents SA10 has
	MDATAI SA0,F
	HRLM A,F
	MOVE G,(D)		; And value in memory
	MCONSO SA0,NXM		; Was it a NXM?
	 JRST DSPE0
	TYPE <NXM on chnl %5O, addr = %4O, mem has %7O chnl got %6O
>
DSPE0:	MCONSO SA0,PARERR	; or PARITY ERR?
	 JRST DSPE1
	TYPE <PAR ERR on chnl %5O, addr = %4O mem has %7O chnl got %6O
>
DSPE1:	PUSHJ P,CRSTSA		; Reset the whole thing
	POPJ P,

; Routine to handle source drive I/O errors
; Entry:  B = current buffer status word
; Call:  JSR DIERR

DIERR:	0
	TLNE B,CDONE		; Did we enter to clean up (xfer DONE)?
	 JRST DICLN		; Yes
	MOVEI C,[ASCIZ \
!!! INPUT I/O ERROR at \]	; Header for printing status information
	PUSHJ P,DICKER		; Check error type and correct if possible
	 JRST   [MOVSI B,IHARD	; +1  Hard error
		 AOS IEHARD	; Log it in the summary
	 	 JRST DIERR0]
	 JRST   [MOVSI B,IUNCR	; +2  Uncorrectable data check
		 AOS IEUNCR	; Log it in the summary
		 JRST DIERR0]
	MOVSI B,ICRCT		; +3  Correctable data check
	AOS IECRCT		; Log it in the summary
DIERR0:	PUSHJ P,STNOOP		; None, do NOOP to do clean up
	IORM B,BFSTAT
	JRST @DIERR		; OK, reenter chan pgm in A, go run it


; Here to clean up after an error.  We enter here after an input I/O operatin
; is supposedly done.  If any error happened, attempt a retry within
; the NRETRY limit.
DICLN:	TLNN B,ICRCT!IUNCR!IHARD   ; Did we have any error?
	 JRST DICLN1		; No, wrap it up
	SOSGE ERETRY		; Yes, any retries left?
	 JRST DICLN0		; No
	JRST STIXFR


; Here with no more retries but persistent hard error
DICLN0:	MOVEI D,NRETRY		; Count of retries
	MOVEI C,[ASCIZ "
!!! Unrecoverable error after %4D retries
"]
	PUSHJ P,STYO
	JRST DICLN2		; And make believe finish normal


; Here things recoveredorrectable error
DICLN1:	MOVN D,ERETRY		; See if any retries happened
	ADDI D,NRETRY
	JUMPE D,DICLN2		; If none, quit
	TYPE <
!!! Error recovered after %4D retries
>
DICLN2:	MOVE B,BFSTAT		; Recover current status
	TLO B,IDONE		; Show input I/O completed
	SETZM NOPRNT		; Allow printing of at least first error
	MOVEI A,NRETRY		; Reinit retry counter
	MOVEM A,ERETRY
	JRST @DIERR		; And return
; Routine to check type of disk I/O error
; Entry: SENSED contains drive sense data
;	 B = current buffer status
;	 C = address of status message header
;	 G = buffer index
; Call:  PUSHJ P,DICKER
; Return:  +1  if hard error
;	   +2  if uncorrectable error
;	   +3  if correctable error

DICKER:	PUSHJ P,STMSG		; Print status information
	MOVE C,SENSED		; Get first 4 sense bytes
	CAMN C,[-1]		; Status stored?
DICKR0:	 BUG (<DICKER: Disk error>, CPOPJ)
	TRNN C,ENVRN		; Environmental data?
	TLNN C,(DATCHK)		; Or not data check error?
	 JRST DICKR0		; We have problems
	CAMN C,[CRCTBL]		; Correctable error?
	 AOS 0(P)		; Yes, return +3
	AOS 0(P)
	JRST DICKR0		; This probably screwed the timing


; Routine to print out status information
; Entry:  STBUF  contains SA10 status data
;	  SENSED contains drive sense information (or -1 if none)
;	  C = address of header text
; Call:  PUSHJ P,STMSG	puts blank line and time stamp on output data
;	 PUSHJ P,PRSTAT just prints status information

STMSG:	MOVE A,STBUF+1			; Get the SA10 status word
	TLNE A,SELERR!BUSPAR!CTLERR!PGMINT!ATTN!UNTEXC  ; Bad error?
	 JRST STMSG0			; Yes, then print it
	MOVE A,SENSED			; Get the first sense bytes
	CAMN A,[CRCTBL]			; Simple correctable error?
	 SKIPN NOPRNT			; Yes, should we print it?
	  JRST STMSG0			; Yes
	POPJ P,				; No, just return
STMSG0:	PUSHJ P,STYO			; Print his header
	PUSHJ P,PTIME			; Time stamp the error
	CRLF
PRSTAT:	LDB A,[POINT 2,STBUF+1,1]	; GET 0=END,1=INIT,2=ASYNC,3=DUMMY
	MOVE C,STTT(A)			; String for status stored
	PUSHJ P,STYO
	LDB D,[POINT 8,STBUF+1,23]	; Device number
	TYPE < Status for device %4O:
   >
	HLLZ E,STBUF+1			; Get 14 status bits from 1st word
	TLZ E,3
	LSH E,2				; Left justified
	MOVEI D,STAMSG			; Bit dictionary
	PUSHJ P,PBITS			; Interpret bits
	CRLF				; New line
	PUSHJ P,DPHADR			; Print physical drive number
	LDB D,[POINT 4,STBUF+1,23]	; Get logical drive number
	MOVE A,SENSED			; Any sense data available?
	CAMN A,[-1]
	 JRST   [MOVE D,ACTDRV		; Get our version of drive/cyl
		 TYPE <, logical drive %4D, cylinder ?, head ?, record ?
SENSE DATA:
    - Not Available -
>
		 POPJ P,]		; And bomb out
	PUSH P,G			; Save G for now
	LDB C,[POINT 4,SENSED+1,27]	; Get the error format code
	CAIE C,4			; If format 4 or 5
	CAIN C,5
	 JRST   [PUSHJ P,GETCHR		; Get CC, HH, R
		 JRST .+3]
	PUSHJ P,GETCH			; Some other format, get CC, HH
	SETZ G,				; Fake record 0
	TYPE <, logical drive %4D, cylinder %5D, head %6D, record %7D
SENSE DATA:
>
	POP P,G				; Recover G
	PUSHJ P,PSB			; Print out hex format of bits
	MOVEI D,SNSMSG			; Now interpret the bits in English
	MOVE E,SENSED			; Get first 20 bits of sense data
	TRZ E,177777			; Left justified
	TYPE <   >			; Space over
	PUSHJ P,PBITS
	MOVE E,SENSED			; Get sense bytes 0-3 again
	CAME E,[ENVRN]			; Environmental data?
	 JRST PRSTA0			; No, wrap it up
	LDB E,[POINT 8,SENSED+1,31]	; Yes, get fmt/msg
	MOVEI C,[ASCIZ |(STATISTICS)|]	; Select message
	CAIE E,6_4
	 MOVEI C,[ASCIZ |(CTLR RECOV ERROR)|]
	PUSHJ P,STYO
PRSTA0:	CRLF
	POPJ P,

; Routine to interpret and print SA10 and disk status information
; Entry:  E = left-justified bit pattern to be converted to English
;	  D = address of string table for bit field
; Call:   PUSHJ P,PBITS

PBITS:	JUMPE E,CPOPJ		; If no bits left, exit
	TLNN E,(1B0)		; Left-most bit on?
	 JRST PBIT1		; No, try the next one
	TLON D,400000		; Yes, do we need punctuation?
	JRST PBIT2		; No
	TYPE < + >		; Yes, add +
PBIT2:	MOVE C,0(D)		; Type the appropriate string for this bit
	PUSHJ P,STYO
PBIT1:	LSH E,1			; Shift bits over
	AOJA D,PBITS		; And test next bit



; Routine to print the physical address of a disk drive
; Entry:  SENSED contains the sense data for a drive
; Call:   PUSHJ P,DPHADR

DPHADR:	TYPE <Physical drive >
	MOVSI C,-10
	LDB A,[POINT 6,SENSED+1,7]	; Get the drive number
	CAMN A,PHADRT(C)		; Look through funny names
	JRST DPHAD2			; Found it
	AOBJN C,.-2
	MOVEI B,"?"			; Not on the list
	JRST DPHAD3
DPHAD2:	MOVEI B,"A"(C)
DPHAD3:	PUSHJ P,TYO
	POPJ P,0



; Routine to output time of day (PTIME) or to output a user-supplied
; time (PTIMEC)

PTIMEC:	SKIPA D,TIMEC			; Get user time (1/60 sec per tick)
PTIME:	MOVE D,TIMET			; Get current time (1/60 sec per tick)
	ADDI D,3			; Round to compute 1/10's of sec
	IDIVI D,^D60			; D _ SEC, E _ 1/60's
	IDIVI E,^D6			; D _ sec, E _ 1/10's
	MOVE F,E			; F _ 1/10's sec
	IDIVI D,^D60			; D _ min, E _ sec
	TYPE <%4D:%5D.%6D min.>
	POPJ P,


; Routine to list SENSE I/O data in hexadecimal
; Entry:  SENSED contains the sense information
; Call:   PUSHJ P,PSB

PSB:	MOVE	F,SENSED		; Get first sense word
	AOJE	F,[TYPE < - Sense Bytes Missing -
>
	 	   POPJ P,]
	MOVE F,[POINT 4,SENSED]		; 4-bit byte ptr into data
	MOVEI D,6			; 6 words of data
PS0:	MOVEI E,^D8			; 8 hex chars/word
	TRNE D,1			; Starting line?
	 JRST PS1			; No
	TYPE <   >			; Yes, space over
PS1:	ILDB B,F			; Get a half-byte
	CAILE B,^D9			; Form hex char
	ADDI B,"A"-"0"-^D10
	ADDI B,"0"
	PUSHJ P,TYO			; Print the char
	MOVEI B,40
	TLNE F,40000
	PUSHJ P,TYO			; Add blank between bytes
	SOJG E,PS1
	PUSHJ P,TYO			; Extra blank between words
	IBP F
	TRNE D,1			; Only do 2 words worth per line
	PUSHJ P,CR
	SOJG D,PS0
	POPJ P,

; Routine to issue a SENSE I/O command for the currently active disk drive
; Call:   JSR DSENSE

DSENSE:	0
	MOVE D,ACTDRV			; Get currently active drive
	DPB D,[POINT 4,PSENSE,23]	; Install the drive number in chan pgm
	MOVE A,[TIC PSENSE]		; Transfer to channel program
	MOVEM A,@CBASE
	SETOM GETSNS			; Flag that we expect sense data
	JRST DSKEX2			; Go run the program


; Routine to set up for a NOOP

STNOOP:	MOVE A,ACTDRV		; Put active drive in the device command
	DPB A,[POINT 4,PNOOP,23]
	MOVEI A,PNOOP		; Channel program address
	POPJ P,


; Routine to complain about SENSE IO error

SNSERR:	PUSH P,A		; Save A - may be a channel pgm adr
	SKIPE INIFLG		; System initialized yet?
	 JRST SNSER0		; Yes
	MOVEI C,[ASCIZ \
!!! DRIVE I/O ERROR AND SENSE I/O ERROR at \]  ; No, print out as much data as poss.
	PUSHJ P,STMSG		; Print out the drive data
SNSER0:	TYPE <!!! SENSE I/O ERROR STATUS:
>
	HRLZ A,CBASE		; Transfer the status info to the usual place
	HRRI A,STBUF
	BLT A,STBUF+3
	PUSHJ P,PRSTAT		; Print what we know
	POP P,A			; Recover A
	SETZM GETSNS		; Clear the flag
	BUG <SNSERR: SENSE IO ERROR>


; Routine to set up an EXCP return
; Call:   PUSHJ P,EXCPRT
; Return:  A = address of EXCP return dispatch word

EXCPRT:	SETZM DOEXCP		; Clear the flag
	MOVE A,DSKI		; Get current interrupt PC
	MOVEM A,INTPC		; Save it for him
	HRRZ A,EXCPGM		; Get adr of dispatch word in A
	POPJ P,
; Routine to reset the CPU after fatal errors
; Call:  PUSHJ P,RSTALL

RSTALL:	PUSHJ P,TTYODN		; Wait until CTY output is done
	APRCLR			; Clear the CPU
	PICLR			; Clear the PI's
	PUSHJ P,CRSTSA		; Reset the whole SA10
	POPJ P,			; Return


; Routine to reset the SA10
; Entry:  @CRSTSA  to reset the whole thing
;	  @DRSTSA  to reset the disk channel only

CRSTSA:	MCONO SA0,RSTSA		; Reset the whole thing
	JRST RSTWT		; Wait to be sure

DRSTSA:	MCONO SA0,@RSTCHC	; Reset the channel
RSTWT:	MOVSI A,1		; Wait for things to settle
	SOJG A,.
	POPJ P,


; BUG entry point.  Called with BUG macro which sets up a transfer table:
;	Loc 0	Address of bug
;	    1   JSR BUGENT
;	    2   Address of string   (BUGENT points here)
;	    3   Return address

BUGENT:	0
	AOSE BUGLCK		; Only allow one at a time
	 JRST .-1
	PIOFF			; Turn off PI's
	MOVEM P,CACS+P		; Save AC's
	MOVEI P,CACS
	BLT P,CACS+16
	MOVE C,BUGENT		; Get bug block address
	SUBI C,2		; Point to start of block
	MOVEM C,BUGBLK		; Save it
	MOVE B,0(C)		; Get bug location
	MOVEM B,BUGCHK		; Save it
	MOVE B,3(C)		; Get the return address
	MOVEM B,BUGRET		; Save it
	MOVEI P,BPDL-1		; Temp BUG PDL
	CRLF
	PUSHJ P,PTIME		; Time stamp it
	TYPE <    >
	MOVE C,BUGBLK		; Address of bug message
	MOVE C,2(C)
	PUSHJ P,STYO		; Type it
	CRLF
	PUSHJ P,TTYODN		; Wait until output done
	MOVSI P,CACS		; Recover AC's we used
	BLT P,P
BUGADR:	PION			; Turn PI's back on
	SETOM BUGLCK		; Clear the bug lock
	JRST @BUGRET

; Routine to get a drive number from TTY
; Prompt message in C
; Call:  PUSHJ P,GTDRV
; Returns +1 if error
;	  +2 if success  (A contains disk channel,,drive number)

GTDRV:	PUSHJ P,CPNUM		; Get an input number
	 POPJ P,		; Error, just return +1
	CAIL A,0		; Drive number in range?
	CAIL A,NPACKS
	 JRST   [TYPE <
?? Drive number out of range
>				; No
		 POPJ P,]
	HRLI A,DCHAN		; Tack in disk channel
	JRST CPOPJ1		; And return +2




; Routine for hard error in selecting disk controller
; SA-10 status is printed after message in octal
; Call:  PUSHJ P,CPHRD

CPHRD:	MOVEI C,[ASCIZ "
!!! ERROR CHECKING DRIVE ACCESS at "]
	PUSHJ P,STMSG			; Print a message
	POPJ P,


; Routine to announce disk drive off line
; Call:  PUSHJ P,CPOFL

CPOFL:	TYPE <!!! Drive %4D off-line
>
	POPJ P,


; Routine to wait for user response (any character typed in)
; Input:  C - Pointer to prompt string
; Call:  PUSHJ P,CPWPT

CPWPT:	PUSHJ P,STYO		; Print his header
	MOVEI C,[ASCIZ " - <CR> to proceed"]
	PUSHJ P,NUMGM		; Print it and get his response
	 JFCL			; Accept any input
	CAIE B,15		; Did he CRLF?
	 PUSHJ P,CR		; No, do it for him
	POPJ P,


; Routine to get a decimal number from TTY
; Prompt message in C
; Call:  PUSHJ P,CPNUM
; Returns +1 if error (non-number entered)
;	  +2 if success

CPNUM:	SETZ A,			; Set up for decimal input
	PUSHJ P,NUMGM		; Print his preamble and get number
	 POPJ P,		; Must enter a number
	CAIN B,177		; Delete input?
	 JRST   [TYPE < XXX >	; Yes
		 SETZ C,	; No more prompt
		 JRST CPNUM]	; Try again
	CAILE B,40		; End with ctl char or CRLF?
	 POPJ P,		; No, return +1
	PUSHJ P,CONDCR		; Be sure we have a new line
	JRST CPOPJ1		; Return +2

TYIM:	PUSHJ P,STYO
TYI:	PUSHJ P,TTYIW		; Get an input TTY char
	CAIE B,15		; CR typed?
	JRST TYO		; No, just echo it
	PUSH P,C		; Yes, make it CRLF
	PUSHJ P,CR
	POP P,C			; And restore the CR
	MOVEI B,15
	POPJ P,			; Return


; Routine to print a prompt string and fetch a number from the console TTY.
; Breaks on non-numeric input.
; Entry:  A = 0  Collect a decimal input
;	     -1  Collect an octal input
;	  C =    Address of string prompt
; Entry:  NUMGM  Print prompt and collect an input
;	  NUMG   Just collect the input
; Return:  +1  No number entered
;	   +2  Number returned in A
; Last character typed is saved in LSTCHR

NUMGM:	MOVEM A,NUMTYP		; Save the type conversion code
	PUSHJ P,STYO		; Print the prompt
	SKIPA
NUMG:	MOVEM A,NUMTYP		; Non-prompt entry, save the conv code
	SETZB A,NONUM		; Clear number accumulator, and collection flag
NUMG0:	PUSHJ P,TYI		; Get a character
	SKIPE NUMTYP		; Decimal?
	 JRST NUMG1		; No, octal
	CAIG B,"9"		; Decimal, digit out of range?
	CAIGE B,"0"
	 JRST NUMG2		; Yes, quit
	SETOM NONUM		; OK, set collection flag
	IMULI A,^D10		; Do decimal conversion
	ADDI A,-"0"(B)
	JRST NUMG0		; Get next digit

NUMG1:	CAIG B,"7"		; Octal, digit out of range?
	CAIGE B,"0"
	 JRST NUMG2		; Yes, quit
	SETOM NONUM		; OK, set collection flag
	LSH A,3			; Do octal conversion
	ADDI A,-"0"(B)
	JRST NUMG0

NUMG2:	MOVEM B,LSTCHR		; Save last character typed
	SKIPE NONUM		; Break char, any number entered?
	 AOS 0(P)		; Yes, return +2
	POPJ P,			; No, return +1

; Routine to fetch cyl, head, and rec number into E, F, G
; Sense data in SENSED (assumed to be format 5)
; Call:  PUSHJ P,GETCHR

GETCHR:	LDB E,[POINT 16,SENSED+2,15]  ; Fetch cylinder address
	LDB F,[POINT 16,SENSED+2,31]  ; And head address
	LDB G,[POINT 8,SENSED+3,7]    ; And record number
	POPJ P,


; Routine to fetch cyl, head, and rec addresses in E, F, and G
; Sense data in SENSED (any format)
; Call:  PUSHJ P,GETCH

GETCH:	LDB E,[POINT 2,SENSED+1,18]  ; Get high order 2 bits of cyl
	LSH E,^D8		; Position them
	LDB F,[POINT 8,SENSED+1,15]  ; Get the low order cyl bits
	ADD E,F			; Combine them
	LDB F,[POINT 5,SENSED+1,23]  ; Finally get the head address
	PUSH P,A		; Save A for now
	MOVE A,SENSED		; Get first 4 sense bytes
	SETZ G,			; Assume record 0
	TLNE A,(1B8!1B17)	; Unless perm or corr error
	 LDB G,[POINT 8,SENSED+3,7]  ; Get valid record number
	POP P,A
	POPJ P,

; Routine to output BELL to TTY
; Call:  PUSHJ P,BELL

BELL:	MOVEI B,7		; Set to print bell
	PUSHJ P,TYO
	MOVEI B,-1		; Now wait for it to hit
	SOJG B,.
	POPJ P,


; Routine to terminate an input from TTY.  A valid ending is any
; control character or blank.  A delete means kill the input to here.
; Anything else is illegal.
; Call:   PUSHJ P,ENDIT
; Return: +1  - non-terminating character typed
;	  +2  - delete (177) typed
;	  +3  - valid terminator

ENDIT:	PUSHJ P,TYI		; Get another TTY char
	MOVEM B,LSTCHR		; Save it
	CAIG B,40		; Valid terminator?
	 JRST   [PUSHJ P,CONDCR	; Yes, be sure we have a new line
		 AOS 0(P)	; Step return by 1
		 JRST ENDIT0]	; And again to return +3
	CAIE B,177		; Was it a delete?
	 POPJ P,		; No, return +1
	TYPE < XXX >		; Delete, do indicator
ENDIT0:	MOVE B,LSTCHR		; Reinstall last char
	SETZ C,			; Clear message AC
	JRST CPOPJ1		; And return +2 or +3


; Conditional carriage return
CONDCR:	PUSH P,A
	MOVE A,LSTCHR		; Get last char typed
	CAIE A,15		; If it was not cr
	 PUSHJ P,CR		; Do one
	POP P,A
	POPJ P,


; Routines to put out 1, 2, 3, and 4 carriage return/line feed's

CR4:	PUSHJ P,CR		; Entry to print 4 CRLF's
CR3:	PUSHJ P,CR		; Entry to print 3 CRLF's
CR2:	PUSHJ P,CR		; Entry to print 2 CRLF's
CR:	TYPE <
>				; Entry to print 1 CRLF
	POPJ P,


; Skip returns

CPOPJ2:	AOS (P)		;SKIP2 RETURN
CPOPJ1:	AOS (P)		;SKIP RETURN
CPOPJ:	POPJ P,
; Routine to print a string on TTY.  Numeric conversion formats are
; provided for Octal, Decimal, and Hexadecimal data.  Each numeric
; conversion is specified by a format descriptor encoded in the string. 
; The descriptor has the form:  %<adr><fmt> where <adr> is the octal
; address of the number to be printed (3 may not be used since this AC
; is used to pass the string pointer).  <fmt> is one character
; specifying the conversion.  Available formats include:
;
; <fmt> = O   Compact octal
;         F   Formatted octal (fixed field width)
;         D   Decimal
;         H   Hexadecimal
;
; For example %4D would convert the contents of AC 4 to decimal and %100H
; would convert the contents of location 100 to hexadecimal.  QOTCHR
; (currently ^V, octal 26) is used as a quote character and prints any
; character following it.
;
; Entry:  C = address of ASCIZ string.  IF C is 0, nothing is typed.
; Call:   PUSHJ P,STYO

STYO:	JUMPE C,CPOPJ		; If 0, just return
	PUSH P,A		; Save working AC's
	PUSH P,B
	HRLI C,440700		; Complete C as a string pointer
STYO1:	ILDB B,C		; Get the next character
	JUMPE B,STYRET		; If the character is null, quit
	CAIN B,"%"		; Escape character
	 JRST STYCV		; Yes, go compute formatting
	CAIN B,QOTCHR		; Is it a quote character?
	 ILDB B,C		; Yes, get the next one whatever it is
	PUSHJ P,TYO		; OK, just print it
	JRST STYO1		; And do the next one

STYRET:	POP P,B			; Recover AC's
	POP P,A
	POPJ P,

; Compute requested numeric format conversion
STYCV:	SETZ A,			; Accumulate address here
STYCV0:	ILDB B,C		; Get next char
	CAIL B,"0"		; Octal char?
	CAILE B,"7"
	 JRST STYCV1		; No
	LSH A,3			; Yes, include it in the address
	ADDI A,-"0"(B)
	JRST STYCV0		; See if there are more

; At this point A = number adr, B = format char
STYCV1:	CAIN A,3		; Is the address 3?
	 JRST STYER		; Yes, print error
	CAIL A,1		; Is it 1 or 2?
	CAILE A,2
	 SKIPA			; No
	ADDI A,-2(P)		; Yes, have to get it off the stack
	MOVE A,0(A)		; OK, number now in A
	TRZ B,40		; Make sure format is upper case
	PUSHJ P,STYSK		; Go do the right format
	JRST STYO1		; Done, finish the string

STYSK:	CAIN B,"O"		; Octal conversion requested?
	 JRST OPT
	CAIN B,"F"		; Formatted octal conversion requested?
	 JRST FOPT
	CAIN B,"D"		; Decimal conversion requested?
	 JRST DPT
	CAIN B,"H"		; Hexadecimal conversion requested?
	 JRST HPT
	SUB P,[1,,1]		; Oops, not legal spec.  Reset stack
STYER:	PUSH P,B		; Save the char for now
	MOVEI B,"*"		; Print an error filler
	PUSHJ P,TYO
	PUSHJ P,TYO
	PUSHJ P,TYO
	POP P,B			; Recover the char
	JUMPE B,STYRET		; If null, return
	JRST STYO1		; Otherwise finish the string

; Compact octal conversion routine - prints an octal number as L,,R
; where no leading 0's or blanks are inserted and L is not printed if
; 0
OPT:	TLNN A,-1		; Anything in the left half?
	 JRST OPT1		; No
	PUSH P,A		; Yes, save the value
	HLRZS A			; Isolate the left half
	PUSHJ P,OPT2		; and print it
	POP P,A			; Restore the full value
	MOVEI B,","		; Separate the halves by ,,
	PUSHJ P,TYO
	PUSHJ P,TYO
OPT1:	HRRZS A			; Isolate the right half
OPT2:	IDIVI A,10		; Get a low order digit
	JUMPE A,OPT3		; If nothing left, move on
	HRLM B,0(P)		; Save this digit in LH of return PC
	PUSHJ P,OPT2		; Get the next digit recursively
	HLRZ B,0(P)		; Restore the previous digit
OPT3:	ADDI B,60		; Convert digit to char
	CAILE B,"9"
	ADDI B,"A"-"9"-1	; If high hex, form letter
	JRST TYO		; Now, go print it


; Formatted octal conversion routine - prints an octal number as L,,R
; where L is 6 characters (with leading blanks if needed) and R is
; 6 characters (with trailing blanks if needed)
FOPT:	PUSH P,A		; Save the number
	HLRZS A			; Isolate the left half
	MOVEI B,6		; Set up to count blanks needed (print
	MOVEM B,FOPTCT		; them first)
	PUSHJ P,FOPT0		; Print the left half with leading blanks
	MOVEI B,","		; Separate the halves by ,,
	PUSHJ P,TYO
	PUSHJ P,TYO
	POP P,A			; Restore the full value
	HRRZS A			; Isolate the right half
	SETZM FOPTCT		; Set up to count blanks needed (don't print them)
	PUSHJ P,FOPT0		; Print the right half
	MOVE A,FOPTCT		; Now add the blanks if needed
	ADDI A,6
	JRST FPBLK

FOPT0:	IDIVI A,10		; Get a low order digit
	SOS FOPTCT		; Decrement number of blanks
	JUMPE A,[PUSH P,B	; Nothing left, save the last digit
		 SKIPLE A,FOPTCT  ; If pos count, print blanks first...
		 PUSHJ P,FPBLK
		 POP P,B	; Recover the last digit
		 JRST OPT3]	; Go start the printing
	HRLM B,0(P)		; Save this digit in LH of return PC
	PUSHJ P,FOPT0		; Get the next digit recursively
	HLRZ B,0(P)		; Restore the previous digit
	JRST OPT3		; And form a char to print it

; Decimal conversion routine
DPT:	MOVEI B,"-"		; Is the number negative?
	SKIPGE A
	PUSHJ P,TYO		; Yes, print a minus sign
	MOVMS A			; Then form the magnitude of the number
DPT1:	IDIVI A,^D10		; Strip a low order decimal digit
	JUMPE A,OPT3		; If last one, start printing
	HRLM B,(P)		; More to go, save in LH of return PC
	PUSHJ P,DPT1		; Get more digits recursively
	HLRZ B,(P)		; Recover previous digit
	JRST OPT3		; Form char and print it


; Hexadecimal conversion routine
HPT:	MOVEI B,0		; Clear buffer AC
	ROTC A,-4		; Strip one hex digit
	ROT B,4
	JUMPE A,OPT3		; If none left, start printing
	HRLM B,(P)		; More, save this one in LH of return PC
	PUSHJ P,HPT		; Get the others recursively
	HLRZ B,(P)		; Now recover the previous digit
	JRST OPT3		; Form char and print it


; Routine to print out a number of blanks
; Entry:   A = number of blanks
; Call:    PUSHJ P,FPBLK

FPBLK:	MOVEI B," "		; Set up to print blanks
	SOJL A,CPOPJ		; If counted out, quit
	PUSHJ P,TYO		; No, print one
	JRST .-2		; And try for another
; Routine to wait for TTY output done and then to output one character.
; Line feeds are handled specially to allow enought fill characters for
; the carriage to reposition.

TYO:
IFNDEF KL,<
	PUSHJ P,TTYODN		; Wait for CTY output done
	DATAO TTY,B		; Output another character
	CAIE B,12		; Was it LF?
	POPJ P,			; No, return
	MOVNI B,CTYTMO		; Yes, set time out
TYOF0:	CONSO TTY,20		; Output busy?
	AOJL B,TYOF0		; No, wait some more
	JUMPGE B,TYOF9		; Output busy now, if we timed out, just quit
	MOVNI B,CTYFIL		; Otherwise, send some fill characters
	MOVEM B,TYOFCT
	MOVEI B,0		; Make them NULL's
TYOF1:	AOSL TYOFCT
	JRST TYOF9
	PUSHJ P,TYO		; Send a NULL
	JRST TYOF1

TYOF9:	MOVEI B,12		; All done, restore the LF to B
	POPJ P,

TYOFCT:	0
	>	; End IFNDEF KL
IFDEF KL,<
	SETZM DTEMTD
	PUSH P,B
	ANDI B,177
	MOVEI B,.DTMTO(B)
	MOVEM B,DTECMD
	CONO DTE,TO11DB
	SKIPN DTEMTD
	JRST .-1
	POP P,B
	POPJ P,
	>	; End IFDEF KL


; Routine to wait until CTY output is done

TTYODN:	CONSZ TTY,20		; Make sure CTY output is done
	JRST .-1
	POPJ P,

; Routine to fetch an input character from CTY, waiting if necessary
; Call:    PUSHJ P,TTYIW
; Return:  +1 always, character in B

TTYIW:	PUSHJ P,TTYIC		; Get input if any
	 JRST .-1		; Nothing, wait some more
	POPJ P,			; Return with char


; Routine to test for TTY input.  Input is also checked against special
; characters for RESET or DDT call
; Call:   PUSHJ P,TTYIC
; Return: +1 Nothing input
;	  +2 Success, character in B

TTYIC:
IFNDEF KL,<
	CONSO TTY,40		; TTY input busy?
	 POPJ P,		; No
	DATAI TTY,B		; Get the char
	>	; End IFNDEF KL
IFDEF KL,<
	SKIPN DTEMTI		; KL, input char?
	 POPJ P,		; No, return
	SETZM DTEMTI		; Yes, clear flag and get char
	MOVE B,DTEF11
	>	; End IFDEF KL
	ANDI B,177		; Strip only char bits
	CAIE B,RSTCHR		; Did he type the restart char?
	 JRST TTYIC0		; No
	TYPE <
^>				; Yes, let him know
	MOVEI B,RSTCHR+100
	PUSHJ P,TYO
	TYPE < - Restarting
>
	JRST @ENTLOC		; Go restart

TTYIC0:	CAIE B,DDTCHR		; Did he type the DDT char?
	 JRST CPOPJ1		; No, just return +2 with the char
	BUG (<Entering DDT, $P to continue>,CPOPJ1)

; Routine to set up SA10 base address data and to initialize
; I/O bus control commands for the SA10
; Entry:   A = disk channel
; Call:    PUSHJ P,CSET

CSET:	MOVEM A,CHAN		; Save the channel address
	LSH A,2
	ADD A,BASEA
	MOVEM A,CBASE
	ADDI A,1
	MOVEM A,CBASE+1
	ADDI A,1
	MOVEM A,CBASE+2
	MOVE A,CHAN
	DPB A,[POINT 2,STBSYC,32]	; Set busy flag]
	DPB A,[POINT 2,CLSTFC,32]	; Clear status flag
	DPB A,[POINT 2,STPIEC,32]	; Set PI enable
	DPB A,[POINT 2,STSRQC,32]	; Set status request
	DPB A,[POINT 2,RSTCHC,32]	; Reset channel
	POPJ P,0


; Routine to initialize PI system and enable clock and SA10 interrupts
; Call:    PUSHJ P,INIPIS

INIPIS:	MOVE A,[JSR UUOTRP]	; Set up for UUO traps
	MOVEM A,41
	MOVE A,[JSR DSKI]	; Set up for disk interrupts
	MOVEM A,40+2*SA0CH
	MOVE A,[JSR APRI]	; And for clock/error interrupts
	MOVEM A,40+2*APRCH
	PIRST			; Reset the PI system
	CLKENB			; Enable the clock
	MCONO SA0,@STPIEC	; Restart SA-10 interrupt enable
	POPJ P,


; Routine to initialize important control variables
; Call:    PUSHJ P,INICTL

INICTL:	SETOM ACTBFR		; Clear currently active I/O buffer
	SETZM GETSNS		; Sense data request flag
	SETZM SFTREQ		; Clear software request flag
	SETZM DOEXCP		; Clear EXCP flag
	SETZM LITES		; Clear light show
	SETZM NOPRNT		; Allow printing of sense messages
	MOVEI A,NRETRY		; Init retry counter
	MOVEM A,ERETRY
	SETOM BUGLCK		; Release the bug stuff
	POPJ P,


; Routine to initialize system hardware
; Call:    PUSHJ P,INIHDW

INIHDW:	PUSHJ P,RSTALL		; Reset the world
	MOVEI A,DCHAN		; Set up base adr and dsk chan CONO templates
	PUSHJ P,CSET
	PUSHJ P,INIPIS		; Initialize PI's (leaves them deactivated)
	POPJ P,
; General data and control variables for SATIMR
SRCDRV:	-1		; Source drive -  subchannel,,drive number
INIFLG:	0		; Timing initialization flag
			;  0 - Timer not initialized
			; -1 - Timer initialized
ENTLOC:	DDTE		; Entry dispatch
	    		;   Initial setup = DDT
	    		;   Subsequent    = TMR
TIMET:	0		; Running time of day (1/60 second ticks)
TIMEC:	0		; User definable time interval (incremented at 1/60
			; second intervals too
ADRLO:	0		; Highest used address in program

; Following is a table for tabulating input and output drive errors
ERRTAB:
IECRCT:	0		; Input correctable errors
IEUNCR:	0		; Input uncorrectable errors
IEHARD:	0		; Input hard errors
OECRCT:	0		; Output correctable errors
OEUNCR:	0		; Output uncorrectable errors
OEHARD:	0		; Output hard errors
NETYPE=.-ERRTAB

; Control variables for interrupt routines - describe current transfer
; being processed.  Transfer is on the basis of input cylinder to 
; corresponding output cylinder.  Cylinders are never mixed.

ACTBFR:	0		; Currently active buffer
ACTDRV:	0		; Currently active drive
GETSNS:	0		; Flag when acquiring drive sense data
			;  0 - no sense data being collected
			; -1 - sense data being collected
DOEXCP:	0		; Flag when executing a special channel program
			;  0 - No EXCP in progress
			; -1 - EXCP in progress
SFTREQ:	0		; Flag when processing a software interrupt request
			;  0 - No software req in progress
			; -1 - Software req in progress
EXCPGM:	0		; Pointer for executing special channel program
			;   LH - address of channel program
			;   RH - address of dispatch word for chan pgm termination
			; Dispatch word format:
			;   LH - error return address
			;   RH - success return address
INTPC:	0		; Contains the PC from which interrupted at termination
			; of EXCP operation.
ACS:	BLOCK 20	; AC storage area for interrupt routine

; Variables controlling error handling
NOPRNT:	0		; Flag controlling printing of sense data for
			; correctable errors.  All other errors are printed.
			;  0 - print sense data
			; -1 - don't print sense data
ERETRY:	0		; Current number of retries left before failure
BUFLOC:	0		; Location of buffer with error detected


; Data arrays controlling the SEEK timing

TIMSEK:	0		; Index into SKSPAN for current timing opn
SKSPAN:	^D814		; Table of SEEK spans to time
	^D700
	^D600
	^D500
	^D400
	^D300
	^D200
	^D100
	^D50
	^D25
	^D10
	^D5
	^D1
	^D0
NSPANS=.-SKSPAN		; Number of span table entries

CNTCYL:	0		; Table center cylinders for span timings
	^D400
	^D814
NCCYL=.-CNTCYL		; Number of center cylinder table entries

CYLTIM:	BLOCK NCCYL	; Storage for normalized times for a given span
			; LH - integer part
			; RH - fraction part


; Variables used in number collection routine
NONUM:	0		; Flag indicating number collected
NUMTYP:	0		; Flag for conversion type
LSTCHR:	0		; Last character typed
FOPTCT:	0		; Counter for blanks in formatted octal output

; Variables to store status and sense information
APCONI:	0		; Error APR CONI word
PICONI:	0		; Error PI CONI word
SACONI:	0		; Save area for SA-10 CONI data
SENSED:	BLOCK 6		; Data area for SENSE I/O information
STBUF:	BLOCK 4		; Save area for SA10 status words

; Variables describing SA-10 addresses
BASEA:	BASE		; Base address for SA-10 fixed data block
CHAN:	0		; Disk channel
CBASE:	BLOCK 3		; CBASE+n points to SA-10 control word n

; Pushdown list storage
PDL:	BLOCK 200	; Regular pushdown list
IPDL:	BLOCK 200	; Interrupt routine pushdown list
BPDL:	BLOCK 10	; BUG handler PDL

; BUG routine variables and storage
BUGCHK:	0		; Address at which BUG happened
BUGRET:	0		; Return address if BUGCHK continued
BUGLCK:	-1		; Lock for BUG handler
CACS:	BLOCK 20	; AC storage for BUG handler
BUGBLK:	0		; Address of BUG data block:
			;  Loc 0  Adr of BUG
			;      1  JSR BUGENT
			;      2  Adr of String
			;      3  Return adr

; Miscellaneous storage and variables
HOMERR:	BLOCK 2				; Home adr buffer for error reentry
PHADRT:	EXP 70,61,52,43,34,25,16,07	; Weird names of drives (indexed by
					; by physical number

; Indirect I/O bus instructions for macro commands (MCONI, MCONO, etc.)
DCONO:	CONO SA0,(DD)
DCONI:	CONI SA0,DD
DDATAO:	DATAO SA0,DD
DDATAI:	DATAI SA0,DD

; SA10 CONO command templates for common commands
STBSYC:	STBSY+SA0CH
CLSTFC:	CLSTF+SA0CH
STPIEC:	STPIE+SA0CH
STSRQC:	STSRQ+SA0CH
RSTCHC:	RSTCH+SA0CH
; Storage of fixed strings and string arrays used in the program

; Strings describing SA-10 types of status information

STTT:	[ASCIZ /INITIAL SELECTION/]
	[ASCIZ /ENDING/]
	[ASCIZ /ASYNC/]
	[ASCIZ /DUMMY/]

; String decoding of disk status bytes 0-2

SNSMSG:	[ASCIZ /COMMAND REJECT/]
	[ASCIZ /INTERVENTION REQ/]
	[ASCIZ /BUS OUT PAR CHK/]
	[ASCIZ /EQUIPMENT CHECK/]
	[ASCIZ /DATA CHECK/]
	[ASCIZ /OVERRUN/]
	[ASCIZ /BYTE 0, BIT 6 ??/]
	[ASCIZ /BYTE 0, BIT 7 ??/]
	[ASCIZ /PERMANENT ERROR/]
	[ASCIZ /TRACK OVERRUN/]
	[ASCIZ /CYLINDER END/]
	[ASCIZ /BYTE 1, BIT 3 ??/]
	[ASCIZ /NO RECORD FOUND/]
	[ASCIZ /FILE PROTECT/]
	[ASCIZ /WRITE INHIBIT/]
	[ASCIZ /OPN INCOMPLETE/]
	[ASCIZ /BYTE 2, BIT 0 ??/]
	[ASCIZ /CORRECTABLE/]
	[ASCIZ /BYTE 2, BIT 2 ??/]
	[ASCIZ /ENVIRONMENTAL DATA/]

; String decoding of SA10/controller status information bits

STAMSG:	[ASCIZ /SELECT ERROR/]
	[ASCIZ /BUS IN PAR ERR/]
	[ASCIZ /CONTROL ERROR/]
	[ASCIZ /BIT 5 ??/]
	[ASCIZ /LENGTH ERROR/]
	[ASCIZ /PROG INT FLAG/]
	[ASCIZ /ATTENTION/]
	[ASCIZ /STATUS MODIFIER/]
	[ASCIZ /CONTROL UNIT END/]
	[ASCIZ /BUSY/]
	[ASCIZ /CHANNEL END/]
	[ASCIZ /DEVICE END/]
	[ASCIZ /UNIT CHECK/]
	[ASCIZ /UNIT EXCEPTION/]
; Following is a channel program stub to reenter an executing program
; after an error.  It resets to the start of a track and starts
; searching for the next record to be transferred.
CPRTRY:	CW <070, RDHA, IDEV>		; Read home address
	IOW 5, HOMERR
	TIC 0		    		; Now reenter the chan pgm


; NOOP channel command template
PNOOP:	CW <052, NOOP, IDEV>
	IOW 4,0
	0


; SENSE I/O channel command template
PSENSE:	CW <050, SENSIO, IDEV>		; Channel program for SENSE I/O
	IOW 30,SENSED	      		; 24 bytes of sensed data
	0


; Channel programs to check drive access status
; READ
CKPGR:	CW <070,SEEK,IDEV>		; Read program - Seek
	IOW 6, CKADR
CKPGR0:	CW <071,SCHIDE,IDEV>		; Search ID equal
	IOW 5, CKADR
	TIC CKPGR0			; Transfer back until record found
CKPGR1:	CW <040,RDDATA,IDEV>		; Read
	IOW (RECL,RDBUF)
	0

; WRITE
CKPGW:	CW <071,SCHIDE,IDEV>		; Write pgm - Search ID equal
	IOW 5, CKADR
	TIC CKPGW			; Transfer back until record found
CKPGW0:	CW <040,WRDATA,IDEV>		; Write
	IOW (RECL,RDBUF)
	0

; SEEK/SEARCH ID EQ DATA
CKADR:	BYTE (16) 0, CHKCYL	; 00CCHHR for access check cylinder
	BYTE (16)0 (8)1		; Head 0, record 1

; Byte pointers to install drive address in chan pgms
CKPTR:	POINT 4,CKPGR,23	; Read pgm - SEEK
	POINT 4,CKPGR0,23	; Read pgm - SEARCH ID EQ
	POINT 4,CKPGR1,23	; Read pgm - READ DATA
	POINT 4,CKPGW,23	; Write pgm - SEARCH ID EQ
	POINT 4,CKPGW0,23	; Write pgm - WRITE DATA
	0			; End of list

; Macros to define data tables for buffer groups as described below
; and macros to help lay out channel programs.

DEFINE	DPNAM(PNAM,INC<1>)<
	PNAM=IQ				; Define incremented symbol
	IQ=IQ+INC
	>

; Following defines a group of pointers used in initializing the device code
; and cross-coupling in various channel programs for a group
IQ=0					; Initialize index
BFPTR:
; The following pointers are to set up the channel program header
; (SEEK's to proper cylinders)
   DPNAM(SSEEK)				; Ptr to initial SKPGM SEEK
	POINT 4,SKPGM,23
   DPNAM(SRDHA)				; Ptr to initial ROTPGM RDHA
	POINT 4,RTPGM,23

; The following pointers are to set up the channel program body
; including the SEEK operations and RDHA operations.  The address
; index for each record in the chan pgm is in A.
   DPNAM(SEKOPN)			; Ptr to SEEK commands
	POINT 4,SKPGM0(A),23
   DPNAM(RDHOPN)			; Ptr to RDHA commands
	POINT 4,RTPGM0(A),23

; The following pointers are to finish up the channel program.
; A points just past the last command in the program.
   DPNAM(SKEOL)				; Ptr to End of SEEK List
	CAIA SKPGM0(A)
   DPNAM(RTEOL)				; Ptr to End of RDHA List
	CAIA RTPGM0(A)
	0

; Buffer storage and control data.
;
; BFSTAT:    Buffer status information
;	         LH - buffer status information about what stage
;	     	       a transfer is in and errors encountered.
;	         RH - address of error handler to be called
; BFPGM:     Entry point for measurement channel programs
; BFDAT:     Addresses of search/seek data table and a byte pointer table for
;	     updating device addresses in channel programs
; 		 LH - address of seek/search data
; 		 RH - address of byte pointers to update chan pgm adrs
; BFTMO:     Time by which current I/O operation must finish  before time-out


BFSTAT:	0			; Buffer status table
BFPGM:	0			; I/O channel program entry addresses
BFDAT:	CLSSD,,BFPTR		; Search/Seek data and device field ptrs
BFTMO:	0			; Time out limit for current operation

; Following actually sets up the channel programs and seek/search data
; tables

; SEEK time measuring channel program
	IB=0
SKPGM:	CW <074, SEEK, IDEV>	; SEEK cylinder and PCI
	IOW (6,CLSSD)		; Starting cylinder/head
SKPGM0:
   REPEAT NITER,<
	IB=1-IB			; Alternate cylinder addresses
	CW <070, SEEK, IDEV>
	IOW (6,CLSSD+2*IB)
	>	; End REPEAT
	CW <052, NOOP, IDEV>	; Final NOOP to be sure Dev End
	IOW 4,0
	0


; Rotation time measuring channel program
RTPGM:	CW <074, RDHA, IDEV>	; Read Home Address and PCI
	IOW (5,HOMAD)		; Data buffer
RTPGM0:
   REPEAT NITER,<
	CW <070, RDHA, IDEV>
	IOW (5,HOMAD)
	>	; End REPEAT
	CW <052, NOOP, IDEV>	; Final NOOP to be sure Dev End
	IOW 4,0
	0


; SEEK data table
CLSSD:	0			; 00CCHHR #1
	BYTE (16) 0 (8) 1
	0			; 00CCHHR #2
	BYTE (16) 0 (8) 1
	0


; Define data space for home address data from RDHA
HOMAD:  BLOCK 2


	LIT
	VAR

; The following are declarations of TMR buffer addresses
; These follow the code for SA10E

BUFORG=14000+<1000*<<.+777>/1000>>
RDBUF=BUFORG				; Single cylinder mode buffers
RBBUF=RDBUF+CYLWDS

	END DDTG
